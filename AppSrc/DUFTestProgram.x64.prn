Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 59744485376
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set piIntFilesFileNumber to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo sErrorText
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Get RestoreIntFiles (&sErrorText) to bOK
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object oDUFStatus_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 17 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 17 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 15 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible 
74835>>>>>        Set Visible_State of oOverallProgress_tb to bVisible
74836>>>>>    End_Procedure
74837>>>>>
74837>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74840>>>>>        Boolean bVisible
74840>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74841>>>>>        Function_Return (bVisible)
74842>>>>>    End_Function
74843>>>>>
74843>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74843>>>>>    // objects defined within this instance of the status panel.
74843>>>>>
74843>>>>>    // note: all of the messages that change text should be forwarded
74843>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74843>>>>>
74843>>>>>    Procedure Set Message_Text String sText
74846>>>>>        Set Label of oMessageTxt to sText
74847>>>>>        Forward Set Message_Text to sText
74849>>>>>    End_Procedure
74850>>>>>
74850>>>>>    Function Message_Text Returns String
74853>>>>>        Function_Return (Label(oMessageTxt))
74854>>>>>    End_Function
74855>>>>>
74855>>>>>    Procedure Set Action_Text String sText
74858>>>>>        Set Label of oActionTxt to sText
74859>>>>>        Forward Set Action_Text to sText
74861>>>>>    End_Procedure
74862>>>>>
74862>>>>>    Function Action_Text Returns String
74865>>>>>        Function_Return (Label(oActionTxt))
74866>>>>>    End_Function
74867>>>>>
74867>>>>>    Procedure Set Button_Text String sText
74870>>>>>        Set Label of oStopButton to sText
74871>>>>>        Forward Set Button_Text to sText
74873>>>>>    End_Procedure
74874>>>>>
74874>>>>>    Function Button_Text Returns String
74877>>>>>        Function_Return (Label(oStopButton))
74878>>>>>    End_Function
74879>>>>>
74879>>>>>    Procedure Set Title_Text String sText
74882>>>>>        Set Label of oTitleTxt to sText
74883>>>>>        Forward Set Title_Text to sText
74885>>>>>    End_Procedure
74886>>>>>
74886>>>>>    Function Title_Text Returns String
74889>>>>>        Function_Return (Label(oTitleTxt))
74890>>>>>    End_Function
74891>>>>>
74891>>>>>    Procedure Set TableName_Text String sText
74894>>>>>        Set Label of oTableNameTxt to sText
74895>>>>>    End_Procedure
74896>>>>>
74896>>>>>    Function TableName_Text Returns String
74899>>>>>        Function_Return (Label(oTableNameTxt))
74900>>>>>    End_Function
74901>>>>>
74901>>>>>    Procedure Set License_Text String sText
74904>>>>>//        Set Label of oLicense_txt to sText
74904>>>>>    End_Procedure 
74905>>>>>    
74905>>>>>    Procedure Set piMaximum Integer iSize
74908>>>>>        Set piMaximum of ghoProgressBar to iSize
74909>>>>>    End_Procedure  
74910>>>>>    
74910>>>>>    Procedure Set piAdvanceBy Integer iCount
74913>>>>>        Set piAdvanceBy of ghoProgressBar to iCount
74914>>>>>    End_Procedure
74915>>>>>
74915>>>>>    Procedure DoAdvance
74918>>>>>        Send DoAdvance of ghoProgressBar
74919>>>>>    End_Procedure
74920>>>>>
74920>>>>>    Procedure Set piPosition Integer iPos
74923>>>>>        Set piPosition of ghoProgressBar to iPos
74924>>>>>    End_Procedure
74925>>>>>    
74925>>>>>    // gets called when status panel is activated passing whether a button
74925>>>>>    // should appear
74925>>>>>    Procedure EnableCancelButton Boolean bEnable
74928>>>>>        Boolean bVisible
74928>>>>>        Get Cancel_Button_Visible_State to bVisible
74929>>>>>        If (bEnable = False) Begin
74931>>>>>            Set Visible_State of oStopButton to bVisible
74932>>>>>        End
74932>>>>>>
74932>>>>>        Set Enabled_State of oStopButton to bEnable
74933>>>>>    End_Procedure
74934>>>>>
74934>>>>>    Procedure Reset_StatusPanel
74937>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74938>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74939>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74940>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74941>>>>>    End_Procedure
74942>>>>>
74942>>>>>//    Object oProgressBar is a cProgressBar
74942>>>>>//        Move Self to ghoProgressBar
74942>>>>>//        Set Location to 1 25
74942>>>>>//        Set Size to 9 173
74942>>>>>//        Set piMinimum        to 0
74942>>>>>//        Set piMaximum        to 2000
74942>>>>>//        Set piAdvanceBy      to 100
74942>>>>>//        Set pbSmooth to True
74942>>>>>//
74942>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74942>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74942>>>>>//        // color will show correctly.
74942>>>>>//        Procedure Page Integer iPageObject
74942>>>>>//            Handle hWin
74942>>>>>//            Forward Send Page iPageObject
74942>>>>>//            If (ghoSkinFramework <> 0) Begin
74942>>>>>//                Get Window_Handle to hWin
74942>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74942>>>>>//            End
74942>>>>>//        End_Procedure
74942>>>>>//    End_Object
74942>>>>>
74942>>>>>End_Object
74943>>>>>
74943>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74943>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74943>>>>>//
74943>>>>>Use VdfBase.pkg
74943>>>>>Use cApplication.pkg
74943>>>>>Use seq_chnl.pkg
74943>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\Lib\vwin32fh\vWin32fh.pkg)
74943>>>>>>>// This code is part of VDF GUIdance
74943>>>>>>>// Visit us @ http://www.vdf-guidance.com
74943>>>>>>>// e-Mail us @ info@vdf-guidance.com
74943>>>>>>>// VDF GUIdance is a mutual project of
74943>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74943>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74943>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74943>>>>>>>//
74943>>>>>>>//
74943>>>>>>>// *** Windows 32bit file handling wrapper class ***
74943>>>>>>>//
74943>>>>>>>
74943>>>>>>>
74943>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74943>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\Lib\vwin32fh\cvFileDialogs.pkg)
74943>>>>>>>>>//***************************************************************************
74943>>>>>>>>>//*
74943>>>>>>>>>//* Class:        cvSaveAsDialog
74943>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74943>>>>>>>>>//*
74943>>>>>>>>>//***************************************************************************
74943>>>>>>>>>
74943>>>>>>>>>Use File_dlg.pkg
74943>>>>>>>>>
74943>>>>>>>>>// *WvA: 13-01-1999 Created
74943>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74943>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74943>>>>>>>>>// file_name.
74943>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74944>>>>>>>>>
74944>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74946>>>>>>>>>        Forward Send Construct_Object iImage_Id
74948>>>>>>>>>        Set HideReadOnly_State to True
74949>>>>>>>>>    End_Procedure
74950>>>>>>>>>
74950>>>>>>>>>    Function SelectedFileName Returns String
74952>>>>>>>>>        String sFileName
74952>>>>>>>>>        Move "" to sFileName
74953>>>>>>>>>        If (Show_Dialog(Self)) Begin
74955>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74956>>>>>>>>>        End
74956>>>>>>>>>>
74956>>>>>>>>>        Function_Return sFileName
74957>>>>>>>>>    End_Function
74958>>>>>>>>>End_Class
74959>>>>>>>>>
74959>>>>>>>>>// *WvA: 13-01-1999 Created
74959>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74959>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74959>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74959>>>>>>>>>//                   file-open dialog
74959>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74961>>>>>>>>>    String sSelectedFile
74961>>>>>>>>>    Integer hoOpenFileDialog
74961>>>>>>>>>
74961>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74963>>>>>>>>>
74963>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74964>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74965>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74966>>>>>>>>>
74966>>>>>>>>>        Move Self       to hoOpenFileDialog
74967>>>>>>>>>    End_Object
74968>>>>>>>>>
74968>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74969>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74970>>>>>>>>>    Function_Return sSelectedFile
74971>>>>>>>>>End_Function
74972>>>>>>>>>
74972>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74973>>>>>>>>>
74973>>>>>>>>>    Procedure Construct_Object
74975>>>>>>>>>        Forward Send Construct_Object
74977>>>>>>>>>        Set HideReadOnly_State to True
74978>>>>>>>>>    End_Procedure
74979>>>>>>>>>
74979>>>>>>>>>    Function SelectedFileName Returns String
74981>>>>>>>>>        String sFileName
74981>>>>>>>>>        Move "" to sFileName
74982>>>>>>>>>        If (Show_Dialog(Self)) Begin
74984>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74985>>>>>>>>>        End
74985>>>>>>>>>>
74985>>>>>>>>>        Function_Return sFileName
74986>>>>>>>>>    End_Function
74987>>>>>>>>>
74987>>>>>>>>>End_Class
74988>>>>>>>>>
74988>>>>>>>>>// Added optional default filename as suggested by Nils
74988>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74990>>>>>>>>>    String sSelectedFile
74990>>>>>>>>>    Integer hoDialog
74990>>>>>>>>>
74990>>>>>>>>>    Move "" to sSelectedFile
74991>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74992>>>>>>>>>    If (hoDialog) Begin
74994>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74994>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74995>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74996>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74997>>>>>>>>>        If (Num_Arguments = 4) Begin
74999>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
75000>>>>>>>>>        End
75000>>>>>>>>>>
75000>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
75001>>>>>>>>>        Send Destroy of hoDialog
75002>>>>>>>>>    End
75002>>>>>>>>>>
75002>>>>>>>>>    Function_Return sSelectedFile
75003>>>>>>>>>End_Function
75004>>>>>>>Use Seq_chnl.pkg
75004>>>>>>>
75004>>>>>>>Use windows.pkg
75004>>>>>>>Use Dll.pkg
75004>>>>>>>
75004>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\Lib\vwin32fh\vwin32fhW.pkg)
75004>>>>>>>>>// This code is part of VDF GUIdance
75004>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
75004>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
75004>>>>>>>>>// VDF GUIdance is a mutual project of
75004>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75004>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75004>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75004>>>>>>>>>//
75004>>>>>>>>>//
75004>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
75004>>>>>>>>>// Unicode variant
75004>>>>>>>>>
75004>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\Lib\vwin32fh\vwin32fhW.h)
75004>>>>>>>>>>>//TH-Header
75004>>>>>>>>>>>//*****************************************************************************************
75004>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
75004>>>>>>>>>>>// All rights reserved.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
75004>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
75004>>>>>>>>>>>// $Authors     : Wil van Antwerpen
75004>>>>>>>>>>>// $Created     : 19.02.2004  19:25
75004>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Contents:
75004>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
75004>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
75004>>>>>>>>>>>//*****************************************************************************************
75004>>>>>>>>>>>//TH-RevisionStart
75004>>>>>>>>>>>//TH-RevisionEnd
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
75004>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define vMax_Path     For |CI260
75004>>>>>>>>>>>Define vMinChar      For |CI$80
75004>>>>>>>>>>>Define vMaxChar      For |CI$7F
75004>>>>>>>>>>>Define vMinShort     For |CI$8000
75004>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
75004>>>>>>>>>>>Define vMinLong      For |CI$80000000
75004>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
75004>>>>>>>>>>>Define vMaxByte      For |CI$FF
75004>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
75004>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// For FindFirstFile
75004>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
75004>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
75004>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
75004>>>>>>>>>>>
75004>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
75004>>>>>>>>>>>// the API-call ShellExecute is used.
75004>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
75004>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
75004>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
75004>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
75004>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
75004>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
75004>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
75004>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
75004>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
75004>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
75004>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
75004>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
75004>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
75004>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// C-Structure
75004>>>>>>>>>>>//typedef struct _browseinfo {
75004>>>>>>>>>>>//    HWND hwndOwner;
75004>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
75004>>>>>>>>>>>//    LPSTR pszDisplayName;
75004>>>>>>>>>>>//    LPCSTR lpszTitle;
75004>>>>>>>>>>>//    UINT ulFlags;
75004>>>>>>>>>>>//    BFFCALLBACK lpfn;
75004>>>>>>>>>>>//    LPARAM lParam;
75004>>>>>>>>>>>//    int iImage;
75004>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
75004>>>>>>>>>>>
75004>>>>>>>>>>>//declare C structure struct_browseinfo
75004>>>>>>>>>>>//as documented in MSDN under Windows Shell API
75004>>>>>>>>>>>Struct tvBrowseInfo
75004>>>>>>>>>>>  Handle    hWndOwner
75004>>>>>>>>>>>  Pointer   pIDLRoot
75004>>>>>>>>>>>  Pointer   pszDisplayName
75004>>>>>>>>>>>  Pointer   lpszTitle
75004>>>>>>>>>>>  DWord     ulFlags
75004>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
75004>>>>>>>>>>>  Pointer   lpfnCallback
75004>>>>>>>>>>>  LongPtr   lParam
75004>>>>>>>>>>>  DWord     iImage
75004>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
75004>>>>>>>>>>>End_Struct // tvBrowseInfo
75004>>>>>>>>>>>
75004>>>>>>>>>>>// Browsing for directory.
75004>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
75004>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
75004>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
75004>>>>>>>>>>>                                            // The callback function can set the status text by
75004>>>>>>>>>>>                                            // sending messages to the dialog box.
75004>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
75004>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
75004>>>>>>>>>>>
75004>>>>>>>>>>>// message from browser
75004>>>>>>>>>>>//Define BFFM_INITIALIZED        1
75004>>>>>>>>>>>//Define BFFM_SELCHANGED         2
75004>>>>>>>>>>>
75004>>>>>>>>>>>// messages to browser
75004>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
75004>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
75004>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75005>>>>>>>>>>>
75005>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75006>>>>>>>>>>>
75006>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>Struct tvSecurity_attributes
75007>>>>>>>>>>>  DWord   nLength
75007>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
75007>>>>>>>>>>>  Pointer lpDescriptor
75007>>>>>>>>>>>  Integer bInheritHandle
75007>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
75007>>>>>>>>>>>End_Struct // tvSecurity_attributes
75007>>>>>>>>>>>
75007>>>>>>>>>>>//nLength:
75007>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75007>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75007>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75007>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75007>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75007>>>>>>>>>>>//
75007>>>>>>>>>>>//lpSecurityDescriptor:
75007>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75007>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75007>>>>>>>>>>>// descriptor of the calling process.
75007>>>>>>>>>>>//
75007>>>>>>>>>>>//bInheritHandle:
75007>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75007>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>// BOOL CreateDirectory(
75007>>>>>>>>>>>//    LPCTSTR lpPathName,
75007>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75007>>>>>>>>>>>//   );
75007>>>>>>>>>>>//
75007>>>>>>>>>>>// lpPathName
75007>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75007>>>>>>>>>>>//  to be created.
75007>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75007>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75007>>>>>>>>>>>// lpSecurityAttributes
75007>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75007>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75007>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75007>>>>>>>>>>>// Returns:
75007>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75007>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75007>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75008>>>>>>>>>>>
75008>>>>>>>>>>>
75008>>>>>>>>>>>// lpPathName
75008>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75008>>>>>>>>>>>//  to be removed.
75008>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75008>>>>>>>>>>>// Returns:
75008>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75008>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75008>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75009>>>>>>>>>>>// executable file or a document file.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// Operation can be one of the following:
75009>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75009>>>>>>>>>>>//            The file can be an executable file or a document file.
75009>>>>>>>>>>>//            The file can be a folder to open.
75009>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75009>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75009>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75009>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// Return Values:
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75009>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75009>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// The following table lists these error values:
75009>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75009>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75009>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75009>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75009>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75009>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75009>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75009>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75009>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75009>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75009>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75009>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75009>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75009>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75009>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75010>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75010>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75010>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75010>>>>>>>>>>>
75010>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75010>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75010>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75010>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75010>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75010>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75010>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75010>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75010>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75010>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75010>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75010>>>>>>>>>>>
75010>>>>>>>>>>>Struct tvShFileOpStruct
75010>>>>>>>>>>>  Handle   hWnd
75010>>>>>>>>>>>  UInteger wFunc
75010>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
75010>>>>>>>>>>>  Pointer  pFrom
75010>>>>>>>>>>>  Pointer  pTo
75010>>>>>>>>>>>  Short    fFlags
75010>>>>>>>>>>>  Integer  fAnyOperationsAborted
75010>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
75010>>>>>>>>>>>  Pointer  hNameMappings
75010>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75010>>>>>>>>>>>End_Struct // tvShFileOpStruct
75010>>>>>>>>>>>
75010>>>>>>>>>>>// hwnd
75010>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// wFunc
75010>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75010>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75010>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75010>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75010>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// pFrom
75010>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75010>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// pTo
75010>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75010>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75010>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75010>>>>>>>>>>>//   double null-terminated.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// fAnyOperationsAborted
75010>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75010>>>>>>>>>>>//   were completed or FALSE otherwise.
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75010>>>>>>>>>>>// This can be a file or a folder.
75010>>>>>>>>>>>// With thanks to Andrew S Kaplan
75010>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75011>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75012>>>>>>>>>>>
75012>>>>>>>>>>>
75012>>>>>>>>>>>
75012>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75012>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75012>>>>>>>>>>>//   Pointer lpPathName ;
75012>>>>>>>>>>>//   Pointer lpPrefixString ;
75012>>>>>>>>>>>//   Integer uUnique ;
75012>>>>>>>>>>>//   Pointer lpTempFileName ;
75012>>>>>>>>>>>//   Returns Integer
75012>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75012>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75013>>>>>>>>>>>
75013>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75014>>>>>>>>>>>
75014>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75015>>>>>>>>>>>
75015>>>>>>>>>>>// from:
75015>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75015>>>>>>>>>>>//
75015>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75015>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75015>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75015>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75015>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75015>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75015>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75015>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75015>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75015>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75015>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75015>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75015>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75015>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75015>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75015>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75015>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75015>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75015>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75015>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75015>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75015>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75015>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75015>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75015>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75015>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75015>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75015>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75015>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75015>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75015>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75015>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75015>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75015>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75015>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75015>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75015>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75015>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75015>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75015>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75015>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75015>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75015>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75015>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75015>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75015>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75015>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75015>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75015>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75015>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75015>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75015>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75015>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75015>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75015>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75015>>>>>>>>>>>
75015>>>>>>>>>>>
75015>>>>>>>>>>>//HRESULT SHGetFolderPath(
75015>>>>>>>>>>>//    HWND hwndOwner,
75015>>>>>>>>>>>//    int nFolder,
75015>>>>>>>>>>>//    HANDLE hToken,
75015>>>>>>>>>>>//    DWORD dwFlags,
75015>>>>>>>>>>>//    LPTSTR pszPath
75015>>>>>>>>>>>//);
75015>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75015>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75015>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75015>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75015>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75015>>>>>>>>>>>//
75015>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>Struct tvWin32FindData
75016>>>>>>>>>>> Dword            dwFileAttributes
75016>>>>>>>>>>> Dword            ftCreationLowDateTime
75016>>>>>>>>>>> Dword            ftCreationHighDateTime
75016>>>>>>>>>>> dword            ftLastAccessLowDateTime
75016>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75016>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75016>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75016>>>>>>>>>>> Dword            nFileSizeHigh
75016>>>>>>>>>>> Dword            nFileSizeLow
75016>>>>>>>>>>> Dword            dwReserved0
75016>>>>>>>>>>> Dword            dwReserved1
75016>>>>>>>>>>> Short[vMax_Path] cFileName
75016>>>>>>>>>>> Short[14]        cAlternateFileName
75016>>>>>>>>>>>End_Struct
75016>>>>>>>>>>>
75016>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75016>>>>>>>>>>>// lpFileName      : address of name of file to search for
75016>>>>>>>>>>>// lpFindFileData  : address of returned information
75016>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75017>>>>>>>>>>>
75017>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75017>>>>>>>>>>>// hFindFile       : handle of search
75017>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75017>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75018>>>>>>>>>>>//  hFindFile      : file search handle
75018>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>Struct tvFileTime
75019>>>>>>>>>>>  DWord dwLowDateTime
75019>>>>>>>>>>>  DWord dwHighDateTime
75019>>>>>>>>>>>End_Struct
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>Struct tvSystemTime
75019>>>>>>>>>>>  UShort wYear
75019>>>>>>>>>>>  UShort wMonth
75019>>>>>>>>>>>  UShort wDayOfWeek
75019>>>>>>>>>>>  UShort wDay
75019>>>>>>>>>>>  UShort wHour
75019>>>>>>>>>>>  UShort wMinute
75019>>>>>>>>>>>  UShort wSecond
75019>>>>>>>>>>>  UShort wMilliSeconds
75019>>>>>>>>>>>End_Struct
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75019>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75019>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75019>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75020>>>>>>>>>>>
75020>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75020>>>>>>>>>>>// This function formats the time in a picture-string passed
75020>>>>>>>>>>>//
75020>>>>>>>>>>>// Picture      Meaning
75020>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75020>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75020>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75020>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75020>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75020>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75020>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75020>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75020>>>>>>>>>>>//    t         One character time marker string, such as A or P
75020>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75020>>>>>>>>>>>//
75020>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75020>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75020>>>>>>>>>>>
75020>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75021>>>>>>>>>>>
75021>>>>>>>>>>>
75021>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75021>>>>>>>>>>>// This function formats the date in a picture-string passed
75021>>>>>>>>>>>//
75021>>>>>>>>>>>// Picture      Meaning
75021>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75021>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75021>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75021>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75021>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75021>>>>>>>>>>>//              value associated with the specified locale.
75021>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75021>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75021>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75021>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75021>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75021>>>>>>>>>>>//              associated with the specified locale.
75021>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75021>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75021>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75021>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75021>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75021>>>>>>>>>>>//              does not have an associated era or period string.
75021>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75021>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75021>>>>>>>>>>>
75021>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75022>>>>>>>>>>>
75022>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75022>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75022>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75022>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75022>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75022>>>>>>>>>>>
75022>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75022>>>>>>>>>>>//
75022>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75022>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75022>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75022>>>>>>>>>>>
75022>>>>>>>>>>>
75022>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75023>>>>>>>>>>>
75023>>>>>>>>>>>
75023>>>>>>>>>>>// **WvA: 20-02-2004
75023>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75023>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75023>>>>>>>>>>>// incorrectly into an unsigned integer.
75023>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75023>>>>>>>>>>>// It does smell a bit fishy though
75023>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75023>>>>>>>>>>>
75023>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75023>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75023>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75023>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75023>>>>>>>>>>>
75023>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75023>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75023>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75023>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75023>>>>>>>>>>>
75023>>>>>>>>>>>
75023>>>>>>>>>>> // Courtesy Of Steve Walter,
75023>>>>>>>>>>> // USA Software, Inc
75023>>>>>>>>>>> // Format a disk
75023>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75023>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75024>>>>>>>>>>>
75024>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75024>>>>>>>>>>>
75024>>>>>>>>>>>// SHCreateDirectoryEx
75024>>>>>>>>>>>
75024>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75024>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75024>>>>>>>>>>>//
75024>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75024>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75024>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75024>>>>>>>>>>>//
75024>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75024>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75024>>>>>>>>>>>//        ERROR_CANCELLED.
75024>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75024>>>>>>>>>>>
75024>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75024>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75024>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75024>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75024>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75024>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75024>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75024>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75024>>>>>>>>>>>
75024>>>>>>>>>>>//        int SHCreateDirectoryEx(
75024>>>>>>>>>>>//            HWND hwnd,
75024>>>>>>>>>>>//            LPCTSTR pszPath,
75024>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75024>>>>>>>>>>>//        );
75024>>>>>>>>>>>
75024>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75025>>>>>>>>>>>
75025>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75026>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75026>>>>>>>>>// This also works with UNC path encoding and wildcards
75026>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75028>>>>>>>>>    Boolean bFolderExists
75028>>>>>>>>>    Boolean bStop
75028>>>>>>>>>    String  sFolder sTmp
75028>>>>>>>>>    Integer iCh
75028>>>>>>>>>
75028>>>>>>>>>    If (sFolderName = "") Begin
75030>>>>>>>>>        Function_Return False
75031>>>>>>>>>    End
75031>>>>>>>>>>
75031>>>>>>>>>
75031>>>>>>>>>    Move True  to bFolderExists
75032>>>>>>>>>    Move False to bStop
75033>>>>>>>>>    Move "dir:" to sFolder
75034>>>>>>>>>    Append sFolder sFolderName
75035>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75036>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75038>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75039>>>>>>>>>>
75039>>>>>>>>>        Function_Return False
75040>>>>>>>>>    End
75040>>>>>>>>>>
75040>>>>>>>>>    Direct_Input channel iCh sFolder
75042>>>>>>>>>    Repeat
75042>>>>>>>>>>
75042>>>>>>>>>        Readln channel iCh sTmp
75044>>>>>>>>>        Move (SeqEof) to bStop
75045>>>>>>>>>        If (Trim(sTmp)="") Begin
75047>>>>>>>>>            Move False to bFolderExists
75048>>>>>>>>>        End
75048>>>>>>>>>>
75048>>>>>>>>>        Else Begin
75049>>>>>>>>>            Move True to bFolderExists
75050>>>>>>>>>            Move True to bStop
75051>>>>>>>>>        End
75051>>>>>>>>>>
75051>>>>>>>>>    Until (bStop)
75053>>>>>>>>>    Close_Input channel iCh
75055>>>>>>>>>    Send Seq_Release_Channel iCh
75056>>>>>>>>>    Function_Return bFolderExists
75057>>>>>>>>>End_Function
75058>>>>>>>>>
75058>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75058>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75060>>>>>>>>>    String  sPath
75060>>>>>>>>>    WString sFolder sTitle
75060>>>>>>>>>    Pointer lpItemIdList
75060>>>>>>>>>    Integer iFolderSelected iRetval
75060>>>>>>>>>    tvBrowseInfo BrowseInfo
75060>>>>>>>>>    tvBrowseInfo BrowseInfo
75060>>>>>>>>>
75060>>>>>>>>>    Move "" to sPath
75061>>>>>>>>>    If (sDialogTitle<>"") Begin
75063>>>>>>>>>        Move sDialogTitle to sTitle
75064>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75064>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75064>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75064>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75064>>>>>>>>>        // selected it will always be valid.
75064>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75065>>>>>>>>>    End
75065>>>>>>>>>>
75065>>>>>>>>>
75065>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75066>>>>>>>>>
75066>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75066>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75066>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75067>>>>>>>>>
75067>>>>>>>>>    // null 128 chars into var (make space)
75067>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75068>>>>>>>>>
75068>>>>>>>>>    // select folder
75068>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75069>>>>>>>>>    // get selected folder name
75069>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75070>>>>>>>>>
75070>>>>>>>>>    // release memory resources that are used by the ItemIdList
75070>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75071>>>>>>>>>
75071>>>>>>>>>    If (iFolderSelected<>0) Begin
75073>>>>>>>>>        Move (CString(sFolder)) to sPath
75074>>>>>>>>>    End
75074>>>>>>>>>>
75074>>>>>>>>>    Function_Return  sPath
75075>>>>>>>>>End_Function
75076>>>>>>>>>
75076>>>>>>>>>// returns 0 if the folder is created.
75076>>>>>>>>>//         1 if the API-call returned an error.
75076>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75078>>>>>>>>>    Integer  iRetval bFolderCreated
75078>>>>>>>>>    WString  sFolder
75078>>>>>>>>>    tvSecurity_attributes SA
75078>>>>>>>>>    tvSecurity_attributes SA
75078>>>>>>>>>
75078>>>>>>>>>    Move False to bFolderCreated
75079>>>>>>>>>    If (sNewFolder <> "") Begin
75081>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75082>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75083>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75084>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75085>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75086>>>>>>>>>    End
75086>>>>>>>>>>
75086>>>>>>>>>
75086>>>>>>>>>    If (bFolderCreated=false) Begin
75088>>>>>>>>>        Move 1 to iRetVal
75089>>>>>>>>>    End
75089>>>>>>>>>>
75089>>>>>>>>>    Function_Return iRetVal
75090>>>>>>>>>End_Function
75091>>>>>>>>>
75091>>>>>>>>>// **WvA: 03-02-2002 Function created.
75091>>>>>>>>>// With this function one can remove a directory.
75091>>>>>>>>>// returns 0 if the folder is removed.
75091>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75091>>>>>>>>>//         2 if the folder did not exist
75091>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75091>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75093>>>>>>>>>    Boolean bRemoved
75093>>>>>>>>>    WString sPath
75093>>>>>>>>>    Integer iRetval
75093>>>>>>>>>
75093>>>>>>>>>    Move 0     to iRetVal
75094>>>>>>>>>    Move False to bRemoved
75095>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75096>>>>>>>>>    If (sFolder="") Begin
75098>>>>>>>>>        Move 3 to iRetVal
75099>>>>>>>>>    End
75099>>>>>>>>>>
75099>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75101>>>>>>>>>        Move 2 to iRetVal
75102>>>>>>>>>    End
75102>>>>>>>>>>
75102>>>>>>>>>    If (iRetVal=0) Begin
75104>>>>>>>>>        // null MAX_PATH chars into var (make space)
75104>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75105>>>>>>>>>        //
75105>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75106>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75107>>>>>>>>>    End
75107>>>>>>>>>>
75107>>>>>>>>>
75107>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75109>>>>>>>>>        Move 1 to iRetVal
75110>>>>>>>>>    End
75110>>>>>>>>>>
75110>>>>>>>>>    Function_Return iRetVal
75111>>>>>>>>>End_Function
75112>>>>>>>>>
75112>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75112>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75112>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75112>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75114>>>>>>>>>    Handle  hInstance hWnd
75114>>>>>>>>>    // remove any leading/trailing spaces in the string
75114>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75115>>>>>>>>>    Move (Trim(sPath))     to sPath
75116>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75116>>>>>>>>>    Append sOperation   (Character(0))
75117>>>>>>>>>    Append sDocument    (Character(0))
75118>>>>>>>>>    Append sParameters  (Character(0))
75119>>>>>>>>>    Append sPath        (Character(0))
75120>>>>>>>>>
75120>>>>>>>>>    Get Window_Handle to hWnd
75121>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75122>>>>>>>>>    If (hInstance <= 32) Begin
75124>>>>>>>>>        Send vDDE_Error_Handler hInstance
75125>>>>>>>>>    End
75125>>>>>>>>>>
75125>>>>>>>>>End_Procedure
75126>>>>>>>>>
75126>>>>>>>>>Class cShellFileOperations is a Array
75127>>>>>>>>>
75127>>>>>>>>>    Procedure Construct_Object
75129>>>>>>>>>        Forward Send Construct_Object
75131>>>>>>>>>        Property Integer piDeleteFlags        0
75132>>>>>>>>>        Property Integer piCopyFlags          0
75133>>>>>>>>>        Property Integer piMoveFlags          0
75134>>>>>>>>>        Property Integer piRenameFlags        0
75135>>>>>>>>>
75135>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75136>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75137>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75138>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75139>>>>>>>>>    End_Procedure
75140>>>>>>>>>
75140>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75140>>>>>>>>>    // files supplied.
75140>>>>>>>>>    //
75140>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75142>>>>>>>>>        Integer  iRetVal
75142>>>>>>>>>        Integer  iUserAbort
75142>>>>>>>>>        WString  wsSource wsDestination
75142>>>>>>>>>        tvShFileOpStruct FOS
75142>>>>>>>>>        tvShFileOpStruct FOS
75142>>>>>>>>>
75142>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75143>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75144>>>>>>>>>
75144>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75146>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75147>>>>>>>>>        End
75147>>>>>>>>>>
75147>>>>>>>>>
75147>>>>>>>>>        Move eOperation            to FOS.wFunc
75148>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75149>>>>>>>>>        Move iFlags                to FOS.fFlags
75150>>>>>>>>>
75150>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75151>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75152>>>>>>>>>        If (iUserAbort <> 0) Begin
75154>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75155>>>>>>>>>        End
75155>>>>>>>>>>
75155>>>>>>>>>        Function_Return (iRetVal)
75156>>>>>>>>>    End_Function
75157>>>>>>>>>
75157>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75159>>>>>>>>>        Integer  iRetVal
75159>>>>>>>>>        Integer  iFlags
75159>>>>>>>>>
75159>>>>>>>>>        Get piDeleteFlags to iFlags
75160>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75161>>>>>>>>>        Function_Return iRetVal
75162>>>>>>>>>    End_Function
75163>>>>>>>>>
75163>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75165>>>>>>>>>        Integer  iRetVal
75165>>>>>>>>>        Integer  iFlags
75165>>>>>>>>>
75165>>>>>>>>>        Get piCopyFlags to iFlags
75166>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75167>>>>>>>>>        Function_Return iRetVal
75168>>>>>>>>>    End_Function
75169>>>>>>>>>
75169>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75171>>>>>>>>>        Integer  iRetVal
75171>>>>>>>>>        Integer  iFlags
75171>>>>>>>>>
75171>>>>>>>>>        Get piMoveFlags to iFlags
75172>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75173>>>>>>>>>        Function_Return iRetVal
75174>>>>>>>>>    End_Function
75175>>>>>>>>>
75175>>>>>>>>>    // Rename a file or folder
75175>>>>>>>>>    // Returns a nonzero value if the operation failed.
75175>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75177>>>>>>>>>        Integer  iRetVal
75177>>>>>>>>>        Integer  iFlags
75177>>>>>>>>>
75177>>>>>>>>>        Get piRenameFlags to iFlags
75178>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75179>>>>>>>>>        Function_Return iRetVal
75180>>>>>>>>>    End_Function
75181>>>>>>>>>
75181>>>>>>>>>
75181>>>>>>>>>    //Example:
75181>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75181>>>>>>>>>    //                                          mode.
75181>>>>>>>>>
75181>>>>>>>>>End_Class
75182>>>>>>>>>
75182>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75184>>>>>>>>>End_Object
75185>>>>>>>>>
75185>>>>>>>>>// Restore to the old way of working with the shell file operations.
75185>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75185>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75185>>>>>>>>>Procedure vWin32fhCompatibilityMode
75187>>>>>>>>>    Integer hoSFO
75187>>>>>>>>>    Integer iFlags
75187>>>>>>>>>
75187>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75188>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75189>>>>>>>>>
75189>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75190>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75191>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75192>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75193>>>>>>>>>End_Procedure
75194>>>>>>>>>
75194>>>>>>>>>// Delete a file or folder
75194>>>>>>>>>// Returns a nonzero value if the operation failed.
75194>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75196>>>>>>>>>    Integer  iRetVal
75196>>>>>>>>>
75196>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75197>>>>>>>>>    Function_Return iRetVal
75198>>>>>>>>>End_Function
75199>>>>>>>>>
75199>>>>>>>>>// Copy a file or folder
75199>>>>>>>>>// Returns a nonzero value if the operation failed.
75199>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75201>>>>>>>>>    Integer  iRetVal
75201>>>>>>>>>
75201>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75202>>>>>>>>>    Function_Return iRetVal
75203>>>>>>>>>End_Function
75204>>>>>>>>>
75204>>>>>>>>>// Move a file or folder
75204>>>>>>>>>// Returns a nonzero value if the operation failed.
75204>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75206>>>>>>>>>    Integer  iRetVal
75206>>>>>>>>>
75206>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75207>>>>>>>>>    Function_Return iRetVal
75208>>>>>>>>>End_Function
75209>>>>>>>>>
75209>>>>>>>>>// Rename a file or folder
75209>>>>>>>>>// Returns a nonzero value if the operation failed.
75209>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75211>>>>>>>>>    Integer  iRetVal
75211>>>>>>>>>
75211>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75212>>>>>>>>>    Function_Return iRetVal
75213>>>>>>>>>End_Function
75214>>>>>>>>>
75214>>>>>>>>>Function vGetWindowsDirectory Returns String
75216>>>>>>>>>    WString wDirectory
75216>>>>>>>>>    Integer iRetVal
75216>>>>>>>>>
75216>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75217>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75218>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75220>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75221>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75222>>>>>>>>>    End
75222>>>>>>>>>>
75222>>>>>>>>>    Function_Return (CString(wDirectory))
75223>>>>>>>>>End_Function
75224>>>>>>>>>
75224>>>>>>>>>Function vGetTempPath Returns String
75226>>>>>>>>>    Integer iRetVal
75226>>>>>>>>>    WString wTempPath
75226>>>>>>>>>
75226>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75227>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75228>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75230>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75231>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75232>>>>>>>>>    End
75232>>>>>>>>>>
75232>>>>>>>>>    Function_Return (CString(wTempPath))
75233>>>>>>>>>End_Function
75234>>>>>>>>>
75234>>>>>>>>>// Courtesy of Marco Kuipers
75234>>>>>>>>>Function vMakeTempFile Returns String
75236>>>>>>>>>    Integer iRetval
75236>>>>>>>>>    String  sTempPath
75236>>>>>>>>>    String  sTempFileName
75236>>>>>>>>>    String  sPrefixString
75236>>>>>>>>>    WString wsTempFileName
75236>>>>>>>>>
75236>>>>>>>>>    Get vGetTempPath to sTempPath
75237>>>>>>>>>    If (sTempPath = "") Begin
75239>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75240>>>>>>>>>        If (sTempPath<>"") Begin
75242>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75243>>>>>>>>>        End
75243>>>>>>>>>>
75243>>>>>>>>>    End
75243>>>>>>>>>>
75243>>>>>>>>>
75243>>>>>>>>>    If (sTempPath = "") Begin
75245>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75245>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75245>>>>>>>>>        Get_Current_Directory to sTempPath
75246>>>>>>>>>    End
75246>>>>>>>>>>
75246>>>>>>>>>
75246>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75247>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75249>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75250>>>>>>>>>>
75250>>>>>>>>>    End
75250>>>>>>>>>>
75250>>>>>>>>>
75250>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75251>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75252>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75253>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75255>>>>>>>>>    //Get ShowLastError to iRetval
75255>>>>>>>>>        Move "" to sTempFileName
75256>>>>>>>>>    End
75256>>>>>>>>>>
75256>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75257>>>>>>>>>    Function_Return sTempFileName
75258>>>>>>>>>End_Function
75259>>>>>>>>>
75259>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75259>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75259>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75259>>>>>>>>>// does not take care of that.
75259>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75261>>>>>>>>>    Integer iRetVal
75261>>>>>>>>>    String  sTempFileName
75261>>>>>>>>>    WString wTempFileName
75261>>>>>>>>>
75261>>>>>>>>>    Move (sPath+Character(0))   to sPath
75262>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75263>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75264>>>>>>>>>
75264>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75265>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75266>>>>>>>>>    Function_Return sTempFileName
75267>>>>>>>>>End_Function
75268>>>>>>>>>
75268>>>>>>>>>//
75268>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75268>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75268>>>>>>>>>//
75268>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75270>>>>>>>>>    Integer iVoid
75270>>>>>>>>>    Handle  hWnd
75270>>>>>>>>>    String  sFolder
75270>>>>>>>>>    WString wFolder
75270>>>>>>>>>
75270>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75271>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75272>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75273>>>>>>>>>    Move (CString(wFolder)) to sFolder
75274>>>>>>>>>    Function_Return sFolder
75275>>>>>>>>>End_Function
75276>>>>>>>>>
75276>>>>>>>>>// Courtesy Of Vincent Oorsprong
75276>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75278>>>>>>>>>    String  sFileDateTime
75278>>>>>>>>>    WString wFormattedTime wFormattedDate
75278>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75278>>>>>>>>>    tvFileTime   FileTime
75278>>>>>>>>>    tvFileTime   FileTime
75278>>>>>>>>>    tvSystemTime SystemTime
75278>>>>>>>>>    tvSystemTime SystemTime
75278>>>>>>>>>
75278>>>>>>>>>    Move "" to sFileDateTime
75279>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75280>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75281>>>>>>>>>
75281>>>>>>>>>    Move 0 to SystemTime.wYear
75282>>>>>>>>>
75282>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75283>>>>>>>>>    If (iSuccess = 1) Begin
75285>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75286>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75287>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75288>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75289>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75290>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75291>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75292>>>>>>>>>    End
75292>>>>>>>>>>
75292>>>>>>>>>    Function_Return sFileDateTime
75293>>>>>>>>>End_Function
75294>>>>>>>>>
75294>>>>>>>>>// **WvA:
75294>>>>>>>>>// A windows replacement for the standard function FileExists.
75294>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75294>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75294>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75294>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75294>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75296>>>>>>>>>    String  sDirSep
75296>>>>>>>>>    Handle  hFindFile
75296>>>>>>>>>    Integer iVoid
75296>>>>>>>>>    tvWin32FindData FindData
75296>>>>>>>>>    tvWin32FindData FindData
75296>>>>>>>>>
75296>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75297>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75298>>>>>>>>>
75298>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75300>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75300>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75301>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75305>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75306>>>>>>>>>        Loop
75307>>>>>>>>>>
75307>>>>>>>>>
75307>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75308>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75309>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75310>>>>>>>>>    End
75310>>>>>>>>>>
75310>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75311>>>>>>>>>End_Function
75312>>>>>>>>>
75312>>>>>>>>>
75312>>>>>>>>>//
75312>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75312>>>>>>>>>// Returns -1 if folder doesn't exist.
75312>>>>>>>>>// The files "." and ".." are not counted.
75312>>>>>>>>>//
75312>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75314>>>>>>>>>    Boolean bFound
75314>>>>>>>>>    Handle  hFindFile
75314>>>>>>>>>    Integer iCount  iVoid
75314>>>>>>>>>    Integer iSuccess
75314>>>>>>>>>    String  sFileName
75314>>>>>>>>>    tvWin32FindData FindData
75314>>>>>>>>>    tvWin32FindData FindData
75314>>>>>>>>>
75314>>>>>>>>>    Move -1 to iCount
75315>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75316>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75317>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75318>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75319>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75320>>>>>>>>>    If (bFound) Begin
75322>>>>>>>>>        Move 0 to iCount
75323>>>>>>>>>    End
75323>>>>>>>>>>
75323>>>>>>>>>    While (bFound)
75327>>>>>>>>>        Increment iCount
75328>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75329>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75331>>>>>>>>>            Decrement iCount
75332>>>>>>>>>        End
75332>>>>>>>>>>
75332>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75333>>>>>>>>>        Move (iSuccess<>0) to bFound
75334>>>>>>>>>    Loop
75335>>>>>>>>>>
75335>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75336>>>>>>>>>    Function_Return iCount
75337>>>>>>>>>End_Function
75338>>>>>>>>>
75338>>>>>>>>>// Create the folder, including intermediate directories.
75338>>>>>>>>>// Don't panic if the folder already exists.
75338>>>>>>>>>// Michael Mullan June 2009.
75338>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75340>>>>>>>>>    String  sFolder
75340>>>>>>>>>    Integer iRetval iFolderCreated
75340>>>>>>>>>    tvSecurity_attributes SA
75340>>>>>>>>>    tvSecurity_attributes SA
75340>>>>>>>>>
75340>>>>>>>>>    Move 0 to iFolderCreated
75341>>>>>>>>>
75341>>>>>>>>>    // null MAX_PATH chars into var (make space)
75341>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75342>>>>>>>>>    If (sNewFolder <> "") Begin
75344>>>>>>>>>
75344>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75345>>>>>>>>>        Move  0  to SA.lpDescriptor
75346>>>>>>>>>        Move  1  to SA.bInheritHandle
75347>>>>>>>>>
75347>>>>>>>>>        //
75347>>>>>>>>>        Move (sNewFolder+"") to sFolder
75348>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75349>>>>>>>>>    End
75349>>>>>>>>>>
75349>>>>>>>>>
75349>>>>>>>>>    If (iFolderCreated <> 0) Begin
75351>>>>>>>>>        Move 1 to iRetVal
75352>>>>>>>>>        Case Begin
75352>>>>>>>>>            Case (iFolderCreated = 161)
75354>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75355>>>>>>>>>>
75355>>>>>>>>>                Case Break
75356>>>>>>>>>            Case (iFolderCreated = 206)
75359>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75360>>>>>>>>>>
75360>>>>>>>>>                Case Break
75361>>>>>>>>>            Case (iFolderCreated = 3)
75364>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75365>>>>>>>>>>
75365>>>>>>>>>                Case Break
75366>>>>>>>>>            Case (iFolderCreated = 80)
75369>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75370>>>>>>>>>                Case Break
75371>>>>>>>>>            Case (iFolderCreated = 183)
75374>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75375>>>>>>>>>                Case Break
75376>>>>>>>>>            Case (iFolderCreated = 1223)
75379>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75380>>>>>>>>>>
75380>>>>>>>>>                Case Break
75381>>>>>>>>>            Case Else
75381>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75382>>>>>>>>>>
75382>>>>>>>>>        Case End
75382>>>>>>>>>    End
75382>>>>>>>>>>
75382>>>>>>>>>    Function_Return iRetVal
75383>>>>>>>>>End_Function
75384>>>>>>>>>
75384>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75386>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75386>>>>>>>>>    Integer iFileSize iVoid
75386>>>>>>>>>    Handle  hFindFile
75386>>>>>>>>>    tvWin32FindData FindData
75386>>>>>>>>>    tvWin32FindData FindData
75386>>>>>>>>>
75386>>>>>>>>>    Move (sFileName+"") to sFileName
75387>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75388>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75389>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75391>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75392>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75393>>>>>>>>>    End
75393>>>>>>>>>>
75393>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75394>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75395>>>>>>>>>
75395>>>>>>>>>    Function_Return iFileSize
75396>>>>>>>>>End_Function
75397>>>>>>>>>
75397>>>>>>>>>//
75397>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75397>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75397>>>>>>>>>//
75397>>>>>>>>>//=============================================================================
75397>>>>>>>>>// Verifies that a path is a valid directory.
75397>>>>>>>>>//
75397>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75397>>>>>>>>>//
75397>>>>>>>>>// Parameters:
75397>>>>>>>>>//      sPath - Address of the path to verify.
75397>>>>>>>>>//=============================================================================
75397>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75399>>>>>>>>>    Integer iResult
75399>>>>>>>>>    Boolean bRetVal
75399>>>>>>>>>
75399>>>>>>>>>    Move false to bRetVal
75400>>>>>>>>>    Move (sPath - Character (0)) to sPath
75401>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75402>>>>>>>>>    If (iResult<>0) Begin
75404>>>>>>>>>        Move True to bRetVal
75405>>>>>>>>>    End
75405>>>>>>>>>>
75405>>>>>>>>>
75405>>>>>>>>>    Function_Return bRetVal
75406>>>>>>>>>End_Function
75407>>>>>>>
75407>>>>>>>//
75407>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75407>>>>>>>// If sStopChar has no occurences in the string an empty string is
75407>>>>>>>// returned.
75407>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75409>>>>>>>    String  sRetVal
75409>>>>>>>    String  sChar
75409>>>>>>>    Integer iLength
75409>>>>>>>    Integer iPos
75409>>>>>>>    Boolean bStopChar
75409>>>>>>>    Move "" to sRetval
75410>>>>>>>    Move (Length(sFrom)) to iLength
75411>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75413>>>>>>>        Move iLength   to iPos
75414>>>>>>>        Move (False)   to bStopChar
75415>>>>>>>        While Not bStopChar
75419>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75420>>>>>>>            Decrement iPos
75421>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75423>>>>>>>                Move (True) to bStopChar
75424>>>>>>>            End
75424>>>>>>>>
75424>>>>>>>            Else Begin
75425>>>>>>>                Move (sChar+sRetVal) to sRetVal
75426>>>>>>>            End
75426>>>>>>>>
75426>>>>>>>        Loop
75427>>>>>>>>
75427>>>>>>>    End
75427>>>>>>>>
75427>>>>>>>    Function_Return sRetVal
75428>>>>>>>End_Function
75429>>>>>>>
75429>>>>>>>// Pre:  sFileName contains the complete path of the file.
75429>>>>>>>// Post: returns the complete path of the file.
75429>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75429>>>>>>>Function ParseFolderName Global String sFileName Returns String
75431>>>>>>>    String sFile
75431>>>>>>>    String sFolderName
75431>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75431>>>>>>>
75431>>>>>>>    Move "" to sFolderName
75432>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75433>>>>>>>    If sDirSep In sFileName Begin
75435>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75436>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75437>>>>>>>    End
75437>>>>>>>>
75437>>>>>>>    Else If ":" In sFileName Begin
75440>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75441>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75442>>>>>>>    End
75442>>>>>>>>
75442>>>>>>>    Function_Return sFolderName
75443>>>>>>>End_Function
75444>>>>>>>
75444>>>>>>>// Pre:  sFileName contains the complete path of the file.
75444>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75444>>>>>>>Function ParseFileName Global String sFileName Returns String
75446>>>>>>>    String sFolderName
75446>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75446>>>>>>>
75446>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75447>>>>>>>    Get ParseFolderName sFileName to sFolderName
75448>>>>>>>    If (sFolderName <> "") Begin
75450>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75451>>>>>>>    End
75451>>>>>>>>
75451>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75452>>>>>>>    Function_Return sFilename
75453>>>>>>>End_Function
75454>>>>>>>
75454>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75454>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75454>>>>>>>//       return "bak" as the extension and not "gif"
75454>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75454>>>>>>>//       such as "html" or "java"
75454>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75456>>>>>>>    String  sFileExtension
75456>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75457>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75458>>>>>>>    Function_Return sFileExtension
75459>>>>>>>End_Function
75460>>>>>>>
75460>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75460>>>>>>>
75460>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75462>>>>>>>    String sMessage
75462>>>>>>>    Case Begin
75462>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75464>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75465>>>>>>>            Case Break
75466>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75469>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75470>>>>>>>            Case Break
75471>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75474>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75475>>>>>>>            Case Break
75476>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75479>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75480>>>>>>>            Case Break
75481>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75484>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75485>>>>>>>            Case Break
75486>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75489>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75490>>>>>>>            Case Break
75491>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75494>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75495>>>>>>>            Case Break
75496>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75499>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75500>>>>>>>            Case Break
75501>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75504>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75505>>>>>>>            Case Break
75506>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75509>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75510>>>>>>>            Case Break
75511>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75514>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75515>>>>>>>            Case Break
75516>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75519>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75520>>>>>>>            Case Break
75521>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75524>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75525>>>>>>>            Case Break
75526>>>>>>>        Case Else
75526>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75527>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75528>>>>>>>            Case Break
75529>>>>>>>    Case End
75529>>>>>>>    Function_Return sMessage
75530>>>>>>>End_Function
75531>>>>>>>
75531>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75533>>>>>>>    String sMessage
75533>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75534>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75535>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75536>>>>>>>End_Procedure
75537>>>>>>>
75537>>>>>>>
75537>>>>>>>// This function informs the user that he entered a yet unknown folder and
75537>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75537>>>>>>>// Choice: "Yes" - this creates the folder
75537>>>>>>>//                 if successful, the function returns false
75537>>>>>>>//                 else it will be true.
75537>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75537>>>>>>>//                 For example: to stop a save
75537>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75537>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75537>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75539>>>>>>>    Integer bIsNotValid
75539>>>>>>>    Integer iUsers_Choice
75539>>>>>>>    String  sMessage
75539>>>>>>>
75539>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75541>>>>>>>        Move "The folder '" to sMessage
75542>>>>>>>        Append sMessage sFolderName
75543>>>>>>>        Append sMessage "' does not yet exist,\n"
75544>>>>>>>        Append sMessage "Do you want to create it now?"
75545>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75546>>>>>>>        Case Begin
75546>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75548>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75549>>>>>>>                If bIsNotValid Begin
75551>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75552>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75554>>>>>>>                    Send Info_Box sMessage "Info"
75555>>>>>>>                End
75555>>>>>>>>
75555>>>>>>>                Case Break
75556>>>>>>>            Case (iUsers_Choice = MBR_No)
75559>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75560>>>>>>>                Case Break
75561>>>>>>>        Case End
75561>>>>>>>    End
75561>>>>>>>>
75561>>>>>>>    Function_Return bIsNotValid
75562>>>>>>>End_Function
75563>>>>>>>
75563>>>>>>>// **WvA
75563>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75563>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75563>>>>>>>// The folder may contain a drive letter or UNC encoding.
75563>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75565>>>>>>>    String sDirSep
75565>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75566>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75567>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75569>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75570>>>>>>>    End
75570>>>>>>>>
75570>>>>>>>    Function_Return sFolderName
75571>>>>>>>End_Function
75572>>>>>>>
75572>>>>>>>//
75572>>>>>>>// Gets the parent path of the currently supplied path
75572>>>>>>>// Returns "" when we are at the root folder.
75572>>>>>>>//
75572>>>>>>>Function vParentPath Global String sPath Returns String
75574>>>>>>>    String sStrip sDirSep
75574>>>>>>>
75574>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75575>>>>>>>    Move (Trim(sPath)) to sPath
75576>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75578>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75579>>>>>>>    End
75579>>>>>>>>
75579>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75581>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75582>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75583>>>>>>>    End
75583>>>>>>>>
75583>>>>>>>    Else Begin
75584>>>>>>>        Move "" to sPath
75585>>>>>>>    End
75585>>>>>>>>
75585>>>>>>>    Function_Return sPath
75586>>>>>>>End_Function
75587>>>>>Use DUFLanguageConstants.inc
75587>>>>>
75587>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75587>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75587>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75587>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75587>>>>>
75587>>>>>Struct tDUFIntFile
75587>>>>>    Integer iID
75587>>>>>    String sIntFileName
75587>>>>>    String sIntLineText
75587>>>>>End_Struct
75587>>>>>
75587>>>>>Struct tDbVersionInfo
75587>>>>>    Number nVersionNumber
75587>>>>>    Handle hObject
75587>>>>>End_Struct
75587>>>>>
75587>>>>>Struct tDbUpdateError
75587>>>>>    Number nUpdateVersion
75587>>>>>    Integer iError
75587>>>>>    String  sOrgErrorText
75587>>>>>    String  sErrorText
75587>>>>>    Integer iErrorLine
75587>>>>>    Boolean bError  
75587>>>>>    Handle  hTable 
75587>>>>>    String  sTableRootName
75587>>>>>    Integer iField
75587>>>>>    Boolean bShortFormat
75587>>>>>End_Struct
75587>>>>>
75587>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75587>>>>>//  DF_FILE_IS_MASTER if master
75587>>>>>//  DF_FILE_IS_ALIAS if alias
75587>>>>>Struct tDbUpdateHandlerMasterAlias
75587>>>>>    Handle hTable
75587>>>>>    Integer iMode
75587>>>>>End_Struct
75587>>>>>
75587>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75587>>>>>Enumeration_List
75587>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75587>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75587>>>>>End_Enumeration_List
75587>>>>>
75587>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75587>>>>>
75587>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75587>>>>>// communicate with the object from anywhere in a program.
75587>>>>>    Global_Variable Handle ghoDbUpdateHandler
75587>>>>>    Move 0 to ghoDbUpdateHandler
75588>>>>>
75588>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75588>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75588>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75588>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75588>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75588>>>>>//    Declare_Datafile DbVersion
75588>>>>>//#ENDIF
75588>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75588>>>>>//****************************************************************************
75588>>>>>// $Module type: Class
75588>>>>>// $Module name: cDbUpdateLogFile
75588>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75588>>>>>// Web-site    : http://www.rdctools.com
75588>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75588>>>>>//
75588>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75588>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75588>>>>>//               that this class is to change; each developer can decide if the errors instead
75588>>>>>//               should be saved to a database table, or something entirely different.
75588>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75588>>>>>//
75588>>>>>// $Rev History:
75588>>>>>//    2016-10-05  Module header created
75588>>>>>//****************************************************************************
75588>>>>>Use UI
75588>>>>>Use vWin32fh.pkg
75588>>>>>
75588>>>>>
75588>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75588>>>>>
75588>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75588>>>>>
75588>>>>>Class cDbUpdateLogFile is a cObject
75589>>>>>
75589>>>>>    Procedure Construct_Object
75591>>>>>        Forward Send Construct_Object
75593>>>>>
75593>>>>>        // Error handling:
75593>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75594>>>>>        Property Integer piChannel -1
75595>>>>>
75595>>>>>        // This property is set by the cDbUpdateHandler object,
75595>>>>>        // when the update process starts.
75595>>>>>        Property DateTime pdtUpdateStart
75596>>>>>
75596>>>>>        // Gets set to False if the log contains data
75596>>>>>        Property Boolean pbEmptyLogFile True
75597>>>>>
75597>>>>>        // Gets set to True after the error log header text
75597>>>>>        // has been written.
75597>>>>>        Property Boolean pbHeaderWritten False
75598>>>>>
75598>>>>>        // If all activities should be logged- not just errors.
75598>>>>>        Property Boolean pbVerboseState False
75599>>>>>
75599>>>>>        // File name for the error log where all errors
75599>>>>>        // after a run is written to (appended).
75599>>>>>        // It is saved in the Data folder.
75599>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75600>>>>>        // If this property is set to "" in object code, the
75600>>>>>        // "shell" command parameter will be used to let Windows decide
75600>>>>>        // with which program to open the logfile.
75600>>>>>        Property String psEditorProgram ""
75601>>>>>
75601>>>>>        Property Boolean pbUseDataTableLog False
75602>>>>>
75602>>>>>        // If true an error will be written to file immediately when
75602>>>>>        // it occurs. This can be handy if a large update generates a lots
75602>>>>>        // of errors and the application crasches before finished, thus
75602>>>>>        // the errors will not be written.
75602>>>>>        Property Boolean pbQuickWrite True
75603>>>>>    End_Procedure
75604>>>>>
75604>>>>>    Procedure End_Construct_Object
75606>>>>>        Forward Send End_Construct_Object
75608>>>>>
75608>>>>>    End_Procedure
75609>>>>>
75609>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75611>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75611>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75613>>>>>        Boolean bShortFormat bDisabled
75613>>>>>        Integer iSize iCurrentField           
75613>>>>>        Handle hCurrentTable
75613>>>>>        String sOrgErrorText sTableRootName
75613>>>>>        
75613>>>>>        Move False to bShortFormat
75614>>>>>        If (num_arguments > 5) Begin
75616>>>>>            Move bShortFormatIn to bShortFormat
75617>>>>>        End
75617>>>>>>
75617>>>>>        // Only do once.
75617>>>>>        If (pbHeaderWritten(Self) = False) Begin
75619>>>>>            Send WriteHeaderData
75620>>>>>        End
75620>>>>>>
75620>>>>>
75620>>>>>        Get Private.phCurrentTable to hCurrentTable  
75621>>>>>        Get Private.piCurrentField to iCurrentField  
75622>>>>>        Get_Attribute DF_API_DISABLED to bDisabled
75625>>>>>        If (iError > 0 and bDisabled = False and hCurrentTable <> 0) Begin
75627>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75630>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75631>>>>>        End
75631>>>>>>
75631>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75632>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75633>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75634>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75635>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75636>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75637>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75638>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75639>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75640>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75641>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75642>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75643>>>>>
75643>>>>>        If (bError = False) Begin
75645>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75646>>>>>        End
75646>>>>>>
75646>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75647>>>>>
75647>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75649>>>>>            If (pbQuickWrite(Self) = True) Begin
75651>>>>>                Send OnWriteRow_DataTable
75652>>>>>                // If we are writing error for error flush the
75652>>>>>                // error array when latest error has been written.
75652>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75653>>>>>            End
75653>>>>>>
75653>>>>>            Procedure_Return
75654>>>>>        End
75654>>>>>>
75654>>>>>        Else Begin
75655>>>>>            If (pbQuickWrite(Self) = True) Begin
75657>>>>>                Send WriteErrorLog
75658>>>>>                // Flush the error log array
75658>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty 
75659>>>>>            End
75659>>>>>>
75659>>>>>        End
75659>>>>>>
75659>>>>>    End_Procedure   
75660>>>>>    
75660>>>>>    Function FetchErrorDescription Integer iError Returns String
75662>>>>>        String sErrorText         
75662>>>>>        Move "" to sErrorText
75663>>>>>        If (iError > 0) Begin
75665>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75666>>>>>        End
75666>>>>>>
75666>>>>>        Function_Return sErrorText
75667>>>>>    End_Function
75668>>>>>
75668>>>>>    // Hook procedure for writing header text prior starting the update work to
75668>>>>>    // a database table. This does nothing by default.
75668>>>>>    // Don't forget to Open your "error log table" first (!) as all
75668>>>>>    // tables have been closed at this stage. Put anything
75668>>>>>    // you want to indicate that the update process is just started.
75668>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75670>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75672>>>>>    End_Procedure
75673>>>>>
75673>>>>>    Procedure OnWriteRow_DataTable
75675>>>>>        tDbUpdateError[] DbUpdateErrorArray
75675>>>>>        tDbUpdateError[] DbUpdateErrorArray
75676>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75677>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75679>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75681>>>>>        End
75681>>>>>>
75681>>>>>    End_Procedure
75682>>>>>
75682>>>>>    Function psLogTextFileWithPath Returns String
75684>>>>>        String sPath sFileName sFullFileName
75684>>>>>        
75684>>>>>        Get psDataPathFirstPart to sPath
75685>>>>>        Get psLogTextFile to sFileName
75686>>>>>        Move (sPath + sFileName) to sFullFileName
75687>>>>>        Function_Return sFullFileName
75688>>>>>    End_Function                     
75689>>>>>    
75689>>>>>    Procedure WriteHeaderData
75691>>>>>        String sFileName
75691>>>>>        Integer iCh iSize
75691>>>>>        Boolean bQuickWrite
75691>>>>>        DateTime dtUpdateStart
75691>>>>>
75691>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75692>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75694>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75695>>>>>            Procedure_Return
75696>>>>>        End
75696>>>>>>
75696>>>>>
75696>>>>>        Get piChannel to iCh
75697>>>>>        If (iCh < 0) Begin
75699>>>>>            Get Seq_New_Channel to iCh
75700>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75702>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75703>>>>>>
75703>>>>>                Procedure_Return
75704>>>>>            End
75704>>>>>>
75704>>>>>            Set piChannel to iCh
75705>>>>>        End
75705>>>>>>
75705>>>>>
75705>>>>>        Get psLogTextFileWithPath to sFileName
75706>>>>>        Get vWin32_APIFileSize sFileName to iSize
75707>>>>>        Get pbQuickWrite to bQuickWrite
75708>>>>>        
75708>>>>>        If (bQuickWrite = True) Begin
75710>>>>>            Append_Output channel iCh sFileName
75712>>>>>                If (bQuickWrite = True) Begin
75714>>>>>                    If (iSize = 0) Begin
75716>>>>>                        Write channel iCh C_BOM_UTF8
75718>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75721>>>>>                        Set pbEmptyLogFile to False
75722>>>>>                    End
75722>>>>>>
75722>>>>>                    Writeln channel iCh
75724>>>>>                    Writeln channel iCh ("*** Database Update Started:      " + String(dtUpdateStart))
75727>>>>>                End
75727>>>>>>
75727>>>>>            Close_Output channel iCh
75729>>>>>            Set pbHeaderWritten to True
75730>>>>>        End
75730>>>>>>
75730>>>>>    End_Procedure
75731>>>>>
75731>>>>>    // Returns the first datapath found in the psDataPath property.
75731>>>>>    // The returned path always ends with a "\"
75731>>>>>    Function psDataPathFirstPart Returns String
75733>>>>>        String sDataPath
75733>>>>>        Integer iCount
75733>>>>>
75733>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75734>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75735>>>>>        If (iCount > 1) Begin
75737>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75738>>>>>        End
75738>>>>>>
75738>>>>>        If (sDataPath <> "") Begin
75740>>>>>            Get vFolderFormat sDataPath to sDataPath
75741>>>>>        End
75741>>>>>>
75741>>>>>
75741>>>>>        Function_Return sDataPath
75742>>>>>    End_Function
75743>>>>>
75743>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75743>>>>>    Procedure WriteErrorLog
75745>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75745>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75746>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75746>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75746>>>>>        Boolean bUseDataTable bQuickWrite
75746>>>>>        DateTime dtUpdateStart dtUpdateEnd
75746>>>>>        TimeSpan tsElapsed
75746>>>>>        Number nVersion                                  
75746>>>>>        Handle hTable
75746>>>>>
75746>>>>>        If (pbHeaderWritten(Self) = False) Begin
75748>>>>>            Send WriteHeaderData
75749>>>>>        End
75749>>>>>>
75749>>>>>
75749>>>>>        Get pbUseDataTableLog to bUseDataTable
75750>>>>>        If (bUseDataTable = True) Begin
75752>>>>>            Send OnWriteRow_DataTable
75753>>>>>            Procedure_Return
75754>>>>>        End
75754>>>>>>
75754>>>>>
75754>>>>>        Get piChannel to iCh
75755>>>>>        If (iCh < 0) Begin
75757>>>>>            Get Seq_New_Channel to iCh
75758>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75760>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75761>>>>>>
75761>>>>>                Procedure_Return
75762>>>>>            End
75762>>>>>>
75762>>>>>            Set piChannel to iCh
75763>>>>>        End
75763>>>>>>
75763>>>>>
75763>>>>>        Get psLogTextFileWithPath to sFileName
75764>>>>>
75764>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75765>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75766>>>>>        Decrement iSize
75767>>>>>
75767>>>>>        Get pdtUpdateStart to dtUpdateStart
75768>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75770>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75771>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75772>>>>>        End
75772>>>>>>
75772>>>>>        Get pbQuickWrite to bQuickWrite
75773>>>>>
75773>>>>>        Append_Output channel iCh sFileName
75775>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75777>>>>>            Writeln channel iCh ("*** Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75780>>>>>        End
75780>>>>>>
75780>>>>>        Else If (bQuickWrite = False) Begin
75783>>>>>            Writeln channel iCh
75785>>>>>            Writeln channel iCh ("*** Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75788>>>>>        End   
75788>>>>>>
75788>>>>>        If (iSize >= 0) Begin
75790>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75792>>>>>//                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75792>>>>>                Writeln channel iCh "[Err No:] [Version:] [Status Text:]"
75795>>>>>            End
75795>>>>>>
75795>>>>>        End
75795>>>>>>
75795>>>>>
75795>>>>>        For iCount from 0 to iSize  
75801>>>>>>
75801>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75802>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75803>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75804>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75805>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75806>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75807>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75808>>>>>            
75808>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75809>>>>>            If (iError = 0) Begin
75811>>>>>                Move " Info  " to sErrorNo
75812>>>>>            End
75812>>>>>>
75812>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75814>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75815>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75815>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75816>>>>>            End
75816>>>>>>
75816>>>>>            Else Begin
75817>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75818>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75818>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText) to sText
75819>>>>>            End
75819>>>>>>
75819>>>>>            Writeln channel iCh sText
75822>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75824>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75825>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75826>>>>>                Writeln channel iCh sOrgErrorText
75829>>>>>            End
75829>>>>>>
75829>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75831>>>>>                Writeln channel iCh
75833>>>>>            End
75833>>>>>>
75833>>>>>        Loop
75834>>>>>>
75834>>>>>        Close_Output channel iCh
75836>>>>>
75836>>>>>        Send Seq_Release_Channel iCh
75837>>>>>        Set piChannel to -1
75838>>>>>
75838>>>>>    End_Procedure
75839>>>>>
75839>>>>>    // The character to pad is optional. If nothing, spaces are used.
75839>>>>>    // Example:
75839>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75839>>>>>    //  or:
75839>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75839>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75839>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75841>>>>>        String sChar
75841>>>>>
75841>>>>>        If (Num_Arguments >= 3) Begin
75843>>>>>            Move sOptChar to sChar
75844>>>>>        End
75844>>>>>>
75844>>>>>        Else Begin
75845>>>>>            Move " " to sChar
75846>>>>>        End
75846>>>>>>
75846>>>>>
75846>>>>>        While (Length(sString) < iLength)
75850>>>>>            Move (sChar + sString) to sString
75851>>>>>        Loop
75852>>>>>>
75852>>>>>
75852>>>>>        Function_Return sString
75853>>>>>    End_Function
75854>>>>>
75854>>>>>    Procedure ShowErrorLog
75856>>>>>        String sPath sFileName sEditorProgram
75856>>>>>        Boolean bExists
75856>>>>>
75856>>>>>        Get psLogTextFileWithPath to sFileName
75857>>>>>        Get vFilePathExists sFileName to bExists
75858>>>>>        If (bExists = True) Begin
75860>>>>>            Get psEditorProgram to sEditorProgram
75861>>>>>            If (sEditorProgram <> "") Begin
75863>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75864>>>>>            End
75864>>>>>>
75864>>>>>            Else Begin
75865>>>>>                Runprogram Shell Background sFileName
75866>>>>>            End
75866>>>>>>
75866>>>>>        End
75866>>>>>>
75866>>>>>        Else Begin
75867>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75868>>>>>        End
75868>>>>>>
75868>>>>>    End_Procedure
75869>>>>>
75869>>>>>End_Class
75870>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75870>>>>>//****************************************************************************
75870>>>>>// $Module type: Class
75870>>>>>// $Module name: cDbUpdateVersion
75870>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75870>>>>>// Web-site    : http://www.rdctools.com
75870>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75870>>>>>//
75870>>>>>// Description : Child class to cDbUpdateHandler.
75870>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75870>>>>>//               Set the pnVersionNumber to a version number.
75870>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75870>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75870>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75870>>>>>//
75870>>>>>// $Rev History:
75870>>>>>//    2016-09-27  Module header created
75870>>>>>//****************************************************************************
75870>>>>>Use UI
75870>>>>>Use DUFLanguageConstants.inc
75870>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75870>>>>>>>//****************************************************************************
75870>>>>>>>// $Module type: Class
75870>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75870>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75870>>>>>>>// Web-site    : http://www.rdctools.com
75870>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75870>>>>>>>//
75870>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75870>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75870>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75870>>>>>>>//               with the help of Sql-scripts.
75870>>>>>>>//
75870>>>>>>>// $Rev History:
75870>>>>>>>//    2014-09-05  Module header created
75870>>>>>>>//
75870>>>>>>>//****************************************************************************
75870>>>>>>>//
75870>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75870>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75870>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75870>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75870>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75870>>>>>>>//
75870>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75870>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75870>>>>>>>
75870>>>>>>>
75870>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75870>>>>>>>// Determines for all DataFlex data types, which SQL native types will be used when creating new columns.
75870>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75870>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75870>>>>>>>//
75870>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75870>>>>>>>>>//****************************************************************************
75870>>>>>>>>>// $Module type: Class
75870>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75870>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75870>>>>>>>>>// Web-site    : http://www.rdctools.com
75870>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75870>>>>>>>>>//
75870>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75870>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75870>>>>>>>>>//
75870>>>>>>>>>// $Rev History:
75870>>>>>>>>>//    2023-11-06  Module header created
75870>>>>>>>>>//
75870>>>>>>>>>//****************************************************************************
75870>>>>>>>>>Use cApplication.pkg
75870>>>>>>>>>Use seq_chnl.pkg
75870>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75870>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75870>>>>>>>>>Use Dfcursor.pkg
75870>>>>>>>>>Use DUFStatusPanel.pkg
75870>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75870>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75870>>>>>>>>>>>//
75870>>>>>>>>>>>// We need to create a mixin class for the library.
75870>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75870>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75870>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75870>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75870>>>>>>>>>>>//
75870>>>>>>>>>>>Use VdfBase.pkg
75870>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75870>>>>>>>>>>>>>Use Unicode.Pkg
75870>>>>>>>>>>>>>
75870>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75871>>>>>>>>>>>>>
75871>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75872>>>>>>>>>>>>>
75872>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75873>>>>>>>>>>>>>
75873>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75874>>>>>>>>>>>>>
75874>>>>>>>>>>>>>
75874>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75874>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75876>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75876>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75876>>>>>>>>>>>>>    String sUUID
75876>>>>>>>>>>>>>    
75876>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75877>>>>>>>>>>>>>    
75877>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75878>>>>>>>>>>>>>    
75878>>>>>>>>>>>>>    If (iRetval = 0) Begin
75880>>>>>>>>>>>>>        Move 0 to pUUIDStr
75881>>>>>>>>>>>>>        
75881>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75882>>>>>>>>>>>>>        If (iRetval = 0) Begin
75884>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75885>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75886>>>>>>>>>>>>>            
75886>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75887>>>>>>>>>>>>>        End
75887>>>>>>>>>>>>>>
75887>>>>>>>>>>>>>    End
75887>>>>>>>>>>>>>>
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75888>>>>>>>>>>>>>    
75888>>>>>>>>>>>>>    Function_Return sUUID
75889>>>>>>>>>>>>>End_Function
75890>>>>>>>>>>>>>
75890>>>>>>>>>>>>>
75890>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75890>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75892>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75892>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75892>>>>>>>>>>>>>    String sUUID
75892>>>>>>>>>>>>>    
75892>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75893>>>>>>>>>>>>>    
75893>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75894>>>>>>>>>>>>>    
75894>>>>>>>>>>>>>    If (iRetval = 0) Begin
75896>>>>>>>>>>>>>        Move 0 to pUUIDStr
75897>>>>>>>>>>>>>        
75897>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75898>>>>>>>>>>>>>        If (iRetval = 0) Begin
75900>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75901>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75902>>>>>>>>>>>>>            
75902>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75903>>>>>>>>>>>>>        End
75903>>>>>>>>>>>>>>
75903>>>>>>>>>>>>>    End
75903>>>>>>>>>>>>>>
75903>>>>>>>>>>>>>    
75903>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75904>>>>>>>>>>>>>    
75904>>>>>>>>>>>>>    Function_Return sUUID
75905>>>>>>>>>>>>>End_Function
75906>>>>>>>>>>>Use cli.pkg
75906>>>>>>>>>>>Use sql.pkg
75906>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75906>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75906>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75906>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>Use Cli.pkg
75906>>>>>>>>>>>>>Use SQL.pkg
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>//   Driver Indentification
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>//   Error number constants
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>// SQL Server spcific types.
75906>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75906>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75906>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75906>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>// SQL Server spcific types.
75906>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75906>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75906>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75906>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75906>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75906>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75906>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75906>>>>>>>>>>>>>//
75906>>>>>>>>>>>>>//     Setup a constraint for a file.
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>
75906>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75907>>>>>>>>>>>>>    
75907>>>>>>>>>>>>>    Procedure Construct_Object
75909>>>>>>>>>>>>>        Forward Send Construct_Object
75911>>>>>>>>>>>>>        
75911>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75912>>>>>>>>>>>>>    End_Procedure
75913>>>>>>>>>>>>>    
75913>>>>>>>>>>>>>    
75913>>>>>>>>>>>>>    
75913>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75913>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75915>>>>>>>>>>>>>        String  sItem
75915>>>>>>>>>>>>>        Integer iStart
75915>>>>>>>>>>>>>        Integer iEnd
75915>>>>>>>>>>>>>        
75915>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75918>>>>>>>>>>>>>        
75918>>>>>>>>>>>>>        Send Delete_Data to hoStore
75919>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75920>>>>>>>>>>>>>        While (iStart > 0)
75924>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75925>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75928>>>>>>>>>>>>>            Else Begin
75929>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75930>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75931>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75934>>>>>>>>>>>>>                
75934>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75937>>>>>>>>>>>>>                
75937>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75940>>>>>>>>>>>>>            End
75940>>>>>>>>>>>>>>
75940>>>>>>>>>>>>>        Loop
75941>>>>>>>>>>>>>>
75941>>>>>>>>>>>>>        
75941>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75942>>>>>>>>>>>>>    End_Procedure
75943>>>>>>>>>>>>>    
75943>>>>>>>>>>>>>    
75943>>>>>>>>>>>>>    
75943>>>>>>>>>>>>>    //   Call the driver's browse connect function
75943>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75945>>>>>>>>>>>>>        String  sDriver
75945>>>>>>>>>>>>>        String  sOutConnStr
75945>>>>>>>>>>>>>        Integer iArg
75945>>>>>>>>>>>>>        Integer iRetval
75945>>>>>>>>>>>>>        
75945>>>>>>>>>>>>>        Get psDriverID to sDriver
75946>>>>>>>>>>>>>        If (sDriver <> "") Begin
75948>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75949>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75954>>>>>>>>>>>>>        End
75954>>>>>>>>>>>>>>
75954>>>>>>>>>>>>>        
75954>>>>>>>>>>>>>        Function_Return sOutConnStr
75955>>>>>>>>>>>>>    End_Function// BrowseConnect
75956>>>>>>>>>>>>>    
75956>>>>>>>>>>>>>    
75956>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75958>>>>>>>>>>>>>        String  sDriver
75958>>>>>>>>>>>>>        String  sOutConnStr
75958>>>>>>>>>>>>>        Integer iArg
75958>>>>>>>>>>>>>        Integer iRetval
75958>>>>>>>>>>>>>        
75958>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75959>>>>>>>>>>>>>        
75959>>>>>>>>>>>>>        Get psDriverID to sDriver
75960>>>>>>>>>>>>>        If (sDriver <> "") Begin
75962>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75963>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75968>>>>>>>>>>>>>        End
75968>>>>>>>>>>>>>>
75968>>>>>>>>>>>>>        
75968>>>>>>>>>>>>>        Function_Return sOutConnStr
75969>>>>>>>>>>>>>    End_Function// BrowseConnect
75970>>>>>>>>>>>>>    
75970>>>>>>>>>>>>>    
75970>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75972>>>>>>>>>>>>>        String  sServerList
75972>>>>>>>>>>>>>        Integer iNumServers
75972>>>>>>>>>>>>>        Integer iDriver
75972>>>>>>>>>>>>>        Integer iClientVersion
75972>>>>>>>>>>>>>        String  sDriver
75972>>>>>>>>>>>>>        
75972>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75973>>>>>>>>>>>>>        
75973>>>>>>>>>>>>>        If (iDriver) Begin
75975>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75978>>>>>>>>>>>>>            
75978>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75979>>>>>>>>>>>>>            
75979>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75980>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75982>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75983>>>>>>>>>>>>>            End
75983>>>>>>>>>>>>>>
75983>>>>>>>>>>>>>            Else Begin
75984>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75985>>>>>>>>>>>>>            End
75985>>>>>>>>>>>>>>
75985>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75986>>>>>>>>>>>>>        End
75986>>>>>>>>>>>>>>
75986>>>>>>>>>>>>>        
75986>>>>>>>>>>>>>        Function_Return iNumServers
75987>>>>>>>>>>>>>    End_Function
75988>>>>>>>>>>>>>    
75988>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75988>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75988>>>>>>>>>>>>>    //   This may take a long time.
75988>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75988>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75990>>>>>>>>>>>>>        Integer iNumServers
75990>>>>>>>>>>>>>        Integer iNetworkLocal
75990>>>>>>>>>>>>>        
75990>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75991>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75992>>>>>>>>>>>>>
75992>>>>>>>>>>>>>        Function_Return iNumServers
75993>>>>>>>>>>>>>    End_Function
75994>>>>>>>>>>>>>    
75994>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75994>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75994>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75994>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75996>>>>>>>>>>>>>        Integer iNumServers
75996>>>>>>>>>>>>>        Integer iNetworkLocal
75996>>>>>>>>>>>>>        
75996>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75997>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75998>>>>>>>>>>>>>        
75998>>>>>>>>>>>>>        Function_Return iNumServers
75999>>>>>>>>>>>>>    End_Function
76000>>>>>>>>>>>>>    
76000>>>>>>>>>>>>>    //   Enumerate database in a given server.
76000>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
76002>>>>>>>>>>>>>        Integer hoSQL
76002>>>>>>>>>>>>>        String  sConnect
76002>>>>>>>>>>>>>        String  sDatabase
76002>>>>>>>>>>>>>        Integer hdbc
76002>>>>>>>>>>>>>        Integer hstmt
76002>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
76002>>>>>>>>>>>>>        
76002>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
76005>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76008>>>>>>>>>>>>>        
76008>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76011>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76013>>>>>>>>>>>>>
76013>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76014>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76017>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
76019>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76020>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
76021>>>>>>>>>>>>>        End
76021>>>>>>>>>>>>>>
76021>>>>>>>>>>>>>        
76021>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76023>>>>>>>>>>>>>            Move Current_Object to hoSQL
76024>>>>>>>>>>>>>        End_Object
76025>>>>>>>>>>>>>        
76025>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76027>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76028>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76030>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76031>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76033>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76033>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76033>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76033>>>>>>>>>>>>>                    //   stay the same.
76033>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76034>>>>>>>>>>>>>                    Send SQLCall to hstmt
76035>>>>>>>>>>>>>                    Repeat
76035>>>>>>>>>>>>>>
76035>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76036>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76038>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76039>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76040>>>>>>>>>>>>>                        End
76040>>>>>>>>>>>>>>
76040>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76042>>>>>>>>>>>>>                    
76042>>>>>>>>>>>>>                    Send SQLClose to hstmt
76043>>>>>>>>>>>>>                End
76043>>>>>>>>>>>>>>
76043>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76044>>>>>>>>>>>>>            End
76044>>>>>>>>>>>>>>
76044>>>>>>>>>>>>>        End
76044>>>>>>>>>>>>>>
76044>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76045>>>>>>>>>>>>>        
76045>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76046>>>>>>>>>>>>>    End_Function
76047>>>>>>>>>>>>>    
76047>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76049>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76049>>>>>>>>>>>>>        
76049>>>>>>>>>>>>>        Case Begin
76049>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76051>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76052>>>>>>>>>>>>>                Case Break
76053>>>>>>>>>>>>>            
76053>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76056>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76057>>>>>>>>>>>>>                Case Break
76058>>>>>>>>>>>>>                
76058>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76061>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76062>>>>>>>>>>>>>                Case Break
76063>>>>>>>>>>>>>            
76063>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76066>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76067>>>>>>>>>>>>>                Case Break
76068>>>>>>>>>>>>>            
76068>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76071>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76072>>>>>>>>>>>>>                Case Break
76073>>>>>>>>>>>>>            
76073>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76076>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76077>>>>>>>>>>>>>                Case Break
76078>>>>>>>>>>>>>            
76078>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76081>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76082>>>>>>>>>>>>>                Case Break
76083>>>>>>>>>>>>>            
76083>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76086>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76087>>>>>>>>>>>>>                Case Break
76088>>>>>>>>>>>>>            
76088>>>>>>>>>>>>>            Case Else
76088>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76089>>>>>>>>>>>>>        Case End
76089>>>>>>>>>>>>>        
76089>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76090>>>>>>>>>>>>>    End_Function
76091>>>>>>>>>>>>>
76091>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76093>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76093>>>>>>>>>>>>>        
76093>>>>>>>>>>>>>        Case Begin
76093>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76095>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76096>>>>>>>>>>>>>                Case Break
76097>>>>>>>>>>>>>
76097>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76100>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76101>>>>>>>>>>>>>                Case Break
76102>>>>>>>>>>>>>                
76102>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76105>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76106>>>>>>>>>>>>>                Case Break
76107>>>>>>>>>>>>>            
76107>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76110>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76111>>>>>>>>>>>>>                Case Break
76112>>>>>>>>>>>>>            
76112>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76115>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76116>>>>>>>>>>>>>                Case Break
76117>>>>>>>>>>>>>            
76117>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76120>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76121>>>>>>>>>>>>>                Case Break
76122>>>>>>>>>>>>>            
76122>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76125>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76126>>>>>>>>>>>>>                Case Break
76127>>>>>>>>>>>>>            
76127>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76130>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76131>>>>>>>>>>>>>                Case Break
76132>>>>>>>>>>>>>            
76132>>>>>>>>>>>>>            Case Else
76132>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76133>>>>>>>>>>>>>        Case End
76133>>>>>>>>>>>>>        
76133>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76134>>>>>>>>>>>>>    End_Function
76135>>>>>>>>>>>>>    
76135>>>>>>>>>>>>>End_Class
76136>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76136>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76136>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76136>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76136>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>Use Cli.pkg
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// Driver attributes
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// Driver Indentification
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// Error number constants
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// Call driver function identifiers
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// DB2 specific data types
76136>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76136>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76136>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76136>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76136>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76136>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76136>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76136>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// Extra DB2 commands
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76136>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>
76136>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76137>>>>>>>>>>>>>    
76137>>>>>>>>>>>>>    Procedure Construct_Object
76139>>>>>>>>>>>>>        Forward Send Construct_Object
76141>>>>>>>>>>>>>        
76141>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76142>>>>>>>>>>>>>    End_Procedure
76143>>>>>>>>>>>>>    
76143>>>>>>>>>>>>>    
76143>>>>>>>>>>>>>    
76143>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76143>>>>>>>>>>>>>    Procedure SeedDataSources
76145>>>>>>>>>>>>>        String  sDriver
76145>>>>>>>>>>>>>        String  sVoid
76145>>>>>>>>>>>>>        Integer iRetval
76145>>>>>>>>>>>>>        
76145>>>>>>>>>>>>>        Get psDriverID to sDriver
76146>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76153>>>>>>>>>>>>>    End_Procedure
76154>>>>>>>>>>>>>    
76154>>>>>>>>>>>>>    
76154>>>>>>>>>>>>>    
76154>>>>>>>>>>>>>    // Call the driver's data sources function
76154>>>>>>>>>>>>>    Function DataSources Returns String
76156>>>>>>>>>>>>>        String  sDriver
76156>>>>>>>>>>>>>        String  sDataSource
76156>>>>>>>>>>>>>        String  sDescription
76156>>>>>>>>>>>>>        Integer iLength
76156>>>>>>>>>>>>>        Integer iRetval
76156>>>>>>>>>>>>>        
76156>>>>>>>>>>>>>        Get psDriverID to sDriver
76157>>>>>>>>>>>>>        If (sDriver <> "") Begin
76159>>>>>>>>>>>>>            Move 8192 to iLength
76160>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76161>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76162>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76167>>>>>>>>>>>>>        End
76167>>>>>>>>>>>>>>
76167>>>>>>>>>>>>>        
76167>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76170>>>>>>>>>>>>>        Else ;            Function_Return ""
76172>>>>>>>>>>>>>    End_Function
76173>>>>>>>>>>>>>    
76173>>>>>>>>>>>>>End_Class
76174>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76174>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76174>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76174>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76174>>>>>>>>>>>>>
76174>>>>>>>>>>>>>Use Cli.pkg
76174>>>>>>>>>>>>>
76174>>>>>>>>>>>>>// Driver Indentification
76174>>>>>>>>>>>>>
76174>>>>>>>>>>>>>// Error number constants
76174>>>>>>>>>>>>>
76174>>>>>>>>>>>>>// Call driver function identifiers
76174>>>>>>>>>>>>>
76174>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76175>>>>>>>>>>>>>    
76175>>>>>>>>>>>>>    Procedure Construct_Object
76177>>>>>>>>>>>>>        Forward Send Construct_Object
76179>>>>>>>>>>>>>        
76179>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76180>>>>>>>>>>>>>    End_Procedure
76181>>>>>>>>>>>>>    
76181>>>>>>>>>>>>>    
76181>>>>>>>>>>>>>    
76181>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76181>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76183>>>>>>>>>>>>>        String  sDriver
76183>>>>>>>>>>>>>        String  sVoid
76183>>>>>>>>>>>>>        Integer iRetval
76183>>>>>>>>>>>>>        
76183>>>>>>>>>>>>>        Get psDriverID to sDriver
76184>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76191>>>>>>>>>>>>>    End_Procedure
76192>>>>>>>>>>>>>    
76192>>>>>>>>>>>>>    
76192>>>>>>>>>>>>>    // Call the driver's data sources function
76192>>>>>>>>>>>>>    Function DataSources Returns String
76194>>>>>>>>>>>>>        String  sDriver
76194>>>>>>>>>>>>>        String  sDataSource
76194>>>>>>>>>>>>>        String  sDescription
76194>>>>>>>>>>>>>        Integer iLength
76194>>>>>>>>>>>>>        Integer iRetval
76194>>>>>>>>>>>>>        
76194>>>>>>>>>>>>>        Get psDriverID to sDriver
76195>>>>>>>>>>>>>        If (sDriver <> "") Begin
76197>>>>>>>>>>>>>            Move 8192 to iLength
76198>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76199>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76200>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76205>>>>>>>>>>>>>        End
76205>>>>>>>>>>>>>>
76205>>>>>>>>>>>>>        
76205>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76208>>>>>>>>>>>>>        Else ;            Function_Return ""
76210>>>>>>>>>>>>>    End_Function
76211>>>>>>>>>>>>>    
76211>>>>>>>>>>>>>End_Class
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76212>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76212>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76212>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76212>>>>>>>>>>>>>Use Ui
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Driver Indentification
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>// Driver attributes
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Call_Driver functions ID's
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to create all vars which may be needed
76212>>>>>>>>>>>>>// in other commands.
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76212>>>>>>>>>>>>>// File must have been opened.
76212>>>>>>>>>>>>>// Filenumber needs to be passed.
76212>>>>>>>>>>>>>// To clear set the owner to "".
76212>>>>>>>>>>>>>// Examples:
76212>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76212>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76212>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76212>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76212>>>>>>>>>>>>>// To clear:
76212>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76212>>>>>>>>>>>>>// options.
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to parse for Callback
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76212>>>>>>>>>>>>>// File must have been opened.
76212>>>>>>>>>>>>>// Filenumber needs to be passed.
76212>>>>>>>>>>>>>// Examples:
76212>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76212>>>>>>>>>>>>>// which will be tries when opening files.
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76212>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76212>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76212>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to change the transaction type.
76212>>>>>>>>>>>>>// Valid types are:
76212>>>>>>>>>>>>>//     DFBTRTT_NONE
76212>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76212>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to get the current transaction type.
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to set explicit_locking
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to get explicit locking
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76212>>>>>>>>>>>>>//
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76212>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76212>>>>>>>>>>>>>
76212>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76213>>>>>>>>>>>>>    
76213>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76215>>>>>>>>>>>>>        Forward Send Construct_object iImage
76217>>>>>>>>>>>>>        
76217>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76218>>>>>>>>>>>>>    End_Procedure
76219>>>>>>>>>>>>>    
76219>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76219>>>>>>>>>>>>>    //
76219>>>>>>>>>>>>>    
76219>>>>>>>>>>>>>    Function CKRevision Returns String
76221>>>>>>>>>>>>>        String  sDriverID
76221>>>>>>>>>>>>>        String  sRevision
76221>>>>>>>>>>>>>        String  sVoid
76221>>>>>>>>>>>>>        Integer iRetval
76221>>>>>>>>>>>>>        
76221>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76221>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76221>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76221>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76222>>>>>>>>>>>>>        Get psDriverID to sDriverID
76223>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76224>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76229>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76230>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76232>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76232>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76233>>>>>>>>>>>>>        End
76233>>>>>>>>>>>>>>
76233>>>>>>>>>>>>>        Function_Return sRevision
76234>>>>>>>>>>>>>    End_Function
76235>>>>>>>>>>>>>    
76235>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76237>>>>>>>>>>>>>        String  sDriverID
76237>>>>>>>>>>>>>        String  sVoid1
76237>>>>>>>>>>>>>        String  sVoid2
76237>>>>>>>>>>>>>        Integer iRetval
76237>>>>>>>>>>>>>        
76237>>>>>>>>>>>>>        Get psDriverID to sDriverID
76238>>>>>>>>>>>>>        
76238>>>>>>>>>>>>>        Move 0 to iRetval
76239>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76239>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76239>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76239>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76240>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76245>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76246>>>>>>>>>>>>>        
76246>>>>>>>>>>>>>        Function_Return iRetval
76247>>>>>>>>>>>>>    End_Function
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76248>>>>>>>>>>>>>    //
76248>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76248>>>>>>>>>>>>>    //
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76250>>>>>>>>>>>>>        Integer iPartRev
76250>>>>>>>>>>>>>        Integer iCurrentPart
76250>>>>>>>>>>>>>        Integer iSeparatorPos
76250>>>>>>>>>>>>>        
76250>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76253>>>>>>>>>>>>>        
76253>>>>>>>>>>>>>        Move 0 to iCurrentPart
76254>>>>>>>>>>>>>        Repeat
76254>>>>>>>>>>>>>>
76254>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76255>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76257>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76258>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76259>>>>>>>>>>>>>                Increment iCurrentPart
76260>>>>>>>>>>>>>            End
76260>>>>>>>>>>>>>>
76260>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76263>>>>>>>>>>>>>                Move sRevision to iPartRev
76264>>>>>>>>>>>>>                Move "" to sRevision
76265>>>>>>>>>>>>>                Increment iCurrentPart
76266>>>>>>>>>>>>>            End
76266>>>>>>>>>>>>>>
76266>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76268>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76270>>>>>>>>>>>>>        
76270>>>>>>>>>>>>>        Function_Return iPartRev
76271>>>>>>>>>>>>>    End_Function
76272>>>>>>>>>>>>>    
76272>>>>>>>>>>>>>    
76272>>>>>>>>>>>>>    
76272>>>>>>>>>>>>>    //
76272>>>>>>>>>>>>>    //  Returns the major revision of the CK
76272>>>>>>>>>>>>>    //
76272>>>>>>>>>>>>>    
76272>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76274>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76275>>>>>>>>>>>>>    End_Function
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76276>>>>>>>>>>>>>    //
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76278>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76279>>>>>>>>>>>>>    End_Function
76280>>>>>>>>>>>>>    
76280>>>>>>>>>>>>>    
76280>>>>>>>>>>>>>    //  Returns the release revision of the CK
76280>>>>>>>>>>>>>    //
76280>>>>>>>>>>>>>    
76280>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76282>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76283>>>>>>>>>>>>>    End_Function
76284>>>>>>>>>>>>>    
76284>>>>>>>>>>>>>    
76284>>>>>>>>>>>>>    //  Returns the major revision of the CK
76284>>>>>>>>>>>>>    //
76284>>>>>>>>>>>>>    
76284>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76286>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76287>>>>>>>>>>>>>    End_Function
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76288>>>>>>>>>>>>>    //
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76290>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76293>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76296>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76299>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76302>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76305>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76309>>>>>>>>>>>>>            End
76309>>>>>>>>>>>>>>
76309>>>>>>>>>>>>>        End
76309>>>>>>>>>>>>>>
76309>>>>>>>>>>>>>        
76309>>>>>>>>>>>>>        Function_Return (False)
76310>>>>>>>>>>>>>    End_Function
76311>>>>>>>>>>>>>    
76311>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76311>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76311>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76311>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76311>>>>>>>>>>>>>    //
76311>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76311>>>>>>>>>>>>>    //   in the following format:
76311>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76311>>>>>>>>>>>>>    //   possible values for <type>:
76311>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76311>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76311>>>>>>>>>>>>>    //       C for client cache engine
76311>>>>>>>>>>>>>    //       D for DOS workstation
76311>>>>>>>>>>>>>    //       N for client Requester
76311>>>>>>>>>>>>>    //       S for NetWare server
76311>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76311>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76311>>>>>>>>>>>>>    //
76311>>>>>>>>>>>>>    //   example:
76311>>>>>>>>>>>>>    //       8.50.T
76311>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76311>>>>>>>>>>>>>    //   32-bits Windows server.
76311>>>>>>>>>>>>>    //
76311>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76311>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76311>>>>>>>>>>>>>    //
76311>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76311>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76311>>>>>>>>>>>>>    
76311>>>>>>>>>>>>>    //  Returns the version information of the
76311>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76311>>>>>>>>>>>>>    
76311>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76313>>>>>>>>>>>>>        
76313>>>>>>>>>>>>>        String  sDriverID
76313>>>>>>>>>>>>>        String  sVersion
76313>>>>>>>>>>>>>        String  sVoid
76313>>>>>>>>>>>>>        Integer iRetval
76313>>>>>>>>>>>>>        
76313>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76313>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76313>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76313>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76314>>>>>>>>>>>>>        Get psDriverID to sDriverID
76315>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76316>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76321>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76322>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76324>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76324>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76325>>>>>>>>>>>>>        End
76325>>>>>>>>>>>>>>
76325>>>>>>>>>>>>>        Function_Return sVersion
76326>>>>>>>>>>>>>    End_Function
76327>>>>>>>>>>>>>    
76327>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76327>>>>>>>>>>>>>    
76327>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76329>>>>>>>>>>>>>        
76329>>>>>>>>>>>>>        String  sDriverID
76329>>>>>>>>>>>>>        String  sVersion
76329>>>>>>>>>>>>>        String  sVoid
76329>>>>>>>>>>>>>        Integer iRetval
76329>>>>>>>>>>>>>        
76329>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76329>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76329>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76329>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76330>>>>>>>>>>>>>        Get psDriverID to sDriverID
76331>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76332>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76337>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76338>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76340>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76340>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76341>>>>>>>>>>>>>        End
76341>>>>>>>>>>>>>>
76341>>>>>>>>>>>>>        Function_Return sVersion
76342>>>>>>>>>>>>>    End_Function
76343>>>>>>>>>>>>>    
76343>>>>>>>>>>>>>    //  Returns the version information of the
76343>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76343>>>>>>>>>>>>>    
76343>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76345>>>>>>>>>>>>>        
76345>>>>>>>>>>>>>        String  sDriverID
76345>>>>>>>>>>>>>        String  sVersion
76345>>>>>>>>>>>>>        String  sVoid
76345>>>>>>>>>>>>>        Integer iRetval
76345>>>>>>>>>>>>>        
76345>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76345>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76345>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76345>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76346>>>>>>>>>>>>>        Get psDriverID to sDriverID
76347>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76348>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76353>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76354>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76356>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76356>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76357>>>>>>>>>>>>>        End
76357>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>        Function_Return sVersion
76358>>>>>>>>>>>>>    End_Function
76359>>>>>>>>>>>>>    
76359>>>>>>>>>>>>>End_Class
76360>>>>>>>>>>>>>
76360>>>>>>>>>>>>>
76360>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76360>>>>>>>>>>>>>//****************************************************************************
76360>>>>>>>>>>>>>// $Module type: Include file
76360>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76360>>>>>>>>>>>>>//
76360>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76360>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76360>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76360>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76360>>>>>>>>>>>>>//
76360>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76360>>>>>>>>>>>>>//
76360>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76360>>>>>>>>>>>>>//
76360>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76360>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76360>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76360>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76360>>>>>>>>>>>>>// in the help folder for more details.
76360>>>>>>>>>>>>>//
76360>>>>>>>>>>>>>Use Winkern.pkg
76360>>>>>>>>>>>>>Use cIniFile.pkg
76360>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76360>>>>>>>>>>>>>>>Use VdfBase.pkg
76360>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76360>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76360>>>>>>>>>>>>>>>>>// Algorithm classes
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76360>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Algorithm types
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76360>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Generic sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// RSA sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// DSS sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// DES sub_ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76360>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76360>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76360>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76360>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76360>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76360>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76360>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76360>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76360>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// RC2 sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76360>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76360>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Hash sub ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76360>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76360>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76360>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76360>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76360>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76360>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// secure channel sub ids
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76360>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76360>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76360>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76360>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76360>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76360>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76360>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76360>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76360>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76360>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76360>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76360>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76360>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76360>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76360>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76360>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76360>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76360>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76360>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76360>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76360>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76360>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76360>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76360>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76360>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76360>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76360>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76360>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76360>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76360>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76360>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76360>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76360>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76360>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76360>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76360>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76360>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76360>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76360>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76360>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76360>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76360>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76360>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76360>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76360>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76360>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76360>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Providers
76360>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76360>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76360>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76360>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76360>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76360>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76360>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76360>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76360>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76360>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76360>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76360>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76360>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76360>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76360>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76360>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76360>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76360>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76360>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76360>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76360>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76360>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76360>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76360>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76360>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Provider types
76360>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76360>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76360>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76360>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76360>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76360>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76360>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76360>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76360>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76360>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76360>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76360>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76360>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76360>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76360>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76360>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76360>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76360>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// KP_MODE
76360>>>>>>>>>>>>>>>>>// KP_MODE
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76360>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76360>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76360>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76360>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76360>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76360>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76360>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76360>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76360>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76360>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76360>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76360>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76360>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76360>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76360>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76360>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76360>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76360>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76360>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76360>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76360>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76360>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76360>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76360>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76360>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76360>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76360>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76360>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76360>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76360>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76360>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76360>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76360>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76360>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76360>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76360>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76360>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76360>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76360>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76360>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76360>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76360>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76360>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76360>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76360>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76360>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76360>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// key BLOB types
76360>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76360>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76360>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76360>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76360>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76360>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76360>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76360>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// KP_PADDING
76360>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76360>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76360>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76360>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76360>>>>>>>>>>>>>>>>>    UChar    bType
76360>>>>>>>>>>>>>>>>>    UChar    bVersion
76360>>>>>>>>>>>>>>>>>    UShort   reserved
76360>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76360>>>>>>>>>>>>>>>>>End_Struct
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76360>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76360>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76360>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76360>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76360>>>>>>>>>>>>>>>>>End_Struct
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76360>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76360>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76360>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76360>>>>>>>>>>>>>>>>>    DWord cbInnerString
76360>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76360>>>>>>>>>>>>>>>>>    DWord cbOuterString
76360>>>>>>>>>>>>>>>>>End_Struct
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76360>>>>>>>>>>>>>>>>>    UChar   bType
76360>>>>>>>>>>>>>>>>>    UChar   bVersion
76360>>>>>>>>>>>>>>>>>    Short   reserved
76360>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76360>>>>>>>>>>>>>>>>>End_Struct
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>Struct CryptoBlob
76360>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76360>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76360>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76360>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76360>>>>>>>>>>>>>>>>>End_Struct
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76360>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76361>>>>>>>>>>>>>>>>>
76361>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76361>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76363>>>>>>>>>>>>>>>>>    
76363>>>>>>>>>>>>>>>>>    Boolean bResult
76363>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76363>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76363>>>>>>>>>>>>>>>>>
76363>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76364>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76365>>>>>>>>>>>>>>>>>    
76365>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76366>>>>>>>>>>>>>>>>>
76366>>>>>>>>>>>>>>>>>    Function_Return bResult
76367>>>>>>>>>>>>>>>>>End_Function
76368>>>>>>>>>>>>>>>>>
76368>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76369>>>>>>>>>>>>>>>>>
76369>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76370>>>>>>>>>>>>>>>>>
76370>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76371>>>>>>>>>>>>>>>>>
76371>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76372>>>>>>>>>>>>>>>>>
76372>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76373>>>>>>>>>>>>>>>>>
76373>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76374>>>>>>>>>>>>>>>>>
76374>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76375>>>>>>>>>>>>>>>>>
76375>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76376>>>>>>>>>>>>>>>>>
76376>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76377>>>>>>>>>>>>>>>>>    
76377>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76378>>>>>>>>>>>>>>>>>
76378>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76379>>>>>>>>>>>>>>>>>
76379>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76380>>>>>>>>>>>>>>>>>
76380>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76381>>>>>>>>>>>>>>>>>    
76381>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76382>>>>>>>>>>>>>>>>>    
76382>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76383>>>>>>>>>>>>>>>>>    
76383>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76384>>>>>>>>>>>>>>>
76384>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76385>>>>>>>>>>>>>>>    
76385>>>>>>>>>>>>>>>    Procedure Construct_Object
76387>>>>>>>>>>>>>>>        Forward Send Construct_Object
76389>>>>>>>>>>>>>>>        
76389>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76390>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76391>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76392>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76393>>>>>>>>>>>>>>>        
76393>>>>>>>>>>>>>>>        // Private properties
76393>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76394>>>>>>>>>>>>>>>        
76394>>>>>>>>>>>>>>>        // Block cipher properties
76394>>>>>>>>>>>>>>>        Property UChar[]    paKey
76395>>>>>>>>>>>>>>>        Property UChar[]    paIV
76396>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76397>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76398>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76399>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76400>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76401>>>>>>>>>>>>>>>    End_Procedure
76402>>>>>>>>>>>>>>>    
76402>>>>>>>>>>>>>>>    
76402>>>>>>>>>>>>>>>    // Acquire key container handle
76402>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76404>>>>>>>>>>>>>>>        Integer iProvider
76404>>>>>>>>>>>>>>>        WString wProvider
76404>>>>>>>>>>>>>>>        Handle hProv
76404>>>>>>>>>>>>>>>        Boolean bOk
76404>>>>>>>>>>>>>>>        Pointer pProv
76404>>>>>>>>>>>>>>>        
76404>>>>>>>>>>>>>>>        Move 0 to hProv
76405>>>>>>>>>>>>>>>        Get piProvider to iProvider
76406>>>>>>>>>>>>>>>        Get psProvider to wProvider
76407>>>>>>>>>>>>>>>        
76407>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76407>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76409>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76410>>>>>>>>>>>>>>>        End
76410>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>        Else Begin
76411>>>>>>>>>>>>>>>            Move 0 to pProv
76412>>>>>>>>>>>>>>>        End
76412>>>>>>>>>>>>>>>>
76412>>>>>>>>>>>>>>>        
76412>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76412>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76413>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76415>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76416>>>>>>>>>>>>>>>        End
76416>>>>>>>>>>>>>>>>
76416>>>>>>>>>>>>>>>        
76416>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76418>>>>>>>>>>>>>>>            // Fallback to original
76418>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76419>>>>>>>>>>>>>>>            
76419>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76421>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76422>>>>>>>>>>>>>>>            End
76422>>>>>>>>>>>>>>>>
76422>>>>>>>>>>>>>>>        End
76422>>>>>>>>>>>>>>>>
76422>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76423>>>>>>>>>>>>>>>        
76423>>>>>>>>>>>>>>>        Function_Return hProv
76424>>>>>>>>>>>>>>>    End_Function
76425>>>>>>>>>>>>>>>    
76425>>>>>>>>>>>>>>>    // Releases key container handle
76425>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76427>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76428>>>>>>>>>>>>>>>    End_Function
76429>>>>>>>>>>>>>>>    
76429>>>>>>>>>>>>>>>    // Creates hash object
76429>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76431>>>>>>>>>>>>>>>        Integer iAlgorithm
76431>>>>>>>>>>>>>>>        Handle hHash
76431>>>>>>>>>>>>>>>        Boolean bOk
76431>>>>>>>>>>>>>>>        
76431>>>>>>>>>>>>>>>        Move 0 to hHash
76432>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76433>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76434>>>>>>>>>>>>>>>        
76434>>>>>>>>>>>>>>>        Function_Return hHash
76435>>>>>>>>>>>>>>>    End_Function
76436>>>>>>>>>>>>>>>    
76436>>>>>>>>>>>>>>>    // Destroys the hash object
76436>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76438>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76439>>>>>>>>>>>>>>>    End_Function
76440>>>>>>>>>>>>>>>    
76440>>>>>>>>>>>>>>>    // Adds data to hash object
76440>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76442>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76443>>>>>>>>>>>>>>>    End_Function
76444>>>>>>>>>>>>>>>    
76444>>>>>>>>>>>>>>>    // Generates session key
76444>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76446>>>>>>>>>>>>>>>        Integer iAlgorithm
76446>>>>>>>>>>>>>>>        Handle hKey
76446>>>>>>>>>>>>>>>        Boolean bOk
76446>>>>>>>>>>>>>>>        
76446>>>>>>>>>>>>>>>        Move 0 to hKey
76447>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76448>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76449>>>>>>>>>>>>>>>        
76449>>>>>>>>>>>>>>>        Function_Return hKey
76450>>>>>>>>>>>>>>>    End_Function
76451>>>>>>>>>>>>>>>    
76451>>>>>>>>>>>>>>>    // Imports a plain text key
76451>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76453>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76453>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76453>>>>>>>>>>>>>>>        Boolean   bSuccess
76453>>>>>>>>>>>>>>>        Handle    hKey
76453>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76453>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76454>>>>>>>>>>>>>>>        Integer iVoid
76454>>>>>>>>>>>>>>>        
76454>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76455>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76456>>>>>>>>>>>>>>>        
76456>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76457>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76458>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76459>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76460>>>>>>>>>>>>>>>        
76460>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76461>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76462>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76463>>>>>>>>>>>>>>>        
76463>>>>>>>>>>>>>>>        Move 0 to hKey
76464>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76465>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76467>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76468>>>>>>>>>>>>>>>        End
76468>>>>>>>>>>>>>>>>
76468>>>>>>>>>>>>>>>        
76468>>>>>>>>>>>>>>>        Function_Return hKey
76469>>>>>>>>>>>>>>>    End_Function
76470>>>>>>>>>>>>>>>    
76470>>>>>>>>>>>>>>>    // Destroys the key
76470>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76472>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76473>>>>>>>>>>>>>>>    End_Function
76474>>>>>>>>>>>>>>>    
76474>>>>>>>>>>>>>>>    // Retrieves key data
76474>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76476>>>>>>>>>>>>>>>        Integer iBuffer iLen
76476>>>>>>>>>>>>>>>        Boolean bOk
76476>>>>>>>>>>>>>>>        
76476>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76477>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76478>>>>>>>>>>>>>>>        Function_Return iBuffer
76479>>>>>>>>>>>>>>>    End_Function
76480>>>>>>>>>>>>>>>    
76480>>>>>>>>>>>>>>>    // Retrieves a hash value
76480>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76482>>>>>>>>>>>>>>>        UChar[] ucHash
76483>>>>>>>>>>>>>>>        Integer liResult
76483>>>>>>>>>>>>>>>        DWord   dwDataLen
76483>>>>>>>>>>>>>>>        
76483>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76484>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76485>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76488>>>>>>>>>>>>>>>        
76488>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76489>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76490>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76493>>>>>>>>>>>>>>>        
76493>>>>>>>>>>>>>>>        Function_Return ucHash
76494>>>>>>>>>>>>>>>    End_Function
76495>>>>>>>>>>>>>>>
76495>>>>>>>>>>>>>>>    // Encrypts data
76495>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76497>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76497>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76497>>>>>>>>>>>>>>>        Boolean bOk
76497>>>>>>>>>>>>>>>        
76497>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76498>>>>>>>>>>>>>>>        If (hProv) Begin
76500>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76501>>>>>>>>>>>>>>>            If (hHash) Begin
76503>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76504>>>>>>>>>>>>>>>                If (bOk) Begin
76506>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76507>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76508>>>>>>>>>>>>>>>                End
76508>>>>>>>>>>>>>>>>
76508>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76509>>>>>>>>>>>>>>>            End
76509>>>>>>>>>>>>>>>>
76509>>>>>>>>>>>>>>>            
76509>>>>>>>>>>>>>>>            If (hKey) Begin
76511>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76511>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76512>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76513>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76514>>>>>>>>>>>>>>>                
76514>>>>>>>>>>>>>>>                //  Reserve space in string
76514>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76516>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76517>>>>>>>>>>>>>>>                End
76517>>>>>>>>>>>>>>>>
76517>>>>>>>>>>>>>>>                
76517>>>>>>>>>>>>>>>                //  Call to really decrypt
76517>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76518>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76518>>>>>>>>>>>>>>>                //Move "" to sData
76518>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76518>>>>>>>>>>>>>>>                //End
76518>>>>>>>>>>>>>>>                
76518>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76519>>>>>>>>>>>>>>>            End 
76519>>>>>>>>>>>>>>>>
76519>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76520>>>>>>>>>>>>>>>        End 
76520>>>>>>>>>>>>>>>>
76520>>>>>>>>>>>>>>>        Function_Return ucData
76521>>>>>>>>>>>>>>>    End_Function
76522>>>>>>>>>>>>>>>    
76522>>>>>>>>>>>>>>>    // Decrypts data
76522>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76524>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76524>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76524>>>>>>>>>>>>>>>        Boolean bOk
76524>>>>>>>>>>>>>>>        
76524>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76525>>>>>>>>>>>>>>>        If (hProv) Begin
76527>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76528>>>>>>>>>>>>>>>            If (hHash) Begin
76530>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76531>>>>>>>>>>>>>>>                If (bOk) Begin
76533>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76534>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76535>>>>>>>>>>>>>>>                End
76535>>>>>>>>>>>>>>>>
76535>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76536>>>>>>>>>>>>>>>            End
76536>>>>>>>>>>>>>>>>
76536>>>>>>>>>>>>>>>            
76536>>>>>>>>>>>>>>>            If (hKey) Begin
76538>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76539>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76540>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76540>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76542>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76543>>>>>>>>>>>>>>>                End
76543>>>>>>>>>>>>>>>>
76543>>>>>>>>>>>>>>>                
76543>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76544>>>>>>>>>>>>>>>            End
76544>>>>>>>>>>>>>>>>
76544>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76545>>>>>>>>>>>>>>>        End
76545>>>>>>>>>>>>>>>>
76545>>>>>>>>>>>>>>>        Function_Return ucData
76546>>>>>>>>>>>>>>>    End_Function
76547>>>>>>>>>>>>>>>    
76547>>>>>>>>>>>>>>>    // Creates a key
76547>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76549>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76549>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76549>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76549>>>>>>>>>>>>>>>        Boolean bOk
76549>>>>>>>>>>>>>>>        Handle hKey
76549>>>>>>>>>>>>>>>        UChar[] aKey
76550>>>>>>>>>>>>>>>
76550>>>>>>>>>>>>>>>        Get paKey to aKey
76551>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76552>>>>>>>>>>>>>>>        Get piKeyType to iType
76553>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76554>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76555>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76556>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76557>>>>>>>>>>>>>>>        
76557>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76558>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76564>>>>>>>>>>>>>>>>
76564>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76565>>>>>>>>>>>>>>>        Loop
76566>>>>>>>>>>>>>>>>
76566>>>>>>>>>>>>>>>        
76566>>>>>>>>>>>>>>>        Move 0 to hKey
76567>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76568>>>>>>>>>>>>>>>        Function_Return hKey
76569>>>>>>>>>>>>>>>    End_Function
76570>>>>>>>>>>>>>>>    
76570>>>>>>>>>>>>>>>    // Sets the key parameters
76570>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76572>>>>>>>>>>>>>>>        Integer iPadding iMode
76572>>>>>>>>>>>>>>>        Boolean bOk
76572>>>>>>>>>>>>>>>        UChar[] aIV
76573>>>>>>>>>>>>>>>        
76573>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76573>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76573>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76573>>>>>>>>>>>>>>>        //Loop
76573>>>>>>>>>>>>>>>
76573>>>>>>>>>>>>>>>        // Set initialization vector
76573>>>>>>>>>>>>>>>        Get paIV to aIV
76574>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76575>>>>>>>>>>>>>>>        If (bOk) Begin
76577>>>>>>>>>>>>>>>            // Set padding
76577>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76578>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76579>>>>>>>>>>>>>>>            If (bOk) Begin
76581>>>>>>>>>>>>>>>                // Set move
76581>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76582>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76583>>>>>>>>>>>>>>>            End
76583>>>>>>>>>>>>>>>>
76583>>>>>>>>>>>>>>>        End
76583>>>>>>>>>>>>>>>>
76583>>>>>>>>>>>>>>>        Function_Return bOk        
76584>>>>>>>>>>>>>>>    End_Function
76585>>>>>>>>>>>>>>>    
76585>>>>>>>>>>>>>>>    // Encrypts using block cipher
76585>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76587>>>>>>>>>>>>>>>        Handle hProv hKey
76587>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76587>>>>>>>>>>>>>>>        Boolean bOk
76587>>>>>>>>>>>>>>>        
76587>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76588>>>>>>>>>>>>>>>        If (hProv) Begin
76590>>>>>>>>>>>>>>>            // Create key
76590>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76591>>>>>>>>>>>>>>>            If (hKey) Begin
76593>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76594>>>>>>>>>>>>>>>                If (bOk) Begin
76596>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76596>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76597>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76598>>>>>>>>>>>>>>>                    
76598>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76599>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76600>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76601>>>>>>>>>>>>>>>                End
76601>>>>>>>>>>>>>>>>
76601>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76602>>>>>>>>>>>>>>>            End
76602>>>>>>>>>>>>>>>>
76602>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76603>>>>>>>>>>>>>>>        End
76603>>>>>>>>>>>>>>>>
76603>>>>>>>>>>>>>>>        Function_Return ucData
76604>>>>>>>>>>>>>>>    End_Function
76605>>>>>>>>>>>>>>>    
76605>>>>>>>>>>>>>>>    // Decrypts using block cipher
76605>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76607>>>>>>>>>>>>>>>        Handle hProv hKey
76607>>>>>>>>>>>>>>>        Integer iLen
76607>>>>>>>>>>>>>>>        Boolean bOk
76607>>>>>>>>>>>>>>>        
76607>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76608>>>>>>>>>>>>>>>        If (hProv) Begin
76610>>>>>>>>>>>>>>>            // Create key
76610>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76611>>>>>>>>>>>>>>>            If (hKey) Begin
76613>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76614>>>>>>>>>>>>>>>                If (bOk) Begin
76616>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76617>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76618>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76619>>>>>>>>>>>>>>>                End
76619>>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76620>>>>>>>>>>>>>>>            End
76620>>>>>>>>>>>>>>>>
76620>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76621>>>>>>>>>>>>>>>        End
76621>>>>>>>>>>>>>>>>
76621>>>>>>>>>>>>>>>        Function_Return ucData
76622>>>>>>>>>>>>>>>    End_Function
76623>>>>>>>>>>>>>>>    
76623>>>>>>>>>>>>>>>    
76623>>>>>>>>>>>>>>>    //  Generates random data.
76623>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76625>>>>>>>>>>>>>>>        Handle hProv
76625>>>>>>>>>>>>>>>        UChar[] uaResult
76626>>>>>>>>>>>>>>>        Boolean bRes
76626>>>>>>>>>>>>>>>        
76626>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76627>>>>>>>>>>>>>>>        
76627>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76628>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76629>>>>>>>>>>>>>>>        
76629>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76630>>>>>>>>>>>>>>>        
76630>>>>>>>>>>>>>>>        Function_Return uaResult
76631>>>>>>>>>>>>>>>    End_Function
76632>>>>>>>>>>>>>>>    
76632>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76632>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76634>>>>>>>>>>>>>>>        String sResult
76634>>>>>>>>>>>>>>>        UChar[] ucData
76635>>>>>>>>>>>>>>>        Pointer pBase64
76635>>>>>>>>>>>>>>>        Integer iVoid
76635>>>>>>>>>>>>>>>        
76635>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76636>>>>>>>>>>>>>>>        
76636>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76637>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76638>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76639>>>>>>>>>>>>>>>        
76639>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76640>>>>>>>>>>>>>>>    End_Function
76641>>>>>>>>>>>>>>>    
76641>>>>>>>>>>>>>>>End_Class
76642>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76642>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76642>>>>>>>>>>>>>>>//>
76642>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76642>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76642>>>>>>>>>>>>>>>//>
76642>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76642>>>>>>>>>>>>>>>//> strings.
76642>>>>>>>>>>>>>>>//>
76642>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76642>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76642>>>>>>>>>>>>>>>//>
76642>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76642>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76642>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76642>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>Use VdfBase.pkg
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76642>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76643>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76644>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76645>>>>>>>>>>>>>>>
76645>>>>>>>>>>>>>>>// Structure
76645>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76645>>>>>>>>>>>>>>>    Pointer pData
76645>>>>>>>>>>>>>>>    Integer iLength
76645>>>>>>>>>>>>>>>End_Struct 
76645>>>>>>>>>>>>>>>
76645>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76645>>>>>>>>>>>>>>>
76645>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76647>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76648>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76651>>>>>>>>>>>>>>>        Address pBase64
76651>>>>>>>>>>>>>>>        String sResult
76651>>>>>>>>>>>>>>>        Integer iVoid
76651>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76652>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76653>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76654>>>>>>>>>>>>>>>        Function_Return sResult
76655>>>>>>>>>>>>>>>    End_Function
76656>>>>>>>>>>>>>>>
76656>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76659>>>>>>>>>>>>>>>        Address pBinary
76659>>>>>>>>>>>>>>>        String sBinary
76659>>>>>>>>>>>>>>>        Integer iVoid iLen
76659>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76660>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76661>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76662>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76663>>>>>>>>>>>>>>>        Function_Return sBinary
76664>>>>>>>>>>>>>>>    End_Function
76665>>>>>>>>>>>>>>>
76665>>>>>>>>>>>>>>>End_Object
76666>>>>>>>>>>>>>Use MSSqldrv.pkg
76666>>>>>>>>>>>>>Use db2_drv.pkg
76666>>>>>>>>>>>>>Use odbc_drv.pkg
76666>>>>>>>>>>>>>Use DFBtrDrv.pkg
76666>>>>>>>>>>>>>Use vWin32fh.pkg
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76666>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76666>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76666>>>>>>>>>>>>>// Note: If a new type is added to the list,
76666>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76666>>>>>>>>>>>>>//       so that it is filled with all SQL
76666>>>>>>>>>>>>>//       keywords for that new type.
76666>>>>>>>>>>>>>Enum_List  
76666>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76666>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76666>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76666>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76666>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76666>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76666>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76666>>>>>>>>>>>>>End_Enum_List
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76666>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76666>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76666>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76666>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76666>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76666>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76666>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76666>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76666>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// SQLConnection.ini constants:
76666>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76666>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76666>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76666>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// DF 19 ini-file settings:
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76666>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76666>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76666>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76666>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76666>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76666>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76666>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76666>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76666>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76666>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// Database Update Framework extended settings:
76666>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76666>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76666>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76666>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76666>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76666>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76666>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76666>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Struct tSQLConnection
76666>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76666>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76666>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76666>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76666>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76666>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76666>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76666>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76666>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76666>>>>>>>>>>>>>    String sPassword                // 10. Password
76666>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76666>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76666>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76666>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76666>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76666>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76666>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76666>>>>>>>>>>>>>End_Struct
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Struct tFilelist
76666>>>>>>>>>>>>>    String sRootName
76666>>>>>>>>>>>>>    String sLogicalName
76666>>>>>>>>>>>>>    String sDisplayName    
76666>>>>>>>>>>>>>    String sNoDriverRootname
76666>>>>>>>>>>>>>    String sDriver
76666>>>>>>>>>>>>>    Handle hTable
76666>>>>>>>>>>>>>    Boolean bIsSystemFile 
76666>>>>>>>>>>>>>    Boolean bErrorOpening
76666>>>>>>>>>>>>>    Boolean bIsAlias
76666>>>>>>>>>>>>>End_Struct
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Struct tFilelistLogicalName
76666>>>>>>>>>>>>>    String sLogicalName
76666>>>>>>>>>>>>>    String sNoDriverRootname
76666>>>>>>>>>>>>>    String sRootName
76666>>>>>>>>>>>>>    String sDisplayName    
76666>>>>>>>>>>>>>    String sDriver
76666>>>>>>>>>>>>>    Handle hTable
76666>>>>>>>>>>>>>    Boolean bIsSystemFile 
76666>>>>>>>>>>>>>    Boolean bErrorOpening
76666>>>>>>>>>>>>>    Boolean bIsAlias
76666>>>>>>>>>>>>>End_Struct
76666>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76666>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76666>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76666>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76666>>>>>>>>>>>>>
76666>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76666>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLScriptArray
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76667>>>>>>>>>>>>>    Integer iOrgArgumentSize
76667>>>>>>>>>>>>>    String[] sSQLScriptArray
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLCollation
76667>>>>>>>>>>>>>    String sCollation
76667>>>>>>>>>>>>>    String sDescription
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSqlErrorArray
76667>>>>>>>>>>>>>    String[]  sSqlErrorArray
76667>>>>>>>>>>>>>    String[]  sSqlStatementArray
76667>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSqlColumnNew
76667>>>>>>>>>>>>>    String  sBaseColumnName
76667>>>>>>>>>>>>>    String  sBaseTableName
76667>>>>>>>>>>>>>    String  sLabel
76667>>>>>>>>>>>>>    Integer iSqlType
76667>>>>>>>>>>>>>    Integer iSize
76667>>>>>>>>>>>>>    Integer iPrecision
76667>>>>>>>>>>>>>    Integer iDFType
76667>>>>>>>>>>>>>    Integer iDFNativeType
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tColumnType
76667>>>>>>>>>>>>>    Integer iSQLType
76667>>>>>>>>>>>>>    String  sSQLType
76667>>>>>>>>>>>>>    Boolean bCanEditSize
76667>>>>>>>>>>>>>    Integer iDefaultSize
76667>>>>>>>>>>>>>    Integer iMinSize
76667>>>>>>>>>>>>>    Number  nMaxSize
76667>>>>>>>>>>>>>    String  sDataFlexType
76667>>>>>>>>>>>>>    Integer iDataFlexType
76667>>>>>>>>>>>>>    Boolean bNativeDataType
76667>>>>>>>>>>>>>    String  sPrecision
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76667>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76667>>>>>>>>>>>>>// keywords.
76667>>>>>>>>>>>>>Struct tSQLKeyWords
76667>>>>>>>>>>>>>    Integer iSQLWord
76667>>>>>>>>>>>>>    Integer iSQLDbType
76667>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLRelation
76667>>>>>>>>>>>>>    Integer iFileNumber
76667>>>>>>>>>>>>>    Integer iFieldNumber
76667>>>>>>>>>>>>>    String  sFileName
76667>>>>>>>>>>>>>    String  sFieldName
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLLoggedInUser
76667>>>>>>>>>>>>>    String sUser
76667>>>>>>>>>>>>>    String sProgram
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76667>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76667>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76667>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76667>>>>>>>>>>>>>// Note: If a new type is added to the list,
76667>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76667>>>>>>>>>>>>>//       so that it is filled with all SQL
76667>>>>>>>>>>>>>//       keywords for that new type.
76667>>>>>>>>>>>>>Enum_List
76667>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76667>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76667>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76667>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76667>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76667>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76667>>>>>>>>>>>>>End_Enum_List
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76667>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76667>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76667>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76667>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76667>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76667>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76667>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76667>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76667>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76667>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76667>>>>>>>>>>>>>Enum_List
76667>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76667>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76667>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76667>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76667>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76667>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76667>>>>>>>>>>>>>End_Enum_List
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76667>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76667>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// These are not defined pre DF 18:
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLIntTableInfo
76667>>>>>>>>>>>>>    String sDriverName
76667>>>>>>>>>>>>>    String sServerName
76667>>>>>>>>>>>>>    String sDatabaseName
76667>>>>>>>>>>>>>    String sSchemaName
76667>>>>>>>>>>>>>    Boolean bRecnumTable
76667>>>>>>>>>>>>>    Integer iPrimaryIndex
76667>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76667>>>>>>>>>>>>>    String sTableCharacterFormat
76667>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76667>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76667>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76667>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76667>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76667>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76667>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76667>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76667>>>>>>>>>>>>>    String sFileIndexTablespace
76667>>>>>>>>>>>>>    String sFileLongTablespace
76667>>>>>>>>>>>>>    String sTableTablespace
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76667>>>>>>>>>>>>>    Integer iFieldNumber
76667>>>>>>>>>>>>>    Integer iFieldIndex
76667>>>>>>>>>>>>>    Integer iFieldRelatedFile
76667>>>>>>>>>>>>>    Integer iFieldRelatedField
76667>>>>>>>>>>>>>    Integer iIndexNumber
76667>>>>>>>>>>>>>    Integer iIndexNumberSegments
76667>>>>>>>>>>>>>    Integer iIndexSegmentField1
76667>>>>>>>>>>>>>    Integer iIndexSegmentField2
76667>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76667>>>>>>>>>>>>>    String  sIndexName
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIColumn
76667>>>>>>>>>>>>>    Integer iFieldNumber
76667>>>>>>>>>>>>>    String  sFieldName
76667>>>>>>>>>>>>>    Integer iType
76667>>>>>>>>>>>>>    String  sType
76667>>>>>>>>>>>>>    Integer iLength
76667>>>>>>>>>>>>>    Integer iPrecision
76667>>>>>>>>>>>>>    Integer iOptions
76667>>>>>>>>>>>>>    Boolean bIsSQLType
76667>>>>>>>>>>>>>    Boolean bAllowNULL
76667>>>>>>>>>>>>>    String  sDefaultValue
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIColumnCompare
76667>>>>>>>>>>>>>    Integer iFieldNumber
76667>>>>>>>>>>>>>    // FROM database:
76667>>>>>>>>>>>>>    Boolean bExistsFrom
76667>>>>>>>>>>>>>    String  sFieldNameFrom
76667>>>>>>>>>>>>>    Integer iTypeFrom
76667>>>>>>>>>>>>>    String  sTypeFrom
76667>>>>>>>>>>>>>    Integer iLengthFrom
76667>>>>>>>>>>>>>    Integer iPrecisionFrom
76667>>>>>>>>>>>>>    Integer iOptionsFrom
76667>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76667>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76667>>>>>>>>>>>>>    String  sDefaultValueFrom
76667>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76667>>>>>>>>>>>>>    Boolean bCancelFrom
76667>>>>>>>>>>>>>    Boolean bErrorFrom
76667>>>>>>>>>>>>>    // TO database:
76667>>>>>>>>>>>>>    Boolean bExistsTo
76667>>>>>>>>>>>>>    Integer iFieldNumberTo
76667>>>>>>>>>>>>>    String  sFieldNameTo
76667>>>>>>>>>>>>>    Integer iTypeTo
76667>>>>>>>>>>>>>    String  sTypeTo
76667>>>>>>>>>>>>>    Integer iLengthTo
76667>>>>>>>>>>>>>    Integer iPrecisionTo
76667>>>>>>>>>>>>>    Integer iOptionsTo
76667>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76667>>>>>>>>>>>>>    Boolean bAllowNULLTo
76667>>>>>>>>>>>>>    String  sDefaultValueTo
76667>>>>>>>>>>>>>    Boolean bShouldChangeTo
76667>>>>>>>>>>>>>    Boolean bCancelTo
76667>>>>>>>>>>>>>    Boolean bErrorTo
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIRelation
76667>>>>>>>>>>>>>    Handle  hTableFrom
76667>>>>>>>>>>>>>    Integer iColumnFrom
76667>>>>>>>>>>>>>    Handle  hTableTo
76667>>>>>>>>>>>>>    Integer iColumnTo
76667>>>>>>>>>>>>>    String  sLogicalNameFrom
76667>>>>>>>>>>>>>    String  sLogicalNameTo
76667>>>>>>>>>>>>>    String  sFieldNameFrom
76667>>>>>>>>>>>>>    String  sFieldNameTo
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIRelationCompare
76667>>>>>>>>>>>>>    // Common:
76667>>>>>>>>>>>>>    Handle  hTableFrom
76667>>>>>>>>>>>>>    Integer iColumnFrom
76667>>>>>>>>>>>>>    Handle  hTableTo
76667>>>>>>>>>>>>>    Integer iColumnTo
76667>>>>>>>>>>>>>    // FROM database:
76667>>>>>>>>>>>>>    Boolean bExistsFrom
76667>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76667>>>>>>>>>>>>>    String  sLogicalNameTo_From
76667>>>>>>>>>>>>>    String  sFieldNameFrom_From
76667>>>>>>>>>>>>>    String  sFieldNameTo_From
76667>>>>>>>>>>>>>    Boolean bShouldChange_From
76667>>>>>>>>>>>>>    Boolean bCancel_From
76667>>>>>>>>>>>>>    Boolean bError_From
76667>>>>>>>>>>>>>    // TO database:
76667>>>>>>>>>>>>>    Boolean bExistsTo
76667>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76667>>>>>>>>>>>>>    String  sLogicalNameTo_To
76667>>>>>>>>>>>>>    String  sFieldNameFrom_To
76667>>>>>>>>>>>>>    String  sFieldNameTo_To
76667>>>>>>>>>>>>>    Boolean bShouldChange_To
76667>>>>>>>>>>>>>    Boolean bCancel_To
76667>>>>>>>>>>>>>    Boolean bError_To
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIIndexSegment
76667>>>>>>>>>>>>>    Integer iFieldNumber
76667>>>>>>>>>>>>>    String  sFieldName
76667>>>>>>>>>>>>>    Boolean bUppercase
76667>>>>>>>>>>>>>    Boolean bAscending
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIIndex
76667>>>>>>>>>>>>>    Integer iIndexNumber
76667>>>>>>>>>>>>>    Integer iPrimaryIndex
76667>>>>>>>>>>>>>    String  sSQLIndexName
76667>>>>>>>>>>>>>    Integer iSQLIndexType
76667>>>>>>>>>>>>>    Boolean bIsSQLClustered
76667>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPIIndexCompare
76667>>>>>>>>>>>>>    // Common:
76667>>>>>>>>>>>>>    Integer iIndexNumber
76667>>>>>>>>>>>>>    // FROM database:
76667>>>>>>>>>>>>>    Boolean bExistsFrom
76667>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76667>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76667>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76667>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76667>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76667>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76667>>>>>>>>>>>>>    Boolean bCancelFrom
76667>>>>>>>>>>>>>    Boolean bErrorFrom
76667>>>>>>>>>>>>>    // TO database:
76667>>>>>>>>>>>>>    Boolean bExistsTo
76667>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76667>>>>>>>>>>>>>    String  sSQLIndexNameTo
76667>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76667>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76667>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76667>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76667>>>>>>>>>>>>>    Boolean bShouldChangeTo
76667>>>>>>>>>>>>>    Boolean bCancelTo
76667>>>>>>>>>>>>>    Boolean bErrorTo
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPITableNameInfo
76667>>>>>>>>>>>>>    Integer iTableNumber
76667>>>>>>>>>>>>>    String  sRootName
76667>>>>>>>>>>>>>    String  sLogicalName
76667>>>>>>>>>>>>>    String  sDisplayName
76667>>>>>>>>>>>>>    String  sDriverID
76667>>>>>>>>>>>>>    Boolean bIsAlias
76667>>>>>>>>>>>>>    Boolean bIsSQL
76667>>>>>>>>>>>>>    Boolean bIsSystemFile
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76667>>>>>>>>>>>>>    Integer iTableNumber
76667>>>>>>>>>>>>>    // FROM
76667>>>>>>>>>>>>>    Boolean bExistsFrom
76667>>>>>>>>>>>>>    String  sRootNameFrom
76667>>>>>>>>>>>>>    String  sLogicalNameFrom
76667>>>>>>>>>>>>>    String  sDisplayNameFrom
76667>>>>>>>>>>>>>    String  sDriverIDFrom
76667>>>>>>>>>>>>>    Boolean bIsAliasFrom
76667>>>>>>>>>>>>>    Boolean bIsSQLFrom
76667>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76667>>>>>>>>>>>>>    // TO database:
76667>>>>>>>>>>>>>    Boolean bExistsTo
76667>>>>>>>>>>>>>    String  sRootNameTo
76667>>>>>>>>>>>>>    String  sLogicalNameTo
76667>>>>>>>>>>>>>    String  sDisplayNameTo
76667>>>>>>>>>>>>>    String  sDriverIDTo
76667>>>>>>>>>>>>>    Boolean bIsAliasTo
76667>>>>>>>>>>>>>    Boolean bIsSQLTo
76667>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPITable
76667>>>>>>>>>>>>>    Handle hTable
76667>>>>>>>>>>>>>    Boolean bFromTable
76667>>>>>>>>>>>>>    Boolean bToTable
76667>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76667>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76667>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76667>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76667>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76667>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76667>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76667>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76667>>>>>>>>>>>>>    Boolean bShouldChange
76667>>>>>>>>>>>>>    Boolean bCancel
76667>>>>>>>>>>>>>    Boolean bError
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPITableCompare
76667>>>>>>>>>>>>>    Handle hTable
76667>>>>>>>>>>>>>    // FROM database:
76667>>>>>>>>>>>>>    Boolean bExistsFrom
76667>>>>>>>>>>>>>    // TO database:
76667>>>>>>>>>>>>>    Boolean bExistsTo
76667>>>>>>>>>>>>>    // Both:
76667>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76667>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76667>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76667>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76667>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76667>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76667>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76667>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76667>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76667>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76667>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Struct tAPITableBooleans
76667>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76667>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76667>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76667>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76667>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76667>>>>>>>>>>>>>End_Struct
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76667>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76667>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76667>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76667>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76667>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76667>>>>>>>>>>>>>Enum_List
76667>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76667>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76667>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76667>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76667>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76667>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76667>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76667>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76667>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76667>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76667>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76667>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76667>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76667>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76667>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76667>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76667>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76667>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76667>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76667>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76667>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76667>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76667>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76667>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76667>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76667>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76667>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76667>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76667>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76667>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76667>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76667>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76667>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76667>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76667>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76667>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76667>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76667>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76667>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76667>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76667>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76667>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76667>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76667>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76667>>>>>>>>>>>>>End_Enum_List
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>>>
76667>>>>>>>>>>>
76667>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76668>>>>>>>>>>>
76668>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76670>>>>>>>>>>>        Handle hoSQLManagerMT
76670>>>>>>>>>>>
76670>>>>>>>>>>>        Property String private.psUseDatabase ""
76671>>>>>>>>>>>
76671>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76671>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76672>>>>>>>>>>>        Property Integer private.piCurrentField 0
76673>>>>>>>>>>>
76673>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76674>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76675>>>>>>>>>>>
76675>>>>>>>>>>>        Property Handle phoSQLManagerMT
76676>>>>>>>>>>>
76676>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76677>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76678>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76679>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76680>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76681>>>>>>>>>>>
76681>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76682>>>>>>>>>>>
76682>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76683>>>>>>>>>>>        Property String[] paSQLFetchResults
76684>>>>>>>>>>>
76684>>>>>>>>>>>        // Error handling
76684>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76685>>>>>>>>>>>        Property Boolean pbSqlError False
76686>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76687>>>>>>>>>>>        Property Boolean pbProcessingError False
76688>>>>>>>>>>>
76688>>>>>>>>>>>        // Statistics on query
76688>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76689>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76690>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76691>>>>>>>>>>>        Property Integer piColumns 0
76692>>>>>>>>>>>        Property Integer piRows 0
76693>>>>>>>>>>>        Property Integer piRowType 0
76694>>>>>>>>>>>        Property String[] paQueryMessages
76695>>>>>>>>>>>        Property String psSQLStatementString
76696>>>>>>>>>>>
76696>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76697>>>>>>>>>>>
76697>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76698>>>>>>>>>>>
76698>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76698>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76698>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76698>>>>>>>>>>>        Property Integer piChunkMax 500
76699>>>>>>>>>>>
76699>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76699>>>>>>>>>>>        Send SetupSQLKeywordArray
76700>>>>>>>>>>>    End_Procedure
76701>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76701>>>>>>>>>>>>
76701>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76703>>>>>>>>>>>>    Integer iStart iEnd
76703>>>>>>>>>>>>    String sRetval
76703>>>>>>>>>>>>
76703>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76704>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76705>>>>>>>>>>>>    If (iStart = 0) Begin
76707>>>>>>>>>>>>        Function_Return ""
76708>>>>>>>>>>>>    End
76708>>>>>>>>>>>>>
76708>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76709>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76710>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76712>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76713>>>>>>>>>>>>    End
76713>>>>>>>>>>>>>
76713>>>>>>>>>>>>    Else Begin
76714>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76715>>>>>>>>>>>>    End
76715>>>>>>>>>>>>>
76715>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76717>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76718>>>>>>>>>>>>        Decrement iEnd
76719>>>>>>>>>>>>    End
76719>>>>>>>>>>>>>
76719>>>>>>>>>>>>    If (iEnd <> 0) Begin
76721>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76722>>>>>>>>>>>>    End
76722>>>>>>>>>>>>>
76722>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76723>>>>>>>>>>>>
76723>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76724>>>>>>>>>>>>End_Function
76725>>>>>>>>>>>>
76725>>>>>>>>>>>>
76725>>>>>>>>>>>
76725>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76725>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76727>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76729>>>>>>>>>>>            Function_Return (EQ)
76730>>>>>>>>>>>        End
76730>>>>>>>>>>>>
76730>>>>>>>>>>>        Function_Return (GT)
76731>>>>>>>>>>>    End_Function
76732>>>>>>>>>>>
76732>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76732>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76734>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76737>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76740>>>>>>>>>>>
76740>>>>>>>>>>>        Function_Return (EQ)
76741>>>>>>>>>>>    End_Function
76742>>>>>>>>>>>
76742>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76744>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76744>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76745>>>>>>>>>>>        Integer iSize
76745>>>>>>>>>>>
76745>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76746>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76747>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76748>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76749>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76750>>>>>>>>>>>
76750>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76751>>>>>>>>>>>    End_Procedure
76752>>>>>>>>>>>
76752>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76752>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76752>>>>>>>>>>>    // have slightly different wording.
76752>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76752>>>>>>>>>>>    // needs to be done for every keyword group below.
76752>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76754>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76754>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76756>>>>>>>>>>>
76756>>>>>>>>>>>        // This should only be called once; but in case it is
76756>>>>>>>>>>>        // we delete the array first.
76756>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76757>>>>>>>>>>>
76757>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76757>>>>>>>>>>>        //
76757>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76758>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76759>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76760>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76761>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76762>>>>>>>>>>>
76762>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76763>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76764>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76765>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76766>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76767>>>>>>>>>>>
76767>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76768>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76769>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76770>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76771>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76772>>>>>>>>>>>
76772>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76773>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76774>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76775>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76776>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76777>>>>>>>>>>>
76777>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76778>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76779>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76780>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76781>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76782>>>>>>>>>>>
76782>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76783>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76784>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76785>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76786>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76787>>>>>>>>>>>
76787>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76788>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76789>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76790>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76791>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76792>>>>>>>>>>>
76792>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76793>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76794>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76795>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76796>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76797>>>>>>>>>>>
76797>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76798>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76799>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76800>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76801>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76802>>>>>>>>>>>
76802>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76803>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76804>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76805>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76806>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76807>>>>>>>>>>>
76807>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76808>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76809>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76810>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76811>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76812>>>>>>>>>>>
76812>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76813>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76814>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76815>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76816>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76817>>>>>>>>>>>
76817>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76819>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76820>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76821>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76822>>>>>>>>>>>
76822>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76824>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76825>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76826>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76827>>>>>>>>>>>
76827>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76828>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76829>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76830>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76831>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76832>>>>>>>>>>>
76832>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76833>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76834>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76835>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76836>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76837>>>>>>>>>>>
76837>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76838>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76839>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76840>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76841>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76842>>>>>>>>>>>
76842>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76844>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76845>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76846>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76847>>>>>>>>>>>
76847>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76848>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76849>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76850>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76851>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76852>>>>>>>>>>>
76852>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76853>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76854>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76855>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76856>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76857>>>>>>>>>>>
76857>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76858>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76859>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76860>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76861>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76862>>>>>>>>>>>
76862>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76863>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76864>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76865>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76866>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76867>>>>>>>>>>>
76867>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76868>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76869>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76870>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76871>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76872>>>>>>>>>>>
76872>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76873>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76874>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76875>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76876>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76877>>>>>>>>>>>
76877>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76878>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76879>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76880>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76881>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76882>>>>>>>>>>>
76882>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76883>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76884>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76885>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76886>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76887>>>>>>>>>>>
76887>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76888>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76889>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76890>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76891>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76892>>>>>>>>>>>
76892>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76893>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76894>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76895>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76896>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76897>>>>>>>>>>>
76897>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76898>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76899>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76900>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76901>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76902>>>>>>>>>>>
76902>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76903>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76904>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76905>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76906>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76907>>>>>>>>>>>
76907>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76908>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76909>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76910>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76911>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76912>>>>>>>>>>>
76912>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76913>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76914>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76915>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76916>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76917>>>>>>>>>>>
76917>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76918>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76919>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76920>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76921>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76922>>>>>>>>>>>
76922>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76923>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76924>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76925>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76926>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76927>>>>>>>>>>>
76927>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76928>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76929>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76930>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76931>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76932>>>>>>>>>>>
76932>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76933>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76934>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76935>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76936>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76937>>>>>>>>>>>
76937>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76938>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76939>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76940>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76941>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76942>>>>>>>>>>>
76942>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76943>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76944>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76945>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76946>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76947>>>>>>>>>>>
76947>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76948>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76949>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76950>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76951>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76952>>>>>>>>>>>
76952>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76953>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76954>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76955>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76956>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76957>>>>>>>>>>>
76957>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76958>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76959>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76960>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76961>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76962>>>>>>>>>>>
76962>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76963>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76964>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76965>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76966>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76967>>>>>>>>>>>
76967>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76968>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76969>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76970>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76971>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76972>>>>>>>>>>>
76972>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76973>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76974>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76975>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76976>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76977>>>>>>>>>>>
76977>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76977>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76978>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76979>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76980>>>>>>>>>>>
76980>>>>>>>>>>>    End_Procedure
76981>>>>>>>>>>>
76981>>>>>>>>>>>End_Class
76982>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76982>>>>>>>>>>>//****************************************************************************
76982>>>>>>>>>>>// $Module type: Class
76982>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76982>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76982>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76982>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76982>>>>>>>>>>>//
76982>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76982>>>>>>>>>>>//
76982>>>>>>>>>>>// $Rev History:
76982>>>>>>>>>>>//    2015-08-11  Module header created
76982>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76982>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76982>>>>>>>>>>>//                Added better error handling.
76982>>>>>>>>>>>//                Added a decompose message for the connection string.
76982>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76982>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76982>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76982>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76982>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76982>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76982>>>>>>>>>>>//****************************************************************************
76982>>>>>>>>>>>Use cli.pkg
76982>>>>>>>>>>>Use MSSqldrv.pkg
76982>>>>>>>>>>>Use db2_drv.pkg
76982>>>>>>>>>>>Use odbc_drv.pkg
76982>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76982>>>>>>>>>>>>>//****************************************************************************
76982>>>>>>>>>>>>>// $Module type: Class
76982>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76982>>>>>>>>>>>>>//
76982>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76982>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76982>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76982>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76982>>>>>>>>>>>>>//
76982>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76982>>>>>>>>>>>>>//
76982>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76982>>>>>>>>>>>>>//               properties of that object.
76982>>>>>>>>>>>>>//
76982>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76982>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76982>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76982>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76982>>>>>>>>>>>>>// in the help folder for more details.
76982>>>>>>>>>>>>>//
76982>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76982>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76982>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76982>>>>>>>>>>>>>>>
76982>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76983>>>>>>>>>>>>>>>    Procedure Construct_Object
76985>>>>>>>>>>>>>>>        Forward Send Construct_Object
76987>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76988>>>>>>>>>>>>>>>    End_Procedure
76989>>>>>>>>>>>>>>>
76989>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76991>>>>>>>>>>>>>>>        String sRetval
76991>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76993>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76994>>>>>>>>>>>>>>>        End                                        
76994>>>>>>>>>>>>>>>>
76994>>>>>>>>>>>>>>>        Else Begin
76995>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76996>>>>>>>>>>>>>>>        End
76996>>>>>>>>>>>>>>>>
76996>>>>>>>>>>>>>>>            
76996>>>>>>>>>>>>>>>        Function_Return sRetval
76997>>>>>>>>>>>>>>>    End_Function
76998>>>>>>>>>>>>>>>
76998>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77000>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
77000>>>>>>>>>>>>>>>        Integer iClientVersion
77000>>>>>>>>>>>>>>>        
77000>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77001>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
77002>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
77003>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
77005>>>>>>>>>>>>>>>            Move "" to sDatabase
77006>>>>>>>>>>>>>>>        End
77006>>>>>>>>>>>>>>>>
77006>>>>>>>>>>>>>>>        
77006>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77008>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77009>>>>>>>>>>>>>>>        End
77009>>>>>>>>>>>>>>>>
77009>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77011>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77012>>>>>>>>>>>>>>>        End
77012>>>>>>>>>>>>>>>>
77012>>>>>>>>>>>>>>>        Else Begin
77013>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77014>>>>>>>>>>>>>>>        End
77014>>>>>>>>>>>>>>>>
77014>>>>>>>>>>>>>>>        
77014>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77016>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77017>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
77019>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77020>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
77021>>>>>>>>>>>>>>>            End
77021>>>>>>>>>>>>>>>>
77021>>>>>>>>>>>>>>>        End
77021>>>>>>>>>>>>>>>>
77021>>>>>>>>>>>>>>>        
77021>>>>>>>>>>>>>>>        Function_Return sConnect
77022>>>>>>>>>>>>>>>    End_Function
77023>>>>>>>>>>>>>>>
77023>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77025>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77025>>>>>>>>>>>>>>>        String sDriverID
77025>>>>>>>>>>>>>>>
77025>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77026>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77028>>>>>>>>>>>>>>>            Function_Return True
77029>>>>>>>>>>>>>>>        End
77029>>>>>>>>>>>>>>>>
77029>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77030>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77032>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77033>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77035>>>>>>>>>>>>>>>        End
77035>>>>>>>>>>>>>>>>
77035>>>>>>>>>>>>>>>        Else Begin
77036>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77038>>>>>>>>>>>>>>>        End
77038>>>>>>>>>>>>>>>>
77038>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77039>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77040>>>>>>>>>>>>>>>    End_Function
77041>>>>>>>>>>>>>>>
77041>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77043>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77043>>>>>>>>>>>>>>>        String sDriver
77043>>>>>>>>>>>>>>>        
77043>>>>>>>>>>>>>>>        Move 0 to iDriver
77044>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77047>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77049>>>>>>>>>>>>>>>            Load_Driver sDriverID
77050>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77053>>>>>>>>>>>>>>>        End
77053>>>>>>>>>>>>>>>>
77053>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77059>>>>>>>>>>>>>>>>
77059>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77062>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77064>>>>>>>>>>>>>>>                Move iCount to iDriver
77065>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77066>>>>>>>>>>>>>>>            End
77066>>>>>>>>>>>>>>>>
77066>>>>>>>>>>>>>>>        Loop
77067>>>>>>>>>>>>>>>>
77067>>>>>>>>>>>>>>>    
77067>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77067>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77069>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77072>>>>>>>>>>>>>>>        End
77072>>>>>>>>>>>>>>>>
77072>>>>>>>>>>>>>>>        Function_Return iClientVersion
77073>>>>>>>>>>>>>>>    End_Function
77074>>>>>>>>>>>>>>>    
77074>>>>>>>>>>>>>>>End_Class
77075>>>>>>>>>>>>>>>
77075>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77076>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77078>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77079>>>>>>>>>>>>>>>    End_Function
77080>>>>>>>>>>>>>>>
77080>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77082>>>>>>>>>>>>>>>        Integer iClientVersion
77082>>>>>>>>>>>>>>>        String sConnect
77082>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77082>>>>>>>>>>>>>>>        
77082>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77083>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77085>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77086>>>>>>>>>>>>>>>        End
77086>>>>>>>>>>>>>>>>
77086>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77088>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77089>>>>>>>>>>>>>>>        End
77089>>>>>>>>>>>>>>>>
77089>>>>>>>>>>>>>>>        Else Begin
77090>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77091>>>>>>>>>>>>>>>        End
77091>>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77092>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77094>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77095>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77096>>>>>>>>>>>>>>>        End
77096>>>>>>>>>>>>>>>>
77096>>>>>>>>>>>>>>>        
77096>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77098>>>>>>>>>>>>>>>
77098>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77099>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77100>>>>>>>>>>>>>>>    End_Function
77101>>>>>>>>>>>>>>>
77101>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77103>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77103>>>>>>>>>>>>>>>        String sDriver
77103>>>>>>>>>>>>>>>        
77103>>>>>>>>>>>>>>>        Move 0 to iDriver
77104>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77107>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77109>>>>>>>>>>>>>>>            Load_Driver sDriverID
77110>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77113>>>>>>>>>>>>>>>        End
77113>>>>>>>>>>>>>>>>
77113>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77119>>>>>>>>>>>>>>>>
77119>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77122>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77124>>>>>>>>>>>>>>>                Move iCount to iDriver
77125>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77126>>>>>>>>>>>>>>>            End
77126>>>>>>>>>>>>>>>>
77126>>>>>>>>>>>>>>>        Loop
77127>>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>    
77127>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77127>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77129>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77132>>>>>>>>>>>>>>>        End
77132>>>>>>>>>>>>>>>>
77132>>>>>>>>>>>>>>>        Function_Return iClientVersion
77133>>>>>>>>>>>>>>>    End_Function
77134>>>>>>>>>>>>>>>    
77134>>>>>>>>>>>>>>>End_Class
77135>>>>>>>>>>>>>>>
77135>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77136>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77138>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77138>>>>>>>>>>>>>>>        String sDriverID
77138>>>>>>>>>>>>>>>
77138>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77139>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77140>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77142>>>>>>>>>>>>>>>            Function_Return True
77143>>>>>>>>>>>>>>>        End
77143>>>>>>>>>>>>>>>>
77143>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77144>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77146>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77148>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77149>>>>>>>>>>>>>>>            End
77149>>>>>>>>>>>>>>>>
77149>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77152>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77153>>>>>>>>>>>>>>>            End
77153>>>>>>>>>>>>>>>>
77153>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77155>>>>>>>>>>>>>>>        End
77155>>>>>>>>>>>>>>>>
77155>>>>>>>>>>>>>>>        Else Begin
77156>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77158>>>>>>>>>>>>>>>        End
77158>>>>>>>>>>>>>>>>
77158>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77159>>>>>>>>>>>>>>>
77159>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77160>>>>>>>>>>>>>>>    End_Function
77161>>>>>>>>>>>>>>>End_Class
77162>>>>>>>>>>>>>>>
77162>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77163>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77165>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77165>>>>>>>>>>>>>>>        String sDriverID
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>        Move False to Err
77166>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77167>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77169>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77170>>>>>>>>>>>>>>>        End
77170>>>>>>>>>>>>>>>>
77170>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77172>>>>>>>>>>>>>>>
77172>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77173>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77174>>>>>>>>>>>>>>>    End_Function
77175>>>>>>>>>>>>>>>End_Class
77176>>>>>>>>>>>>>>>
77176>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77177>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77179>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77179>>>>>>>>>>>>>>>        String sDriverID
77179>>>>>>>>>>>>>>>
77179>>>>>>>>>>>>>>>        Move False to Err
77180>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77181>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77181>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77181>>>>>>>>>>>>>>>//        End
77181>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77183>>>>>>>>>>>>>>>
77183>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77184>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77185>>>>>>>>>>>>>>>    End_Function
77186>>>>>>>>>>>>>>>End_Class
77187>>>>>>>>>>>>>>>
77187>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77188>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77190>>>>>>>>>>>>>>>        Function_Return ""
77191>>>>>>>>>>>>>>>    End_Function
77192>>>>>>>>>>>>>>>End_Class
77193>>>>>>>>>>>>>>>
77193>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77194>>>>>>>>>>>>>>>    Procedure Construct_Object
77196>>>>>>>>>>>>>>>        Forward Send Construct_Object
77198>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77199>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject 
77200>>>>>>>>>>>>>>>    End_Procedure
77201>>>>>>>>>>>>>>>
77201>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77203>>>>>>>>>>>>>>>        String sDriverID sObjectName
77203>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77203>>>>>>>>>>>>>>>
77203>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77204>>>>>>>>>>>>>>>        Case Begin
77204>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77206>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77207>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77208>>>>>>>>>>>>>>>                Case Break
77209>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77212>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77213>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77214>>>>>>>>>>>>>>>                Case Break
77215>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77218>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77219>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77220>>>>>>>>>>>>>>>                Case Break               
77221>>>>>>>>>>>>>>>            Case Else
77221>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77221>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77222>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77223>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77224>>>>>>>>>>>>>>>        Case End
77224>>>>>>>>>>>>>>>
77224>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77225>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77226>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77227>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77228>>>>>>>>>>>>>>>
77228>>>>>>>>>>>>>>>        Function_Return hoDriver
77229>>>>>>>>>>>>>>>    End_Function
77230>>>>>>>>>>>>>>>
77230>>>>>>>>>>>>>>>    Procedure DestroyDriver
77232>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77234>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77235>>>>>>>>>>>>>>>        End
77235>>>>>>>>>>>>>>>>
77235>>>>>>>>>>>>>>>    End_Procedure
77236>>>>>>>>>>>>>>>
77236>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77238>>>>>>>>>>>>>>>        String sConnect
77238>>>>>>>>>>>>>>>        Handle hoDriver
77238>>>>>>>>>>>>>>>
77238>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77239>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77241>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77242>>>>>>>>>>>>>>>        End
77242>>>>>>>>>>>>>>>>
77242>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77243>>>>>>>>>>>>>>>        Send DestroyDriver
77244>>>>>>>>>>>>>>>        Function_Return sConnect
77245>>>>>>>>>>>>>>>    End_Function
77246>>>>>>>>>>>>>>>
77246>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77248>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77248>>>>>>>>>>>>>>>        Handle hoDriver
77248>>>>>>>>>>>>>>>
77248>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77249>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77251>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77252>>>>>>>>>>>>>>>        End
77252>>>>>>>>>>>>>>>>
77252>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77253>>>>>>>>>>>>>>>        Send DestroyDriver
77254>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77255>>>>>>>>>>>>>>>    End_Function
77256>>>>>>>>>>>>>>>
77256>>>>>>>>>>>>>>>End_Class
77257>>>>>>>>>>>>>
77257>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77257>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77257>>>>>>>>>>>>>>>
77257>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77258>>>>>>>>>>>>>>>    
77258>>>>>>>>>>>>>>>    Procedure Construct_Object
77260>>>>>>>>>>>>>>>        Forward Send Construct_Object
77262>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77262>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77263>>>>>>>>>>>>>>>        
77263>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77265>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77266>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77267>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77268>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77269>>>>>>>>>>>>>>>        End_Object
77270>>>>>>>>>>>>>>>    End_Procedure
77271>>>>>>>>>>>>>>>    
77271>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77271>>>>>>>>>>>>>>>    // hidden mechanism desired.
77271>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77273>>>>>>>>>>>>>>>        String sPassword
77273>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77274>>>>>>>>>>>>>>>        Function_Return sPassword
77275>>>>>>>>>>>>>>>    End_Function
77276>>>>>>>>>>>>>>>    
77276>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77276>>>>>>>>>>>>>>>    //
77276>>>>>>>>>>>>>>>    // Params:
77276>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77276>>>>>>>>>>>>>>>    // Returns:
77276>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77276>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77278>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77278>>>>>>>>>>>>>>>        UChar[] ucBinary
77279>>>>>>>>>>>>>>>        Pointer pBase64
77279>>>>>>>>>>>>>>>        Integer iVoid
77279>>>>>>>>>>>>>>>        
77279>>>>>>>>>>>>>>>        //  Encrypt Key
77279>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77280>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77282>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77283>>>>>>>>>>>>>>>>
77283>>>>>>>>>>>>>>>        End
77283>>>>>>>>>>>>>>>>
77283>>>>>>>>>>>>>>>        
77283>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77284>>>>>>>>>>>>>>>        
77284>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77286>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77287>>>>>>>>>>>>>>>>
77287>>>>>>>>>>>>>>>            Function_Return ""
77288>>>>>>>>>>>>>>>        End
77288>>>>>>>>>>>>>>>>
77288>>>>>>>>>>>>>>>        
77288>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77288>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77289>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77290>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77291>>>>>>>>>>>>>>>        
77291>>>>>>>>>>>>>>>        Function_Return sBase64
77292>>>>>>>>>>>>>>>    End_Function
77293>>>>>>>>>>>>>>>    
77293>>>>>>>>>>>>>>>    
77293>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77293>>>>>>>>>>>>>>>    //
77293>>>>>>>>>>>>>>>    // Params:
77293>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77293>>>>>>>>>>>>>>>    // Returns:
77293>>>>>>>>>>>>>>>    //   Readable plain text password
77293>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77295>>>>>>>>>>>>>>>        String sEncryptPassword
77295>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77297>>>>>>>>>>>>>>>        Boolean bIsHex
77297>>>>>>>>>>>>>>>        Integer iLen iVoid
77297>>>>>>>>>>>>>>>        Pointer pBinary
77297>>>>>>>>>>>>>>>        
77297>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77299>>>>>>>>>>>>>>>            //  Decode from Base64
77299>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77300>>>>>>>>>>>>>>>            
77300>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77301>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77302>>>>>>>>>>>>>>>                        
77302>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77303>>>>>>>>>>>>>>>            
77303>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77303>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77304>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77305>>>>>>>>>>>>>>>        End
77305>>>>>>>>>>>>>>>>
77305>>>>>>>>>>>>>>>        
77305>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77306>>>>>>>>>>>>>>>    End_Function
77307>>>>>>>>>>>>>>>End_Class
77308>>>>>>>>>>>>>
77308>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77309>>>>>>>>>>>>>    Procedure Construct_Object
77311>>>>>>>>>>>>>        Forward Send Construct_Object
77313>>>>>>>>>>>>>
77313>>>>>>>>>>>>>        Property String Private_psIniFilePath
77314>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77315>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77316>>>>>>>>>>>>>
77316>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77317>>>>>>>>>>>>>
77317>>>>>>>>>>>>>        // *** You really want to change this value! ***
77317>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77317>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77318>>>>>>>>>>>>>
77318>>>>>>>>>>>>>    End_Procedure
77319>>>>>>>>>>>>>
77319>>>>>>>>>>>>>    Procedure End_Construct_Object
77321>>>>>>>>>>>>>        Forward Send End_Construct_Object
77323>>>>>>>>>>>>>    End_Procedure
77324>>>>>>>>>>>>>
77324>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77326>>>>>>>>>>>>>        String sIniFile
77326>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77327>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77328>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77329>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77330>>>>>>>>>>>>>    End_Procedure
77331>>>>>>>>>>>>>
77331>>>>>>>>>>>>>    Function psIniFilePath Returns String
77333>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77334>>>>>>>>>>>>>    End_Function
77335>>>>>>>>>>>>>
77335>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77337>>>>>>>>>>>>>        String sPath
77337>>>>>>>>>>>>>        Get psIniFilePath to sPath
77338>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77339>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77340>>>>>>>>>>>>>    End_Procedure
77341>>>>>>>>>>>>>
77341>>>>>>>>>>>>>    Function psIniFileName Returns String
77343>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77344>>>>>>>>>>>>>    End_Function
77345>>>>>>>>>>>>>
77345>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77345>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77345>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77345>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77347>>>>>>>>>>>>>        String sIniFile sPath
77347>>>>>>>>>>>>>
77347>>>>>>>>>>>>>        Get psIniFilePath to sPath
77348>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77349>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77350>>>>>>>>>>>>>        Set psFileName to sIniFile
77351>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77352>>>>>>>>>>>>>    End_Procedure
77353>>>>>>>>>>>>>
77353>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77353>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77353>>>>>>>>>>>>>    // Returns the value
77353>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77355>>>>>>>>>>>>>        String sValue sIniFile sPath
77355>>>>>>>>>>>>>
77355>>>>>>>>>>>>>        Get psIniFilePath to sPath
77356>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77357>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77358>>>>>>>>>>>>>        Set psFileName to sIniFile
77359>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77360>>>>>>>>>>>>>
77360>>>>>>>>>>>>>        Function_Return sValue
77361>>>>>>>>>>>>>    End_Function
77362>>>>>>>>>>>>>
77362>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77362>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77364>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77367>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77370>>>>>>>>>>>>>
77370>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77373>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77376>>>>>>>>>>>>>
77376>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77379>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77382>>>>>>>>>>>>>
77382>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77385>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77388>>>>>>>>>>>>>
77388>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77391>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77394>>>>>>>>>>>>>
77394>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77397>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77400>>>>>>>>>>>>>
77400>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77403>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77406>>>>>>>>>>>>>
77406>>>>>>>>>>>>>        Function_Return (EQ)
77407>>>>>>>>>>>>>    End_Function
77408>>>>>>>>>>>>>
77408>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77410>>>>>>>>>>>>>        Handle hoSections
77410>>>>>>>>>>>>>        Integer iItems
77410>>>>>>>>>>>>>
77410>>>>>>>>>>>>>        Send ReadSections hoSections
77411>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77412>>>>>>>>>>>>>        Function_Return iItems
77413>>>>>>>>>>>>>    End_Function
77414>>>>>>>>>>>>>
77414>>>>>>>>>>>>>    // The normal connection string looks something like this;
77414>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77414>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77414>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77414>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77414>>>>>>>>>>>>>//        String sSection
77414>>>>>>>>>>>>>//        Integer iCount
77414>>>>>>>>>>>>>//
77414>>>>>>>>>>>>>//        Move False to Err
77414>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77414>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77414>>>>>>>>>>>>>//        Increment iCount
77414>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77414>>>>>>>>>>>>>//
77414>>>>>>>>>>>>>//        Function_Return (Err = False)
77414>>>>>>>>>>>>>//    End_Function
77414>>>>>>>>>>>>>
77414>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77416>>>>>>>>>>>>>        Integer iCount
77416>>>>>>>>>>>>>        Boolean bExists
77416>>>>>>>>>>>>>        String sSection
77416>>>>>>>>>>>>>
77416>>>>>>>>>>>>>        Move False to Err
77417>>>>>>>>>>>>>        Move 1 to iCount
77418>>>>>>>>>>>>>        Get psIniSectionName to sSection
77419>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77420>>>>>>>>>>>>>        While (bExists = True)
77424>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77425>>>>>>>>>>>>>            Increment iCount
77426>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77427>>>>>>>>>>>>>        Loop
77428>>>>>>>>>>>>>>
77428>>>>>>>>>>>>>        Function_Return (Err = False)
77429>>>>>>>>>>>>>    End_Function
77430>>>>>>>>>>>>>
77430>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77432>>>>>>>>>>>>>        Integer iCount
77432>>>>>>>>>>>>>        String sSection
77432>>>>>>>>>>>>>        Boolean bExists
77432>>>>>>>>>>>>>
77432>>>>>>>>>>>>>        Move False to Err
77433>>>>>>>>>>>>>        Move 1 to iCount
77434>>>>>>>>>>>>>        Get psIniSectionName to sSection
77435>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77436>>>>>>>>>>>>>        While (bExists = True)
77440>>>>>>>>>>>>>            If (iCount = iItem) Begin
77442>>>>>>>>>>>>>                Send DeleteSection sSection
77443>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77443>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77444>>>>>>>>>>>>>            End
77444>>>>>>>>>>>>>>
77444>>>>>>>>>>>>>            Increment iCount
77445>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77446>>>>>>>>>>>>>        Loop
77447>>>>>>>>>>>>>>
77447>>>>>>>>>>>>>
77447>>>>>>>>>>>>>        Function_Return (Err = False)
77448>>>>>>>>>>>>>    End_Function
77449>>>>>>>>>>>>>
77449>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77449>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77449>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77451>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77451>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77452>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77452>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77452>>>>>>>>>>>>>        Integer iIndex
77452>>>>>>>>>>>>>
77452>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77453>>>>>>>>>>>>>        If (iIndex = -1) Begin
77455>>>>>>>>>>>>>            Move True to SQLConnection.bError
77456>>>>>>>>>>>>>            Function_Return SQLConnection
77457>>>>>>>>>>>>>        End
77457>>>>>>>>>>>>>>
77457>>>>>>>>>>>>>
77457>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77458>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77459>>>>>>>>>>>>>
77459>>>>>>>>>>>>>        Function_Return SQLConnection
77460>>>>>>>>>>>>>    End_Function
77461>>>>>>>>>>>>>
77461>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77461>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77463>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77463>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77464>>>>>>>>>>>>>        Integer iRetval iCount iSize
77464>>>>>>>>>>>>>        String sValue
77464>>>>>>>>>>>>>        Boolean bExists
77464>>>>>>>>>>>>>
77464>>>>>>>>>>>>>        Move -1 to iRetval
77465>>>>>>>>>>>>>
77465>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77466>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77467>>>>>>>>>>>>>        Decrement iSize
77468>>>>>>>>>>>>>        For iCount from 0 to iSize
77474>>>>>>>>>>>>>>
77474>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77475>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77476>>>>>>>>>>>>>            If (bExists) Begin
77478>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77479>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77480>>>>>>>>>>>>>            End
77480>>>>>>>>>>>>>>
77480>>>>>>>>>>>>>        Loop
77481>>>>>>>>>>>>>>
77481>>>>>>>>>>>>>
77481>>>>>>>>>>>>>        Function_Return iRetval
77482>>>>>>>>>>>>>    End_Function
77483>>>>>>>>>>>>>
77483>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77483>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77483>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77485>>>>>>>>>>>>>        Integer iCount iSize iItems
77485>>>>>>>>>>>>>        String sValue
77485>>>>>>>>>>>>>        Boolean bExists
77485>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77485>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77486>>>>>>>>>>>>>
77486>>>>>>>>>>>>>        Move 0 to iItems
77487>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77488>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77489>>>>>>>>>>>>>        Decrement iSize
77490>>>>>>>>>>>>>        For iCount from 0 to iSize
77496>>>>>>>>>>>>>>
77496>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77497>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77498>>>>>>>>>>>>>            If (bExists) Begin
77500>>>>>>>>>>>>>                Increment iItems
77501>>>>>>>>>>>>>            End
77501>>>>>>>>>>>>>>
77501>>>>>>>>>>>>>        Loop
77502>>>>>>>>>>>>>>
77502>>>>>>>>>>>>>
77502>>>>>>>>>>>>>        Function_Return (iItems > 1)
77503>>>>>>>>>>>>>    End_Function
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77504>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77506>>>>>>>>>>>>>        Boolean bOK
77506>>>>>>>>>>>>>        Integer iSize iCount
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77507>>>>>>>>>>>>>        tSQLConnection SQLConnection
77507>>>>>>>>>>>>>        tSQLConnection SQLConnection
77507>>>>>>>>>>>>>        String sConnectionString
77507>>>>>>>>>>>>>
77507>>>>>>>>>>>>>        Move False to Err
77508>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77509>>>>>>>>>>>>>
77509>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77510>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77511>>>>>>>>>>>>>        Decrement iSize
77512>>>>>>>>>>>>>        // Set all current connection to inactive.
77512>>>>>>>>>>>>>        For iCount from 0 to iSize
77518>>>>>>>>>>>>>>
77518>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77519>>>>>>>>>>>>>        Loop
77520>>>>>>>>>>>>>>
77520>>>>>>>>>>>>>
77520>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77521>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77522>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77523>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77524>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77525>>>>>>>>>>>>>
77525>>>>>>>>>>>>>        Function_Return (bOK = True)
77526>>>>>>>>>>>>>    End_Function
77527>>>>>>>>>>>>>
77527>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77527>>>>>>>>>>>>>    // Returns True if successful.
77527>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77529>>>>>>>>>>>>>        Boolean bOK
77529>>>>>>>>>>>>>        Integer iItem iSize iCount
77529>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77529>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77530>>>>>>>>>>>>>
77530>>>>>>>>>>>>>        Move False to Err
77531>>>>>>>>>>>>>        Move -1 to iItem
77532>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77533>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77534>>>>>>>>>>>>>        Decrement iSize
77535>>>>>>>>>>>>>        // Set all current connection to inactive.
77535>>>>>>>>>>>>>        For iCount from 0 to iSize
77541>>>>>>>>>>>>>>
77541>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77542>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77544>>>>>>>>>>>>>                Move iCount to iItem
77545>>>>>>>>>>>>>            End
77545>>>>>>>>>>>>>>
77545>>>>>>>>>>>>>        Loop
77546>>>>>>>>>>>>>>
77546>>>>>>>>>>>>>
77546>>>>>>>>>>>>>        If (iItem <> -1) Begin
77548>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77549>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77550>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77551>>>>>>>>>>>>>        End
77551>>>>>>>>>>>>>>
77551>>>>>>>>>>>>>
77551>>>>>>>>>>>>>        Function_Return (bOK = True)
77552>>>>>>>>>>>>>    End_Function
77553>>>>>>>>>>>>>
77553>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77555>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77555>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77556>>>>>>>>>>>>>        String sSection sValue
77556>>>>>>>>>>>>>        Integer iCount
77556>>>>>>>>>>>>>        Boolean bExists
77556>>>>>>>>>>>>>
77556>>>>>>>>>>>>>        Get psIniSectionName to sSection
77557>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77558>>>>>>>>>>>>>        If (bExists = False) Begin
77560>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77561>>>>>>>>>>>>>        End
77561>>>>>>>>>>>>>>
77561>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77562>>>>>>>>>>>>>        If (bExists = True) Begin
77564>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77565>>>>>>>>>>>>>>
77565>>>>>>>>>>>>>        End
77565>>>>>>>>>>>>>>
77565>>>>>>>>>>>>>
77565>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77566>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77567>>>>>>>>>>>>>
77567>>>>>>>>>>>>>        While (bExists = True)                 
77571>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77571>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77571>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77571>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77571>>>>>>>>>>>>>
77571>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77572>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77573>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77574>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77575>>>>>>>>>>>>>
77575>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77575>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77576>>>>>>>>>>>>>            If (sValue = "99") Begin
77578>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77579>>>>>>>>>>>>>            End
77579>>>>>>>>>>>>>>
77579>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77580>>>>>>>>>>>>>
77580>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77581>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77582>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77584>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77585>>>>>>>>>>>>>            End
77585>>>>>>>>>>>>>>
77585>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77587>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77588>>>>>>>>>>>>>            End
77588>>>>>>>>>>>>>>
77588>>>>>>>>>>>>>
77588>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77589>>>>>>>>>>>>>
77589>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77590>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77591>>>>>>>>>>>>>
77591>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77592>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77593>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77595>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77596>>>>>>>>>>>>>            End
77596>>>>>>>>>>>>>>
77596>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77597>>>>>>>>>>>>>
77597>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77597>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77598>>>>>>>>>>>>>
77598>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77599>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77600>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77601>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77602>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77603>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77604>>>>>>>>>>>>>
77604>>>>>>>>>>>>>            Increment iCount
77605>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77606>>>>>>>>>>>>>        Loop
77607>>>>>>>>>>>>>>
77607>>>>>>>>>>>>>
77607>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77607>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77609>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77610>>>>>>>>>>>>>        End
77610>>>>>>>>>>>>>>
77610>>>>>>>>>>>>>
77610>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77611>>>>>>>>>>>>>    End_Function
77612>>>>>>>>>>>>>
77612>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77614>>>>>>>>>>>>>        Integer iCount iSize
77614>>>>>>>>>>>>>        Boolean bOK
77614>>>>>>>>>>>>>        String sSection sValue
77614>>>>>>>>>>>>>
77614>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77614>>>>>>>>>>>>>        Move 0 to iCount
77615>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77616>>>>>>>>>>>>>        If (bOK = False) Begin
77618>>>>>>>>>>>>>            Function_Return False
77619>>>>>>>>>>>>>        End
77619>>>>>>>>>>>>>>
77619>>>>>>>>>>>>>
77619>>>>>>>>>>>>>        Move False to Err
77620>>>>>>>>>>>>>        Get psIniSectionName to sSection
77621>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77621>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77622>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77623>>>>>>>>>>>>>        Decrement iSize
77624>>>>>>>>>>>>>
77624>>>>>>>>>>>>>        For iCount from 0 to iSize
77630>>>>>>>>>>>>>>
77630>>>>>>>>>>>>>            // DF 19 compatible settings:
77630>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77631>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77632>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77633>>>>>>>>>>>>>            
77633>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77634>>>>>>>>>>>>>
77634>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77635>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77637>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77638>>>>>>>>>>>>>            End
77638>>>>>>>>>>>>>>
77638>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77639>>>>>>>>>>>>>
77639>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77641>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77642>>>>>>>>>>>>>            End
77642>>>>>>>>>>>>>>
77642>>>>>>>>>>>>>
77642>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77643>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77644>>>>>>>>>>>>>
77644>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77644>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77645>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77646>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77647>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77648>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77649>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77650>>>>>>>>>>>>>        Loop
77651>>>>>>>>>>>>>>
77651>>>>>>>>>>>>>
77651>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77652>>>>>>>>>>>>>    End_Function
77653>>>>>>>>>>>>>
77653>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77653>>>>>>>>>>>>>    //
77653>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77653>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77653>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77655>>>>>>>>>>>>>        String sRetval
77655>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77657>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77658>>>>>>>>>>>>>        End
77658>>>>>>>>>>>>>>
77658>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77660>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77661>>>>>>>>>>>>>        End
77661>>>>>>>>>>>>>>
77661>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77663>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77664>>>>>>>>>>>>>        End
77664>>>>>>>>>>>>>>
77664>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77666>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77667>>>>>>>>>>>>>        End
77667>>>>>>>>>>>>>>
77667>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77669>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77670>>>>>>>>>>>>>        End
77670>>>>>>>>>>>>>>
77670>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77672>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77673>>>>>>>>>>>>>        End
77673>>>>>>>>>>>>>>
77673>>>>>>>>>>>>>        Function_Return sRetval
77674>>>>>>>>>>>>>    End_Function
77675>>>>>>>>>>>>>
77675>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77675>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77675>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77677>>>>>>>>>>>>>        Integer iRetval
77677>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77679>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77680>>>>>>>>>>>>>        End
77680>>>>>>>>>>>>>>
77680>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77682>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77683>>>>>>>>>>>>>        End
77683>>>>>>>>>>>>>>
77683>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77685>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77686>>>>>>>>>>>>>        End
77686>>>>>>>>>>>>>>
77686>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77688>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77689>>>>>>>>>>>>>        End
77689>>>>>>>>>>>>>>
77689>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77691>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77692>>>>>>>>>>>>>        End
77692>>>>>>>>>>>>>>
77692>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77694>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77695>>>>>>>>>>>>>        End
77695>>>>>>>>>>>>>>
77695>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77697>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77698>>>>>>>>>>>>>        End
77698>>>>>>>>>>>>>>
77698>>>>>>>>>>>>>        Function_Return iRetval
77699>>>>>>>>>>>>>    End_Function
77700>>>>>>>>>>>>>
77700>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77700>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77700>>>>>>>>>>>>>    // the SQL Connection program's grid.
77700>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77702>>>>>>>>>>>>>        String sRetval
77702>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77704>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77705>>>>>>>>>>>>>        End
77705>>>>>>>>>>>>>>
77705>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77707>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77708>>>>>>>>>>>>>        End
77708>>>>>>>>>>>>>>
77708>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77710>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77711>>>>>>>>>>>>>        End
77711>>>>>>>>>>>>>>
77711>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77713>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77714>>>>>>>>>>>>>        End
77714>>>>>>>>>>>>>>
77714>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77716>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77717>>>>>>>>>>>>>        End
77717>>>>>>>>>>>>>>
77717>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77719>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77720>>>>>>>>>>>>>        End
77720>>>>>>>>>>>>>>
77720>>>>>>>>>>>>>        Function_Return sRetval
77721>>>>>>>>>>>>>    End_Function
77722>>>>>>>>>>>>>
77722>>>>>>>>>>>>>    // Pass a driver id and the function will return
77722>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77722>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77722>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77724>>>>>>>>>>>>>        Integer iRetval
77724>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77726>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77727>>>>>>>>>>>>>        End
77727>>>>>>>>>>>>>>
77727>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77729>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77730>>>>>>>>>>>>>        End
77730>>>>>>>>>>>>>>
77730>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77732>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77733>>>>>>>>>>>>>        End
77733>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77735>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77736>>>>>>>>>>>>>        End
77736>>>>>>>>>>>>>>
77736>>>>>>>>>>>>>        Function_Return iRetval
77737>>>>>>>>>>>>>    End_Function
77738>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77738>>>>>>>>>>>>>>
77738>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77740>>>>>>>>>>>>>>    Integer iStart iEnd
77740>>>>>>>>>>>>>>    String sRetval
77740>>>>>>>>>>>>>>
77740>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77741>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77742>>>>>>>>>>>>>>    If (iStart = 0) Begin
77744>>>>>>>>>>>>>>        Function_Return ""
77745>>>>>>>>>>>>>>    End
77745>>>>>>>>>>>>>>>
77745>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77746>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77747>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77749>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77750>>>>>>>>>>>>>>    End
77750>>>>>>>>>>>>>>>
77750>>>>>>>>>>>>>>    Else Begin
77751>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77752>>>>>>>>>>>>>>    End
77752>>>>>>>>>>>>>>>
77752>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77754>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77755>>>>>>>>>>>>>>        Decrement iEnd
77756>>>>>>>>>>>>>>    End
77756>>>>>>>>>>>>>>>
77756>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77758>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77759>>>>>>>>>>>>>>    End
77759>>>>>>>>>>>>>>>
77759>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77760>>>>>>>>>>>>>>
77760>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77761>>>>>>>>>>>>>>End_Function
77762>>>>>>>>>>>>>>
77762>>>>>>>>>>>>>>
77762>>>>>>>>>>>>>
77762>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77764>>>>>>>>>>>>>        String sConnect
77764>>>>>>>>>>>>>        Handle hoDriver
77764>>>>>>>>>>>>>
77764>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77765>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77766>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77767>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77768>>>>>>>>>>>>>        Send Destroy of hoDriver
77769>>>>>>>>>>>>>
77769>>>>>>>>>>>>>        Function_Return sConnect
77770>>>>>>>>>>>>>    End_Function
77771>>>>>>>>>>>>>
77771>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77771>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77773>>>>>>>>>>>>>        String sConnect
77773>>>>>>>>>>>>>
77773>>>>>>>>>>>>>        Case Begin
77773>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77775>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77776>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77778>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77779>>>>>>>>>>>>>                End
77779>>>>>>>>>>>>>>
77779>>>>>>>>>>>>>                Case Break
77780>>>>>>>>>>>>>
77780>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77783>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77785>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77786>>>>>>>>>>>>>                End
77786>>>>>>>>>>>>>>
77786>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77789>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77790>>>>>>>>>>>>>                End
77790>>>>>>>>>>>>>>
77790>>>>>>>>>>>>>
77790>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77792>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77793>>>>>>>>>>>>>                End
77793>>>>>>>>>>>>>>
77793>>>>>>>>>>>>>                Case Break
77794>>>>>>>>>>>>>
77794>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77797>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77798>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77800>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77801>>>>>>>>>>>>>                End
77801>>>>>>>>>>>>>>
77801>>>>>>>>>>>>>                Case Break
77802>>>>>>>>>>>>>
77802>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77805>>>>>>>>>>>>>                Break
77806>>>>>>>>>>>>>
77806>>>>>>>>>>>>>            Case Else
77806>>>>>>>>>>>>>                Move "" to sConnect
77807>>>>>>>>>>>>>        Case End
77807>>>>>>>>>>>>>
77807>>>>>>>>>>>>>        Function_Return sConnect
77808>>>>>>>>>>>>>    End_Function
77809>>>>>>>>>>>>>
77809>>>>>>>>>>>>>    // Use Base64
77809>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77811>>>>>>>>>>>>>        String sRetval
77811>>>>>>>>>>>>>        Handle hoLoginEncryption
77811>>>>>>>>>>>>>
77811>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77812>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77813>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77814>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77815>>>>>>>>>>>>>          
77815>>>>>>>>>>>>>        Function_Return sRetval
77816>>>>>>>>>>>>>    End_Function
77817>>>>>>>>>>>>>
77817>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77819>>>>>>>>>>>>>        String sRetval
77819>>>>>>>>>>>>>        Handle hoLoginEncryption
77819>>>>>>>>>>>>>
77819>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77820>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77821>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77822>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77823>>>>>>>>>>>>>
77823>>>>>>>>>>>>>        Function_Return sRetval
77824>>>>>>>>>>>>>    End_Function
77825>>>>>>>>>>>>>
77825>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77825>>>>>>>>>>>>>    Function ApplicationPath Returns String
77827>>>>>>>>>>>>>        String sApplicationFileName sPath
77827>>>>>>>>>>>>>        Integer iNumChars iRetval
77827>>>>>>>>>>>>>
77827>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77828>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77829>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77830>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77831>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77832>>>>>>>>>>>>>
77832>>>>>>>>>>>>>        Function_Return sPath
77833>>>>>>>>>>>>>    End_Function
77834>>>>>>>>>>>>>
77834>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77834>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77834>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77834>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77836>>>>>>>>>>>>>        Boolean bExists
77836>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77836>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77837>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77837>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77837>>>>>>>>>>>>>        
77837>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77838>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77839>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77840>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77841>>>>>>>>>>>>>        If (bExists = True) Begin
77843>>>>>>>>>>>>>            Function_Return sProgramsPath
77844>>>>>>>>>>>>>        End                      
77844>>>>>>>>>>>>>>
77844>>>>>>>>>>>>>    
77844>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77845>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77847>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77848>>>>>>>>>>>>>        End                                              
77848>>>>>>>>>>>>>>
77848>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77849>>>>>>>>>>>>>        
77849>>>>>>>>>>>>>        Move False to bExists
77850>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77851>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77852>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77853>>>>>>>>>>>>>        Decrement iSize       
77854>>>>>>>>>>>>>        
77854>>>>>>>>>>>>>        For iCount from 0 to iSize
77860>>>>>>>>>>>>>>
77860>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77861>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77862>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77863>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77864>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77870>>>>>>>>>>>>>>
77870>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77871>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77872>>>>>>>>>>>>>                // Check if there are more than one path specified;
77872>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77873>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77875>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77876>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77882>>>>>>>>>>>>>>
77882>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77883>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77884>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77885>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77886>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77887>>>>>>>>>>>>>                        If (bExists = True) Begin
77889>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77890>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77891>>>>>>>>>>>>>                            Move iSize to iCount
77892>>>>>>>>>>>>>                        End                                                    
77892>>>>>>>>>>>>>>
77892>>>>>>>>>>>>>                    Loop
77893>>>>>>>>>>>>>>
77893>>>>>>>>>>>>>                End
77893>>>>>>>>>>>>>>
77893>>>>>>>>>>>>>                Else Begin
77894>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77895>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77896>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77897>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77898>>>>>>>>>>>>>                    If (bExists = True) Begin
77900>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77901>>>>>>>>>>>>>                        Move iSize to iCount
77902>>>>>>>>>>>>>                    End                                                    
77902>>>>>>>>>>>>>>
77902>>>>>>>>>>>>>                End
77902>>>>>>>>>>>>>>
77902>>>>>>>>>>>>>            Loop
77903>>>>>>>>>>>>>>
77903>>>>>>>>>>>>>            If (bExists = False) Begin
77905>>>>>>>>>>>>>                Move "" to sPath    
77906>>>>>>>>>>>>>            End
77906>>>>>>>>>>>>>>
77906>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77907>>>>>>>>>>>>>        Loop        
77908>>>>>>>>>>>>>>
77908>>>>>>>>>>>>>        Send Destroy of hoPaths
77909>>>>>>>>>>>>>        
77909>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77909>>>>>>>>>>>>>        If (sPath = "") Begin
77911>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77912>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77913>>>>>>>>>>>>>        End                  
77913>>>>>>>>>>>>>>
77913>>>>>>>>>>>>>        
77913>>>>>>>>>>>>>        Function_Return sPath    
77914>>>>>>>>>>>>>    End_Function
77915>>>>>>>>>>>>>    
77915>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77915>>>>>>>>>>>>>    // with one or more .ws file names.
77915>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77915>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77915>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77915>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77917>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77919>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77919>>>>>>>>>>>>>        Integer iCh iSize
77919>>>>>>>>>>>>>        Boolean bExists      
77919>>>>>>>>>>>>>        Handle hoIniFile 
77919>>>>>>>>>>>>>        
77919>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77920>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77921>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77923>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77924>>>>>>>>>>>>>        End                                              
77924>>>>>>>>>>>>>>
77924>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77925>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77926>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77927>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77928>>>>>>>>>>>>>        
77928>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77928>>>>>>>>>>>>>        // read the name of the .ws file name.
77928>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77929>>>>>>>>>>>>>        If (bExists = True) Begin
77931>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77932>>>>>>>>>>>>>            If (iCh < 0) Begin
77934>>>>>>>>>>>>>                Function_Return asSWSFiles
77935>>>>>>>>>>>>>            End                                 
77935>>>>>>>>>>>>>>
77935>>>>>>>>>>>>>            
77935>>>>>>>>>>>>>            Repeat
77935>>>>>>>>>>>>>>
77935>>>>>>>>>>>>>                Readln channel iCh sFile
77937>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77939>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77940>>>>>>>>>>>>>                End
77940>>>>>>>>>>>>>>
77940>>>>>>>>>>>>>            Until (SeqEof = True)
77942>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77943>>>>>>>>>>>>>            
77943>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77944>>>>>>>>>>>>>            If (iSize <> 0) Begin
77946>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77947>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77947>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77947>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77948>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77949>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77950>>>>>>>>>>>>>                If (sFile <> "") Begin
77952>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77953>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77954>>>>>>>>>>>>>                    File_Exist sFile bExists
77955>>>>>>>>>>>>>                    If (bExists = True) Begin
77957>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77958>>>>>>>>>>>>>                    End
77958>>>>>>>>>>>>>>
77958>>>>>>>>>>>>>                End
77958>>>>>>>>>>>>>>
77958>>>>>>>>>>>>>                Send Destroy of hoIniFile
77959>>>>>>>>>>>>>            End
77959>>>>>>>>>>>>>>
77959>>>>>>>>>>>>>        End
77959>>>>>>>>>>>>>>
77959>>>>>>>>>>>>>        
77959>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77959>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77961>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77962>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77963>>>>>>>>>>>>>            If (bExists = False) Begin
77965>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77966>>>>>>>>>>>>>            End
77966>>>>>>>>>>>>>>
77966>>>>>>>>>>>>>        
77966>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77967>>>>>>>>>>>>>            If (iCh < 0) Begin
77969>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77970>>>>>>>>>>>>>            End                                 
77970>>>>>>>>>>>>>>
77970>>>>>>>>>>>>>            
77970>>>>>>>>>>>>>            Repeat
77970>>>>>>>>>>>>>>
77970>>>>>>>>>>>>>                Readln channel iCh sFile
77972>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77974>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77975>>>>>>>>>>>>>                End
77975>>>>>>>>>>>>>>
77975>>>>>>>>>>>>>            Until (SeqEof = True)
77977>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77978>>>>>>>>>>>>>        End
77978>>>>>>>>>>>>>>
77978>>>>>>>>>>>>>        
77978>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77979>>>>>>>>>>>>>    End_Function
77980>>>>>>>>>>>>>
77980>>>>>>>>>>>>>End_Class
77981>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77981>>>>>>>>>>>Use vWin32fh.pkg
77981>>>>>>>>>>>
77981>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77981>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77981>>>>>>>>>>>
77981>>>>>>>>>>>// We're making references to this object handle so we need it defined
77981>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77981>>>>>>>>>>>
77981>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77981>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77982>>>>>>>>>>>
77982>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77983>>>>>>>>>>>
77983>>>>>>>>>>>    Procedure Construct_Object
77985>>>>>>>>>>>        Handle ho
77985>>>>>>>>>>>        Forward Send Construct_Object
77987>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77988>>>>>>>>>>>
77988>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77989>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77990>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77991>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77992>>>>>>>>>>>        
77992>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77992>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77992>>>>>>>>>>>        // methods to this class.
77992>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77993>>>>>>>>>>>        Property Boolean pbToANSI          True
77994>>>>>>>>>>>        Property Boolean pbRecnum          True
77995>>>>>>>>>>>        Property Boolean pbCopyData        True
77996>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77997>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77998>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77999>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
78000>>>>>>>>>>>
78000>>>>>>>>>>>        Property Boolean Private.pbUseDriverCacheFiles True
78001>>>>>>>>>>>        Property Boolean Private.pbIgnoreDriverUcaseSupport True
78002>>>>>>>>>>>        
78002>>>>>>>>>>>        // Driver default value settings:
78002>>>>>>>>>>>        // Note: When the object is created the corresponding values
78002>>>>>>>>>>>        // from the driver .int files are read.
78002>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
78002>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
78003>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
78004>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
78005>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
78006>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
78007>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
78008>>>>>>>>>>>
78008>>>>>>>>>>>        // Driver "nullability" settings:
78008>>>>>>>>>>>        // Note: When the object is created the corresponding values
78008>>>>>>>>>>>        // from the driver .int files are read.
78008>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
78008>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
78009>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
78010>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
78011>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
78012>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78013>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
78014>>>>>>>>>>>
78014>>>>>>>>>>>        Property Boolean pbUseCacheFiles                 True
78015>>>>>>>>>>>
78015>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
78015>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
78015>>>>>>>>>>>        //     driver interfaces.
78015>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
78015>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
78015>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
78016>>>>>>>>>>>
78016>>>>>>>>>>>    End_Procedure
78017>>>>>>>>>>>
78017>>>>>>>>>>>    Procedure End_Construct_Object
78019>>>>>>>>>>>        tSQLConnection SQLConnection
78019>>>>>>>>>>>        tSQLConnection SQLConnection
78019>>>>>>>>>>>
78019>>>>>>>>>>>        Forward Send End_Construct_Object
78021>>>>>>>>>>>
78021>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
78021>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
78022>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78023>>>>>>>>>>>    End_Procedure
78024>>>>>>>>>>>
78024>>>>>>>>>>>    // *** Properties ***
78024>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78024>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
78024>>>>>>>>>>>    // merely here for conveniance.
78024>>>>>>>>>>>    //
78024>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
78024>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
78024>>>>>>>>>>>    // This struct property contains all the connection data.
78024>>>>>>>>>>>    //
78024>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78026>>>>>>>>>>>        Boolean bOK
78026>>>>>>>>>>>
78026>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78027>>>>>>>>>>>
78027>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78027>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78029>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78029>>>>>>>>>>>            Procedure_Return
78030>>>>>>>>>>>        End
78030>>>>>>>>>>>>
78030>>>>>>>>>>>
78030>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78030>>>>>>>>>>>        // be logged in already and don't want to do it again.
78030>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78032>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78032>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78032>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78033>>>>>>>>>>>            If (bOK = False) Begin
78035>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78036>>>>>>>>>>>>
78036>>>>>>>>>>>            End
78036>>>>>>>>>>>>
78036>>>>>>>>>>>        End
78036>>>>>>>>>>>>
78036>>>>>>>>>>>
78036>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78036>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78037>>>>>>>>>>>
78037>>>>>>>>>>>    End_Procedure
78038>>>>>>>>>>>
78038>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78038>>>>>>>>>>>    // attempt to load the driver.
78038>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78038>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78040>>>>>>>>>>>        Boolean bOK
78040>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78041>>>>>>>>>>>        Function_Return bOK
78042>>>>>>>>>>>    End_Function
78043>>>>>>>>>>>
78043>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78043>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78045>>>>>>>>>>>        String sAttributeValue sServer
78045>>>>>>>>>>>        Integer iDriverID
78045>>>>>>>>>>>        Boolean bNULL bSQLDriver
78045>>>>>>>>>>>        Handle hDatabase
78045>>>>>>>>>>>        
78045>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78046>>>>>>>>>>>        If (bSQLDriver = False) Begin
78048>>>>>>>>>>>            Procedure_Return
78049>>>>>>>>>>>        End                                      
78049>>>>>>>>>>>>
78049>>>>>>>>>>>        
78049>>>>>>>>>>>        // Note: The properties pbUseDriverCacheFiles and pbIgnoreDriverUcaseSupport,
78049>>>>>>>>>>>        //       should be Set in the cDbUpdateHandler Object:
78049>>>>>>>>>>>        //       
78049>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78050>>>>>>>>>>>        If (iDriverID <> 0) Begin
78052>>>>>>>>>>>            Set_Attribute DF_DRIVER_USE_CACHE of iDriverID to (Private.pbUseDriverCacheFiles(Self)) 
78055>>>>>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_UCASE_SUPPORT of iDriverID to (Private.pbIgnoreDriverUcaseSupport(Self))
78058>>>>>>>>>>>        End
78058>>>>>>>>>>>>
78058>>>>>>>>>>>        
78058>>>>>>>>>>>        // ToDo: Testing!
78058>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78058>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78058>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78058>>>>>>>>>>>
78058>>>>>>>>>>>        // Driver default values for various data types:
78058>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78061>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78062>>>>>>>>>>>
78062>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78065>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78066>>>>>>>>>>>
78066>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78069>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78070>>>>>>>>>>>
78070>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78073>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78074>>>>>>>>>>>
78074>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78077>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78078>>>>>>>>>>>
78078>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78081>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78082>>>>>>>>>>>
78082>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78082>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78085>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78086>>>>>>>>>>>
78086>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78089>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78090>>>>>>>>>>>
78090>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78093>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78094>>>>>>>>>>>
78094>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78097>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78098>>>>>>>>>>>
78098>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78101>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78102>>>>>>>>>>>
78102>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78105>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78106>>>>>>>>>>>
78106>>>>>>>>>>>    End_Procedure
78107>>>>>>>>>>>
78107>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78109>>>>>>>>>>>        Boolean bOK bIsDaw
78109>>>>>>>>>>>        String sConnectionString
78109>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78109>>>>>>>>>>>        Integer iDriverID
78109>>>>>>>>>>>
78109>>>>>>>>>>>        Move False to bOK
78110>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78111>>>>>>>>>>>
78111>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78112>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78113>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78114>>>>>>>>>>>        If (iDriverID = 0) Begin
78116>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78117>>>>>>>>>>>            Function_Return False
78118>>>>>>>>>>>        End
78118>>>>>>>>>>>>
78118>>>>>>>>>>>
78118>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78121>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78122>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78123>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78124>>>>>>>>>>>        Send Destroy   of hoDriver
78125>>>>>>>>>>>
78125>>>>>>>>>>>        Function_Return bOK
78126>>>>>>>>>>>    End_Function
78127>>>>>>>>>>>
78127>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78129>>>>>>>>>>>        tSQLConnection SQLConnection
78129>>>>>>>>>>>        tSQLConnection SQLConnection
78129>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78130>>>>>>>>>>>        Function_Return SQLConnection
78131>>>>>>>>>>>    End_Function
78132>>>>>>>>>>>
78132>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78134>>>>>>>>>>>        tSQLConnection SQLConnection
78134>>>>>>>>>>>        tSQLConnection SQLConnection
78134>>>>>>>>>>>
78134>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78135>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78137>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78138>>>>>>>>>>>        End
78138>>>>>>>>>>>>
78138>>>>>>>>>>>
78138>>>>>>>>>>>        // Else we might want to change the current connection ID
78138>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78141>>>>>>>>>>>            Move False to Err
78142>>>>>>>>>>>            Logout SQLConnection.sDriverID
78143>>>>>>>>>>>            // This will also make a login to the new server.
78143>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78144>>>>>>>>>>>        End
78144>>>>>>>>>>>>
78144>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78145>>>>>>>>>>>    End_Procedure
78146>>>>>>>>>>>
78146>>>>>>>>>>>    Function psConnectionID Returns String
78148>>>>>>>>>>>        tSQLConnection SQLConnection
78148>>>>>>>>>>>        tSQLConnection SQLConnection
78148>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78149>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78150>>>>>>>>>>>    End_Function
78151>>>>>>>>>>>
78151>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78151>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78151>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78151>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78151>>>>>>>>>>>    Procedure Set psDriverID String sValue
78153>>>>>>>>>>>        tSQLConnection SQLConnection
78153>>>>>>>>>>>        tSQLConnection SQLConnection
78153>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78154>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78155>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78156>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78158>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78159>>>>>>>>>>>        End
78159>>>>>>>>>>>>
78159>>>>>>>>>>>    End_Procedure
78160>>>>>>>>>>>
78160>>>>>>>>>>>    Function psDriverID Returns String
78162>>>>>>>>>>>        tSQLConnection SQLConnection
78162>>>>>>>>>>>        tSQLConnection SQLConnection
78162>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78163>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78165>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78166>>>>>>>>>>>        End
78166>>>>>>>>>>>>
78166>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78167>>>>>>>>>>>    End_Function
78168>>>>>>>>>>>
78168>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78171>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78172>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78173>>>>>>>>>>>    End_Procedure
78174>>>>>>>>>>>
78174>>>>>>>>>>>    Function psConnectionString Returns String
78176>>>>>>>>>>>        tSQLConnection SQLConnection
78176>>>>>>>>>>>        tSQLConnection SQLConnection
78176>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78177>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78178>>>>>>>>>>>    End_Function
78179>>>>>>>>>>>
78179>>>>>>>>>>>    Procedure Set psServer String sValue
78181>>>>>>>>>>>        tSQLConnection SQLConnection
78181>>>>>>>>>>>        tSQLConnection SQLConnection
78181>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78182>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78183>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78184>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78185>>>>>>>>>>>    End_Procedure
78186>>>>>>>>>>>
78186>>>>>>>>>>>    Function psServer Returns String
78188>>>>>>>>>>>        tSQLConnection SQLConnection
78188>>>>>>>>>>>        tSQLConnection SQLConnection
78188>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78189>>>>>>>>>>>        Function_Return SQLConnection.sServer
78190>>>>>>>>>>>    End_Function
78191>>>>>>>>>>>
78191>>>>>>>>>>>    Procedure Set psDatabase String sValue
78193>>>>>>>>>>>        tSQLConnection SQLConnection
78193>>>>>>>>>>>        tSQLConnection SQLConnection
78193>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78194>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78195>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78196>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78197>>>>>>>>>>>    End_Procedure
78198>>>>>>>>>>>
78198>>>>>>>>>>>    Function psDatabase Returns String
78200>>>>>>>>>>>        tSQLConnection SQLConnection
78200>>>>>>>>>>>        tSQLConnection SQLConnection
78200>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78201>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78202>>>>>>>>>>>    End_Function
78203>>>>>>>>>>>
78203>>>>>>>>>>>    Procedure Set psUserID String sValue
78205>>>>>>>>>>>        tSQLConnection SQLConnection
78205>>>>>>>>>>>        tSQLConnection SQLConnection
78205>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78206>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78207>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78208>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78209>>>>>>>>>>>    End_Procedure
78210>>>>>>>>>>>
78210>>>>>>>>>>>    Function psUserID Returns String
78212>>>>>>>>>>>        tSQLConnection SQLConnection
78212>>>>>>>>>>>        tSQLConnection SQLConnection
78212>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78213>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78214>>>>>>>>>>>    End_Function
78215>>>>>>>>>>>
78215>>>>>>>>>>>    // This is the uncrypted password
78215>>>>>>>>>>>    Procedure Set psPassword String sValue
78217>>>>>>>>>>>        tSQLConnection SQLConnection
78217>>>>>>>>>>>        tSQLConnection SQLConnection
78217>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78218>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78219>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78220>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78221>>>>>>>>>>>    End_Procedure
78222>>>>>>>>>>>
78222>>>>>>>>>>>    Function psPassword Returns String
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78225>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78226>>>>>>>>>>>    End_Function
78227>>>>>>>>>>>
78227>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78230>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78231>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78232>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78233>>>>>>>>>>>    End_Procedure
78234>>>>>>>>>>>
78234>>>>>>>>>>>    Function pbTrusted Returns Boolean
78236>>>>>>>>>>>        tSQLConnection SQLConnection
78236>>>>>>>>>>>        tSQLConnection SQLConnection
78236>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78237>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78238>>>>>>>>>>>    End_Function
78239>>>>>>>>>>>
78239>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78239>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78239>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78239>>>>>>>>>>>    //     the central pSQLConnection "hub".
78239>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78242>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78243>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78244>>>>>>>>>>>    End_Procedure
78245>>>>>>>>>>>
78245>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78247>>>>>>>>>>>        tSQLConnection SQLConnection
78247>>>>>>>>>>>        tSQLConnection SQLConnection
78247>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78248>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78249>>>>>>>>>>>    End_Function
78250>>>>>>>>>>>
78250>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78252>>>>>>>>>>>        tSQLConnection SQLConnection
78252>>>>>>>>>>>        tSQLConnection SQLConnection
78252>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78253>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78254>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78255>>>>>>>>>>>    End_Procedure
78256>>>>>>>>>>>
78256>>>>>>>>>>>    Function piDbType Returns Integer
78258>>>>>>>>>>>        tSQLConnection SQLConnection
78258>>>>>>>>>>>        tSQLConnection SQLConnection
78258>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78259>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78260>>>>>>>>>>>    End_Function
78261>>>>>>>>>>>
78261>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78263>>>>>>>>>>>        tSQLConnection SQLConnection
78263>>>>>>>>>>>        tSQLConnection SQLConnection
78263>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78264>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78265>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78266>>>>>>>>>>>    End_Procedure
78267>>>>>>>>>>>
78267>>>>>>>>>>>    Function psBaseTableSpace Returns String
78269>>>>>>>>>>>        tSQLConnection SQLConnection
78269>>>>>>>>>>>        tSQLConnection SQLConnection
78269>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78270>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78271>>>>>>>>>>>    End_Function
78272>>>>>>>>>>>
78272>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78274>>>>>>>>>>>        tSQLConnection SQLConnection
78274>>>>>>>>>>>        tSQLConnection SQLConnection
78274>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78275>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78276>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78277>>>>>>>>>>>    End_Procedure
78278>>>>>>>>>>>
78278>>>>>>>>>>>    Function psIndexTableSpace Returns String
78280>>>>>>>>>>>        tSQLConnection SQLConnection
78280>>>>>>>>>>>        tSQLConnection SQLConnection
78280>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78281>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78282>>>>>>>>>>>    End_Function
78283>>>>>>>>>>>
78283>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78285>>>>>>>>>>>        tSQLConnection SQLConnection
78285>>>>>>>>>>>        tSQLConnection SQLConnection
78285>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78286>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78287>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78288>>>>>>>>>>>    End_Procedure
78289>>>>>>>>>>>
78289>>>>>>>>>>>    Function psLongTableSpace Returns String
78291>>>>>>>>>>>        tSQLConnection SQLConnection
78291>>>>>>>>>>>        tSQLConnection SQLConnection
78291>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78292>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78293>>>>>>>>>>>    End_Function
78294>>>>>>>>>>>
78294>>>>>>>>>>>    Procedure Set psSchema String sValue
78296>>>>>>>>>>>        tSQLConnection SQLConnection
78296>>>>>>>>>>>        tSQLConnection SQLConnection
78296>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78297>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78298>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78299>>>>>>>>>>>    End_Procedure
78300>>>>>>>>>>>
78300>>>>>>>>>>>    Function psSchema Returns String
78302>>>>>>>>>>>        tSQLConnection SQLConnection
78302>>>>>>>>>>>        tSQLConnection SQLConnection
78302>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78303>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78304>>>>>>>>>>>    End_Function
78305>>>>>>>>>>>
78305>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78307>>>>>>>>>>>        tSQLConnection SQLConnection
78307>>>>>>>>>>>        tSQLConnection SQLConnection
78307>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78308>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78309>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78310>>>>>>>>>>>    End_Procedure
78311>>>>>>>>>>>
78311>>>>>>>>>>>    Function pbEnabled Returns Boolean
78313>>>>>>>>>>>        tSQLConnection SQLConnection
78313>>>>>>>>>>>        tSQLConnection SQLConnection
78313>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78314>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78315>>>>>>>>>>>    End_Function
78316>>>>>>>>>>>
78316>>>>>>>>>>>
78316>>>>>>>>>>>    // ************************************
78316>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78318>>>>>>>>>>>        tSQLConnection SQLConnection
78318>>>>>>>>>>>        tSQLConnection SQLConnection
78318>>>>>>>>>>>
78318>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78318>>>>>>>>>>>        // deferr reading SQL connection values until later.
78318>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78320>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78320>>>>>>>>>>>            If (ghoConnection > 0) Begin
78322>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78323>>>>>>>>>>>            End
78323>>>>>>>>>>>>
78323>>>>>>>>>>>
78323>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78323>>>>>>>>>>>            // object is used.
78323>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78325>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78326>>>>>>>>>>>            End
78326>>>>>>>>>>>>
78326>>>>>>>>>>>        End
78326>>>>>>>>>>>>
78326>>>>>>>>>>>
78326>>>>>>>>>>>        Function_Return SQLConnection
78327>>>>>>>>>>>    End_Function
78328>>>>>>>>>>>
78328>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78328>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78330>>>>>>>>>>>        tConnection Connection
78330>>>>>>>>>>>        tConnection Connection
78330>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78330>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78330>>>>>>>>>>>        Integer iRetval iDbType
78330>>>>>>>>>>>        Boolean bOK bConnected
78330>>>>>>>>>>>        String sConnectionID
78330>>>>>>>>>>>
78330>>>>>>>>>>>            tConnection[] Connections
78330>>>>>>>>>>>            tConnection[] Connections
78331>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78331>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78331>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78331>>>>>>>>>>>            //   we then generate an error and abort the program...
78331>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78332>>>>>>>>>>>            If (bOK = False) Begin
78334>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78335>>>>>>>>>>>>
78335>>>>>>>>>>>                Abort
78336>>>>>>>>>>>>
78336>>>>>>>>>>>            End
78336>>>>>>>>>>>>
78336>>>>>>>>>>>            If (sConnectionID = "") Begin
78338>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78339>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78341>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78342>>>>>>>>>>>                End
78342>>>>>>>>>>>>
78342>>>>>>>>>>>            End
78342>>>>>>>>>>>>
78342>>>>>>>>>>>
78342>>>>>>>>>>>            Move 0 to iRetval
78343>>>>>>>>>>>            // DAW DF19 connection info:
78343>>>>>>>>>>>            // We first check that the connection is OK:
78343>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78344>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78344>>>>>>>>>>>            If (iRetval = -1) Begin
78346>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78347>>>>>>>>>>>            End
78347>>>>>>>>>>>>
78347>>>>>>>>>>>
78347>>>>>>>>>>>            If (sConnectionID <> "") Begin
78349>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78350>>>>>>>>>>>            End
78350>>>>>>>>>>>>
78350>>>>>>>>>>>            If (Connection.sId = "") Begin
78352>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78353>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78354>>>>>>>>>>>            End
78354>>>>>>>>>>>>
78354>>>>>>>>>>>
78354>>>>>>>>>>>            // DUF connection info struct property:
78354>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78355>>>>>>>>>>>
78355>>>>>>>>>>>            Move Connection.sId to sConnectionID
78356>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78357>>>>>>>>>>>
78357>>>>>>>>>>>            If (bConnected = False) Begin
78359>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78360>>>>>>>>>>>                If (iRetval <> 0) Begin
78362>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78363>>>>>>>>>>>                    Send Exit_Application
78364>>>>>>>>>>>                End
78364>>>>>>>>>>>>
78364>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78365>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78365>>>>>>>>>>>                // been changed in the DAW db login dialog.
78365>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78366>>>>>>>>>>>            End
78366>>>>>>>>>>>>
78366>>>>>>>>>>>
78366>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78367>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78368>>>>>>>>>>>
78368>>>>>>>>>>>            // Not used in DUF:
78368>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78368>>>>>>>>>>>
78368>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78369>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78370>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78371>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78372>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78373>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78374>>>>>>>>>>>
78374>>>>>>>>>>>            // Not used in DUF:
78374>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78374>>>>>>>>>>>
78374>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78374>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78374>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78376>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78377>>>>>>>>>>>            End
78377>>>>>>>>>>>>
78377>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78379>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78380>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78382>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78383>>>>>>>>>>>                End
78383>>>>>>>>>>>>
78383>>>>>>>>>>>            End
78383>>>>>>>>>>>>
78383>>>>>>>>>>>
78383>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78384>>>>>>>>>>>
78384>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78384>>>>>>>>>>>            // the value from the driver id:
78384>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78385>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78387>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78387>>>>>>>>>>>            Get piDbType                                     to iDbType
78388>>>>>>>>>>>            End
78388>>>>>>>>>>>>
78388>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78390>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78391>>>>>>>>>>>            End
78391>>>>>>>>>>>>
78391>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78392>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78393>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78394>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78395>>>>>>>>>>>
78395>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78395>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78396>>>>>>>>>>>
78396>>>>>>>>>>>        Function_Return SQLConnection
78397>>>>>>>>>>>    End_Function
78398>>>>>>>>>>>
78398>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78398>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78398>>>>>>>>>>>    // connection id for a particular driver.
78398>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78398>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78398>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78398>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78398>>>>>>>>>>>    // connections of the DAW cConnect class.
78398>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78400>>>>>>>>>>>        tConnection[] ConnIdArray
78400>>>>>>>>>>>        tConnection[] ConnIdArray
78401>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78401>>>>>>>>>>>        Boolean bEnabled bFound
78401>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78401>>>>>>>>>>>
78401>>>>>>>>>>>        Move False to bFound
78402>>>>>>>>>>>        If (ghoConnection > 0) Begin
78404>>>>>>>>>>>
78404>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78404>>>>>>>>>>>            Get psDriverID to sDriverID
78405>>>>>>>>>>>
78405>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78406>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78406>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78407>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78408>>>>>>>>>>>            Decrement iSize
78409>>>>>>>>>>>            For iCount from 0 to iSize
78415>>>>>>>>>>>>
78415>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78416>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78417>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78418>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78418>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78418>>>>>>>>>>>                If (sConnectionID = "") Begin
78420>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78421>>>>>>>>>>>                End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>                Else Begin
78422>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78424>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78425>>>>>>>>>>>                    End
78425>>>>>>>>>>>>
78425>>>>>>>>>>>                End
78425>>>>>>>>>>>>
78425>>>>>>>>>>>
78425>>>>>>>>>>>                If (bFound = True) Begin
78427>>>>>>>>>>>                    Increment iConnectionIDCounter
78428>>>>>>>>>>>                End
78428>>>>>>>>>>>>
78428>>>>>>>>>>>            Loop
78429>>>>>>>>>>>>
78429>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78430>>>>>>>>>>>            If (bFound = True) Begin
78432>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78433>>>>>>>>>>>            End
78433>>>>>>>>>>>>
78433>>>>>>>>>>>        End
78433>>>>>>>>>>>>
78433>>>>>>>>>>>
78433>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78433>>>>>>>>>>>        // but no DFConn.ini record has been created.
78433>>>>>>>>>>>        If (iSize = -1) Begin
78435>>>>>>>>>>>            Move True to bFound
78436>>>>>>>>>>>        End
78436>>>>>>>>>>>>
78436>>>>>>>>>>>
78436>>>>>>>>>>>        Function_Return bFound
78437>>>>>>>>>>>    End_Function
78438>>>>>>>>>>>
78438>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78438>>>>>>>>>>>    // create a connection to the server.
78438>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78440>>>>>>>>>>>        String sPath sFileName
78440>>>>>>>>>>>        Boolean bExists bActive
78440>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78440>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78441>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78441>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78441>>>>>>>>>>>        Handle hoIniFile
78441>>>>>>>>>>>        Integer iSize iCount iRetval
78441>>>>>>>>>>>
78441>>>>>>>>>>>        Get psIniFilePath to sPath
78442>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78443>>>>>>>>>>>        If (sPath = "") Begin
78445>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78446>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78447>>>>>>>>>>>        End
78447>>>>>>>>>>>>
78447>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78448>>>>>>>>>>>        Get psIniFileName to sFileName
78449>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78450>>>>>>>>>>>
78450>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78451>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78452>>>>>>>>>>>        If (iSize = 0) Begin
78454>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78454>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78454>>>>>>>>>>>            // in the cApplication object.
78454>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78455>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78457>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78458>>>>>>>>>>>            End
78458>>>>>>>>>>>>
78458>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78459>>>>>>>>>>>            Move 1 to iSize
78460>>>>>>>>>>>        End
78460>>>>>>>>>>>>
78460>>>>>>>>>>>
78460>>>>>>>>>>>        Move False to bActive
78461>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78461>>>>>>>>>>>        Decrement iSize
78462>>>>>>>>>>>        For iCount from 0 to iSize
78468>>>>>>>>>>>>
78468>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78469>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78471>>>>>>>>>>>                Move True to bActive
78472>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78473>>>>>>>>>>>            End
78473>>>>>>>>>>>>
78473>>>>>>>>>>>        Loop
78474>>>>>>>>>>>>
78474>>>>>>>>>>>
78474>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78474>>>>>>>>>>>        If (bActive = False) Begin
78476>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78477>>>>>>>>>>>        End
78477>>>>>>>>>>>>
78477>>>>>>>>>>>
78477>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78478>>>>>>>>>>>
78478>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78479>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78480>>>>>>>>>>>
78480>>>>>>>>>>>        Function_Return SQLConnection
78481>>>>>>>>>>>    End_Function
78482>>>>>>>>>>>
78482>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78484>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78485>>>>>>>>>>>    End_Procedure
78486>>>>>>>>>>>
78486>>>>>>>>>>>    Function psIniFilePath Returns String
78488>>>>>>>>>>>        String sRetval
78488>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78489>>>>>>>>>>>        Function_Return sRetval
78490>>>>>>>>>>>    End_Function
78491>>>>>>>>>>>
78491>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78493>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78494>>>>>>>>>>>    End_Procedure
78495>>>>>>>>>>>
78495>>>>>>>>>>>    Function psIniFileName Returns String
78497>>>>>>>>>>>        String sRetval
78497>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78498>>>>>>>>>>>        Function_Return sRetval
78499>>>>>>>>>>>    End_Function
78500>>>>>>>>>>>
78500>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78502>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78503>>>>>>>>>>>    End_Procedure
78504>>>>>>>>>>>
78504>>>>>>>>>>>    Function psIniSectionName Returns String
78506>>>>>>>>>>>        String sRetval
78506>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78507>>>>>>>>>>>        Function_Return sRetval
78508>>>>>>>>>>>    End_Function
78509>>>>>>>>>>>
78509>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78511>>>>>>>>>>>        Handle ho
78511>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78512>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78513>>>>>>>>>>>    End_Procedure
78514>>>>>>>>>>>
78514>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78516>>>>>>>>>>>        Handle ho
78516>>>>>>>>>>>        String sRetval
78516>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78517>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78518>>>>>>>>>>>        Function_Return sRetval
78519>>>>>>>>>>>    End_Function
78520>>>>>>>>>>>
78520>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78522>>>>>>>>>>>        Handle ho
78522>>>>>>>>>>>        Boolean bRetval
78522>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78523>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78524>>>>>>>>>>>        Function_Return bRetval
78525>>>>>>>>>>>    End_Function
78526>>>>>>>>>>>
78526>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78528>>>>>>>>>>>        Handle ho
78528>>>>>>>>>>>        Boolean bRetval
78528>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78529>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78530>>>>>>>>>>>        Function_Return bRetval
78531>>>>>>>>>>>    End_Function
78532>>>>>>>>>>>
78532>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78534>>>>>>>>>>>        Handle ho
78534>>>>>>>>>>>        String sRetval
78534>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78535>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78536>>>>>>>>>>>        Function_Return sRetval
78537>>>>>>>>>>>    End_Function
78538>>>>>>>>>>>
78538>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78540>>>>>>>>>>>        Handle ho
78540>>>>>>>>>>>        String sRetval
78540>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78541>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78542>>>>>>>>>>>        Function_Return sRetval
78543>>>>>>>>>>>    End_Function
78544>>>>>>>>>>>
78544>>>>>>>>>>>    // *** Main Connection Message ***
78544>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78546>>>>>>>>>>>        Handle hoDriver
78546>>>>>>>>>>>        String sConnectionString sError
78546>>>>>>>>>>>        Boolean bLoginSuccessful
78546>>>>>>>>>>>
78546>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78547>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78548>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78549>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78550>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78552>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78553>>>>>>>>>>>>
78553>>>>>>>>>>>            If (bExitProgram = True) Begin
78555>>>>>>>>>>>                Send Exit_Application
78556>>>>>>>>>>>            End
78556>>>>>>>>>>>>
78556>>>>>>>>>>>        End
78556>>>>>>>>>>>>
78556>>>>>>>>>>>        Send Destroy of hoDriver
78557>>>>>>>>>>>    End_Procedure
78558>>>>>>>>>>>
78558>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78560>>>>>>>>>>>        Integer iRetval
78560>>>>>>>>>>>        Handle hoCLI
78560>>>>>>>>>>>        String sDriverID
78560>>>>>>>>>>>
78560>>>>>>>>>>>        Get psDriverID to sDriverID
78561>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78562>>>>>>>>>>>        If (hoCLI <> 0) Begin
78564>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78565>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78566>>>>>>>>>>>            Send Destroy of hoCLI
78567>>>>>>>>>>>        End
78567>>>>>>>>>>>>
78567>>>>>>>>>>>
78567>>>>>>>>>>>        Function_Return iRetval
78568>>>>>>>>>>>    End_Function
78569>>>>>>>>>>>
78569>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78571>>>>>>>>>>>        tSQLConnection SQLConnection
78571>>>>>>>>>>>        tSQLConnection SQLConnection
78571>>>>>>>>>>>
78571>>>>>>>>>>>        Set psDriverID to sDriverID
78572>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78573>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78574>>>>>>>>>>>    End_Procedure
78575>>>>>>>>>>>
78575>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78575>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78575>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78575>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78575>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78575>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78575>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78575>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78577>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78577>>>>>>>>>>>        Handle hoCLI
78577>>>>>>>>>>>        String sID
78577>>>>>>>>>>>
78577>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78579>>>>>>>>>>>            Procedure_Return
78580>>>>>>>>>>>        End
78580>>>>>>>>>>>>
78580>>>>>>>>>>>
78580>>>>>>>>>>>        Move 0 to iResult
78581>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78582>>>>>>>>>>>        If (hoCLI <> 0) Begin
78584>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78585>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78586>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78589>>>>>>>>>>>            Decrement iNumConn
78590>>>>>>>>>>>            For iConn from 0 to iNumConn
78596>>>>>>>>>>>>
78596>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78599>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78601>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78602>>>>>>>>>>>                End
78602>>>>>>>>>>>>
78602>>>>>>>>>>>            Loop
78603>>>>>>>>>>>>
78603>>>>>>>>>>>            Send Destroy of hoCLI
78604>>>>>>>>>>>        End
78604>>>>>>>>>>>>
78604>>>>>>>>>>>
78604>>>>>>>>>>>    End_Procedure
78605>>>>>>>>>>>
78605>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78607>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78607>>>>>>>>>>>        Handle hoCLI
78607>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78607>>>>>>>>>>>        tSQLConnection SQLConnection
78607>>>>>>>>>>>        tSQLConnection SQLConnection
78607>>>>>>>>>>>        Boolean bTrusted
78607>>>>>>>>>>>
78607>>>>>>>>>>>        Move 0 to iResult
78608>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78609>>>>>>>>>>>        If (hoCLI <> 0) Begin
78611>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78612>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78613>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78616>>>>>>>>>>>            Decrement iNumConn
78617>>>>>>>>>>>            For iConn from 0 to iNumConn
78623>>>>>>>>>>>>
78623>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78626>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78628>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78629>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78632>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78635>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78636>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78639>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78640>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78641>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78642>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78643>>>>>>>>>>>
78643>>>>>>>>>>>                    Case Begin
78643>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78645>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78646>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78647>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78648>>>>>>>>>>>                            Case Break
78649>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78652>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78653>>>>>>>>>>>                            Case Break
78654>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78657>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78658>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78660>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78661>>>>>>>>>>>                            End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>                            Case Break
78662>>>>>>>>>>>                        Case Else
78662>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78663>>>>>>>>>>>>
78663>>>>>>>>>>>                            Case Break
78664>>>>>>>>>>>                    Case End
78664>>>>>>>>>>>                End
78664>>>>>>>>>>>>
78664>>>>>>>>>>>            Loop
78665>>>>>>>>>>>>
78665>>>>>>>>>>>            Send Destroy of hoCLI
78666>>>>>>>>>>>        End
78666>>>>>>>>>>>>
78666>>>>>>>>>>>
78666>>>>>>>>>>>        Function_Return SQLConnection
78667>>>>>>>>>>>    End_Function
78668>>>>>>>>>>>
78668>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78670>>>>>>>>>>>        String  sCurrentDriver
78670>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78670>>>>>>>>>>>
78670>>>>>>>>>>>        Move 0 to iDriver
78671>>>>>>>>>>>        Move 0 to iCount
78672>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78675>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78681>>>>>>>>>>>>
78681>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78684>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78686>>>>>>>>>>>                Function_Return iCount
78687>>>>>>>>>>>            End
78687>>>>>>>>>>>>
78687>>>>>>>>>>>        Loop
78688>>>>>>>>>>>>
78688>>>>>>>>>>>
78688>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78688>>>>>>>>>>>        If (iDriver = 0) Begin
78690>>>>>>>>>>>            Move 0 to LastErr
78691>>>>>>>>>>>            Load_Driver sDriverID
78692>>>>>>>>>>>            // If driver could not be loaded.
78692>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78694>>>>>>>>>>>                Move -1 to iCount
78695>>>>>>>>>>>            End
78695>>>>>>>>>>>>
78695>>>>>>>>>>>        End
78695>>>>>>>>>>>>
78695>>>>>>>>>>>        Function_Return iCount
78696>>>>>>>>>>>    End_Function
78697>>>>>>>>>>>
78697>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78697>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78699>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78699>>>>>>>>>>>        Boolean bTrusted bSilent
78699>>>>>>>>>>>        Integer iRetval
78699>>>>>>>>>>>
78699>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78700>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78701>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78702>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78703>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78704>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78705>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78706>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78707>>>>>>>>>>>
78707>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78708>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78708>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78709>>>>>>>>>>>    End_Procedure
78710>>>>>>>>>>>
78710>>>>>>>>>>>    // Called when the object is constructed.
78710>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78710>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78710>>>>>>>>>>>    // the database is needed.
78710>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78712>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78712>>>>>>>>>>>        Integer iDriver iRetval
78712>>>>>>>>>>>        Handle hoCLI
78712>>>>>>>>>>>        Boolean bOK bSilent
78712>>>>>>>>>>>
78712>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78713>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78714>>>>>>>>>>>        Get psConnectionString to sConnectionString
78715>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78715>>>>>>>>>>>        Get psDriverID to sDriverID
78716>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78717>>>>>>>>>>>        If (bOK = False) Begin
78719>>>>>>>>>>>            Function_Return False
78720>>>>>>>>>>>        End
78720>>>>>>>>>>>>
78720>>>>>>>>>>>
78720>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78721>>>>>>>>>>>        // If driver not loaded; load it.
78721>>>>>>>>>>>        If (iDriver = 0) Begin
78723>>>>>>>>>>>            Load_Driver sDriverID
78724>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78725>>>>>>>>>>>        End
78725>>>>>>>>>>>>
78725>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78725>>>>>>>>>>>        If (iDriver = 0) Begin
78727>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78728>>>>>>>>>>>>
78728>>>>>>>>>>>            Function_Return False
78729>>>>>>>>>>>        End           
78729>>>>>>>>>>>>
78729>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78732>>>>>>>>>>>        
78732>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78733>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78734>>>>>>>>>>>        // Delete the connection first; in case it exists
78734>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78735>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78736>>>>>>>>>>>        Send Destroy of hoCLI
78737>>>>>>>>>>>
78737>>>>>>>>>>>        Function_Return (iRetval = 0)
78738>>>>>>>>>>>    End_Function
78739>>>>>>>>>>>
78739>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78741>>>>>>>>>>>        Boolean bOK
78741>>>>>>>>>>>
78741>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78742>>>>>>>>>>>
78742>>>>>>>>>>>        If (bOK = False) Begin
78744>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78745>>>>>>>>>>>>
78745>>>>>>>>>>>            Function_Return False
78746>>>>>>>>>>>        End
78746>>>>>>>>>>>>
78746>>>>>>>>>>>
78746>>>>>>>>>>>        Function_Return True
78747>>>>>>>>>>>    End_Function
78748>>>>>>>>>>>
78748>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78750>>>>>>>>>>>        Boolean bOK
78750>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78751>>>>>>>>>>>        Function_Return bOK
78752>>>>>>>>>>>    End_Function
78753>>>>>>>>>>>
78753>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78755>>>>>>>>>>>        Handle hoIniFile
78755>>>>>>>>>>>        String sConnect
78755>>>>>>>>>>>
78755>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78756>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78757>>>>>>>>>>>
78757>>>>>>>>>>>        Function_Return sConnect
78758>>>>>>>>>>>    End_Function
78759>>>>>>>>>>>
78759>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78759>>>>>>>>>>>    // Pass a complete driver connection string
78759>>>>>>>>>>>    // Returns the following as a struct:
78759>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78759>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78759>>>>>>>>>>>    //
78759>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78761>>>>>>>>>>>        tSQLConnection SQLConnection
78761>>>>>>>>>>>        tSQLConnection SQLConnection
78761>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78761>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78761>>>>>>>>>>>        Integer iPos
78761>>>>>>>>>>>
78761>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78762>>>>>>>>>>>        If (bOK = False) Begin
78764>>>>>>>>>>>            Function_Return SQLConnection
78765>>>>>>>>>>>        End
78765>>>>>>>>>>>>
78765>>>>>>>>>>>
78765>>>>>>>>>>>        Move False to bTrusted
78766>>>>>>>>>>>        Move False to bSilent
78767>>>>>>>>>>>
78767>>>>>>>>>>>        Case Begin
78767>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78769>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78770>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78771>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78772>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78773>>>>>>>>>>>                If (bTrusted = False) Begin
78775>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78776>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78777>>>>>>>>>>>                End
78777>>>>>>>>>>>>
78777>>>>>>>>>>>                Case Break
78778>>>>>>>>>>>
78778>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78781>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78783>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78784>>>>>>>>>>>                End
78784>>>>>>>>>>>>
78784>>>>>>>>>>>                Else Begin
78785>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78786>>>>>>>>>>>                End
78786>>>>>>>>>>>>
78786>>>>>>>>>>>
78786>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78787>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78788>>>>>>>>>>>                If (bTrusted = False) Begin
78790>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78791>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78792>>>>>>>>>>>                End
78792>>>>>>>>>>>>
78792>>>>>>>>>>>                Case Break
78793>>>>>>>>>>>
78793>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78796>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78797>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78798>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78799>>>>>>>>>>>                Case Break
78800>>>>>>>>>>>
78800>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78803>>>>>>>>>>>                Break
78804>>>>>>>>>>>        Case End
78804>>>>>>>>>>>
78804>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78805>>>>>>>>>>>
78805>>>>>>>>>>>        // bSilent?
78805>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78806>>>>>>>>>>>        If (iPos = 0) Begin
78808>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78809>>>>>>>>>>>        End
78809>>>>>>>>>>>>
78809>>>>>>>>>>>        If (iPos = 0) Begin
78811>>>>>>>>>>>            Move "0"                                                            to sValue
78812>>>>>>>>>>>        End
78812>>>>>>>>>>>>
78812>>>>>>>>>>>        Else Begin
78813>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78814>>>>>>>>>>>        End
78814>>>>>>>>>>>>
78814>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78815>>>>>>>>>>>
78815>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78816>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78817>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78818>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78819>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78820>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78821>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78822>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78823>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78824>>>>>>>>>>>
78824>>>>>>>>>>>        Function_Return SQLConnection
78825>>>>>>>>>>>    End_Function
78826>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78826>>>>>>>>>>>>
78826>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78828>>>>>>>>>>>>    Integer iStart iEnd
78828>>>>>>>>>>>>    String sRetval
78828>>>>>>>>>>>>
78828>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78829>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78830>>>>>>>>>>>>    If (iStart = 0) Begin
78832>>>>>>>>>>>>        Function_Return ""
78833>>>>>>>>>>>>    End
78833>>>>>>>>>>>>>
78833>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78834>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78835>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78837>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78838>>>>>>>>>>>>    End
78838>>>>>>>>>>>>>
78838>>>>>>>>>>>>    Else Begin
78839>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78840>>>>>>>>>>>>    End
78840>>>>>>>>>>>>>
78840>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78842>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78843>>>>>>>>>>>>        Decrement iEnd
78844>>>>>>>>>>>>    End
78844>>>>>>>>>>>>>
78844>>>>>>>>>>>>    If (iEnd <> 0) Begin
78846>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78847>>>>>>>>>>>>    End
78847>>>>>>>>>>>>>
78847>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78848>>>>>>>>>>>>
78848>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78849>>>>>>>>>>>>End_Function
78850>>>>>>>>>>>>
78850>>>>>>>>>>>>
78850>>>>>>>>>>>
78850>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78850>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78852>>>>>>>>>>>        Handle ho
78852>>>>>>>>>>>        Integer iIndex
78852>>>>>>>>>>>        Boolean bRetval bOK
78852>>>>>>>>>>>        tSQLConnection SQLConnection
78852>>>>>>>>>>>        tSQLConnection SQLConnection
78852>>>>>>>>>>>
78852>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78853>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78854>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78855>>>>>>>>>>>        If (iIndex = -1) Begin
78857>>>>>>>>>>>            Function_Return False
78858>>>>>>>>>>>        End
78858>>>>>>>>>>>>
78858>>>>>>>>>>>
78858>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78859>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78860>>>>>>>>>>>        If (ghoConnection > 0) Begin
78862>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78863>>>>>>>>>>>            If (iIndex <> -1) Begin
78865>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78866>>>>>>>>>>>            End
78866>>>>>>>>>>>>
78866>>>>>>>>>>>        End
78866>>>>>>>>>>>>
78866>>>>>>>>>>>
78866>>>>>>>>>>>        Function_Return bRetval
78867>>>>>>>>>>>    End_Function
78868>>>>>>>>>>>
78868>>>>>>>>>>>    Procedure Set pbDFConnid Boolean bState
78870>>>>>>>>>>>        Set pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78871>>>>>>>>>>>    End_Procedure
78872>>>>>>>>>>>    
78872>>>>>>>>>>>    Function pbDFConnid Returns Boolean
78874>>>>>>>>>>>        Boolean bState
78874>>>>>>>>>>>        Get pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78875>>>>>>>>>>>        Function_Return bState
78876>>>>>>>>>>>    End_Function
78877>>>>>>>>>>>
78877>>>>>>>>>>>End_Class
78878>>>>>>>>>Use vWin32fh.pkg
78878>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78878>>>>>>>>>>>Use LanguageText.pkg
78878>>>>>>>>>>>Use Windows.pkg
78878>>>>>>>>>>>Use Dfclient.pkg
78878>>>>>>>>>>>Use DFbitmap.pkg
78878>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78878>>>>>>>>>>>Use cRichEdit.pkg
78878>>>>>>>>>>>Use cTextEdit.pkg
78878>>>>>>>>>>>Use cRichEdit.pkg
78878>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78878>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78878>>>>>>>>>>>>>>>Use VDFBase.pkg
78878>>>>>>>>>>>>>>>
78878>>>>>>>>>>>>>>>Class cFormatter is an cObject
78879>>>>>>>>>>>>>>>    
78879>>>>>>>>>>>>>>>    Procedure Construct_object
78881>>>>>>>>>>>>>>>        Integer iCh
78881>>>>>>>>>>>>>>>        Forward Send construct_object
78883>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78884>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78885>>>>>>>>>>>>>>>        
78885>>>>>>>>>>>>>>>        Property String  psLeft
78886>>>>>>>>>>>>>>>        Property String  psright
78887>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78888>>>>>>>>>>>>>>>        Property Integer piPoints
78889>>>>>>>>>>>>>>>        
78889>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78890>>>>>>>>>>>>>>>        Property String  psCurPosright
78891>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78892>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78893>>>>>>>>>>>>>>>        
78893>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78894>>>>>>>>>>>>>>>        Property String  psCurNegright
78895>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78896>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78897>>>>>>>>>>>>>>>        
78897>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78898>>>>>>>>>>>>>>>        Property String  psNumPosright
78899>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78900>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78901>>>>>>>>>>>>>>>        
78901>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78902>>>>>>>>>>>>>>>        Property String  psNumNegright
78903>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78904>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78905>>>>>>>>>>>>>>>        
78905>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78906>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78907>>>>>>>>>>>>>>>        
78907>>>>>>>>>>>>>>>    End_Procedure
78908>>>>>>>>>>>>>>>    
78908>>>>>>>>>>>>>>>    // internal
78908>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78908>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78910>>>>>>>>>>>>>>>        
78910>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78910>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78910>>>>>>>>>>>>>>>        
78910>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78910>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78910>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78911>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78912>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78913>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78914>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78915>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78916>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78917>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78918>>>>>>>>>>>>>>>        
78918>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78919>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78922>>>>>>>>>>>>>>>        
78922>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78923>>>>>>>>>>>>>>>        
78923>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78924>>>>>>>>>>>>>>>        
78924>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78924>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78925>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78926>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78927>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78928>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78929>>>>>>>>>>>>>>>        
78929>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78931>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78932>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78934>>>>>>>>>>>>>>>                Move -2 to iDigits
78935>>>>>>>>>>>>>>>                Increment i
78936>>>>>>>>>>>>>>>            End
78936>>>>>>>>>>>>>>>>
78936>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78940>>>>>>>>>>>>>>>                Increment i
78941>>>>>>>>>>>>>>>            Loop
78942>>>>>>>>>>>>>>>>
78942>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78943>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78946>>>>>>>>>>>>>>>            //
78946>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78947>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78951>>>>>>>>>>>>>>>                Increment i
78952>>>>>>>>>>>>>>>            Loop
78953>>>>>>>>>>>>>>>>
78953>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78954>>>>>>>>>>>>>>>        End
78954>>>>>>>>>>>>>>>>
78954>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78955>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78956>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78957>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78959>>>>>>>>>>>>>>>                Move sFmt to sLeft
78960>>>>>>>>>>>>>>>                Move ""   to sRight
78961>>>>>>>>>>>>>>>            End
78961>>>>>>>>>>>>>>>>
78961>>>>>>>>>>>>>>>            Else Begin
78962>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78963>>>>>>>>>>>>>>>                Move 1 to i
78964>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78968>>>>>>>>>>>>>>>                    Increment i
78969>>>>>>>>>>>>>>>                Loop
78970>>>>>>>>>>>>>>>>
78970>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78971>>>>>>>>>>>>>>>            End
78971>>>>>>>>>>>>>>>>
78971>>>>>>>>>>>>>>>        End
78971>>>>>>>>>>>>>>>>
78971>>>>>>>>>>>>>>>        // set temporary format properties and exit
78971>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78972>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78973>>>>>>>>>>>>>>>        Set psRight        to sRight
78974>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78975>>>>>>>>>>>>>>>    End_Procedure
78976>>>>>>>>>>>>>>>    
78976>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78976>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78976>>>>>>>>>>>>>>>    //
78976>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78976>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78978>>>>>>>>>>>>>>>        String sPos sNeg
78978>>>>>>>>>>>>>>>        Integer iPos
78978>>>>>>>>>>>>>>>        
78978>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78979>>>>>>>>>>>>>>>        If iPos Begin
78981>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78982>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78983>>>>>>>>>>>>>>>        End
78983>>>>>>>>>>>>>>>>
78983>>>>>>>>>>>>>>>        Else Begin
78984>>>>>>>>>>>>>>>            Move sFmt         to sPos
78985>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78986>>>>>>>>>>>>>>>        End
78986>>>>>>>>>>>>>>>>
78986>>>>>>>>>>>>>>>        Send ParseFormat sPos
78987>>>>>>>>>>>>>>>        If bCurrency Begin
78989>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78990>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78991>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78992>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78993>>>>>>>>>>>>>>>        End
78993>>>>>>>>>>>>>>>>
78993>>>>>>>>>>>>>>>        Else Begin
78994>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78995>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78996>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78997>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78998>>>>>>>>>>>>>>>        End
78998>>>>>>>>>>>>>>>>
78998>>>>>>>>>>>>>>>        
78998>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78999>>>>>>>>>>>>>>>        If bCurrency Begin
79001>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
79002>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
79003>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
79004>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
79005>>>>>>>>>>>>>>>        End
79005>>>>>>>>>>>>>>>>
79005>>>>>>>>>>>>>>>        Else Begin
79006>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
79007>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
79008>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
79009>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
79010>>>>>>>>>>>>>>>        End
79010>>>>>>>>>>>>>>>>
79010>>>>>>>>>>>>>>>    End_Procedure
79011>>>>>>>>>>>>>>>    
79011>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
79011>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
79013>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
79013>>>>>>>>>>>>>>>        Integer iDec iLen iCh
79013>>>>>>>>>>>>>>>        
79013>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
79016>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
79017>>>>>>>>>>>>>>>        
79017>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
79018>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
79019>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
79020>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
79021>>>>>>>>>>>>>>>        // format for decimal separator
79021>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
79024>>>>>>>>>>>>>>>        
79024>>>>>>>>>>>>>>>        // format for thousand sep.
79024>>>>>>>>>>>>>>>        If bSep Begin
79026>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
79029>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
79030>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
79031>>>>>>>>>>>>>>>            While (iLen>3)
79035>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79036>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79037>>>>>>>>>>>>>>>            Loop
79038>>>>>>>>>>>>>>>>
79038>>>>>>>>>>>>>>>        End
79038>>>>>>>>>>>>>>>>
79038>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79038>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79041>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79042>>>>>>>>>>>>>>>    End_Function
79043>>>>>>>>>>>>>>>    
79043>>>>>>>>>>>>>>>    // Public: Format for currency
79043>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79045>>>>>>>>>>>>>>>        String  sLeft sRight
79045>>>>>>>>>>>>>>>        Integer bSep
79045>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79047>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79048>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79049>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79050>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79053>>>>>>>>>>>>>>>        End
79053>>>>>>>>>>>>>>>>
79053>>>>>>>>>>>>>>>        Else Begin
79054>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79055>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79056>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79057>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79060>>>>>>>>>>>>>>>        End
79060>>>>>>>>>>>>>>>>
79060>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79061>>>>>>>>>>>>>>>    End_Function
79062>>>>>>>>>>>>>>>    
79062>>>>>>>>>>>>>>>    // Public: Format for numeric
79062>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79064>>>>>>>>>>>>>>>        String  sLeft sRight
79064>>>>>>>>>>>>>>>        Integer bSep
79064>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79066>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79067>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79068>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79069>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79072>>>>>>>>>>>>>>>        End
79072>>>>>>>>>>>>>>>>
79072>>>>>>>>>>>>>>>        Else Begin
79073>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79074>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79075>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79076>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79079>>>>>>>>>>>>>>>        End
79079>>>>>>>>>>>>>>>>
79079>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79080>>>>>>>>>>>>>>>    End_Function
79081>>>>>>>>>>>>>>>    
79081>>>>>>>>>>>>>>>    
79081>>>>>>>>>>>>>>>    // Public: Format passing format string
79081>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79083>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79083>>>>>>>>>>>>>>>        String  sLeft sRight
79083>>>>>>>>>>>>>>>        Integer iPoints bSep
79083>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79084>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79085>>>>>>>>>>>>>>>        Case Begin
79085>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79088>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79092>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79096>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79098>>>>>>>>>>>>>>>        Case End
79098>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79099>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79100>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79101>>>>>>>>>>>>>>>        Get psRight        to sRight
79102>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79103>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79104>>>>>>>>>>>>>>>    End_Function
79105>>>>>>>>>>>>>>>    
79105>>>>>>>>>>>>>>>End_Class
79106>>>>>>>>>>>>>
79106>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79106>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79107>>>>>>>>>>>>>
79107>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79109>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79110>>>>>>>>>>>>>End_Function
79111>>>>>>>>>>>>>
79111>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79113>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79114>>>>>>>>>>>>>End_Function
79115>>>>>>>>>>>>>
79115>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79117>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79118>>>>>>>>>>>>>End_Function
79119>>>>>>>>>>>>>
79119>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79121>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79122>>>>>>>>>>>>>End_Procedure
79123>>>>>>>>>>>>>
79123>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79125>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79126>>>>>>>>>>>>>End_Procedure
79127>>>>>>>>>>>>>
79127>>>>>>>>>>>>>
79127>>>>>>>>>>>Use tWinStructs.pkg
79127>>>>>>>>>>>
79127>>>>>>>>>>>Use cli.pkg
79127>>>>>>>>>>>Use DFBTRDRV.PKG
79127>>>>>>>>>>>Use MSSqldrv.pkg
79127>>>>>>>>>>>Use db2_drv.pkg
79127>>>>>>>>>>>Use odbc_drv.pkg
79127>>>>>>>>>>>Use seq_chnl.pkg
79127>>>>>>>>>>>
79127>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79127>>>>>>>>>>>Register_Function Help_filename Returns String
79127>>>>>>>>>>>Register_Function GetHelpFile Returns String
79127>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79127>>>>>>>>>>>
79127>>>>>>>>>>>// *** Constant Declarations: ***
79127>>>>>>>>>>>//
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>// System icon menu constants. If the upper left hand
79127>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79127>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79127>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79127>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79127>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79127>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79127>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79127>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79127>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79127>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79127>>>>>>>>>>>
79127>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79127>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79127>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79127>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79127>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79127>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79127>>>>>>>>>>>
79127>>>>>>>>>>>// *** Struct Declarations: ***
79127>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79127>>>>>>>>>>>    DWord   cbSize
79127>>>>>>>>>>>    Integer fMask
79127>>>>>>>>>>>    Handle  hwnd
79127>>>>>>>>>>>    Pointer lpVerb
79127>>>>>>>>>>>    Pointer lpFile
79127>>>>>>>>>>>    Pointer lpParameters
79127>>>>>>>>>>>    Pointer lpDirectory
79127>>>>>>>>>>>    Integer nShow
79127>>>>>>>>>>>    Integer iMissingAlignment1
79127>>>>>>>>>>>    Pointer hInstApp
79127>>>>>>>>>>>    Pointer lpIDList
79127>>>>>>>>>>>    Pointer lpClass
79127>>>>>>>>>>>    Handle  hkeyClass
79127>>>>>>>>>>>    DWord   dwHotKey
79127>>>>>>>>>>>    Integer iMissingAlignment2
79127>>>>>>>>>>>    Handle  hIconMonitor // Union
79127>>>>>>>>>>>    //Handle  hMonitor     // Union
79127>>>>>>>>>>>    Handle  hProcess
79127>>>>>>>>>>>End_Struct
79127>>>>>>>>>>>
79127>>>>>>>>>>>
79127>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79127>>>>>>>>>>>//Type MEMORYSTATUS
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79127>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79127>>>>>>>>>>>//End_Type
79127>>>>>>>>>>>
79127>>>>>>>>>>>// *** External Function calls: ***
79127>>>>>>>>>>>//
79127>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79128>>>>>>>>>>>
79128>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79129>>>>>>>>>>>
79129>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79129>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79130>>>>>>>>>>>
79130>>>>>>>>>>>    // Wrapper Function WNetGetUser
79130>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79132>>>>>>>>>>>
79132>>>>>>>>>>>        DWord   dwResult
79132>>>>>>>>>>>        UWide   uwName uwUserName
79132>>>>>>>>>>>        UWide   uwName uwUserName
79132>>>>>>>>>>>
79132>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79133>>>>>>>>>>>
79133>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79134>>>>>>>>>>>
79134>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79135>>>>>>>>>>>
79135>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79136>>>>>>>>>>>
79136>>>>>>>>>>>        Function_Return dwResult
79137>>>>>>>>>>>    End_Function
79138>>>>>>>>>>>
79138>>>>>>>>>>>
79138>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79139>>>>>>>>>>>
79139>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79140>>>>>>>>>>>
79140>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79141>>>>>>>>>>>
79141>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79142>>>>>>>>>>>
79142>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79143>>>>>>>>>>>
79143>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79143>>>>>>>>>>>
79143>>>>>>>>>>>Function ComputerName Desktop Returns String
79145>>>>>>>>>>>    String sName
79145>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79146>>>>>>>>>>>>
79146>>>>>>>>>>>    Function_Return sName
79147>>>>>>>>>>>End_Function
79148>>>>>>>>>>>
79148>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79150>>>>>>>>>>>    WString wName
79150>>>>>>>>>>>    Integer iRetval iLength
79150>>>>>>>>>>>
79150>>>>>>>>>>>    Move 0 to iLength
79151>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79152>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79153>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79154>>>>>>>>>>>
79154>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79156>>>>>>>>>>>        Function_Return (CString (wName))
79157>>>>>>>>>>>    End
79157>>>>>>>>>>>>
79157>>>>>>>>>>>
79157>>>>>>>>>>>    Function_Return "User Unknown"
79158>>>>>>>>>>>End_Function
79159>>>>>>>>>>>
79159>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79161>>>>>>>>>>>    String sClient sDriver sClientDriver
79161>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79161>>>>>>>>>>>    Handle hoMsqlDrv
79161>>>>>>>>>>>
79161>>>>>>>>>>>    Move 0 to iDriver
79162>>>>>>>>>>>    Move "" to sClient
79163>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79166>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79172>>>>>>>>>>>>
79172>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79175>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79177>>>>>>>>>>>            Move iCount to iDriver
79178>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79179>>>>>>>>>>>        End
79179>>>>>>>>>>>>
79179>>>>>>>>>>>    Loop
79180>>>>>>>>>>>>
79180>>>>>>>>>>>
79180>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79180>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79182>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79185>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79186>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79187>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79188>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79189>>>>>>>>>>>    End
79189>>>>>>>>>>>>
79189>>>>>>>>>>>
79189>>>>>>>>>>>    Function_Return sClient
79190>>>>>>>>>>>End_Function
79191>>>>>>>>>>>
79191>>>>>>>>>>>// *** Class Declarations: ***
79191>>>>>>>>>>>//
79191>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79192>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79194>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79195>>>>>>>>>>>    End_Procedure
79196>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79198>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79200>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79201>>>>>>>>>>>    End_Procedure
79202>>>>>>>>>>>End_Class
79203>>>>>>>>>>>
79203>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79204>>>>>>>>>>>    Procedure Construct_Object
79206>>>>>>>>>>>        Forward Send Construct_Object
79208>>>>>>>>>>>        Property Handle phoEditorHandle
79209>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79210>>>>>>>>>>>    End_Procedure
79211>>>>>>>>>>>
79211>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79213>>>>>>>>>>>        Handle hoEditor
79213>>>>>>>>>>>        Boolean bCanCopy
79213>>>>>>>>>>>        Address aEditorAddress
79213>>>>>>>>>>>
79213>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79214>>>>>>>>>>>        Send Select_All of hoEditor
79215>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79216>>>>>>>>>>>        If (bCanCopy = True) Begin
79218>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79219>>>>>>>>>>>            Send Copy   of hoEditor
79220>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79220>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79221>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79222>>>>>>>>>>>        End
79222>>>>>>>>>>>>
79222>>>>>>>>>>>    End_Procedure
79223>>>>>>>>>>>End_Class
79224>>>>>>>>>>>
79224>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79225>>>>>>>>>>>    Procedure Construct_Object
79227>>>>>>>>>>>        Forward Send Construct_Object
79229>>>>>>>>>>>
79229>>>>>>>>>>>        Set Size to 100 245
79230>>>>>>>>>>>        Set Location to 6 6
79231>>>>>>>>>>>        Set Border_Style to Border_None
79232>>>>>>>>>>>        Set Read_Only_State to True
79233>>>>>>>>>>>        Set pbWrap to True
79234>>>>>>>>>>>        Set peAnchors to anAll
79235>>>>>>>>>>>    End_Procedure
79236>>>>>>>>>>>
79236>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79236>>>>>>>>>>>
79236>>>>>>>>>>>    Procedure AppendTextLn String sText
79238>>>>>>>>>>>        String sWorkspaceWSFile
79238>>>>>>>>>>>
79238>>>>>>>>>>>        // Only works for English:
79238>>>>>>>>>>>        If (ghoApplication > 0) Begin
79240>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79242>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79243>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79244>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79245>>>>>>>>>>>            End
79245>>>>>>>>>>>>
79245>>>>>>>>>>>        End
79245>>>>>>>>>>>>
79245>>>>>>>>>>>        Send AppendText sText
79246>>>>>>>>>>>        Send AppendText (character(10))
79247>>>>>>>>>>>    End_Procedure
79248>>>>>>>>>>>
79248>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79248>>>>>>>>>>>    //    information box
79248>>>>>>>>>>>    Procedure Show_Current_Directory
79250>>>>>>>>>>>        String sDir
79250>>>>>>>>>>>
79250>>>>>>>>>>>        Get_Current_Directory To sDir
79251>>>>>>>>>>>
79251>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79252>>>>>>>>>>>    End_Procedure
79253>>>>>>>>>>>
79253>>>>>>>>>>>    Procedure Show_Windows_Directory
79255>>>>>>>>>>>        String sWindir
79255>>>>>>>>>>>
79255>>>>>>>>>>>        Get_Windows_Directory To sWindir
79256>>>>>>>>>>>
79256>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79257>>>>>>>>>>>    End_Procedure
79258>>>>>>>>>>>
79258>>>>>>>>>>>    Procedure Show_Current_User
79260>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79261>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79262>>>>>>>>>>>    End_Procedure
79263>>>>>>>>>>>
79263>>>>>>>>>>>    Procedure Show_Number_Format
79265>>>>>>>>>>>        Integer iFormat
79265>>>>>>>>>>>        String sFormatText
79265>>>>>>>>>>>
79265>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79268>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79269>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79270>>>>>>>>>>>
79270>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79273>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79274>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79275>>>>>>>>>>>    End_Procedure
79276>>>>>>>>>>>
79276>>>>>>>>>>>    Procedure Show_Filelist_Name
79278>>>>>>>>>>>        String sFilename
79278>>>>>>>>>>>
79278>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79281>>>>>>>>>>>
79281>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79282>>>>>>>>>>>    End_Procedure
79283>>>>>>>>>>>
79283>>>>>>>>>>>    Procedure Show_Lock_Delay
79285>>>>>>>>>>>        Integer iLockdelay
79285>>>>>>>>>>>
79285>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79288>>>>>>>>>>>
79288>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79289>>>>>>>>>>>    End_Procedure
79290>>>>>>>>>>>
79290>>>>>>>>>>>    Procedure Show_Lock_Timeout
79292>>>>>>>>>>>        Integer iLockTimeout
79292>>>>>>>>>>>
79292>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79295>>>>>>>>>>>
79295>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79296>>>>>>>>>>>    End_Procedure
79297>>>>>>>>>>>
79297>>>>>>>>>>>    Procedure Show_Screen_Size
79299>>>>>>>>>>>        Integer iYscreensize iXscreensize
79299>>>>>>>>>>>
79299>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79300>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79301>>>>>>>>>>>
79301>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79302>>>>>>>>>>>    End_Procedure
79303>>>>>>>>>>>
79303>>>>>>>>>>>    Procedure Show_Page_Size
79305>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79306>>>>>>>>>>>    End_procedure
79307>>>>>>>>>>>
79307>>>>>>>>>>>    Procedure Show_Date
79309>>>>>>>>>>>        Date dToday
79309>>>>>>>>>>>
79309>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79310>>>>>>>>>>>
79310>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79311>>>>>>>>>>>    End_procedure
79312>>>>>>>>>>>
79312>>>>>>>>>>>    Procedure Show_Date_Format
79314>>>>>>>>>>>        Integer iDateFormat
79314>>>>>>>>>>>        String sDateFormat
79314>>>>>>>>>>>
79314>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79317>>>>>>>>>>>        Case Begin
79317>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79319>>>>>>>>>>>                Move C_$USA To sDateFormat
79320>>>>>>>>>>>                Case Break
79321>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79324>>>>>>>>>>>                Move C_$European To sDateFormat
79325>>>>>>>>>>>                Case Break
79326>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79329>>>>>>>>>>>                Move C_$Military To sDateFormat
79330>>>>>>>>>>>                Case Break
79331>>>>>>>>>>>            Case Else
79331>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79332>>>>>>>>>>>                Case Break
79333>>>>>>>>>>>        Case End
79333>>>>>>>>>>>
79333>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79334>>>>>>>>>>>    End_Procedure
79335>>>>>>>>>>>
79335>>>>>>>>>>>    // 2013-08-14 NGS
79335>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79335>>>>>>>>>>>    Procedure Show_Systemresources
79337>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79337>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79337>>>>>>>>>>>        Integer iRetval
79337>>>>>>>>>>>        Number nValue
79337>>>>>>>>>>>        String sValue
79337>>>>>>>>>>>
79337>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79338>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79339>>>>>>>>>>>        If (iRetval = 0) Begin
79341>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79342>>>>>>>>>>>            Procedure_Return
79343>>>>>>>>>>>        End
79343>>>>>>>>>>>>
79343>>>>>>>>>>>
79343>>>>>>>>>>>        Send AppendTextLn ""
79344>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79345>>>>>>>>>>>
79345>>>>>>>>>>>        // Show memory in Gigabytes:
79345>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79346>>>>>>>>>>>        Move (Round(nValue)) to nValue
79347>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79348>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79349>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79350>>>>>>>>>>>
79350>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79350>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79351>>>>>>>>>>>        Move (Round(nValue)) to nValue
79352>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79353>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79354>>>>>>>>>>>
79354>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79354>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79355>>>>>>>>>>>        Move (Round(nValue)) to nValue
79356>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79357>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79358>>>>>>>>>>>
79358>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79358>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79359>>>>>>>>>>>        Move (Round(nValue)) to nValue
79360>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79361>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79362>>>>>>>>>>>
79362>>>>>>>>>>>        // Add an empty row after the memory information:
79362>>>>>>>>>>>        Send AppendTextLn ""
79363>>>>>>>>>>>    End_Procedure
79364>>>>>>>>>>>
79364>>>>>>>>>>>    Procedure Show_Registration
79366>>>>>>>>>>>        String sRegName
79366>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79366>>>>>>>>>>>
79366>>>>>>>>>>>        Registration sRegName iSN
79367>>>>>>>>>>>>
79367>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79368>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79369>>>>>>>>>>>
79369>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79370>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79371>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79372>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79373>>>>>>>>>>>    End_Procedure
79374>>>>>>>>>>>
79374>>>>>>>>>>>    //****************************************************************************
79374>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79374>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79374>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79374>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79374>>>>>>>>>>>    // information To be displayed
79374>>>>>>>>>>>    //****************************************************************************
79374>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79374>>>>>>>>>>>
79374>>>>>>>>>>>    Procedure Show_ServicePack
79376>>>>>>>>>>>        String sKey sVersion sDataFlex
79376>>>>>>>>>>>        Handle hoRegistry
79376>>>>>>>>>>>        Boolean bExists bOpened
79376>>>>>>>>>>>
79376>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79377>>>>>>>>>>>
79377>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79378>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79379>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79380>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79381>>>>>>>>>>>
79381>>>>>>>>>>>        If (bExists) Begin
79383>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79384>>>>>>>>>>>        End
79384>>>>>>>>>>>>
79384>>>>>>>>>>>        Else Begin
79385>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79386>>>>>>>>>>>        End
79386>>>>>>>>>>>>
79386>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79387>>>>>>>>>>>        If (bExists) Begin
79389>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79390>>>>>>>>>>>            If (bOpened) Begin
79392>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79393>>>>>>>>>>>                If (bExists) Begin
79395>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79396>>>>>>>>>>>                End
79396>>>>>>>>>>>>
79396>>>>>>>>>>>                Send CloseKey of hoRegistry
79397>>>>>>>>>>>            End
79397>>>>>>>>>>>>
79397>>>>>>>>>>>        End
79397>>>>>>>>>>>>
79397>>>>>>>>>>>        Send Destroy of hoRegistry
79398>>>>>>>>>>>
79398>>>>>>>>>>>        If (sVersion <> "") Begin
79400>>>>>>>>>>>           Send AppendTextLn sVersion
79401>>>>>>>>>>>           Send AppendTextLn ""
79402>>>>>>>>>>>        End
79402>>>>>>>>>>>>
79402>>>>>>>>>>>    End_Procedure
79403>>>>>>>>>>>
79403>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79405>>>>>>>>>>>        Integer hoWorkspace
79405>>>>>>>>>>>
79405>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79407>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79408>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79410>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79411>>>>>>>>>>>            End
79411>>>>>>>>>>>>
79411>>>>>>>>>>>        End
79411>>>>>>>>>>>>
79411>>>>>>>>>>>    End_Procedure
79412>>>>>>>>>>>
79412>>>>>>>>>>>    //****************************************************************************
79412>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79412>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79412>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79412>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79412>>>>>>>>>>>    // the information To be displayed
79412>>>>>>>>>>>    //****************************************************************************
79412>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79412>>>>>>>>>>>
79412>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79414>>>>>>>>>>>        If (ghoConnection > 0) Begin
79416>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79417>>>>>>>>>>>            Send AppendTextLn ""
79418>>>>>>>>>>>        End
79418>>>>>>>>>>>>
79418>>>>>>>>>>>    End_Procedure
79419>>>>>>>>>>>
79419>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79421>>>>>>>>>>>        Boolean bOK
79421>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79422>>>>>>>>>>>        Function_Return bOK
79423>>>>>>>>>>>    End_Function
79424>>>>>>>>>>>
79424>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79426>>>>>>>>>>>        If (ghoConnection > 0) Begin
79428>>>>>>>>>>>            Send AppendTextLn ""
79429>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79430>>>>>>>>>>>        End
79430>>>>>>>>>>>>
79430>>>>>>>>>>>    End_Procedure
79431>>>>>>>>>>>    
79431>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79433>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79434>>>>>>>>>>>    End_Function
79435>>>>>>>>>>>    
79435>>>>>>>>>>>    Procedure Show_Versions
79437>>>>>>>>>>>        Integer iVersion iRevision iBuild
79437>>>>>>>>>>>        
79437>>>>>>>>>>>        Version_Information iVersion iRevision iBuild
79439>>>>>>>>>>>        
79439>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
79440>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79441>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79442>>>>>>>>>>>    End_Procedure
79443>>>>>>>>>>>    
79443>>>>>>>>>>>    Procedure Show_Platform
79445>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Platform,"64-bit"))
79446>>>>>>>>>>>    End_Procedure
79447>>>>>>>>>>>    
79447>>>>>>>>>>>    Function CKRevisionNumber String sDriverID Returns String
79449>>>>>>>>>>>        Handle hoCLIHandler
79449>>>>>>>>>>>        Handle hoDFBtrDrvHandler
79449>>>>>>>>>>>        String sCKRevision
79449>>>>>>>>>>>        
79449>>>>>>>>>>>        
79449>>>>>>>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
79451>>>>>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
79452>>>>>>>>>>>            Set psDriverID of hoCLIHandler to sDriverID
79453>>>>>>>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
79454>>>>>>>>>>>            Send Destroy of hoCLIHandler
79455>>>>>>>>>>>        End
79455>>>>>>>>>>>>
79455>>>>>>>>>>>        Else Begin
79456>>>>>>>>>>>            If (sDriverID = "DFBTRDRV") Begin
79458>>>>>>>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
79459>>>>>>>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
79460>>>>>>>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
79461>>>>>>>>>>>                Send Destroy of hoDFBtrDrvHandler
79462>>>>>>>>>>>            End
79462>>>>>>>>>>>>
79462>>>>>>>>>>>        End
79462>>>>>>>>>>>>
79462>>>>>>>>>>>        
79462>>>>>>>>>>>        Function_Return sCKRevision
79463>>>>>>>>>>>    End_Function    
79464>>>>>>>>>>>    
79464>>>>>>>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
79466>>>>>>>>>>>        
79466>>>>>>>>>>>        If (sDriverID = "DATAFLEX") Begin
79468>>>>>>>>>>>            Function_Return False
79469>>>>>>>>>>>        End
79469>>>>>>>>>>>>
79469>>>>>>>>>>>        
79469>>>>>>>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
79470>>>>>>>>>>>    End_Function
79471>>>>>>>>>>>    
79471>>>>>>>>>>>    Procedure Show_Drivers
79473>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79473>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79473>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79473>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79473>>>>>>>>>>>
79473>>>>>>>>>>>        Move False to bStudioLicense
79474>>>>>>>>>>>
79474>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79475>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79476>>>>>>>>>>>
79476>>>>>>>>>>>        // For testing purposes:
79476>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79476>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79476>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79476>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79476>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79476>>>>>>>>>>>//
79476>>>>>>>>>>>        Move False to Err
79477>>>>>>>>>>>
79477>>>>>>>>>>>        // Loop through all loaded drivers.
79477>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79480>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79482>>>>>>>>>>>            Send AppendTextLn ""
79483>>>>>>>>>>>        End
79483>>>>>>>>>>>>
79483>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79489>>>>>>>>>>>>
79489>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79490>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79493>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79494>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79495>>>>>>>>>>>
79495>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79497>>>>>>>>>>>
79497>>>>>>>>>>>                // Pervasive/Btrieve database
79497>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79499>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79500>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79501>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79503>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79504>>>>>>>>>>>                    End
79504>>>>>>>>>>>>
79504>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79505>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79507>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79508>>>>>>>>>>>                    End
79508>>>>>>>>>>>>
79508>>>>>>>>>>>                End
79508>>>>>>>>>>>>
79508>>>>>>>>>>>
79508>>>>>>>>>>>                Else Begin
79509>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79510>>>>>>>>>>>                    Move 0 to iNumServers
79511>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79513>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79516>>>>>>>>>>>                    End
79516>>>>>>>>>>>>
79516>>>>>>>>>>>
79516>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79518>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79520>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79521>>>>>>>>>>>                        End
79521>>>>>>>>>>>>
79521>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79522>>>>>>>>>>>                    End
79522>>>>>>>>>>>>
79522>>>>>>>>>>>
79522>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79522>>>>>>>>>>>                    // Studio licens is in use and there is no
79522>>>>>>>>>>>                    // number of max users defined because the driver is
79522>>>>>>>>>>>                    // relying on the info from the VDF license.
79522>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79524>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79525>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79526>>>>>>>>>>>                    End
79526>>>>>>>>>>>>
79526>>>>>>>>>>>                End
79526>>>>>>>>>>>>
79526>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79527>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79529>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79530>>>>>>>>>>>                End
79530>>>>>>>>>>>>
79530>>>>>>>>>>>                If (iNumServers <> 0) Begin
79532>>>>>>>>>>>                    For iCount from 1 to iNumServers
79538>>>>>>>>>>>>
79538>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79541>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79543>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79544>>>>>>>>>>>                        End
79544>>>>>>>>>>>>
79544>>>>>>>>>>>                    Loop
79545>>>>>>>>>>>>
79545>>>>>>>>>>>                End
79545>>>>>>>>>>>>
79545>>>>>>>>>>>            End
79545>>>>>>>>>>>>
79545>>>>>>>>>>>        Loop
79546>>>>>>>>>>>>
79546>>>>>>>>>>>
79546>>>>>>>>>>>        Send AppendTextLn ""
79547>>>>>>>>>>>        If (bStudioLicense = False) Begin
79549>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79550>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79551>>>>>>>>>>>        End
79551>>>>>>>>>>>>
79551>>>>>>>>>>>        Else Begin
79552>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79553>>>>>>>>>>>        End
79553>>>>>>>>>>>>
79553>>>>>>>>>>>        Send Destroy of hoCLIHandler
79554>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79555>>>>>>>>>>>    End_Procedure
79556>>>>>>>>>>>
79556>>>>>>>>>>>    Procedure Show_HelpFile
79558>>>>>>>>>>>        String sHelpFile
79558>>>>>>>>>>>        Integer eHelpType
79558>>>>>>>>>>>
79558>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79560>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79561>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79563>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79564>>>>>>>>>>>            End
79564>>>>>>>>>>>>
79564>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79567>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79568>>>>>>>>>>>            End
79568>>>>>>>>>>>>
79568>>>>>>>>>>>            Else Begin
79569>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79570>>>>>>>>>>>            End
79570>>>>>>>>>>>>
79570>>>>>>>>>>>
79570>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79571>>>>>>>>>>>        End
79571>>>>>>>>>>>>
79571>>>>>>>>>>>    End_Procedure
79572>>>>>>>>>>>
79572>>>>>>>>>>>    Procedure Show_EnterAsTab
79574>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79574>>>>>>>>>>>        String sText
79574>>>>>>>>>>>
79574>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79576>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79577>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79579>>>>>>>>>>>                Move "True" To sText
79580>>>>>>>>>>>            End
79580>>>>>>>>>>>>
79580>>>>>>>>>>>            Else Begin
79581>>>>>>>>>>>                Move "False" To sText
79582>>>>>>>>>>>            End
79582>>>>>>>>>>>>
79582>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79583>>>>>>>>>>>        End
79583>>>>>>>>>>>>
79583>>>>>>>>>>>    End_Procedure
79584>>>>>>>>>>>
79584>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79584>>>>>>>>>>>    //    found systeminformation
79584>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79586>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79588>>>>>>>>>>>
79588>>>>>>>>>>>        Send Delete_Data
79589>>>>>>>>>>>
79589>>>>>>>>>>>        Set Changed_State To False
79590>>>>>>>>>>>        Set Read_Only_State To True
79591>>>>>>>>>>>
79591>>>>>>>>>>>        Send Show_Registration
79592>>>>>>>>>>>        Send Show_Drivers
79593>>>>>>>>>>>        Send Show_ServicePack
79594>>>>>>>>>>>        Send Show_Versions
79595>>>>>>>>>>>        Send Show_Platform
79596>>>>>>>>>>>        Send AppendTextLn ""
79597>>>>>>>>>>>
79597>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79599>>>>>>>>>>>            Send Show_WorkSpaceInformation
79600>>>>>>>>>>>            Send Show_HelpFile
79601>>>>>>>>>>>            Send AppendTextLn ""
79602>>>>>>>>>>>        End
79602>>>>>>>>>>>>
79602>>>>>>>>>>>        Else Begin
79603>>>>>>>>>>>            Send AppendTextLn ""
79604>>>>>>>>>>>        End
79604>>>>>>>>>>>>
79604>>>>>>>>>>>
79604>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79606>>>>>>>>>>>            Send Show_ConnectionIdInformation
79607>>>>>>>>>>>        End
79607>>>>>>>>>>>>
79607>>>>>>>>>>>
79607>>>>>>>>>>>        Send Show_Current_User
79608>>>>>>>>>>>        Send Show_Windows_Directory
79609>>>>>>>>>>>        Send Show_Current_Directory
79610>>>>>>>>>>>
79610>>>>>>>>>>>        // This is already shown in the workspace details,
79610>>>>>>>>>>>        // unless no workspace object is present:
79610>>>>>>>>>>>        If (ghoApplication = 0) Begin
79612>>>>>>>>>>>            Send Show_Filelist_Name
79613>>>>>>>>>>>        End
79613>>>>>>>>>>>>
79613>>>>>>>>>>>
79613>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79615>>>>>>>>>>>            Send AppendTextLn ""
79616>>>>>>>>>>>            Send Show_EnterAsTab
79617>>>>>>>>>>>        End
79617>>>>>>>>>>>>
79617>>>>>>>>>>>
79617>>>>>>>>>>>        Send Show_Screen_Size
79618>>>>>>>>>>>        Send Show_Page_Size
79619>>>>>>>>>>>        Send Show_Number_Format
79620>>>>>>>>>>>        Send Show_Date_Format
79621>>>>>>>>>>>        Send Show_Lock_Delay
79622>>>>>>>>>>>        Send Show_Lock_Timeout
79623>>>>>>>>>>>        Send Show_Date
79624>>>>>>>>>>>        Send Show_Systemresources
79625>>>>>>>>>>>        Send Beginning_of_Data
79626>>>>>>>>>>>
79626>>>>>>>>>>>        Set Icon to 'default.ico'
79627>>>>>>>>>>>    End_Procedure
79628>>>>>>>>>>>End_Class
79629>>>>>>>>>>>
79629>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79630>>>>>>>>>>>    Procedure Construct_Object
79632>>>>>>>>>>>        Forward Send Construct_Object
79634>>>>>>>>>>>
79634>>>>>>>>>>>        Set Label to C_$SystemInformation
79635>>>>>>>>>>>        Set Size to 140 267
79636>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79637>>>>>>>>>>>        Set Border_Style to Border_Thick
79638>>>>>>>>>>>        Set Sysmenu_Icon to False
79639>>>>>>>>>>>
79639>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79639>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79640>>>>>>>>>>>
79640>>>>>>>>>>>        // 2014-09-14 NGS
79640>>>>>>>>>>>        // Added a container object around the cTexteditor
79640>>>>>>>>>>>        // object to get a border around the text.
79640>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79642>>>>>>>>>>>            Set Location to 2 4
79643>>>>>>>>>>>            Set Size to 110 255
79644>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79645>>>>>>>>>>>            Set Color to clWhite
79646>>>>>>>>>>>            Set peAnchors to anAll
79647>>>>>>>>>>>
79647>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79649>>>>>>>>>>>            End_Object
79650>>>>>>>>>>>
79650>>>>>>>>>>>        End_Object
79651>>>>>>>>>>>
79651>>>>>>>>>>>        Object oCloseButton is a Button
79653>>>>>>>>>>>            Set Label to C_$Close
79654>>>>>>>>>>>            Set Location to 120 210
79655>>>>>>>>>>>            CompilerWarnings Off
79655>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79656>>>>>>>>>>>            CompilerWarnings On
79656>>>>>>>>>>>            Set Default_State To True
79657>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79657>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79657>>>>>>>>>>>            // for that situation.
79657>>>>>>>>>>>            Set peAnchors to anBottomRight
79658>>>>>>>>>>>        End_Object
79659>>>>>>>>>>>
79659>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79661>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79662>>>>>>>>>>>            Set Size to 14 50
79663>>>>>>>>>>>            Set Location to 120 158
79664>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79664>>>>>>>>>>>            // we might as well prepare the object for it.
79664>>>>>>>>>>>            Set peAnchors to anBottomRight
79665>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79666>>>>>>>>>>>        End_Object
79667>>>>>>>>>>>
79667>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79668>>>>>>>>>>>    End_Procedure
79669>>>>>>>>>>>
79669>>>>>>>>>>>    Procedure Page Integer iPageObject
79671>>>>>>>>>>>        Handle hMenu
79671>>>>>>>>>>>        Integer iPrevState
79671>>>>>>>>>>>
79671>>>>>>>>>>>        Forward Send Page iPageObject
79673>>>>>>>>>>>
79673>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79673>>>>>>>>>>>        //
79673>>>>>>>>>>>    End_Procedure
79674>>>>>>>>>>>
79674>>>>>>>>>>>End_Class
79675>>>>>>>>>>>
79675>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79676>>>>>>>>>>>    Procedure Construct_Object
79678>>>>>>>>>>>        Forward Send Construct_Object
79680>>>>>>>>>>>
79680>>>>>>>>>>>        Property String psContentText
79681>>>>>>>>>>>
79681>>>>>>>>>>>        Set Size to 77 153
79682>>>>>>>>>>>        Set Location to 8 60
79683>>>>>>>>>>>        Set Read_Only_State to True
79684>>>>>>>>>>>        Set Skip_State to True
79685>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79685>>>>>>>>>>>        // or 1/20 of a printer's point.
79685>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79686>>>>>>>>>>>        Set Border_Style  to Border_None
79687>>>>>>>>>>>    End_Procedure
79688>>>>>>>>>>>
79688>>>>>>>>>>>    // Adds a line of text to the edit object
79688>>>>>>>>>>>    Procedure Add_Line String sText
79690>>>>>>>>>>>        String sContentText
79690>>>>>>>>>>>        Get psContentText to sContentText
79691>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79692>>>>>>>>>>>        Set psContentText to sContentText
79693>>>>>>>>>>>    End_Procedure
79694>>>>>>>>>>>
79694>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79694>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79694>>>>>>>>>>>    // because the object isn't paged yet when we add these
79694>>>>>>>>>>>    // values and the COM edit object needs to be paged
79694>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79694>>>>>>>>>>>    Procedure Add_LineLn String sText
79696>>>>>>>>>>>        String sContentText sCR
79696>>>>>>>>>>>
79696>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79697>>>>>>>>>>>        Get psContentText to sContentText
79698>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79699>>>>>>>>>>>        Set psContentText to sContentText
79700>>>>>>>>>>>    End_Procedure
79701>>>>>>>>>>>
79701>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79703>>>>>>>>>>>        String sLinkText
79703>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79704>>>>>>>>>>>        Send Show_HomePage sLinkText
79705>>>>>>>>>>>    End_Procedure
79706>>>>>>>>>>>
79706>>>>>>>>>>>    Procedure Page Integer iPageObject
79708>>>>>>>>>>>        String sContentText
79708>>>>>>>>>>>
79708>>>>>>>>>>>        Forward Send Page iPageObject
79710>>>>>>>>>>>        Get psContentText to sContentText
79711>>>>>>>>>>>        Send AppendText sContentText
79712>>>>>>>>>>>        send Beginning_of_Data
79713>>>>>>>>>>>    End_Procedure
79714>>>>>>>>>>>
79714>>>>>>>>>>>End_Class
79715>>>>>>>>>>>
79715>>>>>>>>>>>Class AboutDialog is a ModalPanel
79716>>>>>>>>>>>    Procedure Construct_Object
79718>>>>>>>>>>>
79718>>>>>>>>>>>        Forward Send Construct_Object
79720>>>>>>>>>>>
79720>>>>>>>>>>>        Set Label to C_$About
79721>>>>>>>>>>>        Set Size to 118 230
79722>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79723>>>>>>>>>>>        Set Border_Style to Border_Thick
79724>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79725>>>>>>>>>>>
79725>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79727>>>>>>>>>>>        End_Object
79728>>>>>>>>>>>
79728>>>>>>>>>>>        Object oBox is a Container3d
79730>>>>>>>>>>>            Set Border_Style to Border_Normal
79731>>>>>>>>>>>            Set Size to 90 220
79732>>>>>>>>>>>            Set Location to 4 5
79733>>>>>>>>>>>            Set Color to clWhite
79734>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79734>>>>>>>>>>>            // we might as well prepare the object for it.
79734>>>>>>>>>>>            Set peAnchors to anAll
79735>>>>>>>>>>>
79735>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79737>>>>>>>>>>>                Set Border_Style To Border_None
79738>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79739>>>>>>>>>>>                Set Color to clWhite
79740>>>>>>>>>>>                Set Size to 45 50
79741>>>>>>>>>>>                Set Location to 0 3
79742>>>>>>>>>>>            End_Object
79743>>>>>>>>>>>
79743>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79745>>>>>>>>>>>                Set Border_Style to Border_None
79746>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79747>>>>>>>>>>>                Set Color to clWhite
79748>>>>>>>>>>>                Set Size to 30 55
79749>>>>>>>>>>>                Set Location to 50 3
79750>>>>>>>>>>>            End_Object
79751>>>>>>>>>>>
79751>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79753>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79753>>>>>>>>>>>                // we might as well prepare the object for it.
79753>>>>>>>>>>>                Set peAnchors to anAll
79754>>>>>>>>>>>            End_Object
79755>>>>>>>>>>>
79755>>>>>>>>>>>            // These objects are here for backwards compatability only.
79755>>>>>>>>>>>            // They are not used.
79755>>>>>>>>>>>            Object oProductName is a TextBox
79757>>>>>>>>>>>                Set Label To C_$ProductName
79758>>>>>>>>>>>                Set Size To 10 45
79759>>>>>>>>>>>                Set Location To 8 53
79760>>>>>>>>>>>                Set Visible_State to False
79761>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79762>>>>>>>>>>>            End_Object
79763>>>>>>>>>>>
79763>>>>>>>>>>>            Object oVersion is a TextBox
79765>>>>>>>>>>>                Set Label To C_$Version
79766>>>>>>>>>>>                Set Size To 10 25
79767>>>>>>>>>>>                Set Location To 21 53
79768>>>>>>>>>>>                Set Visible_State to False
79769>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79770>>>>>>>>>>>            End_Object
79771>>>>>>>>>>>
79771>>>>>>>>>>>            Object oCopyright is a TextBox
79773>>>>>>>>>>>                Set Label To C_$Copyright
79774>>>>>>>>>>>                Set Size To 10 31
79775>>>>>>>>>>>                Set Location To 34 53
79776>>>>>>>>>>>                Set Visible_State to False
79777>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79778>>>>>>>>>>>            End_Object
79779>>>>>>>>>>>
79779>>>>>>>>>>>            Object oAuthor is a TextBox
79781>>>>>>>>>>>                Set Label To C_$Author
79782>>>>>>>>>>>                Set Size To 10 22
79783>>>>>>>>>>>                Set Location To 46 53
79784>>>>>>>>>>>                Set Visible_State to False
79785>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79786>>>>>>>>>>>            End_Object
79787>>>>>>>>>>>
79787>>>>>>>>>>>        End_Object
79788>>>>>>>>>>>
79788>>>>>>>>>>>        Object oOKButton is a Button
79790>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79791>>>>>>>>>>>            Set Location to 98 176
79792>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79792>>>>>>>>>>>            // we might as well prepare the object for it.
79792>>>>>>>>>>>            Set peAnchors to anBottomRight
79793>>>>>>>>>>>        End_Object
79794>>>>>>>>>>>
79794>>>>>>>>>>>        Object oSysInfoButton is a Button
79796>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79797>>>>>>>>>>>            Set Location to 98 123
79798>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79798>>>>>>>>>>>            // we might as well prepare the object for it.
79798>>>>>>>>>>>            Set peAnchors to anBottomRight
79799>>>>>>>>>>>        End_Object
79800>>>>>>>>>>>
79800>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79802>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79803>>>>>>>>>>>            Set Size to 14 50
79804>>>>>>>>>>>            Set Location to 98 70
79805>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79805>>>>>>>>>>>            // we might as well prepare the object for it.
79805>>>>>>>>>>>            Set peAnchors to anBottomRight
79806>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79807>>>>>>>>>>>        End_Object
79808>>>>>>>>>>>
79808>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79809>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79810>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79811>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79811>>>>>>>>>>>    End_Procedure
79812>>>>>>>>>>>
79812>>>>>>>>>>>    Procedure Page Integer iPageObject
79814>>>>>>>>>>>        Handle hMenu
79814>>>>>>>>>>>        Integer iPrevState
79814>>>>>>>>>>>
79814>>>>>>>>>>>        Forward Send Page iPageObject
79816>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79816>>>>>>>>>>>        Set Icon to "Default.ico"
79817>>>>>>>>>>>
79817>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79817>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79818>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79819>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79819>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79819>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79820>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79821>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79822>>>>>>>>>>>        // The "Close" menu command may be good to have.
79822>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79822>>>>>>>>>>>    End_Procedure
79823>>>>>>>>>>>
79823>>>>>>>>>>>    Procedure Set ProductName String sText
79825>>>>>>>>>>>        Set Value of oProductName to sText
79826>>>>>>>>>>>    End_Procedure
79827>>>>>>>>>>>
79827>>>>>>>>>>>    Procedure Set Copyright String sText
79829>>>>>>>>>>>        Set Value of oCopyright to sText
79830>>>>>>>>>>>    End_Procedure
79831>>>>>>>>>>>
79831>>>>>>>>>>>    Procedure Set Author String sText
79833>>>>>>>>>>>        Set Value of oAuthor to sText
79834>>>>>>>>>>>    End_Procedure
79835>>>>>>>>>>>
79835>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79835>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79835>>>>>>>>>>>    //       program as a pre-compile!
79835>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79835>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79835>>>>>>>>>>>
79835>>>>>>>>>>>    Procedure Set Version String sVersion
79837>>>>>>>>>>>        Handle hoVersionInfo
79837>>>>>>>>>>>        Boolean bIncluded
79837>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79837>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79837>>>>>>>>>>>
79837>>>>>>>>>>>        If (sVersion = "") Begin
79839>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79839>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79839>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79841>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79842>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79844>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79845>>>>>>>>>>>                    If (bIncluded) Begin
79847>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79848>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79849>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79850>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79851>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79852>>>>>>>>>>>                    End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>                End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>            End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>        End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>
79852>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79852>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79853>>>>>>>>>>>        Readln sCompileDateAndTime
79854>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79855>>>>>>>>>>>        If (iPos <> 0) Begin
79857>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79858>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79859>>>>>>>>>>>        End
79859>>>>>>>>>>>>
79859>>>>>>>>>>>        Close_Input
79860>>>>>>>>>>>
79860>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79862>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79863>>>>>>>>>>>        End
79863>>>>>>>>>>>>
79863>>>>>>>>>>>
79863>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79864>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79866>>>>>>>>>>>            If (sCertInfo <> "") Begin
79868>>>>>>>>>>>                Send Add_LineLn sCertInfo
79869>>>>>>>>>>>            End
79869>>>>>>>>>>>>
79869>>>>>>>>>>>            Else Begin
79870>>>>>>>>>>>//                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79870>>>>>>>>>>>            End
79870>>>>>>>>>>>>
79870>>>>>>>>>>>        End
79870>>>>>>>>>>>>
79870>>>>>>>>>>>    End_Procedure
79871>>>>>>>>>>>
79871>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79873>>>>>>>>>>>        Boolean bIsDate
79873>>>>>>>>>>>        String sGoodCharacters sChar
79873>>>>>>>>>>>        Integer iCount iLength
79873>>>>>>>>>>>
79873>>>>>>>>>>>        Move True to bIsDate
79874>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79875>>>>>>>>>>>        Move (Length(sDate)) to iLength
79876>>>>>>>>>>>        For iCount from 1 to iLength
79882>>>>>>>>>>>>
79882>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79883>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79884>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79885>>>>>>>>>>>            If (bIsDate = False) Begin
79887>>>>>>>>>>>                Move iLength to iCount
79888>>>>>>>>>>>            End
79888>>>>>>>>>>>>
79888>>>>>>>>>>>        Loop
79889>>>>>>>>>>>>
79889>>>>>>>>>>>        Function_Return bIsDate
79890>>>>>>>>>>>    End_Function
79891>>>>>>>>>>>
79891>>>>>>>>>>>    Function GetCompileDate Returns Date
79893>>>>>>>>>>>        Date dCompileDate
79893>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79893>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79893>>>>>>>>>>>        Boolean bIsValid   
79893>>>>>>>>>>>        
79893>>>>>>>>>>>        Move 0 to dCompileDate
79894>>>>>>>>>>>        // Get full path to the current running executable
79894>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79895>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79896>>>>>>>>>>>
79896>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79896>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79897>>>>>>>>>>>
79897>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79899>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79900>>>>>>>>>>>        If (iPos > 0) Begin
79902>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79902>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79903>>>>>>>>>>>
79903>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79903>>>>>>>>>>>            // change the format and then move the string to the date variable.
79903>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79906>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79909>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79910>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79912>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79913>>>>>>>>>>>            End
79913>>>>>>>>>>>>
79913>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79914>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79915>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79918>>>>>>>>>>>        End
79918>>>>>>>>>>>>
79918>>>>>>>>>>>        Else Begin
79919>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79920>>>>>>>>>>>>
79920>>>>>>>>>>>        End
79920>>>>>>>>>>>>
79920>>>>>>>>>>>
79920>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79921>>>>>>>>>>>
79921>>>>>>>>>>>        Function_Return dCompileDate
79922>>>>>>>>>>>    End_Function
79923>>>>>>>>>>>
79923>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79923>>>>>>>>>>>    // (the passed program), has been finished
79923>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79923>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79925>>>>>>>>>>>        Handle hProcess
79925>>>>>>>>>>>        Integer iVoid
79925>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79925>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79925>>>>>>>>>>>
79925>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79926>>>>>>>>>>>
79926>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79927>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79928>>>>>>>>>>>
79928>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79929>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79930>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79930>>>>>>>>>>>        Move 0                       to sInfo.nShow
79931>>>>>>>>>>>
79931>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79932>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79933>>>>>>>>>>>        If (hProcess) Begin
79935>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79936>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79937>>>>>>>>>>>        End
79937>>>>>>>>>>>>
79937>>>>>>>>>>>    End_Procedure
79938>>>>>>>>>>>
79938>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79940>>>>>>>>>>>        String sDirSep
79940>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79941>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79942>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79944>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79945>>>>>>>>>>>        End
79945>>>>>>>>>>>>
79945>>>>>>>>>>>        Function_Return sPath
79946>>>>>>>>>>>    End_Function
79947>>>>>>>>>>>
79947>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79947>>>>>>>>>>>    // or there is a problem with the certificate.
79947>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79947>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79947>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79949>>>>>>>>>>>        Boolean bExists
79949>>>>>>>>>>>        String sPath sProgram sParams sRetval
79949>>>>>>>>>>>        Integer iCh
79949>>>>>>>>>>>
79949>>>>>>>>>>>        Move "" to sRetval
79950>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79951>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79952>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79953>>>>>>>>>>>        If (bExists = False) Begin
79955>>>>>>>>>>>            Function_Return "-1"
79956>>>>>>>>>>>        End
79956>>>>>>>>>>>>
79956>>>>>>>>>>>
79956>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79957>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79958>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79959>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79960>>>>>>>>>>>        Get Seq_New_Channel to iCh
79961>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79963>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79966>>>>>>>>>>>        Close_Output channel iCh
79968>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79968>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79969>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79971>>>>>>>>>>>            Readln channel iCh sRetval
79973>>>>>>>>>>>            Readln channel iCh sRetval
79975>>>>>>>>>>>            Readln channel iCh sRetval
79977>>>>>>>>>>>            Readln channel iCh sRetval
79979>>>>>>>>>>>        Close_Input channel iCh
79981>>>>>>>>>>>        Send Seq_Release_Channel iCh
79982>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79984>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79985>>>>>>>>>>>        End
79985>>>>>>>>>>>>
79985>>>>>>>>>>>        Else Begin
79986>>>>>>>>>>>            Move "" to sRetval
79987>>>>>>>>>>>        End
79987>>>>>>>>>>>>
79987>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79987>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79988>>>>>>>>>>>>
79988>>>>>>>>>>>        Function_Return sRetval
79989>>>>>>>>>>>    End_Function
79990>>>>>>>>>>>
79990>>>>>>>>>>>    Procedure Add_LineLn String sValue
79992>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79993>>>>>>>>>>>    End_Procedure
79994>>>>>>>>>>>
79994>>>>>>>>>>>    Procedure Add_Line String sValue
79996>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79997>>>>>>>>>>>    End_Procedure
79998>>>>>>>>>>>
79998>>>>>>>>>>>    Procedure Set Logo string sLogo
80000>>>>>>>>>>>        // Square bitmaps of 80x80 work best
80000>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
80001>>>>>>>>>>>    End_Procedure
80002>>>>>>>>>>>
80002>>>>>>>>>>>    Procedure Set LogoDF String sLogo
80004>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
80005>>>>>>>>>>>    End_Procedure
80006>>>>>>>>>>>
80006>>>>>>>>>>>    Procedure Show_Sysinfo
80008>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
80009>>>>>>>>>>>    End_Procedure
80010>>>>>>>>>>>
80010>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
80012>>>>>>>>>>>        Handle hWnd
80012>>>>>>>>>>>        Get Window_Handle to hWnd
80013>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
80014>>>>>>>>>>>    End_Procedure
80015>>>>>>>>>>>
80015>>>>>>>>>>>End_Class
80016>>>>>>>>>
80016>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
80018>>>>>>>>>    End_Function
80019>>>>>>>>>
80019>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
80019>>>>>>>>>
80019>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
80020>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
80021>>>>>>>>>>
80021>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
80023>>>>>>>>>>    Integer iStart iEnd
80023>>>>>>>>>>    String sRetval
80023>>>>>>>>>>
80023>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
80024>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
80025>>>>>>>>>>    If (iStart = 0) Begin
80027>>>>>>>>>>        Function_Return ""
80028>>>>>>>>>>    End
80028>>>>>>>>>>>
80028>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
80029>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
80030>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
80032>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80033>>>>>>>>>>    End
80033>>>>>>>>>>>
80033>>>>>>>>>>    Else Begin
80034>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
80035>>>>>>>>>>    End
80035>>>>>>>>>>>
80035>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
80037>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80038>>>>>>>>>>        Decrement iEnd
80039>>>>>>>>>>    End
80039>>>>>>>>>>>
80039>>>>>>>>>>    If (iEnd <> 0) Begin
80041>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
80042>>>>>>>>>>    End
80042>>>>>>>>>>>
80042>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
80043>>>>>>>>>>
80043>>>>>>>>>>    Function_Return (Trim(sRetval))
80044>>>>>>>>>>End_Function
80045>>>>>>>>>>
80045>>>>>>>>>>
80045>>>>>>>>>    
80045>>>>>>>>>    Procedure Construct_Object
80047>>>>>>>>>        Handle ho
80047>>>>>>>>>        Forward Send Construct_Object
80049>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
80050>>>>>>>>>        
80050>>>>>>>>>        Send CreateDbUpdateLibraryProperties
80051>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
80052>>>>>>>>>        Property String[] pasSQLDataTables
80053>>>>>>>>>        Property tFilelist[] pFileListArray  
80054>>>>>>>>>        Property tFilelist[] pErrorTables
80055>>>>>>>>>
80055>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
80055>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
80055>>>>>>>>>        // etc settings.
80055>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80057>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
80058>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
80059>>>>>>>>>            Set phoSQLConnectionHandler to ho
80060>>>>>>>>>        End
80060>>>>>>>>>>
80060>>>>>>>>>
80060>>>>>>>>>    End_Procedure
80061>>>>>>>>>
80061>>>>>>>>>    Procedure End_Construct_Object
80063>>>>>>>>>        Forward Send End_Construct_Object
80065>>>>>>>>>
80065>>>>>>>>>    End_Procedure
80066>>>>>>>>>
80066>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
80066>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
80066>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
80066>>>>>>>>>    // Good read about which collation to select:
80066>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
80066>>>>>>>>>    Procedure Set psCollation String sCollation
80068>>>>>>>>>        Set private.psCollation to sCollation
80069>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80071>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80072>>>>>>>>>        End
80072>>>>>>>>>>
80072>>>>>>>>>    End_Procedure
80073>>>>>>>>>
80073>>>>>>>>>    Function psCollation Returns String
80075>>>>>>>>>        String sCollation
80075>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80077>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80078>>>>>>>>>        End   
80078>>>>>>>>>>
80078>>>>>>>>>        Else Begin
80079>>>>>>>>>            Get private.psCollation to sCollation
80080>>>>>>>>>        End
80080>>>>>>>>>>
80080>>>>>>>>>        Function_Return sCollation
80081>>>>>>>>>    End_Function
80082>>>>>>>>>
80082>>>>>>>>>    // Array sorting helper functions:
80082>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80084>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80086>>>>>>>>>            Function_Return (EQ)
80087>>>>>>>>>        End
80087>>>>>>>>>>
80087>>>>>>>>>
80087>>>>>>>>>        Function_Return (GT)
80088>>>>>>>>>    End_Function
80089>>>>>>>>>
80089>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80091>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80094>>>>>>>>>
80094>>>>>>>>>        Function_Return (GT)
80095>>>>>>>>>    End_Function
80096>>>>>>>>>
80096>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80096>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80096>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80098>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80098>>>>>>>>>        Handle hTable
80098>>>>>>>>>        Boolean bIsSame
80098>>>>>>>>>
80098>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80099>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80100>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80103>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80104>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80107>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80110>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80111>>>>>>>>>
80111>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80113>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80114>>>>>>>>>        End
80114>>>>>>>>>>
80114>>>>>>>>>        Else Begin
80115>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80116>>>>>>>>>        End
80116>>>>>>>>>>
80116>>>>>>>>>
80116>>>>>>>>>        Function_Return bIsSame
80117>>>>>>>>>    End_Function
80118>>>>>>>>>
80118>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80120>>>>>>>>>        Integer iRetval
80120>>>>>>>>>        Move 1 to iRetval
80121>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80123>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80124>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80125>>>>>>>>>        End
80125>>>>>>>>>>
80125>>>>>>>>>        Function_Return (iRetval = 0)
80126>>>>>>>>>    End_Function
80127>>>>>>>>>
80127>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80129>>>>>>>>>        String sDirSep
80129>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80130>>>>>>>>>        Move (Trim(sPath)) to sPath
80131>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80133>>>>>>>>>            Move (sPath + sDirSep) to sPath
80134>>>>>>>>>        End
80134>>>>>>>>>>
80134>>>>>>>>>        Function_Return sPath
80135>>>>>>>>>    End_Function
80136>>>>>>>>>
80136>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80138>>>>>>>>>        Integer i iCols iItem
80138>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80138>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80139>>>>>>>>>
80139>>>>>>>>>        Get SQLGetStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80140>>>>>>>>>        For i from 1 to iCols
80146>>>>>>>>>>
80146>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80147>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80148>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80149>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80150>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80151>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80152>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80153>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80154>>>>>>>>>        Loop
80155>>>>>>>>>>
80155>>>>>>>>>        Set piColumns to iCols
80156>>>>>>>>>        Set paQueryColumns to aQueryColumns
80157>>>>>>>>>    End_Procedure
80158>>>>>>>>>
80158>>>>>>>>>    // *** Property Messages ***
80158>>>>>>>>>    //
80158>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80158>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80158>>>>>>>>>    //
80158>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80160>>>>>>>>>        tSQLConnection SQLConnection
80160>>>>>>>>>        tSQLConnection SQLConnection
80160>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80162>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80162>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80163>>>>>>>>>>
80163>>>>>>>>>            Function_Return
80164>>>>>>>>>        End
80164>>>>>>>>>>
80164>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80165>>>>>>>>>        Function_Return SQLConnection
80166>>>>>>>>>    End_Function
80167>>>>>>>>>
80167>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80167>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80169>>>>>>>>>        Function_Return False
80170>>>>>>>>>    End_Function
80171>>>>>>>>>
80171>>>>>>>>>    Procedure Set psServer String sValue
80173>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80175>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80175>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80176>>>>>>>>>>
80176>>>>>>>>>            Procedure_Return
80177>>>>>>>>>        End
80177>>>>>>>>>>
80177>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80178>>>>>>>>>    End_Procedure
80179>>>>>>>>>
80179>>>>>>>>>    Function psServer Returns String
80181>>>>>>>>>        String sValue
80181>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80183>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80184>>>>>>>>>>
80184>>>>>>>>>            Function_Return
80185>>>>>>>>>        End
80185>>>>>>>>>>
80185>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80186>>>>>>>>>        Function_Return sValue
80187>>>>>>>>>    End_Function
80188>>>>>>>>>
80188>>>>>>>>>    Procedure Set psDatabase String sValue
80190>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80192>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80193>>>>>>>>>>
80193>>>>>>>>>            Procedure_Return
80194>>>>>>>>>        End
80194>>>>>>>>>>
80194>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80195>>>>>>>>>    End_Procedure
80196>>>>>>>>>
80196>>>>>>>>>    Function psDatabase Returns String
80198>>>>>>>>>        String sValue
80198>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80200>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80201>>>>>>>>>>
80201>>>>>>>>>            Function_Return
80202>>>>>>>>>        End
80202>>>>>>>>>>
80202>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80203>>>>>>>>>        Function_Return sValue
80204>>>>>>>>>    End_Function
80205>>>>>>>>>
80205>>>>>>>>>    Procedure Set psUserID String sValue
80207>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80209>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80210>>>>>>>>>>
80210>>>>>>>>>            Procedure_Return
80211>>>>>>>>>        End
80211>>>>>>>>>>
80211>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80212>>>>>>>>>    End_Procedure
80213>>>>>>>>>
80213>>>>>>>>>    Function psUserID Returns String
80215>>>>>>>>>        String sValue
80215>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80217>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80218>>>>>>>>>>
80218>>>>>>>>>            Function_Return
80219>>>>>>>>>        End
80219>>>>>>>>>>
80219>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80220>>>>>>>>>        Function_Return sValue
80221>>>>>>>>>    End_Function
80222>>>>>>>>>
80222>>>>>>>>>    Procedure Set psPassword String sValue
80224>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80226>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80227>>>>>>>>>>
80227>>>>>>>>>            Procedure_Return
80228>>>>>>>>>        End
80228>>>>>>>>>>
80228>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80229>>>>>>>>>    End_Procedure
80230>>>>>>>>>
80230>>>>>>>>>    Function psPassword Returns String
80232>>>>>>>>>        String sValue
80232>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80234>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80235>>>>>>>>>>
80235>>>>>>>>>            Function_Return
80236>>>>>>>>>        End
80236>>>>>>>>>>
80236>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80237>>>>>>>>>        Function_Return sValue
80238>>>>>>>>>    End_Function
80239>>>>>>>>>
80239>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80241>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80243>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80244>>>>>>>>>>
80244>>>>>>>>>            Procedure_Return
80245>>>>>>>>>        End
80245>>>>>>>>>>
80245>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80246>>>>>>>>>    End_Procedure
80247>>>>>>>>>
80247>>>>>>>>>    Function pbTrusted Returns Boolean
80249>>>>>>>>>        Boolean bValue
80249>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80251>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80252>>>>>>>>>>
80252>>>>>>>>>            Function_Return
80253>>>>>>>>>        End
80253>>>>>>>>>>
80253>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80254>>>>>>>>>        Function_Return bValue
80255>>>>>>>>>    End_Function
80256>>>>>>>>>
80256>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80258>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80260>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80261>>>>>>>>>>
80261>>>>>>>>>            Procedure_Return
80262>>>>>>>>>        End
80262>>>>>>>>>>
80262>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80263>>>>>>>>>    End_Procedure
80264>>>>>>>>>
80264>>>>>>>>>    Function pbSilentLogin Returns Boolean
80266>>>>>>>>>        Boolean bValue
80266>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80268>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80269>>>>>>>>>>
80269>>>>>>>>>            Function_Return
80270>>>>>>>>>        End
80270>>>>>>>>>>
80270>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80271>>>>>>>>>        Function_Return bValue
80272>>>>>>>>>    End_Function
80273>>>>>>>>>
80273>>>>>>>>>    Procedure Set psConnectionID String sValue
80275>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80277>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80278>>>>>>>>>>
80278>>>>>>>>>            Procedure_Return
80279>>>>>>>>>        End
80279>>>>>>>>>>
80279>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80280>>>>>>>>>    End_Procedure
80281>>>>>>>>>
80281>>>>>>>>>    Function psConnectionID Returns String
80283>>>>>>>>>        String sValue
80283>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80285>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80286>>>>>>>>>>
80286>>>>>>>>>            Function_Return
80287>>>>>>>>>        End
80287>>>>>>>>>>
80287>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80288>>>>>>>>>        Function_Return sValue
80289>>>>>>>>>    End_Function
80290>>>>>>>>>
80290>>>>>>>>>    Procedure Set psConnectionString String sValue
80292>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80294>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80295>>>>>>>>>>
80295>>>>>>>>>            Procedure_Return
80296>>>>>>>>>        End
80296>>>>>>>>>>
80296>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80297>>>>>>>>>    End_Procedure
80298>>>>>>>>>
80298>>>>>>>>>    Function psConnectionString Returns String
80300>>>>>>>>>        String sValue
80300>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80302>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80303>>>>>>>>>>
80303>>>>>>>>>            Function_Return
80304>>>>>>>>>        End
80304>>>>>>>>>>
80304>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80305>>>>>>>>>        Function_Return sValue
80306>>>>>>>>>    End_Function
80307>>>>>>>>>
80307>>>>>>>>>    // The normal connection string looks something like this;
80307>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80307>>>>>>>>>    // ...and the full connection string looks like this;
80307>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80307>>>>>>>>>    Function psFullConnectionString Returns String
80309>>>>>>>>>        String sConnectionID sConnectionString
80309>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80311>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80312>>>>>>>>>>
80312>>>>>>>>>            Function_Return
80313>>>>>>>>>        End
80313>>>>>>>>>>
80313>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80314>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80315>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80316>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80317>>>>>>>>>    End_Function
80318>>>>>>>>>
80318>>>>>>>>>    Function piConnectionOptions Returns Integer
80320>>>>>>>>>        Integer iValue
80320>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80322>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80323>>>>>>>>>>
80323>>>>>>>>>            Function_Return
80324>>>>>>>>>        End
80324>>>>>>>>>>
80324>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80325>>>>>>>>>        Function_Return iValue
80326>>>>>>>>>    End_Function
80327>>>>>>>>>
80327>>>>>>>>>    Procedure Set psSchema String sValue
80329>>>>>>>>>        tSQLConnection SQLConnection
80329>>>>>>>>>        tSQLConnection SQLConnection
80329>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80331>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80332>>>>>>>>>>
80332>>>>>>>>>            Procedure_Return
80333>>>>>>>>>        End
80333>>>>>>>>>>
80333>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80334>>>>>>>>>    End_Procedure
80335>>>>>>>>>
80335>>>>>>>>>    Function psSchema Returns String
80337>>>>>>>>>        String sRetval
80337>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80339>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80340>>>>>>>>>>
80340>>>>>>>>>            Function_Return
80341>>>>>>>>>        End
80341>>>>>>>>>>
80341>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80342>>>>>>>>>        Function_Return sRetval
80343>>>>>>>>>    End_Function
80344>>>>>>>>>
80344>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80346>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80348>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80349>>>>>>>>>>
80349>>>>>>>>>            Procedure_Return
80350>>>>>>>>>        End
80350>>>>>>>>>>
80350>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80351>>>>>>>>>    End_Procedure
80352>>>>>>>>>
80352>>>>>>>>>    Function psBaseTableSpace Returns String
80354>>>>>>>>>        String sRetval
80354>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80356>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80357>>>>>>>>>>
80357>>>>>>>>>            Function_Return
80358>>>>>>>>>        End
80358>>>>>>>>>>
80358>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80359>>>>>>>>>        Function_Return sRetval
80360>>>>>>>>>    End_Function
80361>>>>>>>>>
80361>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80363>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80365>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80366>>>>>>>>>>
80366>>>>>>>>>            Procedure_Return
80367>>>>>>>>>        End
80367>>>>>>>>>>
80367>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80368>>>>>>>>>    End_Procedure
80369>>>>>>>>>
80369>>>>>>>>>    Function psLongTableSpace Returns String
80371>>>>>>>>>        String sRetval
80371>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80373>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80374>>>>>>>>>>
80374>>>>>>>>>            Function_Return
80375>>>>>>>>>        End
80375>>>>>>>>>>
80375>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80376>>>>>>>>>        Function_Return sRetval
80377>>>>>>>>>    End_Function
80378>>>>>>>>>
80378>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80380>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80382>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80383>>>>>>>>>>
80383>>>>>>>>>            Procedure_Return
80384>>>>>>>>>        End
80384>>>>>>>>>>
80384>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80385>>>>>>>>>    End_Procedure
80386>>>>>>>>>
80386>>>>>>>>>    Function psIndexTableSpace Returns String
80388>>>>>>>>>        String sRetval
80388>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80390>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80391>>>>>>>>>>
80391>>>>>>>>>            Function_Return
80392>>>>>>>>>        End
80392>>>>>>>>>>
80392>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80393>>>>>>>>>        Function_Return sRetval
80394>>>>>>>>>    End_Function
80395>>>>>>>>>
80395>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80397>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80399>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80400>>>>>>>>>>
80400>>>>>>>>>            Procedure_Return
80401>>>>>>>>>        End
80401>>>>>>>>>>
80401>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80402>>>>>>>>>    End_Procedure
80403>>>>>>>>>
80403>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80405>>>>>>>>>        Boolean bState
80405>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80407>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80408>>>>>>>>>>
80408>>>>>>>>>            Function_Return
80409>>>>>>>>>        End
80409>>>>>>>>>>
80409>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80410>>>>>>>>>        Function_Return bState
80411>>>>>>>>>    End_Function
80412>>>>>>>>>
80412>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80414>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80416>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80417>>>>>>>>>>
80417>>>>>>>>>            Procedure_Return
80418>>>>>>>>>        End
80418>>>>>>>>>>
80418>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80419>>>>>>>>>    End_Procedure
80420>>>>>>>>>
80420>>>>>>>>>    Function pbToANSI Returns Boolean
80422>>>>>>>>>        Boolean bState
80422>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80424>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80425>>>>>>>>>>
80425>>>>>>>>>            Function_Return
80426>>>>>>>>>        End
80426>>>>>>>>>>
80426>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80427>>>>>>>>>        Function_Return bState
80428>>>>>>>>>    End_Function
80429>>>>>>>>>
80429>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80431>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80433>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80434>>>>>>>>>>
80434>>>>>>>>>            Procedure_Return
80435>>>>>>>>>        End
80435>>>>>>>>>>
80435>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80436>>>>>>>>>    End_Procedure
80437>>>>>>>>>
80437>>>>>>>>>    Function pbRecnum Returns Boolean
80439>>>>>>>>>        Boolean bState
80439>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80441>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80442>>>>>>>>>>
80442>>>>>>>>>            Function_Return
80443>>>>>>>>>        End
80443>>>>>>>>>>
80443>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80444>>>>>>>>>        Function_Return bState
80445>>>>>>>>>    End_Function
80446>>>>>>>>>
80446>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80448>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80450>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80451>>>>>>>>>>
80451>>>>>>>>>            Procedure_Return
80452>>>>>>>>>        End
80452>>>>>>>>>>
80452>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80453>>>>>>>>>    End_Procedure
80454>>>>>>>>>
80454>>>>>>>>>    Function pbCopyData Returns Boolean
80456>>>>>>>>>        Boolean bState
80456>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80458>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80459>>>>>>>>>>
80459>>>>>>>>>            Function_Return
80460>>>>>>>>>        End
80460>>>>>>>>>>
80460>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80461>>>>>>>>>        Function_Return bState
80462>>>>>>>>>    End_Function
80463>>>>>>>>>
80463>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80465>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80467>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80468>>>>>>>>>>
80468>>>>>>>>>            Procedure_Return
80469>>>>>>>>>        End
80469>>>>>>>>>>
80469>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80470>>>>>>>>>    End_Procedure
80471>>>>>>>>>
80471>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80473>>>>>>>>>        Boolean bState
80473>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80475>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80476>>>>>>>>>>
80476>>>>>>>>>            Function_Return
80477>>>>>>>>>        End
80477>>>>>>>>>>
80477>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80478>>>>>>>>>        Function_Return bState
80479>>>>>>>>>    End_Function
80480>>>>>>>>>
80480>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80482>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80484>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80485>>>>>>>>>>
80485>>>>>>>>>            Procedure_Return
80486>>>>>>>>>        End
80486>>>>>>>>>>
80486>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80487>>>>>>>>>    End_Procedure
80488>>>>>>>>>
80488>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80490>>>>>>>>>        Boolean bState
80490>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80492>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80493>>>>>>>>>>
80493>>>>>>>>>            Function_Return
80494>>>>>>>>>        End
80494>>>>>>>>>>
80494>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80495>>>>>>>>>        Function_Return bState
80496>>>>>>>>>    End_Function
80497>>>>>>>>>
80497>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80499>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80501>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80502>>>>>>>>>>
80502>>>>>>>>>            Procedure_Return
80503>>>>>>>>>        End
80503>>>>>>>>>>
80503>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80504>>>>>>>>>    End_Procedure
80505>>>>>>>>>
80505>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80507>>>>>>>>>        Boolean bState
80507>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80509>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80510>>>>>>>>>>
80510>>>>>>>>>            Function_Return
80511>>>>>>>>>        End
80511>>>>>>>>>>
80511>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80512>>>>>>>>>        Function_Return bState
80513>>>>>>>>>    End_Function
80514>>>>>>>>>
80514>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80516>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80518>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80519>>>>>>>>>>
80519>>>>>>>>>            Procedure_Return
80520>>>>>>>>>        End
80520>>>>>>>>>>
80520>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80521>>>>>>>>>    End_Procedure
80522>>>>>>>>>
80522>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80524>>>>>>>>>        Boolean bState
80524>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80526>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80527>>>>>>>>>>
80527>>>>>>>>>            Function_Return
80528>>>>>>>>>        End
80528>>>>>>>>>>
80528>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80529>>>>>>>>>        Function_Return bState
80530>>>>>>>>>    End_Function
80531>>>>>>>>>
80531>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80533>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80535>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80536>>>>>>>>>>
80536>>>>>>>>>            Procedure_Return
80537>>>>>>>>>        End
80537>>>>>>>>>>
80537>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80538>>>>>>>>>    End_Procedure
80539>>>>>>>>>
80539>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80541>>>>>>>>>        String sRetval
80541>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80543>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80544>>>>>>>>>>
80544>>>>>>>>>            Function_Return
80545>>>>>>>>>        End
80545>>>>>>>>>>
80545>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80546>>>>>>>>>        Function_Return sRetval
80547>>>>>>>>>    End_Function
80548>>>>>>>>>
80548>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80550>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80552>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80553>>>>>>>>>>
80553>>>>>>>>>            Procedure_Return
80554>>>>>>>>>        End
80554>>>>>>>>>>
80554>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80555>>>>>>>>>    End_Procedure
80556>>>>>>>>>
80556>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80558>>>>>>>>>        String sRetval
80558>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80560>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80561>>>>>>>>>>
80561>>>>>>>>>            Function_Return
80562>>>>>>>>>        End
80562>>>>>>>>>>
80562>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80563>>>>>>>>>        Function_Return sRetval
80564>>>>>>>>>    End_Function
80565>>>>>>>>>
80565>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80567>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80569>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80570>>>>>>>>>>
80570>>>>>>>>>            Procedure_Return
80571>>>>>>>>>        End
80571>>>>>>>>>>
80571>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80572>>>>>>>>>    End_Procedure
80573>>>>>>>>>
80573>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80575>>>>>>>>>        String sRetval
80575>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80577>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80578>>>>>>>>>>
80578>>>>>>>>>            Function_Return
80579>>>>>>>>>        End
80579>>>>>>>>>>
80579>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80580>>>>>>>>>        Function_Return sRetval
80581>>>>>>>>>    End_Function
80582>>>>>>>>>
80582>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80584>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80586>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80587>>>>>>>>>>
80587>>>>>>>>>            Procedure_Return
80588>>>>>>>>>        End
80588>>>>>>>>>>
80588>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80589>>>>>>>>>    End_Procedure
80590>>>>>>>>>
80590>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80592>>>>>>>>>        String sRetval
80592>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80594>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80595>>>>>>>>>>
80595>>>>>>>>>            Function_Return
80596>>>>>>>>>        End
80596>>>>>>>>>>
80596>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80597>>>>>>>>>        Function_Return sRetval
80598>>>>>>>>>    End_Function
80599>>>>>>>>>
80599>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80601>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80603>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80604>>>>>>>>>>
80604>>>>>>>>>            Procedure_Return
80605>>>>>>>>>        End
80605>>>>>>>>>>
80605>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80606>>>>>>>>>    End_Procedure
80607>>>>>>>>>
80607>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80609>>>>>>>>>        String sRetval
80609>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80611>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80612>>>>>>>>>>
80612>>>>>>>>>            Function_Return
80613>>>>>>>>>        End
80613>>>>>>>>>>
80613>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80614>>>>>>>>>        Function_Return sRetval
80615>>>>>>>>>    End_Function
80616>>>>>>>>>
80616>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80618>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80620>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80621>>>>>>>>>>
80621>>>>>>>>>            Procedure_Return
80622>>>>>>>>>        End
80622>>>>>>>>>>
80622>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80623>>>>>>>>>    End_Procedure
80624>>>>>>>>>
80624>>>>>>>>>    Function psDriverDefaultValueText Returns String
80626>>>>>>>>>        String sRetval
80626>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80628>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80629>>>>>>>>>>
80629>>>>>>>>>            Function_Return
80630>>>>>>>>>        End
80630>>>>>>>>>>
80630>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80631>>>>>>>>>        Function_Return sRetval
80632>>>>>>>>>    End_Function
80633>>>>>>>>>
80633>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80635>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80637>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80638>>>>>>>>>>
80638>>>>>>>>>            Procedure_Return
80639>>>>>>>>>        End
80639>>>>>>>>>>
80639>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80640>>>>>>>>>    End_Procedure
80641>>>>>>>>>
80641>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80643>>>>>>>>>        Boolean bState
80643>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80645>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80646>>>>>>>>>>
80646>>>>>>>>>            Function_Return
80647>>>>>>>>>        End
80647>>>>>>>>>>
80647>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80648>>>>>>>>>        Function_Return bState
80649>>>>>>>>>    End_Function
80650>>>>>>>>>
80650>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80652>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80654>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80655>>>>>>>>>>
80655>>>>>>>>>            Procedure_Return
80656>>>>>>>>>        End
80656>>>>>>>>>>
80656>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80657>>>>>>>>>    End_Procedure
80658>>>>>>>>>
80658>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80660>>>>>>>>>        Boolean bState
80660>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80662>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80663>>>>>>>>>>
80663>>>>>>>>>            Function_Return
80664>>>>>>>>>        End
80664>>>>>>>>>>
80664>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80665>>>>>>>>>        Function_Return bState
80666>>>>>>>>>    End_Function
80667>>>>>>>>>
80667>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80669>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80671>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80672>>>>>>>>>>
80672>>>>>>>>>            Procedure_Return
80673>>>>>>>>>        End
80673>>>>>>>>>>
80673>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80674>>>>>>>>>    End_Procedure
80675>>>>>>>>>
80675>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80677>>>>>>>>>        Boolean bState
80677>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80679>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80680>>>>>>>>>>
80680>>>>>>>>>            Function_Return
80681>>>>>>>>>        End
80681>>>>>>>>>>
80681>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80682>>>>>>>>>        Function_Return bState
80683>>>>>>>>>    End_Function
80684>>>>>>>>>
80684>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80686>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80688>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80689>>>>>>>>>>
80689>>>>>>>>>            Procedure_Return
80690>>>>>>>>>        End
80690>>>>>>>>>>
80690>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80691>>>>>>>>>    End_Procedure
80692>>>>>>>>>
80692>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80694>>>>>>>>>        Boolean bState
80694>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80696>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80697>>>>>>>>>>
80697>>>>>>>>>            Function_Return
80698>>>>>>>>>        End
80698>>>>>>>>>>
80698>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80699>>>>>>>>>        Function_Return bState
80700>>>>>>>>>    End_Function
80701>>>>>>>>>
80701>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80703>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80705>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80706>>>>>>>>>>
80706>>>>>>>>>            Procedure_Return
80707>>>>>>>>>        End
80707>>>>>>>>>>
80707>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80708>>>>>>>>>    End_Procedure
80709>>>>>>>>>
80709>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80711>>>>>>>>>        Boolean bState
80711>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80713>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80714>>>>>>>>>>
80714>>>>>>>>>            Function_Return
80715>>>>>>>>>        End
80715>>>>>>>>>>
80715>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80716>>>>>>>>>        Function_Return bState
80717>>>>>>>>>    End_Function
80718>>>>>>>>>
80718>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80720>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80722>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80723>>>>>>>>>>
80723>>>>>>>>>            Procedure_Return
80724>>>>>>>>>        End
80724>>>>>>>>>>
80724>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80725>>>>>>>>>    End_Procedure
80726>>>>>>>>>
80726>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80728>>>>>>>>>        Boolean bState
80728>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80730>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80731>>>>>>>>>>
80731>>>>>>>>>            Function_Return
80732>>>>>>>>>        End
80732>>>>>>>>>>
80732>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80733>>>>>>>>>        Function_Return bState
80734>>>>>>>>>    End_Function
80735>>>>>>>>>
80735>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80735>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80735>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80735>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80735>>>>>>>>>    Procedure Set psDriverID String sValue
80737>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80738>>>>>>>>>        Delegate Set psDriverID to sValue
80740>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80741>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80742>>>>>>>>>    End_Procedure
80743>>>>>>>>>
80743>>>>>>>>>    Function psDriverID Returns String
80745>>>>>>>>>        String sDriverID
80745>>>>>>>>>
80745>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80746>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80746>>>>>>>>>        Delegate Get psDriverID to sDriverID
80748>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80749>>>>>>>>>        Move False to Err
80750>>>>>>>>>
80750>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80750>>>>>>>>>        // probably used as "utilites" from a special made program and
80750>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80750>>>>>>>>>        If (sDriverID = "") Begin
80752>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80753>>>>>>>>>        End
80753>>>>>>>>>>
80753>>>>>>>>>        Function_Return sDriverID
80754>>>>>>>>>    End_Function
80755>>>>>>>>>
80755>>>>>>>>>    Procedure Set piDbType Integer iValue
80757>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80758>>>>>>>>>        Delegate Set piDbType to iValue
80760>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80761>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80762>>>>>>>>>    End_Procedure
80763>>>>>>>>>
80763>>>>>>>>>    Function piDbType Returns Integer
80765>>>>>>>>>        Integer iRetval
80765>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80766>>>>>>>>>        Function_Return iRetval
80767>>>>>>>>>    End_Function
80768>>>>>>>>>
80768>>>>>>>>>    // Returns the index for the passed sTableName
80768>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80768>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80770>>>>>>>>>        Integer iIndex iSize iCount iItem
80770>>>>>>>>>        String[] asTablesArray
80771>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80771>>>>>>>>>
80771>>>>>>>>>        Move -1 to iIndex
80772>>>>>>>>>        Get psConnectionString to sConnectionString
80773>>>>>>>>>        Get psDatabase to sDatabase
80774>>>>>>>>>        Get psSchema   to sSchema
80775>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
80776>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
80777>>>>>>>>>        If (iItem <> -1) Begin
80779>>>>>>>>>            Move iItem to iIndex
80780>>>>>>>>>        End
80780>>>>>>>>>>
80780>>>>>>>>>        Function_Return iIndex
80781>>>>>>>>>    End_Function
80782>>>>>>>>>
80782>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80782>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80784>>>>>>>>>        String[] sReturnArray
80785>>>>>>>>>        Boolean bOK
80785>>>>>>>>>
80785>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80786>>>>>>>>>        If (bOK = False) Begin
80788>>>>>>>>>            Function_Return sReturnArray
80789>>>>>>>>>        End
80789>>>>>>>>>>
80789>>>>>>>>>
80789>>>>>>>>>        Case Begin
80789>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80791>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80792>>>>>>>>>                Case Break
80793>>>>>>>>>
80793>>>>>>>>>            Case Else
80793>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80794>>>>>>>>>>
80794>>>>>>>>>                Case Break
80795>>>>>>>>>        Case End
80795>>>>>>>>>
80795>>>>>>>>>        Function_Return sReturnArray
80796>>>>>>>>>    End_Function
80797>>>>>>>>>
80797>>>>>>>>>    // Returns a string array with all tables for the current database.
80797>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80799>>>>>>>>>        String[] asReturnArray
80800>>>>>>>>>        String sConnectionString sSelect
80800>>>>>>>>>        Integer iSize iCount iDbType
80800>>>>>>>>>        Boolean bOK
80800>>>>>>>>>
80800>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80802>>>>>>>>>            Function_Return asReturnArray
80803>>>>>>>>>        End
80803>>>>>>>>>>
80803>>>>>>>>>
80803>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80804>>>>>>>>>        If (bOK = False) Begin
80806>>>>>>>>>            Function_Return asReturnArray
80807>>>>>>>>>        End
80807>>>>>>>>>>
80807>>>>>>>>>        If (sSchema = "") Begin
80809>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80810>>>>>>>>>        End
80810>>>>>>>>>>
80810>>>>>>>>>
80810>>>>>>>>>        Get psConnectionString to sConnectionString
80811>>>>>>>>>
80811>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80811>>>>>>>>>        // the dbType.
80811>>>>>>>>>        Get piDbType to iDbType
80812>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80814>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80816>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80817>>>>>>>>>            End
80817>>>>>>>>>>
80817>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80819>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80820>>>>>>>>>            End
80820>>>>>>>>>>
80820>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80822>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80823>>>>>>>>>            End
80823>>>>>>>>>>
80823>>>>>>>>>        End
80823>>>>>>>>>>
80823>>>>>>>>>
80823>>>>>>>>>        Case Begin
80823>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80825>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80826>>>>>>>>>                Case Break
80827>>>>>>>>>
80827>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80830>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80831>>>>>>>>>                Case Break
80832>>>>>>>>>
80832>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80835>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80836>>>>>>>>>                Case Break
80837>>>>>>>>>
80837>>>>>>>>>            Case Else
80837>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80838>>>>>>>>>>
80838>>>>>>>>>                Case Break
80839>>>>>>>>>        Case End
80839>>>>>>>>>
80839>>>>>>>>>        Function_Return asReturnArray
80840>>>>>>>>>    End_Function
80841>>>>>>>>>
80841>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80841>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80843>>>>>>>>>        String[] sReturnArray
80844>>>>>>>>>        Boolean bOK
80844>>>>>>>>>
80844>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80845>>>>>>>>>        If (bOK = False) Begin
80847>>>>>>>>>            Function_Return sReturnArray
80848>>>>>>>>>        End
80848>>>>>>>>>>
80848>>>>>>>>>
80848>>>>>>>>>        Case Begin
80848>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80850>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80851>>>>>>>>>                Case Break
80852>>>>>>>>>
80852>>>>>>>>>            Case Else
80852>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80853>>>>>>>>>>
80853>>>>>>>>>                Case Break
80854>>>>>>>>>        Case End
80854>>>>>>>>>
80854>>>>>>>>>        Function_Return sReturnArray
80855>>>>>>>>>    End_Function
80856>>>>>>>>>
80856>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80856>>>>>>>>>    Function _SqlUtilEnumerateColumnsByHandle String sDriverID Handle hTable Returns String[]
80858>>>>>>>>>        String[] asReturnArray
80859>>>>>>>>>        String sRootName sTableName
80859>>>>>>>>>        
80859>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
80862>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
80863>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to asReturnArray
80864>>>>>>>>>        Function_Return asReturnArray
80865>>>>>>>>>    End_Function
80866>>>>>>>>>
80866>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80866>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80868>>>>>>>>>        String[] sReturnArray
80869>>>>>>>>>        String sConnectionString sSelect sSchema
80869>>>>>>>>>        Boolean bOK
80869>>>>>>>>>        Integer iDbType
80869>>>>>>>>>
80869>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80870>>>>>>>>>        If (bOK = False) Begin
80872>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80873>>>>>>>>>>
80873>>>>>>>>>            Function_Return sReturnArray
80874>>>>>>>>>        End
80874>>>>>>>>>>
80874>>>>>>>>>
80874>>>>>>>>>        Get psConnectionString to sConnectionString
80875>>>>>>>>>        Get psSchema to sSchema
80876>>>>>>>>>
80876>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80876>>>>>>>>>        // the dbType.
80876>>>>>>>>>        Get piDbType to iDbType
80877>>>>>>>>>
80877>>>>>>>>>        Case Begin
80877>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80879>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80881>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80882>>>>>>>>>                End
80882>>>>>>>>>>
80882>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80884>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80885>>>>>>>>>                End
80885>>>>>>>>>>
80885>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80887>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80888>>>>>>>>>                End
80888>>>>>>>>>>
80888>>>>>>>>>
80888>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80889>>>>>>>>>                Case Break
80890>>>>>>>>>
80890>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80893>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80894>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80895>>>>>>>>>                Case Break
80896>>>>>>>>>
80896>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80899>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80900>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80901>>>>>>>>>                Case Break
80902>>>>>>>>>
80902>>>>>>>>>            Case Else
80902>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80903>>>>>>>>>>
80903>>>>>>>>>                Case Break
80904>>>>>>>>>        Case End
80904>>>>>>>>>
80904>>>>>>>>>        Function_Return sReturnArray
80905>>>>>>>>>    End_Function
80906>>>>>>>>>
80906>>>>>>>>>
80906>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80906>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80908>>>>>>>>>        String[] asReturnArray asReturnArray2
80910>>>>>>>>>        String sConnectionString sSelect sSchema
80910>>>>>>>>>        Boolean bOK
80910>>>>>>>>>        Integer iCount iSize
80910>>>>>>>>>
80910>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80911>>>>>>>>>        If (bOK = False) Begin
80913>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80914>>>>>>>>>>
80914>>>>>>>>>            Function_Return asReturnArray
80915>>>>>>>>>        End
80915>>>>>>>>>>
80915>>>>>>>>>
80915>>>>>>>>>        Get psConnectionString to sConnectionString
80916>>>>>>>>>        Get psSchema to sSchema
80917>>>>>>>>>
80917>>>>>>>>>        Case Begin
80917>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80919>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80920>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80921>>>>>>>>>                Case Break
80922>>>>>>>>>
80922>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80925>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80926>>>>>>>>>>
80926>>>>>>>>>//                Move () to sSelect
80926>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80926>>>>>>>>>                Case Break
80927>>>>>>>>>
80927>>>>>>>>>            Case Else
80927>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80928>>>>>>>>>>
80928>>>>>>>>>                Case Break
80929>>>>>>>>>        Case End
80929>>>>>>>>>
80929>>>>>>>>>        Move (SizeOfArray(asReturnArray)) to iSize
80930>>>>>>>>>        Decrement iSize
80931>>>>>>>>>        For iCount from 0 to iSize
80937>>>>>>>>>>
80937>>>>>>>>>            If (Trim(asReturnArray[iCount]) <> "") Begin
80939>>>>>>>>>                Move asReturnArray[iCount] to asReturnArray2[SizeOfArray(asReturnArray2)]
80940>>>>>>>>>            End
80940>>>>>>>>>>
80940>>>>>>>>>        Loop
80941>>>>>>>>>>
80941>>>>>>>>>
80941>>>>>>>>>        Function_Return asReturnArray2
80942>>>>>>>>>    End_Function
80943>>>>>>>>>
80943>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80943>>>>>>>>>    // The format of the array is "TableName.FieldName"
80943>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80945>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80947>>>>>>>>>        tSQLRelation[] sRelationsArray
80947>>>>>>>>>        tSQLRelation[] sRelationsArray
80948>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80948>>>>>>>>>        Boolean bOK
80948>>>>>>>>>        Integer iCount iSize iLength
80948>>>>>>>>>
80948>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80949>>>>>>>>>        If (bOK = False) Begin
80951>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80952>>>>>>>>>>
80952>>>>>>>>>            Function_Return sRelationsArray
80953>>>>>>>>>        End
80953>>>>>>>>>>
80953>>>>>>>>>
80953>>>>>>>>>        Get psConnectionString to sConnectionString
80954>>>>>>>>>        Get psSchema to sSchema
80955>>>>>>>>>
80955>>>>>>>>>        Case Begin
80955>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80957>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80958>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80959>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80960>>>>>>>>>                Case Break
80961>>>>>>>>>
80961>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80964>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80965>>>>>>>>>>
80965>>>>>>>>>//                Move () to sSelect
80965>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80965>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80965>>>>>>>>>                Case Break
80966>>>>>>>>>
80966>>>>>>>>>            Case Else
80966>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80967>>>>>>>>>>
80967>>>>>>>>>                Case Break
80968>>>>>>>>>        Case End
80968>>>>>>>>>
80968>>>>>>>>>        Move (Length(sTableName)) to iLength
80969>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80970>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80971>>>>>>>>>        Decrement iSize
80972>>>>>>>>>        For iCount from 0 to iSize
80978>>>>>>>>>>
80978>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80980>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80981>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80982>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80983>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80984>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80985>>>>>>>>>            End
80985>>>>>>>>>>
80985>>>>>>>>>        Loop
80986>>>>>>>>>>
80986>>>>>>>>>
80986>>>>>>>>>        Function_Return sRelationsArray
80987>>>>>>>>>    End_Function
80988>>>>>>>>>
80988>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80990>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80990>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80991>>>>>>>>>        String[] sUsers sPrograms
80993>>>>>>>>>        String sSelect
80993>>>>>>>>>        Integer iSize iCount
80993>>>>>>>>>
80993>>>>>>>>>        Case Begin
80993>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80995>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80996>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80997>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80998>>>>>>>>>                Case Break
80999>>>>>>>>>            Case Else
80999>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
81000>>>>>>>>>>
81000>>>>>>>>>        Case End
81000>>>>>>>>>
81000>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
81001>>>>>>>>>        Decrement iSize
81002>>>>>>>>>        For iCount from 0 to iSize
81008>>>>>>>>>>
81008>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
81009>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
81010>>>>>>>>>        Loop
81011>>>>>>>>>>
81011>>>>>>>>>
81011>>>>>>>>>        Function_Return SQLLoggedInUser
81012>>>>>>>>>    End_Function
81013>>>>>>>>>
81013>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
81013>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
81013>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
81015>>>>>>>>>        String[] sFilesData
81016>>>>>>>>>        Boolean bExists
81016>>>>>>>>>        Integer iCh
81016>>>>>>>>>        String sFileName sExt
81016>>>>>>>>>
81016>>>>>>>>>        Get vFolderExists sDataPath to bExists
81017>>>>>>>>>        If (bExists = True) Begin
81019>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
81020>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
81021>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
81022>>>>>>>>>            Direct_Input channel iCh sDataPath
81024>>>>>>>>>                Repeat
81024>>>>>>>>>>
81024>>>>>>>>>                    Readln channel iCh sFileName
81026>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
81027>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
81029>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
81031>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
81032>>>>>>>>>                        End
81032>>>>>>>>>>
81032>>>>>>>>>                    End
81032>>>>>>>>>>
81032>>>>>>>>>                Until (SeqEof = True)
81034>>>>>>>>>            Close_Input channel iCh
81036>>>>>>>>>            Send Seq_Release_Channel iCh
81037>>>>>>>>>        End
81037>>>>>>>>>>
81037>>>>>>>>>        Function_Return sFilesData
81038>>>>>>>>>    End_Function
81039>>>>>>>>>
81039>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
81039>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns tSQLCollation[]
81041>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
81041>>>>>>>>>        String sDescription sFrom sSys sValue sDescr sPrevious
81041>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
81041>>>>>>>>>        Integer iFetchResult iRows iColumn iPos iRow
81041>>>>>>>>>        tSQLConnection SQLConnection
81041>>>>>>>>>        tSQLConnection SQLConnection
81041>>>>>>>>>        tSQLCollation[] aCollations
81041>>>>>>>>>        tSQLCollation[] aCollations
81042>>>>>>>>>        
81042>>>>>>>>>        If (sDriverID = "") Begin
81044>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the '_SqlEnumerateDatabaseCollations' function"
81045>>>>>>>>>>
81045>>>>>>>>>            Function_Return aCollations
81046>>>>>>>>>        End
81046>>>>>>>>>>
81046>>>>>>>>>
81046>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
81046>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
81048>>>>>>>>>            Function_Return aCollations
81049>>>>>>>>>        End                 
81049>>>>>>>>>>
81049>>>>>>>>>
81049>>>>>>>>>        Get phoSQLManager to hoSQLManager
81050>>>>>>>>>        Get psConnectionID     to sConnectionID
81051>>>>>>>>>        Get psConnectionString to sConnectionString
81052>>>>>>>>>        Move 0 to LastErr
81053>>>>>>>>>
81053>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81054>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
81055>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81056>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
81058>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
81059>>>>>>>>>>
81059>>>>>>>>>            Function_Return aCollations
81060>>>>>>>>>        End
81060>>>>>>>>>>
81060>>>>>>>>>
81060>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
81061>>>>>>>>>
81061>>>>>>>>>        If (hStmt = 0) Begin
81063>>>>>>>>>            Send SqlDisconnect of hoSQLManager
81064>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
81065>>>>>>>>>>
81065>>>>>>>>>            Function_Return aCollations
81066>>>>>>>>>        End
81066>>>>>>>>>>
81066>>>>>>>>>        
81066>>>>>>>>>        Move 0 to iRow
81067>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
81068>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
81069>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
81070>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
81071>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
81072>>>>>>>>>
81072>>>>>>>>>        // MS-SQL Syntax:  
81072>>>>>>>>>        // SELECT name, description
81072>>>>>>>>>        //   from sys.fn_helpcollations();
81072>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
81073>>>>>>>>>
81073>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
81074>>>>>>>>>        Get SQLGetStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
81075>>>>>>>>>        Repeat
81075>>>>>>>>>>
81075>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
81076>>>>>>>>>            If (iFetchResult <> 0) Begin
81078>>>>>>>>>                Get SQLColumnValue of hStmt 1 to sValue 
81079>>>>>>>>>                If (sValue <> sPrevious) Begin         
81081>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81081>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81081>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81082>>>>>>>>>                    If (iPos <> 1) Begin
81084>>>>>>>>>                        Move (Trim(sValue)) to aCollations[iRow].sCollation
81085>>>>>>>>>                        Get SQLColumnValue of hStmt 2 to sDescr
81086>>>>>>>>>                        Move (Trim(sDescr)) to aCollations[iRow].sDescription
81087>>>>>>>>>                        Increment iRow
81088>>>>>>>>>                    End
81088>>>>>>>>>>
81088>>>>>>>>>                End
81088>>>>>>>>>>
81088>>>>>>>>>                Move sValue to sPrevious
81089>>>>>>>>>            End
81089>>>>>>>>>>
81089>>>>>>>>>        Until (iFetchResult = 0)
81091>>>>>>>>>        Send SQLClose of hStmt
81092>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81093>>>>>>>>>
81093>>>>>>>>>        Function_Return aCollations
81094>>>>>>>>>    End_Function
81095>>>>>>>>>
81095>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81095>>>>>>>>>    // for DAW drivers.
81095>>>>>>>>>    // Returns: A string array.
81095>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81097>>>>>>>>>        String[] sReturnArray
81098>>>>>>>>>        String sValue sPrevious
81098>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81098>>>>>>>>>        Integer iFetchResult iRows
81098>>>>>>>>>        tSQLConnection SQLConnection
81098>>>>>>>>>        tSQLConnection SQLConnection
81098>>>>>>>>>
81098>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81099>>>>>>>>>
81099>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81101>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81102>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81103>>>>>>>>>
81103>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81105>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81106>>>>>>>>>                If (hstmt <> 0) Begin
81108>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81109>>>>>>>>>                    Get SQLGetStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81110>>>>>>>>>                    Repeat
81110>>>>>>>>>>
81110>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81111>>>>>>>>>                        If (iFetchResult <> 0) Begin
81113>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81114>>>>>>>>>                            If (sValue <> sPrevious) Begin
81116>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81117>>>>>>>>>                            End
81117>>>>>>>>>>
81117>>>>>>>>>                            Move sValue to sPrevious
81118>>>>>>>>>                        End
81118>>>>>>>>>>
81118>>>>>>>>>                    Until (iFetchResult = 0)
81120>>>>>>>>>                    Send SQLClose of hstmt
81121>>>>>>>>>                End
81121>>>>>>>>>>
81121>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81122>>>>>>>>>            End
81122>>>>>>>>>>
81122>>>>>>>>>        End
81122>>>>>>>>>>
81122>>>>>>>>>
81122>>>>>>>>>        Function_Return sReturnArray
81123>>>>>>>>>    End_Function
81124>>>>>>>>>
81124>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81126>>>>>>>>>        String[] sReturnArray
81127>>>>>>>>>        String sDataSource
81127>>>>>>>>>        Handle hoSQLHandler
81127>>>>>>>>>        Integer iItem
81127>>>>>>>>>
81127>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81128>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81129>>>>>>>>>
81129>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81130>>>>>>>>>
81130>>>>>>>>>        Repeat
81130>>>>>>>>>>
81130>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81131>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81132>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81133>>>>>>>>>            Increment iItem
81134>>>>>>>>>        Until (sDataSource = "")
81136>>>>>>>>>
81136>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81137>>>>>>>>>
81137>>>>>>>>>        Function_Return sReturnArray
81138>>>>>>>>>    End_Function
81139>>>>>>>>>
81139>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81141>>>>>>>>>        String[] sReturnArray
81142>>>>>>>>>        String sDataSource
81142>>>>>>>>>        Handle hoSQLHandler
81142>>>>>>>>>        Integer iItem
81142>>>>>>>>>
81142>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81143>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81144>>>>>>>>>
81144>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81145>>>>>>>>>
81145>>>>>>>>>        Repeat
81145>>>>>>>>>>
81145>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81146>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81148>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81149>>>>>>>>>                Increment iItem
81150>>>>>>>>>            End
81150>>>>>>>>>>
81150>>>>>>>>>        Until (sDataSource = "")
81152>>>>>>>>>
81152>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81153>>>>>>>>>
81153>>>>>>>>>        Function_Return sReturnArray
81154>>>>>>>>>    End_Function
81155>>>>>>>>>
81155>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81157>>>>>>>>>        String[] sDataSources
81158>>>>>>>>>        tSQLConnection SQLConnection
81158>>>>>>>>>        tSQLConnection SQLConnection
81158>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81158>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81159>>>>>>>>>        Integer iDataSources iCount iItem
81159>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81159>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81159>>>>>>>>>        Boolean bExists bKeyOpened
81159>>>>>>>>>
81159>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81160>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81161>>>>>>>>>        Move SQLConnection.sServer           to sServer
81162>>>>>>>>>
81162>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81162>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81164>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81165>>>>>>>>>            Set psFileName of hoIniFile to sServer
81166>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81167>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81168>>>>>>>>>            Send Destroy of hoIniFile
81169>>>>>>>>>        End
81169>>>>>>>>>>
81169>>>>>>>>>
81169>>>>>>>>>        // DSN - read DATABASE name from the registry
81169>>>>>>>>>        Else Begin
81170>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81171>>>>>>>>>
81171>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81171>>>>>>>>>            // most probably place the info is kept that we're after.
81171>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81172>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81173>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81174>>>>>>>>>            If (bExists = True) Begin
81176>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81177>>>>>>>>>            End
81177>>>>>>>>>>
81177>>>>>>>>>            Else Begin
81178>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81179>>>>>>>>>            End
81179>>>>>>>>>>
81179>>>>>>>>>
81179>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81180>>>>>>>>>            If (bExists) Begin
81182>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81183>>>>>>>>>                If (bKeyOpened) Begin
81185>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81186>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81187>>>>>>>>>                    If (iDataSources > 0) Begin
81189>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81190>>>>>>>>>                        Decrement iDataSources
81191>>>>>>>>>                        for iCount from 0 to iDataSources
81197>>>>>>>>>>
81197>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81198>>>>>>>>>                        Loop
81199>>>>>>>>>>
81199>>>>>>>>>                        Move 0 to iItem
81200>>>>>>>>>                        for iCount from 0 to iDataSources
81206>>>>>>>>>>
81206>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81207>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81208>>>>>>>>>                            If (bKeyOpened = True) Begin
81210>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81211>>>>>>>>>                                If (bExists = True) Begin
81213>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81214>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81215>>>>>>>>>                                    Increment iItem
81216>>>>>>>>>                                End
81216>>>>>>>>>>
81216>>>>>>>>>                            End
81216>>>>>>>>>>
81216>>>>>>>>>                        Loop
81217>>>>>>>>>>
81217>>>>>>>>>                    End
81217>>>>>>>>>>
81217>>>>>>>>>                    Send CloseKey of hoRegistry
81218>>>>>>>>>                    Send Destroy of hoODBCDataSources
81219>>>>>>>>>                End
81219>>>>>>>>>>
81219>>>>>>>>>            End
81219>>>>>>>>>>
81219>>>>>>>>>
81219>>>>>>>>>            // We then check the "User DNS" area in the registry.
81219>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81220>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81221>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81222>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81223>>>>>>>>>
81223>>>>>>>>>            If (bExists) Begin
81225>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81226>>>>>>>>>                If (bKeyOpened) Begin
81228>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81229>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81230>>>>>>>>>                    If (iDataSources > 0) Begin
81232>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81233>>>>>>>>>                        Decrement iDataSources
81234>>>>>>>>>                        for iCount from 0 to iDataSources
81240>>>>>>>>>>
81240>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81241>>>>>>>>>                        Loop
81242>>>>>>>>>>
81242>>>>>>>>>                        for iCount from 0 to iDataSources
81248>>>>>>>>>>
81248>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81249>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81250>>>>>>>>>                            If (bKeyOpened = True) Begin
81252>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81253>>>>>>>>>                                If (bExists = True) Begin
81255>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81256>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81257>>>>>>>>>                                    Increment iItem
81258>>>>>>>>>                                End
81258>>>>>>>>>>
81258>>>>>>>>>                            End
81258>>>>>>>>>>
81258>>>>>>>>>                        Loop
81259>>>>>>>>>>
81259>>>>>>>>>                    End
81259>>>>>>>>>>
81259>>>>>>>>>                    Send CloseKey of hoRegistry
81260>>>>>>>>>                    Send Destroy of hoODBCDataSources
81261>>>>>>>>>                End
81261>>>>>>>>>>
81261>>>>>>>>>            End
81261>>>>>>>>>>
81261>>>>>>>>>
81261>>>>>>>>>            Send Destroy of hoRegistry
81262>>>>>>>>>        End
81262>>>>>>>>>>
81262>>>>>>>>>
81262>>>>>>>>>        Function_Return sReturnArray
81263>>>>>>>>>    End_Function
81264>>>>>>>>>
81264>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81264>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81264>>>>>>>>>    // insert it for scriplets to come after the first one.
81264>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81266>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81266>>>>>>>>>        Integer iStart iEnd iDbType
81266>>>>>>>>>        Boolean bOK
81266>>>>>>>>>
81266>>>>>>>>>        Get piDbType to iDbType
81267>>>>>>>>>        Get psDriverID to sDriverID
81268>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81269>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81270>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81271>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81272>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81273>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81275>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81276>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81277>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81278>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81279>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81280>>>>>>>>>        End
81280>>>>>>>>>>
81280>>>>>>>>>        Else Begin
81281>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81282>>>>>>>>>
81282>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81282>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81284>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81285>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81286>>>>>>>>>            End
81286>>>>>>>>>>
81286>>>>>>>>>
81286>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81286>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81286>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81286>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81289>>>>>>>>>                // Make sure we only have one space between statements/words.
81289>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81290>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81291>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81292>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81293>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81294>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81296>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81297>>>>>>>>>                End
81297>>>>>>>>>>
81297>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81298>>>>>>>>>                // Remove data view as it already exists!
81298>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81299>>>>>>>>>            End
81299>>>>>>>>>>
81299>>>>>>>>>        End
81299>>>>>>>>>>
81299>>>>>>>>>
81299>>>>>>>>>        Function_Return sStmt
81300>>>>>>>>>    End_Function
81301>>>>>>>>>
81301>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81301>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81303>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81303>>>>>>>>>        Integer iRetval
81303>>>>>>>>>        Boolean bOK
81303>>>>>>>>>
81303>>>>>>>>>        Get psDriverID to sDriverID
81304>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81305>>>>>>>>>
81305>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81306>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81307>>>>>>>>>        Set psSQLStatementString to sSQLString
81308>>>>>>>>>
81308>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81308>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81308>>>>>>>>>        Move False to Err
81309>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81310>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81311>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81312>>>>>>>>>        Move 0 to LastErr
81313>>>>>>>>>
81313>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81313>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81314>>>>>>>>>        Send ResetFillSQLTables
81315>>>>>>>>>
81315>>>>>>>>>        Function_Return (Err = False)
81316>>>>>>>>>    End_Function
81317>>>>>>>>>
81317>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81317>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81319>>>>>>>>>        String sRetval
81319>>>>>>>>>        Integer iDbType iIndex
81319>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81319>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81320>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81320>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81320>>>>>>>>>
81320>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81320>>>>>>>>>        Move "" to sRetval
81321>>>>>>>>>        Get piDbType to iDbType
81322>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81323>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81324>>>>>>>>>
81324>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81325>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81326>>>>>>>>>        If (iIndex >= 0) Begin
81328>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81329>>>>>>>>>        End
81329>>>>>>>>>>
81329>>>>>>>>>
81329>>>>>>>>>        Function_Return sRetval
81330>>>>>>>>>    End_Function
81331>>>>>>>>>
81331>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81331>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81333>>>>>>>>>        String[] sSQLScriptArray
81334>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment sPrint
81334>>>>>>>>>        Integer iSize iCount
81334>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment bPrint
81334>>>>>>>>>
81334>>>>>>>>>        Move False to bCommentStart
81335>>>>>>>>>        Move False to bCommentEnd
81336>>>>>>>>>        Move False to bDashComment
81337>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81338>>>>>>>>>        Move "*/"  to sCommentEnd
81339>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81340>>>>>>>>>        Move "PRINT " to sPrint
81341>>>>>>>>>
81341>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81342>>>>>>>>>        Decrement iSize
81343>>>>>>>>>        Move "" to sText
81344>>>>>>>>>
81344>>>>>>>>>        for iCount from 0 to iSize
81350>>>>>>>>>>
81350>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81351>>>>>>>>>            Move (Trim(sLine)) to sTmp
81352>>>>>>>>>            If (sTmp <> "") Begin
81354>>>>>>>>>                Move False to bPrint
81355>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81356>>>>>>>>>                If (bCommentStart = False) Begin
81358>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81359>>>>>>>>>                    If (bCommentStart = False) Begin
81361>>>>>>>>>                        Move (Uppercase(Left(sTmp, 6)) = sPrint) to bPrint
81362>>>>>>>>>                    End
81362>>>>>>>>>>
81362>>>>>>>>>                End
81362>>>>>>>>>>
81362>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81363>>>>>>>>>                If (bCommentEnd = True) Begin
81365>>>>>>>>>                    Move False to bCommentStart
81366>>>>>>>>>                End
81366>>>>>>>>>>
81366>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False and bPrint = False) Begin
81368>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81369>>>>>>>>>                End
81369>>>>>>>>>>
81369>>>>>>>>>            End
81369>>>>>>>>>>
81369>>>>>>>>>        Loop
81370>>>>>>>>>>
81370>>>>>>>>>
81370>>>>>>>>>        // Update the retval struct array:
81370>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81371>>>>>>>>>        Function_Return SqlScriptArray
81372>>>>>>>>>    End_Function
81373>>>>>>>>>
81373>>>>>>>>>    // Helper function that builds a string like;
81373>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81373>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81375>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81375>>>>>>>>>
81375>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81376>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81377>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81378>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81379>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81380>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81381>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81382>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81383>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81384>>>>>>>>>        Function_Return sRetval
81385>>>>>>>>>    End_Function
81386>>>>>>>>>
81386>>>>>>>>>    // Helper function to create a SQL statement like;
81386>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81386>>>>>>>>>    // Used for checking if an index exists.
81386>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81388>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81388>>>>>>>>>
81388>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81389>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81390>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81391>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81392>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81393>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81394>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81395>>>>>>>>>
81395>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81396>>>>>>>>>
81396>>>>>>>>>        Function_Return sRetval
81397>>>>>>>>>    End_Function
81398>>>>>>>>>
81398>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81398>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81398>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81400>>>>>>>>>        String sRetval
81400>>>>>>>>>        If (iLength <> 0) Begin
81402>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81403>>>>>>>>>            If (iDecimals <> 0) Begin
81405>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81406>>>>>>>>>            End
81406>>>>>>>>>>
81406>>>>>>>>>            Move (sRetval + ")") to sRetval
81407>>>>>>>>>        End
81407>>>>>>>>>>
81407>>>>>>>>>        Function_Return sRetval
81408>>>>>>>>>    End_Function
81409>>>>>>>>>
81409>>>>>>>>>    // Checks that the passed sDriverID is defined.
81409>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81409>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81411>>>>>>>>>        Boolean bOK
81411>>>>>>>>>        Integer iDriver
81411>>>>>>>>>
81411>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81413>>>>>>>>>            Function_Return False
81414>>>>>>>>>        End
81414>>>>>>>>>>
81414>>>>>>>>>
81414>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81415>>>>>>>>>
81415>>>>>>>>>        If (bOK = False) Begin
81417>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81418>>>>>>>>>>
81418>>>>>>>>>            Function_Return False
81419>>>>>>>>>        End
81419>>>>>>>>>>
81419>>>>>>>>>
81419>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81420>>>>>>>>>        If (iDriver = 0) Begin
81422>>>>>>>>>            Load_Driver sDriverID
81423>>>>>>>>>        End
81423>>>>>>>>>>
81423>>>>>>>>>
81423>>>>>>>>>        Function_Return True
81424>>>>>>>>>    End_Function
81425>>>>>>>>>
81425>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81425>>>>>>>>>    // This is only of concern for certain SQL data types.
81425>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81427>>>>>>>>>        Integer iLength
81427>>>>>>>>>        Boolean bOK bCheckTypeLength
81427>>>>>>>>>
81427>>>>>>>>>        If (num_arguments > 1) Begin
81429>>>>>>>>>            Move iLen to iLength
81430>>>>>>>>>        End
81430>>>>>>>>>>
81430>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81431>>>>>>>>>
81431>>>>>>>>>        If (bCheckTypeLength = True) Begin
81433>>>>>>>>>            Move (iLength > 0) to bOK
81434>>>>>>>>>        End
81434>>>>>>>>>>
81434>>>>>>>>>
81434>>>>>>>>>        Function_Return (bOK = True)
81435>>>>>>>>>    End_Function
81436>>>>>>>>>
81436>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81438>>>>>>>>>        String sVal sSchema sDriverID
81438>>>>>>>>>        Integer iDbType
81438>>>>>>>>>
81438>>>>>>>>>        If (Trim(sTableName) = "") Begin
81440>>>>>>>>>            Function_Return ""
81441>>>>>>>>>        End
81441>>>>>>>>>>
81441>>>>>>>>>
81441>>>>>>>>>        Get psDriverID to sDriverID
81442>>>>>>>>>        Get piDbType   to iDbType
81443>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81445>>>>>>>>>            Get psUserID to sSchema
81446>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81446>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81447>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81448>>>>>>>>>            Function_Return sTableName
81449>>>>>>>>>        End
81449>>>>>>>>>>
81449>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81451>>>>>>>>>            Get psDatabase to sVal
81452>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81453>>>>>>>>>            Function_Return sTableName
81454>>>>>>>>>        End
81454>>>>>>>>>>
81454>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81456>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81457>>>>>>>>>            Function_Return sTableName
81458>>>>>>>>>        End
81458>>>>>>>>>>
81458>>>>>>>>>
81458>>>>>>>>>        Get psSchema to sSchema
81459>>>>>>>>>        If (sSchema = "") Begin
81461>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81462>>>>>>>>>        End
81462>>>>>>>>>>
81462>>>>>>>>>
81462>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81463>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81465>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81467>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81468>>>>>>>>>            End
81468>>>>>>>>>>
81468>>>>>>>>>            Else Begin
81469>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81470>>>>>>>>>            End
81470>>>>>>>>>>
81470>>>>>>>>>        End
81470>>>>>>>>>>
81470>>>>>>>>>
81470>>>>>>>>>        Function_Return sTableName
81471>>>>>>>>>    End_Function
81472>>>>>>>>>
81472>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81472>>>>>>>>>    // the passed sFieldName has the correct spelling.
81472>>>>>>>>>    // Used with Embedded SQL statement calls.
81472>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81472>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81474>>>>>>>>>        String sRetval sValue sDriverID
81474>>>>>>>>>        String[] asColumnNamesArray
81475>>>>>>>>>        Integer iIndex 
81475>>>>>>>>>
81475>>>>>>>>>        Move "" to sRetval
81476>>>>>>>>>        Get psDriverID to sDriverID
81477>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to asColumnNamesArray
81478>>>>>>>>>        Move (SearchArray(sTableName, asColumnNamesArray, Desktop, (RefFunc(DFSTRICMP)))) to iIndex
81479>>>>>>>>>        If (iIndex <> -1) Begin
81481>>>>>>>>>            Move asColumnNamesArray[iIndex] to sRetval
81482>>>>>>>>>        End
81482>>>>>>>>>>
81482>>>>>>>>>
81482>>>>>>>>>        Function_Return sRetval
81483>>>>>>>>>    End_Function
81484>>>>>>>>>
81484>>>>>>>>>    Function _SqlColumnNumberToColumnName String sTableName Integer iColumn Returns String
81486>>>>>>>>>        String sRetval sDriverID
81486>>>>>>>>>        String[] asColumnNamesArray
81487>>>>>>>>>
81487>>>>>>>>>        Move "" to sRetval
81488>>>>>>>>>        Get psDriverID to sDriverID
81489>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to asColumnNamesArray
81490>>>>>>>>>        If (iColumn > -1 and iColumn <= SizeOfArray(asColumnNamesArray)) Begin
81492>>>>>>>>>            Move asColumnNamesArray[iColumn] to sRetval
81493>>>>>>>>>        End
81493>>>>>>>>>>
81493>>>>>>>>>
81493>>>>>>>>>        Function_Return sRetval
81494>>>>>>>>>    End_Function
81495>>>>>>>>>
81495>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81497>>>>>>>>>        String[] sReturnArray
81498>>>>>>>>>        Handle hoSQLHandler
81498>>>>>>>>>        Integer iCount iSize iItem
81498>>>>>>>>>        String sServer
81498>>>>>>>>>        tSQLConnection SQLConnection
81498>>>>>>>>>        tSQLConnection SQLConnection
81498>>>>>>>>>
81498>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81499>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81500>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81501>>>>>>>>>
81501>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81502>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81503>>>>>>>>>        Decrement iSize
81504>>>>>>>>>
81504>>>>>>>>>        For iCount from 0 to iSize
81510>>>>>>>>>>
81510>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81511>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81512>>>>>>>>>            Increment iItem
81513>>>>>>>>>        Loop
81514>>>>>>>>>>
81514>>>>>>>>>
81514>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81515>>>>>>>>>
81515>>>>>>>>>        Function_Return sReturnArray
81516>>>>>>>>>    End_Function
81517>>>>>>>>>
81517>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81519>>>>>>>>>        String[] asSQLTables
81520>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81520>>>>>>>>>        Handle hoSQLHandler
81520>>>>>>>>>        Integer iCount iSize iItem iPos
81520>>>>>>>>>        Boolean bOK
81520>>>>>>>>>        tSQLConnection SQLConnection
81520>>>>>>>>>        tSQLConnection SQLConnection
81520>>>>>>>>>
81520>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81521>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81523>>>>>>>>>            Function_Return asSQLTables
81524>>>>>>>>>        End
81524>>>>>>>>>>
81524>>>>>>>>>
81524>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81525>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81526>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81527>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81528>>>>>>>>>
81528>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81529>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81530>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81531>>>>>>>>>
81531>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81532>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81533>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81533>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81533>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81533>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81533>>>>>>>>>//                If (iPos > 0) Begin
81533>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81533>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81533>>>>>>>>>//                End
81533>>>>>>>>>//            End
81533>>>>>>>>>//        End
81533>>>>>>>>>
81533>>>>>>>>>        Get pasSQLDataTables to asSQLTables
81534>>>>>>>>>        If (SizeOfArray(asSQLTables) <> 0) Begin
81536>>>>>>>>>            Function_Return asSQLTables
81537>>>>>>>>>        End
81537>>>>>>>>>>
81537>>>>>>>>>
81537>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81538>>>>>>>>>        Move False to Err
81539>>>>>>>>>        Move 0 to iItem
81540>>>>>>>>>
81540>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81540>>>>>>>>>        For iCount from 1 to iSize
81546>>>>>>>>>>
81546>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81547>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81548>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81549>>>>>>>>>            If (sSchema = "") Begin
81551>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81552>>>>>>>>>            End
81552>>>>>>>>>>
81552>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81553>>>>>>>>>            Move (Trim(sTable)) to sTable
81554>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81556>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81557>>>>>>>>>            End
81557>>>>>>>>>>
81557>>>>>>>>>            Else Begin
81558>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81559>>>>>>>>>            End
81559>>>>>>>>>>
81559>>>>>>>>>            If (bOK = True) Begin
81561>>>>>>>>>                Move sTable to asSQLTables[iItem]
81562>>>>>>>>>                Increment iItem
81563>>>>>>>>>            End
81563>>>>>>>>>>
81563>>>>>>>>>        Loop
81564>>>>>>>>>>
81564>>>>>>>>>
81564>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81565>>>>>>>>>
81565>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81566>>>>>>>>>        Function_Return asSQLTables
81567>>>>>>>>>    End_Function
81568>>>>>>>>>
81568>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81570>>>>>>>>>        String[] sReturnArray
81571>>>>>>>>>        String sValue
81571>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81571>>>>>>>>>        Integer iRetval iCols iFetchResult
81571>>>>>>>>>        tSQLConnection SQLConnection
81571>>>>>>>>>        tSQLConnection SQLConnection
81571>>>>>>>>>
81571>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81572>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81573>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81574>>>>>>>>>
81574>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81576>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81577>>>>>>>>>            If (hStmt <> 0) Begin
81579>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81580>>>>>>>>>                If (sArgument <> "") Begin
81582>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81583>>>>>>>>>                End
81583>>>>>>>>>>
81583>>>>>>>>>
81583>>>>>>>>>                Send SqlCall             of hStmt
81584>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81585>>>>>>>>>                If (iRetval = 0) Begin
81587>>>>>>>>>                    Repeat
81587>>>>>>>>>>
81587>>>>>>>>>                        Get SQLGetStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81588>>>>>>>>>                        If (iCols > 0) Begin
81590>>>>>>>>>                            Repeat
81590>>>>>>>>>>
81590>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81591>>>>>>>>>                                If (iFetchResult <> 0) Begin
81593>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81594>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81595>>>>>>>>>                                End
81595>>>>>>>>>>
81595>>>>>>>>>                            Until (iFetchResult = 0)
81597>>>>>>>>>                        End
81597>>>>>>>>>>
81597>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81598>>>>>>>>>                    Until (iRetval = 0)
81600>>>>>>>>>                    Send SqlClose of hStmt
81601>>>>>>>>>                End
81601>>>>>>>>>>
81601>>>>>>>>>            End
81601>>>>>>>>>>
81601>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81602>>>>>>>>>        End
81602>>>>>>>>>>
81602>>>>>>>>>        Function_Return sReturnArray
81603>>>>>>>>>    End_Function
81604>>>>>>>>>
81604>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81606>>>>>>>>>        String sOrgFormat sNewFormat sRootName sTableName sPhysicalFileName sDriverID sDataPath
81606>>>>>>>>>        Boolean bOpened bOK
81606>>>>>>>>>
81606>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81606>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81606>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81606>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81606>>>>>>>>>        // proper .int files for the two tables.
81606>>>>>>>>>//        If (Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST") Begin
81606>>>>>>>>>//            Function_Return True
81606>>>>>>>>>//        End
81606>>>>>>>>>
81606>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81609>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
81610>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81611>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81612>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81613>>>>>>>>>
81613>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81613>>>>>>>>>//        Sleep 1  
81613>>>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
81614>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81617>>>>>>>>>        If (bOpened = False) Begin
81619>>>>>>>>>            Open hTable
81621>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81624>>>>>>>>>        End
81624>>>>>>>>>>
81624>>>>>>>>>        If (bOpened = False) Begin
81626>>>>>>>>>            Function_Return False
81627>>>>>>>>>        End
81627>>>>>>>>>>
81627>>>>>>>>>
81627>>>>>>>>>        Get psDriverID to sDriverID
81628>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81631>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81632>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81632>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81632>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81633>>>>>>>>>        Move False to Err
81634>>>>>>>>>
81634>>>>>>>>>        If (hTable > 0) Begin
81636>>>>>>>>>            Structure_Start hTable
81637>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81640>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81643>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81645>>>>>>>>>        End
81645>>>>>>>>>>
81645>>>>>>>>>        Else Begin
81646>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81649>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81652>>>>>>>>>        End
81652>>>>>>>>>>
81652>>>>>>>>>        Function_Return (Err = False)
81653>>>>>>>>>    End_Function
81654>>>>>>>>>
81654>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81654>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81656>>>>>>>>>        Handle hTable
81656>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81656>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81656>>>>>>>>>
81656>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81657>>>>>>>>>        If (bSameTableNames = True) Begin
81659>>>>>>>>>            Function_Return True
81660>>>>>>>>>        End
81660>>>>>>>>>>
81660>>>>>>>>>
81660>>>>>>>>>        Move True to bOK
81661>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81662>>>>>>>>>        Set Private.phCurrentTable              to hTable
81663>>>>>>>>>        
81663>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81666>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81668>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81671>>>>>>>>>        End
81671>>>>>>>>>>
81671>>>>>>>>>        
81671>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81674>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81676>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81679>>>>>>>>>        End
81679>>>>>>>>>>
81679>>>>>>>>>        
81679>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81682>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81684>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81687>>>>>>>>>        End
81687>>>>>>>>>>
81687>>>>>>>>>
81687>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81689>>>>>>>>>            Get psConnectionID to sConnectionID
81690>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81691>>>>>>>>>            If (bTableExists = True) Begin
81693>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81694>>>>>>>>>            End
81694>>>>>>>>>>
81694>>>>>>>>>            Else Begin
81695>>>>>>>>>                Get pbToANSI to bANSI
81696>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False True to bOK
81697>>>>>>>>>            End
81697>>>>>>>>>>
81697>>>>>>>>>        End
81697>>>>>>>>>>
81697>>>>>>>>>
81697>>>>>>>>>        Function_Return bOK
81698>>>>>>>>>    End_Function
81699>>>>>>>>>
81699>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81699>>>>>>>>>    // It creates an .int file in the first Data folder of the psDataPath property. 
81699>>>>>>>>>    // It is important that the hTable can be opened.
81699>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Boolean bBackup Returns Boolean
81701>>>>>>>>>        Boolean bOK bExists bUseConnectionID bOpen 
81701>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sTableName sSchemaName sANSI_OEM 
81701>>>>>>>>>        String[] asIndexArray
81702>>>>>>>>>        Integer iCount iCh iSize iPos
81702>>>>>>>>>        Handle hTableOrg
81702>>>>>>>>>
81702>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81703>>>>>>>>>        Get psConnectionString to sConnectionString
81704>>>>>>>>>
81704>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81705>>>>>>>>>        If (bANSI = False) Begin
81707>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81708>>>>>>>>>        End
81708>>>>>>>>>>
81708>>>>>>>>>
81708>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81709>>>>>>>>>        Get vFolderExists sDataPath to bOK
81710>>>>>>>>>        If (bOK = False) Begin
81712>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81713>>>>>>>>>>
81713>>>>>>>>>            Function_Return False
81714>>>>>>>>>        End
81714>>>>>>>>>>
81714>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81715>>>>>>>>>
81715>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81718>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
81719>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81722>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81723>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81724>>>>>>>>>
81724>>>>>>>>>        Get psSchema hTable to sSchemaName
81725>>>>>>>>>        If (sSchemaName = "") Begin
81727>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81728>>>>>>>>>        End
81728>>>>>>>>>>
81728>>>>>>>>>        
81728>>>>>>>>>        If (bBackup = True) Begin
81730>>>>>>>>>            // If the .int file already exists; we rename it to "FileName" + ".bak"
81730>>>>>>>>>            Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81731>>>>>>>>>            If (bExists = True) Begin
81733>>>>>>>>>                Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81734>>>>>>>>>            End
81734>>>>>>>>>>
81734>>>>>>>>>        End 
81734>>>>>>>>>>
81734>>>>>>>>>        Else Begin
81735>>>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalFileName) to bOK
81736>>>>>>>>>        End
81736>>>>>>>>>>
81736>>>>>>>>>
81736>>>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
81737>>>>>>>>>        Get _SqlUtilEnumerateIndexes sTableName sDriverID to asIndexArray
81738>>>>>>>>>
81738>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81739>>>>>>>>>        If (iCh < 0) Begin 
81741>>>>>>>>>            Error DFERR_PROGRAM "No free channel for creating output file. (Routine: _SqlUtilCreateIntFile)"
81742>>>>>>>>>>
81742>>>>>>>>>            Function_Return False
81743>>>>>>>>>        End
81743>>>>>>>>>>
81743>>>>>>>>>        
81743>>>>>>>>>        Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81748>>>>>>>>>        If (bUseConnectionID = True) Begin
81750>>>>>>>>>            Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81757>>>>>>>>>        End
81757>>>>>>>>>>
81757>>>>>>>>>        Else Begin
81758>>>>>>>>>            Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81765>>>>>>>>>        End
81765>>>>>>>>>>
81765>>>>>>>>>        Writeln channel iCh CS_DATABASE_NAME          " " (Uppercase(sTableName))
81770>>>>>>>>>        Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName)) 
81775>>>>>>>>>        Writeln channel iCh ""
81778>>>>>>>>>        // There seems to be a new order how these are set from DF19.
81778>>>>>>>>>        If (bSysFile = True) Begin
81780>>>>>>>>>            Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81785>>>>>>>>>            Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81790>>>>>>>>>        End
81790>>>>>>>>>>
81790>>>>>>>>>        Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81795>>>>>>>>>        Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81800>>>>>>>>>
81800>>>>>>>>>        If (bSysFile = False) Begin
81802>>>>>>>>>            Move (SizeOfArray(asIndexArray)) to iSize
81803>>>>>>>>>            Move (SortArray(asIndexArray)) to asIndexArray
81804>>>>>>>>>            If (iSize > 0) Begin
81806>>>>>>>>>                Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81809>>>>>>>>>                Writeln channel iCh "" // Just an empty line
81812>>>>>>>>>            End
81812>>>>>>>>>>
81812>>>>>>>>>            Decrement iSize
81813>>>>>>>>>            for iCount from 0 to iSize
81819>>>>>>>>>>
81819>>>>>>>>>                Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81822>>>>>>>>>                Writeln channel iCh (CS_INDEX_NAME   * String(asIndexArray[iCount]))
81825>>>>>>>>>                Writeln channel iCh ""
81828>>>>>>>>>            Loop
81829>>>>>>>>>>
81829>>>>>>>>>        End
81829>>>>>>>>>>
81829>>>>>>>>>
81829>>>>>>>>>        Flush_Output channel iCh
81831>>>>>>>>>        Close_Output channel iCh
81833>>>>>>>>>        Send Seq_Close_Channel iCh 
81834>>>>>>>>>        
81834>>>>>>>>>        // There might be a bug in the MSSQLDRV driver, because if we create an .int file for a sysfile
81834>>>>>>>>>        // a Structure_Start/End *always* removes the line "RECNUM_TABLE NO", even if it shouldn't.
81834>>>>>>>>>        If (bSysFile = False) Begin
81836>>>>>>>>>            Open hTable
81838>>>>>>>>>            Move hTable to hTableOrg
81839>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
81842>>>>>>>>>            If (bOpen = True) Begin
81844>>>>>>>>>                Structure_Start hTable sDriverID
81845>>>>>>>>>                Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81847>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Table number:" * String(hTableOrg))
81848>>>>>>>>>            End
81848>>>>>>>>>>
81848>>>>>>>>>        End
81848>>>>>>>>>>
81848>>>>>>>>>
81848>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81848>>>>>>>>>//        Sleep 1
81848>>>>>>>>>
81848>>>>>>>>>        Function_Return (bOK = True)
81849>>>>>>>>>    End_Function 
81850>>>>>>>>>    
81850>>>>>>>>>    // Simplier version of the _SqlUtilCreateIntFile. It can be used if there might be something wrong with the .int file and it needs
81850>>>>>>>>>    // to be refreshed by the driver. 
81850>>>>>>>>>    Function _SqlUtilRefreshIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean        
81852>>>>>>>>>        String sOrgFormat sNewFormat
81852>>>>>>>>>        Boolean bErr
81852>>>>>>>>>        Integer iLastErr iErrLine
81852>>>>>>>>>        
81852>>>>>>>>>        Move Err to bErr
81853>>>>>>>>>        Move LastErr to iLastErr
81854>>>>>>>>>        Move ErrLine to iErrLine
81855>>>>>>>>>        Move False to Err
81856>>>>>>>>>        Open hTable
81858>>>>>>>>>        If (Err = True) Begin 
81860>>>>>>>>>            Error DFERR_PROGRAM ("The table:" * String(hTable) * "could not be opened")
81861>>>>>>>>>>
81861>>>>>>>>>            Move bErr to Err
81862>>>>>>>>>            Move iLastErr to LastErr
81863>>>>>>>>>            Move iErrLine to ErrLine
81864>>>>>>>>>            Function_Return False
81865>>>>>>>>>        End
81865>>>>>>>>>>
81865>>>>>>>>>        
81865>>>>>>>>>        Structure_Start hTable
81866>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler  
81868>>>>>>>>>
81868>>>>>>>>>        If (Err = True) Begin  
81870>>>>>>>>>            Error DFERR_PROGRAM ("The table:" * String(hTable) * "could not restructered properly. Error:" * String(LastErr))
81871>>>>>>>>>>
81871>>>>>>>>>            Move bErr to Err
81872>>>>>>>>>            Move iLastErr to LastErr
81873>>>>>>>>>            Move iErrLine to ErrLine
81874>>>>>>>>>            Function_Return False
81875>>>>>>>>>        End
81875>>>>>>>>>>
81875>>>>>>>>>        Function_Return True
81876>>>>>>>>>    End_Function
81877>>>>>>>>>
81877>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81879>>>>>>>>>        String sDataPath sDriverID
81879>>>>>>>>>        Boolean bOK
81879>>>>>>>>>        Integer iPos
81879>>>>>>>>>
81879>>>>>>>>>        If (sTableName contains ".") Begin
81881>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81882>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
81883>>>>>>>>>        End
81883>>>>>>>>>>
81883>>>>>>>>>
81883>>>>>>>>>        Get psDriverID to sDriverID
81884>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81885>>>>>>>>>        // First delete the cache file:
81885>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81886>>>>>>>>>
81886>>>>>>>>>        Function_Return bOK
81887>>>>>>>>>    End_Function
81888>>>>>>>>>
81888>>>>>>>>>    // Collects all tables from the SQL Database backend and sets the pasSQLTables property.
81888>>>>>>>>>    Procedure UtilFillSQLTables
81890>>>>>>>>>        String[] asSQLTables
81891>>>>>>>>>        String sDataBase
81891>>>>>>>>>        Integer iSize iCount
81891>>>>>>>>>
81891>>>>>>>>>        Get psDatabase to sDataBase
81892>>>>>>>>>        If (sDataBase = "") Begin
81894>>>>>>>>>            Set pasSQLDataTables to asSQLTables
81895>>>>>>>>>            Procedure_Return
81896>>>>>>>>>        End
81896>>>>>>>>>>
81896>>>>>>>>>        Get _SqlUtilEnumerateTables MSSQLDRV_ID sDataBase "" to asSQLTables
81897>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81898>>>>>>>>>    End_Procedure  
81899>>>>>>>>>    
81899>>>>>>>>>    Procedure ResetFillSQLTables
81901>>>>>>>>>        String[] asSQLTables
81902>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81903>>>>>>>>>    End_Procedure
81904>>>>>>>>>    
81904>>>>>>>>>    // This collects *all* filelist entries and sets the pFileListArray struct property.
81904>>>>>>>>>    Procedure UtilFillFileListStruct
81906>>>>>>>>>        tFilelist[] Tables
81906>>>>>>>>>        tFilelist[] Tables
81907>>>>>>>>>        String sRootName sLogicalName sDisplayName sDriver sNoDriverRootname
81907>>>>>>>>>        Handle hTable
81907>>>>>>>>>        Integer iItem iCount iLastErr iErrLine
81907>>>>>>>>>        Boolean bIsSystem bIsAlias bOpened bErr
81907>>>>>>>>>        
81907>>>>>>>>>        Move 0 to iItem
81908>>>>>>>>>        Move 0 to hTable 
81909>>>>>>>>>        Move Err to bErr
81910>>>>>>>>>        Move LastErr to iLastErr
81911>>>>>>>>>        Move ErrLine to iErrLine
81912>>>>>>>>>        Repeat
81912>>>>>>>>>>
81912>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81915>>>>>>>>>            // 0 = no more table in Filelist.cfg, 50 = Flexerrs.
81915>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin  
81917>>>>>>>>>                Move False to Err
81918>>>>>>>>>                Move False to bIsSystem
81919>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81922>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81925>>>>>>>>>                Get _DriverIDFromRootName sRootName to sDriver
81926>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Reading table" * String(hTable) * "LogicalName =" * sLogicalName)
81927>>>>>>>>>                Send DoAdvance of ghoProgressBar
81928>>>>>>>>>//                Send Ignore_All of Error_Object_Id
81928>>>>>>>>>                Move False to bIsSystem
81929>>>>>>>>>                Open hTable
81931>>>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpened
81934>>>>>>>>>                If (bOpened = True) Begin
81936>>>>>>>>>                    Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
81939>>>>>>>>>                End
81939>>>>>>>>>>
81939>>>>>>>>>//                Send Trap_All of Error_Object_Id
81939>>>>>>>>>                Close hTable
81940>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81943>>>>>>>>>                Get _TableNameOnly sRootName to sNoDriverRootname
81944>>>>>>>>>                Move hTable              to Tables[iItem].hTable
81945>>>>>>>>>                Move sRootName           to Tables[iItem].sRootName
81946>>>>>>>>>                Move sLogicalName        to Tables[iItem].sLogicalName
81947>>>>>>>>>                Move sDisplayName        to Tables[iItem].sDisplayName
81948>>>>>>>>>                Move sNoDriverRootname   to Tables[iItem].sNoDriverRootname
81949>>>>>>>>>                Move sDriver             to Tables[iItem].sDriver 
81950>>>>>>>>>                Move bIsSystem           to Tables[iItem].bIsSystemFile
81951>>>>>>>>>                Move (bOpened = False)   to Tables[iItem].bErrorOpening
81952>>>>>>>>>                Get _IsAliasTable hTable to Tables[iItem].bIsAlias 
81953>>>>>>>>>                Move False to Err
81954>>>>>>>>>                Increment iItem
81955>>>>>>>>>            End
81955>>>>>>>>>>
81955>>>>>>>>>        Until (hTable = 0)
81957>>>>>>>>>        
81957>>>>>>>>>        Move bErr to Err
81958>>>>>>>>>        Move iLastErr to LastErr
81959>>>>>>>>>        Move iErrLine to ErrLine
81960>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81961>>>>>>>>>        Set pFileListArray to Tables
81962>>>>>>>>>    End_Procedure   
81963>>>>>>>>>    
81963>>>>>>>>>    // Special array search function for the tFilelistLogicalName struct.
81963>>>>>>>>>    // Used by e.g. UtilAliasToMasterTableHandle
81963>>>>>>>>>    Function CompareFileListTable tFilelistLogicalName FileListTable1 tFilelistLogicalName FileListTable2 Returns Integer
81965>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) < Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (LT)
81968>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) > Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (GT)
81971>>>>>>>>>
81971>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) < Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (LT)
81974>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) > Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (GT)
81977>>>>>>>>>            
81977>>>>>>>>>        Function_Return (EQ)
81978>>>>>>>>>    End_Function
81979>>>>>>>>>
81979>>>>>>>>>    // Finds the corresponding Master table for the passed Alias handle
81979>>>>>>>>>    Function UtilAliasToMasterTableHandle Handle hTable Returns Handle
81981>>>>>>>>>        Handle hMasterTable
81981>>>>>>>>>        String sDriver sRootNameAlias sNoDriverRootnameAlias
81981>>>>>>>>>        Boolean bIsAlias bFound bIsIntTable
81981>>>>>>>>>        Integer iSize iCount iItem 
81981>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81981>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81982>>>>>>>>>        tFilelistLogicalName FileListTable
81982>>>>>>>>>        tFilelistLogicalName FileListTable
81982>>>>>>>>>        
81982>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
81983>>>>>>>>>        If (bIsAlias = False) Begin
81985>>>>>>>>>            Function_Return 0
81986>>>>>>>>>        End
81986>>>>>>>>>>
81986>>>>>>>>>        
81986>>>>>>>>>        Move 0 to hMasterTable
81987>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameAlias 
81990>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
81991>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
81992>>>>>>>>>        Get pFilelistLogicalTables  to FilelistLogicalTables
81993>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sLogicalName
81994>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sNoDriverRootname
81995>>>>>>>>>        Move (SearchArray(FileListTable, FilelistLogicalTables, Self, (RefFunc(CompareFileListTable)))) to iItem
81996>>>>>>>>>        If (iItem = -1) Begin
81998>>>>>>>>>            Function_Return 0
81999>>>>>>>>>        End
81999>>>>>>>>>>
81999>>>>>>>>>        Move (Lowercase(sNoDriverRootnameAlias) = Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) and Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) = Lowercase(FilelistLogicalTables[iItem].sLogicalName)) to bFound
82000>>>>>>>>>        If (bFound = True) Begin
82002>>>>>>>>>            Move FilelistLogicalTables[iItem].hTable to hMasterTable
82003>>>>>>>>>            Function_Return hMasterTable
82004>>>>>>>>>        End
82004>>>>>>>>>>
82004>>>>>>>>>        
82004>>>>>>>>>        Function_Return hMasterTable
82005>>>>>>>>>    End_Function
82006>>>>>>>>>     
82006>>>>>>>>>    Function pFilelistLogicalTables Returns tFilelistLogicalName
82008>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
82008>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
82009>>>>>>>>>        tFilelist[] FileListTables
82009>>>>>>>>>        tFilelist[] FileListTables
82010>>>>>>>>>        Integer iSize iCount
82010>>>>>>>>>        
82010>>>>>>>>>        Get pFileListArray to FileListTables
82011>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
82012>>>>>>>>>        Decrement iSize
82013>>>>>>>>>        for iCount from 0 to iSize
82019>>>>>>>>>>
82019>>>>>>>>>            Move FileListTables[iCount].bErrorOpening       to FilelistLogicalTables[iCount].bErrorOpening    
82020>>>>>>>>>            Move FileListTables[iCount].bIsAlias            to FilelistLogicalTables[iCount].bIsAlias
82021>>>>>>>>>            Move FileListTables[iCount].bIsSystemFile       to FilelistLogicalTables[iCount].bIsSystemFile
82022>>>>>>>>>            Move FileListTables[iCount].hTable              to FilelistLogicalTables[iCount].hTable
82023>>>>>>>>>            Move FileListTables[iCount].sDisplayName        to FilelistLogicalTables[iCount].sDisplayName
82024>>>>>>>>>            Move FileListTables[iCount].sDriver             to FilelistLogicalTables[iCount].sDriver
82025>>>>>>>>>            Move FileListTables[iCount].sLogicalName        to FilelistLogicalTables[iCount].sLogicalName
82026>>>>>>>>>            Move FileListTables[iCount].sNoDriverRootname   to FilelistLogicalTables[iCount].sNoDriverRootname
82027>>>>>>>>>            Move FileListTables[iCount].sRootName           to FilelistLogicalTables[iCount].sRootName
82028>>>>>>>>>        Loop
82029>>>>>>>>>>
82029>>>>>>>>>        Move (SortArray(FilelistLogicalTables)) to FilelistLogicalTables
82030>>>>>>>>>        Function_Return FilelistLogicalTables
82031>>>>>>>>>    End_Function 
82032>>>>>>>>>    
82032>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
82032>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
82032>>>>>>>>>    // if it is an SQL table
82032>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
82034>>>>>>>>>        Boolean bExists bIsSQLTable
82034>>>>>>>>>        String sDataPath sRootName
82034>>>>>>>>>
82034>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
82035>>>>>>>>>        If (bExists = False) Begin
82037>>>>>>>>>            Function_Return False
82038>>>>>>>>>        End
82038>>>>>>>>>>
82038>>>>>>>>>
82038>>>>>>>>>        Move False to bIsSQLTable
82039>>>>>>>>>        If (hTable > 0) Begin
82041>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
82044>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
82045>>>>>>>>>        End
82045>>>>>>>>>>
82045>>>>>>>>>        If (bIsSQLTable = True) Begin
82047>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
82048>>>>>>>>>            Function_Return bExists
82049>>>>>>>>>        End
82049>>>>>>>>>>
82049>>>>>>>>>        Else Begin
82050>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
82051>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
82052>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
82053>>>>>>>>>        End
82053>>>>>>>>>>
82053>>>>>>>>>
82053>>>>>>>>>        Function_Return bExists
82054>>>>>>>>>    End_Function
82055>>>>>>>>>
82055>>>>>>>>>    // Note: This variant uses the pasSQLDataTables property!
82055>>>>>>>>>    //       Thus, that property needs to have been initialized before
82055>>>>>>>>>    //       calling.
82055>>>>>>>>>    // It checks that the SQL table exists on the SQL end, *or*
82055>>>>>>>>>    // if embedded database, that the .dat file exists on disk.
82055>>>>>>>>>    Function _UtilTableExists_Ex Handle hTable Returns Boolean
82057>>>>>>>>>        Boolean bExists bIsSQLTable
82057>>>>>>>>>        String sDataPath sRootName
82057>>>>>>>>>
82057>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
82058>>>>>>>>>        If (bExists = False) Begin
82060>>>>>>>>>            Function_Return False
82061>>>>>>>>>        End
82061>>>>>>>>>>
82061>>>>>>>>>
82061>>>>>>>>>        Move False to bIsSQLTable
82062>>>>>>>>>        If (hTable > 0) Begin
82064>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
82067>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
82068>>>>>>>>>        End
82068>>>>>>>>>>
82068>>>>>>>>>        If (bIsSQLTable = True) Begin
82070>>>>>>>>>            Get _UtilTableIsSql_Ex hTable to bExists
82071>>>>>>>>>            Function_Return bExists
82072>>>>>>>>>        End
82072>>>>>>>>>>
82072>>>>>>>>>        Else Begin
82073>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
82074>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
82075>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
82076>>>>>>>>>        End
82076>>>>>>>>>>
82076>>>>>>>>>
82076>>>>>>>>>        Function_Return bExists
82077>>>>>>>>>    End_Function
82078>>>>>>>>>
82078>>>>>>>>>    // Pass a table handle
82078>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
82078>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
82080>>>>>>>>>        Handle hTable
82080>>>>>>>>>        Boolean bFound
82080>>>>>>>>>
82080>>>>>>>>>        Move False to bFound
82081>>>>>>>>>        Move 0 to hTable
82082>>>>>>>>>        Repeat
82082>>>>>>>>>>
82082>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
82085>>>>>>>>>            If (hTable > 0) Begin
82087>>>>>>>>>                If (hTable = hCheckTable) Begin
82089>>>>>>>>>                    Move True to bFound
82090>>>>>>>>>                End
82090>>>>>>>>>>
82090>>>>>>>>>            End
82090>>>>>>>>>>
82090>>>>>>>>>            If (bFound = True) ;                Break
82093>>>>>>>>>        Until (hTable = 0)
82095>>>>>>>>>
82095>>>>>>>>>        Function_Return bFound
82096>>>>>>>>>    End_Function
82097>>>>>>>>>
82097>>>>>>>>>    // Returns number of tables in filelist.cfg.
82097>>>>>>>>>    Function _UtilNumberOfFileListTables Returns Boolean
82099>>>>>>>>>        Handle hTable
82099>>>>>>>>>        Integer iCount
82099>>>>>>>>>
82099>>>>>>>>>        Move 0 to iCount
82100>>>>>>>>>        Move 0 to hTable
82101>>>>>>>>>        Repeat
82101>>>>>>>>>>
82101>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
82104>>>>>>>>>            If (hTable > 0) Begin
82106>>>>>>>>>                Increment iCount
82107>>>>>>>>>            End
82107>>>>>>>>>>
82107>>>>>>>>>        Until (hTable = 0)
82109>>>>>>>>>
82109>>>>>>>>>        Function_Return iCount
82110>>>>>>>>>    End_Function
82111>>>>>>>>>
82111>>>>>>>>>    // DataFlex Embedded Database Data Types:
82111>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82111>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
82113>>>>>>>>>        tColumnType[] ColumnType
82113>>>>>>>>>        tColumnType[] ColumnType
82114>>>>>>>>>        Integer i
82114>>>>>>>>>
82114>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
82115>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
82116>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
82117>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
82118>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
82119>>>>>>>>>        Increment i
82120>>>>>>>>>
82120>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
82121>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
82122>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
82123>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
82124>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
82125>>>>>>>>>        Increment i
82126>>>>>>>>>
82126>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
82127>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
82128>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
82129>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
82130>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
82131>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82132>>>>>>>>>        Increment i
82133>>>>>>>>>
82133>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
82134>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
82135>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
82136>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
82137>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82138>>>>>>>>>        Increment i
82139>>>>>>>>>
82139>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
82140>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
82141>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
82142>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
82143>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82144>>>>>>>>>        Increment i
82145>>>>>>>>>
82145>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
82146>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
82147>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82148>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
82149>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
82150>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82151>>>>>>>>>        Increment i
82152>>>>>>>>>
82152>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
82153>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
82154>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
82155>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
82157>>>>>>>>>
82157>>>>>>>>>        Function_Return ColumnType
82158>>>>>>>>>    End_Function
82159>>>>>>>>>
82159>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
82161>>>>>>>>>        tColumnType[] aColumnType
82161>>>>>>>>>        tColumnType[] aColumnType
82162>>>>>>>>>        Integer i
82162>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
82162>>>>>>>>>>// Generated By The Database Update Framework
82162>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\DB2_DRV_DriverDef.xml
82162>>>>>>>>>>// Driver COLUMN DATA TYPES
82162>>>>>>>>>>//
82162>>>>>>>>>>// Created: 2024-10-15 10:49:58,567
82162>>>>>>>>>>
82162>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82163>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82164>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82165>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82166>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82167>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82168>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82169>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82170>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82171>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82172>>>>>>>>>>            Increment i
82173>>>>>>>>>>
82173>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82174>>>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
82175>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82176>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82177>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82178>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82179>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82180>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82181>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82182>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82183>>>>>>>>>>            Increment i
82184>>>>>>>>>>
82184>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82185>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82186>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82187>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82188>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82189>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82190>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82191>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82192>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82193>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82194>>>>>>>>>>            Increment i
82195>>>>>>>>>>
82195>>>>>>>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
82196>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82197>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82198>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82199>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82200>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82201>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82202>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82203>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82204>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82205>>>>>>>>>>            Increment i
82206>>>>>>>>>>
82206>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82207>>>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
82208>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82209>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82210>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82211>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82212>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82213>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82214>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82215>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82216>>>>>>>>>>            Increment i
82217>>>>>>>>>>
82217>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82218>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82219>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82220>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82221>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82222>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82223>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82224>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82225>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82226>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82227>>>>>>>>>>            Increment i
82228>>>>>>>>>>
82228>>>>>>>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
82229>>>>>>>>>>            Move -350                                    to aColumnType[i].iSQLType
82230>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82231>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82232>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82233>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82234>>>>>>>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
82235>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82236>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82237>>>>>>>>>>            Move 1073741823                              to aColumnType[i].sPrecision
82238>>>>>>>>>>            Increment i
82239>>>>>>>>>>
82239>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82240>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82241>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82242>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82243>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82244>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82245>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82246>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82247>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82248>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82249>>>>>>>>>>            Increment i
82250>>>>>>>>>>
82250>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82251>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82252>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82253>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82254>>>>>>>>>>            Move 192898100                               to aColumnType[i].iDefaultSize
82255>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82256>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82257>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82258>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82259>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82260>>>>>>>>>>            Increment i
82261>>>>>>>>>>
82261>>>>>>>>>>            Move "graphic"                               to aColumnType[i].sSQLType
82262>>>>>>>>>>            Move -95                                     to aColumnType[i].iSQLType
82263>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82264>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82265>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82266>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82267>>>>>>>>>>            Move 127                                     to aColumnType[i].nMaxSize
82268>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82269>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82270>>>>>>>>>>            Move 127                                     to aColumnType[i].sPrecision
82271>>>>>>>>>>            Increment i
82272>>>>>>>>>>
82272>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82273>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82274>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82275>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82276>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82277>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82278>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82279>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82280>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82281>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82282>>>>>>>>>>            Increment i
82283>>>>>>>>>>
82283>>>>>>>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
82284>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82285>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82286>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82287>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82288>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82289>>>>>>>>>>            Move 32000                                   to aColumnType[i].nMaxSize
82290>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82291>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82292>>>>>>>>>>            Move 32000                                   to aColumnType[i].sPrecision
82293>>>>>>>>>>            Increment i
82294>>>>>>>>>>
82294>>>>>>>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
82295>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82296>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82297>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82298>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82299>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82300>>>>>>>>>>            Move 32700                                   to aColumnType[i].nMaxSize
82301>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82302>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82303>>>>>>>>>>            Move 32700                                   to aColumnType[i].sPrecision
82304>>>>>>>>>>            Increment i
82305>>>>>>>>>>
82305>>>>>>>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
82306>>>>>>>>>>            Move -97                                     to aColumnType[i].iSQLType
82307>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82308>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82309>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82310>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82311>>>>>>>>>>            Move 16350                                   to aColumnType[i].nMaxSize
82312>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82313>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82314>>>>>>>>>>            Move 16350                                   to aColumnType[i].sPrecision
82315>>>>>>>>>>            Increment i
82316>>>>>>>>>>
82316>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82317>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82318>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82319>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82320>>>>>>>>>>            Move 192897884                               to aColumnType[i].iDefaultSize
82321>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82322>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82323>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82324>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82325>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82326>>>>>>>>>>            Increment i
82327>>>>>>>>>>
82327>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82328>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82329>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82330>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82331>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82332>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82333>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82334>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82335>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82336>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82337>>>>>>>>>>            Increment i
82338>>>>>>>>>>
82338>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82339>>>>>>>>>>            Move 92                                      to aColumnType[i].iSQLType
82340>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82341>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82342>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82343>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82344>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82345>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82346>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82347>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82348>>>>>>>>>>            Increment i
82349>>>>>>>>>>
82349>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82350>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82351>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82352>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82353>>>>>>>>>>            Move 192898868                               to aColumnType[i].iDefaultSize
82354>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82355>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82356>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82357>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82358>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82359>>>>>>>>>>            Increment i
82360>>>>>>>>>>
82360>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82361>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82362>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82363>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82364>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82365>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82366>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82367>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82368>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82369>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82370>>>>>>>>>>            Increment i
82371>>>>>>>>>>
82371>>>>>>>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
82372>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82373>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82374>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82375>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82376>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82377>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82378>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82379>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82380>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82381>>>>>>>>>>            Increment i
82382>>>>>>>>>>
82382>>>>>>>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
82383>>>>>>>>>>            Move -96                                     to aColumnType[i].iSQLType
82384>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82385>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82386>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82387>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82388>>>>>>>>>>            Move 16336                                   to aColumnType[i].nMaxSize
82389>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82390>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82391>>>>>>>>>>            Move 16336                                   to aColumnType[i].sPrecision
82392>>>>>>>>>>            Increment i
82393>>>>>>>>>>
82393>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82394>>>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
82395>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82396>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82397>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82398>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82399>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82400>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82401>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82402>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82403>>>>>>>>>>            Increment i
82404>>>>>>>>>>
82404>>>>>>>>>>
82404>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82404>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82404>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82404>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82404>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82404>>>>>>>>>//        Increment i
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>//
82404>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82404>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82404>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82404>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82404>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82404>>>>>>>>>
82404>>>>>>>>>        Function_Return aColumnType
82405>>>>>>>>>    End_Function
82406>>>>>>>>>
82406>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82406>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82406>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82408>>>>>>>>>        tColumnType[] aColumnType
82408>>>>>>>>>        tColumnType[] aColumnType
82409>>>>>>>>>        Integer i
82409>>>>>>>>>
82409>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82411>>>>>>>>>>// Generated By The Database Update Framework
82411>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\MSSQLDRV_DriverDef.xml
82411>>>>>>>>>>// Driver COLUMN DATA TYPES
82411>>>>>>>>>>//
82411>>>>>>>>>>// Created: 2024-10-15 10:49:25,717
82411>>>>>>>>>>
82411>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82412>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82413>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82414>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82415>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82416>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82417>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82418>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82419>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82420>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82421>>>>>>>>>>            Increment i
82422>>>>>>>>>>
82422>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82423>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82424>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82425>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82426>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82427>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82428>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82429>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82430>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82431>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82432>>>>>>>>>>            Increment i
82433>>>>>>>>>>
82433>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82434>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82435>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82436>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82437>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82438>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82439>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82440>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82441>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82442>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82443>>>>>>>>>>            Increment i
82444>>>>>>>>>>
82444>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82445>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82446>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82447>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82448>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82449>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82450>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82451>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82452>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82453>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82454>>>>>>>>>>            Increment i
82455>>>>>>>>>>
82455>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82456>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82457>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82458>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82459>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82460>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82461>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82462>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82463>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82464>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82465>>>>>>>>>>            Increment i
82466>>>>>>>>>>
82466>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82467>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82468>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82469>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82470>>>>>>>>>>            Move 115808772                               to aColumnType[i].iDefaultSize
82471>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82472>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82473>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82474>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82475>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82476>>>>>>>>>>            Increment i
82477>>>>>>>>>>
82477>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82478>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82479>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82480>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82481>>>>>>>>>>            Move 115808868                               to aColumnType[i].iDefaultSize
82482>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82483>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82484>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82485>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82486>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82487>>>>>>>>>>            Increment i
82488>>>>>>>>>>
82488>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82489>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82490>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82491>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82492>>>>>>>>>>            Move 115808964                               to aColumnType[i].iDefaultSize
82493>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82494>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82495>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82496>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82497>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82498>>>>>>>>>>            Increment i
82499>>>>>>>>>>
82499>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82500>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82501>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82502>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82503>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82504>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82505>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82506>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82507>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82508>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82509>>>>>>>>>>            Increment i
82510>>>>>>>>>>
82510>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82511>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82512>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82513>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82514>>>>>>>>>>            Move 115808508                               to aColumnType[i].iDefaultSize
82515>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82516>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82517>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82518>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82519>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82520>>>>>>>>>>            Increment i
82521>>>>>>>>>>
82521>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82522>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82523>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82524>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82525>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82526>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82527>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82528>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82529>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82530>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82531>>>>>>>>>>            Increment i
82532>>>>>>>>>>
82532>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82533>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82534>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82535>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82536>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82537>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82538>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82539>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82540>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82541>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82542>>>>>>>>>>            Increment i
82543>>>>>>>>>>
82543>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82544>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82545>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82546>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82547>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82548>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82549>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82550>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82551>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82552>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82553>>>>>>>>>>            Increment i
82554>>>>>>>>>>
82554>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82555>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82556>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82557>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82558>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82559>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82560>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82561>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82562>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82563>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82564>>>>>>>>>>            Increment i
82565>>>>>>>>>>
82565>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82566>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82567>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82568>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82569>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82570>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82571>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82572>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82573>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82574>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82575>>>>>>>>>>            Increment i
82576>>>>>>>>>>
82576>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82577>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82578>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82579>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82580>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82581>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82582>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82583>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82584>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82585>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82586>>>>>>>>>>            Increment i
82587>>>>>>>>>>
82587>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82588>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82589>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82590>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82591>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82592>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82593>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82594>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82595>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82596>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82597>>>>>>>>>>            Increment i
82598>>>>>>>>>>
82598>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82599>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82600>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82601>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82602>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82603>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82604>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82605>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82606>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82607>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82608>>>>>>>>>>            Increment i
82609>>>>>>>>>>
82609>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82610>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82611>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82612>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82613>>>>>>>>>>            Move 115809924                               to aColumnType[i].iDefaultSize
82614>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82615>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82616>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82617>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82618>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82619>>>>>>>>>>            Increment i
82620>>>>>>>>>>
82620>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82621>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82622>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82623>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82624>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82625>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82626>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82627>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82628>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82629>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82630>>>>>>>>>>            Increment i
82631>>>>>>>>>>
82631>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82632>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82633>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82634>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82635>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82636>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82637>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82638>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82639>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82640>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82641>>>>>>>>>>            Increment i
82642>>>>>>>>>>
82642>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82643>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82644>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82645>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82646>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82647>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82648>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82649>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82650>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82651>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82652>>>>>>>>>>            Increment i
82653>>>>>>>>>>
82653>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82654>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82655>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82656>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82657>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82658>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82659>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82660>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82661>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82662>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82663>>>>>>>>>>            Increment i
82664>>>>>>>>>>
82664>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82665>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82666>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82667>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82668>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82669>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82670>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82671>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82672>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82673>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82674>>>>>>>>>>            Increment i
82675>>>>>>>>>>
82675>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82676>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82677>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82678>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82679>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82680>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82681>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82682>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82683>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82684>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82685>>>>>>>>>>            Increment i
82686>>>>>>>>>>
82686>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82687>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82688>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82689>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82690>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82691>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82692>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82693>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82694>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82695>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82696>>>>>>>>>>            Increment i
82697>>>>>>>>>>
82697>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82698>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82699>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82700>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82701>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82702>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82703>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82704>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82705>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82706>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82707>>>>>>>>>>            Increment i
82708>>>>>>>>>>
82708>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82709>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82710>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82711>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82712>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82713>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82714>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82715>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82716>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82717>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82718>>>>>>>>>>            Increment i
82719>>>>>>>>>>
82719>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82720>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82721>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82722>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82723>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82724>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82725>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82726>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82727>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82728>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82729>>>>>>>>>>            Increment i
82730>>>>>>>>>>
82730>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82731>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82732>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82734>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82735>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82736>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82737>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82738>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82739>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82740>>>>>>>>>>            Increment i
82741>>>>>>>>>>
82741>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82742>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82743>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82744>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82745>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82746>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82747>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82748>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82749>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82750>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82751>>>>>>>>>>            Increment i
82752>>>>>>>>>>
82752>>>>>>>>>>
82752>>>>>>>>>
82752>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>//
82752>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82752>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82752>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82752>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82752>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82752>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82752>>>>>>>>>//            Increment i
82752>>>>>>>>>
82752>>>>>>>>>        End
82752>>>>>>>>>>
82752>>>>>>>>>
82752>>>>>>>>>        Function_Return aColumnType
82753>>>>>>>>>    End_Function
82754>>>>>>>>>
82754>>>>>>>>>    // MySQL Data Types
82754>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82756>>>>>>>>>        tColumnType[] aColumnType
82756>>>>>>>>>        tColumnType[] aColumnType
82757>>>>>>>>>        Integer i
82757>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82757>>>>>>>>>>// Generated By The Database Update Framework
82757>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82757>>>>>>>>>>// Driver COLUMN DATA TYPES
82757>>>>>>>>>>//
82757>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82757>>>>>>>>>>
82757>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82758>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82759>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82760>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82761>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82762>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82763>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82764>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82765>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82766>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82767>>>>>>>>>>            Increment i
82768>>>>>>>>>>
82768>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82769>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82770>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82771>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82772>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82773>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82774>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82775>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82776>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82777>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82778>>>>>>>>>>            Increment i
82779>>>>>>>>>>
82779>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82780>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82781>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82782>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82783>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82784>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82785>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82786>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82787>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82788>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82789>>>>>>>>>>            Increment i
82790>>>>>>>>>>
82790>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82791>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82792>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82793>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82794>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82795>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82796>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82797>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82798>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82799>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82800>>>>>>>>>>            Increment i
82801>>>>>>>>>>
82801>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82802>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82803>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82804>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82805>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82806>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82807>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82808>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82809>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82810>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82811>>>>>>>>>>            Increment i
82812>>>>>>>>>>
82812>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82813>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82814>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82815>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82816>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82817>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82818>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82819>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82820>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82821>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82822>>>>>>>>>>            Increment i
82823>>>>>>>>>>
82823>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82824>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82825>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82826>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82827>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82828>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82829>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82830>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82831>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82832>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82833>>>>>>>>>>            Increment i
82834>>>>>>>>>>
82834>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82835>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82836>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82837>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82838>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82839>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82840>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82841>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82842>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82843>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82844>>>>>>>>>>            Increment i
82845>>>>>>>>>>
82845>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82846>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82847>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82848>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82849>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82850>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82851>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82852>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82853>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82854>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82855>>>>>>>>>>            Increment i
82856>>>>>>>>>>
82856>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82857>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82858>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82859>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82860>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82861>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82862>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82863>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82864>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82865>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82866>>>>>>>>>>            Increment i
82867>>>>>>>>>>
82867>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82868>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82869>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82870>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82871>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82872>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82873>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82874>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82875>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82876>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82877>>>>>>>>>>            Increment i
82878>>>>>>>>>>
82878>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82879>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82880>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82881>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82882>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82883>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82884>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82885>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82886>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82887>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82888>>>>>>>>>>            Increment i
82889>>>>>>>>>>
82889>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82890>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82891>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82892>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82893>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82894>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82895>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82896>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82897>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82898>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82899>>>>>>>>>>            Increment i
82900>>>>>>>>>>
82900>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82901>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82902>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82903>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82904>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82905>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82906>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82907>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82908>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82909>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82910>>>>>>>>>>            Increment i
82911>>>>>>>>>>
82911>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82912>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82913>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82914>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82915>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82916>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82917>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82918>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82919>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82920>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82921>>>>>>>>>>            Increment i
82922>>>>>>>>>>
82922>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82923>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82924>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82925>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82926>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82927>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82928>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82929>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82930>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82931>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82932>>>>>>>>>>            Increment i
82933>>>>>>>>>>
82933>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82934>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82935>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82936>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82937>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82938>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82939>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82940>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82941>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82942>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82943>>>>>>>>>>            Increment i
82944>>>>>>>>>>
82944>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82945>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82946>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82947>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82948>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82949>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82950>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82951>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82952>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82953>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82954>>>>>>>>>>            Increment i
82955>>>>>>>>>>
82955>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82956>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82957>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82958>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82959>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82960>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82961>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82962>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82963>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82964>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82965>>>>>>>>>>            Increment i
82966>>>>>>>>>>
82966>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82967>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82968>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82969>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82970>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82971>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82972>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82973>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82974>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82975>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82976>>>>>>>>>>            Increment i
82977>>>>>>>>>>
82977>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82978>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82979>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82980>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82981>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82982>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82983>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82984>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82985>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82986>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82987>>>>>>>>>>            Increment i
82988>>>>>>>>>>
82988>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82989>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82990>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82991>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82992>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82993>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82994>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82995>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82996>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82997>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82998>>>>>>>>>>            Increment i
82999>>>>>>>>>>
82999>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
83000>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
83001>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83002>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83003>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
83004>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83005>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
83006>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83007>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83008>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
83009>>>>>>>>>>            Increment i
83010>>>>>>>>>>
83010>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
83011>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83012>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83013>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83014>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
83015>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83016>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
83017>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83018>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83019>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
83020>>>>>>>>>>            Increment i
83021>>>>>>>>>>
83021>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
83022>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
83023>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83024>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83025>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
83026>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83027>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
83028>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83029>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83030>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
83031>>>>>>>>>>            Increment i
83032>>>>>>>>>>
83032>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83033>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
83034>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83036>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
83037>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83038>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83039>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83040>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83041>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83042>>>>>>>>>>            Increment i
83043>>>>>>>>>>
83043>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
83044>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
83045>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83047>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
83048>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83049>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83050>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83051>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83052>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83053>>>>>>>>>>            Increment i
83054>>>>>>>>>>
83054>>>>>>>>>>
83054>>>>>>>>>
83054>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>//
83054>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
83054>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
83054>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83054>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
83054>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
83054>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83054>>>>>>>>>//        Increment i
83054>>>>>>>>>
83054>>>>>>>>>        Function_Return aColumnType
83055>>>>>>>>>    End_Function
83056>>>>>>>>>
83056>>>>>>>>>    // Oracle Data Types
83056>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
83058>>>>>>>>>        tColumnType[] aColumnType
83058>>>>>>>>>        tColumnType[] aColumnType
83059>>>>>>>>>        Integer i
83059>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
83059>>>>>>>>>>// Generated By The Database Update Framework
83059>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
83059>>>>>>>>>>// Driver COLUMN DATA TYPES
83059>>>>>>>>>>//
83059>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
83059>>>>>>>>>>
83059>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
83060>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
83061>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83062>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83063>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83064>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83065>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83066>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83067>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83068>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83069>>>>>>>>>>            Increment i
83070>>>>>>>>>>
83070>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83071>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
83072>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83073>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83074>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83075>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83076>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83077>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83078>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83079>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83080>>>>>>>>>>            Increment i
83081>>>>>>>>>>
83081>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
83082>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
83083>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83084>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83085>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83086>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83087>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83088>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83089>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83090>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83091>>>>>>>>>>            Increment i
83092>>>>>>>>>>
83092>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83093>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
83094>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83095>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83096>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83097>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
83098>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
83099>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83100>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83101>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83102>>>>>>>>>>            Increment i
83103>>>>>>>>>>
83103>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
83104>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
83105>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83106>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83107>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83108>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83109>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83110>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83111>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83112>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83113>>>>>>>>>>            Increment i
83114>>>>>>>>>>
83114>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
83115>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
83116>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83117>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83118>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83119>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83120>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83121>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83122>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83123>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83124>>>>>>>>>>            Increment i
83125>>>>>>>>>>
83125>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
83126>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
83127>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83128>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83129>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83130>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83131>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83132>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83133>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83134>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83135>>>>>>>>>>            Increment i
83136>>>>>>>>>>
83136>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83137>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83138>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83139>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83140>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83141>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83142>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83143>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83144>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83145>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83146>>>>>>>>>>            Increment i
83147>>>>>>>>>>
83147>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83148>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83149>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83150>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83151>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83152>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83153>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83154>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83155>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83156>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83157>>>>>>>>>>            Increment i
83158>>>>>>>>>>
83158>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83159>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83160>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83161>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83162>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83163>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83164>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83165>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83166>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83167>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83168>>>>>>>>>>            Increment i
83169>>>>>>>>>>
83169>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83170>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83171>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83172>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83173>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83174>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83175>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83176>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83177>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83178>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83179>>>>>>>>>>            Increment i
83180>>>>>>>>>>
83180>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83181>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83182>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83183>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83184>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83185>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83186>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83187>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83188>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83189>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83190>>>>>>>>>>            Increment i
83191>>>>>>>>>>
83191>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83192>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83193>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83194>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83195>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83196>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83197>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83198>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83199>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83200>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83201>>>>>>>>>>            Increment i
83202>>>>>>>>>>
83202>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83203>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83204>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83205>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83206>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83207>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83208>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83209>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83210>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83211>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83212>>>>>>>>>>            Increment i
83213>>>>>>>>>>
83213>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83214>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83215>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83216>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83217>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83218>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83219>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83220>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83221>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83222>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83223>>>>>>>>>>            Increment i
83224>>>>>>>>>>
83224>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83225>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83226>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83227>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83228>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83229>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83230>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83231>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83232>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83233>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83234>>>>>>>>>>            Increment i
83235>>>>>>>>>>
83235>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83236>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83237>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83238>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83239>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83240>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83241>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83242>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83243>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83244>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83245>>>>>>>>>>            Increment i
83246>>>>>>>>>>
83246>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83247>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83248>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83249>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83250>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83251>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83252>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83253>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83254>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83255>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83256>>>>>>>>>>            Increment i
83257>>>>>>>>>>
83257>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83258>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83259>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83260>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83261>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83262>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83263>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83264>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83265>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83266>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83267>>>>>>>>>>            Increment i
83268>>>>>>>>>>
83268>>>>>>>>>>
83268>>>>>>>>>
83268>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83268>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83268>>>>>>>>>//        Increment i
83268>>>>>>>>>//
83268>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83268>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83268>>>>>>>>>
83268>>>>>>>>>        Function_Return aColumnType
83269>>>>>>>>>    End_Function
83270>>>>>>>>>
83270>>>>>>>>>    // PostgreSQL Data Types
83270>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83272>>>>>>>>>        tColumnType[] aColumnType
83272>>>>>>>>>        tColumnType[] aColumnType
83273>>>>>>>>>        Integer i
83273>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83273>>>>>>>>>>// Generated By The Database Update Framework
83273>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83273>>>>>>>>>>// Driver COLUMN DATA TYPES
83273>>>>>>>>>>//
83273>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83273>>>>>>>>>>
83273>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83274>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83275>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83276>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83277>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83278>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83279>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83280>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83281>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83282>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83283>>>>>>>>>>            Increment i
83284>>>>>>>>>>
83284>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83285>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83286>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83287>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83288>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83289>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83290>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83291>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83292>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83293>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83294>>>>>>>>>>            Increment i
83295>>>>>>>>>>
83295>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83296>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83297>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83298>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83299>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83300>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83301>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83302>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83303>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83304>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83305>>>>>>>>>>            Increment i
83306>>>>>>>>>>
83306>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83307>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83308>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83309>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83310>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83311>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83312>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83313>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83314>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83315>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83316>>>>>>>>>>            Increment i
83317>>>>>>>>>>
83317>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83318>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83319>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83320>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83321>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83322>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83323>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83324>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83325>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83326>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83327>>>>>>>>>>            Increment i
83328>>>>>>>>>>
83328>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83329>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83330>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83331>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83332>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83333>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83334>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83335>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83336>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83337>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83338>>>>>>>>>>            Increment i
83339>>>>>>>>>>
83339>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83340>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83341>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83342>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83343>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83344>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83345>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83346>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83347>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83348>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83349>>>>>>>>>>            Increment i
83350>>>>>>>>>>
83350>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83351>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83352>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83353>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83354>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83355>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83356>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83357>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83358>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83359>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83360>>>>>>>>>>            Increment i
83361>>>>>>>>>>
83361>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83362>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83363>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83364>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83365>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83366>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83367>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83368>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83369>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83370>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83371>>>>>>>>>>            Increment i
83372>>>>>>>>>>
83372>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83373>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83374>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83375>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83376>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83377>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83378>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83379>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83380>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83381>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83382>>>>>>>>>>            Increment i
83383>>>>>>>>>>
83383>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83384>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83385>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83386>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83387>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83388>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83389>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83390>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83391>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83392>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83393>>>>>>>>>>            Increment i
83394>>>>>>>>>>
83394>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83395>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83396>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83397>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83398>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83399>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83400>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83401>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83402>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83403>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83404>>>>>>>>>>            Increment i
83405>>>>>>>>>>
83405>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83406>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83407>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83408>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83409>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83410>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83411>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83412>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83413>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83414>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83415>>>>>>>>>>            Increment i
83416>>>>>>>>>>
83416>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83417>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83418>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83419>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83420>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83421>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83422>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83423>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83424>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83425>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83426>>>>>>>>>>            Increment i
83427>>>>>>>>>>
83427>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83428>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83429>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83430>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83431>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83432>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83433>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83434>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83435>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83436>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83437>>>>>>>>>>            Increment i
83438>>>>>>>>>>
83438>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83439>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83440>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83441>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83442>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83443>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83444>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83445>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83446>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83447>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83448>>>>>>>>>>            Increment i
83449>>>>>>>>>>
83449>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83450>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83451>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83452>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83453>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83454>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83455>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83456>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83457>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83458>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83459>>>>>>>>>>            Increment i
83460>>>>>>>>>>
83460>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83461>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83462>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83463>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83464>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83465>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83466>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83467>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83468>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83469>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83470>>>>>>>>>>            Increment i
83471>>>>>>>>>>
83471>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83472>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83473>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83474>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83475>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83476>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83477>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83478>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83479>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83480>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83481>>>>>>>>>>            Increment i
83482>>>>>>>>>>
83482>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83483>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83484>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83485>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83486>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83487>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83488>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83489>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83490>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83491>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83492>>>>>>>>>>            Increment i
83493>>>>>>>>>>
83493>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83494>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83495>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83496>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83497>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83498>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83499>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83500>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83501>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83502>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83503>>>>>>>>>>            Increment i
83504>>>>>>>>>>
83504>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83505>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83506>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83507>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83508>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83509>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83510>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83511>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83512>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83513>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83514>>>>>>>>>>            Increment i
83515>>>>>>>>>>
83515>>>>>>>>>>
83515>>>>>>>>>
83515>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83515>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83515>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83515>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>//
83515>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83515>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83515>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83515>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83515>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83515>>>>>>>>>//        Increment i
83515>>>>>>>>>
83515>>>>>>>>>        Function_Return aColumnType
83516>>>>>>>>>    End_Function
83517>>>>>>>>>
83517>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83517>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83519>>>>>>>>>        Integer iValue iSize iCount iStart iItem
83519>>>>>>>>>        tColumnType[] ColumnTypeArray
83519>>>>>>>>>        tColumnType[] ColumnTypeArray
83520>>>>>>>>>        tColumnType RetvalType
83520>>>>>>>>>        tColumnType RetvalType
83520>>>>>>>>>        String sValue
83520>>>>>>>>>        Boolean bFrameworkDataFlexType
83520>>>>>>>>>
83520>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83521>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83522>>>>>>>>>
83522>>>>>>>>>        Move 0 to iStart
83523>>>>>>>>>        Move (Uppercase(sType)) to sType
83524>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83525>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83527>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83528>>>>>>>>>            Function_Return RetvalType
83529>>>>>>>>>        End
83529>>>>>>>>>>
83529>>>>>>>>>
83529>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83530>>>>>>>>>        Move iType to RetvalType.iSQLType
83531>>>>>>>>>        Move sType to RetvalType.sSQLType 
83532>>>>>>>>>        Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83533>>>>>>>>>        
83533>>>>>>>>>        If (iItem = -1) Begin
83535>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83536>>>>>>>>>            Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83537>>>>>>>>>        End
83537>>>>>>>>>>
83537>>>>>>>>>        If (iItem <> -1) Begin
83539>>>>>>>>>            Move ColumnTypeArray[iItem].sSQLType       to RetvalType.sSQLType
83540>>>>>>>>>            Move ColumnTypeArray[iItem].iSQLType       to RetvalType.iSQLType
83541>>>>>>>>>            Move ColumnTypeArray[iItem].sDataFlexType  to RetvalType.sDataFlexType
83542>>>>>>>>>            Move ColumnTypeArray[iItem].iDataFlexType  to RetvalType.iDataFlexType
83543>>>>>>>>>            Move ColumnTypeArray[iItem].sPrecision     to RetvalType.sPrecision
83544>>>>>>>>>            Move ColumnTypeArray[iItem].bCanEditSize   to RetvalType.bCanEditSize
83545>>>>>>>>>        End
83545>>>>>>>>>>
83545>>>>>>>>>
83545>>>>>>>>>        Function_Return RetvalType
83546>>>>>>>>>    End_Function
83547>>>>>>>>>
83547>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83547>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83549>>>>>>>>>        tColumnType[] ColumnType
83549>>>>>>>>>        tColumnType[] ColumnType
83550>>>>>>>>>
83550>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83550>>>>>>>>>        // the dbType.
83550>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83552>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83554>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83555>>>>>>>>>            End
83555>>>>>>>>>>
83555>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83557>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83558>>>>>>>>>            End
83558>>>>>>>>>>
83558>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83560>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83561>>>>>>>>>            End
83561>>>>>>>>>>
83561>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83563>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83564>>>>>>>>>            End
83564>>>>>>>>>>
83564>>>>>>>>>        End
83564>>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>        Case Begin
83564>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83566>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83567>>>>>>>>>                Case Break
83568>>>>>>>>>
83568>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83571>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83572>>>>>>>>>                Case Break
83573>>>>>>>>>
83573>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83576>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83577>>>>>>>>>                Case Break
83578>>>>>>>>>        Case End
83578>>>>>>>>>
83578>>>>>>>>>        Function_Return ColumnType
83579>>>>>>>>>    End_Function
83580>>>>>>>>>
83580>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83580>>>>>>>>>    // are mapped to a DUF data type.
83580>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83582>>>>>>>>>        tColumnType ColumnType
83582>>>>>>>>>        tColumnType ColumnType
83582>>>>>>>>>        String sDataType
83582>>>>>>>>>        Integer iDriverID iCount
83582>>>>>>>>>
83582>>>>>>>>>        Move 0 to iCount
83583>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83584>>>>>>>>>
83584>>>>>>>>>        Case Begin
83584>>>>>>>>>            // DF_ASCII
83584>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83586>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83588>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83591>>>>>>>>>                End
83591>>>>>>>>>>
83591>>>>>>>>>                Else Begin
83592>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83595>>>>>>>>>                End
83595>>>>>>>>>>
83595>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83596>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83597>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83598>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83599>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83600>>>>>>>>>                Case Break
83601>>>>>>>>>
83601>>>>>>>>>            // DF_BINARY
83601>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83604>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83606>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83609>>>>>>>>>                End
83609>>>>>>>>>>
83609>>>>>>>>>                Else Begin
83610>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83613>>>>>>>>>                End
83613>>>>>>>>>>
83613>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83614>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83615>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83616>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83617>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83618>>>>>>>>>                Case Break
83619>>>>>>>>>
83619>>>>>>>>>            // DF_DATE
83619>>>>>>>>>            Case (iType = DF_DATE_DUF)
83622>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83624>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83627>>>>>>>>>                End
83627>>>>>>>>>>
83627>>>>>>>>>                Else Begin
83628>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83631>>>>>>>>>                End
83631>>>>>>>>>>
83631>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83632>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83633>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83634>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83635>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83636>>>>>>>>>                Case Break
83637>>>>>>>>>
83637>>>>>>>>>            // DF_DATETIME
83637>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83640>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83642>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83645>>>>>>>>>                End
83645>>>>>>>>>>
83645>>>>>>>>>                Else Begin
83646>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83649>>>>>>>>>                End
83649>>>>>>>>>>
83649>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83650>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83651>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83652>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83653>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83654>>>>>>>>>                Case Break
83655>>>>>>>>>
83655>>>>>>>>>            // DF_NUMERIC
83655>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83655>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83655>>>>>>>>>            // we make them here all "Numeric"...
83655>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83655>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83655>>>>>>>>>            // End
83655>>>>>>>>>            // Else Begin
83655>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83655>>>>>>>>>            // End
83655>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83655>>>>>>>>>            Case (iType = DF_BCD_DUF)
83658>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83659>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83660>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83661>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83662>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83663>>>>>>>>>                Case Break
83664>>>>>>>>>
83664>>>>>>>>>            // DF_TEXT
83664>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83667>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83669>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83672>>>>>>>>>                End
83672>>>>>>>>>>
83672>>>>>>>>>                Else Begin
83673>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83676>>>>>>>>>                End
83676>>>>>>>>>>
83676>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83677>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83678>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83679>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83680>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83681>>>>>>>>>                Case Break
83682>>>>>>>>>
83682>>>>>>>>>            Case Else
83682>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83683>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83684>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83685>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83686>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83687>>>>>>>>>
83687>>>>>>>>>        Case End
83687>>>>>>>>>
83687>>>>>>>>>        Function_Return ColumnType
83688>>>>>>>>>    End_Function
83689>>>>>>>>>
83689>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83691>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83693>>>>>>>>>        Handle hTable
83693>>>>>>>>>        Integer iIndex
83693>>>>>>>>>        String sTableName
83693>>>>>>>>>        Boolean bFlexErrs
83693>>>>>>>>>
83693>>>>>>>>>        // a) Get the exception table array the developer has specified
83693>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83694>>>>>>>>>
83694>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83694>>>>>>>>>        Repeat
83694>>>>>>>>>>
83694>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83697>>>>>>>>>            If (hTable <> 0) Begin
83699>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83702>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83703>>>>>>>>>                If (bFlexErrs = False) Begin
83705>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83707>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83708>>>>>>>>>                        If (iIndex = -1) Begin
83710>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83711>>>>>>>>>                        End
83711>>>>>>>>>>
83711>>>>>>>>>                    End
83711>>>>>>>>>>
83711>>>>>>>>>                End
83711>>>>>>>>>>
83711>>>>>>>>>            End
83711>>>>>>>>>>
83711>>>>>>>>>        Until (hTable = 0)
83713>>>>>>>>>
83713>>>>>>>>>        Move 0 to hTable
83714>>>>>>>>>
83714>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83714>>>>>>>>>        Repeat
83714>>>>>>>>>>
83714>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83717>>>>>>>>>            If (hTable > 0) Begin
83719>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83722>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83723>>>>>>>>>                If (bFlexErrs = False) Begin
83725>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83726>>>>>>>>>                    If (iIndex = -1) Begin
83728>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83729>>>>>>>>>                    End
83729>>>>>>>>>>
83729>>>>>>>>>                End
83729>>>>>>>>>>
83729>>>>>>>>>            End
83729>>>>>>>>>>
83729>>>>>>>>>        Until (hTable = 0)
83731>>>>>>>>>
83731>>>>>>>>>        Function_Return iTablesArray
83732>>>>>>>>>    End_Function
83733>>>>>>>>>
83733>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83735>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83737>>>>>>>>>        Handle hTable
83737>>>>>>>>>        Integer iIndex
83737>>>>>>>>>        String sTableName
83737>>>>>>>>>        Boolean bFlexErrs
83737>>>>>>>>>
83737>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83738>>>>>>>>>        Move 0 to hTable
83739>>>>>>>>>
83739>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83739>>>>>>>>>        Repeat
83739>>>>>>>>>>
83739>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83742>>>>>>>>>            If (hTable > 0) Begin
83744>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83747>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83748>>>>>>>>>                If (bFlexErrs = False) Begin
83750>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83751>>>>>>>>>                    If (iIndex = -1) Begin
83753>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83754>>>>>>>>>                    End
83754>>>>>>>>>>
83754>>>>>>>>>                End
83754>>>>>>>>>>
83754>>>>>>>>>            End
83754>>>>>>>>>>
83754>>>>>>>>>        Until (hTable = 0)
83756>>>>>>>>>
83756>>>>>>>>>        Function_Return iTablesArray
83757>>>>>>>>>    End_Function
83758>>>>>>>>>
83758>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83760>>>>>>>>>        tAPIColumn NewAPIColumn
83760>>>>>>>>>        tAPIColumn NewAPIColumn
83760>>>>>>>>>
83760>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83761>>>>>>>>>        Move iType      to NewAPIColumn.iType
83762>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83763>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83764>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83765>>>>>>>>>
83765>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83766>>>>>>>>>
83766>>>>>>>>>        Function_Return aCurrent
83767>>>>>>>>>    End_Function
83768>>>>>>>>>
83768>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83770>>>>>>>>>        String sRetval sFieldName
83770>>>>>>>>>        Integer iCount iSize
83770>>>>>>>>>
83770>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83771>>>>>>>>>        Decrement iSize
83772>>>>>>>>>        For iCount from 0 to iSize
83778>>>>>>>>>>
83778>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83779>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83780>>>>>>>>>        Loop
83781>>>>>>>>>>
83781>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83782>>>>>>>>>
83782>>>>>>>>>        Function_Return sRetval
83783>>>>>>>>>    End_Function
83784>>>>>>>>>
83784>>>>>>>>>    // *** Miscellaneous other functions ***
83784>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83784>>>>>>>>>    //
83784>>>>>>>>>
83784>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83784>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83786>>>>>>>>>        Integer iPerc
83786>>>>>>>>>        Number nReady nTotal
83786>>>>>>>>>
83786>>>>>>>>>        Send DoAdvance of ghoProgressBar
83787>>>>>>>>>
83787>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83789>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83790>>>>>>>>>        End
83790>>>>>>>>>>
83790>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83792>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83793>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83794>>>>>>>>>        End
83794>>>>>>>>>>
83794>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83796>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83797>>>>>>>>>        End
83797>>>>>>>>>>
83797>>>>>>>>>
83797>>>>>>>>>        Case Begin
83797>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83799>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83800>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83801>>>>>>>>>                Case Break
83802>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83805>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83806>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83807>>>>>>>>>                Case Break
83808>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83811>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83812>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83813>>>>>>>>>                Case Break
83814>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83817>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83818>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83819>>>>>>>>>                Case Break
83820>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83823>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83824>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83825>>>>>>>>>                Case Break
83826>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83829>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83830>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83831>>>>>>>>>                Case Break
83832>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83835>>>>>>>>>                Send None
83836>>>>>>>>>                Case Break
83837>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83840>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83841>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83842>>>>>>>>>                Case Break
83843>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83846>>>>>>>>>                //*** Interpret numbers
83846>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83847>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83848>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83849>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83850>>>>>>>>>                Case Break
83851>>>>>>>>>            Case Else
83851>>>>>>>>>                Set Message_Text to ""
83852>>>>>>>>>                Set Action_Text  to ""
83853>>>>>>>>>        Case End
83853>>>>>>>>>
83853>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83854>>>>>>>>>        Function_Return False
83855>>>>>>>>>    End_Function
83856>>>>>>>>>
83856>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83856>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83858>>>>>>>>>        Function_Return False
83859>>>>>>>>>    End_Function
83860>>>>>>>>>
83860>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83860>>>>>>>>>    //
83860>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83860>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83860>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83860>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83860>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83860>>>>>>>>>    //   ALTER TABLE MyTable
83860>>>>>>>>>    //       REBUILD
83860>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83862>>>>>>>>>        Boolean bOK
83862>>>>>>>>>
83862>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83864>>>>>>>>>            Function_Return False
83865>>>>>>>>>        End
83865>>>>>>>>>>
83865>>>>>>>>>
83865>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83865>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83866>>>>>>>>>
83866>>>>>>>>>        Function_Return (bOK = True)
83867>>>>>>>>>    End_Function
83868>>>>>>>>>
83868>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83868>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83868>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83868>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83868>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83868>>>>>>>>>    //   ALTER TABLE MyTable
83868>>>>>>>>>    //       REBUILD
83868>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83870>>>>>>>>>        tSQLScriptArray SQLScriptArray
83870>>>>>>>>>        tSQLScriptArray SQLScriptArray
83870>>>>>>>>>        String sDriverID
83870>>>>>>>>>        Boolean bOK
83870>>>>>>>>>        Integer iSize iCount
83870>>>>>>>>>
83870>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83872>>>>>>>>>            Function_Return False
83873>>>>>>>>>        End
83873>>>>>>>>>>
83873>>>>>>>>>
83873>>>>>>>>>        Get psDriverID to sDriverID
83874>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83875>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83877>>>>>>>>>            Function_Return False
83878>>>>>>>>>        End
83878>>>>>>>>>>
83878>>>>>>>>>
83878>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83879>>>>>>>>>        Decrement iSize
83880>>>>>>>>>
83880>>>>>>>>>        For iCount from 0 to iSize
83886>>>>>>>>>>
83886>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83888>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83889>>>>>>>>>            End
83889>>>>>>>>>>
83889>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83891>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83892>>>>>>>>>            End
83892>>>>>>>>>>
83892>>>>>>>>>        Loop
83893>>>>>>>>>>
83893>>>>>>>>>
83893>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83894>>>>>>>>>
83894>>>>>>>>>        Function_Return (bOK = True)
83895>>>>>>>>>    End_Function
83896>>>>>>>>>
83896>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83896>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83896>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83896>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83898>>>>>>>>>        Integer iChannel iArgumentSize iCount
83898>>>>>>>>>        Number nByteCount
83898>>>>>>>>>        String sSQLScript
83898>>>>>>>>>        tSQLScriptArray SqlScriptArray
83898>>>>>>>>>        tSQLScriptArray SqlScriptArray
83898>>>>>>>>>        UChar[] uCharData
83899>>>>>>>>>
83899>>>>>>>>>        Move False to Err
83900>>>>>>>>>        Get Seq_New_Channel to iChannel
83901>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83903>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83904>>>>>>>>>>
83904>>>>>>>>>            Move True to SqlScriptArray.bError
83905>>>>>>>>>            Function_Return SqlScriptArray
83906>>>>>>>>>        End
83906>>>>>>>>>>
83906>>>>>>>>>
83906>>>>>>>>>        // First decide the size of the script
83906>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83908>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83910>>>>>>>>>        Close_Input channel iChannel
83912>>>>>>>>>
83912>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83913>>>>>>>>>        If (nByteCount  < 1) Begin
83915>>>>>>>>>            Send Seq_Release_Channel iChannel
83916>>>>>>>>>            Move True to SqlScriptArray.bError
83917>>>>>>>>>            Function_Return SqlScriptArray
83918>>>>>>>>>        End
83918>>>>>>>>>>
83918>>>>>>>>>
83918>>>>>>>>>        // If necessary change the string argument_size
83918>>>>>>>>>        // Read the script file from memory line-by-line
83918>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83920>>>>>>>>>            Move 0 to iCount
83921>>>>>>>>>            Repeat
83921>>>>>>>>>>
83921>>>>>>>>>                Readln channel iChannel sSQLScript
83923>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83924>>>>>>>>>                Increment iCount
83925>>>>>>>>>            Until (SeqEof = True)
83927>>>>>>>>>        Close_Input channel iChannel
83929>>>>>>>>>        Send Seq_Release_Channel iChannel
83930>>>>>>>>>
83930>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83930>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83931>>>>>>>>>
83931>>>>>>>>>        Function_Return SqlScriptArray
83932>>>>>>>>>    End_Function
83933>>>>>>>>>
83933>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83935>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83935>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83935>>>>>>>>>        Integer i iMsgs iRows jRows iRowType iCount jCount iChunkCounter iChunkMax iCh iNextSet iMessage iPos
83935>>>>>>>>>        String[] asMsg asSQLQueryMessages
83937>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83937>>>>>>>>>        TimeSpan tsQuery
83937>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83937>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83937>>>>>>>>>        tSQLConnection SQLConnection
83937>>>>>>>>>        tSQLConnection SQLConnection
83937>>>>>>>>>        Boolean bShowProgress
83937>>>>>>>>>        
83937>>>>>>>>>        If (num_arguments > 4) Begin
83939>>>>>>>>>            Move bShowProgr to bShowProgress
83940>>>>>>>>>        End
83940>>>>>>>>>>
83940>>>>>>>>>        Get phoSQLManager to hoSql
83941>>>>>>>>>
83941>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83942>>>>>>>>>        // There seems to be a problem with passing strings when their value gets really big, aka
83942>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83942>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83942>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83942>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83942>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83942>>>>>>>>>        Get piChunkMax to iChunkMax 
83943>>>>>>>>>        Move False to Err
83944>>>>>>>>>        Move 0 to iChunkCounter
83945>>>>>>>>>        Move "" to sStmt
83946>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83947>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83948>>>>>>>>>
83948>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83949>>>>>>>>>
83949>>>>>>>>>        Get phoSQLManager  to hoSQL
83950>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83952>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83954>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83955>>>>>>>>>                If (iPos > 0) Begin
83957>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83958>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83959>>>>>>>>>                End
83959>>>>>>>>>>
83959>>>>>>>>>            End
83959>>>>>>>>>>
83959>>>>>>>>>        End
83959>>>>>>>>>>
83959>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83960>>>>>>>>>
83960>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83961>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83963>>>>>>>>>            Move False to Err
83964>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83965>>>>>>>>>            If (hoStmt <> 0) Begin
83967>>>>>>>>>
83967>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83967>>>>>>>>>                If (bCreateScriptFile = True) Begin
83969>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83970>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83971>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83972>>>>>>>>>                    Get Seq_New_Channel to iCh
83973>>>>>>>>>                    If (iCh <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83975>>>>>>>>>                        Direct_Output channel iCh sExportFile
83977>>>>>>>>>                    End
83977>>>>>>>>>>
83977>>>>>>>>>                End
83977>>>>>>>>>>
83977>>>>>>>>>
83977>>>>>>>>>                // Record starting date/time stamp
83977>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83978>>>>>>>>>                // Turn on error handling if enabled
83978>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83980>>>>>>>>>                    Set pbSqlError to False
83981>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83982>>>>>>>>>                    Move Error_Object_Id to hoError
83983>>>>>>>>>                    Move Self to Error_Object_Id
83984>>>>>>>>>                End
83984>>>>>>>>>>
83984>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83986>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83987>>>>>>>>>                End
83987>>>>>>>>>>
83987>>>>>>>>>
83987>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83988>>>>>>>>>                Decrement iRows
83989>>>>>>>>>
83989>>>>>>>>>                for iCount from 0 to iRows
83995>>>>>>>>>>
83995>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83996>>>>>>>>>
83996>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83998>>>>>>>>>                        If (sSQLVal <> "") Begin
84000>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
84001>>>>>>>>>                        End
84001>>>>>>>>>>
84001>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
84002>>>>>>>>>                    End
84002>>>>>>>>>>
84002>>>>>>>>>
84002>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
84002>>>>>>>>>                    // or if at the very end of the script.
84002>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
84004>>>>>>>>>
84004>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
84004>>>>>>>>>                        // instead of all in one go.
84004>>>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel sStmt
84005>>>>>>>>>                        
84005>>>>>>>>>                        // *** Execute script lines: ***
84005>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
84006>>>>>>>>>//                        Get SQLFetchResultsetValues of hoStmt to asSQLQueryMessages
84006>>>>>>>>>                        
84006>>>>>>>>>                        If (bCreateScriptFile = True) Begin
84008>>>>>>>>>                            Writeln channel iCh sStmt 
84011>>>>>>>>>                            Writeln channel iCh "GO"
84014>>>>>>>>>                        End
84014>>>>>>>>>>
84014>>>>>>>>>                        Move "" to sStmt
84015>>>>>>>>>                        Move 0 to iChunkCounter
84016>>>>>>>>>                    End
84016>>>>>>>>>>
84016>>>>>>>>>                    Increment iChunkCounter
84017>>>>>>>>>                Loop
84018>>>>>>>>>>
84018>>>>>>>>>
84018>>>>>>>>>                Repeat
84018>>>>>>>>>>
84018>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
84020>>>>>>>>>                        Move hoError to Error_Object_Id
84021>>>>>>>>>                    End
84021>>>>>>>>>>
84021>>>>>>>>>
84021>>>>>>>>>                    Send _SqlColumnInfo hoStmt
84022>>>>>>>>>                    Get SQLGetStmtAttribute  of hoStmt SqlSTMTATTRIB_ROWCOUNT to jRows
84023>>>>>>>>>                    Get SQLGetStmtAttribute  of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
84024>>>>>>>>>                    Get SQLGetStmtAttribute  of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
84025>>>>>>>>>                    Set piRows    to jRows
84026>>>>>>>>>                    Set piRowType to iRowType
84027>>>>>>>>>
84027>>>>>>>>>                    If (iMsgs <> 0) Begin
84029>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
84031>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to asSQLQueryMessages
84032>>>>>>>>>                        End
84032>>>>>>>>>>
84032>>>>>>>>>                        for jCount from 1 to iMsgs
84038>>>>>>>>>>
84038>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
84039>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
84040>>>>>>>>>                            If (bShowProgress = True) Begin
84042>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
84044>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
84045>>>>>>>>>                                End
84045>>>>>>>>>>
84045>>>>>>>>>                                Else Begin
84046>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
84048>>>>>>>>>                                End
84048>>>>>>>>>>
84048>>>>>>>>>                            End
84048>>>>>>>>>>
84048>>>>>>>>>                            Move sMessage to asMsg[SizeOfArray(asMsg)]
84049>>>>>>>>>                            Move sMessage to asSQLQueryMessages[SizeOfArray(asSQLQueryMessages)]
84050>>>>>>>>>                        Loop
84051>>>>>>>>>>
84051>>>>>>>>>
84051>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
84053>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to asSQLQueryMessages
84054>>>>>>>>>                        End
84054>>>>>>>>>>
84054>>>>>>>>>                        Set paQueryMessages to asMsg
84055>>>>>>>>>                    End
84055>>>>>>>>>>
84055>>>>>>>>>
84055>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
84056>>>>>>>>>                Until (iNextSet = 0)
84058>>>>>>>>>    
84058>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
84059>>>>>>>>>            End
84059>>>>>>>>>>
84059>>>>>>>>>
84059>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
84060>>>>>>>>>            Set ptsQueryExec to tsQuery
84061>>>>>>>>>            Send SqlClose of hoStmt
84062>>>>>>>>>
84062>>>>>>>>>            If (bCreateScriptFile = True) Begin
84064>>>>>>>>>                Close_Output channel iCh
84066>>>>>>>>>                Send Seq_Release_Channel iCh
84067>>>>>>>>>            End
84067>>>>>>>>>>
84067>>>>>>>>>        End
84067>>>>>>>>>>
84067>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
84068>>>>>>>>>
84068>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
84069>>>>>>>>>    End_Function
84070>>>>>>>>>
84070>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84072>>>>>>>>>        tSQLScriptArray SQLScriptArray
84072>>>>>>>>>        tSQLScriptArray SQLScriptArray
84072>>>>>>>>>        String sDriverID sCollation
84072>>>>>>>>>        Boolean bOK
84072>>>>>>>>>        Integer iSize iCount
84072>>>>>>>>>
84072>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84074>>>>>>>>>            Function_Return False
84075>>>>>>>>>        End
84075>>>>>>>>>>
84075>>>>>>>>>
84075>>>>>>>>>        Get psDriverID  to sDriverID
84076>>>>>>>>>        Get psCollation to sCollation
84077>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84078>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84080>>>>>>>>>            Function_Return False
84081>>>>>>>>>        End
84081>>>>>>>>>>
84081>>>>>>>>>
84081>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84082>>>>>>>>>        Decrement iSize
84083>>>>>>>>>
84083>>>>>>>>>        For iCount from 0 to iSize
84089>>>>>>>>>>
84089>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84091>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84092>>>>>>>>>            End
84092>>>>>>>>>>
84092>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84094>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84095>>>>>>>>>            End
84095>>>>>>>>>>
84095>>>>>>>>>        Loop
84096>>>>>>>>>>
84096>>>>>>>>>
84096>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84097>>>>>>>>>
84097>>>>>>>>>        Function_Return (bOK = True)
84098>>>>>>>>>    End_Function
84099>>>>>>>>>
84099>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84101>>>>>>>>>        tSQLScriptArray SQLScriptArray
84101>>>>>>>>>        tSQLScriptArray SQLScriptArray
84101>>>>>>>>>        String sDriverID sCollation
84101>>>>>>>>>        Boolean bOK
84101>>>>>>>>>        Integer iSize iCount
84101>>>>>>>>>
84101>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84103>>>>>>>>>            Function_Return False
84104>>>>>>>>>        End
84104>>>>>>>>>>
84104>>>>>>>>>
84104>>>>>>>>>        Get psDriverID  to sDriverID
84105>>>>>>>>>        Get psCollation to sCollation
84106>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84107>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84109>>>>>>>>>            Function_Return False
84110>>>>>>>>>        End
84110>>>>>>>>>>
84110>>>>>>>>>
84110>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84111>>>>>>>>>        Decrement iSize
84112>>>>>>>>>
84112>>>>>>>>>        For iCount from 0 to iSize
84118>>>>>>>>>>
84118>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84120>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84121>>>>>>>>>            End
84121>>>>>>>>>>
84121>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84123>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84124>>>>>>>>>            End
84124>>>>>>>>>>
84124>>>>>>>>>        Loop
84125>>>>>>>>>>
84125>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
84125>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84126>>>>>>>>>
84126>>>>>>>>>        Function_Return (bOK = True)
84127>>>>>>>>>    End_Function
84128>>>>>>>>>
84128>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84130>>>>>>>>>        Integer iMax iPos
84130>>>>>>>>>        String sName
84130>>>>>>>>>
84130>>>>>>>>>        Move (Lowercase(sField)) to sField
84131>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84134>>>>>>>>>        For iPos from 0 to iMax
84140>>>>>>>>>>
84140>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84143>>>>>>>>>            Move (Lowercase(sName)) to sName
84144>>>>>>>>>            If (sName = sField) Begin
84146>>>>>>>>>                Function_Return iPos
84147>>>>>>>>>            End
84147>>>>>>>>>>
84147>>>>>>>>>        Loop
84148>>>>>>>>>>
84148>>>>>>>>>        Function_Return -1
84149>>>>>>>>>    End_Function
84150>>>>>>>>>
84150>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84150>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84150>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84150>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84150>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84152>>>>>>>>>        String sID sConnString
84152>>>>>>>>>        Integer iDriver iNumConn iCount
84152>>>>>>>>>        Handle hoCLI
84152>>>>>>>>>        Boolean bOK
84152>>>>>>>>>
84152>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84153>>>>>>>>>        If (bOK = False) Begin
84155>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84156>>>>>>>>>>
84156>>>>>>>>>            Function_Return False
84157>>>>>>>>>        End
84157>>>>>>>>>>
84157>>>>>>>>>
84157>>>>>>>>>        Move False to bOK
84158>>>>>>>>>        Get phoCLIHandler to hoCLI
84159>>>>>>>>>        If (hoCLI <> 0) Begin
84161>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84162>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84163>>>>>>>>>
84163>>>>>>>>>            // If driver not loaded; load it.
84163>>>>>>>>>            If (iDriver = 0) Begin
84165>>>>>>>>>                Load_Driver sDriverID
84166>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84167>>>>>>>>>            End
84167>>>>>>>>>>
84167>>>>>>>>>            If (iDriver <> 0) Begin
84169>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84172>>>>>>>>>                Decrement iNumConn
84173>>>>>>>>>                For iCount from 0 to iNumConn
84179>>>>>>>>>>
84179>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84182>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84185>>>>>>>>>                    If (sID = sConnectionID) Begin
84187>>>>>>>>>                        Move True to bOK
84188>>>>>>>>>                    End
84188>>>>>>>>>>
84188>>>>>>>>>                Loop
84189>>>>>>>>>>
84189>>>>>>>>>            End
84189>>>>>>>>>>
84189>>>>>>>>>        End
84189>>>>>>>>>>
84189>>>>>>>>>
84189>>>>>>>>>        Function_Return bOK
84190>>>>>>>>>    End_Function
84191>>>>>>>>>
84191>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84193>>>>>>>>>        Boolean bOK
84193>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84194>>>>>>>>>        Function_Return bOK
84195>>>>>>>>>    End_Function
84196>>>>>>>>>
84196>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84198>>>>>>>>>        Integer iDriverIndex
84198>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84199>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84200>>>>>>>>>    End_Function
84201>>>>>>>>>
84201>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84201>>>>>>>>>    // attempt to load the driver.
84201>>>>>>>>>    // Returns true if the passed driver is SQL based.
84201>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84203>>>>>>>>>        Boolean bOK
84203>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84204>>>>>>>>>        Function_Return bOK
84205>>>>>>>>>    End_Function
84206>>>>>>>>>
84206>>>>>>>>>    // *** Error Handler ***
84206>>>>>>>>>    //
84206>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84206>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84206>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84208>>>>>>>>>        Integer iSize iErrorMode
84208>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84208>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84208>>>>>>>>>
84208>>>>>>>>>        If (pbProcessingError(Self)) Begin
84210>>>>>>>>>            Procedure_Return
84211>>>>>>>>>        End
84211>>>>>>>>>>
84211>>>>>>>>>
84211>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84212>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84214>>>>>>>>>            Set Private.pbProcessingError to False
84215>>>>>>>>>            Procedure_Return
84216>>>>>>>>>        End
84216>>>>>>>>>>
84216>>>>>>>>>
84216>>>>>>>>>        Set pbProcessingError to True
84217>>>>>>>>>        Set pbSqlError to True
84218>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84219>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84220>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84221>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84222>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84223>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84224>>>>>>>>>        Set pbProcessingError to False
84225>>>>>>>>>    End_Procedure
84226>>>>>>>>>
84226>>>>>>>>>    // *** Miscellanous Helper Functions ***
84226>>>>>>>>>    //
84226>>>>>>>>>    // Helper function. Takes a DF_FILE_ROOT_NAME value as parameter and
84226>>>>>>>>>    // returns the table name only; stripped of any prefix, path or filename extension.
84226>>>>>>>>>    Function _TableNameOnly String sTableName Returns String
84228>>>>>>>>>        Integer iPos
84228>>>>>>>>>        Move (Pos(":", sTableName)) to iPos
84229>>>>>>>>>        If (iPos <> 0) Begin
84231>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
84232>>>>>>>>>        End  
84232>>>>>>>>>>
84232>>>>>>>>>        Move (Pos(".int", Lowercase(sTableName))) to iPos
84233>>>>>>>>>        If (iPos <> 0) Begin
84235>>>>>>>>>            Move (Left(sTableName, (iPos -1))) to sTableName
84236>>>>>>>>>        End  
84236>>>>>>>>>>
84236>>>>>>>>>        Function_Return sTableName
84237>>>>>>>>>    End_Function
84238>>>>>>>>>
84238>>>>>>>>>    // Removes any prefix from a table name.
84238>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84238>>>>>>>>>    //         dbo.mytable returns mytable
84238>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84240>>>>>>>>>        Integer iPos
84240>>>>>>>>>        Move (Pos(":", sName)) to iPos
84241>>>>>>>>>        If (iPos <> 0) Begin
84243>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84244>>>>>>>>>        End
84244>>>>>>>>>>
84244>>>>>>>>>        Move (Pos(".", sName)) to iPos
84245>>>>>>>>>        If (iPos <> 0) Begin
84247>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84248>>>>>>>>>        End
84248>>>>>>>>>>
84248>>>>>>>>>        Function_Return sName
84249>>>>>>>>>    End_Function
84250>>>>>>>>>    
84250>>>>>>>>>    Function _DriverIDFromRootName String sRootName Returns String
84252>>>>>>>>>        String sDriverID
84252>>>>>>>>>        Integer iPos
84252>>>>>>>>>        Move DATAFLEX_ID to sDriverID
84253>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
84254>>>>>>>>>        If (iPos <> 0) Begin
84256>>>>>>>>>            Move (Left(sRootName, (iPos -1))) to sDriverID
84257>>>>>>>>>        End
84257>>>>>>>>>>
84257>>>>>>>>>        Function_Return sDriverID
84258>>>>>>>>>    End_Function
84259>>>>>>>>>    // Does the Rootname points to a .dat file?
84259>>>>>>>>>    Function _IsDatEntry Handle hTable Returns Boolean
84261>>>>>>>>>        Boolean bFound bIsIntEntry
84261>>>>>>>>>        String sRootName sNoDriverRootname sDriver
84261>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84264>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84265>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84266>>>>>>>>>        Get _IsIntEntry hTable to bIsIntEntry
84267>>>>>>>>>        Move (bIsIntEntry = False and sDriver = DATAFLEX_ID) to bFound
84268>>>>>>>>>        Function_Return bFound
84269>>>>>>>>>    End_Function
84270>>>>>>>>>
84270>>>>>>>>>    // Checks that the RootName points to a .dat file and that the .dat file exists on disk.
84270>>>>>>>>>    Function _DatFileExists Handle hTable Returns Boolean
84272>>>>>>>>>        Boolean bExists
84272>>>>>>>>>        String sDataPath sRootName sNoDriverRootname
84272>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84275>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84276>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84277>>>>>>>>>        File_Exist (sDataPath + "\" + sNoDriverRootname + ".dat") bExists
84278>>>>>>>>>        Function_Return bExists
84279>>>>>>>>>    End_Function
84280>>>>>>>>>    
84280>>>>>>>>>    // Does the Rootname contain a ".int" suffix.
84280>>>>>>>>>    Function _IsIntEntry Handle hTable Returns Boolean
84282>>>>>>>>>        Boolean bFound
84282>>>>>>>>>        String sRootName
84282>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84285>>>>>>>>>        Move (Lowercase(sRootName) contains ".int") to bFound
84286>>>>>>>>>        Function_Return bFound
84287>>>>>>>>>    End_Function
84288>>>>>>>>>
84288>>>>>>>>>    // Checks to see if the .int file actually exists in the Data folder.
84288>>>>>>>>>    Function _IntFileExists Handle hTable Returns Boolean
84290>>>>>>>>>        Boolean bExists bIsIntFile
84290>>>>>>>>>        String sDataPath sIntFileName
84290>>>>>>>>>        Integer iPos
84290>>>>>>>>>        
84290>>>>>>>>>        Move False to bExists
84291>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84292>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName
84295>>>>>>>>>        Get _TableNameOnly sIntFileName to sIntFileName
84296>>>>>>>>>        Move (Pos(".int", Lowercase(sIntFileName))) to iPos
84297>>>>>>>>>        If (iPos = 0) Begin
84299>>>>>>>>>            Move (sIntFileName + ".int") to sIntFileName
84300>>>>>>>>>        End
84300>>>>>>>>>>
84300>>>>>>>>>        File_Exist (sDataPath + "\" + sIntFileName) bExists
84301>>>>>>>>>        Function_Return bExists    
84302>>>>>>>>>    End_Function
84303>>>>>>>>>        
84303>>>>>>>>>    // Returns True if the hTable's RootName has a driver <> DataFlex
84303>>>>>>>>>    Function _IsSQLEntry Handle hTable Returns Boolean
84305>>>>>>>>>        Boolean bFound bIsIntFile
84305>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname sDriver
84305>>>>>>>>>        
84305>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84308>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84309>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84310>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84311>>>>>>>>>        Move (bIsIntFile = True or sDriver <> DATAFLEX_ID) to bFound
84312>>>>>>>>>        Function_Return bFound
84313>>>>>>>>>    End_Function
84314>>>>>>>>>
84314>>>>>>>>>    // This is used in place of the DF_FILE_OPENED table attribute, because
84314>>>>>>>>>    // the table then needs to be open, which takes time.
84314>>>>>>>>>    Function _IsAliasTable Handle hTable Returns Boolean
84316>>>>>>>>>        Boolean bFound bIsIntTable
84316>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname
84316>>>>>>>>>        
84316>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84319>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84322>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84323>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
84324>>>>>>>>>        // Do we have an Alias table?
84324>>>>>>>>>        Move (Lowercase(sLogicalName) <> Lowercase(sNoDriverRootname)) to bFound
84325>>>>>>>>>        Function_Return bFound
84326>>>>>>>>>    End_Function
84327>>>>>>>>>
84327>>>>>>>>>    // If the SQL table cannot be opened, we do the checking a bit different.
84327>>>>>>>>>    Function _IsSystemFile Handle hTable Returns Boolean
84329>>>>>>>>>        Boolean bIsSystem bIsSQL bExists bOpen
84329>>>>>>>>>        String sRootName sDataPath sDriver
84329>>>>>>>>>        String[] asIndexes
84330>>>>>>>>>        Move False to bIsSystem
84331>>>>>>>>>
84331>>>>>>>>>        Open hTable
84333>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84336>>>>>>>>>        If (bOpen = True) Begin
84338>>>>>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
84341>>>>>>>>>            Function_Return bIsSystem
84342>>>>>>>>>        End
84342>>>>>>>>>>
84342>>>>>>>>>        
84342>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84345>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84346>>>>>>>>>        Get _TableNameOnly sRootName to sRootName
84347>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
84348>>>>>>>>>        Get PathAtIndex of (phoWorkspace(ghoApplication))  sDataPath 1 to sDataPath
84349>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
84350>>>>>>>>>        
84350>>>>>>>>>        Get _IsSQLEntry hTable to bIsSQL
84351>>>>>>>>>        If (bIsSQL = False) Begin
84353>>>>>>>>>            File_Exist (sDataPath + sRootName + ".dat") bExists
84354>>>>>>>>>            If (bExists = True) Begin
84356>>>>>>>>>                Open (sDataPath + sRootName + ".dat") as hTable
84358>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem 
84361>>>>>>>>>                Close hTable
84362>>>>>>>>>            End
84362>>>>>>>>>>
84362>>>>>>>>>        End 
84362>>>>>>>>>>
84362>>>>>>>>>        Else Begin
84363>>>>>>>>>            Get _SqlUtilEnumerateIndexes sRootName sDriver to asIndexes
84364>>>>>>>>>            Move (SizeOfArray(asIndexes) = 0) to bIsSystem
84365>>>>>>>>>        End
84365>>>>>>>>>>
84365>>>>>>>>>        Function_Return bIsSystem
84366>>>>>>>>>    End_Function
84367>>>>>>>>>                          
84367>>>>>>>>>    // Removes any driver prefix and any .int suffix from the Rootname
84367>>>>>>>>>    // If any driver found, it will be placed in the ByRef param: sDriver.
84367>>>>>>>>>    Function _RemoveDriverFromRootName String sRootname String ByRef sDriver Returns String
84369>>>>>>>>>        String sNoDriverRootname
84369>>>>>>>>>        Integer iPos
84369>>>>>>>>>        
84369>>>>>>>>>        Move sRootname to sNoDriverRootname
84370>>>>>>>>>        Move (Pos(":", sRootname)) to iPos
84371>>>>>>>>>        If (iPos <> 0) Begin
84373>>>>>>>>>            Move (Left(sRootname, iPos -1)) to sDriver
84374>>>>>>>>>            Move (Mid(sRootname, Length(sRootname), iPos +1)) to sNoDriverRootname    
84375>>>>>>>>>        End
84375>>>>>>>>>>
84375>>>>>>>>>        Else Begin
84376>>>>>>>>>            Move DATAFLEX_ID to sDriver
84377>>>>>>>>>        End
84377>>>>>>>>>>
84377>>>>>>>>>        Move (Pos(".int", Lowercase(sNoDriverRootname))) to iPos
84378>>>>>>>>>        If (iPos <> 0) Begin
84380>>>>>>>>>            Move (Left(sNoDriverRootname, iPos -1)) to sNoDriverRootname
84381>>>>>>>>>        End
84381>>>>>>>>>>
84381>>>>>>>>>        Function_Return sNoDriverRootname    
84382>>>>>>>>>    End_Function
84383>>>>>>>>>
84383>>>>>>>>>    Function _CountFilelistSystemTables Returns Integer
84385>>>>>>>>>        tFilelist[] FileListTables
84385>>>>>>>>>        tFilelist[] FileListTables
84386>>>>>>>>>        Integer iCount iSize iItems
84386>>>>>>>>>        
84386>>>>>>>>>        Move 0 to iItems
84387>>>>>>>>>        Get pFileListArray to FileListTables
84388>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84389>>>>>>>>>        If (iSize <> 0) Begin
84391>>>>>>>>>            Decrement iSize
84392>>>>>>>>>            for iCount from 0 to iSize
84398>>>>>>>>>>
84398>>>>>>>>>                If (FileListTables[iCount].bIsSystemFile = True) Begin
84400>>>>>>>>>                    Increment iItems
84401>>>>>>>>>                End
84401>>>>>>>>>>
84401>>>>>>>>>            Loop
84402>>>>>>>>>>
84402>>>>>>>>>        End
84402>>>>>>>>>>
84402>>>>>>>>>        Function_Return iItems    
84403>>>>>>>>>    End_Function
84404>>>>>>>>>
84404>>>>>>>>>    Function _CountFileListAliasTables Returns Integer
84406>>>>>>>>>        tFilelist[] FileListTables
84406>>>>>>>>>        tFilelist[] FileListTables
84407>>>>>>>>>        Integer iCount iSize iItems
84407>>>>>>>>>        
84407>>>>>>>>>        Move 0 to iItems
84408>>>>>>>>>        Get pFileListArray to FileListTables
84409>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84410>>>>>>>>>        If (iSize <> 0) Begin
84412>>>>>>>>>            Decrement iSize
84413>>>>>>>>>            for iCount from 0 to iSize
84419>>>>>>>>>>
84419>>>>>>>>>                If (FileListTables[iCount].bIsAlias = True) Begin
84421>>>>>>>>>                    Increment iItems
84422>>>>>>>>>                End
84422>>>>>>>>>>
84422>>>>>>>>>            Loop
84423>>>>>>>>>>
84423>>>>>>>>>        End
84423>>>>>>>>>>
84423>>>>>>>>>        Function_Return iItems    
84424>>>>>>>>>    End_Function
84425>>>>>>>>>
84425>>>>>>>>>    Function _CountFileListMasterTables Returns Integer
84427>>>>>>>>>        String sRootName sLogicalName sDriver sNoDriverRootname
84427>>>>>>>>>        Handle hTable
84427>>>>>>>>>        Integer iSize iItems
84427>>>>>>>>>        Boolean bIsAlias bIsIntTable
84427>>>>>>>>>        
84427>>>>>>>>>        Move 0 to iItems
84428>>>>>>>>>        Move 0 to hTable 
84429>>>>>>>>>        Repeat
84429>>>>>>>>>>
84429>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84432>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84434>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84435>>>>>>>>>                If (bIsAlias = False) Begin
84437>>>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84440>>>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName                    
84443>>>>>>>>>                    Get _RemoveDriverFromRootName sRootName (&sDriver) to sNoDriverRootname
84444>>>>>>>>>                    Get _IsIntEntry hTable to bIsIntTable
84445>>>>>>>>>                    If (sDriver <> DATAFLEX_ID and Lowercase(sNoDriverRootname) = Lowercase(sLogicalName)) Begin
84447>>>>>>>>>                        Increment iItems
84448>>>>>>>>>                    End
84448>>>>>>>>>>
84448>>>>>>>>>                End
84448>>>>>>>>>>
84448>>>>>>>>>            End
84448>>>>>>>>>>
84448>>>>>>>>>        Until (hTable = 0)
84450>>>>>>>>>        
84450>>>>>>>>>        Function_Return iItems
84451>>>>>>>>>    End_Function
84452>>>>>>>>>
84452>>>>>>>>>    Function _CountFileListOpenErrors Returns Integer
84454>>>>>>>>>        tFilelist[] FileListTables
84454>>>>>>>>>        tFilelist[] FileListTables
84455>>>>>>>>>        Integer iCount iSize iItems
84455>>>>>>>>>        
84455>>>>>>>>>        Move 0 to iItems
84456>>>>>>>>>        Get pFileListArray to FileListTables
84457>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84458>>>>>>>>>        If (iSize <> 0) Begin
84460>>>>>>>>>            Decrement iSize
84461>>>>>>>>>            for iCount from 0 to iSize
84467>>>>>>>>>>
84467>>>>>>>>>                If (FileListTables[iCount].bErrorOpening = True) Begin
84469>>>>>>>>>                    Increment iItems
84470>>>>>>>>>                End
84470>>>>>>>>>>
84470>>>>>>>>>            Loop
84471>>>>>>>>>>
84471>>>>>>>>>        End
84471>>>>>>>>>>
84471>>>>>>>>>        Function_Return iItems    
84472>>>>>>>>>    End_Function 
84473>>>>>>>>>
84473>>>>>>>>>    // Checks all Alias Filelist entries for errors,
84473>>>>>>>>>    // and return them as a string array of RootNames.
84473>>>>>>>>>    Function _CountFileListAliasErrors Returns tFilelist[]
84475>>>>>>>>>        Integer iCount iItem
84475>>>>>>>>>        Handle hTable
84475>>>>>>>>>        Boolean bIsAlias bOK
84475>>>>>>>>>        String sRootName
84475>>>>>>>>>        tFilelist[] FileListArray
84475>>>>>>>>>        tFilelist[] FileListArray
84476>>>>>>>>>        
84476>>>>>>>>>        Move 0 to iCount
84477>>>>>>>>>        Move 0 to hTable
84478>>>>>>>>>        Repeat
84478>>>>>>>>>>
84478>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84481>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84483>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84484>>>>>>>>>                If (bIsAlias = True) Begin
84486>>>>>>>>>                    Get _FindAliasEntryError hTable to iItem
84487>>>>>>>>>                    If (iItem <> 0) Begin
84489>>>>>>>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84492>>>>>>>>>                        Move hTable    to FileListArray[iCount].hTable
84493>>>>>>>>>                        Move sRootName to FileListArray[iCount].sRootName
84494>>>>>>>>>                    End
84494>>>>>>>>>>
84494>>>>>>>>>                    Add iItem to iCount
84495>>>>>>>>>                End
84495>>>>>>>>>>
84495>>>>>>>>>            End
84495>>>>>>>>>>
84495>>>>>>>>>        Until (hTable = 0)
84497>>>>>>>>>        
84497>>>>>>>>>        Function_Return FileListArray
84498>>>>>>>>>    End_Function
84499>>>>>>>>>
84499>>>>>>>>>    // Helper function for _CountFileListAliasErrors.
84499>>>>>>>>>    // Checks to see if an Alias Filelist entry is correct
84499>>>>>>>>>    // What it does:
84499>>>>>>>>>    //  1. Checks that the Filelist entry is an Alias table
84499>>>>>>>>>    //  2. If an Alias, checks if the RootName points to a valid Table
84499>>>>>>>>>    Function _FindAliasEntryError Handle hTable Returns Integer
84501>>>>>>>>>        Handle hMasterTable
84501>>>>>>>>>        String sDataPath sDriver sLogicalNameAlias sRootNameAlias sNoDriverRootnameAlias sLogicalNameMaster sRootNameMaster sNoDriverRootnameMaster
84501>>>>>>>>>        Boolean bOK bFound bIsAlias bIsAliasSQL bIsMasterSQL bIsIntFile
84501>>>>>>>>>        Integer iRetval
84501>>>>>>>>>        
84501>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
84502>>>>>>>>>        If (bIsAlias = False) Begin
84504>>>>>>>>>            Function_Return 0
84505>>>>>>>>>        End
84505>>>>>>>>>>
84505>>>>>>>>>        
84505>>>>>>>>>        Move 0 to iRetval
84506>>>>>>>>>        Move False to bOK
84507>>>>>>>>>        Move False to bIsAliasSQL
84508>>>>>>>>>        Move False to bIsMasterSQL
84509>>>>>>>>>
84509>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84510>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootNameAlias
84513>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameAlias
84516>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
84517>>>>>>>>>        Get UtilAliasToMasterTableHandle hTable to hMasterTable
84518>>>>>>>>>        Move (hMasterTable <> 0) to bOK
84519>>>>>>>>>        If (bOK = True) Begin
84521>>>>>>>>>            Get _IsSQLEntry hTable       to bIsAliasSQL
84522>>>>>>>>>            Get _IsSQLEntry hMasterTable to bIsMasterSQL 
84523>>>>>>>>>            Move (bIsAliasSQL = bIsMasterSQL) to bOK
84524>>>>>>>>>        End
84524>>>>>>>>>>
84524>>>>>>>>>        
84524>>>>>>>>>        // Checks that the .int file exists in the Data folder
84524>>>>>>>>>        If (bIsIntFile = True) Begin
84526>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84527>>>>>>>>>            File_Exist (sDataPath + "\" + sNoDriverRootnameAlias) bOK
84528>>>>>>>>>        End
84528>>>>>>>>>>
84528>>>>>>>>>
84528>>>>>>>>>        If (bOK = False) Begin
84530>>>>>>>>>            Move 1 to iRetval
84531>>>>>>>>>        End
84531>>>>>>>>>>
84531>>>>>>>>>        Function_Return iRetval
84532>>>>>>>>>    End_Function
84533>>>>>>>>>        
84533>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84533>>>>>>>>>    // The returned path always ends with a "\"
84533>>>>>>>>>    Function psDataPathFirstPart Returns String
84535>>>>>>>>>        String sDataPath
84535>>>>>>>>>        Integer iCount
84535>>>>>>>>>
84535>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84536>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84537>>>>>>>>>        If (iCount > 1) Begin
84539>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84540>>>>>>>>>        End
84540>>>>>>>>>>
84540>>>>>>>>>        If (sDataPath <> "") Begin
84542>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84543>>>>>>>>>        End
84543>>>>>>>>>>
84543>>>>>>>>>
84543>>>>>>>>>        Function_Return sDataPath
84544>>>>>>>>>    End_Function
84545>>>>>>>>>
84545>>>>>>>>>    Function psLogTextFileWithPath Returns String
84547>>>>>>>>>        String sFileName
84547>>>>>>>>>        Handle hoLogFile
84547>>>>>>>>>        Get phoLogFile to hoLogFile
84548>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84549>>>>>>>>>        Function_Return sFileName
84550>>>>>>>>>    End_Function
84551>>>>>>>>>
84551>>>>>>>>>    Function phoLogFile Returns Handle
84553>>>>>>>>>        Handle hoLogFile   
84553>>>>>>>>>        Boolean bErr
84553>>>>>>>>>        
84553>>>>>>>>>        Move Err to bErr
84554>>>>>>>>>        Move 0 to hoLogFile
84555>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84556>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84557>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84559>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84560>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84561>>>>>>>>>        Move bErr to Err
84562>>>>>>>>>        
84562>>>>>>>>>        Function_Return hoLogFile
84563>>>>>>>>>    End_Function
84564>>>>>>>>>
84564>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84566>>>>>>>>>        Number nCurrentVersionUpdate
84566>>>>>>>>>
84566>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84567>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84569>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84570>>>>>>>>>
84570>>>>>>>>>        Function_Return nCurrentVersionUpdate
84571>>>>>>>>>    End_Function
84572>>>>>>>>>
84572>>>>>>>>>    Procedure LogError String sText Boolean bError
84574>>>>>>>>>        Handle hoLogFile
84574>>>>>>>>>        Number nCurrentVersionUpdate
84574>>>>>>>>>
84574>>>>>>>>>        Get phoLogFile to hoLogFile
84575>>>>>>>>>        If (hoLogFile = 0) Begin
84577>>>>>>>>>            Procedure_Return
84578>>>>>>>>>        End
84578>>>>>>>>>>
84578>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84579>>>>>>>>>
84579>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84580>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84581>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84582>>>>>>>>>    End_Procedure
84583>>>>>>>>>
84583>>>>>>>>>    Function pbContinueOnError Returns Boolean
84585>>>>>>>>>        Boolean bContinueOnError
84585>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84587>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84588>>>>>>>>>        End
84588>>>>>>>>>>
84588>>>>>>>>>        Function_Return bContinueOnError
84589>>>>>>>>>    End_Function
84590>>>>>>>>>
84590>>>>>>>>>
84590>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84592>>>>>>>>>        Integer iChIn iChOut // iCount
84592>>>>>>>>>        Boolean bExists
84592>>>>>>>>>        String sExistingColumn
84592>>>>>>>>>
84592>>>>>>>>>        Move False to bExists
84593>>>>>>>>>        Get Seq_New_Channel to iChIn
84594>>>>>>>>>        Get Seq_New_Channel to iChOut
84595>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84597>>>>>>>>>            Function_Return True
84598>>>>>>>>>        End
84598>>>>>>>>>>
84598>>>>>>>>>
84598>>>>>>>>>        Move False to Err
84599>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84599>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84601>>>>>>>>>        While (not(SeqEof))
84605>>>>>>>>>            Readln channel iChIn sExistingColumn
84607>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84609>>>>>>>>>                Move True to bExists
84610>>>>>>>>>            End
84610>>>>>>>>>>
84610>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84612>>>>>>>>>                Move True to SeqEof
84613>>>>>>>>>            End
84613>>>>>>>>>>
84613>>>>>>>>>        Loop
84614>>>>>>>>>>
84614>>>>>>>>>        Close_Input channel iChIn
84616>>>>>>>>>        Send Seq_Release_Channel iChIn
84617>>>>>>>>>
84617>>>>>>>>>        If (bExists = False) Begin
84619>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84621>>>>>>>>>            Writeln channel iChOut sColumnName
84624>>>>>>>>>            Close_Output channel iChOut
84626>>>>>>>>>            Send Seq_Release_Channel iChOut
84627>>>>>>>>>        End
84627>>>>>>>>>>
84627>>>>>>>>>
84627>>>>>>>>>        Function_Return (Err = False)
84628>>>>>>>>>    End_Function
84629>>>>>>>>>
84629>>>>>>>>>    // Changes source code files.
84629>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84629>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84629>>>>>>>>>    // to use a Connection ID.
84629>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84629>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84629>>>>>>>>>    // Returns True if no errors occured.
84629>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84631>>>>>>>>>        Integer iCh iRow iItems iCount
84631>>>>>>>>>        String sValue sRow
84631>>>>>>>>>        String[] sFileArray
84632>>>>>>>>>        Boolean bExists bIsActive bFileChange
84632>>>>>>>>>
84632>>>>>>>>>        Move False to Err
84633>>>>>>>>>        Move 0 to iRow
84634>>>>>>>>>        Move False to bFileChange
84635>>>>>>>>>
84635>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84637>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84638>>>>>>>>>        End
84638>>>>>>>>>>
84638>>>>>>>>>
84638>>>>>>>>>        Get vFilePathExists sFileName to bExists
84639>>>>>>>>>        If (bExists = False) Begin
84641>>>>>>>>>            If (bShowResult = True) Begin
84643>>>>>>>>>                If (bIsActive = True) Begin
84645>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84646>>>>>>>>>                End
84646>>>>>>>>>>
84646>>>>>>>>>                Else Begin
84647>>>>>>>>>                    Showln "File does not exist: " sFileName
84650>>>>>>>>>                End
84650>>>>>>>>>>
84650>>>>>>>>>            End
84650>>>>>>>>>>
84650>>>>>>>>>            Function_Return False
84651>>>>>>>>>        End
84651>>>>>>>>>>
84651>>>>>>>>>
84651>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84652>>>>>>>>>        If (iCh < 1) Begin
84654>>>>>>>>>            Function_Return False
84655>>>>>>>>>        End
84655>>>>>>>>>>
84655>>>>>>>>>
84655>>>>>>>>>        If (bShowResult = True) Begin
84657>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84659>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84660>>>>>>>>>                If (bIsActive = True) Begin
84662>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84663>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84664>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84665>>>>>>>>>                End
84665>>>>>>>>>>
84665>>>>>>>>>            End
84665>>>>>>>>>>
84665>>>>>>>>>            Else Begin
84666>>>>>>>>>                Showln ""
84668>>>>>>>>>                Showln "sFileName = " sFileName
84671>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84676>>>>>>>>>            End
84676>>>>>>>>>>
84676>>>>>>>>>        End
84676>>>>>>>>>>
84676>>>>>>>>>
84676>>>>>>>>>        While (not(SeqEof))
84680>>>>>>>>>            Readln channel iCh sRow
84682>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84684>>>>>>>>>                // Change the whole line to the new connection id:
84684>>>>>>>>>                Move sChangeTo to sRow 
84685>>>>>>>>>                Move True to bFileChange
84686>>>>>>>>>            End
84686>>>>>>>>>>
84686>>>>>>>>>            Move sRow to sFileArray[iRow]
84687>>>>>>>>>            Increment iRow
84688>>>>>>>>>        Loop
84689>>>>>>>>>>
84689>>>>>>>>>        Send Seq_Close_Channel iCh
84690>>>>>>>>>
84690>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84690>>>>>>>>>
84690>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84691>>>>>>>>>        If (iCh < 1) Begin
84693>>>>>>>>>            Function_Return False
84694>>>>>>>>>        End
84694>>>>>>>>>>
84694>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84695>>>>>>>>>        Decrement iItems
84696>>>>>>>>>
84696>>>>>>>>>        for iCount from 0 to iItems
84702>>>>>>>>>>
84702>>>>>>>>>            Move sFileArray[iCount] to sValue
84703>>>>>>>>>            Writeln channel iCh sValue
84706>>>>>>>>>        Loop
84707>>>>>>>>>>
84707>>>>>>>>>        Send Seq_Close_Channel iCh
84708>>>>>>>>>
84708>>>>>>>>>        Function_Return bFileChange
84709>>>>>>>>>    End_Function
84710>>>>>>>>>
84710>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84710>>>>>>>>>    // and opens it in "notepad.exe".
84710>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84710>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84710>>>>>>>>>    Procedure _UtilShowErrorList
84712>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84712>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84712>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84712>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84712>>>>>>>>>
84712>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84713>>>>>>>>>        Get vFolderFormat sPath to sPath
84714>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84715>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84716>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84717>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84718>>>>>>>>>            If (iRows > 0) Begin
84720>>>>>>>>>                Decrement iRows
84721>>>>>>>>>                for iCount from 0 to iRows
84727>>>>>>>>>>
84727>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84728>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84729>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84730>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84736>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84740>>>>>>>>>                Loop
84741>>>>>>>>>>
84741>>>>>>>>>            End
84741>>>>>>>>>>
84741>>>>>>>>>        Send Seq_Close_Channel iCh
84742>>>>>>>>>
84742>>>>>>>>>        If (iRows > 0) Begin
84744>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84745>>>>>>>>>        End
84745>>>>>>>>>>
84745>>>>>>>>>    End_Procedure
84746>>>>>>>>>
84746>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84746>>>>>>>>>    // and the table needs to exist as an SQL table.
84746>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84748>>>>>>>>>        String sRootName sDriverID
84748>>>>>>>>>        Boolean bIsSQL
84748>>>>>>>>>
84748>>>>>>>>>        Move False to bIsSQL
84749>>>>>>>>>        If (hTable > 0) Begin
84751>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84754>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84755>>>>>>>>>            If (bIsSQL = True) Begin
84757>>>>>>>>>                Get psDriverID to sDriverID
84758>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84759>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84760>>>>>>>>>            End
84760>>>>>>>>>>
84760>>>>>>>>>        End
84760>>>>>>>>>>
84760>>>>>>>>>
84760>>>>>>>>>        Function_Return bIsSQL
84761>>>>>>>>>    End_Function
84762>>>>>>>>>
84762>>>>>>>>>    // Note: This version uses the pasSQLDataTables array(!)
84762>>>>>>>>>    //       Thus that property needs to have been initialized before
84762>>>>>>>>>    //       calling this function.
84762>>>>>>>>>    Function _UtilTableIsSql_Ex Handle hTable Returns Boolean
84764>>>>>>>>>        String sRootName sDriverID
84764>>>>>>>>>        Boolean bIsSQL
84764>>>>>>>>>
84764>>>>>>>>>        Move False to bIsSQL
84765>>>>>>>>>        If (hTable > 0) Begin
84767>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84770>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84771>>>>>>>>>            If (bIsSQL = True) Begin
84773>>>>>>>>>                Get psDriverID to sDriverID
84774>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84775>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists_Ex sRootName sDriverID to bIsSQL
84776>>>>>>>>>            End
84776>>>>>>>>>>
84776>>>>>>>>>        End
84776>>>>>>>>>>
84776>>>>>>>>>
84776>>>>>>>>>        Function_Return bIsSQL
84777>>>>>>>>>    End_Function
84778>>>>>>>>>
84778>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84780>>>>>>>>>        Boolean bIsSQL
84780>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84781>>>>>>>>>        Function_Return bIsSQL
84782>>>>>>>>>    End_Function
84783>>>>>>>>>
84783>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84783>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84785>>>>>>>>>        String sDatabase sSchema sVal
84785>>>>>>>>>        Boolean bExists
84785>>>>>>>>>        String[] asTablesArray
84786>>>>>>>>>        Integer iItem
84786>>>>>>>>>
84786>>>>>>>>>        Move False to bExists
84787>>>>>>>>>        Get psDatabase to sDatabase
84788>>>>>>>>>        Get psSchema   to sSchema
84789>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84791>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84792>>>>>>>>>>
84792>>>>>>>>>            Function_Return False
84793>>>>>>>>>        End
84793>>>>>>>>>>
84793>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
84794>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84795>>>>>>>>>        If (iItem <> -1) Begin
84797>>>>>>>>>            Move True to bExists
84798>>>>>>>>>        End
84798>>>>>>>>>>
84798>>>>>>>>>        Function_Return bExists
84799>>>>>>>>>    End_Function
84800>>>>>>>>>
84800>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84800>>>>>>>>>    // This alternative is much faster as it first enumerates all SQL tables
84800>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists_Ex String sTableName String sDriverID Returns Boolean
84802>>>>>>>>>        String sDatabase sSchema sVal
84802>>>>>>>>>        Boolean bExists
84802>>>>>>>>>        String[] asTablesArray
84803>>>>>>>>>        Integer iItem
84803>>>>>>>>>
84803>>>>>>>>>        Move False to bExists
84804>>>>>>>>>        Get psDatabase to sDatabase
84805>>>>>>>>>        Get psSchema   to sSchema
84806>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84808>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84809>>>>>>>>>>
84809>>>>>>>>>            Function_Return False
84810>>>>>>>>>        End
84810>>>>>>>>>>
84810>>>>>>>>>        Get pasSQLDataTables to asTablesArray
84811>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84812>>>>>>>>>        If (iItem <> -1) Begin
84814>>>>>>>>>            Move True to bExists
84815>>>>>>>>>        End
84815>>>>>>>>>>
84815>>>>>>>>>        Function_Return bExists
84816>>>>>>>>>    End_Function
84817>>>>>>>>>
84817>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84817>>>>>>>>>    // that the embedded .dat file exists on disk.
84817>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84819>>>>>>>>>        Boolean bExists bIsEmbedded
84819>>>>>>>>>        String sDataPath sRootName
84819>>>>>>>>>
84819>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84820>>>>>>>>>        If (bExists = False) Begin
84822>>>>>>>>>            Function_Return False
84823>>>>>>>>>        End
84823>>>>>>>>>>
84823>>>>>>>>>
84823>>>>>>>>>        Move False to bIsEmbedded
84824>>>>>>>>>        If (hTable > 0) Begin
84826>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84829>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84830>>>>>>>>>        End
84830>>>>>>>>>>
84830>>>>>>>>>        If (bIsEmbedded = True) Begin
84832>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84833>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84834>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84835>>>>>>>>>        End
84835>>>>>>>>>>
84835>>>>>>>>>
84835>>>>>>>>>        Function_Return bIsEmbedded
84836>>>>>>>>>    End_Function
84837>>>>>>>>>
84837>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84837>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84839>>>>>>>>>        Date dDate
84839>>>>>>>>>        Integer iYY iHH iMM iSS
84839>>>>>>>>>        Boolean bExists
84839>>>>>>>>>        DateTime dtFileDateTime
84839>>>>>>>>>
84839>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84840>>>>>>>>>        Get vFilePathExists sFileName to bExists
84841>>>>>>>>>        If (bExists = True) Begin
84843>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84847>>>>>>>>>            Move dDate            to dtFileDateTime
84848>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84849>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84850>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84851>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84852>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84853>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84854>>>>>>>>>        End
84854>>>>>>>>>>
84854>>>>>>>>>
84854>>>>>>>>>        Function_Return dtFileDateTime
84855>>>>>>>>>    End_Function
84856>>>>>>>>>
84856>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84856>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84858>>>>>>>>>        Boolean bExists bIsNewer
84858>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84858>>>>>>>>>
84858>>>>>>>>>        Move False to bIsNewer
84859>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84860>>>>>>>>>        If (bExists = True) Begin
84862>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84863>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84864>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84865>>>>>>>>>        End
84865>>>>>>>>>>
84865>>>>>>>>>        Function_Return bIsNewer
84866>>>>>>>>>    End_Function
84867>>>>>>>>>
84867>>>>>>>>>End_Class
84868>>>>>>>
84868>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84868>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84869>>>>>>>
84869>>>>>>>    Procedure Construct_Object
84871>>>>>>>        Forward Send Construct_Object
84873>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84874>>>>>>>    End_Procedure
84875>>>>>>>
84875>>>>>>>    Procedure End_Construct_Object
84877>>>>>>>        Forward Send End_Construct_Object
84879>>>>>>>    End_Procedure
84880>>>>>>>
84880>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84880>>>>>>>    //
84880>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84880>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84882>>>>>>>        Function_Return False
84883>>>>>>>    End_Function
84884>>>>>>>
84884>>>>>>>    // Function for creating a new *Database*.
84884>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84884>>>>>>>    // Returns True if successful.
84884>>>>>>>    // ToDo: Currently only works for MS-SQL...
84884>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84886>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84886>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84886>>>>>>>        Handle hConnection hStmt hoSQLManager
84886>>>>>>>        Integer iFetchResult iDbType
84886>>>>>>>        Boolean bOK bExists
84886>>>>>>>
84886>>>>>>>        Get piDbType to iDbType
84887>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84889>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84890>>>>>>>>
84890>>>>>>>            Function_Return False
84891>>>>>>>        End
84891>>>>>>>>
84891>>>>>>>
84891>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84892>>>>>>>        If (bExists = True) Begin
84894>>>>>>>            Function_Return True
84895>>>>>>>        End
84895>>>>>>>>
84895>>>>>>>
84895>>>>>>>        Get phoSQLManager to hoSQLManager
84896>>>>>>>
84896>>>>>>>        Get psConnectionID     to sConnectionID
84897>>>>>>>        Get psConnectionString to sConnectionString
84898>>>>>>>        Move 0 to LastErr
84899>>>>>>>
84899>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84901>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84901>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84901>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84901>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84901>>>>>>>//                If (iPos > 0) Begin
84901>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84901>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84901>>>>>>>//                End
84901>>>>>>>//            End
84901>>>>>>>        End
84901>>>>>>>>
84901>>>>>>>
84901>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84902>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84903>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84904>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84906>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84907>>>>>>>>
84907>>>>>>>            Function_Return False
84908>>>>>>>        End
84908>>>>>>>>
84908>>>>>>>
84908>>>>>>>        Get SqlOpen of hConnection to hStmt
84909>>>>>>>
84909>>>>>>>        If (hStmt = 0) Begin
84911>>>>>>>            Send SqlDisconnect of hoSQLManager
84912>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84913>>>>>>>>
84913>>>>>>>            Function_Return False
84914>>>>>>>        End
84914>>>>>>>>
84914>>>>>>>
84914>>>>>>>        Get psCollation to sCollation
84915>>>>>>>
84915>>>>>>>        Case Begin
84915>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84917>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84918>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84919>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84920>>>>>>>
84920>>>>>>>                // Check if database exists
84920>>>>>>>                Send SqlExecDirect of hStmt sSQL
84921>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84922>>>>>>>                Send SqlClose of hStmt
84923>>>>>>>                Send SqlDisconnect of hConnection
84924>>>>>>>                // If database already exists we're out of here!
84924>>>>>>>                // Note that we return True as this is not an error.
84924>>>>>>>                If (iFetchResult > 0) Begin
84926>>>>>>>                    Function_Return True
84927>>>>>>>                End
84927>>>>>>>>
84927>>>>>>>                // Database doesn't exist, create it.
84927>>>>>>>                If (iFetchResult = 0) Begin
84929>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84930>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84931>>>>>>>                    If (sCollation <> "") Begin
84933>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84934>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84935>>>>>>>                    End
84935>>>>>>>>
84935>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84936>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84937>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84939>>>>>>>                        Function_Return False
84940>>>>>>>                    End
84940>>>>>>>>
84940>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84940>>>>>>>                    Sleep 1
84941>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84942>>>>>>>                End
84942>>>>>>>>
84942>>>>>>>                Case Break
84943>>>>>>>
84943>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84946>>>>>>>                // ToDo: How should this be set/checked?
84946>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84946>>>>>>>//                    Set psCollation to "utf8"
84946>>>>>>>//                End
84946>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84946>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84947>>>>>>>                Case Break
84948>>>>>>>
84948>>>>>>>            Case Else
84948>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84949>>>>>>>>
84949>>>>>>>        Case End
84949>>>>>>>
84949>>>>>>>        If (Err = False) Begin
84951>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84952>>>>>>>        End
84952>>>>>>>>
84952>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84952>>>>>>>        // the one we just created.
84952>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84954>>>>>>>            Set psDatabase to sDatabase
84955>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84955>>>>>>>            If (bPermanantly = True) Begin
84957>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84959>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84960>>>>>>>                End
84960>>>>>>>>
84960>>>>>>>            End
84960>>>>>>>>
84960>>>>>>>        End
84960>>>>>>>>
84960>>>>>>>
84960>>>>>>>        If (Err = False) Begin
84962>>>>>>>            Send ResetFillSQLTables
84963>>>>>>>        End
84963>>>>>>>>
84963>>>>>>>        Function_Return (Err = False)
84964>>>>>>>    End_Function
84965>>>>>>>
84965>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84965>>>>>>>    // will be used.
84965>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84967>>>>>>>        Boolean bOK bExists bShowProgress bErr
84967>>>>>>>        String sStatement sDriverID
84967>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84967>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84967>>>>>>>        Integer iDbType
84967>>>>>>>
84967>>>>>>>        If (sDatabase = "") Begin
84969>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84970>>>>>>>>
84970>>>>>>>            Function_Return False
84971>>>>>>>        End
84971>>>>>>>>
84971>>>>>>>        If (sBackupName = "") Begin
84973>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84974>>>>>>>>
84974>>>>>>>            Function_Return False
84975>>>>>>>        End
84975>>>>>>>>
84975>>>>>>>
84975>>>>>>>        // Create backup-folder if it doesn't exist
84975>>>>>>>        Get vFolderExists sPath to bExists
84976>>>>>>>        If (bExists = False and sPath <> "") Begin
84978>>>>>>>            Get vCreateDirectory sPath to bErr
84979>>>>>>>            If (bErr = True) Begin
84981>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84982>>>>>>>>
84982>>>>>>>                Function_Return False
84983>>>>>>>            End
84983>>>>>>>>
84983>>>>>>>        End
84983>>>>>>>>
84983>>>>>>>        // Make sure the path ends with a back-slash
84983>>>>>>>        If (sPath <> "") Begin
84985>>>>>>>            Get vFolderFormat sPath to sPath
84986>>>>>>>        End
84986>>>>>>>>
84986>>>>>>>
84986>>>>>>>        Get psDriverID to sDriverID
84987>>>>>>>        Get piDbType   to iDbType
84988>>>>>>>        If (num_arguments > 3) Begin
84990>>>>>>>            Move bShowProg to bShowProgress
84991>>>>>>>        End
84991>>>>>>>>
84991>>>>>>>
84991>>>>>>>        Case Begin
84991>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84993>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84993>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84993>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84994>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84995>>>>>>>
84995>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84996>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84997>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84998>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84999>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
85000>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
85001>>>>>>>                Case Break
85002>>>>>>>            Case Else
85002>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
85003>>>>>>>        Case End
85003>>>>>>>        
85003>>>>>>>        Function_Return bOK
85004>>>>>>>    End_Function
85005>>>>>>>
85005>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
85007>>>>>>>        String sStatement sDriverID sRetval
85007>>>>>>>        tSQLScriptArray SQLScriptArray
85007>>>>>>>        tSQLScriptArray SQLScriptArray
85007>>>>>>>        Integer iDbType iRows iFetchResult
85007>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
85007>>>>>>>        tSQLConnection SQLConnection
85007>>>>>>>        tSQLConnection SQLConnection
85007>>>>>>>
85007>>>>>>>        If (sDatabase = "") Begin
85009>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
85010>>>>>>>>
85010>>>>>>>            Function_Return ""
85011>>>>>>>        End
85011>>>>>>>>
85011>>>>>>>
85011>>>>>>>        Move "" to sRetval
85012>>>>>>>        Get psDriverID to sDriverID
85013>>>>>>>        Get piDbType   to iDbType
85014>>>>>>>
85014>>>>>>>        Case Begin
85014>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85016>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
85016>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
85017>>>>>>>
85017>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
85018>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
85019>>>>>>>                Get phoSQLManager to hoSQLHandler
85020>>>>>>>
85020>>>>>>>                If (hoSQLHandler <> 0) Begin
85022>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85023>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
85024>>>>>>>
85024>>>>>>>                    If (hoSQLConnect <> 0) Begin
85026>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
85027>>>>>>>                        If (hstmt <> 0) Begin
85029>>>>>>>                            Send SqlExecDirect of hstmt sStatement
85030>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
85031>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
85032>>>>>>>                            If (iFetchResult <> 0) Begin
85034>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
85035>>>>>>>                            End
85035>>>>>>>>
85035>>>>>>>                            Send SQLClose of hstmt
85036>>>>>>>                        End
85036>>>>>>>>
85036>>>>>>>                        Send SQLDisconnect of hoSQLConnect
85037>>>>>>>                    End
85037>>>>>>>>
85037>>>>>>>                End
85037>>>>>>>>
85037>>>>>>>                Case Break
85038>>>>>>>            Case Else
85038>>>>>>>                If (bSilent = False) Begin
85040>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
85041>>>>>>>                End
85041>>>>>>>>
85041>>>>>>>        Case End
85041>>>>>>>
85041>>>>>>>        Function_Return sRetval
85042>>>>>>>    End_Function
85043>>>>>>> 
85043>>>>>>>    // To change the collation sequence for an existing database.
85043>>>>>>>    // Please take a backup copy of the database first, then make sure *no* users
85043>>>>>>>    // are using the database!
85043>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sCollation Boolean bCreateScriptFile Boolean bBackup Boolean bSilent Returns Boolean
85045>>>>>>>        String sStatement sDriverID sRetval
85045>>>>>>>        Integer iDbType iSize iCount
85045>>>>>>>        Boolean bOK
85045>>>>>>>        tSQLScriptArray SQLScriptArray
85045>>>>>>>        tSQLScriptArray SQLScriptArray
85045>>>>>>>        tSQLConnection SQLConnection
85045>>>>>>>        tSQLConnection SQLConnection
85045>>>>>>>
85045>>>>>>>        If (sDatabase = "") Begin
85047>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85048>>>>>>>>
85048>>>>>>>            Function_Return ""
85049>>>>>>>        End
85049>>>>>>>>
85049>>>>>>>
85049>>>>>>>        Move False to Err
85050>>>>>>>        Move False to bOK
85051>>>>>>>        Move "" to sRetval
85052>>>>>>>        Get psDriverID to sDriverID
85053>>>>>>>        Get piDbType   to iDbType
85054>>>>>>>
85054>>>>>>>        Case Begin
85054>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85056>>>>>>>                SQLIncludeScriptFile ..\Scripts\ChangeMSSQLCollation.sql as ChangeMSSQLCollation.sql
85056>>>>>>>                Get _SqlUtilReadResource "ChangeMSSQLCollation.sql" sDriverID False to SQLScriptArray
85057>>>>>>>
85057>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
85058>>>>>>>                Decrement iSize
85059>>>>>>>                
85059>>>>>>>                // Parameter replacements in the script: sDatabase, sCollation.
85059>>>>>>>                For iCount from 0 to iSize
85065>>>>>>>>
85065>>>>>>>                    If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
85067>>>>>>>                        Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabase))) to SQLScriptArray.sSQLScriptArray[iCount]
85068>>>>>>>                    End
85068>>>>>>>>
85068>>>>>>>                    If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
85070>>>>>>>                        Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
85071>>>>>>>                    End
85071>>>>>>>>
85071>>>>>>>                    If (bBackup = False) Begin
85073>>>>>>>                        Move (Replace("DECLARE @ShouldBackup BIT = 1", SQLScriptArray.sSQLScriptArray[iCount], String("DECLARE @ShouldBackup BIT = 0"))) to SQLScriptArray.sSQLScriptArray[iCount]                        
85074>>>>>>>                    End
85074>>>>>>>>
85074>>>>>>>                Loop
85075>>>>>>>>
85075>>>>>>>
85075>>>>>>>                Set Title_Text of ghoStatusPanel to "Running SQL script to change collating sequence."
85076>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile "SQLChangeCollation.sql" to bOK
85077>>>>>>>
85077>>>>>>>                Case Break
85078>>>>>>>            Case Else 
85078>>>>>>>                Move False to bOK
85079>>>>>>>                If (bSilent = False) Begin
85081>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationChange function is currently not implemented for selected driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
85082>>>>>>>                End
85082>>>>>>>>
85082>>>>>>>        Case End
85082>>>>>>>
85082>>>>>>>        Function_Return bOK
85083>>>>>>>    End_Function
85084>>>>>>>  
85084>>>>>>>    Function SqlDatabaseCollationSetNew String sDatabase String sSQLCollation Returns Boolean
85086>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
85086>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
85086>>>>>>>        Handle hConnection hStmt hoSQLManager
85086>>>>>>>        Integer iDbType // iFetchResult
85086>>>>>>>
85086>>>>>>>        If (sDatabase = "") Begin
85088>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85089>>>>>>>>
85089>>>>>>>            Function_Return False
85090>>>>>>>        End
85090>>>>>>>>
85090>>>>>>>
85090>>>>>>>        If (sSQLCollation = "") Begin
85092>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85093>>>>>>>>
85093>>>>>>>            Function_Return False
85094>>>>>>>        End
85094>>>>>>>>
85094>>>>>>>
85094>>>>>>>        Get psDriverID to sDriverID
85095>>>>>>>        Get piDbType   to iDbType
85096>>>>>>>
85096>>>>>>>        Get phoSQLManager to hoSQLManager
85097>>>>>>>        Get psConnectionID     to sConnectionID
85098>>>>>>>        Get psConnectionString to sConnectionString
85099>>>>>>>        Move 0 to LastErr
85100>>>>>>>
85100>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85101>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
85102>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85103>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
85105>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
85106>>>>>>>>
85106>>>>>>>            Function_Return False
85107>>>>>>>        End
85107>>>>>>>>
85107>>>>>>>
85107>>>>>>>        Get SqlOpen of hConnection to hStmt
85108>>>>>>>
85108>>>>>>>        If (hStmt = 0) Begin
85110>>>>>>>            Send SqlDisconnect of hoSQLManager
85111>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
85112>>>>>>>>
85112>>>>>>>            Function_Return False
85113>>>>>>>        End
85113>>>>>>>>
85113>>>>>>>
85113>>>>>>>        // Check if collation already exists
85113>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
85114>>>>>>>        // If the current collate is the same as the new; do nothing.
85114>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
85116>>>>>>>            Function_Return True
85117>>>>>>>        End
85117>>>>>>>>
85117>>>>>>>
85117>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
85118>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
85119>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
85120>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
85121>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
85122>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
85123>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
85124>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
85125>>>>>>>
85125>>>>>>>        // MS-SQL Syntax:
85125>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
85125>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
85125>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
85125>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
85126>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85127>>>>>>>
85127>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85128>>>>>>>        // Set new collating sequence:
85128>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
85129>>>>>>>        Move (String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
85130>>>>>>>        // Reset to Mult_User
85130>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
85131>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85132>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
85134>>>>>>>           Function_Return False
85135>>>>>>>        End
85135>>>>>>>>
85135>>>>>>>
85135>>>>>>>        Function_Return (Err = False)
85136>>>>>>>    End_Function
85137>>>>>>>
85137>>>>>>>
85137>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85137>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
85139>>>>>>>        Function_Return False
85140>>>>>>>    End_Function
85141>>>>>>>
85141>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
85141>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
85141>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
85141>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
85141>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
85141>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
85143>>>>>>>        Handle hToTable
85143>>>>>>>        Boolean bOK bExists bOpened bCopyData
85143>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
85143>>>>>>>        tSQLConnection SQLConnection
85143>>>>>>>        tSQLConnection SQLConnection
85143>>>>>>>        Integer iPos iMaxRecords
85143>>>>>>>
85143>>>>>>>        Get psDriverID to sDriverID
85144>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85145>>>>>>>        If (bExists = False) Begin
85147>>>>>>>            Function_Return False
85148>>>>>>>        End
85148>>>>>>>>
85148>>>>>>>
85148>>>>>>>        If (num_arguments > 1) Begin
85150>>>>>>>            Move bCpyDat to bCopyData
85151>>>>>>>        End
85151>>>>>>>>
85151>>>>>>>        Else Begin
85152>>>>>>>            Move False to bCopyData
85153>>>>>>>        End
85153>>>>>>>>
85153>>>>>>>
85153>>>>>>>        Open hTable
85155>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85158>>>>>>>        If (bOpened = False) Begin
85160>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
85161>>>>>>>>
85161>>>>>>>            Function_Return False
85162>>>>>>>        End
85162>>>>>>>>
85162>>>>>>>        Move 0 to hToTable
85163>>>>>>>
85163>>>>>>>        Move 16711679 to iMaxRecords
85164>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85167>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
85168>>>>>>>        If (iPos > 0) Begin
85170>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
85171>>>>>>>        End
85171>>>>>>>>
85171>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85174>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
85175>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
85176>>>>>>>
85176>>>>>>>        If (ghoProgressBar <> 0) Begin
85178>>>>>>>            Send DoAdvance of ghoProgressBar
85179>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
85180>>>>>>>        End
85180>>>>>>>>
85180>>>>>>>
85180>>>>>>>        Move False to Err
85181>>>>>>>
85181>>>>>>>        Structure_Start hToTable DATAFLEX_ID
85182>>>>>>>            Structure_Copy hTable to hToTable
85183>>>>>>>
85183>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
85186>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
85189>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
85192>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
85195>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
85198>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85199>>>>>>>
85199>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85201>>>>>>>
85201>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85202>>>>>>>        Move (not(Err)) to bOK
85203>>>>>>>        If (bOK = True and bCopyData = True) Begin
85205>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
85206>>>>>>>        End
85206>>>>>>>>
85206>>>>>>>
85206>>>>>>>        // This must be after copying data...
85206>>>>>>>        If (Err = False) Begin
85208>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85211>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85214>>>>>>>        End
85214>>>>>>>>
85214>>>>>>>        Move (not(Err)) to bOK
85215>>>>>>>
85215>>>>>>>        Function_Return (bOK = True)
85216>>>>>>>    End_Function
85217>>>>>>>
85217>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
85217>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85217>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
85219>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
85219>>>>>>>        Integer iDbType
85219>>>>>>>        Boolean bExists
85219>>>>>>>
85219>>>>>>>        Get psDriverID to sDriverID
85220>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85221>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85222>>>>>>>        If (bExists = True) Begin
85224>>>>>>>            Function_Return False
85225>>>>>>>        End
85225>>>>>>>>
85225>>>>>>>
85225>>>>>>>        Get psDataPathFirstPart to sPath
85226>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85227>>>>>>>
85227>>>>>>>        Get piDbType to iDbType
85228>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85229>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85230>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85231>>>>>>>
85231>>>>>>>        Move False to Err
85232>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85233>>>>>>>
85233>>>>>>>        If (Err = False) Begin
85235>>>>>>>            Send ResetFillSQLTables
85236>>>>>>>        End
85236>>>>>>>>
85236>>>>>>>        Function_Return (Err = False)
85237>>>>>>>    End_Function
85238>>>>>>>
85238>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
85238>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85238>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
85240>>>>>>>        String sSQLString sPath sCreateTable sDriverID
85240>>>>>>>        Integer iDbType
85240>>>>>>>        Boolean bExists
85240>>>>>>>
85240>>>>>>>        Get psDriverID to sDriverID
85241>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85242>>>>>>>        If (bExists = True) Begin
85244>>>>>>>            Function_Return False
85245>>>>>>>        End
85245>>>>>>>>
85245>>>>>>>
85245>>>>>>>        Get psDataPathFirstPart to sPath
85246>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85247>>>>>>>        If (bExists = True) Begin
85249>>>>>>>            // ToDo: What should we do if an .int file already exists?
85249>>>>>>>        End
85249>>>>>>>>
85249>>>>>>>
85249>>>>>>>        Get piDbType to iDbType
85250>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85251>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85252>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85253>>>>>>>
85253>>>>>>>        Move False to Err
85254>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85255>>>>>>>
85255>>>>>>>        If (Err = False) Begin
85257>>>>>>>            Send ResetFillSQLTables
85258>>>>>>>        End
85258>>>>>>>>
85258>>>>>>>        Function_Return (Err = False)
85259>>>>>>>    End_Function
85260>>>>>>>    
85260>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
85260>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
85260>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
85262>>>>>>>        Boolean bOK                                                            
85262>>>>>>>        String sStatement
85262>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
85263>>>>>>>        Function_Return bOK
85264>>>>>>>    End_Function
85265>>>>>>>    
85265>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
85265>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
85265>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
85265>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
85267>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
85267>>>>>>>        Integer iRetval iDbType
85267>>>>>>>        Boolean bExists bOK
85267>>>>>>>
85267>>>>>>>        Get psDriverID to sDriverID
85268>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85269>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85270>>>>>>>        If (bExists = False) Begin
85272>>>>>>>            Function_Return False
85273>>>>>>>        End
85273>>>>>>>>
85273>>>>>>>
85273>>>>>>>        Get psDataPathFirstPart to sPath
85274>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85275>>>>>>>
85275>>>>>>>        Get piDbType to iDbType
85276>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85277>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85278>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85279>>>>>>>
85279>>>>>>>        Move False to Err
85280>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85281>>>>>>>
85281>>>>>>>        // We also need to remove the cache-file since the table has been changed
85281>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85282>>>>>>>
85282>>>>>>>        If (Err = False) Begin
85284>>>>>>>            Send ResetFillSQLTables
85285>>>>>>>        End
85285>>>>>>>>
85285>>>>>>>        Function_Return (Err = False)
85286>>>>>>>    End_Function
85287>>>>>>>
85287>>>>>>>    // First deletes the data cache file and then drops the passed data table.
85287>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
85289>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
85289>>>>>>>        Integer iRetval iDbType
85289>>>>>>>        Boolean bOK
85289>>>>>>>
85289>>>>>>>        Get psDriverID to sDriverID
85290>>>>>>>        Get psDataPathFirstPart to sPath
85291>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85292>>>>>>>
85292>>>>>>>        Get piDbType to iDbType
85293>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85294>>>>>>>        Get psSchema to sSchema
85295>>>>>>>        If (sSchema = "") Begin
85297>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85298>>>>>>>        End
85298>>>>>>>>
85298>>>>>>>        Move (Uppercase(sTableName)) to sVal
85299>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85301>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85302>>>>>>>        End
85302>>>>>>>>
85302>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85303>>>>>>>
85303>>>>>>>        Move False to Err
85304>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85305>>>>>>>
85305>>>>>>>        // We also need to remove the cache-file since the table has been changed
85305>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85306>>>>>>>
85306>>>>>>>        Function_Return (Err = False)
85307>>>>>>>    End_Function
85308>>>>>>>
85308>>>>>>>    // *** Sql View Messages ***
85308>>>>>>>
85308>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
85308>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
85310>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
85310>>>>>>>        Integer iRetval
85310>>>>>>>        Boolean bOK
85310>>>>>>>
85310>>>>>>>        Get psDriverID to sDriverID
85311>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
85312>>>>>>>
85312>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
85313>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
85314>>>>>>>        Set psSQLStatementString to sSQLString
85315>>>>>>>
85315>>>>>>>        // As we don't check if the view exist or not, it might happen
85315>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
85315>>>>>>>        Move False to Err
85316>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85317>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85318>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85319>>>>>>>        Move 0 to LastErr
85320>>>>>>>
85320>>>>>>>        // We also need to remove the cache-file since the table has been changed
85320>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
85321>>>>>>>
85321>>>>>>>        Function_Return (Err = False)
85322>>>>>>>    End_Function
85323>>>>>>>
85323>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
85325>>>>>>>        Boolean bOK
85325>>>>>>>        Integer iDbType
85325>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
85325>>>>>>>
85325>>>>>>>        Get psDriverID to sDriverID
85326>>>>>>>        Get piDbType   to iDbType
85327>>>>>>>
85327>>>>>>>        Case Begin
85327>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85329>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85330>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85331>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85332>>>>>>>            Break
85333>>>>>>>
85333>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85336>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85337>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85338>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
85339>>>>>>>            Break
85340>>>>>>>
85340>>>>>>>            Case (iDbType = EN_DbTypeOracle)
85343>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85344>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85345>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85346>>>>>>>            Break
85347>>>>>>>
85347>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85350>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85351>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85352>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85353>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
85354>>>>>>>            Break
85355>>>>>>>
85355>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85358>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85359>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85360>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
85361>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85362>>>>>>>            Break
85363>>>>>>>        Case End
85363>>>>>>>
85363>>>>>>>        Move False to Err
85364>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85365>>>>>>>        Move (Err = False) to bOK
85366>>>>>>>
85366>>>>>>>        Function_Return bOK
85367>>>>>>>    End_Function
85368>>>>>>>
85368>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85368>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
85370>>>>>>>        Function_Return False
85371>>>>>>>    End_Function
85372>>>>>>>
85372>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
85372>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85374>>>>>>>        Integer iLength iDecimals
85374>>>>>>>        String sColumnValue
85374>>>>>>>        String sTableName sDriverID
85374>>>>>>>        Boolean bOK bInitializeValue
85374>>>>>>>
85374>>>>>>>        Get psDriverID to sDriverID
85375>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85376>>>>>>>        If (bOK = False) Begin
85378>>>>>>>            Function_Return False
85379>>>>>>>        End
85379>>>>>>>>
85379>>>>>>>
85379>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85380>>>>>>>        If (sTableName = "") Begin
85382>>>>>>>            Function_Return False
85383>>>>>>>        End
85383>>>>>>>>
85383>>>>>>>
85383>>>>>>>        Move iLen         to iLength
85384>>>>>>>        If (num_arguments > 4) Begin
85386>>>>>>>            Move iDec     to iDecimals
85387>>>>>>>            Move bInitVal to bInitializeValue
85388>>>>>>>            Move sColVal  to sColumnValue
85389>>>>>>>        End
85389>>>>>>>>
85389>>>>>>>        Else Begin
85390>>>>>>>            Move 0        to iDecimals
85391>>>>>>>            Move False    to bInitializeValue
85392>>>>>>>            Move ""       to sColumnValue
85393>>>>>>>        End
85393>>>>>>>>
85393>>>>>>>
85393>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLength iDecimals bInitializeValue sColumnValue to bOK
85394>>>>>>>
85394>>>>>>>        Function_Return bOK
85395>>>>>>>    End_Function
85396>>>>>>>
85396>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
85396>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85398>>>>>>>        Integer iDbType iLength iDecimals iDriver
85398>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
85398>>>>>>>        String sDriverID sNotNull
85398>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
85398>>>>>>>        Handle hTable
85398>>>>>>>
85398>>>>>>>        Get psDriverID to sDriverID
85399>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85400>>>>>>>        If (bOK = False) Begin
85402>>>>>>>            Function_Return True
85403>>>>>>>        End
85403>>>>>>>>
85403>>>>>>>
85403>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85404>>>>>>>        If (hTable = 0) Begin
85406>>>>>>>            Get NextFreeFilelistSlot to hTable
85407>>>>>>>        End
85407>>>>>>>>
85407>>>>>>>
85407>>>>>>>        Get piDbType to iDbType
85408>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
85408>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85409>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
85411>>>>>>>            Function_Return True
85412>>>>>>>        End
85412>>>>>>>>
85412>>>>>>>
85412>>>>>>>        Get DriverIndex sDriverID to iDriver
85413>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85416>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85419>>>>>>>
85419>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85420>>>>>>>        If (num_arguments > 3) Begin
85422>>>>>>>            Move iLen     to iLength
85423>>>>>>>            Move iDec     to iDecimals
85424>>>>>>>            Move bInitVal to bInitializeValue
85425>>>>>>>            Move sColVal  to sColumnValue
85426>>>>>>>        End
85426>>>>>>>>
85426>>>>>>>
85426>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
85427>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85428>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85429>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85430>>>>>>>
85430>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85431>>>>>>>        If (bFixed = False) Begin
85433>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85434>>>>>>>        End
85434>>>>>>>>
85434>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85435>>>>>>>
85435>>>>>>>        Move False to Err
85436>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85437>>>>>>>
85437>>>>>>>        If (bInitializeValue = True and Err = False) Begin
85439>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
85440>>>>>>>        End
85440>>>>>>>>
85440>>>>>>>
85440>>>>>>>        If (Err = False) Begin
85442>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
85443>>>>>>>        End
85443>>>>>>>>
85443>>>>>>>
85443>>>>>>>        Move (not(Err)) to bRetval
85444>>>>>>>
85444>>>>>>>        // We also need to remove the cache-file since the table has been changed
85444>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85445>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85448>>>>>>>
85448>>>>>>>        Function_Return bRetval
85449>>>>>>>    End_Function
85450>>>>>>>
85450>>>>>>>    // To update all current rows for a table column with a common value.
85450>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
85452>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
85452>>>>>>>        Boolean bRetval bSQLDriver
85452>>>>>>>        Integer iCurrErr iDbType
85452>>>>>>>
85452>>>>>>>        Move False to bRetval
85453>>>>>>>        Get piDbType to iDbType
85454>>>>>>>        Get psDriverID to sDriverID
85455>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85456>>>>>>>        If (bSQLDriver = False) Begin
85458>>>>>>>            Function_Return bRetval
85459>>>>>>>        End
85459>>>>>>>>
85459>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85460>>>>>>>
85460>>>>>>>        Move Err to iCurrErr
85461>>>>>>>        Move False to Err
85462>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
85463>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
85464>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
85465>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
85465>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85467>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
85468>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85469>>>>>>>        End
85469>>>>>>>>
85469>>>>>>>        Else Begin
85470>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85471>>>>>>>        End
85471>>>>>>>>
85471>>>>>>>
85471>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85472>>>>>>>        Move (Err = False) to bRetval
85473>>>>>>>        Move iCurrErr to Err
85474>>>>>>>
85474>>>>>>>        Function_Return bRetval
85475>>>>>>>    End_Function
85476>>>>>>>
85476>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85476>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85476>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85478>>>>>>>        String sDriverID sTableName
85478>>>>>>>        Boolean bOK
85478>>>>>>>
85478>>>>>>>        Get psDriverID to sDriverID
85479>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85480>>>>>>>        If (bOK = False) Begin
85482>>>>>>>            Function_Return False
85483>>>>>>>        End
85483>>>>>>>>
85483>>>>>>>
85483>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85484>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
85485>>>>>>>
85485>>>>>>>        Function_Return (Err = False)
85486>>>>>>>    End_Function
85487>>>>>>>
85487>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
85487>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85487>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85487>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85489>>>>>>>        Integer iDbType iLength iDecimals
85489>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
85489>>>>>>>        Boolean bExists bOK bFixed
85489>>>>>>>        Handle hTable
85489>>>>>>>
85489>>>>>>>        Get psDriverID to sDriverID
85490>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85491>>>>>>>        If (bOK = False) Begin
85493>>>>>>>            Function_Return False
85494>>>>>>>        End
85494>>>>>>>>
85494>>>>>>>
85494>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85495>>>>>>>        If (hTable = 0) Begin
85497>>>>>>>            Get NextFreeFilelistSlot to hTable
85498>>>>>>>        End
85498>>>>>>>>
85498>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
85499>>>>>>>        If (bExists = False) Begin
85501>>>>>>>            Function_Return False
85502>>>>>>>        End
85502>>>>>>>>
85502>>>>>>>
85502>>>>>>>        If (num_arguments > 3) Begin
85504>>>>>>>            Move iLen to iLength
85505>>>>>>>        End
85505>>>>>>>>
85505>>>>>>>        If (num_arguments > 4) Begin
85507>>>>>>>            Move iDec to iDecimals
85508>>>>>>>        End
85508>>>>>>>>
85508>>>>>>>
85508>>>>>>>        Get piDbType to iDbType
85509>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85510>>>>>>>
85510>>>>>>>        Move False to Err
85511>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85512>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85513>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85514>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85515>>>>>>>
85515>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85516>>>>>>>        If (bFixed = False) Begin
85518>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85519>>>>>>>        End
85519>>>>>>>>
85519>>>>>>>
85519>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85520>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85521>>>>>>>
85521>>>>>>>        // We also need to remove the cache-file since the table has been changed
85521>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85522>>>>>>>
85522>>>>>>>        Function_Return (Err = False)
85523>>>>>>>    End_Function
85524>>>>>>>
85524>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85526>>>>>>>        Boolean bOK bErr bIsSQLDriver
85526>>>>>>>        String sDriverID
85526>>>>>>>        Integer iDataType
85526>>>>>>>
85526>>>>>>>        Get psDriverID to sDriverID
85527>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85528>>>>>>>        If (bIsSQLDriver = False) Begin
85530>>>>>>>            Function_Return False
85531>>>>>>>        End
85531>>>>>>>>
85531>>>>>>>
85531>>>>>>>        Move Err to bErr
85532>>>>>>>        Move False to bErr
85533>>>>>>>
85533>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85533>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85533>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85534>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85537>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85539>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85540>>>>>>>        End
85540>>>>>>>>
85540>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85543>>>>>>>        Move (not(Err)) to bOK
85544>>>>>>>        Move bErr to Err
85545>>>>>>>
85545>>>>>>>        Function_Return bOK
85546>>>>>>>    End_Function
85547>>>>>>>
85547>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85549>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85549>>>>>>>        String sDriverID
85549>>>>>>>
85549>>>>>>>        Get psDriverID to sDriverID
85550>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85551>>>>>>>        If (bIsSQLDriver = False) Begin
85553>>>>>>>            Function_Return False
85554>>>>>>>        End
85554>>>>>>>>
85554>>>>>>>
85554>>>>>>>        Move Err to bErr
85555>>>>>>>        Move False to bErr
85556>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85559>>>>>>>        If (bNullable = bCurrentState) Begin
85561>>>>>>>            Function_Return True
85562>>>>>>>        End
85562>>>>>>>>
85562>>>>>>>
85562>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85565>>>>>>>        If (bOpen = False) Begin
85567>>>>>>>            Get AutoConnectionIDLogin to bOK
85568>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85569>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85570>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85571>>>>>>>            Open hTable
85573>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85574>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85575>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85576>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85579>>>>>>>        End
85579>>>>>>>>
85579>>>>>>>        If (bOpen = True) Begin
85581>>>>>>>            Structure_Start hTable sDriverID
85582>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85585>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85586>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85588>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85589>>>>>>>        End
85589>>>>>>>>
85589>>>>>>>
85589>>>>>>>        Move (not(Err)) to bOK
85590>>>>>>>        Move bErr to Err
85591>>>>>>>
85591>>>>>>>        Function_Return bOK
85592>>>>>>>    End_Function
85593>>>>>>>
85593>>>>>>>    // Drop column by its table handle
85593>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85595>>>>>>>        String sDriverID sTableName
85595>>>>>>>        Boolean bOK
85595>>>>>>>
85595>>>>>>>        Get psDriverID to sDriverID
85596>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85597>>>>>>>        If (bOK = False) Begin
85599>>>>>>>            Function_Return False
85600>>>>>>>        End
85600>>>>>>>>
85600>>>>>>>
85600>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85601>>>>>>>        If (sTableName = "") Begin
85603>>>>>>>            Function_Return False
85604>>>>>>>        End
85604>>>>>>>>
85604>>>>>>>
85604>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85605>>>>>>>
85605>>>>>>>        Function_Return (bOK = True)
85606>>>>>>>    End_Function
85607>>>>>>>
85607>>>>>>>    // Drop column by its table name as a string.
85607>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85609>>>>>>>        Integer iDbType iDriver
85609>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85609>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85609>>>>>>>        Handle hTable
85609>>>>>>>
85609>>>>>>>        Get psDriverID to sDriverID
85610>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85611>>>>>>>        If (bOK = False) Begin
85613>>>>>>>            Function_Return False
85614>>>>>>>        End
85614>>>>>>>>
85614>>>>>>>
85614>>>>>>>        Get DriverIndex sDriverID to iDriver
85615>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85618>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85621>>>>>>>
85621>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85622>>>>>>>        If (hTable <> 0) Begin
85624>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85625>>>>>>>            If (bExists = False) Begin
85627>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85630>>>>>>>                Function_Return False
85631>>>>>>>            End
85631>>>>>>>>
85631>>>>>>>        End
85631>>>>>>>>
85631>>>>>>>
85631>>>>>>>        Get piDbType to iDbType
85632>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85634>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85635>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85636>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85639>>>>>>>            Function_Return bOK
85640>>>>>>>        End
85640>>>>>>>>
85640>>>>>>>
85640>>>>>>>        Move False to Err
85641>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85642>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85643>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85644>>>>>>>
85644>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85645>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85646>>>>>>>        Move (not(Err)) to bRetval
85647>>>>>>>
85647>>>>>>>        // We also need to remove the cache-file since the table has been changed
85647>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85648>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85651>>>>>>>
85651>>>>>>>        Function_Return bRetval
85652>>>>>>>    End_Function
85653>>>>>>>
85653>>>>>>>    // Rename a field/column by table handle (filelist number)
85653>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85655>>>>>>>        String sDriverID sTableName
85655>>>>>>>        Boolean bOK
85655>>>>>>>
85655>>>>>>>        Get psDriverID to sDriverID
85656>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85657>>>>>>>        If (bOK = False) Begin
85659>>>>>>>            Function_Return False
85660>>>>>>>        End
85660>>>>>>>>
85660>>>>>>>
85660>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85661>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85662>>>>>>>
85662>>>>>>>        Function_Return (Err = False)
85663>>>>>>>    End_Function
85664>>>>>>>
85664>>>>>>>    // Rename a field/column by table name.
85664>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85666>>>>>>>        Integer iDbType iDataType
85666>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85666>>>>>>>        Boolean bOK bRetval
85666>>>>>>>        Handle hTable
85666>>>>>>>
85666>>>>>>>        Move sTableName to sOrgTableName
85667>>>>>>>        Get psDriverID to sDriverID
85668>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85669>>>>>>>        If (bOK = False) Begin
85671>>>>>>>            Function_Return False
85672>>>>>>>        End
85672>>>>>>>>
85672>>>>>>>
85672>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85673>>>>>>>        If (sVal = "") Begin
85675>>>>>>>            Function_Return False
85676>>>>>>>        End
85676>>>>>>>>
85676>>>>>>>
85676>>>>>>>        Get piDbType to iDbType
85677>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85678>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85679>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85680>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85681>>>>>>>
85681>>>>>>>        Case Begin
85681>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85683>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85684>>>>>>>                Case Break
85685>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85685>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85688>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85689>>>>>>>                Case Break
85690>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85690>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85693>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85694>>>>>>>                Case Break
85695>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85695>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85698>>>>>>>                Move sOrgTableName to sTableName
85699>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85700>>>>>>>                Case Break
85701>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85704>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85704>>>>>>>                Move sOrgTableName to sTableName
85705>>>>>>>                Get psDatabase to sDatabase
85706>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85707>>>>>>>                If (hTable = 0) Begin
85709>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85710>>>>>>>                    If (bOK = False) Begin
85712>>>>>>>                        Function_Return False
85713>>>>>>>                    End
85713>>>>>>>>
85713>>>>>>>                    Get NextFreeFilelistSlot to hTable
85714>>>>>>>                End
85714>>>>>>>>
85714>>>>>>>                Else Begin
85715>>>>>>>                    Open hTable
85717>>>>>>>                End
85717>>>>>>>>
85717>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85718>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85719>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85720>>>>>>>                Case Break
85721>>>>>>>            Case Else
85721>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85722>>>>>>>        Case End
85722>>>>>>>
85722>>>>>>>        Move False to Err
85723>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85724>>>>>>>        Move (Err = False) to bRetval
85725>>>>>>>        // We also need to remove the cache-file since the table has been changed
85725>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85726>>>>>>>
85726>>>>>>>        Function_Return bRetval
85727>>>>>>>    End_Function
85728>>>>>>>
85728>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85730>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85730>>>>>>>        Integer iNumCols iCount iDataType
85730>>>>>>>        String sValue
85730>>>>>>>
85730>>>>>>>        Get phoSQLManager to hoSQLHandler
85731>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85732>>>>>>>        If (hSQLConnect <> 0) Begin
85734>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85735>>>>>>>            If (hStmt <> 0) Begin
85737>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85738>>>>>>>
85738>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85739>>>>>>>                For iCount from 1 to iNumCols
85745>>>>>>>>
85745>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85746>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85748>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85749>>>>>>>                        Move iNumCols to iCount // We're out of here
85750>>>>>>>                    End
85750>>>>>>>>
85750>>>>>>>                Loop
85751>>>>>>>>
85751>>>>>>>
85751>>>>>>>                Send SQLClose of hStmt
85752>>>>>>>            End
85752>>>>>>>>
85752>>>>>>>            Send SQLDisconnect of hSQLConnect
85753>>>>>>>        End
85753>>>>>>>>
85753>>>>>>>
85753>>>>>>>        Function_Return iDataType
85754>>>>>>>    End_Function
85755>>>>>>>
85755>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85755>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85757>>>>>>>        Function_Return False
85758>>>>>>>    End_Function
85759>>>>>>>
85759>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85761>>>>>>>        String sMessage // sConnectionString
85761>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85761>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85761>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85764>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85764>>>>>>>        TimeSpan tsQuery tsFetch
85764>>>>>>>        tSqlErrorArray aSqlErrorArray
85764>>>>>>>        tSqlErrorArray aSqlErrorArray
85764>>>>>>>        Boolean bOK bShowProgress
85764>>>>>>>        tSQLConnection SQLConnection
85764>>>>>>>        tSQLConnection SQLConnection
85764>>>>>>>
85764>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85765>>>>>>>        If (bOK = False) Begin
85767>>>>>>>            Procedure_Return
85768>>>>>>>        End
85768>>>>>>>>
85768>>>>>>>
85768>>>>>>>        If (num_arguments > 2) Begin
85770>>>>>>>            Move bShowProgr to bShowProgress
85771>>>>>>>        End
85771>>>>>>>>
85771>>>>>>>
85771>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85772>>>>>>>        Get phoSQLManager to hoSqlHandler
85773>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85774>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85775>>>>>>>
85775>>>>>>>        If (hoSQLConnect <> 0) Begin
85777>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85778>>>>>>>            If (hoStmt <> 0) Begin
85780>>>>>>>                // record starting date/time stamp
85780>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85781>>>>>>>                // turn on error handling if enabled
85781>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85783>>>>>>>                    Set pbSqlError to False
85784>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85785>>>>>>>                    Move Error_Object_Id to hoError
85786>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85788>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85789>>>>>>>                    End
85789>>>>>>>>
85789>>>>>>>                    Else Begin
85790>>>>>>>                        Move Self to Error_Object_Id
85791>>>>>>>                    End
85791>>>>>>>>
85791>>>>>>>                End
85791>>>>>>>>
85791>>>>>>>
85791>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85791>>>>>>>                Set psSQLStatementString to sStmt
85792>>>>>>>                Send Cursor_Wait of Cursor_Control
85793>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85794>>>>>>>                Send Cursor_Ready of Cursor_Control
85795>>>>>>>
85795>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85797>>>>>>>                    Move hoError to Error_Object_Id
85798>>>>>>>                End
85798>>>>>>>>
85798>>>>>>>
85798>>>>>>>                Move 0 to iMsgs
85799>>>>>>>                Move Err to iErr
85800>>>>>>>                Move LastErr to iLastErr
85801>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85802>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85803>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85804>>>>>>>                Send _SqlColumnInfo hoStmt
85805>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85806>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85807>>>>>>>                Repeat
85807>>>>>>>>
85807>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85808>>>>>>>                    If (iFetchResult <> 0) Begin
85810>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85811>>>>>>>                    End
85811>>>>>>>>
85811>>>>>>>                Until (iFetchResult = 0)
85813>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85814>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85815>>>>>>>                Move iErr to Err
85816>>>>>>>                Move iLastErr to LastErr
85817>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85818>>>>>>>
85818>>>>>>>                Set piRows    to iRows
85819>>>>>>>                Set piRowType to iRowType
85820>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85821>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85822>>>>>>>
85822>>>>>>>                If (iMsgs <> 0) Begin
85824>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85826>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85827>>>>>>>                    End
85827>>>>>>>>
85827>>>>>>>                    For i from 1 to iMsgs
85833>>>>>>>>
85833>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85834>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85835>>>>>>>                        If (bShowProgress = True) Begin
85837>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85839>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85840>>>>>>>                            End
85840>>>>>>>>
85840>>>>>>>                            Else Begin
85841>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85843>>>>>>>                            End
85843>>>>>>>>
85843>>>>>>>                        End
85843>>>>>>>>
85843>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85844>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85845>>>>>>>                    Loop
85846>>>>>>>>
85846>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85848>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85849>>>>>>>                    End
85849>>>>>>>>
85849>>>>>>>                    Set paQueryMessages to sMsg
85850>>>>>>>                End
85850>>>>>>>>
85850>>>>>>>                Else Begin
85851>>>>>>>                    If (bShowProgress = True) Begin
85853>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85854>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85856>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85857>>>>>>>                            Decrement iMsgs
85858>>>>>>>                            For i from 0 to iMsgs
85864>>>>>>>>
85864>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85867>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85870>>>>>>>                            Loop
85871>>>>>>>>
85871>>>>>>>                        End
85871>>>>>>>>
85871>>>>>>>                    End
85871>>>>>>>>
85871>>>>>>>                End
85871>>>>>>>>
85871>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85872>>>>>>>            End
85872>>>>>>>>
85872>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85873>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85874>>>>>>>            Set ptsQueryExec to tsQuery
85875>>>>>>>            Set ptsFetchResults to tsFetch
85876>>>>>>>            Send SqlClose of hoStmt
85877>>>>>>>        End
85877>>>>>>>>
85877>>>>>>>
85877>>>>>>>        Send SqlDisconnect of hoSQLConnect
85878>>>>>>>    End_Procedure
85879>>>>>>>
85879>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85879>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85879>>>>>>>    // Returns False if no error occured.
85879>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85881>>>>>>>        Boolean bOK bShowProgress
85881>>>>>>>        tSQLScriptArray SQLScriptArray
85881>>>>>>>        tSQLScriptArray SQLScriptArray
85881>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85881>>>>>>>        TimeSpan tsTotalTime
85881>>>>>>>
85881>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85882>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85883>>>>>>>        If (SQLScriptArray.bError = True) Begin
85885>>>>>>>            Function_Return False
85886>>>>>>>        End
85886>>>>>>>>
85886>>>>>>>
85886>>>>>>>        If (num_arguments > 3) Begin
85888>>>>>>>            Move bShowProgr to bShowProgress
85889>>>>>>>        End
85889>>>>>>>>
85889>>>>>>>
85889>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85890>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85891>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85892>>>>>>>
85892>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85893>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85894>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85895>>>>>>>
85895>>>>>>>        Function_Return bOK
85896>>>>>>>    End_Function
85897>>>>>>>
85897>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85897>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85899>>>>>>>        Function_Return False
85900>>>>>>>    End_Function
85901>>>>>>>
85901>>>>>>>    // Does three things with auxilirary files;
85901>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85901>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85901>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85901>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85903>>>>>>>        String sDataPath sDDSrcPath sDriverID
85903>>>>>>>        Boolean bOK bExists
85903>>>>>>>        Integer iCount iCh iPos
85903>>>>>>>
85903>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85903>>>>>>>        If (sTableName contains ".") Begin
85905>>>>>>>            Move (Pos(".", sTableName)) to iPos
85906>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85907>>>>>>>        End
85907>>>>>>>>
85907>>>>>>>
85907>>>>>>>        Get psDriverID to sDriverID
85908>>>>>>>        Get psDataPathFirstPart to sDataPath
85909>>>>>>>        Get vFolderExists sDataPath to bOK
85910>>>>>>>        If (bOK = False) Begin
85912>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85913>>>>>>>>
85913>>>>>>>            Function_Return False
85914>>>>>>>        End
85914>>>>>>>>
85914>>>>>>>
85914>>>>>>>        // First delete the cache file:
85914>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85915>>>>>>>
85915>>>>>>>        Get Seq_New_Channel to iCh
85916>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85918>>>>>>>            Function_Return False
85919>>>>>>>        End
85919>>>>>>>>
85919>>>>>>>
85919>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85920>>>>>>>        If (bExists = False) Begin
85922>>>>>>>            Function_Return False
85923>>>>>>>        End
85923>>>>>>>>
85923>>>>>>>
85923>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85924>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85924>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85925>>>>>>>
85925>>>>>>>        // If in development environment; output new .fd file:
85925>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85926>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85927>>>>>>>        If (iCount > 1) Begin
85929>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85930>>>>>>>        End
85930>>>>>>>>
85930>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85931>>>>>>>        If (bExists = True) Begin
85933>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85934>>>>>>>            Move False to Err
85935>>>>>>>            Get AutoConnectionIDLogin to bOK
85936>>>>>>>            If (hTable <> 0) Begin
85938>>>>>>>                Open hTable
85940>>>>>>>            End
85940>>>>>>>>
85940>>>>>>>            Else Begin
85941>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85942>>>>>>>            End
85942>>>>>>>>
85942>>>>>>>
85942>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85945>>>>>>>            If (bOK = True) Begin
85947>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85949>>>>>>>            End
85949>>>>>>>>
85949>>>>>>>            If (Err = True) Begin
85951>>>>>>>                Move False to bOK
85952>>>>>>>            End
85952>>>>>>>>
85952>>>>>>>        End
85952>>>>>>>>
85952>>>>>>>
85952>>>>>>>        Function_Return (bOK = True)
85953>>>>>>>    End_Function
85954>>>>>>>
85954>>>>>>>    // Message for changing .int files to use connection ID's
85954>>>>>>>    //
85954>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85954>>>>>>>    // OR changes an existing connection id to a new id.
85954>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85954>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85954>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult Returns String[] 
85956>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85956>>>>>>>        String[] asFilesData asFileChanges
85958>>>>>>>        Boolean bOK bCancel bChange
85958>>>>>>>        Integer iSize iCount
85958>>>>>>>
85958>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to asFilesData
85959>>>>>>>        Move (SizeOfArray(asFilesData))    to iSize
85960>>>>>>>        If (iSize = 0) Begin
85962>>>>>>>            If (ghoStatusPanel <> 0) Begin
85964>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85966>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85967>>>>>>>                End
85967>>>>>>>>
85967>>>>>>>            End
85967>>>>>>>>
85967>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85968>>>>>>>            Function_Return 0
85969>>>>>>>        End
85969>>>>>>>>
85969>>>>>>>
85969>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85970>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85971>>>>>>>        Decrement iSize
85972>>>>>>>        For iCount from 0 to iSize
85978>>>>>>>>
85978>>>>>>>            Move asFilesData[iCount] to sFileName
85979>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85981>>>>>>>                // This makes sure that we also can change an existing connection id to something new:
85981>>>>>>>                Get _UtilChangeSourceCodeLine (sDataPath + sFileName) (CS_SERVER_NAME * CS_SERVER) (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bChange
85982>>>>>>>                If (bChange = True) Begin
85984>>>>>>>                    Move sFileName to asFileChanges[SizeOfArray(asFileChanges)]
85985>>>>>>>                End
85985>>>>>>>>
85985>>>>>>>                If (ghoStatusPanel <> 0) Begin
85987>>>>>>>                    If (Active_State(ghoStatusPanel)) Begin
85989>>>>>>>                        Get Check_StatusPanel of ghoStatusPanel to bCancel
85990>>>>>>>                        If (bCancel = True) Begin
85992>>>>>>>                            Send Deactivate of ghoStatusPanel
85993>>>>>>>                            Function_Return asFileChanges
85994>>>>>>>                        End
85994>>>>>>>>
85994>>>>>>>                    End
85994>>>>>>>>
85994>>>>>>>                End
85994>>>>>>>>
85994>>>>>>>            End
85994>>>>>>>>
85994>>>>>>>        Loop
85995>>>>>>>>
85995>>>>>>>
85995>>>>>>>         // ToDo: Not sure at all we want to do this automatically:
85995>>>>>>>//        Get psDriverID to sDriverID
85995>>>>>>>//         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85995>>>>>>>//        Move "" to sFileName
85995>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
85995>>>>>>>//            Move "MSSQLDrv.int" to sFileName
85995>>>>>>>//        End
85995>>>>>>>//        If (sDriverID = DB2_DRV_ID) Begin
85995>>>>>>>//            Move "DB2_Drv.int" to sFileName
85995>>>>>>>//        End
85995>>>>>>>//        If (sDriverID = ODBC_DRV_ID) Begin
85995>>>>>>>//            Move "ODBC_Drv.int" to sFileName
85995>>>>>>>//        End
85995>>>>>>>//        If (sFileName <> "") Begin
85995>>>>>>>//            Move "" to sDriverFile
85995>>>>>>>//            Get_File_Path sFileName to sDriverFile
85995>>>>>>>//            Get ParseFolderName sDriverFile to sPath
85995>>>>>>>//            If (sDataPath <> sPath) Begin
85995>>>>>>>//                Move "" to sDriverFile
85995>>>>>>>//            End
85995>>>>>>>//            If (sDriverFile <> "") Begin
85995>>>>>>>//                Get psConnectionString to sConnectionString
85995>>>>>>>//                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85995>>>>>>>//            End
85995>>>>>>>//        End     
85995>>>>>>>        
85995>>>>>>>        Function_Return asFileChanges
85996>>>>>>>    End_Function
85997>>>>>>>
85997>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85997>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85999>>>>>>>        String[] sDatabaseArray
86000>>>>>>>        String sVal sServer sDriverID
86000>>>>>>>        Integer iCount iSize iPos
86000>>>>>>>        Boolean bExists
86000>>>>>>>        tSQLConnection SQLConnection
86000>>>>>>>        tSQLConnection SQLConnection
86000>>>>>>>
86000>>>>>>>        Move False to bExists
86001>>>>>>>        Get psDriverID to sDriverID
86002>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
86002>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
86004>>>>>>>            Function_Return bExists
86005>>>>>>>        End
86005>>>>>>>>
86005>>>>>>>
86005>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
86006>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
86008>>>>>>>            Function_Return False
86009>>>>>>>        End
86009>>>>>>>>
86009>>>>>>>
86009>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86010>>>>>>>        Move SQLConnection.sServer to sServer
86011>>>>>>>
86011>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
86011>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
86013>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
86014>>>>>>>        End
86014>>>>>>>>
86014>>>>>>>        Else If (sServer contains "/") Begin
86017>>>>>>>            Move (Pos("/", sServer)) to iPos
86018>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
86019>>>>>>>        End
86019>>>>>>>>
86019>>>>>>>
86019>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
86020>>>>>>>        Decrement iSize
86021>>>>>>>        For iCount from 0 to iSize
86027>>>>>>>>
86027>>>>>>>            Move sDatabaseArray[iCount] to sVal
86028>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
86030>>>>>>>                Move True to bExists
86031>>>>>>>                If (bExists = True) Begin
86033>>>>>>>                    Move iSize to iCount // We're done.
86034>>>>>>>                End
86034>>>>>>>>
86034>>>>>>>            End
86034>>>>>>>>
86034>>>>>>>        Loop
86035>>>>>>>>
86035>>>>>>>
86035>>>>>>>        Function_Return bExists
86036>>>>>>>    End_Function
86037>>>>>>>
86037>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
86037>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
86039>>>>>>>        String sDatabase sSchema sTableName sVal
86039>>>>>>>        Boolean bExists
86039>>>>>>>        String[] sTablesArray
86040>>>>>>>        Integer iSize iCount
86040>>>>>>>
86040>>>>>>>        Move False to bExists
86041>>>>>>>        Get UtilTableHandleToString hTable to sTableName
86042>>>>>>>        Get psDatabase to sDatabase
86043>>>>>>>        Get psSchema   to sSchema
86044>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
86045>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
86046>>>>>>>        Decrement iSize
86047>>>>>>>        For iCount from 0 to iSize
86053>>>>>>>>
86053>>>>>>>            Move sTablesArray[iCount] to sVal
86054>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86056>>>>>>>                Move True to bExists
86057>>>>>>>                Move iSize to iCount // We're done!
86058>>>>>>>            End
86058>>>>>>>>
86058>>>>>>>        Loop
86059>>>>>>>>
86059>>>>>>>
86059>>>>>>>        Function_Return bExists
86060>>>>>>>    End_Function
86061>>>>>>>
86061>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
86063>>>>>>>        String sVal sTableSpelledCorrectly
86063>>>>>>>        Boolean bExists
86063>>>>>>>        String[] sTablesArray
86064>>>>>>>        Integer iSize iCount
86064>>>>>>>
86064>>>>>>>        Move False to bExists
86065>>>>>>>        Move sTableName to sTableSpelledCorrectly
86066>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
86067>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
86068>>>>>>>        Decrement iSize
86069>>>>>>>        For iCount from 0 to iSize
86075>>>>>>>>
86075>>>>>>>            Move sTablesArray[iCount] to sVal
86076>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86078>>>>>>>                Move sVal to sTableSpelledCorrectly
86079>>>>>>>                Move iSize to iCount // We're done!
86080>>>>>>>            End
86080>>>>>>>>
86080>>>>>>>        Loop
86081>>>>>>>>
86081>>>>>>>
86081>>>>>>>        Function_Return sTableSpelledCorrectly
86082>>>>>>>    End_Function
86083>>>>>>>
86083>>>>>>>    // ToDo: This index name function needs to be finished...
86083>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
86085>>>>>>>        String sSchema sTableName sDriverID
86085>>>>>>>        Boolean bExists
86085>>>>>>>
86085>>>>>>>        Get psDriverID to sDriverID
86086>>>>>>>        Get psSchema to sSchema
86087>>>>>>>        Get UtilTableHandleToString hTable to sTableName
86088>>>>>>>
86088>>>>>>>        Function_Return bExists
86089>>>>>>>    End_Function
86090>>>>>>>
86090>>>>>>>    // Checks if a column/field name exists in a SQL table definition
86090>>>>>>>    // Returns True if it does
86090>>>>>>>    // Sample:
86090>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
86090>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
86092>>>>>>>        Integer iNumColumns iColumn
86092>>>>>>>        String sColumn sDriverID
86092>>>>>>>        String[] sColumnsArray
86093>>>>>>>        Boolean bExists bOK
86093>>>>>>>
86093>>>>>>>        Move False to bExists
86094>>>>>>>        Get AutoConnectionIDLogin to bOK
86095>>>>>>>        Get psDriverID to sDriverID
86096>>>>>>>
86096>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
86097>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
86098>>>>>>>        Decrement iNumColumns
86099>>>>>>>        For iColumn from 0 to iNumColumns
86105>>>>>>>>
86105>>>>>>>            Move sColumnsArray[iColumn] to sColumn
86106>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
86108>>>>>>>                Move True to bExists
86109>>>>>>>                Move iNumColumns to iColumn // We're out of here
86110>>>>>>>            End
86110>>>>>>>>
86110>>>>>>>        Loop
86111>>>>>>>>
86111>>>>>>>
86111>>>>>>>        Function_Return bExists
86112>>>>>>>    End_Function
86113>>>>>>>
86113>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
86115>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
86115>>>>>>>        Boolean bOpened bOK
86115>>>>>>>        String sColumnName sNativeTypeName
86115>>>>>>>
86115>>>>>>>        Get AutoConnectionIDLogin to bOK
86116>>>>>>>        Get OpenTableExclusive hTable to bOK
86117>>>>>>>        If (bOK = False) Begin
86119>>>>>>>            Function_Return False
86120>>>>>>>        End
86120>>>>>>>>
86120>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86123>>>>>>>        If (bOpened = False) Begin
86125>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
86126>>>>>>>>
86126>>>>>>>            Function_Return False
86127>>>>>>>        End
86127>>>>>>>>
86127>>>>>>>
86127>>>>>>>        Move False to Err
86128>>>>>>>
86128>>>>>>>        Structure_Start hTable
86129>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
86132>>>>>>>
86132>>>>>>>            For iColumn from 1 to iNumColumns
86138>>>>>>>>
86138>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
86141>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
86144>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
86147>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
86150>>>>>>>
86150>>>>>>>                Case Begin
86150>>>>>>>                    Case (iDFType = DF_DATE)
86152>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86154>>>>>>>                            // Convert datetime to date
86154>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
86157>>>>>>>                        End
86157>>>>>>>>
86157>>>>>>>                        Case Break
86158>>>>>>>                    Case (iDFType = DF_DATETIME)
86161>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86163>>>>>>>                            // Convert datetime to datetime2
86163>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
86166>>>>>>>                        End
86166>>>>>>>>
86166>>>>>>>                        Case Break
86167>>>>>>>                    Case (iDFType = DF_ASCII)
86170>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
86172>>>>>>>                            // Convert char to varchar
86172>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86175>>>>>>>                        End
86175>>>>>>>>
86175>>>>>>>                        Case Break
86176>>>>>>>                    Case (iDFType = DF_TEXT)
86179>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
86181>>>>>>>                            // Convert text to varchar(max)
86181>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86184>>>>>>>                        End
86184>>>>>>>>
86184>>>>>>>                        Case Break
86185>>>>>>>                    Case (iDFType = DF_BINARY)
86188>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
86190>>>>>>>                            // Convert image to varbinary(max)
86190>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
86193>>>>>>>                        End
86193>>>>>>>>
86193>>>>>>>                        Case Break
86194>>>>>>>                Case End
86194>>>>>>>            Loop
86195>>>>>>>>
86195>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86196>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86198>>>>>>>
86198>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86199>>>>>>>        Function_Return (Err = False)
86200>>>>>>>    End_Function
86201>>>>>>>
86201>>>>>>>
86201>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
86201>>>>>>>    // the DbUpdateVersion database revision in.
86201>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
86201>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
86201>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
86203>>>>>>>        Boolean bOK bOpened
86203>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
86203>>>>>>>
86203>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86206>>>>>>>        Get _TableNameOnly sTableName to sTableName
86207>>>>>>>        If (sTableName = "") Begin
86209>>>>>>>            Function_Return False
86210>>>>>>>        End
86210>>>>>>>>
86210>>>>>>>
86210>>>>>>>        // This just creates the table and a "dummy" column.
86210>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
86211>>>>>>>        If (bOK = False) Begin
86213>>>>>>>            Function_Return False
86214>>>>>>>        End
86214>>>>>>>>
86214>>>>>>>
86214>>>>>>>        Close hTable
86215>>>>>>>        Move False to Err
86216>>>>>>>
86216>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
86217>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
86218>>>>>>>        Move "Decimal" to sDataType
86219>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
86220>>>>>>>
86220>>>>>>>        // Adds the "sColumnName" passed to the function
86220>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
86221>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
86222>>>>>>>
86222>>>>>>>        // Now we can delete the dummy column:
86222>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
86223>>>>>>>
86223>>>>>>>        // Finally, we attach to the newly created table.
86223>>>>>>>        If (Err = False) Begin
86225>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
86226>>>>>>>        End
86226>>>>>>>>
86226>>>>>>>        Open hTable
86228>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86231>>>>>>>
86231>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
86232>>>>>>>    End_Function
86233>>>>>>>
86233>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
86233>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
86233>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
86233>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
86233>>>>>>>    // column types.
86233>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
86235>>>>>>>        Handle hDatabase
86235>>>>>>>        Integer iDriver iServers iCount
86235>>>>>>>        String sValue
86235>>>>>>>
86235>>>>>>>        If (sServer = "") Begin
86237>>>>>>>            Function_Return 0
86238>>>>>>>        End
86238>>>>>>>>
86238>>>>>>>
86238>>>>>>>        Get DriverIndex sDriverID to iDriver
86239>>>>>>>        If (iDriver = 0) Begin
86241>>>>>>>            Function_Return 0
86242>>>>>>>        End
86242>>>>>>>>
86242>>>>>>>
86242>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
86245>>>>>>>        For iCount from 1 to iServers
86251>>>>>>>>
86251>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
86254>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
86256>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
86259>>>>>>>            End
86259>>>>>>>>
86259>>>>>>>        Loop
86260>>>>>>>>
86260>>>>>>>
86260>>>>>>>        Function_Return hDatabase
86261>>>>>>>    End_Function
86262>>>>>>>
86262>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
86262>>>>>>>    // from the passed filelist.
86262>>>>>>>    // Returns the number of tables affected.
86262>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
86264>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
86264>>>>>>>        Integer iRetval
86264>>>>>>>        Handle hTable
86264>>>>>>>
86264>>>>>>>        // We first save the current filelist as the passed filelist name
86264>>>>>>>        // may come from another workspace, to restore it when we're ready.
86264>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
86267>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
86270>>>>>>>        Move 0 to hTable
86271>>>>>>>        Move 0 to iRetval
86272>>>>>>>
86272>>>>>>>        Repeat
86272>>>>>>>>
86272>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86275>>>>>>>            If (hTable <> 0) Begin
86277>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86280>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86283>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86286>>>>>>>                Move (Uppercase(sRootName)) to sVal
86287>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
86289>>>>>>>                    // Prefixes:
86289>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
86290>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
86291>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
86292>>>>>>>                    // Suffixes:
86292>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
86293>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
86294>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
86295>>>>>>>
86295>>>>>>>                    // Change Filelist entry:
86295>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
86298>>>>>>>
86298>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
86299>>>>>>>                    If (sVal contains "dbo.") Begin
86301>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
86302>>>>>>>
86302>>>>>>>                        // Change Filelist entry:
86302>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
86305>>>>>>>                    End
86305>>>>>>>>
86305>>>>>>>                    Increment iRetval
86306>>>>>>>                End
86306>>>>>>>>
86306>>>>>>>            End
86306>>>>>>>>
86306>>>>>>>        Until (hTable = 0)
86308>>>>>>>
86308>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
86311>>>>>>>
86311>>>>>>>        Function_Return iRetval
86312>>>>>>>    End_Function
86313>>>>>>>
86313>>>>>>>    // To open all Sql based tables in Filelist.cfg
86313>>>>>>>    Procedure SqlUtilOpenAllTables
86315>>>>>>>        Handle hTable
86315>>>>>>>        String sRoot sDriverID
86315>>>>>>>        Boolean bOK
86315>>>>>>>
86315>>>>>>>        Move 0 to hTable
86316>>>>>>>        Move "" to sDriverID
86317>>>>>>>        Get AutoConnectionIDLogin to bOK
86318>>>>>>>
86318>>>>>>>        Repeat
86318>>>>>>>>
86318>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86321>>>>>>>            If (hTable > 0) Begin
86323>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86326>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86328>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86331>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86333>>>>>>>                        Open hTable
86335>>>>>>>                    End
86335>>>>>>>>
86335>>>>>>>                End
86335>>>>>>>>
86335>>>>>>>            End
86335>>>>>>>>
86335>>>>>>>
86335>>>>>>>        Until (hTable = 0)
86337>>>>>>>    End_Procedure
86338>>>>>>>
86338>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86338>>>>>>>//        String sRetval sDriverID
86338>>>>>>>//        String sTableName
86338>>>>>>>//        Integer iDbType iIndex
86338>>>>>>>//        Boolean bOK
86338>>>>>>>//
86338>>>>>>>//        Get psDriverID to sDriverID
86338>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86338>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86338>>>>>>>//            Function_Return ""
86338>>>>>>>//        End
86338>>>>>>>//
86338>>>>>>>//        Move False to Err
86338>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86338>>>>>>>//        Get piDbType to iDbType
86338>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86338>>>>>>>//        If (iIndex = -1) Begin
86338>>>>>>>//            Function_Return ""
86338>>>>>>>//        End
86338>>>>>>>//
86338>>>>>>>//        Function_Return sRetval
86338>>>>>>>//    End_Function
86338>>>>>>>
86338>>>>>>>    // Checks if the passed Table;
86338>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86338>>>>>>>    // 2) It has an .int file.
86338>>>>>>>    // If both is True it should already be connected to SQL
86338>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86340>>>>>>>        Boolean bExists bRootName
86340>>>>>>>        String sRootName sDataPath
86340>>>>>>>
86340>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86343>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86344>>>>>>>
86344>>>>>>>        Get psDataPathFirstPart to sDataPath
86345>>>>>>>        Get vFolderExists sDataPath to bExists
86346>>>>>>>        If (bExists = False) Begin
86348>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86348>>>>>>>            Function_Return False
86349>>>>>>>        End
86349>>>>>>>>
86349>>>>>>>
86349>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86350>>>>>>>        Get _TableNameOnly sRootName to sRootName
86351>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86352>>>>>>>
86352>>>>>>>        Function_Return (bRootName = True and bExists = True)
86353>>>>>>>    End_Function
86354>>>>>>>
86354>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86356>>>>>>>        Boolean bViewTableType bOpen bOK
86356>>>>>>>        Integer iTableCount iNumTables
86356>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86356>>>>>>>        Handle hoCliHandler
86356>>>>>>>        tSQLConnection SQLConnection
86356>>>>>>>        tSQLConnection SQLConnection
86356>>>>>>>
86356>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86359>>>>>>>        If (bOpen = False) Begin
86361>>>>>>>            Get AutoConnectionIDLogin to bOK
86362>>>>>>>            Open hTable
86364>>>>>>>        End
86364>>>>>>>>
86364>>>>>>>
86364>>>>>>>        Get pSQLConnection to SQLConnection
86365>>>>>>>        Get phoCLIHandler to hoCliHandler
86366>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86367>>>>>>>
86367>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86370>>>>>>>        Get _TableNameOnly sTableName to sTableName
86371>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86374>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86375>>>>>>>
86375>>>>>>>        For iTableCount from 1 to iNumTables
86381>>>>>>>>
86381>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86382>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86383>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86385>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86386>>>>>>>                Move iNumTables to iTableCount // We're done.
86387>>>>>>>            End
86387>>>>>>>>
86387>>>>>>>        Loop
86388>>>>>>>>
86388>>>>>>>
86388>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86389>>>>>>>        If (bOpen = False) Begin
86391>>>>>>>            Close hTable
86392>>>>>>>        End
86392>>>>>>>>
86392>>>>>>>
86392>>>>>>>        Function_Return bViewTableType
86393>>>>>>>    End_Function
86394>>>>>>>
86394>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86394>>>>>>>    //
86394>>>>>>>    // SQL utility function that returns a database type (string) constant
86394>>>>>>>    // corresponding to the passed iDbType.
86394>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86396>>>>>>>        String sRetval
86396>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86397>>>>>>>        Function_Return sRetval
86398>>>>>>>    End_Function
86399>>>>>>>
86399>>>>>>>    // SQL utility function that returns a database type constant (integer)
86399>>>>>>>    // corresponding to the passed sDbType string constant.
86399>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86401>>>>>>>        Integer iRetval
86401>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86402>>>>>>>        Function_Return iRetval
86403>>>>>>>    End_Function
86404>>>>>>>
86404>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86404>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86404>>>>>>>    // the SQL Connection program's grid.
86404>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86406>>>>>>>        String sRetval
86406>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86407>>>>>>>        Function_Return sRetval
86408>>>>>>>    End_Function
86409>>>>>>>
86409>>>>>>>    // Pass a driver name as a string and the function will return
86409>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86409>>>>>>>    // quite work and always returns "MS SQL Server"
86409>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86411>>>>>>>        Integer iRetval
86411>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86412>>>>>>>        Function_Return iRetval
86413>>>>>>>    End_Function
86414>>>>>>>
86414>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86414>>>>>>>    // that "fits" in the max allowed length for table names.
86414>>>>>>>    // Max number of characters allowed for table names;
86414>>>>>>>    // IBM DB2      = 128
86414>>>>>>>    // MS-SQL       = 128
86414>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86414>>>>>>>    // MySQL        = 64
86414>>>>>>>    // PostgreSQL   = 64
86414>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86416>>>>>>>        String sGUIDName
86416>>>>>>>        Integer iDbType iLength
86416>>>>>>>
86416>>>>>>>        Get piDbType to iDbType
86417>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86418>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86419>>>>>>>        Move (Length(sGUIDName)) to iLength
86420>>>>>>>
86420>>>>>>>        Case Begin
86420>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86422>>>>>>>            If (iLength > 128) Begin
86424>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86425>>>>>>>            End
86425>>>>>>>>
86425>>>>>>>            Case Break
86426>>>>>>>
86426>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86429>>>>>>>            If (iLength > 128) Begin
86431>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86432>>>>>>>            End
86432>>>>>>>>
86432>>>>>>>            Case Break
86433>>>>>>>
86433>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86436>>>>>>>            If (iLength > 128) Begin
86438>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86439>>>>>>>            End
86439>>>>>>>>
86439>>>>>>>            Case Break
86440>>>>>>>
86440>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86443>>>>>>>            If (iLength > 64) Begin
86445>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86446>>>>>>>            End
86446>>>>>>>>
86446>>>>>>>            Case Break
86447>>>>>>>
86447>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86450>>>>>>>            If (iLength > 64) Begin
86452>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86453>>>>>>>            End
86453>>>>>>>>
86453>>>>>>>        Case End
86453>>>>>>>
86453>>>>>>>        Function_Return sGUIDName
86454>>>>>>>    End_Function
86455>>>>>>>
86455>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86455>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86455>>>>>>>    // including full path.
86455>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86457>>>>>>>        String sText
86457>>>>>>>        Integer iCh iSize iArgSize
86457>>>>>>>
86457>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86458>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86459>>>>>>>        Get_Channel_Size iCh to iSize
86460>>>>>>>        Read_Block channel iCh sText iSize
86462>>>>>>>        Send Seq_Close_Channel iCh
86463>>>>>>>
86463>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86464>>>>>>>            Write channel iCh sText
86466>>>>>>>        Send Seq_Close_Channel iCh
86467>>>>>>>
86467>>>>>>>        // Wait for file to be written to disk.
86467>>>>>>>        Sleep 2
86468>>>>>>>    End_Procedure
86469>>>>>>>
86469>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86471>>>>>>>        String sNotNull sRetval sDefaultValue
86471>>>>>>>        Boolean bOK
86471>>>>>>>
86471>>>>>>>        Get IsSQLDriver sDriverID to bOK
86472>>>>>>>        If (bOK = False) Begin
86474>>>>>>>            Function_Return ""
86475>>>>>>>        End
86475>>>>>>>>
86475>>>>>>>
86475>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86476>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86477>>>>>>>
86477>>>>>>>        Case Begin
86477>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86479>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86480>>>>>>>                Case Break
86481>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86484>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86485>>>>>>>                Case Break
86486>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86489>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86490>>>>>>>                Case Break
86491>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86494>>>>>>>                Move (String(sNotNull))                                     to sRetval
86495>>>>>>>                Case Break
86496>>>>>>>
86496>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86496>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86496>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86499>>>>>>>                Move  ""                                                    to sRetval
86500>>>>>>>                Case Break
86501>>>>>>>
86501>>>>>>>            Case Else
86501>>>>>>>                Move  ""                                                    to sRetval
86502>>>>>>>        Case End
86502>>>>>>>
86502>>>>>>>        Function_Return sRetval
86503>>>>>>>    End_Function
86504>>>>>>>
86504>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86504>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86506>>>>>>>        Function_Return False
86507>>>>>>>    End_Function
86508>>>>>>>
86508>>>>>>>    // Enumerate SQL Servers.
86508>>>>>>>    // Pass a driver id. Returns a string array.
86508>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86508>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86508>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86510>>>>>>>        String[] sReturnArray
86511>>>>>>>        Handle hoSQLHandler
86511>>>>>>>        String sServer
86511>>>>>>>        Integer iCount iNumItems iDataSourceType
86511>>>>>>>
86511>>>>>>>        If (num_arguments > 1) Begin
86513>>>>>>>            Move iDatSrcType to iDataSourceType
86514>>>>>>>        End
86514>>>>>>>>
86514>>>>>>>
86514>>>>>>>        Case Begin
86514>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86516>>>>>>>                Get phoMSSQLHandler to hoSQLHandler 
86517>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
86518>>>>>>>                If (iNumItems = 0) Begin
86520>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
86521>>>>>>>                End
86521>>>>>>>>
86521>>>>>>>                For iCount from 0 to (iNumItems - 1)
86527>>>>>>>>
86527>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86528>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86529>>>>>>>                Loop
86530>>>>>>>>
86530>>>>>>>                Case Break
86531>>>>>>>
86531>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86534>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86535>>>>>>>                Send SeedDataSources of hoSQLHandler
86536>>>>>>>                Move 0 to iCount
86537>>>>>>>                Repeat
86537>>>>>>>>
86537>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86538>>>>>>>                    If (sServer <> "") Begin
86540>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86541>>>>>>>                        Move sServer to sReturnArray[iCount]
86542>>>>>>>                    End
86542>>>>>>>>
86542>>>>>>>                    Increment iCount
86543>>>>>>>                Until (sServer = "")
86545>>>>>>>                Case Break
86546>>>>>>>
86546>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86549>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86550>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86551>>>>>>>                Move 0 to iCount
86552>>>>>>>                Repeat
86552>>>>>>>>
86552>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86553>>>>>>>                    If (sServer <> "") Begin
86555>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86556>>>>>>>                        Move sServer to sReturnArray[iCount]
86557>>>>>>>                    End
86557>>>>>>>>
86557>>>>>>>                    Increment iCount
86558>>>>>>>                Until (sServer = "")
86560>>>>>>>                Case Break
86561>>>>>>>
86561>>>>>>>            Case Else
86561>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86562>>>>>>>>
86562>>>>>>>        Case End
86562>>>>>>>
86562>>>>>>>        Function_Return sReturnArray
86563>>>>>>>    End_Function
86564>>>>>>>
86564>>>>>>>    // Returns all databases as a string array for the passed driver id.
86564>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86566>>>>>>>        String[] sReturnArray
86567>>>>>>>        String sServer sVal
86567>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86567>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86568>>>>>>>        tSQLConnection SQLConnection
86568>>>>>>>        tSQLConnection SQLConnection
86568>>>>>>>        Boolean bOK
86568>>>>>>>        Integer iCount iSize
86568>>>>>>>
86568>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86569>>>>>>>        If (bOK = False) Begin
86571>>>>>>>            Function_Return sReturnArray
86572>>>>>>>        End
86572>>>>>>>>
86572>>>>>>>
86572>>>>>>>        Case Begin
86572>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86574>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86575>>>>>>>                Case Break
86576>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86579>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86580>>>>>>>                Case Break
86581>>>>>>>
86581>>>>>>>            // This is needed to be able to check if a database exists or not.
86581>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86584>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86585>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86587>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86589>>>>>>>                        // If a FILEDSN: (can only be one database name)
86589>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86590>>>>>>>                    End
86590>>>>>>>>
86590>>>>>>>                    Else Begin
86591>>>>>>>                        // Else the DSN's were read from the registry.
86591>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86592>>>>>>>                        Move SQLConnection.sServer to sServer
86593>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86594>>>>>>>                        Decrement iSize
86595>>>>>>>                        for iCount from 0 to iSize
86601>>>>>>>>
86601>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86602>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86604>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86605>>>>>>>                                Move iSize to iCount // We're done.
86606>>>>>>>                            End
86606>>>>>>>>
86606>>>>>>>                        Loop
86607>>>>>>>>
86607>>>>>>>                    End
86607>>>>>>>>
86607>>>>>>>                End
86607>>>>>>>>
86607>>>>>>>                Case Break
86608>>>>>>>
86608>>>>>>>            Case Else
86608>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86608>>>>>>>        Case End
86608>>>>>>>
86608>>>>>>>        Function_Return sReturnArray
86609>>>>>>>    End_Function
86610>>>>>>>
86610>>>>>>>    
86610>>>>>>>    // *** Database API Functions: ***
86610>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86610>>>>>>>    // make changes/updates to the database.
86610>>>>>>>
86610>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86610>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86612>>>>>>>        Function_Return False
86613>>>>>>>    End_Function
86614>>>>>>>
86614>>>>>>>    // This might not do what you think - Here's what it does:
86614>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86614>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86614>>>>>>>    // to the SQL table.
86614>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86614>>>>>>>    // already exists in SQL.
86614>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86614>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86614>>>>>>>    // restructuring an existing table.
86614>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86616>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86616>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86616>>>>>>>        Handle hToTable
86616>>>>>>>
86616>>>>>>>        Move True to bUseConnectionID
86617>>>>>>>        If (num_arguments > 1) Begin
86619>>>>>>>            Move bUseConnID to bUseConnectionID
86620>>>>>>>        End
86620>>>>>>>>
86620>>>>>>>
86620>>>>>>>        Get psDriverID to sDriverID
86621>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86621>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86622>>>>>>>        If (bExists = False) Begin
86624>>>>>>>            Function_Return False
86625>>>>>>>        End
86625>>>>>>>>
86625>>>>>>>
86625>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86626>>>>>>>
86626>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86627>>>>>>>        If (bOK = False) Begin
86629>>>>>>>            Function_Return False
86630>>>>>>>        End
86630>>>>>>>>
86630>>>>>>>
86630>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86630>>>>>>>        // we do nothing
86630>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86631>>>>>>>        If (bExists = True) Begin
86633>>>>>>>            Function_Return False
86634>>>>>>>        End
86634>>>>>>>>
86634>>>>>>>
86634>>>>>>>        Get psConnectionID     to sConnectionID
86635>>>>>>>        Get psConnectionString to sConnectionString
86636>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86638>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86639>>>>>>>>
86639>>>>>>>            Function_Return False
86640>>>>>>>        End
86640>>>>>>>>
86640>>>>>>>
86640>>>>>>>        Set Private.phCurrentTable to hTable
86641>>>>>>>        Get psSchema to sSchema
86642>>>>>>>        If (sSchema = "") Begin
86644>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86645>>>>>>>        End
86645>>>>>>>>
86645>>>>>>>
86645>>>>>>>        // If we should use a connection id we need to check it exists;
86645>>>>>>>        // else we create it before attempting creating the table
86645>>>>>>>        If (bUseConnectionID = True) Begin
86647>>>>>>>            Get AutoConnectionIDLogin to bOK
86648>>>>>>>            If (bOk = False) Begin
86650>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86651>>>>>>>>
86651>>>>>>>                Function_Return False
86652>>>>>>>            End
86652>>>>>>>>
86652>>>>>>>        End
86652>>>>>>>>
86652>>>>>>>
86652>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86655>>>>>>>        Get _TableNameOnly sRootName to sRootName
86656>>>>>>>        If (sRootName = "") Begin
86658>>>>>>>            Function_Return False
86659>>>>>>>        End
86659>>>>>>>>
86659>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86660>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86663>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86666>>>>>>>
86666>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86666>>>>>>>        //
86666>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86666>>>>>>>        // because then the table should not be visible to users.
86666>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86666>>>>>>>//        If (iPos <> 1) Begin
86666>>>>>>>//            If (sDisplayName contains ".") Begin
86666>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86666>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86666>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86666>>>>>>>//            End
86666>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86666>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86666>>>>>>>//            End
86666>>>>>>>//        End
86666>>>>>>>
86666>>>>>>>        If (bIsAlias = False) Begin
86668>>>>>>>            Get OpenTableExclusive hTable to bOpened
86669>>>>>>>            If (bOpened = False) Begin
86671>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86672>>>>>>>>
86672>>>>>>>                Function_Return False
86673>>>>>>>            End
86673>>>>>>>>
86673>>>>>>>        End
86673>>>>>>>>
86673>>>>>>>
86673>>>>>>>        If (ghoProgressBar <> 0) Begin
86675>>>>>>>            Send DoAdvance of ghoProgressBar
86676>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86677>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86678>>>>>>>        End
86678>>>>>>>>
86678>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86678>>>>>>>        Move hTable to hToTable
86679>>>>>>>        Move False to Err
86680>>>>>>>
86680>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86680>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86680>>>>>>>        // a proper and updated .int file.
86680>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86683>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile True to bOK
86684>>>>>>>
86684>>>>>>>        If (bIsAlias = False) Begin
86686>>>>>>>            Structure_Start hToTable sDriverID
86687>>>>>>>                Set Private.phCurrentTable to hTable
86688>>>>>>>                If (bUseConnectionID = True) Begin
86690>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86693>>>>>>>                End
86693>>>>>>>>
86693>>>>>>>                Else Begin
86694>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86697>>>>>>>                End
86697>>>>>>>>
86697>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86700>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86700>>>>>>>                Move False to Err
86701>>>>>>>                Move 0 to LastErr
86702>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86703>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86705>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86706>>>>>>>        End
86706>>>>>>>>
86706>>>>>>>
86706>>>>>>>        Move (not(Err)) to bOK
86707>>>>>>>        If (bOK = True) Begin
86709>>>>>>>            // The attributes set above will always trigger an error
86709>>>>>>>            // We also adjust the Filelist entries
86709>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86712>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86715>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86718>>>>>>>
86718>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86718>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86719>>>>>>>        End
86719>>>>>>>>
86719>>>>>>>
86719>>>>>>>        If (bOK = True) Begin
86721>>>>>>>            Send ResetFillSQLTables
86722>>>>>>>        End
86722>>>>>>>>
86722>>>>>>>        Function_Return (bOK = True)
86723>>>>>>>    End_Function
86724>>>>>>>
86724>>>>>>>    // Sample usage:
86724>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86724>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86724>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86726>>>>>>>        Boolean bOK bIsSQLTable
86726>>>>>>>
86726>>>>>>>        Get AutoConnectionIDLogin to bOK
86727>>>>>>>        Move False to Err
86728>>>>>>>        Get OpenTableExclusive hTable to bOK
86729>>>>>>>        If (bOK = False) Begin
86731>>>>>>>            Function_Return False
86732>>>>>>>        End
86732>>>>>>>>
86732>>>>>>>
86732>>>>>>>        // ToDo: Add to all table change functions!
86732>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86733>>>>>>>            If (bIsSQLTable = True) Begin
86735>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86738>>>>>>>            End
86738>>>>>>>>
86738>>>>>>>
86738>>>>>>>        Set Private.phCurrentTable to hTable
86739>>>>>>>        Structure_Start hTable
86740>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86743>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86744>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86746>>>>>>>
86746>>>>>>>        Set Message_Text of ghoStatusPanel to ""
86747>>>>>>>        Set Action_Text  of ghoStatusPanel to ""
86748>>>>>>>        Function_Return (Err = False)
86749>>>>>>>    End_Function
86750>>>>>>>
86750>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86752>>>>>>>        Boolean bOK
86752>>>>>>>        
86752>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86753>>>>>>>        If (bOK = True) Begin
86755>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86756>>>>>>>        End
86756>>>>>>>>
86756>>>>>>>        
86756>>>>>>>        Function_Return (bOK = True)
86757>>>>>>>    End_Function
86758>>>>>>>    
86758>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86758>>>>>>>    // or to change the filelist slot names.
86758>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86760>>>>>>>        String sFileListName
86760>>>>>>>        
86760>>>>>>>        Move False to Err
86761>>>>>>>
86761>>>>>>>        If (ghoProgressBar <> 0) Begin
86763>>>>>>>            Send DoAdvance of ghoProgressBar
86764>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86765>>>>>>>        End
86765>>>>>>>>
86765>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86765>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86767>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86770>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86773>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86776>>>>>>>            Function_Return (Err = False) // And we're done.
86777>>>>>>>        End
86777>>>>>>>>
86777>>>>>>>
86777>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86779>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86779>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86780>>>>>>>        End
86780>>>>>>>>
86780>>>>>>>//        Else Begin
86780>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86780>>>>>>>//        End
86780>>>>>>>//
86780>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86780>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86780>>>>>>>
86780>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86783>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86786>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86789>>>>>>>        
86789>>>>>>>        Function_Return (Err = False)
86790>>>>>>>    End_Function
86791>>>>>>>
86791>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86793>>>>>>>        Boolean bOK
86793>>>>>>>
86793>>>>>>>        Get AutoConnectionIDLogin to bOK
86794>>>>>>>        Move False to Err
86795>>>>>>>        Get OpenTableExclusive hTable to bOK
86796>>>>>>>        If (bOK = False) Begin
86798>>>>>>>            Function_Return False
86799>>>>>>>        End
86799>>>>>>>>
86799>>>>>>>
86799>>>>>>>        Set Private.phCurrentTable to hTable
86800>>>>>>>        Structure_Start hTable
86801>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86804>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86805>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86807>>>>>>>
86807>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86808>>>>>>>        Function_Return (Err = False)
86809>>>>>>>    End_Function
86810>>>>>>>
86810>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86812>>>>>>>        Boolean bOK bIsSQLTable
86812>>>>>>>
86812>>>>>>>        Move False to Err
86813>>>>>>>        Get AutoConnectionIDLogin to bOK
86814>>>>>>>        Open hToTable
86816>>>>>>>        Get OpenTableExclusive hTable to bOK
86817>>>>>>>        If (bOK = False) Begin
86819>>>>>>>            Function_Return False
86820>>>>>>>        End
86820>>>>>>>>
86820>>>>>>>
86820>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86821>>>>>>>            If (bIsSQLTable = True) Begin
86823>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86826>>>>>>>            End
86826>>>>>>>>
86826>>>>>>>
86826>>>>>>>        Set Private.phCurrentTable to hTable
86827>>>>>>>        Structure_Start hTable
86828>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86831>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86834>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86835>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86837>>>>>>>
86837>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86838>>>>>>>        Function_Return (Err = False)
86839>>>>>>>    End_Function
86840>>>>>>>
86840>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86842>>>>>>>        Integer[] aTableConvertExceptions
86843>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86844>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86845>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86846>>>>>>>    End_Procedure
86847>>>>>>>
86847>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86849>>>>>>>        Integer[] aTableDateCorrectionExceptions
86850>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86851>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86852>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86853>>>>>>>    End_Procedure
86854>>>>>>>
86854>>>>>>>    Procedure ApiTableConvertALLToSql
86856>>>>>>>        Integer[] iTablesArray
86857>>>>>>>        Integer iSize iCount
86857>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86857>>>>>>>        String sDriverID
86857>>>>>>>
86857>>>>>>>        Get psDriverID to sDriverID
86858>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86859>>>>>>>        Get pbToANSI          to bToANSI
86860>>>>>>>        Get pbRecnum          to bRecnum
86861>>>>>>>        Get pbCopyData        to bCopyData
86862>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86864>>>>>>>            Get pbContinueOnError to bContinueOnError
86865>>>>>>>        End
86865>>>>>>>>
86865>>>>>>>
86865>>>>>>>        Get _AllTablesToConvert to iTablesArray
86866>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86867>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86868>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86869>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86870>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86871>>>>>>>
86871>>>>>>>        Decrement iSize
86872>>>>>>>        For iCount from 0 to iSize
86878>>>>>>>>
86878>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86879>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86880>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86880>>>>>>>            // if there was an error converting one table...
86880>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86880>>>>>>>        Loop
86881>>>>>>>>
86881>>>>>>>
86881>>>>>>>    End_Procedure
86882>>>>>>>
86882>>>>>>>    Procedure ApiTableAttachALLToSql
86884>>>>>>>        Integer[] iTablesArray
86885>>>>>>>        Integer iSize iCount
86885>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86885>>>>>>>        String sDriverID
86885>>>>>>>
86885>>>>>>>        Get psDriverID to sDriverID
86886>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86887>>>>>>>        Get pbToANSI          to bToANSI
86888>>>>>>>        Get pbRecnum          to bRecnum
86889>>>>>>>        Get pbCopyData        to bCopyData
86890>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86892>>>>>>>            Get pbContinueOnError to bContinueOnError
86893>>>>>>>        End
86893>>>>>>>>
86893>>>>>>>
86893>>>>>>>        Get _AllTablesToConvert to iTablesArray
86894>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86895>>>>>>>        Decrement iSize
86896>>>>>>>        For iCount from 0 to iSize
86902>>>>>>>>
86902>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86903>>>>>>>        Loop
86904>>>>>>>>
86904>>>>>>>
86904>>>>>>>    End_Procedure
86905>>>>>>>
86905>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86907>>>>>>>        Handle hToTable hoLogFile
86907>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86907>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86907>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86907>>>>>>>        tSQLConnection SQLConnection
86907>>>>>>>        tSQLConnection SQLConnection
86907>>>>>>>        
86907>>>>>>>        // ToDo: Remake logic. Instead create the new table!?
86907>>>>>>>        Get _UtilTableExists hTable to bExists
86908>>>>>>>        If (bExists = False) Begin
86910>>>>>>>            Set Private.phCurrentTable to hTable
86911>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86912>>>>>>>>
86912>>>>>>>            Function_Return False
86913>>>>>>>        End
86913>>>>>>>>
86913>>>>>>>
86913>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86914>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86914>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86914>>>>>>>        If (bIsAlias = True) Begin
86916>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86919>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86921>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86924>>>>>>>                Get psConnectionID to sConnectionID
86925>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False False to bOK
86926>>>>>>>            End
86926>>>>>>>>
86926>>>>>>>            Function_Return True
86927>>>>>>>        End
86927>>>>>>>>
86927>>>>>>>
86927>>>>>>>        Set Private.phCurrentTable to hTable
86928>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86931>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86934>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86937>>>>>>>
86937>>>>>>>        If (ghoProgressBar <> 0) Begin
86939>>>>>>>            Send DoAdvance of ghoProgressBar
86940>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86941>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86942>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86943>>>>>>>        End
86943>>>>>>>>
86943>>>>>>>
86943>>>>>>>        // Marco Kuipers suggestion;
86943>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86943>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86943>>>>>>>        // SQL table.
86943>>>>>>>        Get _UtilTableIsSql hTable to bOK
86944>>>>>>>        If (bOK = False) Begin
86946>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86947>>>>>>>            If (bExists = True) Begin
86949>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86949>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86949>>>>>>>                Get phoLogFile to hoLogFile
86950>>>>>>>                If (hoLogFile <> 0) Begin          
86952>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86953>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86953>>>>>>>                    Send LogError sWarning False
86954>>>>>>>                End
86954>>>>>>>>
86954>>>>>>>                Else Begin
86955>>>>>>>                    Error DFERR_PROGRAM sWarning
86956>>>>>>>>
86956>>>>>>>                End                                                       
86956>>>>>>>>
86956>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86957>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86958>>>>>>>            End
86958>>>>>>>>
86958>>>>>>>        End
86958>>>>>>>>
86958>>>>>>>
86958>>>>>>>        // Does the rootname contain a driver?
86958>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86960>>>>>>>            // Does the table already exist as an SQL table?
86960>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86961>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86961>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86961>>>>>>>            If (bExists = False) Begin
86963>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86964>>>>>>>            End
86964>>>>>>>>
86964>>>>>>>            If (bExists = True) Begin
86966>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86967>>>>>>>                Function_Return False
86968>>>>>>>            End
86968>>>>>>>>
86968>>>>>>>        End
86968>>>>>>>>
86968>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86969>>>>>>>
86969>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86970>>>>>>>//        If (bUseConnectionID = True) Begin
86970>>>>>>>//            Move False to bUseConnectionID
86970>>>>>>>//        End
86970>>>>>>>
86970>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86971>>>>>>>        Move SQLConnection.sSchema           to sSchema
86972>>>>>>>        If (sSchema = "") Begin
86974>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86975>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86976>>>>>>>        End
86976>>>>>>>>
86976>>>>>>>
86976>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86977>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86978>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86979>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86981>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86982>>>>>>>>
86982>>>>>>>            Function_Return False
86983>>>>>>>        End
86983>>>>>>>>
86983>>>>>>>
86983>>>>>>>        Get AutoConnectionIDLogin to bOK
86984>>>>>>>        Open hTable
86986>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86989>>>>>>>        If (bOpened = False) Begin
86991>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86992>>>>>>>>
86992>>>>>>>            Function_Return False
86993>>>>>>>        End
86993>>>>>>>>
86993>>>>>>>
86993>>>>>>>        If (ghoProgressBar <> 0) Begin
86995>>>>>>>            Send DoAdvance of ghoProgressBar
86996>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86997>>>>>>>        End
86997>>>>>>>>
86997>>>>>>>
86997>>>>>>>        Move 0 to hToTable
86998>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86999>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
87000>>>>>>>
87000>>>>>>>        Case Begin
87000>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
87002>>>>>>>                Case Break
87003>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
87006>>>>>>>                Case Break
87007>>>>>>>            Case (sDriverID = DB2_DRV_ID)
87010>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87011>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
87012>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87013>>>>>>>                Case Break
87014>>>>>>>            Case (sDriverID = DATAFLEX_ID)
87017>>>>>>>                Case Break
87018>>>>>>>            Case Else
87018>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
87019>>>>>>>>
87019>>>>>>>                Case Break
87020>>>>>>>        Case End
87020>>>>>>>
87020>>>>>>>        Move False to Err
87021>>>>>>>
87021>>>>>>>        Structure_Start hToTable sDriverID
87022>>>>>>>            Structure_Copy hTable to hToTable
87023>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87026>>>>>>>
87026>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87028>>>>>>>                If (bUseConnectionID = True) Begin
87030>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87033>>>>>>>                End
87033>>>>>>>>
87033>>>>>>>                Else Begin
87034>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
87037>>>>>>>                End
87037>>>>>>>>
87037>>>>>>>
87037>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
87040>>>>>>>
87040>>>>>>>                If (sSchema <> "") Begin
87042>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
87045>>>>>>>                End
87045>>>>>>>>
87045>>>>>>>
87045>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87047>>>>>>>                    If (sLongTableSpace <> "") Begin
87049>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
87052>>>>>>>                    End
87052>>>>>>>>
87052>>>>>>>                    If (sBaseTableSpace <> "") Begin
87054>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
87057>>>>>>>                    End
87057>>>>>>>>
87057>>>>>>>                    If (sIndexTableSpace <> "") Begin
87059>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
87062>>>>>>>                    End
87062>>>>>>>>
87062>>>>>>>                End
87062>>>>>>>>
87062>>>>>>>            End
87062>>>>>>>>
87062>>>>>>>
87062>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87063>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87065>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87066>>>>>>>
87066>>>>>>>        Move (not(Err)) to bOK
87067>>>>>>>
87067>>>>>>>        If (bOK = True and bCopyData = True) Begin
87069>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
87070>>>>>>>
87070>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
87072>>>>>>>                Get pbContinueOnError to bContinueOnError
87073>>>>>>>            End
87073>>>>>>>>
87073>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
87073>>>>>>>            // rename it by adding a GUID to the end of the table name
87073>>>>>>>            // - or as much as "fit" because different SQL back-ends have
87073>>>>>>>            // different rules how long a table name can be.
87073>>>>>>>            // The new table will probably contain data but something went
87073>>>>>>>            // wrong while converting the data from embedded to SQL.
87073>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
87075>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87076>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87077>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
87078>>>>>>>>
87078>>>>>>>            End
87078>>>>>>>>
87078>>>>>>>        End
87078>>>>>>>>
87078>>>>>>>
87078>>>>>>>        // This must be after copying data...
87078>>>>>>>        If (Err = False) Begin
87080>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87083>>>>>>>            // It seems the Studio does not do this any more, so commented out.
87083>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
87083>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87083>>>>>>>            //                // The max length for the display_name is 31 characters...
87083>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
87083>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
87083>>>>>>>            //                End
87083>>>>>>>            //            End
87083>>>>>>>        End
87083>>>>>>>>
87083>>>>>>>
87083>>>>>>>        Close hTable
87084>>>>>>>        Move (not(Err)) to bOK
87085>>>>>>>        If (bOK = True) Begin
87087>>>>>>>            Send ResetFillSQLTables
87088>>>>>>>        End
87088>>>>>>>>
87088>>>>>>>        Function_Return bOK
87089>>>>>>>    End_Function
87090>>>>>>>
87090>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
87090>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
87090>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
87090>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
87092>>>>>>>        Boolean bOpened bOK
87092>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
87092>>>>>>>        String sErrorFile sEmpty sPath
87092>>>>>>>
87092>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
87095>>>>>>>        Get AutoConnectionIDLogin to bOK
87096>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87098>>>>>>>            Send IncreaseSortBufferSize
87099>>>>>>>//            Send SetAllIndexesToBatch hToTable
87099>>>>>>>        End
87099>>>>>>>>
87099>>>>>>>
87099>>>>>>>        Move False to Err
87100>>>>>>>        Open sPhysicalName as hToTable
87102>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
87105>>>>>>>        If (bOpened = False) Begin
87107>>>>>>>            Function_Return False
87108>>>>>>>        End
87108>>>>>>>>
87108>>>>>>>
87108>>>>>>>        If (ghoStatusPanel <> 0) Begin
87110>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87111>>>>>>>            Set piMinimum of ghoProgressBar to 0
87112>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
87113>>>>>>>        End
87113>>>>>>>>
87113>>>>>>>
87113>>>>>>>        Move "" to sEmpty
87114>>>>>>>        Move False to Err
87115>>>>>>>        Move True to bOK
87116>>>>>>>        Set Private.phCurrentTable to hToTable
87117>>>>>>>
87117>>>>>>>        // No need to get the record identifier
87117>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
87120>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87123>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87125>>>>>>>            // Remove all indices to speed up copying of data:
87125>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87130>>>>>>>            If (iRetval <> 0) Begin       
87132>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87133>>>>>>>>
87133>>>>>>>                Close hToTable
87134>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87137>>>>>>>                Function_Return False
87138>>>>>>>            End
87138>>>>>>>>
87138>>>>>>>        End
87138>>>>>>>>
87138>>>>>>>
87138>>>>>>>        Move (sRootName + ".err") to sErrorFile
87139>>>>>>>        Move 0 to iIndex
87140>>>>>>>        Move False to Err
87141>>>>>>>
87141>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
87143>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87146>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87151>>>>>>>            If (iRetval <> 0) Begin
87153>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87154>>>>>>>>
87154>>>>>>>                Close hToTable
87155>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87158>>>>>>>                Function_Return False
87159>>>>>>>            End
87159>>>>>>>>
87159>>>>>>>        End
87159>>>>>>>>
87159>>>>>>>        Else Begin
87160>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87163>>>>>>>        End
87163>>>>>>>>
87163>>>>>>>
87163>>>>>>>        If (Err = False) Begin
87165>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87166>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87167>>>>>>>        End
87167>>>>>>>>
87167>>>>>>>
87167>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87169>>>>>>>            // Recreate indices:
87169>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87174>>>>>>>            If (iRetval <> 0) Begin
87176>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87177>>>>>>>>
87177>>>>>>>                Close hToTable
87178>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87181>>>>>>>                Function_Return False
87182>>>>>>>            End
87182>>>>>>>>
87182>>>>>>>        End
87182>>>>>>>>
87182>>>>>>>
87182>>>>>>>        Close hToTable
87183>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87186>>>>>>>
87186>>>>>>>        If (bOK = True) Begin
87188>>>>>>>            Move (not(Err)) to bOK
87189>>>>>>>        End
87189>>>>>>>>
87189>>>>>>>
87189>>>>>>>        If (ghoStatusPanel <> 0) Begin
87191>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87192>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87193>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87194>>>>>>>        End
87194>>>>>>>>
87194>>>>>>>
87194>>>>>>>        Function_Return (bOK = True)
87195>>>>>>>    End_Function
87196>>>>>>>
87196>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87196>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87196>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87198>>>>>>>        Handle hFile
87198>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87198>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
87198>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
87198>>>>>>>        tSQLConnection SQLConnection
87198>>>>>>>        tSQLConnection SQLConnection
87198>>>>>>>        tAPIColumn[] aColumns
87198>>>>>>>        tAPIColumn[] aColumns
87199>>>>>>>        tColumnType ColumnType
87199>>>>>>>        tColumnType ColumnType
87199>>>>>>>
87199>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87199>>>>>>>        Get _UtilTableExists hTable to bOk
87200>>>>>>>        If (bOk = True) Begin
87202>>>>>>>            Function_Return False
87203>>>>>>>        End
87203>>>>>>>>
87203>>>>>>>
87203>>>>>>>        Set Private.phCurrentTable to hTable
87204>>>>>>>        Move sLogicalName to sTableName
87205>>>>>>>        If (ghoProgressBar <> 0) Begin
87207>>>>>>>            Send DoAdvance of ghoProgressBar
87208>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87209>>>>>>>        End
87209>>>>>>>>
87209>>>>>>>
87209>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87210>>>>>>>        Get psDriverID to sDriverID
87211>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87212>>>>>>>        Get piDbType to iDbType
87213>>>>>>>
87213>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87213>>>>>>>        Move False to bDeleteDummy
87214>>>>>>>        If (Num_Arguments = 8) Begin
87216>>>>>>>            Move aColumnIn to aColumns
87217>>>>>>>        End
87217>>>>>>>>
87217>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87219>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87220>>>>>>>            Move ColumnType.iSQLType to iDataType
87221>>>>>>>            If (bRecnum = False) Begin
87223>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87224>>>>>>>            End
87224>>>>>>>>
87224>>>>>>>            Else Begin
87225>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87226>>>>>>>            End
87226>>>>>>>>
87226>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87227>>>>>>>            Move True to bDeleteDummy
87228>>>>>>>        End
87228>>>>>>>>
87228>>>>>>>
87228>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87228>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87228>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87228>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87228>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87230>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87231>>>>>>>            Decrement iSize
87232>>>>>>>            for iCount from 0 to iSize
87238>>>>>>>>
87238>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87240>>>>>>>                    Move False to bRecnum
87241>>>>>>>                    Move iSize to iCount
87242>>>>>>>                End
87242>>>>>>>>
87242>>>>>>>            Loop
87243>>>>>>>>
87243>>>>>>>        End
87243>>>>>>>>
87243>>>>>>>
87243>>>>>>>        // If this is a SQL based driver we also check if the table exists
87243>>>>>>>        // in the SQL back end; in case we do nothing.
87243>>>>>>>        If (bSqlDriver = True) Begin
87245>>>>>>>            // Get all connection properties
87245>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87246>>>>>>>            Move SQLConnection.sSchema to sSchema
87247>>>>>>>            If (sSchema = "") Begin
87249>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87250>>>>>>>            End
87250>>>>>>>>
87250>>>>>>>
87250>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87251>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87251>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87251>>>>>>>            If (bExists = False) Begin
87253>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87254>>>>>>>            End
87254>>>>>>>>
87254>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87254>>>>>>>            // we will just add it to Filelist.cfg
87254>>>>>>>            If (bExists = True) Begin
87256>>>>>>>                If (bExistsInFilelist = False) Begin
87258>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87260>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87261>>>>>>>                    End
87261>>>>>>>>
87261>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87264>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87267>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87270>>>>>>>                    Move False to bSysFile
87271>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile False to bOK
87272>>>>>>>                End
87272>>>>>>>>
87272>>>>>>>                Function_Return False
87273>>>>>>>            End
87273>>>>>>>>
87273>>>>>>>        End
87273>>>>>>>>
87273>>>>>>>
87273>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87274>>>>>>>        If (num_arguments > 6) Begin
87276>>>>>>>            If (bANSI = False) Begin
87278>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87279>>>>>>>            End
87279>>>>>>>>
87279>>>>>>>        End
87279>>>>>>>>
87279>>>>>>>
87279>>>>>>>        Move False to Err
87280>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87282>>>>>>>            Move sRootName to sPhysicalFile
87283>>>>>>>        End
87283>>>>>>>>
87283>>>>>>>
87283>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87285>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87286>>>>>>>
87286>>>>>>>            // If DAW driver and we should use a connection id we need to
87286>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87286>>>>>>>            If (bUseConnectionID = True) Begin
87288>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87289>>>>>>>                If (bExists = False) Begin
87291>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
87292>>>>>>>                    If (bOk = False) Begin
87294>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87295>>>>>>>>
87295>>>>>>>                        Function_Return False
87296>>>>>>>                    End
87296>>>>>>>>
87296>>>>>>>                End
87296>>>>>>>>
87296>>>>>>>            End
87296>>>>>>>>
87296>>>>>>>
87296>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87298>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87299>>>>>>>            End
87299>>>>>>>>
87299>>>>>>>            Else Begin
87300>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87301>>>>>>>            End
87301>>>>>>>>
87301>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87302>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
87302>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87302>>>>>>>//            End
87302>>>>>>>        End
87302>>>>>>>>
87302>>>>>>>        Move False to Err
87303>>>>>>>        Move 0 to hFile
87304>>>>>>>
87304>>>>>>>        Structure_Start hFile sDriverID
87305>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87307>>>>>>>                If (bUseConnectionID = True) Begin
87309>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87312>>>>>>>                End
87312>>>>>>>>
87312>>>>>>>                Else Begin
87313>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87316>>>>>>>                End
87316>>>>>>>>
87316>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87319>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87322>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87325>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87328>>>>>>>
87328>>>>>>>                If (sSchema <> "") Begin
87330>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87333>>>>>>>                End
87333>>>>>>>>
87333>>>>>>>
87333>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87335>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87337>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87340>>>>>>>                    End
87340>>>>>>>>
87340>>>>>>>                End
87340>>>>>>>>
87340>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87342>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87344>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87347>>>>>>>                    End
87347>>>>>>>>
87347>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87349>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87352>>>>>>>                    End
87352>>>>>>>>
87352>>>>>>>                End
87352>>>>>>>>
87352>>>>>>>            End
87352>>>>>>>>
87352>>>>>>>
87352>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87355>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87356>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87357>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87359>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87360>>>>>>>
87360>>>>>>>        Move (not(Err)) to bOK
87361>>>>>>>        If (bOk = True) Begin
87363>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87365>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87366>>>>>>>            End
87366>>>>>>>>
87366>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87369>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87372>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87375>>>>>>>
87375>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87375>>>>>>>            If (bDeleteDummy) Begin
87377>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87378>>>>>>>            End
87378>>>>>>>>
87378>>>>>>>        End
87378>>>>>>>>
87378>>>>>>>
87378>>>>>>>        If (bOk = True and sDriverID <> DATAFLEX_ID) Begin
87380>>>>>>>            Send ResetFillSQLTables
87381>>>>>>>        End
87381>>>>>>>>
87381>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87382>>>>>>>        Close hTable
87383>>>>>>>        Function_Return bOK
87384>>>>>>>    End_Function
87385>>>>>>>
87385>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87387>>>>>>>        Move False to Err
87388>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87391>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87394>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87397>>>>>>>
87397>>>>>>>        Function_Return (Err = False)
87398>>>>>>>    End_Function
87399>>>>>>>
87399>>>>>>>    // ToDo: Needs to be revised
87399>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87401>>>>>>>        Handle hTable
87401>>>>>>>        String sDEFName sDataPath
87401>>>>>>>        Boolean bExists
87401>>>>>>>
87401>>>>>>>        // Do nothing if MSSQL Driver.
87401>>>>>>>//        Get IsMSSQLDriver to bExists
87401>>>>>>>//        If (bExists = True) Begin
87401>>>>>>>//            Procedure_Return
87401>>>>>>>//        End
87401>>>>>>>
87401>>>>>>>        Get psDataPathFirstPart to sDataPath
87402>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87403>>>>>>>        If (bExists = True) Begin
87405>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87405>>>>>>>            // still be missing from the filelist and needs to be added.
87405>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
87406>>>>>>>            If (bExists = True) Begin
87408>>>>>>>                Procedure_Return
87409>>>>>>>            End
87409>>>>>>>>
87409>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87409>>>>>>>            Else Begin
87410>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87413>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87416>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87419>>>>>>>                Procedure_Return
87420>>>>>>>            End
87420>>>>>>>>
87420>>>>>>>        End
87420>>>>>>>>
87420>>>>>>>
87420>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87421>>>>>>>        Move 0 to hTable
87422>>>>>>>        Move False to Err
87423>>>>>>>
87423>>>>>>>        Structure_Start hTable DATAFLEX_ID
87424>>>>>>>            Load_Def sDEFName Onto hTable
87425>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87428>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87429>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87431>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87432>>>>>>>
87432>>>>>>>        Move iFilelistSlot to hTable
87433>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87436>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87439>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87442>>>>>>>
87442>>>>>>>    End_Procedure
87443>>>>>>>
87443>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87445>>>>>>>        Boolean bTmp bErr bOK
87445>>>>>>>        String sTableName sDisplayName sFileName
87445>>>>>>>
87445>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87445>>>>>>>        Move Err to bTmp
87446>>>>>>>        Move False to Err
87447>>>>>>>
87447>>>>>>>        Get AutoConnectionIDLogin to bOK
87448>>>>>>>        // First get the info for the current filelist slot:
87448>>>>>>>        Open iFromFileSlot
87450>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87453>>>>>>>        If (bOK = True) Begin
87455>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87458>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87461>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87464>>>>>>>
87464>>>>>>>            //...then move it.
87464>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87467>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87470>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87473>>>>>>>
87473>>>>>>>            //...and finally remove the old filelist values.
87473>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87476>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87479>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87482>>>>>>>        End
87482>>>>>>>>
87482>>>>>>>        Close iFromFileSlot
87483>>>>>>>
87483>>>>>>>        Move Err to bErr
87484>>>>>>>        Move bTmp to Err
87485>>>>>>>        Function_Return (bErr = False)
87486>>>>>>>    End_Function
87487>>>>>>>
87487>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87489>>>>>>>        Handle hTable
87489>>>>>>>        Boolean bOK
87489>>>>>>>        String sDriverID
87489>>>>>>>
87489>>>>>>>        Get _UtilTableExists hTableFrom to bOK
87490>>>>>>>        If (bOK = False) Begin
87492>>>>>>>            Set Private.phCurrentTable to hTableFrom
87493>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. From Table:" * String(hTableFrom) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87494>>>>>>>>
87494>>>>>>>            Function_Return False
87495>>>>>>>        End
87495>>>>>>>>
87495>>>>>>>
87495>>>>>>>        Get _UtilTableExists hTableTo to bOK
87496>>>>>>>        If (bOK = False) Begin
87498>>>>>>>            Set Private.phCurrentTable to hTableTo
87499>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. To Table:" * String(hTableTo) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87500>>>>>>>>
87500>>>>>>>            Function_Return False
87501>>>>>>>        End
87501>>>>>>>>
87501>>>>>>>
87501>>>>>>>        Get AutoConnectionIDLogin to bOK
87502>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87503>>>>>>>        If (bOK = False) Begin
87505>>>>>>>            Function_Return False
87506>>>>>>>        End
87506>>>>>>>>
87506>>>>>>>
87506>>>>>>>        Move False to Err
87507>>>>>>>        Open hTableTo
87509>>>>>>>
87509>>>>>>>        Move hTableFrom to hTable
87510>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87513>>>>>>>        Set Private.phCurrentTable to hTable
87514>>>>>>>
87514>>>>>>>        Structure_Start hTable sDriverID
87515>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87518>>>>>>>            If (iColumnTo <> 0) Begin
87520>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87523>>>>>>>            End
87523>>>>>>>>
87523>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87524>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87526>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87527>>>>>>>
87527>>>>>>>        If (hTableTo > 0) Begin
87529>>>>>>>            Close hTableTo
87530>>>>>>>        End
87530>>>>>>>>
87530>>>>>>>
87530>>>>>>>        Function_Return (Err = False)
87531>>>>>>>    End_Function
87532>>>>>>>
87532>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87532>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87534>>>>>>>        String sTableName sDriverID
87534>>>>>>>        Boolean bOk
87534>>>>>>>        String sDataPath
87534>>>>>>>
87534>>>>>>>        Get AutoConnectionIDLogin to bOK
87535>>>>>>>        Move False to Err
87536>>>>>>>        Get psDriverID to sDriverID
87537>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87538>>>>>>>        If (sTableName = "") Begin
87540>>>>>>>            Function_Return False
87541>>>>>>>        End
87541>>>>>>>>
87541>>>>>>>
87541>>>>>>>        Set Private.phCurrentTable to hTable
87542>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87543>>>>>>>        Delete_db sTableName
87544>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87545>>>>>>>
87545>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87547>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87547>>>>>>>            Get psDataPathFirstPart to sDataPath
87548>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87549>>>>>>>        End
87549>>>>>>>>
87549>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87549>>>>>>>        If (hTable <> 0) Begin
87551>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87554>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87557>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87560>>>>>>>        End
87560>>>>>>>>
87560>>>>>>>
87560>>>>>>>        If (hTable <> 0 and sDriverID <> DATAFLEX_ID) Begin
87562>>>>>>>            Send ResetFillSQLTables
87563>>>>>>>        End
87563>>>>>>>>
87563>>>>>>>        Close hTable
87564>>>>>>>        Function_Return (hTable <> 0)
87565>>>>>>>    End_Function
87566>>>>>>>
87566>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87568>>>>>>>        Handle hTable
87568>>>>>>>        Boolean bOK
87568>>>>>>>
87568>>>>>>>        Get AutoConnectionIDLogin to bOK
87569>>>>>>>        Move False to Err
87570>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87572>>>>>>>        Move hTableFrom to hTable
87573>>>>>>>
87573>>>>>>>        Structure_Start hTable
87574>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87577>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87578>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87580>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87581>>>>>>>
87581>>>>>>>        Close hTableFrom
87582>>>>>>>        Function_Return (Err = False)
87583>>>>>>>    End_Function
87584>>>>>>>
87584>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87586>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87586>>>>>>>        Boolean bOK bExists bOpened
87586>>>>>>>        tAPITableNameInfo APITableNameInfo
87586>>>>>>>        tAPITableNameInfo APITableNameInfo
87586>>>>>>>
87586>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87589>>>>>>>        If (bOpened = False) Begin
87591>>>>>>>            Get OpenTableExclusive hTable to bOpened
87592>>>>>>>            If (bOpened = False) Begin
87594>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87595>>>>>>>                Function_Return False
87596>>>>>>>            End
87596>>>>>>>>
87596>>>>>>>        End
87596>>>>>>>>
87596>>>>>>>
87596>>>>>>>        Set Private.phCurrentTable to hTable
87597>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87598>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87599>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87600>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87601>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87602>>>>>>>        If (bExists = True) Begin
87604>>>>>>>            Function_Return True
87605>>>>>>>        End
87605>>>>>>>>
87605>>>>>>>
87605>>>>>>>        Set Private.phCurrentTable to hTable
87606>>>>>>>        Move False to Err
87607>>>>>>>        Get psDataPathFirstPart to sDataPath
87608>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87611>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87614>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87617>>>>>>>
87617>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87620>>>>>>>        Close hTable
87621>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87623>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87624>>>>>>>            If (bExists = True) Begin
87626>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87628>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87631>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87631>>>>>>>                    // might report "File in use..." and the deletion will fail.
87631>>>>>>>                    Sleep 2
87632>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87633>>>>>>>                End
87633>>>>>>>>
87633>>>>>>>            End
87633>>>>>>>>
87633>>>>>>>        End
87633>>>>>>>>
87633>>>>>>>
87633>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87635>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87637>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87638>>>>>>>            End
87638>>>>>>>>
87638>>>>>>>
87638>>>>>>>            // Change the table name in the .int file to the new table new:
87638>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87639>>>>>>>            If (bOK = False) Begin
87641>>>>>>>                Function_Return False
87642>>>>>>>            End
87642>>>>>>>>
87642>>>>>>>
87642>>>>>>>            // Change table name at the SQL side:
87642>>>>>>>            Get psSchema to sSchema
87643>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87644>>>>>>>
87644>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87645>>>>>>>            // Remove cache file and Rename the physical file names:
87645>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87646>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87647>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87648>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87649>>>>>>>
87649>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87649>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87649>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87649>>>>>>>//            End
87649>>>>>>>        End
87649>>>>>>>>
87649>>>>>>>
87649>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87652>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87655>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87658>>>>>>>
87658>>>>>>>        Function_Return (Err = False)
87659>>>>>>>    End_Function
87660>>>>>>>
87660>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87662>>>>>>>        Move False to Err
87663>>>>>>>        Set Private.phCurrentTable to hTable
87664>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87667>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87670>>>>>>>
87670>>>>>>>        Function_Return (Err = False)
87671>>>>>>>    End_Function
87672>>>>>>>
87672>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87674>>>>>>>        Handle hTable
87674>>>>>>>        String sTableName
87674>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87674>>>>>>>        Integer iDbType
87674>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK bSysfile
87674>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87674>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87674>>>>>>>        tSQLConnection SQLConnection
87674>>>>>>>        tSQLConnection SQLConnection
87674>>>>>>>        tAPITable      APITableFrom APITableTo
87674>>>>>>>        tAPITable      APITableFrom APITableTo
87674>>>>>>>        tColumnType    ColumnType
87674>>>>>>>        tColumnType    ColumnType
87674>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87674>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87675>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87675>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87676>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87676>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87677>>>>>>>
87677>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87677>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87679>>>>>>>            Function_Return False
87680>>>>>>>        End
87680>>>>>>>>
87680>>>>>>>        
87680>>>>>>>        Move True to bOk
87681>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87682>>>>>>>        Get piDbType                            to iDbType
87683>>>>>>>        Get pbRecnum                            to bRecnum
87684>>>>>>>        Get pbToANSI                            to bToANSI
87685>>>>>>>        Get pbCopyData                          to bCopyData
87686>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87687>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87688>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87689>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87690>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87691>>>>>>>
87691>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87692>>>>>>>        Set Private.phCurrentTable              to hTable
87693>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87694>>>>>>>
87694>>>>>>>        If (ghoProgressBar <> 0) Begin
87696>>>>>>>            Send DoAdvance of ghoProgressBar
87697>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87698>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87699>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87700>>>>>>>        End
87700>>>>>>>>
87700>>>>>>>
87700>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87701>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87702>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87703>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87704>>>>>>>        Move True                               to APITableFrom.bFromTable
87705>>>>>>>        Move hTable                             to APITableFrom.hTable
87706>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87707>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87708>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87709>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87710>>>>>>>
87710>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87710>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87712>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87713>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87714>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87716>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87719>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87720>>>>>>>>
87720>>>>>>>                Function_Return False
87721>>>>>>>            End
87721>>>>>>>>
87721>>>>>>>        End
87721>>>>>>>>
87721>>>>>>>
87721>>>>>>>        If (bTableExists = True) Begin
87723>>>>>>>            If (bIsSQLTableTo = True) Begin
87725>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87726>>>>>>>            End
87726>>>>>>>>
87726>>>>>>>            Get OpenTableExclusive hTable to bOpened
87727>>>>>>>            If (bOpened = False) Begin
87729>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87730>>>>>>>                Function_Return False
87731>>>>>>>            End
87731>>>>>>>>
87731>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87732>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87733>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87734>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87735>>>>>>>        End
87735>>>>>>>>
87735>>>>>>>
87735>>>>>>>        Move True to bOk
87736>>>>>>>        Move False to Err
87737>>>>>>>        Case Begin
87737>>>>>>>            // Alias table:
87737>>>>>>>            Case (bIsAliasFrom = True)
87739>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87739>>>>>>>                Case Break
87740>>>>>>>
87740>>>>>>>            Case (bIsSQLTableFrom = True and bIsSQLTableTo = False and bTableExists = True)
87743>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOk
87744>>>>>>>                    If (bOk = True) Begin
87746>>>>>>>                        Send LogError ("DataFlex table:" * String(APITableNameInfoFrom.sLogicalName) * "successfully converted to use driver:" * String(sDriverIDFrom)) False
87747>>>>>>>                    End
87747>>>>>>>>
87747>>>>>>>                Case Break
87748>>>>>>>            // New Table:
87748>>>>>>>            Case (bTableExists = False)
87751>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87752>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87752>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87754>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87755>>>>>>>                End                                                                 
87755>>>>>>>>
87755>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87756>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87757>>>>>>>                Case Break
87758>>>>>>>
87758>>>>>>>            // Update table:
87758>>>>>>>            Case (bTableExists = True)
87761>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87762>>>>>>>                If (bIsSame = True) Begin
87764>>>>>>>                    Case Break
87765>>>>>>>                End
87765>>>>>>>>
87765>>>>>>>                If (bFilelistError = True) Begin
87767>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87768>>>>>>>                    If (bOk = False) Begin
87770>>>>>>>                        Case Break
87771>>>>>>>                    End
87771>>>>>>>>
87771>>>>>>>                End
87771>>>>>>>>
87771>>>>>>>
87771>>>>>>>                If (ghoProgressBar <> 0) Begin
87773>>>>>>>                    Send DoAdvance of ghoProgressBar
87774>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87775>>>>>>>                End
87775>>>>>>>>
87775>>>>>>>
87775>>>>>>>                // Columns:
87775>>>>>>>                Move True to bOk
87776>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87777>>>>>>>                If (bIsSame = False) Begin
87779>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87780>>>>>>>                End
87780>>>>>>>>
87780>>>>>>>                If (bOk = False) Begin
87782>>>>>>>                    Case Break
87783>>>>>>>                End
87783>>>>>>>>
87783>>>>>>>
87783>>>>>>>                // Indexes:
87783>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87784>>>>>>>                If (bIsSame = False) Begin
87786>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87787>>>>>>>                End
87787>>>>>>>>
87787>>>>>>>
87787>>>>>>>                // Relations:
87787>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87788>>>>>>>                If (bIsSame = False) Begin
87790>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87791>>>>>>>                    If (bOk = False) Begin
87793>>>>>>>                        Case Break
87794>>>>>>>                    End
87794>>>>>>>>
87794>>>>>>>                End
87794>>>>>>>>
87794>>>>>>>
87794>>>>>>>                Case Break
87795>>>>>>>
87795>>>>>>>            Case Else
87795>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87796>>>>>>>>
87796>>>>>>>                Move False to bOk
87797>>>>>>>        Case End
87797>>>>>>>        
87797>>>>>>>        If (bOk = True) Begin
87799>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87799>>>>>>>            // or convert an embedded table to SQL
87799>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87801>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87802>>>>>>>                If (bOk = False) Begin
87804>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87805>>>>>>>                End
87805>>>>>>>>
87805>>>>>>>            End
87805>>>>>>>>
87805>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87808>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87809>>>>>>>            End
87809>>>>>>>>
87809>>>>>>>            
87809>>>>>>>            // Filelist Names:
87809>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87810>>>>>>>        End
87810>>>>>>>>
87810>>>>>>>        
87810>>>>>>>        // Refresh .int file: 
87810>>>>>>>        If (bIsSQLTableTo = True) Begin
87812>>>>>>>            Open hTable
87814>>>>>>>            Structure_Start hTable
87815>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
87817>>>>>>>            Send ResetFillSQLTables
87818>>>>>>>        End
87818>>>>>>>>
87818>>>>>>>
87818>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87819>>>>>>>
87819>>>>>>>        Function_Return bOK
87820>>>>>>>    End_Function
87821>>>>>>>
87821>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87821>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87823>>>>>>>        Function_Return False
87824>>>>>>>    End_Function
87825>>>>>>>
87825>>>>>>>    // Adds a column name to the passed table number.
87825>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87827>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87827>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87827>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87827>>>>>>>
87827>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87828>>>>>>>        If (bExists = True) Begin
87830>>>>>>>            Function_Return False
87831>>>>>>>        End
87831>>>>>>>>
87831>>>>>>>
87831>>>>>>>        Move False to Err
87832>>>>>>>        If (num_arguments > 4) Begin
87834>>>>>>>            Move iPrec to iPrecision
87835>>>>>>>        End
87835>>>>>>>>
87835>>>>>>>        If (num_arguments > 6) Begin
87837>>>>>>>            Move bInitVal to bInitializeValue
87838>>>>>>>            Move sColVal  to sColumnValue
87839>>>>>>>        End
87839>>>>>>>>
87839>>>>>>>        If (iType < -1490) Begin
87841>>>>>>>            Move (iType + 1500) to iType
87842>>>>>>>        End
87842>>>>>>>>
87842>>>>>>>
87842>>>>>>>        Move hTable to iFile
87843>>>>>>>        Get psDriverID to sDriverID
87844>>>>>>>        Get AutoConnectionIDLogin to bOK
87845>>>>>>>        Move False to Err
87846>>>>>>>        Move LastErr to iLastErr
87847>>>>>>>        Get OpenTableExclusive iFile to bOK
87848>>>>>>>        Set Private.phCurrentTable to hTable
87849>>>>>>>
87849>>>>>>>        Structure_Start iFile sDriverID
87850>>>>>>>            Move 0 to iColumn
87851>>>>>>>            Set Private.piCurrentField to iColumn
87852>>>>>>>            Create_Field hTable At iColumn
87853>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87856>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87859>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87862>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87865>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87866>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87868>>>>>>>
87868>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87869>>>>>>>
87869>>>>>>>        // If in development environment; create .fd file:
87869>>>>>>>        Open hTable
87871>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87872>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87873>>>>>>>        If (iCount > 1) Begin
87875>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87876>>>>>>>        End
87876>>>>>>>>
87876>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87877>>>>>>>        If (bExists = True) Begin
87879>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87880>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87883>>>>>>>            Get _TableNameOnly sTableName to sTableName
87884>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87886>>>>>>>        End
87886>>>>>>>>
87886>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87888>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87889>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87890>>>>>>>            If (iCount > 1) Begin
87892>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87893>>>>>>>            End
87893>>>>>>>>
87893>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87894>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87894>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87894>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87894>>>>>>>        End
87894>>>>>>>>
87894>>>>>>>        // Check for a default value
87894>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87896>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87897>>>>>>>        End
87897>>>>>>>>
87897>>>>>>>        Close hTable
87898>>>>>>>
87898>>>>>>>        Function_Return (Err = False)
87899>>>>>>>    End_Function
87900>>>>>>>
87900>>>>>>>    // Adds a column name to the passed table number.
87900>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87902>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87902>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87902>>>>>>>        String sDdSrcPath sTableName
87902>>>>>>>
87902>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87903>>>>>>>        Move False to Err
87904>>>>>>>        If (bExists = True) Begin
87906>>>>>>>            Function_Return False
87907>>>>>>>        End
87907>>>>>>>>
87907>>>>>>>        If (num_arguments > 4) Begin
87909>>>>>>>            Move iPrec to iPrecision
87910>>>>>>>        End
87910>>>>>>>>
87910>>>>>>>        If (iType < -1490) Begin
87912>>>>>>>            Move (iType + 1500) to iType
87913>>>>>>>        End
87913>>>>>>>>
87913>>>>>>>
87913>>>>>>>        Get AutoConnectionIDLogin to bOK
87914>>>>>>>        Move False to Err
87915>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87916>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87916>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87916>>>>>>>        Get piDbType to iDbType
87917>>>>>>>        If (bIsSQLTypeTo = False) Begin
87919>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87920>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87922>>>>>>>                Move DF_DATE to iType
87923>>>>>>>            End
87923>>>>>>>>
87923>>>>>>>        End
87923>>>>>>>>
87923>>>>>>>
87923>>>>>>>        // Structure_start will change the value of hTable...
87923>>>>>>>        Move hTable to iFile
87924>>>>>>>        Get OpenTableExclusive iFile to bOK
87925>>>>>>>        If (bOK = False) Begin
87927>>>>>>>            Function_Return False
87928>>>>>>>        End
87928>>>>>>>>
87928>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87931>>>>>>>
87931>>>>>>>        // If the passed column number is higher than the current number of fields
87931>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87931>>>>>>>        // a new field to the end:
87931>>>>>>>        If (iColumn > iNumberOfFields) Begin
87933>>>>>>>            Move 0 to iColumn
87934>>>>>>>        End
87934>>>>>>>>
87934>>>>>>>
87934>>>>>>>        Set Private.phCurrentTable to hTable
87935>>>>>>>        Set Private.piCurrentField to iColumn
87936>>>>>>>
87936>>>>>>>        Structure_Start iFile
87937>>>>>>>            Create_Field iFile At iColumn
87938>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87941>>>>>>>            If (bIsSQLTypeTo = False) Begin
87943>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87946>>>>>>>            End
87946>>>>>>>>
87946>>>>>>>            Else Begin
87947>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87950>>>>>>>            End
87950>>>>>>>>
87950>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87951>>>>>>>            If (bIsDateType = False) Begin
87953>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87956>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87959>>>>>>>            End
87959>>>>>>>>
87959>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87960>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87962>>>>>>>
87962>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87963>>>>>>>        // If in development environment; create .fd file:
87963>>>>>>>        Open hTable
87965>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87966>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87967>>>>>>>        If (iCount > 1) Begin
87969>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87970>>>>>>>        End
87970>>>>>>>>
87970>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87971>>>>>>>        If (bExists = True) Begin
87973>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87974>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87977>>>>>>>            Get _TableNameOnly sTableName to sTableName
87978>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87980>>>>>>>        End
87980>>>>>>>>
87980>>>>>>>
87980>>>>>>>        // Check for a default value
87980>>>>>>>        Close hTable
87981>>>>>>>
87981>>>>>>>        Function_Return (Err = False)
87982>>>>>>>    End_Function
87983>>>>>>>
87983>>>>>>>    // To update all records for a table column with a fixed value.
87983>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87985>>>>>>>        Integer iRecs iCurrErr iField iRecord
87985>>>>>>>        Boolean bRetval bOpen
87985>>>>>>>
87985>>>>>>>        Move 0 to iRecs
87986>>>>>>>        Move False to bRetval
87987>>>>>>>        Move Err to iCurrErr
87988>>>>>>>        Move False to Err
87989>>>>>>>
87989>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87992>>>>>>>        If (bOpen = False) Begin
87994>>>>>>>            Open hTable
87996>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87999>>>>>>>            If (bOpen = False) Begin
88001>>>>>>>                Function_Return bRetval
88002>>>>>>>            End
88002>>>>>>>>
88002>>>>>>>        End
88002>>>>>>>>
88002>>>>>>>
88002>>>>>>>        Field_Map hTable sFieldName to iField
88004>>>>>>>        If (iField <> 0) Begin
88006>>>>>>>            Set Private.phCurrentTable to hTable
88007>>>>>>>            Set Private.piCurrentField to iField
88008>>>>>>>            Clear hTable
88009>>>>>>>            Repeat
88009>>>>>>>>
88009>>>>>>>                Vfind hTable 0 GT
88011>>>>>>>                If (Found) Begin
88013>>>>>>>                    If (ghoStatusPanel <> 0) Begin
88015>>>>>>>                        Get_Field_Value hTable 0 to iRecord
88018>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
88019>>>>>>>                    End
88019>>>>>>>>
88019>>>>>>>                    Reread hTable
88023>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
88026>>>>>>>                        SaveRecord hTable
88027>>>>>>>                    Unlock
88028>>>>>>>>
88028>>>>>>>                End
88028>>>>>>>>
88028>>>>>>>           Until (not(Found))
88030>>>>>>>        End
88030>>>>>>>>
88030>>>>>>>
88030>>>>>>>        Move (Err = False) to bRetval
88031>>>>>>>        Move iCurrErr to Err
88032>>>>>>>
88032>>>>>>>        Function_Return bRetval
88033>>>>>>>    End_Function
88034>>>>>>>
88034>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
88034>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
88036>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
88036>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
88036>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
88036>>>>>>>
88036>>>>>>>        Get psDriverID to sDriverID
88037>>>>>>>        Get piDbType to iDbType
88038>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88039>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
88040>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
88041>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
88042>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
88044>>>>>>>            Move True to bIsSqlTable
88045>>>>>>>        End
88045>>>>>>>>
88045>>>>>>>        Move False to bIsOpen
88046>>>>>>>        If (hTable > 0) Begin
88048>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88051>>>>>>>        End
88051>>>>>>>>
88051>>>>>>>        If (bIsOpen = True) Begin
88053>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88056>>>>>>>        End
88056>>>>>>>>
88056>>>>>>>        Else Begin
88057>>>>>>>            Get pbRecnum to bRecnumTable
88058>>>>>>>        End
88058>>>>>>>>
88058>>>>>>>
88058>>>>>>>        Move False to Err
88059>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
88060>>>>>>>        Decrement iSize
88061>>>>>>>        for iCount from 0 to iSize
88067>>>>>>>>
88067>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
88068>>>>>>>            If (hTable > 0) Begin
88070>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88071>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88072>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
88075>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
88076>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88077>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88078>>>>>>>            End
88078>>>>>>>>
88078>>>>>>>            Else Begin
88079>>>>>>>                Move False to bFieldExists
88080>>>>>>>            End
88080>>>>>>>>
88080>>>>>>>
88080>>>>>>>            If (bFieldExists = False) Begin
88082>>>>>>>                Move 0 to iColumn
88083>>>>>>>                Create_Field hTable At iColumn
88084>>>>>>>            End
88084>>>>>>>>
88084>>>>>>>            Else Begin
88085>>>>>>>                Move iCount to iColumn
88086>>>>>>>            End
88086>>>>>>>>
88086>>>>>>>
88086>>>>>>>            Set Private.piCurrentField to iColumn
88087>>>>>>>
88087>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
88088>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
88091>>>>>>>
88091>>>>>>>            Move aColumns[iCount].iType to iType
88092>>>>>>>            Move (not(iType < -1490)) to bNativeType
88093>>>>>>>            If (iType < -1490) Begin
88095>>>>>>>                Move (iType + 1500) to iType
88096>>>>>>>            End
88096>>>>>>>>
88096>>>>>>>
88096>>>>>>>            If (bIsSqlTable = True) Begin
88098>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
88100>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
88101>>>>>>>//                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
88101>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
88104>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
88107>>>>>>>
88107>>>>>>>                    Move aColumns[iCount].sDefaultValue  to sDefaultValue
88108>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88110>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88111>>>>>>>                    End
88111>>>>>>>>
88111>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
88114>>>>>>>
88114>>>>>>>                End
88114>>>>>>>>
88114>>>>>>>                Else Begin
88115>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
88118>>>>>>>                End
88118>>>>>>>>
88118>>>>>>>            End
88118>>>>>>>>
88118>>>>>>>            Else Begin
88119>>>>>>>                If (bCreating = False) Begin
88121>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88122>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88124>>>>>>>                        Move DF_DATE to iType
88125>>>>>>>                    End
88125>>>>>>>>
88125>>>>>>>                End
88125>>>>>>>>
88125>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88128>>>>>>>            End
88128>>>>>>>>
88128>>>>>>>
88128>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
88129>>>>>>>            If (bIsDateType = False) Begin
88131>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88134>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88137>>>>>>>            End
88137>>>>>>>>
88137>>>>>>>
88137>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
88139>>>>>>>                Move 0 to iIndex
88140>>>>>>>                Create_Index hTable at iIndex
88141>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88144>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
88147>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88150>>>>>>>
88150>>>>>>>                // If we have an identity table - we must create a primary_key table.
88150>>>>>>>                If (bIsSqlTable = True) Begin
88152>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88155>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88158>>>>>>>                End
88158>>>>>>>>
88158>>>>>>>            End
88158>>>>>>>>
88158>>>>>>>        Loop
88159>>>>>>>>
88159>>>>>>>
88159>>>>>>>        Function_Return (Err = False)
88160>>>>>>>    End_Function
88161>>>>>>>
88161>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88161>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88163>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88163>>>>>>>        Boolean bOK bIsSqlTable
88163>>>>>>>        String sFieldNameTo
88163>>>>>>>
88163>>>>>>>        If (num_arguments > 4) Begin
88165>>>>>>>            Move iPrec to iPrecFrom
88166>>>>>>>        End
88166>>>>>>>>
88166>>>>>>>        If (iTypeFrom < -1490) Begin
88168>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88169>>>>>>>        End
88169>>>>>>>>
88169>>>>>>>
88169>>>>>>>        Get AutoConnectionIDLogin to bOK
88170>>>>>>>        Move False to Err
88171>>>>>>>        Get OpenTableExclusive hTable to bOK
88172>>>>>>>        If (bOK = False) Begin
88174>>>>>>>            Function_Return False
88175>>>>>>>        End
88175>>>>>>>>
88175>>>>>>>
88175>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88176>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88177>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88179>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88180>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88181>>>>>>>        If (Err = True) Begin
88183>>>>>>>            Function_Return False
88184>>>>>>>        End
88184>>>>>>>>
88184>>>>>>>
88184>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88187>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
88188>>>>>>>        If (bIsSqlTable = False) Begin
88190>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88193>>>>>>>        End
88193>>>>>>>>
88193>>>>>>>        Else Begin
88194>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88197>>>>>>>        End
88197>>>>>>>>
88197>>>>>>>        // Let the driver decide the other values;
88197>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88200>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88203>>>>>>>
88203>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88205>>>>>>>            Function_Return False
88206>>>>>>>        End
88206>>>>>>>>
88206>>>>>>>
88206>>>>>>>        Set Private.phCurrentTable to hTable
88207>>>>>>>        Set Private.piCurrentField to iColumn
88208>>>>>>>
88208>>>>>>>        Structure_Start hTable
88209>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88212>>>>>>>            If (bIsSqlTable = False) Begin
88214>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88217>>>>>>>            End
88217>>>>>>>>
88217>>>>>>>            Else Begin
88218>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88221>>>>>>>            End
88221>>>>>>>>
88221>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
88224>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88227>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88228>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88230>>>>>>>
88230>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88231>>>>>>>        Function_Return (Err = False)
88232>>>>>>>    End_Function
88233>>>>>>>
88233>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88233>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88235>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88235>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88235>>>>>>>        String sFieldNameTo sDriverIDTo
88235>>>>>>>        tColumnType ColumnType
88235>>>>>>>        tColumnType ColumnType
88235>>>>>>>
88235>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88236>>>>>>>        Get piDbType to iDbType
88237>>>>>>>        If (num_arguments > 4) Begin
88239>>>>>>>            Move iPrec to iPrecFrom
88240>>>>>>>            Move iOpt  to iOptionFrom
88241>>>>>>>        End
88241>>>>>>>>
88241>>>>>>>        If (iTypeFrom < -1490) Begin
88243>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88244>>>>>>>        End
88244>>>>>>>>
88244>>>>>>>
88244>>>>>>>        Get AutoConnectionIDLogin to bOK
88245>>>>>>>        Move False to Err
88246>>>>>>>        Close hTable
88247>>>>>>>        Get OpenTableExclusive hTable to bOK
88248>>>>>>>        If (bOK = False) Begin
88250>>>>>>>            Function_Return False
88251>>>>>>>        End
88251>>>>>>>>
88251>>>>>>>
88251>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88254>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88257>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88258>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88260>>>>>>>            Move DF_DATE to iDataFlexType
88261>>>>>>>        End
88261>>>>>>>>
88261>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88264>>>>>>>
88264>>>>>>>        If (bIsSQLTableTo = True) Begin
88266>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
88269>>>>>>>        End
88269>>>>>>>>
88269>>>>>>>        Else Begin
88270>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88273>>>>>>>        End
88273>>>>>>>>
88273>>>>>>>
88273>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88276>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88279>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
88282>>>>>>>
88282>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88282>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
88282>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88284>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
88285>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88287>>>>>>>                Move DF_DATE to iTypeTo  
88288>>>>>>>            End
88288>>>>>>>>
88288>>>>>>>        End
88288>>>>>>>>
88288>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88291>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
88292>>>>>>>        End
88292>>>>>>>>
88292>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88293>>>>>>>
88293>>>>>>>        If (bCompareDate_DateTime = False) Begin
88295>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88296>>>>>>>            If (bSkip = True) Begin
88298>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88300>>>>>>>                    Function_Return True
88301>>>>>>>                End
88301>>>>>>>>
88301>>>>>>>            End
88301>>>>>>>>
88301>>>>>>>        End
88301>>>>>>>>
88301>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88304>>>>>>>            Function_Return True
88305>>>>>>>        End
88305>>>>>>>>
88305>>>>>>>
88305>>>>>>>        Set Private.phCurrentTable to hTable
88306>>>>>>>        Set Private.piCurrentField to iColumn
88307>>>>>>>
88307>>>>>>>        Structure_Start hTable
88308>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88310>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88313>>>>>>>            End
88313>>>>>>>>
88313>>>>>>>
88313>>>>>>>            If (bIsSameDataType = False) Begin
88315>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88318>>>>>>>                If (bIsSQLTableTo = True) Begin
88320>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
88323>>>>>>>                End
88323>>>>>>>>
88323>>>>>>>            End
88323>>>>>>>>
88323>>>>>>>
88323>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
88325>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88328>>>>>>>            End
88328>>>>>>>>
88328>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
88330>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88333>>>>>>>            End
88333>>>>>>>>
88333>>>>>>>
88333>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88335>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88335>>>>>>>                If (bRecnumTable = True) Begin
88337>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88340>>>>>>>                End
88340>>>>>>>>
88340>>>>>>>
88340>>>>>>>                // We might need to create an index here.
88340>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88340>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88340>>>>>>>                // index update checking logic.
88340>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88343>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88345>>>>>>>                    Create_Index hTable At iIndex
88346>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88349>>>>>>>                End
88349>>>>>>>>
88349>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88352>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88355>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88358>>>>>>>                If (bIsSQLTableTo = True) Begin
88360>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88363>>>>>>>                End
88363>>>>>>>>
88363>>>>>>>            End
88363>>>>>>>>
88363>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88364>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88366>>>>>>>
88366>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88367>>>>>>>        Function_Return (Err = False)
88368>>>>>>>    End_Function
88369>>>>>>>
88369>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88371>>>>>>>        Boolean bOK
88371>>>>>>>
88371>>>>>>>        Get AutoConnectionIDLogin to bOK
88372>>>>>>>        Move False to Err
88373>>>>>>>        Get OpenTableExclusive hTable to bOK
88374>>>>>>>        If (bOK = False) Begin
88376>>>>>>>            Function_Return False
88377>>>>>>>        End
88377>>>>>>>>
88377>>>>>>>
88377>>>>>>>        Structure_Start hTable
88378>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88381>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88382>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88384>>>>>>>
88384>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88385>>>>>>>        Function_Return (Err = False)
88386>>>>>>>    End_Function
88387>>>>>>>
88387>>>>>>>    // To move an existing field to another position in a table.
88387>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
88389>>>>>>>        String sColumn sDriverID
88389>>>>>>>        Integer iType iSQLType
88389>>>>>>>        Boolean bOK bIsDate
88389>>>>>>>
88389>>>>>>>        Close hTable
88390>>>>>>>        Get AutoConnectionIDLogin to bOK
88391>>>>>>>        Get OpenTableExclusive hTable to bOK
88392>>>>>>>        If (bOK = False) Begin
88394>>>>>>>            Function_Return False
88395>>>>>>>        End
88395>>>>>>>>
88395>>>>>>>
88395>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88398>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88400>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88401>>>>>>>>
88401>>>>>>>            Function_Return False
88402>>>>>>>        End
88402>>>>>>>>
88402>>>>>>>
88402>>>>>>>        Set Action_Text of ghoStatusPanel to "Restructures table..."
88403>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88406>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88409>>>>>>>        If (bIsSQLType = True) Begin
88411>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iOld to iSQLType
88414>>>>>>>            Get UtilColumnIsDateType iSQLType bIsSQLType  to bIsDate
88415>>>>>>>        End
88415>>>>>>>>
88415>>>>>>>        Else Begin
88416>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
88417>>>>>>>        End
88417>>>>>>>>
88417>>>>>>>
88417>>>>>>>        Set Private.phCurrentTable to hTable
88418>>>>>>>        Set Private.piCurrentField to iOld
88419>>>>>>>
88419>>>>>>>        Move False to Err
88420>>>>>>>
88420>>>>>>>        Structure_Start hTable
88421>>>>>>>            Delete_Field hTable iOld
88422>>>>>>>            Create_Field hTable At iNew
88423>>>>>>>            
88423>>>>>>>            // This one is the crucial line:
88423>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88426>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88429>>>>>>>            
88429>>>>>>>            // If SQL table it is important that we don't try to change the field type, as MS-SQL then will generate an error.
88429>>>>>>>            If (bIsSQLType = True and bIsDate = False) Begin
88431>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
88434>>>>>>>            End
88434>>>>>>>>
88434>>>>>>>            If (bIsDate = False) Begin
88436>>>>>>>                Set_Attribute DF_FIELD_TYPE   of hTable iNew to iType
88439>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88442>>>>>>>            End
88442>>>>>>>>
88442>>>>>>>            If (iType = DF_BCD) Begin
88444>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88447>>>>>>>            End
88447>>>>>>>>
88447>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88449>>>>>>>
88449>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88450>>>>>>>        Move (not(Err)) to bOK
88451>>>>>>>        Move False to Err
88452>>>>>>>        Move 0 to LastErr
88453>>>>>>>        Function_Return bOK
88454>>>>>>>    End_Function 
88455>>>>>>>    
88455>>>>>>>    // Deletes a column name for the passed table number (and column number).
88455>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88457>>>>>>>        Integer iColumn
88457>>>>>>>        Boolean bOK
88457>>>>>>>
88457>>>>>>>        Get AutoConnectionIDLogin to bOK
88458>>>>>>>        Move False to Err
88459>>>>>>>        Close hTable
88460>>>>>>>        Get OpenTableExclusive hTable to bOK
88461>>>>>>>        If (bOK = False) Begin
88463>>>>>>>            Function_Return False
88464>>>>>>>        End
88464>>>>>>>>
88464>>>>>>>
88464>>>>>>>        If (not(Err)) Begin
88466>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88467>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88468>>>>>>>            Field_Map hTable sFieldName to iColumn
88470>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88471>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88472>>>>>>>            If (iColumn = 0) Begin
88474>>>>>>>                Move 0 to LastErr
88475>>>>>>>                Function_Return False
88476>>>>>>>            End
88476>>>>>>>>
88476>>>>>>>            Move False to Err
88477>>>>>>>
88477>>>>>>>            Set Private.phCurrentTable to hTable
88478>>>>>>>            Set Private.piCurrentField to iColumn
88479>>>>>>>
88479>>>>>>>            Structure_Start hTable
88480>>>>>>>                Delete_Field hTable iColumn
88481>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88482>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88484>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88485>>>>>>>        End
88485>>>>>>>>
88485>>>>>>>        Else Begin
88486>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88487>>>>>>>>
88487>>>>>>>        End
88487>>>>>>>>
88487>>>>>>>
88487>>>>>>>        Function_Return (Err = False)
88488>>>>>>>    End_Function
88489>>>>>>>
88489>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88489>>>>>>>    // Returns True if no errors occured.
88489>>>>>>>    // Sample usage:
88489>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88489>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88491>>>>>>>        Integer iField
88491>>>>>>>        Boolean bOK bExists bIsOpen
88491>>>>>>>
88491>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88492>>>>>>>        If (bExists = True) Begin
88494>>>>>>>            Function_Return False
88495>>>>>>>        End
88495>>>>>>>>
88495>>>>>>>
88495>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
88495>>>>>>>        //       opened exclusively, so we first open it in normal mode.
88495>>>>>>>        Close hTable
88496>>>>>>>        Open hTable
88498>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88501>>>>>>>        If (bIsOpen = False) Begin
88503>>>>>>>            Function_Return False
88504>>>>>>>        End
88504>>>>>>>>
88504>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88505>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88506>>>>>>>        Field_Map hTable sOldFieldName to iField
88508>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88509>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88510>>>>>>>
88510>>>>>>>        Get AutoConnectionIDLogin to bOK
88511>>>>>>>        Get OpenTableExclusive hTable to bOK
88512>>>>>>>        If (bOK = False) Begin
88514>>>>>>>            Function_Return False
88515>>>>>>>        End
88515>>>>>>>>
88515>>>>>>>
88515>>>>>>>        Move False to Err
88516>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88517>>>>>>>        Set Private.phCurrentTable to hTable
88518>>>>>>>        Set Private.piCurrentField to iField
88519>>>>>>>
88519>>>>>>>        If (iField > 0) Begin
88521>>>>>>>            Structure_Start hTable
88522>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88525>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88526>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88528>>>>>>>        End
88528>>>>>>>>
88528>>>>>>>        Else Begin
88529>>>>>>>            Move 0 to LastErr
88530>>>>>>>            Move False to Err
88531>>>>>>>        End
88531>>>>>>>>
88531>>>>>>>
88531>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88532>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88533>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88534>>>>>>>
88534>>>>>>>        Function_Return (Err = False)
88535>>>>>>>    End_Function
88536>>>>>>>
88536>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88538>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88538>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88539>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88539>>>>>>>        Boolean bRenameField
88539>>>>>>>
88539>>>>>>>        Open hTable
88541>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88542>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88543>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88544>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88547>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88548>>>>>>>        Decrement iSize
88549>>>>>>>        for iCount from 0 to iSize
88555>>>>>>>>
88555>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88557>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88558>>>>>>>
88558>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88560>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88562>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88563>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88564>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88566>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88567>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88568>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88569>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88570>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88571>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88572>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88573>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88574>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88575>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88576>>>>>>>                        Increment iItem
88577>>>>>>>                    End
88577>>>>>>>>
88577>>>>>>>                End
88577>>>>>>>>
88577>>>>>>>            End
88577>>>>>>>>
88577>>>>>>>        Loop
88578>>>>>>>>
88578>>>>>>>
88578>>>>>>>        Move False to Err
88579>>>>>>>        Move 0 to LastErr
88580>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88581>>>>>>>        Function_Return aAPIColumnsToInsert
88582>>>>>>>    End_Function
88583>>>>>>>
88583>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88585>>>>>>>        Integer iSize iCount
88585>>>>>>>        Boolean bOK
88585>>>>>>>        tAPIColumn[] aColumnsTo
88585>>>>>>>        tAPIColumn[] aColumnsTo
88586>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88586>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88587>>>>>>>
88587>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88588>>>>>>>        If (iSize = 0) Begin
88590>>>>>>>            Function_Return True
88591>>>>>>>        End
88591>>>>>>>>
88591>>>>>>>
88591>>>>>>>        Move False to Err
88592>>>>>>>        Decrement iSize
88593>>>>>>>        for iCount from 0 to iSize
88599>>>>>>>>
88599>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88600>>>>>>>        Loop
88601>>>>>>>>
88601>>>>>>>
88601>>>>>>>        Function_Return bOK
88602>>>>>>>    End_Function
88603>>>>>>>
88603>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88603>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88605>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88605>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88606>>>>>>>        Integer iSize iCount iItem iShouldMove
88606>>>>>>>
88606>>>>>>>        Move 0 to iItem
88607>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88608>>>>>>>        Decrement iSize
88609>>>>>>>        for iCount from 0 to iSize
88615>>>>>>>>
88615>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88617>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88618>>>>>>>                If (iShouldMove <> -1) Begin
88620>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88621>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88622>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88623>>>>>>>                    Increment iItem
88624>>>>>>>                End
88624>>>>>>>>
88624>>>>>>>            End
88624>>>>>>>>
88624>>>>>>>        Loop
88625>>>>>>>>
88625>>>>>>>
88625>>>>>>>        Move False to Err
88626>>>>>>>        Move 0 to LastErr
88627>>>>>>>        Function_Return aAPIColumnsToMove
88628>>>>>>>    End_Function
88629>>>>>>>
88629>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88631>>>>>>>        Integer iSize iCount
88631>>>>>>>        Boolean bOK
88631>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88631>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88632>>>>>>>
88632>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88633>>>>>>>        If (iSize = 0) Begin
88635>>>>>>>            Function_Return True
88636>>>>>>>        End
88636>>>>>>>>
88636>>>>>>>
88636>>>>>>>        Move False to Err
88637>>>>>>>        Decrement iSize
88638>>>>>>>        for iCount from 0 to iSize
88644>>>>>>>>
88644>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88645>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88647>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88648>>>>>>>                If (bOK = True) Begin
88650>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88651>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88652>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88653>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88655>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88656>>>>>>>                        Decrement iSize
88657>>>>>>>                        Move 0 to iCount
88658>>>>>>>                    End
88658>>>>>>>>
88658>>>>>>>                End
88658>>>>>>>>
88658>>>>>>>                Else Begin
88659>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88660>>>>>>>                End
88660>>>>>>>>
88660>>>>>>>            End
88660>>>>>>>>
88660>>>>>>>        Loop
88661>>>>>>>>
88661>>>>>>>
88661>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88662>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88664>>>>>>>            Move 0 to LastErr
88665>>>>>>>        End
88665>>>>>>>>
88665>>>>>>>        Function_Return bOK
88666>>>>>>>    End_Function
88667>>>>>>>
88667>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88667>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88667>>>>>>>    // - The "FROM" field name is <> "TO" field name
88667>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88667>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88667>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88669>>>>>>>        Boolean bShouldRename
88669>>>>>>>        String sFieldNameFrom sFieldNameTo
88669>>>>>>>
88669>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88670>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88671>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88673>>>>>>>            Function_Return False
88674>>>>>>>        End
88674>>>>>>>>
88674>>>>>>>
88674>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88675>>>>>>>//        If (bShouldRename = False) Begin
88675>>>>>>>//            Function_Return False
88675>>>>>>>//        End
88675>>>>>>>//
88675>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88675>>>>>>>//            Function_Return True
88675>>>>>>>//        End
88675>>>>>>>
88675>>>>>>>        Function_Return bShouldRename
88676>>>>>>>    End_Function
88677>>>>>>>
88677>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88677>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88677>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88679>>>>>>>        Integer iCount iSize iRetval
88679>>>>>>>        String sFieldNameFrom
88679>>>>>>>
88679>>>>>>>        Move -1 to iRetval
88680>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88682>>>>>>>            Function_Return iRetval
88683>>>>>>>        End
88683>>>>>>>>
88683>>>>>>>
88683>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88684>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88685>>>>>>>        Decrement iSize
88686>>>>>>>        for iCount from 0 to iSize
88692>>>>>>>>
88692>>>>>>>            // We're only interested in fields other than the passed field/column number:
88692>>>>>>>            If (iCount <> iColumn) Begin
88694>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88696>>>>>>>                    Move (iCount + 1) to iRetval
88697>>>>>>>                End
88697>>>>>>>>
88697>>>>>>>            End
88697>>>>>>>>
88697>>>>>>>        Loop
88698>>>>>>>>
88698>>>>>>>
88698>>>>>>>        Move 0 to LastErr
88699>>>>>>>        Function_Return iRetval
88700>>>>>>>    End_Function
88701>>>>>>>
88701>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88703>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88703>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88704>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88704>>>>>>>        Boolean bRenameField
88704>>>>>>>
88704>>>>>>>        Open hTable
88706>>>>>>>        Move 0 to iItem
88707>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88708>>>>>>>        Decrement iSize
88709>>>>>>>        for iCount from 0 to iSize
88715>>>>>>>>
88715>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88717>>>>>>>                // Check if the field exists in another position (other field number)
88717>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88718>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88719>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88721>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88722>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88723>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88724>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88725>>>>>>>                    Increment iItem
88726>>>>>>>                End
88726>>>>>>>>
88726>>>>>>>            End
88726>>>>>>>>
88726>>>>>>>        Loop
88727>>>>>>>>
88727>>>>>>>
88727>>>>>>>        Move False to Err
88728>>>>>>>        Move 0 to LastErr
88729>>>>>>>        Function_Return aAPIColumnsToRename
88730>>>>>>>    End_Function
88731>>>>>>>
88731>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88733>>>>>>>        Integer iSize iCount
88733>>>>>>>        Boolean bOK
88733>>>>>>>        tAPIColumn[] aColumnsTo
88733>>>>>>>        tAPIColumn[] aColumnsTo
88734>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88734>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88735>>>>>>>
88735>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88736>>>>>>>        If (iSize = 0) Begin
88738>>>>>>>            Function_Return True
88739>>>>>>>        End
88739>>>>>>>>
88739>>>>>>>
88739>>>>>>>        Move False to Err
88740>>>>>>>        Decrement iSize
88741>>>>>>>        For iCount from 0 to iSize
88747>>>>>>>>
88747>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88748>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88749>>>>>>>        Loop
88750>>>>>>>>
88750>>>>>>>
88750>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88751>>>>>>>        Function_Return bOK
88752>>>>>>>    End_Function
88753>>>>>>>
88753>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88755>>>>>>>        Boolean bDateType
88755>>>>>>>
88755>>>>>>>        If (bIsSQLTableTo = True) Begin
88757>>>>>>>            Move (iType = SQL_DATE or iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88758>>>>>>>        End
88758>>>>>>>>
88758>>>>>>>        Else Begin
88759>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88760>>>>>>>        End
88760>>>>>>>>
88760>>>>>>>
88760>>>>>>>        Function_Return bDateType
88761>>>>>>>    End_Function
88762>>>>>>>
88762>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88764>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88764>>>>>>>        Integer iCount2 iColumn2
88764>>>>>>>        Handle hFile
88764>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88764>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88764>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88764>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88764>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88769>>>>>>>        tColumnType ColumnType
88769>>>>>>>        tColumnType ColumnType
88769>>>>>>>
88769>>>>>>>        Move False to Err
88770>>>>>>>        Close hTable
88771>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88772>>>>>>>        If (bIsOpen = False) Begin
88774>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88775>>>>>>>>
88775>>>>>>>            Function_Return False
88776>>>>>>>        End 
88776>>>>>>>>
88776>>>>>>>        
88776>>>>>>>        Get piDbType to iDbType
88777>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88780>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88781>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88782>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88785>>>>>>>
88785>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88786>>>>>>>
88786>>>>>>>        // Before we start to change the table we need to do three things;
88786>>>>>>>        // 1) Insert any new fields
88786>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88787>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88789>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88790>>>>>>>            If (bOK = False) Begin
88792>>>>>>>                Function_Return False
88793>>>>>>>            End
88793>>>>>>>>
88793>>>>>>>            // Update info with changes made.
88793>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88794>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88795>>>>>>>        End
88795>>>>>>>>
88795>>>>>>>
88795>>>>>>>        // 2) Move fields with same names
88795>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88796>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88798>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88799>>>>>>>            If (bOK = False) Begin
88801>>>>>>>                Function_Return False
88802>>>>>>>            End
88802>>>>>>>>
88802>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88803>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88804>>>>>>>        End
88804>>>>>>>>
88804>>>>>>>        
88804>>>>>>>        // 3) Rename fields
88804>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88805>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88807>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88808>>>>>>>            If (bOK = False) Begin
88810>>>>>>>                Function_Return False
88811>>>>>>>            End
88811>>>>>>>>
88811>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88812>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88813>>>>>>>        End
88813>>>>>>>>
88813>>>>>>>
88813>>>>>>>        // Note: Fields will be removed if needed in the Structure_Start/End below.
88813>>>>>>>        // Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88813>>>>>>>
88813>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88813>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88815>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88816>>>>>>>            If (bIsSame = True) Begin
88818>>>>>>>                Function_Return True
88819>>>>>>>            End
88819>>>>>>>>
88819>>>>>>>        End
88819>>>>>>>>
88819>>>>>>>
88819>>>>>>>        Move False to Err
88820>>>>>>>        // We can now continue to make standard field changes:
88820>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88821>>>>>>>        Set Private.phCurrentTable to hTable
88822>>>>>>>        Move hTable to hFile
88823>>>>>>>        Structure_Start hFile sDriverIDTo
88824>>>>>>>
88824>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88825>>>>>>>            Decrement iColumns
88826>>>>>>>            for iCount from 0 to iColumns
88832>>>>>>>>
88832>>>>>>>                Send DoAdvance of ghoProgressBar
88833>>>>>>>
88833>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88834>>>>>>>                Set Private.piCurrentField                  to iColumn
88835>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88836>>>>>>>                If (bIsSame = False) Begin
88838>>>>>>>
88838>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88839>>>>>>>                    If (bFieldExistsFrom = True) Begin
88841>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88842>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88843>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88844>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88845>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88846>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88847>>>>>>>
88847>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88848>>>>>>>                        If (iTypeFrom < -1490) Begin
88850>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88851>>>>>>>                        End
88851>>>>>>>>
88851>>>>>>>
88851>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88851>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88851>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88853>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88854>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88856>>>>>>>                                Move DF_DATE to iTypeFrom
88857>>>>>>>                            End
88857>>>>>>>>
88857>>>>>>>                        End
88857>>>>>>>>
88857>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88860>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88861>>>>>>>                        End
88861>>>>>>>>
88861>>>>>>>
88861>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88862>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88863>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88864>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88865>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88866>>>>>>>
88866>>>>>>>                        Move False to bSkipTypeChange
88867>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88869>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88870>>>>>>>                        End
88870>>>>>>>>
88870>>>>>>>
88870>>>>>>>                        If (bFieldExistsTo = False) Begin
88872>>>>>>>                            Move 0 to iColumn
88873>>>>>>>                            Create_Field hFile At iColumn
88874>>>>>>>                            Set Private.piCurrentField to iColumn
88875>>>>>>>                        End
88875>>>>>>>>
88875>>>>>>>
88875>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88877>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88880>>>>>>>                        End
88880>>>>>>>>
88880>>>>>>>
88880>>>>>>>                        // Note: In MS-SQL it is vital that *nothing* gets changed for e.g. a "datetime" column, else error: 22018 is generated by the SQL backend:
88880>>>>>>>                        //       "Explicit conversion from data type int to datetime2 is not allowed", which will make the update to fail, and all changes for the table is rollbacked. 
88880>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity and bSkipTypeChange = False) Begin
88882>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88885>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88886>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88888>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88889>>>>>>>                            End
88889>>>>>>>>
88889>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88892>>>>>>>                        End
88892>>>>>>>>
88892>>>>>>>
88892>>>>>>>                        If (bSkipTypeChange = False) Begin
88894>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88896>>>>>>>                                If (bIsSQLTableTo = True) Begin
88898>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88901>>>>>>>                                End
88901>>>>>>>>
88901>>>>>>>                                Else Begin                                                   
88902>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88904>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88905>>>>>>>                                    End
88905>>>>>>>>
88905>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88908>>>>>>>                                End
88908>>>>>>>>
88908>>>>>>>                            End
88908>>>>>>>>
88908>>>>>>>                        End
88908>>>>>>>>
88908>>>>>>>
88908>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88909>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88909>>>>>>>                        If (bIsDateType = False and iLengthFrom <> iLengthTo) Begin
88911>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88914>>>>>>>                        End
88914>>>>>>>>
88914>>>>>>>                        // We do want to set the precision for e.g. DateTime2 (can be 3 or 7, but DataFlex can just handle "3").
88914>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
88916>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88919>>>>>>>                        End
88919>>>>>>>>
88919>>>>>>>
88919>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88921>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88921>>>>>>>                            If (bRecnumTable = True) Begin
88923>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88926>>>>>>>                            End
88926>>>>>>>>
88926>>>>>>>
88926>>>>>>>                            // We might need to create an index here.
88926>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88926>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88926>>>>>>>                            // index update checking logic.
88926>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88929>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88931>>>>>>>                                Create_Index hFile at iIndex
88932>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88935>>>>>>>                            End
88935>>>>>>>>
88935>>>>>>>
88935>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88938>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88941>>>>>>>                                // Note: The order here is crucial!
88941>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88944>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88947>>>>>>>                        End
88947>>>>>>>>
88947>>>>>>>                    End
88947>>>>>>>>
88947>>>>>>>                    Else Begin
88948>>>>>>>                        Delete_Field hFile iColumn
88949>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88950>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88951>>>>>>>                        Decrement iCount2
88952>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88952>>>>>>>                        // starting with the array number we just deleted the field for.
88952>>>>>>>                        for iColumn2 from iCount to iCount2
88958>>>>>>>>
88958>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88959>>>>>>>                        Loop
88960>>>>>>>>
88960>>>>>>>                        Decrement iCount
88961>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88962>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88963>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88965>>>>>>>                            Move iColumns to iCount 
88966>>>>>>>                        End
88966>>>>>>>>
88966>>>>>>>                    End
88966>>>>>>>>
88966>>>>>>>                End 
88966>>>>>>>>
88966>>>>>>>                If (Err = True) Begin 
88968>>>>>>>                    Move False to bOK
88969>>>>>>>                    Move iColumns to iCount
88970>>>>>>>                End
88970>>>>>>>>
88970>>>>>>>            Loop
88971>>>>>>>>
88971>>>>>>>
88971>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructuring table..."
88972>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88974>>>>>>>
88974>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88975>>>>>>>        Function_Return (Not(Err))
88976>>>>>>>    End_Function
88977>>>>>>>
88977>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88977>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88979>>>>>>>        Function_Return False
88980>>>>>>>    End_Function
88981>>>>>>>
88981>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88981>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88981>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88981>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88983>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88983>>>>>>>        String sDriverID
88983>>>>>>>        Boolean bOK bExists bIsSQLTable
88983>>>>>>>
88983>>>>>>>        Get AutoConnectionIDLogin to bOK
88984>>>>>>>        Get OpenTableExclusive hTable to bOK
88985>>>>>>>        If (bOK = False) Begin
88987>>>>>>>            Function_Return False
88988>>>>>>>        End
88988>>>>>>>>
88988>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88991>>>>>>>
88991>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88992>>>>>>>            If (bIsSQLTable = True) Begin
88994>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88997>>>>>>>            End
88997>>>>>>>>
88997>>>>>>>
88997>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
89000>>>>>>>        Move (iIndexSegments > 0) to bExists
89001>>>>>>>        If (bExists = True) Begin
89003>>>>>>>            Function_Return True
89004>>>>>>>        End
89004>>>>>>>>
89004>>>>>>>
89004>>>>>>>        Move -1 to iSegment1
89005>>>>>>>        Move -1 to iSegment2
89006>>>>>>>        Move -1 to iSegment3
89007>>>>>>>        Move -1 to iSegment4
89008>>>>>>>        Move -1 to iSegment5
89009>>>>>>>        Move -1 to iSegment6
89010>>>>>>>        Move -1 to iSegment7
89011>>>>>>>        Move -1 to iSegment8
89012>>>>>>>        Move -1 to iSegment9
89013>>>>>>>        Move -1 to iSegment10
89014>>>>>>>
89014>>>>>>>        If (num_arguments > 3) Begin
89016>>>>>>>            Move iSgmnt1 to iSegment1
89017>>>>>>>        End
89017>>>>>>>>
89017>>>>>>>        If (num_arguments > 4) Begin
89019>>>>>>>            Move iSgmnt2 to iSegment2
89020>>>>>>>        End
89020>>>>>>>>
89020>>>>>>>        If (num_arguments > 5) Begin
89022>>>>>>>            Move iSgmnt3 to iSegment3
89023>>>>>>>        End
89023>>>>>>>>
89023>>>>>>>        If (num_arguments > 6) Begin
89025>>>>>>>            Move iSgmnt4 to iSegment4
89026>>>>>>>        End
89026>>>>>>>>
89026>>>>>>>        If (num_arguments > 7) Begin
89028>>>>>>>            Move iSgmnt5 to iSegment5
89029>>>>>>>        End
89029>>>>>>>>
89029>>>>>>>        If (num_arguments > 8) Begin
89031>>>>>>>            Move iSgmnt6 to iSegment6
89032>>>>>>>        End
89032>>>>>>>>
89032>>>>>>>        If (num_arguments > 9) Begin
89034>>>>>>>            Move iSgmnt7 to iSegment7
89035>>>>>>>        End
89035>>>>>>>>
89035>>>>>>>        If (num_arguments > 10) Begin
89037>>>>>>>            Move iSgmnt8 to iSegment8
89038>>>>>>>        End
89038>>>>>>>>
89038>>>>>>>        If (num_arguments > 11) Begin
89040>>>>>>>            Move iSgmnt9 to iSegment9
89041>>>>>>>        End
89041>>>>>>>>
89041>>>>>>>        If (num_arguments > 12) Begin
89043>>>>>>>            Move iSgmnt10 to iSegment10
89044>>>>>>>        End
89044>>>>>>>>
89044>>>>>>>
89044>>>>>>>        Move False to Err
89045>>>>>>>        Move hTable to iTableNo
89046>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89047>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89048>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89049>>>>>>>
89049>>>>>>>        // We start by deleting the index, if it exists.
89049>>>>>>>        If (bExists = True) Begin
89051>>>>>>>            Structure_Start hTable sDriverID
89052>>>>>>>                Delete_Index iTableNo iIndex
89053>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89054>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89056>>>>>>>        End
89056>>>>>>>>
89056>>>>>>>
89056>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89057>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89058>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89059>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89060>>>>>>>        Move False to Err
89061>>>>>>>        Move 0 to LastErr
89062>>>>>>>
89062>>>>>>>        // Need to re-open if index deleted.
89062>>>>>>>        Move iTableNo to hTable
89063>>>>>>>        Get OpenTableExclusive hTable to bOK
89064>>>>>>>        If (bOK = False) Begin
89066>>>>>>>            Function_Return False
89067>>>>>>>        End
89067>>>>>>>>
89067>>>>>>>
89067>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89068>>>>>>>        Structure_Start hTable sDriverID
89069>>>>>>>            Create_Index hTable At iIndex
89070>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
89073>>>>>>>
89073>>>>>>>            If (iSgmnt1 <> -1) Begin
89075>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
89078>>>>>>>            End
89078>>>>>>>>
89078>>>>>>>            If (iSegment2 <> -1) Begin
89080>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
89083>>>>>>>            End
89083>>>>>>>>
89083>>>>>>>            If (iSegment3 <> -1) Begin
89085>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
89088>>>>>>>            End
89088>>>>>>>>
89088>>>>>>>            If (iSegment4 <> -1) Begin
89090>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
89093>>>>>>>            End
89093>>>>>>>>
89093>>>>>>>            If (iSegment5 <> -1) Begin
89095>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
89098>>>>>>>            End
89098>>>>>>>>
89098>>>>>>>            If (iSegment6 <> -1) Begin
89100>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
89103>>>>>>>            End
89103>>>>>>>>
89103>>>>>>>            If (iSegment7 <> -1) Begin
89105>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
89108>>>>>>>            End
89108>>>>>>>>
89108>>>>>>>            If (iSegment8 <> -1) Begin
89110>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
89113>>>>>>>            End
89113>>>>>>>>
89113>>>>>>>            If (iSegment9 <> -1) Begin
89115>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
89118>>>>>>>            End
89118>>>>>>>>
89118>>>>>>>            If (iSegment10 <> -1) Begin
89120>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
89123>>>>>>>            End
89123>>>>>>>>
89123>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89124>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89126>>>>>>>
89126>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89127>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89128>>>>>>>
89128>>>>>>>        Function_Return (Err = False)
89129>>>>>>>    End_Function
89130>>>>>>>
89130>>>>>>>    // Example:
89130>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
89130>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
89130>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
89132>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
89132>>>>>>>        String sDriverID
89132>>>>>>>        Boolean bOK bIsSQLTable
89132>>>>>>>
89132>>>>>>>        Get AutoConnectionIDLogin to bOK
89133>>>>>>>
89133>>>>>>>        Move False to Err
89134>>>>>>>        Move hTable to iTableNo
89135>>>>>>>        Get OpenTableExclusive hTable to bOK
89136>>>>>>>        If (bOK = False) Begin
89138>>>>>>>            Function_Return False
89139>>>>>>>        End
89139>>>>>>>>
89139>>>>>>>
89139>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89142>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89143>>>>>>>            If (bIsSQLTable = True) Begin
89145>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89148>>>>>>>            End
89148>>>>>>>>
89148>>>>>>>
89148>>>>>>>        // We start by deleting the index
89148>>>>>>>        Structure_Start hTable sDriverID
89149>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89150>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89151>>>>>>>            Delete_Index iTableNo iIndex
89152>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89153>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89154>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89156>>>>>>>
89156>>>>>>>        Move False to Err
89157>>>>>>>        Move iTableNo to hTable
89158>>>>>>>        Get OpenTableExclusive hTable to bOK
89159>>>>>>>        If (bOK = False) Begin
89161>>>>>>>            Function_Return False
89162>>>>>>>        End
89162>>>>>>>>
89162>>>>>>>
89162>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89163>>>>>>>        Structure_Start hTable sDriverID
89164>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
89165>>>>>>>
89165>>>>>>>            Create_Index hTable at iIndex
89166>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
89169>>>>>>>
89169>>>>>>>            For iNumSgmnt from 0 to (iNumSgmnts - 1)
89175>>>>>>>>
89175>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
89178>>>>>>>            Loop
89179>>>>>>>>
89179>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89181>>>>>>>
89181>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89182>>>>>>>
89182>>>>>>>        Function_Return (Err = False)
89183>>>>>>>    End_Function
89184>>>>>>>
89184>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89186>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
89186>>>>>>>        String sDriverID sSQLIndexName
89186>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89186>>>>>>>
89186>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89187>>>>>>>        If (iSegmentsFrom = 0) Begin
89189>>>>>>>            Function_Return False
89190>>>>>>>        End
89190>>>>>>>>
89190>>>>>>>
89190>>>>>>>        Get AutoConnectionIDLogin to bOK
89191>>>>>>>        Move False to Err
89192>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89193>>>>>>>        If (bIsOpen = False) Begin
89195>>>>>>>            Function_Return False
89196>>>>>>>        End
89196>>>>>>>>
89196>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89199>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89200>>>>>>>            If (bIsSQLTable = True) Begin
89202>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89205>>>>>>>            End
89205>>>>>>>>
89205>>>>>>>
89205>>>>>>>        Move 0     to iSegmentsTo
89206>>>>>>>        Move 0     to iSQLIndexType
89207>>>>>>>        Move ""    to sSQLIndexName
89208>>>>>>>        Move False to bIsSQLTemporaryIndex
89209>>>>>>>        Move False to bIsSQLPrimaryKey
89210>>>>>>>        Move False to bIsSQLClustered
89211>>>>>>>
89211>>>>>>>        // I'm not sure we should rename the index at all. It is deleted and re-created below(!)
89211>>>>>>>//        #IF (!@ > 182)
89211>>>>>>>//            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
89211>>>>>>>//        #ENDIF
89211>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
89214>>>>>>>        Move (iSegmentsTo > 0) to bExists
89215>>>>>>>        If (bExists = True) Begin
89217>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
89219>>>>>>>                Move APIIndex.sSQLIndexName                                                 to sSQLIndexName
89220>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber     to iSQLIndexType
89223>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                           to bIsSQLTemporaryIndex
89224>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89227>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89230>>>>>>>            End
89230>>>>>>>>
89230>>>>>>>        End
89230>>>>>>>>
89230>>>>>>>
89230>>>>>>>        Move hTable to iTableNo
89231>>>>>>>        Move False to Err
89232>>>>>>>        Move 0 to LastErr
89233>>>>>>>
89233>>>>>>>        Structure_Start hTable sDriverID
89234>>>>>>>            Delete_Index hTable APIIndex.iIndexNumber
89235>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
89236>>>>>>>
89236>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89238>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
89241>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89244>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89247>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89250>>>>>>>                End
89250>>>>>>>>
89250>>>>>>>
89250>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89253>>>>>>>
89253>>>>>>>            For iCount from 0 to (iSegmentsFrom -1)
89259>>>>>>>>
89259>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
89260>>>>>>>                If (iFieldFrom <> -1 ) Begin
89262>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89265>>>>>>>                        If (pbCompareIndexAscending(Self) = True) Begin
89267>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
89270>>>>>>>                    End
89270>>>>>>>>
89270>>>>>>>                        If (pbCompareIndexUppercase(Self) = True) Begin
89272>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
89275>>>>>>>                    End
89275>>>>>>>>
89275>>>>>>>                End
89275>>>>>>>>
89275>>>>>>>            Loop
89276>>>>>>>>
89276>>>>>>>
89276>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89277>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89279>>>>>>>
89279>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89280>>>>>>>
89280>>>>>>>        Function_Return (Err = False)
89281>>>>>>>    End_Function
89282>>>>>>>
89282>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
89282>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
89282>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
89284>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
89284>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
89284>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
89284>>>>>>>
89284>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
89285>>>>>>>        
89285>>>>>>>        If (bIsSQLDriver = False) Begin
89287>>>>>>>            Function_Return False
89288>>>>>>>        End
89288>>>>>>>>
89288>>>>>>>
89288>>>>>>>        Move False to Err
89289>>>>>>>        Move hTable to iTableNo
89290>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89293>>>>>>>        for iCount from 0 to iLastIndex
89299>>>>>>>>
89299>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
89302>>>>>>>            Move (iSegments > 0) to bExists
89303>>>>>>>            If (bExists = True) Begin
89305>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
89308>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
89310>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
89311>>>>>>>                    Structure_Start iTableNo sDriverID
89312>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
89315>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89317>>>>>>>                    Open hTable
89319>>>>>>>                End
89319>>>>>>>>
89319>>>>>>>            End
89319>>>>>>>>
89319>>>>>>>        Loop
89320>>>>>>>>
89320>>>>>>>
89320>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89323>>>>>>>        If (bIsOpen = False) Begin
89325>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89326>>>>>>>        End
89326>>>>>>>>
89326>>>>>>>        If (bIsOpen = False) Begin
89328>>>>>>>            Function_Return False
89329>>>>>>>        End
89329>>>>>>>>
89329>>>>>>>
89329>>>>>>>        Function_Return (Err = False)
89330>>>>>>>    End_Function
89331>>>>>>>
89331>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89331>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89331>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89333>>>>>>>        Integer iSize iCount
89333>>>>>>>        Integer iRetVal
89333>>>>>>>
89333>>>>>>>        Move 0 to iRetVal
89334>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89337>>>>>>>        If (iRetVal = 0) Begin
89339>>>>>>>            Function_Return 0
89340>>>>>>>        End
89340>>>>>>>>
89340>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89341>>>>>>>        Decrement iSize
89342>>>>>>>        for iCount from 0 to iSize
89348>>>>>>>>
89348>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89350>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89352>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89353>>>>>>>                End
89353>>>>>>>>
89353>>>>>>>            End
89353>>>>>>>>
89353>>>>>>>        Loop
89354>>>>>>>>
89354>>>>>>>
89354>>>>>>>        Function_Return iRetVal
89355>>>>>>>    End_Function
89356>>>>>>>
89356>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89358>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89358>>>>>>>        Boolean bIsSQLTable
89358>>>>>>>        
89358>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89359>>>>>>>            If (bIsSQLTable = True) Begin
89361>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89364>>>>>>>            End
89364>>>>>>>>
89364>>>>>>>
89364>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89367>>>>>>>        If (iSegment = iNumSegments) Begin
89369>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89369>>>>>>>        End
89369>>>>>>>>
89369>>>>>>>
89369>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89372>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89378>>>>>>>>
89378>>>>>>>                //*** Move index segment attributes
89378>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89381>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89384>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89387>>>>>>>
89387>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89390>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89393>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89396>>>>>>>            Loop
89397>>>>>>>>
89397>>>>>>>
89397>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89400>>>>>>>        End
89400>>>>>>>>
89400>>>>>>>
89400>>>>>>>        Function_Return (Err = False)
89401>>>>>>>    End_Function
89402>>>>>>>
89402>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89404>>>>>>>        Integer iCount iSize iIndex
89404>>>>>>>        String sDriverID
89404>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
89404>>>>>>>
89404>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
89405>>>>>>>        If (iSize = 0) Begin
89407>>>>>>>            Function_Return True
89408>>>>>>>        End
89408>>>>>>>>
89408>>>>>>>
89408>>>>>>>        Get AutoConnectionIDLogin to bOK
89409>>>>>>>        Move False to Err
89410>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89413>>>>>>>        If (bIsOpen = False) Begin
89415>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89416>>>>>>>            If (bIsOpen = False) Begin
89418>>>>>>>                Function_Return False
89419>>>>>>>            End
89419>>>>>>>>
89419>>>>>>>        End
89419>>>>>>>>
89419>>>>>>>
89419>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89422>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89423>>>>>>>            If (bIsSQLTable = True) Begin
89425>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89428>>>>>>>            End
89428>>>>>>>>
89428>>>>>>>
89428>>>>>>>        Move False to Err
89429>>>>>>>        Move 0 to LastErr
89430>>>>>>>        Decrement iSize
89431>>>>>>>
89431>>>>>>>        Structure_Start hTable sDriverID
89432>>>>>>>            For iCount from 0 to iSize
89438>>>>>>>>
89438>>>>>>>//                Move False to bIsSQLPrimaryKey
89438>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
89438>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89438>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89438>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89438>>>>>>>//                #ENDIF
89438>>>>>>>                // We can't delete if this is a primary key index:
89438>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
89438>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89439>>>>>>>                    Delete_Index hTable iIndex
89440>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89440>>>>>>>//                End
89440>>>>>>>            Loop
89441>>>>>>>>
89441>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89442>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89444>>>>>>>//        Move False to Err
89444>>>>>>>        Move 0 to LastErr
89445>>>>>>>
89445>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89446>>>>>>>        Function_Return (Err = False)
89447>>>>>>>    End_Function
89448>>>>>>>
89448>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89450>>>>>>>        Boolean bOK
89450>>>>>>>
89450>>>>>>>        Get AutoConnectionIDLogin to bOK
89451>>>>>>>        Move False to Err
89452>>>>>>>        Get OpenTableExclusive hTable to bOK
89453>>>>>>>        If (bOK = False) Begin
89455>>>>>>>            Function_Return False
89456>>>>>>>        End
89456>>>>>>>>
89456>>>>>>>        Structure_Start hTable
89457>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89460>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89461>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89463>>>>>>>
89463>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89464>>>>>>>        Function_Return (Err = False)
89465>>>>>>>    End_Function
89466>>>>>>>
89466>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89468>>>>>>>        Integer iCase
89468>>>>>>>        Boolean bOK
89468>>>>>>>
89468>>>>>>>        If (bUppercase = True) Begin
89470>>>>>>>            Move DF_CASE_IGNORED to iCase
89471>>>>>>>        End
89471>>>>>>>>
89471>>>>>>>        Else Begin
89472>>>>>>>            Move DF_CASE_USED to iCase
89473>>>>>>>        End
89473>>>>>>>>
89473>>>>>>>
89473>>>>>>>        Get AutoConnectionIDLogin to bOK
89474>>>>>>>        Move False to Err
89475>>>>>>>        Get OpenTableExclusive hTable to bOK
89476>>>>>>>        If (bOK = False) Begin
89478>>>>>>>            Function_Return False
89479>>>>>>>        End
89479>>>>>>>>
89479>>>>>>>        Structure_Start hTable
89480>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89483>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89484>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89486>>>>>>>
89486>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89487>>>>>>>        Function_Return (Err = False)
89488>>>>>>>    End_Function
89489>>>>>>>
89489>>>>>>>    // To delete an index
89489>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89491>>>>>>>        Integer iTableNo iNumSegments
89491>>>>>>>        String sDriverID
89491>>>>>>>        Boolean bOK bIsSQLTable
89491>>>>>>>
89491>>>>>>>        Get AutoConnectionIDLogin to bOK
89492>>>>>>>        Move False to Err
89493>>>>>>>        Move hTable to iTableNo
89494>>>>>>>        Get OpenTableExclusive hTable to bOK
89495>>>>>>>        If (bOK = False) Begin
89497>>>>>>>            Function_Return False
89498>>>>>>>        End
89498>>>>>>>>
89498>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89501>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89502>>>>>>>            If (bIsSQLTable = True) Begin
89504>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89507>>>>>>>            End
89507>>>>>>>>
89507>>>>>>>
89507>>>>>>>        // Check to see if the index exists or not...
89507>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89510>>>>>>>        If (iNumSegments = 0) Begin
89512>>>>>>>            Function_Return True // Then nothing to do.
89513>>>>>>>        End
89513>>>>>>>>
89513>>>>>>>
89513>>>>>>>        Structure_Start hTable sDriverID
89514>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89515>>>>>>>            Delete_Index iTableNo iIndex
89516>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89517>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89518>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89520>>>>>>>
89520>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89521>>>>>>>        Function_Return (Err = False)
89522>>>>>>>    End_Function
89523>>>>>>>
89523>>>>>>>    // Delete an Index Segment
89523>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89525>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89525>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89525>>>>>>>        Integer iIndexType
89525>>>>>>>        String sDriverID
89525>>>>>>>
89525>>>>>>>        Get AutoConnectionIDLogin to bOK
89526>>>>>>>        Move False to Err
89527>>>>>>>
89527>>>>>>>        Get OpenTableExclusive hTable to bOK
89528>>>>>>>        If (bOK = False) Begin
89530>>>>>>>            Function_Return False
89531>>>>>>>        End
89531>>>>>>>>
89531>>>>>>>
89531>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89532>>>>>>>            If (bIsSQLTable = True) Begin
89534>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89537>>>>>>>            End
89537>>>>>>>>
89537>>>>>>>
89537>>>>>>>        // Check to see if the index exists or not...
89537>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89540>>>>>>>        If (iNumSegments = 0) Begin
89542>>>>>>>            Function_Return False
89543>>>>>>>        End
89543>>>>>>>>
89543>>>>>>>
89543>>>>>>>        Move False to bIndexTemporary
89544>>>>>>>        Get psDriverID to sDriverID
89545>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89546>>>>>>>        If (bSQLDriver) Begin
89548>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89551>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89554>>>>>>>                Move True to bIndexTemporary
89555>>>>>>>        End
89555>>>>>>>>
89555>>>>>>>
89555>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89555>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89557>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89560>>>>>>>            If (iSegment = iNumSegments) Begin
89562>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89565>>>>>>>            End
89565>>>>>>>>
89565>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89568>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89574>>>>>>>>
89574>>>>>>>                    //*** Move index segment attributes
89574>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89577>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89580>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89583>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89586>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89589>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89592>>>>>>>                Loop
89593>>>>>>>>
89593>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89596>>>>>>>            End
89596>>>>>>>>
89596>>>>>>>        End
89596>>>>>>>>
89596>>>>>>>
89596>>>>>>>        Else Begin
89597>>>>>>>           Structure_Start hTable
89598>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89601>>>>>>>               If (iSegment = iNumSegments) Begin
89603>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89606>>>>>>>               End
89606>>>>>>>>
89606>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89609>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89615>>>>>>>>
89615>>>>>>>                       //*** Move index segment attributes
89615>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89618>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89621>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89624>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89627>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89630>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89633>>>>>>>                   Loop
89634>>>>>>>>
89634>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89637>>>>>>>               End
89637>>>>>>>>
89637>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89638>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89640>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89641>>>>>>>        End
89641>>>>>>>>
89641>>>>>>>
89641>>>>>>>        Function_Return (Err = False)
89642>>>>>>>    End_Function
89643>>>>>>>
89643>>>>>>>    // Add/Insert an Index Segment
89643>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89645>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89645>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89645>>>>>>>        Integer iIndexType
89645>>>>>>>        String sDriverId
89645>>>>>>>
89645>>>>>>>        Get AutoConnectionIDLogin to bOK
89646>>>>>>>        Move False to Err
89647>>>>>>>
89647>>>>>>>        Get OpenTableExclusive hTable to bOK
89648>>>>>>>        If (bOK = False) Begin
89650>>>>>>>            Function_Return False
89651>>>>>>>        End
89651>>>>>>>>
89651>>>>>>>
89651>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89652>>>>>>>            If (bIsSQLTable = True) Begin
89654>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89657>>>>>>>            End
89657>>>>>>>>
89657>>>>>>>
89657>>>>>>>        Move False to bIndexTemporary
89658>>>>>>>        // Check to see if the index exists or not...
89658>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89661>>>>>>>        If (iNumSegments = 0) Begin
89663>>>>>>>            Function_Return False
89664>>>>>>>        End
89664>>>>>>>>
89664>>>>>>>
89664>>>>>>>        Get psDriverID to sDriverID
89665>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89666>>>>>>>        If (bSQLDriver) Begin
89668>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89671>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89674>>>>>>>                Move True to bIndexTemporary
89675>>>>>>>        End
89675>>>>>>>>
89675>>>>>>>
89675>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89675>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89677>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89680>>>>>>>
89680>>>>>>>           If (iSegment > iNumSegments) Begin
89682>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89685>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89686>>>>>>>           End
89686>>>>>>>>
89686>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89689>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89692>>>>>>>               Move iNumSegments to iCurSegment
89693>>>>>>>
89693>>>>>>>               While (iCurSegment > iSegment)
89697>>>>>>>                   //*** Move index segment attributes
89697>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89700>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89703>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89706>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89709>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89712>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89715>>>>>>>                   Decrement iCurSegment
89716>>>>>>>               Loop
89717>>>>>>>>
89717>>>>>>>
89717>>>>>>>               //*** Now set new segment attributes
89717>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89720>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89723>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89726>>>>>>>           End
89726>>>>>>>>
89726>>>>>>>        End
89726>>>>>>>>
89726>>>>>>>
89726>>>>>>>        Else Begin
89727>>>>>>>        Structure_Start hTable
89728>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89731>>>>>>>
89731>>>>>>>            If (iSegment > iNumSegments) Begin
89733>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89736>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89737>>>>>>>            End
89737>>>>>>>>
89737>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89740>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89743>>>>>>>                Move iNumSegments to iCurSegment
89744>>>>>>>
89744>>>>>>>                While (iCurSegment > iSegment)
89748>>>>>>>                    //*** Move index segment attributes
89748>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89751>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89754>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89757>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89760>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89763>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89766>>>>>>>                    Decrement iCurSegment
89767>>>>>>>                Loop
89768>>>>>>>>
89768>>>>>>>
89768>>>>>>>                //*** Now set new segment attributes
89768>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89771>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89774>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89777>>>>>>>            End
89777>>>>>>>>
89777>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89778>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89780>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89781>>>>>>>        End
89781>>>>>>>>
89781>>>>>>>
89781>>>>>>>        Function_Return (Err = False)
89782>>>>>>>    End_Function
89783>>>>>>>
89783>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89783>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89785>>>>>>>        Function_Return False
89786>>>>>>>    End_Function  
89787>>>>>>>    
89787>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89787>>>>>>>    // for an SQL conversion.
89787>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89789>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89789>>>>>>>        
89789>>>>>>>        Move True to bConvertTo30FormatbOK
89790>>>>>>>        Move True to bRepairAndReindexOK
89791>>>>>>>        Move True to bFixBogusDatesOK
89792>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89793>>>>>>>        
89793>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89795>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89796>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89797>>>>>>>        End                                                                                
89797>>>>>>>>
89797>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89799>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89800>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89801>>>>>>>        End
89801>>>>>>>>
89801>>>>>>>        If (bConvertTo30Format = True) Begin
89803>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89804>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89805>>>>>>>        End                                                 
89805>>>>>>>>
89805>>>>>>>        If (bRepairAndReindex = True) Begin
89807>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89808>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89809>>>>>>>        End  
89809>>>>>>>>
89809>>>>>>>        If (bFixBogusDates = True) Begin
89811>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89812>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89813>>>>>>>        End                                    
89813>>>>>>>>
89813>>>>>>>        
89813>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89814>>>>>>>    End_Function
89815>>>>>>>
89815>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89817>>>>>>>        Boolean bOK bFlexErrs bTemp
89817>>>>>>>        Handle hTable
89817>>>>>>>        String sTableName
89817>>>>>>>        Integer iCount iSize
89817>>>>>>>        
89817>>>>>>>        Move True to bOK
89818>>>>>>>        Move 0 to hTable    
89819>>>>>>>
89819>>>>>>>        Get UtilFilelistNoOfTables to iSize
89820>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89821>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89822>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89823>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89824>>>>>>>
89824>>>>>>>        Repeat
89824>>>>>>>>
89824>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89825>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89826>>>>>>>            Increment iCount
89827>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89830>>>>>>>            If (hTable > 0) Begin
89832>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89835>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89836>>>>>>>                If (bFlexErrs = False) Begin
89838>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89839>>>>>>>                    If (bTemp = False) Begin
89841>>>>>>>                        Move False to bOK
89842>>>>>>>                    End
89842>>>>>>>>
89842>>>>>>>                End
89842>>>>>>>>
89842>>>>>>>            End
89842>>>>>>>>
89842>>>>>>>        Until (hTable = 0)
89844>>>>>>>        
89844>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89845>>>>>>>        Function_Return bOK
89846>>>>>>>    End_Function
89847>>>>>>>    
89847>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89847>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89847>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89847>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89849>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89849>>>>>>>        String sRevision
89849>>>>>>>        
89849>>>>>>>        Get AutoConnectionIDLogin to bOK
89850>>>>>>>        If (bOK = False) Begin
89852>>>>>>>            Function_Return True
89853>>>>>>>        End
89853>>>>>>>>
89853>>>>>>>        Get OpenTableExclusive hTable to bOK
89854>>>>>>>        If (bOK = False) Begin
89856>>>>>>>            Function_Return True
89857>>>>>>>        End
89857>>>>>>>>
89857>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89858>>>>>>>        If (bIsEmbedded = False) Begin
89860>>>>>>>            Function_Return True
89861>>>>>>>        End                             
89861>>>>>>>>
89861>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89862>>>>>>>        If (bIsAlias = True) Begin
89864>>>>>>>            Function_Return True
89865>>>>>>>        End                     
89865>>>>>>>>
89865>>>>>>>        
89865>>>>>>>        Move False to Err
89866>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89869>>>>>>>        If (sRevision contains "2.3") Begin
89871>>>>>>>            Move False to Err
89872>>>>>>>            Set Private.phCurrentTable to hTable
89873>>>>>>>            Structure_Start hTable    
89874>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89877>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89878>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89880>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89881>>>>>>>        End
89881>>>>>>>>
89881>>>>>>>        
89881>>>>>>>        Function_Return (Err = False)
89882>>>>>>>    End_Function
89883>>>>>>>
89883>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89885>>>>>>>        Boolean bIgnore bExists bOK bResponse
89885>>>>>>>        Handle hTable   
89885>>>>>>>        String sTableName
89885>>>>>>>        
89885>>>>>>>        Move False to Err 
89886>>>>>>>        Move True to bOK
89887>>>>>>>        Move 0 to hTable
89888>>>>>>>        Repeat
89888>>>>>>>>
89888>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89891>>>>>>>            If (hTable > 0) Begin
89893>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89896>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89897>>>>>>>                If (bIgnore = False) Begin
89899>>>>>>>                    Get _UtilTableExists hTable to bExists
89900>>>>>>>                    If (bExists = False) Begin
89902>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89903>>>>>>>                        If (bResponse = False) Begin
89905>>>>>>>                            Move False to bOK
89906>>>>>>>                        End
89906>>>>>>>>
89906>>>>>>>                        
89906>>>>>>>                    End
89906>>>>>>>>
89906>>>>>>>                End
89906>>>>>>>>
89906>>>>>>>            End
89906>>>>>>>>
89906>>>>>>>        Until (hTable = 0)                     
89908>>>>>>>        
89908>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89909>>>>>>>        Function_Return bOK
89910>>>>>>>    End_Function
89911>>>>>>>    
89911>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89911>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89911>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89911>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89911>>>>>>>    //
89911>>>>>>>    // The root of the problem is the following:
89911>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89911>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89911>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89911>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89911>>>>>>>    // an SQL error will be thrown;
89911>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89911>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89913>>>>>>>        Boolean bOK bIsAlias bIsSQL
89913>>>>>>>        Integer iCount iSize iDateSize
89913>>>>>>>        Handle hTable
89913>>>>>>>        String sLogicalName
89913>>>>>>>        Integer[] aTablesToCheck aDateFields
89915>>>>>>>
89915>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89916>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89917>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89918>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89919>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89920>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89921>>>>>>>
89921>>>>>>>        Move True to bOK
89922>>>>>>>        Decrement iSize
89923>>>>>>>        for iCount from 0 to iSize
89929>>>>>>>>
89929>>>>>>>            Move aTablesToCheck[iCount] to hTable
89930>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89931>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89932>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89933>>>>>>>
89933>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89936>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89937>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89938>>>>>>>
89938>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89940>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89941>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89942>>>>>>>                If (iDateSize > 0) Begin
89944>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89945>>>>>>>                    Close hTable
89946>>>>>>>                End
89946>>>>>>>>
89946>>>>>>>            End
89946>>>>>>>>
89946>>>>>>>        Loop
89947>>>>>>>>
89947>>>>>>>
89947>>>>>>>        Close DF_ALL
89948>>>>>>>        Function_Return bOK
89949>>>>>>>    End_Function
89950>>>>>>>
89950>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89950>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89952>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89954>>>>>>>        Integer iSize iCount iType
89954>>>>>>>        Boolean bOpen bOK
89954>>>>>>>        
89954>>>>>>>        Get _UtilTableExists hTable to bOK
89955>>>>>>>        If (bOK = False) Begin
89957>>>>>>>            Set Private.phCurrentTable to hTable
89958>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89959>>>>>>>>
89959>>>>>>>            Function_Return aDateFieldsEmpty
89960>>>>>>>        End
89960>>>>>>>>
89960>>>>>>>        Set Private.phCurrentTable to hTable
89961>>>>>>>        Set Private.piCurrentField to 0
89962>>>>>>>
89962>>>>>>>        Open hTable
89964>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89967>>>>>>>        If (bOpen = False) Begin
89969>>>>>>>            Function_Return aDateFieldsEmpty
89970>>>>>>>        End
89970>>>>>>>>
89970>>>>>>>
89970>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89973>>>>>>>        For iCount from 1 to iSize
89979>>>>>>>>
89979>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89982>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89984>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89985>>>>>>>            End
89985>>>>>>>>
89985>>>>>>>        Loop
89986>>>>>>>>
89986>>>>>>>
89986>>>>>>>        Function_Return aDateFields
89987>>>>>>>    End_Function
89988>>>>>>>
89988>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89988>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89988>>>>>>>    // and the record is saved
89988>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89988>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89988>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89990>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89990>>>>>>>        String sDriverID sDateMin
89990>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89990>>>>>>>        Date dDate dDateMin
89990>>>>>>>        Integer[] iaChangeField
89991>>>>>>>
89991>>>>>>>        Get _UtilTableExists hTable to bOK
89992>>>>>>>        // I believe we should just skip files not found and not report an error.
89992>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89992>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89992>>>>>>>        // Especially considering that this call is probably done at the very
89992>>>>>>>        // beginning of a DUF update.
89992>>>>>>>        If (bOK = False) Begin
89994>>>>>>>//            Set Private.phCurrentTable to hTable
89994>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89994>>>>>>>//            Function_Return False
89994>>>>>>>            Function_Return True
89995>>>>>>>        End
89995>>>>>>>>
89995>>>>>>>
89995>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89995>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89995>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89998>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
90001>>>>>>>
90001>>>>>>>//        Send SetAllIndexesToBatch hTable True
90001>>>>>>>        Open hTable
90003>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
90006>>>>>>>        If (bOpened = False) Begin
90008>>>>>>>            Function_Return False
90009>>>>>>>        End
90009>>>>>>>>
90009>>>>>>>        
90009>>>>>>>        Set Private.phCurrentTable to hTable
90010>>>>>>>        Move 0 to iRecord
90011>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
90012>>>>>>>        Decrement iSize
90013>>>>>>>
90013>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90016>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
90017>>>>>>>        If (iDriverIndex <> 0) Begin
90019>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
90022>>>>>>>            If (sDateMin = "") Begin
90024>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
90025>>>>>>>            End
90025>>>>>>>>
90025>>>>>>>            Else Begin
90026>>>>>>>                If (IsDate(sDateMin)) Begin
90028>>>>>>>                    Move sDateMin to dDateMin
90029>>>>>>>                End
90029>>>>>>>>
90029>>>>>>>                Else Begin
90030>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
90031>>>>>>>                End
90031>>>>>>>>
90031>>>>>>>            End
90031>>>>>>>>
90031>>>>>>>        End
90031>>>>>>>>
90031>>>>>>>        Else Begin
90032>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
90033>>>>>>>        End
90033>>>>>>>>
90033>>>>>>>
90033>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
90036>>>>>>>        Set piPosition   of ghoProgressBar to 0
90037>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
90038>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
90039>>>>>>>        Move False to Err
90040>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90041>>>>>>>
90041>>>>>>>        Clear hTable
90042>>>>>>>        Repeat
90042>>>>>>>>
90042>>>>>>>            Vfind hTable 0 GT
90044>>>>>>>            Move Found to bFound
90045>>>>>>>            If (bFound = True) Begin
90047>>>>>>>                Move False to bSaveChanges
90048>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
90049>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
90050>>>>>>>                Decrement iSize
90051>>>>>>>                For iCount from 0 to iSize
90057>>>>>>>>
90057>>>>>>>                    Move aDateFields[iCount] to iField
90058>>>>>>>                    Get_Field_Value hTable iField to dDate
90061>>>>>>>                    If (bFixZeroDates = True) Begin
90063>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
90064>>>>>>>                    End
90064>>>>>>>>
90064>>>>>>>                    Else Begin
90065>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
90066>>>>>>>                    End
90066>>>>>>>>
90066>>>>>>>                    If (bChange = True) Begin
90068>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
90069>>>>>>>                    End
90069>>>>>>>>
90069>>>>>>>                Loop
90070>>>>>>>>
90070>>>>>>>
90070>>>>>>>                // Only change Date fields that needs to be changed.
90070>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
90072>>>>>>>                    Reread hTable
90076>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
90077>>>>>>>                        Decrement iSize
90078>>>>>>>                        For iCount from 0 to iSize
90084>>>>>>>>
90084>>>>>>>                            Move iaChangeField[iCount] to iField
90085>>>>>>>                            Set Private.piCurrentField to iField
90086>>>>>>>                            Set_Field_Value hTable iField to dDateMin
90089>>>>>>>                        Loop
90090>>>>>>>>
90090>>>>>>>                        Move False to Err
90091>>>>>>>                        SaveRecord hTable
90092>>>>>>>                    Unlock
90093>>>>>>>>
90093>>>>>>>                End
90093>>>>>>>>
90093>>>>>>>
90093>>>>>>>                Increment iRecord
90094>>>>>>>                // Increment the StatusPanel counter and check the
90094>>>>>>>                // cancel status every 100 records rather than every
90094>>>>>>>                // record, it's way faster.
90094>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
90096>>>>>>>                    Send DoAdvance of ghoProgressBar
90097>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
90098>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
90099>>>>>>>                End
90099>>>>>>>>
90099>>>>>>>            End
90099>>>>>>>>
90099>>>>>>>        Until (bFound = False)
90101>>>>>>>
90101>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
90104>>>>>>>        If (bResetIndexesToOnLine = True) Begin
90106>>>>>>>            Send SetAllIndexesToBatch hTable False
90107>>>>>>>        End
90107>>>>>>>>
90107>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90108>>>>>>>
90108>>>>>>>        Function_Return (Err = False)
90109>>>>>>>    End_Function
90110>>>>>>>
90110>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
90110>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
90110>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
90112>>>>>>>        Boolean bIsSame
90112>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
90112>>>>>>>
90112>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
90113>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
90114>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
90115>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
90116>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
90117>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
90118>>>>>>>
90118>>>>>>>        If (bCompareFilelistUppercase = True) Begin
90120>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
90121>>>>>>>        End
90121>>>>>>>>
90121>>>>>>>        Else Begin
90122>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
90123>>>>>>>        End
90123>>>>>>>>
90123>>>>>>>        If (bIsSame = False) Begin
90125>>>>>>>            Function_Return False
90126>>>>>>>        End
90126>>>>>>>>
90126>>>>>>>
90126>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
90127>>>>>>>        If (bIsSame = False) Begin
90129>>>>>>>            Function_Return False
90130>>>>>>>        End
90130>>>>>>>>
90130>>>>>>>
90130>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
90131>>>>>>>        If (bIsSame = False) Begin
90133>>>>>>>            Function_Return False
90134>>>>>>>        End
90134>>>>>>>>
90134>>>>>>>
90134>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
90135>>>>>>>        If (bIsSame = False) Begin
90137>>>>>>>            Function_Return False
90138>>>>>>>        End
90138>>>>>>>>
90138>>>>>>>
90138>>>>>>>        Function_Return bIsSame
90139>>>>>>>    End_Function
90140>>>>>>>
90140>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90142>>>>>>>        Handle hTableFrom hTableTo
90142>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90142>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
90142>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90142>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90142>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90143>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90143>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90144>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90144>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90145>>>>>>>
90145>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
90146>>>>>>>        If (bIsSame = True) Begin
90148>>>>>>>            Function_Return True
90149>>>>>>>        End
90149>>>>>>>>
90149>>>>>>>
90149>>>>>>>        Move False to bFilelistError
90150>>>>>>>        Move True to bIsSame
90151>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90152>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90153>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90154>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90155>>>>>>>        Set Private.phCurrentTable to hTableFrom
90156>>>>>>>        
90156>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90157>>>>>>>
90157>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90158>>>>>>>        Get _TableNameOnly sRootName             to sRootName
90159>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90160>>>>>>>
90160>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90160>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90160>>>>>>>        If (bCodeGenerateMode = True) Begin
90162>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90162>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90164>>>>>>>                Function_Return False
90165>>>>>>>            End
90165>>>>>>>>
90165>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90166>>>>>>>            If (bIsSame = False) Begin
90168>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90169>>>>>>>                Move True to bFilelistError
90170>>>>>>>                Function_Return False
90171>>>>>>>            End
90171>>>>>>>>
90171>>>>>>>        End
90171>>>>>>>>
90171>>>>>>>
90171>>>>>>>        If (bCodeGenerateMode = False) Begin
90173>>>>>>>            // Then we want to create this table
90173>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90175>>>>>>>                Function_Return False
90176>>>>>>>            End
90176>>>>>>>>
90176>>>>>>>
90176>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90177>>>>>>>            If (bIsSame = False) Begin
90179>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90180>>>>>>>>
90180>>>>>>>                Move True to bFilelistError
90181>>>>>>>                Function_Return False
90182>>>>>>>            End
90182>>>>>>>>
90182>>>>>>>        End
90182>>>>>>>>
90182>>>>>>>
90182>>>>>>>        // Check columns:
90182>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90183>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90184>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90185>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90186>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90187>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90188>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90189>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90190>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90191>>>>>>>        If (bIsSame = False) Begin
90193>>>>>>>            Function_Return False
90194>>>>>>>        End
90194>>>>>>>>
90194>>>>>>>
90194>>>>>>>        // ...then check indexes:
90194>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90195>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90196>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90197>>>>>>>        If (bIsSame = False) Begin
90199>>>>>>>            Function_Return False
90200>>>>>>>        End
90200>>>>>>>>
90200>>>>>>>
90200>>>>>>>        // ...and finally relationships:
90200>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90201>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90202>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90203>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90204>>>>>>>
90204>>>>>>>        Function_Return (bIsSame = True)
90205>>>>>>>    End_Function
90206>>>>>>>
90206>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90206>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90208>>>>>>>        Handle hTable
90208>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90208>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90208>>>>>>>
90208>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90210>>>>>>>            Move True to bFilelistError
90211>>>>>>>            Function_Return False
90212>>>>>>>        End
90212>>>>>>>>
90212>>>>>>>
90212>>>>>>>        Move APITableCompare.hTable to hTable
90213>>>>>>>        Move True  to bIsSame
90214>>>>>>>        Move False to bFilelistError
90215>>>>>>>
90215>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90217>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90218>>>>>>>        End
90218>>>>>>>>
90218>>>>>>>        Else Begin
90219>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90220>>>>>>>        End
90220>>>>>>>>
90220>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90221>>>>>>>
90221>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90222>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90223>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90224>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90225>>>>>>>
90225>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90225>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90225>>>>>>>        If (bCodeGenerateMode = True) Begin
90227>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90227>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90229>>>>>>>                Function_Return False
90230>>>>>>>            End
90230>>>>>>>>
90230>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90231>>>>>>>            If (bIsSame = False) Begin
90233>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90234>>>>>>>                Move True to bFilelistError
90235>>>>>>>                Function_Return False
90236>>>>>>>            End
90236>>>>>>>>
90236>>>>>>>        End
90236>>>>>>>>
90236>>>>>>>
90236>>>>>>>        If (bCodeGenerateMode = False) Begin
90238>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90240>>>>>>>                // Then we might want to create this table
90240>>>>>>>                Function_Return False
90241>>>>>>>            End
90241>>>>>>>>
90241>>>>>>>
90241>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90242>>>>>>>            If (bIsSame = False) Begin
90244>>>>>>>                Function_Return False
90245>>>>>>>            End
90245>>>>>>>>
90245>>>>>>>
90245>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90246>>>>>>>            If (bIsSame = False) Begin
90248>>>>>>>                Function_Return False
90249>>>>>>>            End
90249>>>>>>>>
90249>>>>>>>
90249>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90250>>>>>>>            If (bIsSame = False) Begin
90252>>>>>>>                Function_Return False
90253>>>>>>>            End
90253>>>>>>>>
90253>>>>>>>
90253>>>>>>>            // Check table names et al.
90253>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90254>>>>>>>            If (bIsSame = False) Begin
90256>>>>>>>                Function_Return False
90257>>>>>>>            End
90257>>>>>>>>
90257>>>>>>>        End
90257>>>>>>>>
90257>>>>>>>
90257>>>>>>>        // Check Columns:
90257>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90258>>>>>>>        If (bIsSame = False) Begin
90260>>>>>>>            Function_Return False
90261>>>>>>>        End
90261>>>>>>>>
90261>>>>>>>
90261>>>>>>>        // ...then check Indexes:
90261>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90262>>>>>>>        If (bIsSame = False) Begin
90264>>>>>>>            Function_Return False
90265>>>>>>>        End
90265>>>>>>>>
90265>>>>>>>
90265>>>>>>>        // ...and finally Relationships:
90265>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90266>>>>>>>
90266>>>>>>>        Function_Return (bIsSame = True)
90267>>>>>>>    End_Function
90268>>>>>>>
90268>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90268>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90268>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90268>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90268>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90270>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90270>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90270>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90270>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90272>>>>>>>        tAPIColumn[]    aApiColumns
90272>>>>>>>        tAPIColumn[]    aApiColumns
90273>>>>>>>        tAPIIndex[]     aApiIndexes
90273>>>>>>>        tAPIIndex[]     aApiIndexes
90274>>>>>>>        tAPIRelation[]  aApiRelations
90274>>>>>>>        tAPIRelation[]  aApiRelations
90275>>>>>>>        Handle hTable
90275>>>>>>>        Integer iCount
90275>>>>>>>        Boolean bUserCancel bOK
90275>>>>>>>        String sLogicalName sMessageText
90275>>>>>>>
90275>>>>>>>        Get AutoConnectionIDLogin to bOK
90276>>>>>>>        Move 0 to hTable
90277>>>>>>>        If (bFromTables = True) Begin
90279>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90280>>>>>>>            If (bCompareUtil = True) Begin
90282>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90283>>>>>>>            End
90283>>>>>>>>
90283>>>>>>>        End
90283>>>>>>>>
90283>>>>>>>        Else Begin
90284>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90285>>>>>>>            If (bCompareUtil = True) Begin
90287>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90288>>>>>>>            End
90288>>>>>>>>
90288>>>>>>>        End
90288>>>>>>>>
90288>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90289>>>>>>>
90289>>>>>>>        Get UtilFilelistNoOfTables to iCount
90290>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90291>>>>>>>        Move 0 to iCount
90292>>>>>>>
90292>>>>>>>        Repeat
90292>>>>>>>>
90292>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90295>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90297>>>>>>>
90297>>>>>>>                Open hTable
90299>>>>>>>                // ToDo: Needs to be revised
90299>>>>>>>                // For some reason tables may be reported as "unopened", while in
90299>>>>>>>                // fact the open was successful (!)
90299>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90299>>>>>>>//                If (bIsOpen = False) Begin
90299>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90299>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90299>>>>>>>//                    Function_Return aApiTablesEmpty
90299>>>>>>>//                End
90299>>>>>>>
90299>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90302>>>>>>>                Set piPosition of ghoProgressBar to iCount
90303>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90304>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90305>>>>>>>
90305>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90306>>>>>>>//                Close hTable DF_PERMANENT
90306>>>>>>>                Increment iCount
90307>>>>>>>            End
90307>>>>>>>>
90307>>>>>>>
90307>>>>>>>            If (bStatusPanel = True) Begin
90309>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90310>>>>>>>                If (bUserCancel = True) Begin
90312>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90313>>>>>>>                    Function_Return aApiTablesEmpty
90314>>>>>>>                End
90314>>>>>>>>
90314>>>>>>>            End
90314>>>>>>>>
90314>>>>>>>
90314>>>>>>>        Until (hTable = 0)
90316>>>>>>>
90316>>>>>>>        Function_Return aApiTables
90317>>>>>>>    End_Function
90318>>>>>>>
90318>>>>>>>    // Returns a 'single' table APITable struct.
90318>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90320>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90320>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90320>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90320>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90320>>>>>>>        tAPIColumn[]     aApiColumns
90320>>>>>>>        tAPIColumn[]     aApiColumns
90321>>>>>>>        tAPIIndex[]      aApiIndexes
90321>>>>>>>        tAPIIndex[]      aApiIndexes
90322>>>>>>>        tAPIRelation[]   aApiRelations
90322>>>>>>>        tAPIRelation[]   aApiRelations
90323>>>>>>>        Boolean bIsOpen
90323>>>>>>>
90323>>>>>>>        Open hTable
90325>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90328>>>>>>>        If (bIsOpen = False) Begin
90330>>>>>>>            Move True to ApiTableEmpty.bError
90331>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90332>>>>>>>            Function_Return ApiTableEmpty
90333>>>>>>>        End
90333>>>>>>>>
90333>>>>>>>
90333>>>>>>>        // Fill Table Name Info
90333>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90334>>>>>>>
90334>>>>>>>        // Fill columns
90334>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90335>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90337>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90339>>>>>>>                Move True to ApiTableEmpty.bError
90340>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90341>>>>>>>                Function_Return ApiTableEmpty
90342>>>>>>>            End
90342>>>>>>>>
90342>>>>>>>        End
90342>>>>>>>>
90342>>>>>>>
90342>>>>>>>        // Fill indexes
90342>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90343>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90345>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90347>>>>>>>                Move True to ApiTableEmpty.bError
90348>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90349>>>>>>>                Function_Return ApiTableEmpty
90350>>>>>>>            End
90350>>>>>>>>
90350>>>>>>>        End
90350>>>>>>>>
90350>>>>>>>
90350>>>>>>>        // Fill relationships
90350>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90351>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90353>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90355>>>>>>>                Move True to ApiTableEmpty.bError
90356>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90357>>>>>>>                Function_Return ApiTableEmpty
90358>>>>>>>            End
90358>>>>>>>>
90358>>>>>>>        End
90358>>>>>>>>
90358>>>>>>>
90358>>>>>>>        Move hTable             to ApiTable.hTable
90359>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90360>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
90361>>>>>>>
90361>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90362>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90363>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90364>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90365>>>>>>>
90365>>>>>>>        Function_Return ApiTable
90366>>>>>>>    End_Function
90367>>>>>>>
90367>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90369>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90369>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90369>>>>>>>        Boolean bIsOpen
90369>>>>>>>
90369>>>>>>>        Open hTable
90371>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90374>>>>>>>        If (bIsOpen = False) Begin
90376>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90377>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90378>>>>>>>            Function_Return APITableNameInfoEmpty
90379>>>>>>>        End
90379>>>>>>>>
90379>>>>>>>
90379>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90380>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90383>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90386>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90389>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90392>>>>>>>
90392>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90393>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
90394>>>>>>>
90394>>>>>>>        Function_Return APITableNameInfo
90395>>>>>>>    End_Function
90396>>>>>>>
90396>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90398>>>>>>>        Integer iSize iCount iItem
90398>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90398>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90398>>>>>>>
90398>>>>>>>        Move -1 to iItem
90399>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90400>>>>>>>        Decrement iSize
90401>>>>>>>        for iCount from 0 to iSize
90407>>>>>>>>
90407>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90408>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90410>>>>>>>                Move iCount to iItem
90411>>>>>>>                Move iSize  to iCount // We're done.
90412>>>>>>>            End
90412>>>>>>>>
90412>>>>>>>        Loop
90413>>>>>>>>
90413>>>>>>>
90413>>>>>>>        Function_Return iItem
90414>>>>>>>    End_Function
90415>>>>>>>
90415>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90417>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90420>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90423>>>>>>>
90423>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90426>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90429>>>>>>>
90429>>>>>>>        Function_Return (EQ)
90430>>>>>>>    End_Function
90431>>>>>>>
90431>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90433>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90433>>>>>>>        Handle hTable
90433>>>>>>>        tAPITable[] aAPITableFromAndTo
90433>>>>>>>        tAPITable[] aAPITableFromAndTo
90434>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90434>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90434>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90434>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90434>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90434>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90435>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90435>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90436>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90436>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90437>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90437>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90438>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90438>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90438>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90438>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90441>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90441>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90444>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90444>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90447>>>>>>>
90447>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90448>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90449>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90451>>>>>>>            Function_Return aAPITableCompare
90452>>>>>>>        End
90452>>>>>>>>
90452>>>>>>>
90452>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90453>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90454>>>>>>>
90454>>>>>>>        Move 0 to iItem
90455>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90456>>>>>>>        Decrement iSize
90457>>>>>>>        for iCount from 0 to iSize
90463>>>>>>>>
90463>>>>>>>
90463>>>>>>>            Move iCount to iItemFrom
90464>>>>>>>            Move iCount to iItemTo
90465>>>>>>>            Move APITableEmpty to APITableFrom
90466>>>>>>>            Move APITableEmpty to APITableTo
90467>>>>>>>
90467>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90469>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90470>>>>>>>            End
90470>>>>>>>>
90470>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90472>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90473>>>>>>>            End
90473>>>>>>>>
90473>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90475>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90476>>>>>>>                Move (iCount + 1) to iItemTo
90477>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90478>>>>>>>            End
90478>>>>>>>>
90478>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
90480>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
90481>>>>>>>                If (iItemTo <> -1) Begin
90483>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
90484>>>>>>>                End
90484>>>>>>>>
90484>>>>>>>                Else Begin
90485>>>>>>>                    Move APITableEmpty to APITableTo
90486>>>>>>>                End
90486>>>>>>>>
90486>>>>>>>            End
90486>>>>>>>>
90486>>>>>>>
90486>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90487>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90488>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90489>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90490>>>>>>>
90490>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90491>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90492>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90493>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90494>>>>>>>
90494>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90495>>>>>>>
90495>>>>>>>            If (hTable > 0) Begin
90497>>>>>>>
90497>>>>>>>                // Table info:
90497>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90498>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90499>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90500>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90501>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90502>>>>>>>
90502>>>>>>>                // Column info:
90502>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90503>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90504>>>>>>>
90504>>>>>>>                // Index info:
90504>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90505>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90506>>>>>>>
90506>>>>>>>                // Relation info:
90506>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90507>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90508>>>>>>>
90508>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90509>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90510>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90511>>>>>>>                If (iItemTo > iItemFrom) Begin
90513>>>>>>>                    Increment iCount
90514>>>>>>>                End
90514>>>>>>>>
90514>>>>>>>                Increment iItem
90515>>>>>>>            End
90515>>>>>>>>
90515>>>>>>>
90515>>>>>>>        Loop
90516>>>>>>>>
90516>>>>>>>
90516>>>>>>>        Function_Return aAPITableCompare
90517>>>>>>>    End_Function
90518>>>>>>>
90518>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
90520>>>>>>>        Integer iSize iCount iItem
90520>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90520>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90520>>>>>>>
90520>>>>>>>        Move -1 to iItem
90521>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90522>>>>>>>        Decrement iSize
90523>>>>>>>        For iCount from 0 to iSize
90529>>>>>>>>
90529>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90530>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
90532>>>>>>>                Move iCount to iItem
90533>>>>>>>                Move iSize  to iCount // We're done.
90534>>>>>>>            End
90534>>>>>>>>
90534>>>>>>>        Loop
90535>>>>>>>>
90535>>>>>>>
90535>>>>>>>        Function_Return iItem
90536>>>>>>>    End_Function
90537>>>>>>>
90537>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90539>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90539>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90539>>>>>>>
90539>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90541>>>>>>>            Function_Return APITableNameInfoCompare
90542>>>>>>>        End
90542>>>>>>>>
90542>>>>>>>
90542>>>>>>>        // FROM database info:
90542>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90544>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90545>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90546>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90547>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90548>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90549>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90550>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90551>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90552>>>>>>>        End
90552>>>>>>>>
90552>>>>>>>
90552>>>>>>>        // TO database info:
90552>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90554>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90555>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90556>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90557>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90558>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90559>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90560>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90561>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90562>>>>>>>        End
90562>>>>>>>>
90562>>>>>>>
90562>>>>>>>        Function_Return APITableNameInfoCompare
90563>>>>>>>    End_Function
90564>>>>>>>
90564>>>>>>>    // Note:
90564>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90564>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90564>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90564>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90564>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90564>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90566>>>>>>>        String sTableName
90566>>>>>>>        Boolean bOpen bExists bOK
90566>>>>>>>
90566>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90567>>>>>>>        If (bExists = False) Begin
90569>>>>>>>            Function_Return ""
90570>>>>>>>        End
90570>>>>>>>>
90570>>>>>>>
90570>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90571>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90574>>>>>>>        If (bOpen = False) Begin
90576>>>>>>>            Get AutoConnectionIDLogin to bOK
90577>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90578>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90579>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90580>>>>>>>            Open hTable
90582>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90583>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90584>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90585>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90588>>>>>>>        End
90588>>>>>>>>
90588>>>>>>>        If (bOpen = True) Begin
90590>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90591>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90594>>>>>>>            // If blank it is an embedded table:
90594>>>>>>>            If (sTableName = "") Begin
90596>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90599>>>>>>>                Move 0 to LastErr
90600>>>>>>>                Move False to Err
90601>>>>>>>            End
90601>>>>>>>>
90601>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90602>>>>>>>        End
90602>>>>>>>>
90602>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90603>>>>>>>        Move 0 to LastErr
90604>>>>>>>
90604>>>>>>>        Function_Return sTableName
90605>>>>>>>    End_Function
90606>>>>>>>
90606>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90606>>>>>>>    // Returns 0 if unsuccessful.
90606>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90606>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90608>>>>>>>        String sValue sPrefixTableName sDriverID
90608>>>>>>>        Handle hTable hRetval
90608>>>>>>>
90608>>>>>>>        Get psDriverID to sDriverID
90609>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90611>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90612>>>>>>>        End
90612>>>>>>>>
90612>>>>>>>        Move 0 to hTable
90613>>>>>>>        Move 0 to hRetval
90614>>>>>>>        Repeat
90614>>>>>>>>
90614>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90617>>>>>>>            If (hTable <> 0) Begin
90619>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90622>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90624>>>>>>>                    Move hTable to hRetval
90625>>>>>>>                    Move 0 to hTable
90626>>>>>>>                End
90626>>>>>>>>
90626>>>>>>>            End
90626>>>>>>>>
90626>>>>>>>        Until (hTable = 0)
90628>>>>>>>
90628>>>>>>>        Function_Return hRetval
90629>>>>>>>    End_Function
90630>>>>>>>
90630>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90630>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90630>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90632>>>>>>>        Boolean bOK bExists
90632>>>>>>>        String sDataPath sBackupFolder
90632>>>>>>>
90632>>>>>>>        Close DF_ALL DF_PERMANENT
90633>>>>>>>        Send DoAdvance of ghoProgressBar
90634>>>>>>>
90634>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90635>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90636>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90637>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90638>>>>>>>
90638>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90639>>>>>>>        If (bExists = False) Begin
90641>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90642>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90643>>>>>>>            If (bExists = False) Begin
90645>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90646>>>>>>>>
90646>>>>>>>                Function_Return False
90647>>>>>>>            End
90647>>>>>>>>
90647>>>>>>>        End
90647>>>>>>>>
90647>>>>>>>
90647>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90648>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90649>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90650>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90651>>>>>>>        // We need to wait for Windows before we can copy files back
90651>>>>>>>        Sleep 2  
90652>>>>>>>        
90652>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90652>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90653>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90654>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90655>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90656>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90657>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90658>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90658>>>>>>>        
90658>>>>>>>
90658>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90659>>>>>>>        Function_Return True
90660>>>>>>>    End_Function
90661>>>>>>>    
90661>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90663>>>>>>>        Boolean bOK bRetval
90663>>>>>>>        Handle hTable
90663>>>>>>>        Integer iSize iCount
90663>>>>>>>        
90663>>>>>>>        Move True to bOK
90664>>>>>>>        Get UtilFilelistNoOfTables to iSize
90665>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90666>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90667>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90668>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90669>>>>>>>
90669>>>>>>>        Repeat
90669>>>>>>>>
90669>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90670>>>>>>>            Increment iCount
90671>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90674>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90676>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90677>>>>>>>                If (bRetval = False) Begin
90679>>>>>>>                    Move False to bOK
90680>>>>>>>                End
90680>>>>>>>>
90680>>>>>>>            End
90680>>>>>>>>
90680>>>>>>>        Until (hTable = 0)
90682>>>>>>>                
90682>>>>>>>        Function_Return bOK
90683>>>>>>>    End_Function           
90684>>>>>>>    
90684>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90684>>>>>>>    // After the header has been repaired - also makes a re-index.  
90684>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90684>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90686>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90686>>>>>>>        Integer iRetval
90686>>>>>>>        String sRootName sFileName sDataPath
90686>>>>>>>        
90686>>>>>>>        Move False to Err
90687>>>>>>>        Move 0 to LastErr 
90688>>>>>>>        Move True to bOK
90689>>>>>>>        
90689>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90690>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90692>>>>>>>            Function_Return True
90693>>>>>>>        End
90693>>>>>>>>
90693>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90694>>>>>>>        If (bIsAlias = True) Begin
90696>>>>>>>            Function_Return True
90697>>>>>>>        End
90697>>>>>>>>
90697>>>>>>>        
90697>>>>>>>        // Check for bad file and remove if exists
90697>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90700>>>>>>>        Set private.phCurrentTable to hTable  
90701>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90702>>>>>>>        
90702>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90702>>>>>>>        // with a "4077 - File in use" error.
90702>>>>>>>        Close DF_ALL DF_PERMANENT    
90703>>>>>>>        Open hTable
90705>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90708>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90709>>>>>>>        If (bIsOpen = False) Begin
90711>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90712>>>>>>>>
90712>>>>>>>            Function_Return False        
90713>>>>>>>        End
90713>>>>>>>>
90713>>>>>>>
90713>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90714>>>>>>>        If (bBadExists = True) Begin
90716>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90717>>>>>>>            Get vDeleteFile sFileName to iRetval
90718>>>>>>>        End
90718>>>>>>>>
90718>>>>>>>        
90718>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90719>>>>>>>        
90719>>>>>>>        Move False to Err
90720>>>>>>>        // **** Repair and reindex the table. ****
90720>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90721>>>>>>>
90721>>>>>>>        // Check for bad file: if it exists, something went wrong
90721>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90722>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90723>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90724>>>>>>>        If (bBadExists = True) Begin
90726>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90727>>>>>>>>
90727>>>>>>>            Move False to bOK
90728>>>>>>>        End
90728>>>>>>>>
90728>>>>>>>        Close hTable
90729>>>>>>>
90729>>>>>>>        Function_Return bOK
90730>>>>>>>    End_Function
90731>>>>>>>
90731>>>>>>>    // Repair and reindex the named DataFlex data-table.
90731>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90731>>>>>>>    // so use with care (make sure you only pass embedded table names).
90731>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90733>>>>>>>        String sMode
90733>>>>>>>        Integer iVoid
90733>>>>>>>
90733>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90734>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90735>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90736>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90741>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90742>>>>>>>        Function_Return (iVoid = 0)
90743>>>>>>>    End_Function
90744>>>>>>>
90744>>>>>>>    // Returns _two_ arrays.
90744>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90744>>>>>>>    // Also returns all files that are Alias files in a second array.
90744>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90744>>>>>>>    //            the DoSetAllMasterAndAlias message.
90744>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90746>>>>>>>        Integer[] iaFileIsAlias
90747>>>>>>>        Integer hTable iFileAlias iSize
90747>>>>>>>        Boolean bOpen
90747>>>>>>>
90747>>>>>>>        Move 0 to hTable
90748>>>>>>>        Repeat
90748>>>>>>>>
90748>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90751>>>>>>>            If (hTable <> 0) Begin
90753>>>>>>>                Open hTable
90755>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90758>>>>>>>                If (bOpen = True) Begin
90760>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90763>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90765>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90766>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90767>>>>>>>                    End
90767>>>>>>>>
90767>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90770>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90771>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90772>>>>>>>                    End
90772>>>>>>>>
90772>>>>>>>                End
90772>>>>>>>>
90772>>>>>>>            End
90772>>>>>>>>
90772>>>>>>>        Until (hTable = 0)
90774>>>>>>>
90774>>>>>>>        Function_Return iaFileIsAlias
90775>>>>>>>    End_Function  
90776>>>>>>>    
90776>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90776>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90778>>>>>>>        String sMode
90778>>>>>>>        Integer iRepairNeeded bIsOpen
90778>>>>>>>
90778>>>>>>>        Move "0" to sMode
90779>>>>>>>        Set private.phCurrentTable to hTable 
90780>>>>>>>        Close hTable
90781>>>>>>>        Open hTable
90783>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90786>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90791>>>>>>>
90791>>>>>>>        Function_Return iRepairNeeded
90792>>>>>>>    End_Function
90793>>>>>>>
90793>>>>>>>    // Helper function
90793>>>>>>>    // Takes two params:
90793>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90793>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90793>>>>>>>    // Returns:
90793>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90793>>>>>>>    //  DF_FILE_IS_MASTER if master
90793>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90793>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90795>>>>>>>        Integer i iSize
90795>>>>>>>
90795>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90796>>>>>>>        Decrement iSize
90797>>>>>>>        for i from 0 to iSize
90803>>>>>>>>
90803>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90805>>>>>>>                Function_Return DF_FILE_IS_MASTER
90806>>>>>>>            End
90806>>>>>>>>
90806>>>>>>>        Loop
90807>>>>>>>>
90807>>>>>>>
90807>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90808>>>>>>>        Decrement iSize
90809>>>>>>>        for i from 0 to iSize
90815>>>>>>>>
90815>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90817>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90818>>>>>>>            End
90818>>>>>>>>
90818>>>>>>>        Loop
90819>>>>>>>>
90819>>>>>>>
90819>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90820>>>>>>>    End_Function
90821>>>>>>>
90821>>>>>>>    // Determine the available indexes of a table.
90821>>>>>>>    //
90821>>>>>>>    // Arguments:
90821>>>>>>>    //   Handle hTable - The number of the table
90821>>>>>>>    //
90821>>>>>>>    // Returns:
90821>>>>>>>    //   String - A string to be used with the sort command
90821>>>>>>>    //   to re-index all indexes of a table.
90821>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90823>>>>>>>        String  sSortString
90823>>>>>>>        Integer iLastIndex iNumSegments iCount
90823>>>>>>>
90823>>>>>>>        Move "" to sSortString
90824>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90827>>>>>>>
90827>>>>>>>        for iCount from 1 to iLastIndex
90833>>>>>>>>
90833>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90836>>>>>>>            If iNumSegments Begin
90838>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90841>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90842>>>>>>>            End
90842>>>>>>>>
90842>>>>>>>        Loop
90843>>>>>>>>
90843>>>>>>>
90843>>>>>>>        Function_Return sSortString
90844>>>>>>>    End_Function
90845>>>>>>>
90845>>>>>>>    
90845>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90845>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90847>>>>>>>        Function_Return False
90848>>>>>>>    End_Function
90849>>>>>>>
90849>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90849>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90851>>>>>>>        Boolean bIsSame
90851>>>>>>>        Integer iCount iColumns iColumn
90851>>>>>>>
90851>>>>>>>        Move True to bIsSame
90852>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90853>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90854>>>>>>>        Decrement iColumns
90855>>>>>>>
90855>>>>>>>        For iCount from 0 to iColumns
90861>>>>>>>>
90861>>>>>>>            Set piPosition of ghoProgressBar to iCount
90862>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90863>>>>>>>            If (bIsSame = False) Begin
90865>>>>>>>                Function_Return False
90866>>>>>>>            End
90866>>>>>>>>
90866>>>>>>>        Loop
90867>>>>>>>>
90867>>>>>>>
90867>>>>>>>        Function_Return (bIsSame = True)
90868>>>>>>>    End_Function
90869>>>>>>>
90869>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90869>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90871>>>>>>>        Integer iFromType iToType iDbType
90871>>>>>>>        tColumnType ColumnType
90871>>>>>>>        tColumnType ColumnType
90871>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90871>>>>>>>
90871>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90873>>>>>>>            Function_Return False
90874>>>>>>>        End
90874>>>>>>>>
90874>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90876>>>>>>>            Function_Return False
90877>>>>>>>        End
90877>>>>>>>>
90877>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90879>>>>>>>            Function_Return False
90880>>>>>>>        End                                                                
90880>>>>>>>>
90880>>>>>>>
90880>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90882>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90884>>>>>>>                Function_Return False
90885>>>>>>>            End
90885>>>>>>>>
90885>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90887>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90889>>>>>>>                    End
90889>>>>>>>>
90889>>>>>>>                Else Begin
90890>>>>>>>                    Function_Return False
90891>>>>>>>                End
90891>>>>>>>>
90891>>>>>>>            End
90891>>>>>>>>
90891>>>>>>>        End
90891>>>>>>>>
90891>>>>>>>
90891>>>>>>>        Get piDbType                       to iDbType
90892>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90893>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90894>>>>>>>
90894>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90894>>>>>>>        // data types between Embedded and SQL.
90894>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90896>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90897>>>>>>>        End
90897>>>>>>>>
90897>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90899>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90900>>>>>>>        End
90900>>>>>>>>
90900>>>>>>>
90900>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90901>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90902>>>>>>>
90902>>>>>>>        // Make Date and DateTime comparison?
90902>>>>>>>        If (bCompareDate_DataTime = True) Begin
90904>>>>>>>            If (iFromType <> iToType) Begin
90906>>>>>>>                Function_Return False
90907>>>>>>>            End
90907>>>>>>>>
90907>>>>>>>        End
90907>>>>>>>>
90907>>>>>>>
90907>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90907>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90909>>>>>>>            If (iFromType <> iToType) Begin
90911>>>>>>>                Function_Return False
90912>>>>>>>            End
90912>>>>>>>>
90912>>>>>>>        End
90912>>>>>>>>
90912>>>>>>>
90912>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90912>>>>>>>        If (bIsDateTypeFrom = False) Begin
90914>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90916>>>>>>>                Function_Return False
90917>>>>>>>            End
90917>>>>>>>>
90917>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90919>>>>>>>                Function_Return False
90920>>>>>>>            End
90920>>>>>>>>
90920>>>>>>>        End
90920>>>>>>>>
90920>>>>>>>
90920>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90922>>>>>>>            Function_Return False
90923>>>>>>>        End
90923>>>>>>>>
90923>>>>>>>
90923>>>>>>>        Function_Return True
90924>>>>>>>    End_Function
90925>>>>>>>
90925>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90927>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber iDriverID
90927>>>>>>>        Boolean bIdentityKey bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90927>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90927>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90929>>>>>>>        String sDriverID sRootName sLogicalName sDataType
90929>>>>>>>
90929>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90930>>>>>>>        Get piDbType to iDbType
90931>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90934>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90937>>>>>>>
90937>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90940>>>>>>>        If (bIsOpen = False) Begin
90942>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90943>>>>>>>            Open hTable
90945>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90946>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90949>>>>>>>            If (bIsOpen = False) Begin
90951>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90952>>>>>>>                Move True to APIColumnsEmpty[0].bError
90953>>>>>>>                Function_Return APIColumnsEmpty
90954>>>>>>>            End
90954>>>>>>>>
90954>>>>>>>        End
90954>>>>>>>>
90954>>>>>>>
90954>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90957>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90958>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90959>>>>>>>        If (bIsSqlTable = True) Begin
90961>>>>>>>            Get _UtilTableExists hTable to bExists
90962>>>>>>>            If (bExists = False) Begin
90964>>>>>>>                Move True to APIColumnsEmpty[0].bError
90965>>>>>>>                Function_Return APIColumnsEmpty
90966>>>>>>>            End
90966>>>>>>>>
90966>>>>>>>        End
90966>>>>>>>>
90966>>>>>>>//        Get DriverIndex sDriverID to iDriverID
90966>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
90966>>>>>>>//            Set_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE of iDriverId to 'datetime2'
90966>>>>>>>//        End
90966>>>>>>>
90966>>>>>>>        Move 0 to iCount
90967>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90970>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90971>>>>>>>
90971>>>>>>>        for iColumn from 1 to iNumColumns
90977>>>>>>>>
90977>>>>>>>            Move 0 to iOptions
90978>>>>>>>            Move False to bIdentityKey
90979>>>>>>>            Move False to Err
90980>>>>>>>            Move 0     to LastErr
90981>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90982>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90983>>>>>>>
90983>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90984>>>>>>>            If (bIsSqlTable = True) Begin 
90986>>>>>>>//                If (iType = DF_DATE) Begin
90986>>>>>>>//                    // Note: This is actually the same as SQL_DATETIME
90986>>>>>>>//                    Move SQL_DATE to iType
90986>>>>>>>//                    Move 3 to APIColumns[iCouknt].iPrecision
90986>>>>>>>//                End
90986>>>>>>>//                Else If (iType = DF_DATET Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeIME) Begin
90986>>>>>>>//                    // In modern MS-SQL databases SQL_DATETIME will be = to "datetime2".
90986>>>>>>>//                    // By default MS-SQL will create such a field with 7 (!) decimal places.
90986>>>>>>>//                    // This is just a waste because DataFlex will truncate that to 3 decimal
90986>>>>>>>//                    // places. Therefore, we hard-code the precision to be only thee decimals.
90986>>>>>>>//                    Move SQL_DATETIME to iType
90986>>>>>>>//                    Move 3 to APIColumns[iCount].iPrecision
90986>>>>>>>//                End
90986>>>>>>>//                Move iType                                                to APIColumns[iCount].iType
90986>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
90989>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90992>>>>>>>                Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90995>>>>>>>                Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90998>>>>>>>            End
90998>>>>>>>>
90998>>>>>>>            Else Begin
90999>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
91002>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
91003>>>>>>>            End
91003>>>>>>>>
91003>>>>>>>
91003>>>>>>>            // If the array value is out of bounce it means that this column doesn't exist on the backend.
91003>>>>>>>            Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
91006>>>>>>>            Move (iCheckFieldNumber >= 0) to bExists
91007>>>>>>>            If (bExists = False) Begin
91009>>>>>>>                Move 0 to APIColumns[iCount].iType
91010>>>>>>>            End
91010>>>>>>>>
91010>>>>>>>            If (bExists = True) Begin
91012>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
91015>>>>>>>            End
91015>>>>>>>>
91015>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91016>>>>>>>            If (bIdentityKey = True) Begin
91018>>>>>>>                Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
91019>>>>>>>            End
91019>>>>>>>>
91019>>>>>>>
91019>>>>>>>//            Else Begin
91019>>>>>>>//                Move False to Err
91019>>>>>>>//                Move 0     to LastErr
91019>>>>>>>//                If (bIsSqlTable = True) Begin
91019>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
91019>>>>>>>//                End
91019>>>>>>>//                Else Begin
91019>>>>>>>//                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
91019>>>>>>>//                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
91019>>>>>>>//                End
91019>>>>>>>//                // If the array value is out of bounce it means that this column doesn't exist on the backend.
91019>>>>>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
91019>>>>>>>//                If (bExists = False) Begin
91019>>>>>>>//                    Move 0 to APIColumns[iCount].iType
91019>>>>>>>//                End
91019>>>>>>>//            End
91019>>>>>>>
91019>>>>>>>            If (bExists = True) Begin
91021>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
91022>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
91025>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
91025>>>>>>>//                If (bIsSqlTable = True) Begin
91025>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
91025>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
91025>>>>>>>//                End
91025>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength 
91028>>>>>>>                If (APIColumns[iCount].iPrecision = 0) Begin
91030>>>>>>>                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
91033>>>>>>>                End
91033>>>>>>>>
91033>>>>>>>
91033>>>>>>>                // If the length was zero we might have an Overlap(!) field.
91033>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
91033>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
91035>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
91038>>>>>>>                    If (iType = DF_OVERLAP) Begin
91040>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
91041>>>>>>>                        Move 0 to APIColumns[iCount].iLength
91042>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
91043>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
91044>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
91045>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
91046>>>>>>>                        Decrement iCount
91047>>>>>>>                    End
91047>>>>>>>>
91047>>>>>>>                End
91047>>>>>>>>
91047>>>>>>>            End
91047>>>>>>>>
91047>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
91048>>>>>>>            If (bUserCancel = True) Begin
91050>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
91051>>>>>>>                Function_Return APIColumnsEmpty
91052>>>>>>>            End
91052>>>>>>>>
91052>>>>>>>            Increment iCount
91053>>>>>>>        Loop
91054>>>>>>>>
91054>>>>>>>
91054>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91055>>>>>>>        Function_Return APIColumns
91056>>>>>>>    End_Function
91057>>>>>>>     
91057>>>>>>>    // ToDo: Shouldn't this be the other way round? The From bit last? That is what should be of interest??
91057>>>>>>>    // *** 
91057>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO column arrays.
91057>>>>>>>    // The combined data will be sorted on the first struct member: iFieldNumber
91057>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
91059>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
91059>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
91060>>>>>>>        tAPIColumnCompare   APIColumnCompare
91060>>>>>>>        tAPIColumnCompare   APIColumnCompare
91060>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91060>>>>>>>
91060>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
91061>>>>>>>        Decrement iSizeFrom
91062>>>>>>>        for iCount from 0 to iSizeFrom
91068>>>>>>>>
91068>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
91069>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
91070>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
91071>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
91072>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
91073>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
91074>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
91075>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
91076>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
91077>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
91078>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
91079>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
91080>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
91081>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
91082>>>>>>>        Loop
91083>>>>>>>>
91083>>>>>>>
91083>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
91084>>>>>>>        Decrement iSizeTo
91085>>>>>>>        for iCount from 0 to iSizeTo
91091>>>>>>>>
91091>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
91092>>>>>>>            // Search if the field number already exists in the "to" array; else add it. <
91092>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
91093>>>>>>>            If (iItem = -1) Begin
91095>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
91096>>>>>>>            End
91096>>>>>>>>
91096>>>>>>>
91096>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
91097>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
91098>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
91099>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
91100>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
91101>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
91102>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
91103>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
91104>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
91105>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
91106>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
91107>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
91108>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
91109>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
91110>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
91111>>>>>>>        Loop
91112>>>>>>>>
91112>>>>>>>
91112>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
91113>>>>>>>
91113>>>>>>>        Function_Return aAPIColumnCompare
91114>>>>>>>    End_Function
91115>>>>>>>
91115>>>>>>>    // Checks if a field name exists in a table definition
91115>>>>>>>    // Returns True if it does
91115>>>>>>>    // Sample:
91115>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
91115>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
91117>>>>>>>        Integer iNumColumns iColumn
91117>>>>>>>        String sColumn
91117>>>>>>>        Boolean bExists bOK bOpen
91117>>>>>>>
91117>>>>>>>        Get AutoConnectionIDLogin to bOK
91118>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91119>>>>>>>        Open hTable
91121>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91122>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91125>>>>>>>        If (bOpen = False) Begin
91127>>>>>>>            Function_Return False
91128>>>>>>>        End
91128>>>>>>>>
91128>>>>>>>
91128>>>>>>>        Move False to bExists
91129>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91132>>>>>>>        for iColumn from 1 to iNumColumns
91138>>>>>>>>
91138>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91141>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91143>>>>>>>                Move iNumColumns to iColumn
91144>>>>>>>                Move True to bExists
91145>>>>>>>            End
91145>>>>>>>>
91145>>>>>>>        Loop
91146>>>>>>>>
91146>>>>>>>        Close hTable
91147>>>>>>>
91147>>>>>>>        Function_Return bExists
91148>>>>>>>    End_Function
91149>>>>>>>
91149>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
91149>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
91151>>>>>>>        Integer iNumColumns iColumn iRetval
91151>>>>>>>        String sColumn
91151>>>>>>>        Boolean bOK bOpen
91151>>>>>>>
91151>>>>>>>        Get AutoConnectionIDLogin to bOK
91152>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91153>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91154>>>>>>>        Open hTable
91156>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91157>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91160>>>>>>>        If (bOpen = False) Begin
91162>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91163>>>>>>>            Function_Return False
91164>>>>>>>        End
91164>>>>>>>>
91164>>>>>>>
91164>>>>>>>        Move 0 to iColumn
91165>>>>>>>        Move 0 to iRetval
91166>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91169>>>>>>>        For iColumn from 1 to iNumColumns
91175>>>>>>>>
91175>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91178>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91180>>>>>>>                Move iColumn to iRetval
91181>>>>>>>                Move iNumColumns to iColumn
91182>>>>>>>            End
91182>>>>>>>>
91182>>>>>>>        Loop
91183>>>>>>>>
91183>>>>>>>        Close hTable
91184>>>>>>>
91184>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91185>>>>>>>        Function_Return iRetval
91186>>>>>>>    End_Function
91187>>>>>>>
91187>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
91187>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91187>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
91189>>>>>>>        tColumnType RetvalType
91189>>>>>>>        tColumnType RetvalType
91189>>>>>>>
91189>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
91190>>>>>>>        Function_Return RetvalType.iSQLType
91191>>>>>>>    End_Function
91192>>>>>>>
91192>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
91192>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91192>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
91194>>>>>>>        tColumnType RetvalType
91194>>>>>>>        tColumnType RetvalType
91194>>>>>>>
91194>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91195>>>>>>>        Function_Return RetvalType.sSQLType
91196>>>>>>>    End_Function
91197>>>>>>>
91197>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
91199>>>>>>>        tColumnType RetvalType
91199>>>>>>>        tColumnType RetvalType
91199>>>>>>>
91199>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91200>>>>>>>        Function_Return RetvalType.sPrecision
91201>>>>>>>    End_Function
91202>>>>>>>
91202>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
91204>>>>>>>        tColumnType RetvalType
91204>>>>>>>        tColumnType RetvalType
91204>>>>>>>
91204>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91205>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
91205>>>>>>>        // if the column type length is _not_ fixed.
91205>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
91206>>>>>>>    End_Function
91207>>>>>>>
91207>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
91209>>>>>>>        tColumnType RetvalType
91209>>>>>>>        tColumnType RetvalType
91209>>>>>>>        String sValue
91209>>>>>>>        Integer iRetval iPos
91209>>>>>>>
91209>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91210>>>>>>>        Move RetvalType.sPrecision to sValue
91211>>>>>>>        Move (Pos(".", sValue)) to iPos
91212>>>>>>>        If (iPos <> 0) Begin
91214>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
91215>>>>>>>        End
91215>>>>>>>>
91215>>>>>>>        Else Begin
91216>>>>>>>            Move sValue to iRetval
91217>>>>>>>        End
91217>>>>>>>>
91217>>>>>>>        Function_Return iRetval
91218>>>>>>>    End_Function
91219>>>>>>>
91219>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91221>>>>>>>        tColumnType RetvalType
91221>>>>>>>        tColumnType RetvalType
91221>>>>>>>        String sValue
91221>>>>>>>        Integer iRetval iPos
91221>>>>>>>
91221>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91222>>>>>>>        Move RetvalType.sPrecision to sValue
91223>>>>>>>        Move (Pos(".", sValue)) to iPos
91224>>>>>>>        If (iPos = 0) Begin
91226>>>>>>>            Function_Return 0
91227>>>>>>>        End
91227>>>>>>>>
91227>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91228>>>>>>>
91228>>>>>>>        Function_Return iRetval
91229>>>>>>>    End_Function
91230>>>>>>>
91230>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91230>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91232>>>>>>>        Function_Return False
91233>>>>>>>    End_Function
91234>>>>>>>
91234>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91234>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91236>>>>>>>        Boolean bIsSame
91236>>>>>>>        Integer iCount iSize
91236>>>>>>>
91236>>>>>>>        Move True to bIsSame
91237>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91238>>>>>>>        Decrement iSize
91239>>>>>>>        For iCount from 0 to iSize
91245>>>>>>>>
91245>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91246>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91247>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91248>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91249>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91250>>>>>>>            If (bIsSame = False) Begin
91252>>>>>>>                Function_Return False
91253>>>>>>>            End
91253>>>>>>>>
91253>>>>>>>        Loop
91254>>>>>>>>
91254>>>>>>>
91254>>>>>>>        Function_Return bIsSame
91255>>>>>>>    End_Function
91256>>>>>>>
91256>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91256>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91258>>>>>>>        Boolean bIsSame
91258>>>>>>>        Integer iSegment
91258>>>>>>>
91258>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91259>>>>>>>        If (bIsSame = False) Begin
91261>>>>>>>            Function_Return False
91262>>>>>>>        End
91262>>>>>>>>
91262>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91263>>>>>>>        If (bIsSame = False) Begin
91265>>>>>>>            Function_Return False
91266>>>>>>>        End
91266>>>>>>>>
91266>>>>>>>
91266>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91268>>>>>>>            // * We should probably not compare SQL index names?
91268>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91268>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91268>>>>>>>            //     Function_Return False
91268>>>>>>>            // End
91268>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91269>>>>>>>            If (bIsSame = False) Begin
91271>>>>>>>                Function_Return False
91272>>>>>>>            End
91272>>>>>>>>
91272>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91273>>>>>>>            If (bIsSame = False) Begin
91275>>>>>>>                Function_Return False
91276>>>>>>>            End
91276>>>>>>>>
91276>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91277>>>>>>>            If (bIsSame = False) Begin
91279>>>>>>>                Function_Return False
91280>>>>>>>            End
91280>>>>>>>>
91280>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
91281>>>>>>>            If (bIsSame = False) Begin
91283>>>>>>>                Function_Return False
91284>>>>>>>            End
91284>>>>>>>>
91284>>>>>>>        End
91284>>>>>>>>
91284>>>>>>>
91284>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91285>>>>>>>        Move (iSegment = -1) to bIsSame
91286>>>>>>>
91286>>>>>>>        Function_Return bIsSame
91287>>>>>>>    End_Function
91288>>>>>>>
91288>>>>>>>    // Compares each segment for the passed index.
91288>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91288>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91290>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91290>>>>>>>        Boolean bIsSame
91290>>>>>>>
91290>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91291>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91292>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91293>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo 
91294>>>>>>>        If (iNumSegmentsFrom <> iNumSegmentsTo) Begin
91296>>>>>>>            Function_Return -1
91297>>>>>>>        End
91297>>>>>>>>
91297>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91298>>>>>>>
91298>>>>>>>        Decrement iNumSegments
91299>>>>>>>        for iSegment from 0 to iNumSegments
91305>>>>>>>>
91305>>>>>>>            Move False to bIsSame
91306>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
91308>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91309>>>>>>>            End
91309>>>>>>>>
91309>>>>>>>            If (bIsSame = False) Begin
91311>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91312>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91313>>>>>>>                Function_Return iSegment
91314>>>>>>>            End
91314>>>>>>>>
91314>>>>>>>        Loop
91315>>>>>>>>
91315>>>>>>>
91315>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91316>>>>>>>        Function_Return -1 // This means bIsSame = True
91317>>>>>>>    End_Function
91318>>>>>>>
91318>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91320>>>>>>>        Boolean bIsSame
91320>>>>>>>
91320>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91321>>>>>>>        If (bIsSame = False) Begin
91323>>>>>>>            Function_Return False
91324>>>>>>>        End
91324>>>>>>>>
91324>>>>>>>        If (bCompareIndexUppercase = True) Begin
91326>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91327>>>>>>>            If (bIsSame = False) Begin
91329>>>>>>>                Function_Return False
91330>>>>>>>            End
91330>>>>>>>>
91330>>>>>>>        End
91330>>>>>>>>
91330>>>>>>>        If (bCompareIndexAscending = True) Begin
91332>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91333>>>>>>>            If (bIsSame = False) Begin
91335>>>>>>>                Function_Return False
91336>>>>>>>            End
91336>>>>>>>>
91336>>>>>>>        End
91336>>>>>>>>
91336>>>>>>>
91336>>>>>>>        Function_Return True
91337>>>>>>>    End_Function
91338>>>>>>>
91338>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91340>>>>>>>        Boolean bIsSame bOK
91340>>>>>>>        Integer iSize iSizeTo iCount
91340>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91340>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91341>>>>>>>
91341>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91342>>>>>>>        If (iSize = 0) Begin
91344>>>>>>>            Function_Return True
91345>>>>>>>        End
91345>>>>>>>>
91345>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
91346>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
91347>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91348>>>>>>>
91348>>>>>>>        For iCount from 0 to (iSize - 1)
91354>>>>>>>>
91354>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91355>>>>>>>            If (bIsSame = False) Begin
91357>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91358>>>>>>>            End
91358>>>>>>>>
91358>>>>>>>        Loop
91359>>>>>>>>
91359>>>>>>>
91359>>>>>>>        // We probably should delete other indexes if they exists.
91359>>>>>>>        For iCount from (iSize +1) to iSizeTo
91365>>>>>>>>
91365>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91366>>>>>>>        Loop
91367>>>>>>>>
91367>>>>>>>
91367>>>>>>>        Function_Return bOK
91368>>>>>>>    End_Function
91369>>>>>>>
91369>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91371>>>>>>>        tAPIIndex[] APIIndexes
91371>>>>>>>        tAPIIndex[] APIIndexes
91372>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91372>>>>>>>        String sDriverID
91372>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
91372>>>>>>>
91372>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91373>>>>>>>        Get psDriverID to sDriverID
91374>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91375>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
91376>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91379>>>>>>>        If (bIsOpen = False) Begin
91381>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91382>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91383>>>>>>>            Open hTable
91385>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91386>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91387>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91390>>>>>>>            If (bIsOpen = False) Begin
91392>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91393>>>>>>>                Move True to APIIndexes[0].bError
91394>>>>>>>                Function_Return APIIndexes
91395>>>>>>>            End
91395>>>>>>>>
91395>>>>>>>        End
91395>>>>>>>>
91395>>>>>>>
91395>>>>>>>        Move 0 to iCount
91396>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91399>>>>>>>        For iIndex from 1 to iIndexes
91405>>>>>>>>
91405>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91405>>>>>>>            // numbers doesn't not need to be consequitive:
91405>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91408>>>>>>>            If (iNumSegments > 0) Begin
91410>>>>>>>
91410>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91411>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91414>>>>>>>                If (bIsSQLTable = True) Begin
91416>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91419>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91422>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91425>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91428>>>>>>>                End
91428>>>>>>>>
91428>>>>>>>
91428>>>>>>>                Move 0 to iSegmentCount
91429>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91432>>>>>>>                For iSegment from 1 to iNumSegments
91438>>>>>>>>
91438>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91441>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91442>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91445>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91448>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91451>>>>>>>                    Increment iSegmentCount
91452>>>>>>>                Loop
91453>>>>>>>>
91453>>>>>>>                Increment iCount
91454>>>>>>>            End
91454>>>>>>>>
91454>>>>>>>        Loop
91455>>>>>>>>
91455>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91456>>>>>>>
91456>>>>>>>        Function_Return APIIndexes
91457>>>>>>>    End_Function
91458>>>>>>>
91458>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91458>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91458>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91458>>>>>>>    // have "holes" in the series of index numbers.
91458>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91460>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91460>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91461>>>>>>>        tAPIIndexCompare   APIIndexCompare
91461>>>>>>>        tAPIIndexCompare   APIIndexCompare
91461>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91461>>>>>>>
91461>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91462>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91463>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91465>>>>>>>            Function_Return aAPIIndexCompare
91466>>>>>>>        End
91466>>>>>>>>
91466>>>>>>>
91466>>>>>>>        Decrement iSizeFrom
91467>>>>>>>        for iCount from 0 to iSizeFrom
91473>>>>>>>>
91473>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91474>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91475>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91476>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91477>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91478>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91479>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91480>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91481>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91482>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91483>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91484>>>>>>>        Loop
91485>>>>>>>>
91485>>>>>>>
91485>>>>>>>        Decrement iSizeTo
91486>>>>>>>        for iCount from 0 to iSizeTo
91492>>>>>>>>
91492>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91493>>>>>>>            // Search if the Index number already exists in the array; else add it.
91493>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91494>>>>>>>            If (iItem = -1) Begin
91496>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91497>>>>>>>            End
91497>>>>>>>>
91497>>>>>>>
91497>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91498>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91499>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91500>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91501>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91502>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91503>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91504>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91505>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91506>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91507>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91508>>>>>>>        Loop
91509>>>>>>>>
91509>>>>>>>
91509>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91510>>>>>>>
91510>>>>>>>        Function_Return aAPIIndexCompare
91511>>>>>>>    End_Function
91512>>>>>>>
91512>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91512>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91514>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91514>>>>>>>        String sDriverID
91514>>>>>>>
91514>>>>>>>        Get psDriverID to sDriverID
91515>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91516>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91517>>>>>>>        If (bIsSqlTable = True) Begin
91519>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
91520>>>>>>>        End
91520>>>>>>>>
91520>>>>>>>
91520>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91521>>>>>>>        If (bIsSame = False) Begin
91523>>>>>>>            Function_Return False
91524>>>>>>>        End
91524>>>>>>>>
91524>>>>>>>
91524>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91526>>>>>>>            // Don't think we should do this. Or should we?
91526>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91526>>>>>>>
91526>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91527>>>>>>>            If (bIsSame = False) Begin
91529>>>>>>>                Function_Return False
91530>>>>>>>            End
91530>>>>>>>>
91530>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91531>>>>>>>            If (bIsSame = False) Begin
91533>>>>>>>                Function_Return False
91534>>>>>>>            End
91534>>>>>>>>
91534>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91535>>>>>>>            If (bIsSame = False) Begin
91537>>>>>>>                Function_Return False
91538>>>>>>>            End
91538>>>>>>>>
91538>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91539>>>>>>>            If (bIsSame = False) Begin
91541>>>>>>>                Function_Return False
91542>>>>>>>            End
91542>>>>>>>>
91542>>>>>>>        End
91542>>>>>>>>
91542>>>>>>>
91542>>>>>>>        Function_Return bIsSame
91543>>>>>>>    End_Function
91544>>>>>>>
91544>>>>>>>    // DF_INDEX_SQL_TYPE values
91544>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91544>>>>>>>    // returns a string with the name.
91544>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91546>>>>>>>        String sRetval
91546>>>>>>>            Case Begin
91546>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91548>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91549>>>>>>>                    Case Break
91550>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91553>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91554>>>>>>>                    Case Break
91555>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91558>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91559>>>>>>>                    Case Break
91560>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91563>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91564>>>>>>>                    Case Break
91565>>>>>>>                Case Else
91565>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91566>>>>>>>            Case End
91566>>>>>>>        Function_Return sRetval
91567>>>>>>>    End_Function
91568>>>>>>>
91568>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91568>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91570>>>>>>>        Function_Return False
91571>>>>>>>    End_Function
91572>>>>>>>
91572>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91572>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91574>>>>>>>        Boolean bIsSame
91574>>>>>>>        Integer iSize iCount
91574>>>>>>>
91574>>>>>>>        Move True to bIsSame
91575>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91576>>>>>>>        Decrement iSize
91577>>>>>>>        For iCount from 0 to iSize
91583>>>>>>>>
91583>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91584>>>>>>>            If (bIsSame = False) Begin
91586>>>>>>>                Function_Return False
91587>>>>>>>            End
91587>>>>>>>>
91587>>>>>>>        Loop
91588>>>>>>>>
91588>>>>>>>
91588>>>>>>>        Function_Return bIsSame
91589>>>>>>>    End_Function
91590>>>>>>>
91590>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91590>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91592>>>>>>>        Boolean bIsSame
91592>>>>>>>
91592>>>>>>>        Move True to bIsSame
91593>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91595>>>>>>>            Function_Return False
91596>>>>>>>        End
91596>>>>>>>>
91596>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91598>>>>>>>            Function_Return False
91599>>>>>>>        End
91599>>>>>>>>
91599>>>>>>>
91599>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91599>>>>>>>
91599>>>>>>>        Function_Return bIsSame
91600>>>>>>>    End_Function
91601>>>>>>>
91601>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91601>>>>>>>    // already exists.
91601>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91603>>>>>>>        Boolean bOK
91603>>>>>>>        Integer iSizeTo iSize iCount iColumn
91603>>>>>>>        String sDriverID
91603>>>>>>>
91603>>>>>>>        Move True to bOK
91604>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91605>>>>>>>        If (iSizeTo > 0) Begin
91607>>>>>>>            Get AutoConnectionIDLogin to bOK
91608>>>>>>>            Move False to Err
91609>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91611>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91614>>>>>>>            Decrement iSizeTo
91615>>>>>>>
91615>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91615>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91615>>>>>>>            Structure_Start hTable sDriverID
91616>>>>>>>                for iCount from 0 to iSizeTo
91622>>>>>>>>
91622>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91623>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91626>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91629>>>>>>>                Loop
91630>>>>>>>>
91630>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91631>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91633>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91634>>>>>>>        End
91634>>>>>>>>
91634>>>>>>>
91634>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91635>>>>>>>        Decrement iSize
91636>>>>>>>        for iCount from 0 to iSize
91642>>>>>>>>
91642>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91643>>>>>>>        Loop
91644>>>>>>>>
91644>>>>>>>
91644>>>>>>>        Function_Return bOK
91645>>>>>>>    End_Function
91646>>>>>>>
91646>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91648>>>>>>>        tAPIRelation[] APIRelations
91648>>>>>>>        tAPIRelation[] APIRelations
91649>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91649>>>>>>>        Handle hParent
91649>>>>>>>        Boolean bIsOpen
91649>>>>>>>
91649>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91650>>>>>>>        Move 0 to iCount
91651>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91654>>>>>>>        If (bIsOpen = False) Begin
91656>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91657>>>>>>>            Open hTable
91659>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91660>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91663>>>>>>>            If (bIsOpen = False) Begin
91665>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91666>>>>>>>                Move True to APIRelations[0].bError
91667>>>>>>>                Function_Return APIRelations
91668>>>>>>>            End
91668>>>>>>>>
91668>>>>>>>        End
91668>>>>>>>>
91668>>>>>>>
91668>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91671>>>>>>>        For iColumn from 1 to iNumColumns
91677>>>>>>>>
91677>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91680>>>>>>>            If (hParent <> 0) Begin
91682>>>>>>>                Open hParent
91684>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91685>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91688>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91689>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91692>>>>>>>
91692>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91693>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91696>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91699>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91700>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91703>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91704>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91705>>>>>>>                Move False                                              to APIRelations[iCount].bError
91706>>>>>>>                Close hParent
91707>>>>>>>                Increment iCount
91708>>>>>>>            End
91708>>>>>>>>
91708>>>>>>>        Loop
91709>>>>>>>>
91709>>>>>>>
91709>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91710>>>>>>>        Function_Return APIRelations
91711>>>>>>>    End_Function
91712>>>>>>>
91712>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO relation arrays.
91712>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91712>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91714>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91714>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91715>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91715>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91716>>>>>>>        tAPIRelationCompare   APIRelationCompare
91716>>>>>>>        tAPIRelationCompare   APIRelationCompare
91716>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91716>>>>>>>
91716>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91717>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91718>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91720>>>>>>>            Function_Return aAPIRelationCompare
91721>>>>>>>        End
91721>>>>>>>>
91721>>>>>>>
91721>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91722>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91723>>>>>>>
91723>>>>>>>        Decrement iSizeFrom
91724>>>>>>>        for iCount from 0 to iSizeFrom
91730>>>>>>>>
91730>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91731>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91732>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91733>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91734>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91735>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91736>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91737>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91738>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91739>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91740>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91741>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91742>>>>>>>        Loop
91743>>>>>>>>
91743>>>>>>>
91743>>>>>>>        Decrement iSizeTo
91744>>>>>>>        for iCount from 0 to iSizeTo
91750>>>>>>>>
91750>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91751>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91752>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91753>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91754>>>>>>>
91754>>>>>>>            // Search if the relation already exists in the array; else add it.
91754>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91755>>>>>>>            If (iItem = -1) Begin
91757>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91758>>>>>>>            End
91758>>>>>>>>
91758>>>>>>>
91758>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91759>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91760>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91761>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91762>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91763>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91764>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91765>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91766>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91767>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91768>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91769>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91770>>>>>>>        Loop
91771>>>>>>>>
91771>>>>>>>
91771>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91772>>>>>>>
91772>>>>>>>        Function_Return aAPIRelationCompare
91773>>>>>>>    End_Function
91774>>>>>>>
91774>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91774>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91776>>>>>>>        Function_Return False
91777>>>>>>>    End_Function
91778>>>>>>>
91778>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91778>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91778>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91778>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91780>>>>>>>        Boolean bFound
91780>>>>>>>
91780>>>>>>>        Move False to Err
91781>>>>>>>        Open CodeMast
91783>>>>>>>        Open CodeType
91785>>>>>>>
91785>>>>>>>        If (bCodeType = True) Begin
91787>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91788>>>>>>>            Clear CodeType
91789>>>>>>>            Move sTypeValue to CODETYPE.Type
91790>>>>>>>            Find eq CODETYPE by 1
91791>>>>>>>>
91791>>>>>>>            Move Found to bFound
91792>>>>>>>            If (bFound = True) Begin
91794>>>>>>>                Reread CodeType
91798>>>>>>>            End
91798>>>>>>>>
91798>>>>>>>            Else Begin
91799>>>>>>>                Clear CodeType
91800>>>>>>>            End
91800>>>>>>>>
91800>>>>>>>
91800>>>>>>>            Move sTypeValue to CODETYPE.Type
91801>>>>>>>            Move sValue2    to CODETYPE.Description
91802>>>>>>>            Move sValue3    to CODETYPE.Comment
91803>>>>>>>            SaveRecord CODETYPE
91804>>>>>>>
91804>>>>>>>            If (bFound = True) Begin
91806>>>>>>>                Unlock
91807>>>>>>>>
91807>>>>>>>            End
91807>>>>>>>>
91807>>>>>>>        End
91807>>>>>>>>
91807>>>>>>>
91807>>>>>>>        If (bCodeType = False) Begin
91809>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91810>>>>>>>            Clear CODEMAST
91811>>>>>>>            Move sTypeValue to CODEMAST.Type
91812>>>>>>>            Move sValue2    to CODEMAST.Code
91813>>>>>>>            Find eq CODEMAST by 1
91814>>>>>>>>
91814>>>>>>>            Move Found to bFound
91815>>>>>>>            If (bFound = True) Begin
91817>>>>>>>                Reread CODEMAST
91821>>>>>>>            End
91821>>>>>>>>
91821>>>>>>>            Else Begin
91822>>>>>>>                Clear CODEMAST
91823>>>>>>>            End
91823>>>>>>>>
91823>>>>>>>
91823>>>>>>>            Move sTypeValue to CODEMAST.Type
91824>>>>>>>            Move sValue2    to CODEMAST.Code
91825>>>>>>>            Move sValue3    to CODEMAST.Description
91826>>>>>>>            SaveRecord CODEMAST
91827>>>>>>>
91827>>>>>>>            If (bFound = True) Begin
91829>>>>>>>                Unlock
91830>>>>>>>>
91830>>>>>>>            End
91830>>>>>>>>
91830>>>>>>>        End
91830>>>>>>>>
91830>>>>>>>
91830>>>>>>>        Close CodeMast
91831>>>>>>>        Close CodeType
91832>>>>>>>
91832>>>>>>>        Function_Return (Err = False)
91833>>>>>>>    End_Function
91834>>>>>>>
91834>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91834>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91834>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91836>>>>>>>        Boolean bFound
91836>>>>>>>
91836>>>>>>>        Move False to Err
91837>>>>>>>        Open CodeMast
91839>>>>>>>        Open CodeType
91841>>>>>>>
91841>>>>>>>        Clear CodeType
91842>>>>>>>        Move sFromValue to CODETYPE.Type
91843>>>>>>>        Find eq CODETYPE.Type
91844>>>>>>>>
91844>>>>>>>        If (Found = True) Begin
91846>>>>>>>            Reread CODETYPE
91850>>>>>>>                Move sToValue to CODETYPE.Type
91851>>>>>>>                SaveRecord CODETYPE
91852>>>>>>>            Unlock
91853>>>>>>>>
91853>>>>>>>        End
91853>>>>>>>>
91853>>>>>>>
91853>>>>>>>        Clear CODEMAST
91854>>>>>>>        Find gt CODEMAST by Recnum
91855>>>>>>>>
91855>>>>>>>        While (Found = True)
91859>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91860>>>>>>>            If (bFound = True) Begin
91862>>>>>>>                Reread CODEMAST
91866>>>>>>>                    Move sToValue to CODEMAST.Type
91867>>>>>>>                    SaveRecord CODEMAST
91868>>>>>>>                Unlock
91869>>>>>>>>
91869>>>>>>>            End
91869>>>>>>>>
91869>>>>>>>            Find gt CODEMAST by Recnum
91870>>>>>>>>
91870>>>>>>>        Loop
91871>>>>>>>>
91871>>>>>>>
91871>>>>>>>        Close CodeMast
91872>>>>>>>        Close CodeType
91873>>>>>>>
91873>>>>>>>        Function_Return (Err = False)
91874>>>>>>>    End_Function
91875>>>>>>>
91875>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91875>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91877>>>>>>>        Boolean bFound
91877>>>>>>>
91877>>>>>>>        Move False to Err
91878>>>>>>>        Open CodeMast
91880>>>>>>>
91880>>>>>>>        Clear CODEMAST
91881>>>>>>>        Move sTypeValue to CODEMAST.Type
91882>>>>>>>        Move sValue2    to CODEMAST.Code
91883>>>>>>>        Find eq CODEMAST.Code
91884>>>>>>>>
91884>>>>>>>        Move Found to bFound
91885>>>>>>>        If (bFound = True) Begin
91887>>>>>>>            Delete CODEMAST
91888>>>>>>>        End
91888>>>>>>>>
91888>>>>>>>
91888>>>>>>>        Close CodeMast
91889>>>>>>>
91889>>>>>>>        Function_Return (Err = False)
91890>>>>>>>    End_Function
91891>>>>>>>
91891>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91893>>>>>>>        Boolean bRecnum bToAnsi
91893>>>>>>>        Integer iCh
91893>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91893>>>>>>>
91893>>>>>>>        If (Trim(sDataPath) = "") Begin
91895>>>>>>>            Function_Return False
91896>>>>>>>        End
91896>>>>>>>>
91896>>>>>>>
91896>>>>>>>        Move False to Err
91897>>>>>>>        Get psDriverID     to sDriverID
91898>>>>>>>        Get psConnectionID to sConnectionID
91899>>>>>>>        Get psSchema       to sSchemaName
91900>>>>>>>        Get True           to bRecnum
91901>>>>>>>        Get pbToANSI       to bToAnsi
91902>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91903>>>>>>>        If (bToAnsi = False) Begin
91905>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91906>>>>>>>        End
91906>>>>>>>>
91906>>>>>>>
91906>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91907>>>>>>>        Move "CodeMast.int"         to sFileName
91908>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91909>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91912>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91915>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91918>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91921>>>>>>>            Writeln channel iCh ("")
91924>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91927>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91930>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91933>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91936>>>>>>>            Writeln channel iCh ("")
91939>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91942>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91945>>>>>>>            Writeln channel iCh ("")
91948>>>>>>>        Send Seq_Close_Channel iCh
91949>>>>>>>
91949>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91950>>>>>>>        Move "CodeType.int"         to sFileName
91951>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91952>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91955>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91958>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91961>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91964>>>>>>>            Writeln channel iCh ("")
91967>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91970>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91973>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91976>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91979>>>>>>>            Writeln channel iCh ("")
91982>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91985>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91988>>>>>>>            Writeln channel iCh ("")
91991>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91994>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91997>>>>>>>            Writeln channel iCh ("")
92000>>>>>>>        Send Seq_Close_Channel iCh
92001>>>>>>>
92001>>>>>>>        Function_Return (Err = False)
92002>>>>>>>    End_Function
92003>>>>>>>
92003>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92003>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
92005>>>>>>>        Function_Return False
92006>>>>>>>    End_Function
92007>>>>>>>
92007>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
92007>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
92007>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
92009>>>>>>>        Boolean bOK bExists
92009>>>>>>>        String sDataPath sBackupFolder
92009>>>>>>>
92009>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
92010>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
92011>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92012>>>>>>>        Get vFolderFormat sDataPath to sDataPath
92013>>>>>>>
92013>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92014>>>>>>>        If (bExists = False) Begin
92016>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92017>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92018>>>>>>>            If (bExists = False) Begin
92020>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
92021>>>>>>>>
92021>>>>>>>                Function_Return False
92022>>>>>>>            End
92022>>>>>>>>
92022>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
92023>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
92024>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
92025>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
92026>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
92027>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
92028>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
92029>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
92030>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
92031>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
92032>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
92033>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
92034>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
92035>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
92036>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
92037>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
92038>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
92039>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
92040>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
92041>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
92042>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
92043>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
92044>>>>>>>        End
92044>>>>>>>>
92044>>>>>>>
92044>>>>>>>        Set Message_Text of ghoStatusPanel to ""
92045>>>>>>>        Function_Return True
92046>>>>>>>    End_Function
92047>>>>>>>    
92047>>>>>>>    // Check if the file exists in the Data folder,
92047>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
92047>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
92049>>>>>>>        String sPath
92049>>>>>>>        Boolean bExists
92049>>>>>>>
92049>>>>>>>        Get psDataPathFirstPart to sPath
92050>>>>>>>        Move (sPath + sFileName) to sFileName
92051>>>>>>>        Get vFilePathExists sFileName to bExists
92052>>>>>>>
92052>>>>>>>        If (bExists = False) Begin
92054>>>>>>>            // Read from memory & create file on disk.
92054>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
92055>>>>>>>            Get vFilePathExists sFileName to bExists
92056>>>>>>>        End
92056>>>>>>>>
92056>>>>>>>        Function_Return bExists
92057>>>>>>>    End_Function
92058>>>>>>>
92058>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
92060>>>>>>>        tColumnType RetvalType
92060>>>>>>>        tColumnType RetvalType
92060>>>>>>>        Integer iRetval
92060>>>>>>>
92060>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
92061>>>>>>>        Move RetvalType.iDataFlexType to iRetval
92062>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
92064>>>>>>>            If (iLength <= 255) Begin
92066>>>>>>>                Move DF_ASCII to iRetval
92067>>>>>>>            End
92067>>>>>>>>
92067>>>>>>>        End
92067>>>>>>>>
92067>>>>>>>        Function_Return iRetval
92068>>>>>>>    End_Function
92069>>>>>>>             
92069>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
92071>>>>>>>        String sRetval
92071>>>>>>>
92071>>>>>>>        Case Begin
92071>>>>>>>            Case (iDataType = DF_ASCII)
92073>>>>>>>                Move "DF_ASCII" to sRetval
92074>>>>>>>                Case Break
92075>>>>>>>            Case (iDataType = DF_BCD)
92078>>>>>>>                Move "DF_BCD" to sRetval
92079>>>>>>>                Case Break
92080>>>>>>>            Case (iDataType = DF_BINARY)
92083>>>>>>>                Move "DF_BINARY" to sRetval
92084>>>>>>>                Case Break
92085>>>>>>>            Case (iDataType = DF_DATE)
92088>>>>>>>                Move "DF_DATE" to sRetval
92089>>>>>>>                Case Break
92090>>>>>>>            Case (iDataType = DF_DATETIME)
92093>>>>>>>                Move "DF_DATETIME" to sRetval
92094>>>>>>>                Case Break
92095>>>>>>>            Case (iDataType = DF_TEXT)
92098>>>>>>>                Move "DF_TEXT" to sRetval
92099>>>>>>>                Case Break
92100>>>>>>>            Case Else
92100>>>>>>>                Move "" to sRetval
92101>>>>>>>        Case End
92101>>>>>>>
92101>>>>>>>        Function_Return sRetval
92102>>>>>>>    End_Function
92103>>>>>>>
92103>>>>>>>    // The default value used for a datatype as specified in the driver int file.
92103>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
92105>>>>>>>        String sRetval sServer
92105>>>>>>>        tColumnType RetvalType
92105>>>>>>>        tColumnType RetvalType
92105>>>>>>>        Integer iDriver iDataFlexType
92105>>>>>>>        Handle hDatabase
92105>>>>>>>
92105>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
92106>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
92107>>>>>>>        Get DriverIndex sDriverID to iDriver
92108>>>>>>>        Get psServer to sServer
92109>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92110>>>>>>>        If (hDatabase = 0) Begin
92112>>>>>>>            Function_Return ""
92113>>>>>>>        End
92113>>>>>>>>
92113>>>>>>>
92113>>>>>>>        Case Begin
92113>>>>>>>            Case (iDataFlexType = DF_ASCII)
92115>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
92118>>>>>>>                Case Break
92119>>>>>>>            Case (iDataFlexType = DF_BCD)
92122>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
92125>>>>>>>                Case Break
92126>>>>>>>            Case (iDataFlexType = DF_BINARY)
92129>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
92132>>>>>>>                Case Break
92133>>>>>>>            Case (iDataFlexType = DF_DATE)
92136>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
92139>>>>>>>                Case Break
92140>>>>>>>            Case (iDataFlexType = DF_DATETIME)
92143>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
92146>>>>>>>                Case Break
92147>>>>>>>            Case (iDataFlexType = DF_TEXT)
92150>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
92153>>>>>>>                Case Break
92154>>>>>>>            Case Else
92154>>>>>>>                Move "" to sRetval
92155>>>>>>>        Case End
92155>>>>>>>
92155>>>>>>>        Function_Return sRetval
92156>>>>>>>    End_Function
92157>>>>>>>
92157>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
92159>>>>>>>        String sDriverID sServer
92159>>>>>>>        tColumnType RetvalType
92159>>>>>>>        tColumnType RetvalType
92159>>>>>>>        Integer iDbType iDriver
92159>>>>>>>        Handle hDatabase
92159>>>>>>>
92159>>>>>>>        Get psDriverID to sDriverID
92160>>>>>>>        Get piDbType   to iDbType
92161>>>>>>>        Get DriverIndex sDriverID to iDriver
92162>>>>>>>        Get psServer to sServer
92163>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92164>>>>>>>        If (hDatabase = 0) Begin
92166>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
92167>>>>>>>>
92167>>>>>>>            Procedure_Return
92168>>>>>>>        End
92168>>>>>>>>
92168>>>>>>>
92168>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
92171>>>>>>>
92171>>>>>>>    End_Procedure
92172>>>>>>>
92172>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
92174>>>>>>>        String sDriverID sServer
92174>>>>>>>        tColumnType RetvalType
92174>>>>>>>        tColumnType RetvalType
92174>>>>>>>        Integer iDbType iDriver
92174>>>>>>>        Handle hDatabase
92174>>>>>>>
92174>>>>>>>        Get psDriverID to sDriverID
92175>>>>>>>        Get piDbType   to iDbType
92176>>>>>>>        Get DriverIndex sDriverID to iDriver
92177>>>>>>>        Get psServer to sServer
92178>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92179>>>>>>>        If (hDatabase = 0) Begin
92181>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
92182>>>>>>>>
92182>>>>>>>            Procedure_Return
92183>>>>>>>        End
92183>>>>>>>>
92183>>>>>>>
92183>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
92186>>>>>>>
92186>>>>>>>    End_Procedure
92187>>>>>>>
92187>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
92187>>>>>>>    // are mapped to the standard DataFlex data types.
92187>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
92187>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
92189>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92189>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92191>>>>>>>        String sDataType
92191>>>>>>>        Integer iDataType iDriverID iCount
92191>>>>>>>        Boolean bSQLDriver
92191>>>>>>>
92191>>>>>>>        Move 0 to iCount
92192>>>>>>>        Get DriverIndex sDriverID to iDriverID
92193>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92194>>>>>>>        If (bSQLDriver = False) Begin
92196>>>>>>>            Function_Return EmptyArray
92197>>>>>>>        End
92197>>>>>>>>
92197>>>>>>>
92197>>>>>>>        // DF_ASCII
92197>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92199>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92202>>>>>>>        End
92202>>>>>>>>
92202>>>>>>>        Else Begin
92203>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92206>>>>>>>        End
92206>>>>>>>>
92206>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92207>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
92208>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
92209>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92210>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92211>>>>>>>        Increment iCount
92212>>>>>>>
92212>>>>>>>        // DF_BINARY
92212>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92214>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92217>>>>>>>        End
92217>>>>>>>>
92217>>>>>>>        Else Begin
92218>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92221>>>>>>>        End
92221>>>>>>>>
92221>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92222>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92223>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92224>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92225>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92226>>>>>>>        Increment iCount
92227>>>>>>>
92227>>>>>>>        // DF_DATE
92227>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92229>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92232>>>>>>>        End
92232>>>>>>>>
92232>>>>>>>        Else Begin
92233>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92236>>>>>>>        End
92236>>>>>>>>
92236>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92237>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92238>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92239>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92240>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92241>>>>>>>        Increment iCount
92242>>>>>>>
92242>>>>>>>        // DF_DATETIME
92242>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92244>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92247>>>>>>>        End
92247>>>>>>>>
92247>>>>>>>        Else Begin
92248>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92251>>>>>>>        End
92251>>>>>>>>
92251>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92252>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92253>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92254>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92255>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92256>>>>>>>        Increment iCount
92257>>>>>>>
92257>>>>>>>        // DF_NUMERIC
92257>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92257>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92257>>>>>>>        // we make them here all "Numeric"...
92257>>>>>>>        Case Begin
92257>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92259>>>>>>>                Move SQL_NUMERIC to iDataType
92260>>>>>>>                Move "numeric"   to sDataType
92261>>>>>>>                Case Break
92262>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92265>>>>>>>                Move SQL_NUMERIC to iDataType
92266>>>>>>>                Move "NUMERIC"   to sDataType
92267>>>>>>>                Case Break
92268>>>>>>>            Case Else
92268>>>>>>>                Move DF_BCD      to iDataType
92269>>>>>>>                Move "Numeric"   to sDataType
92270>>>>>>>        Case End
92270>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92271>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92272>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92273>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92274>>>>>>>        Increment iCount
92275>>>>>>>
92275>>>>>>>        // DF_TEXT
92275>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92277>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92280>>>>>>>        End
92280>>>>>>>>
92280>>>>>>>        Else Begin
92281>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92284>>>>>>>        End
92284>>>>>>>>
92284>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92285>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92286>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92287>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92288>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92289>>>>>>>
92289>>>>>>>        Function_Return ColumnTypeArray
92290>>>>>>>    End_Function
92291>>>>>>>
92291>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92293>>>>>>>        tColumnType[] ColumnTypeArray
92293>>>>>>>        tColumnType[] ColumnTypeArray
92294>>>>>>>        tColumnType   ColumnType
92294>>>>>>>        tColumnType   ColumnType
92294>>>>>>>        Integer iCount iSize
92294>>>>>>>
92294>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92295>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92296>>>>>>>        Decrement iSize
92297>>>>>>>
92297>>>>>>>        for iCount from 0 to iSize
92303>>>>>>>>
92303>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92305>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92306>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92307>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92308>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92309>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92310>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92311>>>>>>>                Move iSize to iCount
92312>>>>>>>            End
92312>>>>>>>>
92312>>>>>>>        Loop
92313>>>>>>>>
92313>>>>>>>
92313>>>>>>>        Function_Return ColumnType
92314>>>>>>>    End_Function
92315>>>>>>>
92315>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92315>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92315>>>>>>>    // but the Logical name is different.
92315>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92315>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92317>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
92317>>>>>>>        Handle hInTable hMasterTable 
92317>>>>>>>        Boolean bIsAlias
92317>>>>>>>        
92317>>>>>>>        Move hTable to hInTable
92318>>>>>>>        Move False to bIsAlias
92319>>>>>>>        Move 0 to hMasterTable
92320>>>>>>>        
92320>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92323>>>>>>>        // Remove any prefix with a driver name.
92323>>>>>>>        Get _TableNameOnly sRootName to sRootName     
92324>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92327>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
92328>>>>>>>        
92328>>>>>>>        // If the table has the same root and logical name it can't be an alias,
92328>>>>>>>        // so we can safely return a "False".
92328>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
92330>>>>>>>            Function_Return True
92331>>>>>>>        End
92331>>>>>>>>
92331>>>>>>>        
92331>>>>>>>        Function_Return False
92332>>>>>>>        
92332>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
92332>>>>>>>        // as the passed hTable root name.
92332>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
92332>>>>>>>//        Move 0 to hTable
92332>>>>>>>//        Repeat
92332>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92332>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92332>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
92332>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
92332>>>>>>>//                // If we found another table with the same root and logical name
92332>>>>>>>//                // we have found a master table.
92332>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
92332>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
92332>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
92332>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
92332>>>>>>>//                        Move hTable to hMasterTable   
92332>>>>>>>//                        Move 0 to hTable // To end the loop.
92332>>>>>>>//                    End
92332>>>>>>>//                End
92332>>>>>>>//            End
92332>>>>>>>//        Until (hTable = 0)
92332>>>>>>>//        
92332>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
92332>>>>>>>//            Move True to bIsAlias
92332>>>>>>>//        End
92332>>>>>>>//        
92332>>>>>>>//        Function_Return bIsAlias
92332>>>>>>>    End_Function
92333>>>>>>>
92333>>>>>>>    // To Open a table with any driver.
92333>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92333>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92333>>>>>>>    //
92333>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92333>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92333>>>>>>>    // returns a True if successful (table could be opened).
92333>>>>>>>    //
92333>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92333>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92333>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92333>>>>>>>    // set properly we can open the table.
92333>>>>>>>    //
92333>>>>>>>    // DAW Driver Syntax:
92333>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92333>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92333>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92333>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92333>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92333>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92333>>>>>>>    //
92333>>>>>>>    // DAW Driver Sample:
92333>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92333>>>>>>>    //
92333>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92335>>>>>>>        String sTableNameOrg
92335>>>>>>>        Boolean bOpen bOK
92335>>>>>>>        tSQLConnection SQLConnection
92335>>>>>>>        tSQLConnection SQLConnection
92335>>>>>>>        
92335>>>>>>>        Move False to bOpen
92336>>>>>>>        Move sTableName to sTableNameOrg
92337>>>>>>>        If (hTable > 0) Begin
92339>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92340>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92341>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92342>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92343>>>>>>>            Open hTable Mode iMode
92345>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92346>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92347>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92348>>>>>>>            Send Trap_Error of Error_Object_Id 10
92349>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92352>>>>>>>            If (bOpen = True) Begin
92354>>>>>>>                Function_Return True
92355>>>>>>>            End
92355>>>>>>>>
92355>>>>>>>        End
92355>>>>>>>>
92355>>>>>>>
92355>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92356>>>>>>>        If (hTable > 0) Begin
92358>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92361>>>>>>>        End
92361>>>>>>>>
92361>>>>>>>
92361>>>>>>>        Function_Return bOpen
92362>>>>>>>    End_Function
92363>>>>>>>
92363>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92365>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92365>>>>>>>        Boolean bOpen bOK
92365>>>>>>>        tSQLConnection SQLConnection
92365>>>>>>>        tSQLConnection SQLConnection
92365>>>>>>>
92365>>>>>>>        If (hTable < 1) Begin
92367>>>>>>>            Function_Return False
92368>>>>>>>        End
92368>>>>>>>>
92368>>>>>>>
92368>>>>>>>        Move sTableName to sTableNameOrg
92369>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92370>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92371>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92372>>>>>>>        Move SQLConnection.sSchema to sSchema
92373>>>>>>>        If (sSchema = "") Begin
92375>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92376>>>>>>>        End
92376>>>>>>>>
92376>>>>>>>
92376>>>>>>>        // We need to remove the ".int" part of the table name because
92376>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92376>>>>>>>        // "bare" table name without any extension.
92376>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92378>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92380>>>>>>>                Get ParseFileExtension sTableName to sExt
92381>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92382>>>>>>>            End
92382>>>>>>>>
92382>>>>>>>            Else Begin
92383>>>>>>>                Move sTableName to sTableNameShort
92384>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92385>>>>>>>            End
92385>>>>>>>>
92385>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92386>>>>>>>            Move sConnection to sTableName
92387>>>>>>>        End
92387>>>>>>>>
92387>>>>>>>
92387>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92388>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92389>>>>>>>        If (hTable = 0) Begin
92391>>>>>>>            Get NextFreeFilelistSlot to hTable
92392>>>>>>>        End
92392>>>>>>>>
92392>>>>>>>
92392>>>>>>>        Case Begin
92392>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92394>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92394>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92396>>>>>>>                    Close hTable
92397>>>>>>>                    Open sTableName as hTable
92399>>>>>>>                End
92399>>>>>>>>
92399>>>>>>>                Else Begin
92400>>>>>>>                    Get OpenTableExclusive hTable to bOK
92401>>>>>>>                    If (bOK = False) Begin
92403>>>>>>>                        Function_Return False
92404>>>>>>>                    End
92404>>>>>>>>
92404>>>>>>>                End
92404>>>>>>>>
92404>>>>>>>                Case Break
92405>>>>>>>
92405>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92408>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92408>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92410>>>>>>>                    Close hTable
92411>>>>>>>                    Open sTableName as hTable
92413>>>>>>>                End
92413>>>>>>>>
92413>>>>>>>                Else Begin
92414>>>>>>>                    Get OpenTableExclusive hTable to bOK
92415>>>>>>>                    If (bOK = False) Begin
92417>>>>>>>                        Function_Return False
92418>>>>>>>                    End
92418>>>>>>>>
92418>>>>>>>                End
92418>>>>>>>>
92418>>>>>>>                Case Break
92419>>>>>>>
92419>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92422>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92422>>>>>>>                If (iMode = DF_SHARE) Begin
92424>>>>>>>                    Close hTable
92425>>>>>>>                    Open sTableName as hTable
92427>>>>>>>                End
92427>>>>>>>>
92427>>>>>>>                Else Begin
92428>>>>>>>                    Get OpenTableExclusive hTable to bOK
92429>>>>>>>                    If (bOK = False) Begin
92431>>>>>>>                        Function_Return False
92432>>>>>>>                    End
92432>>>>>>>>
92432>>>>>>>                End
92432>>>>>>>>
92432>>>>>>>                Case Break
92433>>>>>>>
92433>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92436>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92438>>>>>>>                    Close hTable
92439>>>>>>>                    Open sTableName as hTable
92441>>>>>>>                End
92441>>>>>>>>
92441>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92444>>>>>>>                    Get OpenTableExclusive hTable to bOK
92445>>>>>>>                    If (bOK = False) Begin
92447>>>>>>>                        Function_Return False
92448>>>>>>>                    End
92448>>>>>>>>
92448>>>>>>>                End
92448>>>>>>>>
92448>>>>>>>                Else Begin
92449>>>>>>>                    Open hTable
92451>>>>>>>                End
92451>>>>>>>>
92451>>>>>>>                Case Break
92452>>>>>>>
92452>>>>>>>            Case Else
92452>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92453>>>>>>>>
92453>>>>>>>        Case End
92453>>>>>>>
92453>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92454>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92455>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92457>>>>>>>            Move False to Found
92458>>>>>>>        End
92458>>>>>>>>
92458>>>>>>>        // If open failed, the Err is set to true,
92458>>>>>>>        // but we don't want that because it could end our loop.
92458>>>>>>>        Move False to Err
92459>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92462>>>>>>>
92462>>>>>>>        Function_Return bOpen
92463>>>>>>>    End_Function
92464>>>>>>>
92464>>>>>>>    // Pass a table's logical name
92464>>>>>>>    // Returns True if the table exists in filelist.cfg.
92464>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92466>>>>>>>        Handle hTable
92466>>>>>>>        Boolean bFound
92466>>>>>>>        String sCompareTable
92466>>>>>>>
92466>>>>>>>        Move False to bFound
92467>>>>>>>        Move 0 to hTable
92468>>>>>>>        Repeat
92468>>>>>>>>
92468>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92471>>>>>>>            If (hTable > 0) Begin
92473>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92476>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92478>>>>>>>                    Move True to bFound
92479>>>>>>>                End
92479>>>>>>>>
92479>>>>>>>            End
92479>>>>>>>>
92479>>>>>>>            If (bFound = True) ;                Break
92482>>>>>>>        Until (hTable = 0)
92484>>>>>>>
92484>>>>>>>        Function_Return (bFound = True)
92485>>>>>>>    End_Function
92486>>>>>>>
92486>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92486>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92488>>>>>>>        Boolean bOK bExists
92488>>>>>>>        String sDriverID
92488>>>>>>>
92488>>>>>>>        Get _UtilTableExists hTable to bExists
92489>>>>>>>        If (bExists = False) Begin
92491>>>>>>>            Function_Return DATAFLEX_ID
92492>>>>>>>        End
92492>>>>>>>>
92492>>>>>>>        Get OpenTableExclusive hTable to bOK
92493>>>>>>>        If (bOK = False) Begin
92495>>>>>>>            Function_Return DATAFLEX_ID
92496>>>>>>>        End
92496>>>>>>>>
92496>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92499>>>>>>>        Function_Return sDriverID
92500>>>>>>>    End_Function
92501>>>>>>>
92501>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92501>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92503>>>>>>>        Handle hTable
92503>>>>>>>        Integer iRetval
92503>>>>>>>
92503>>>>>>>        Move 0 to hTable
92504>>>>>>>        Move 0 to iRetval
92505>>>>>>>
92505>>>>>>>        Repeat
92505>>>>>>>>
92505>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92508>>>>>>>            If (hTable > 0) Begin
92510>>>>>>>                Increment iRetval
92511>>>>>>>            End
92511>>>>>>>>
92511>>>>>>>        Until (hTable = 0)
92513>>>>>>>
92513>>>>>>>        Function_Return iRetval
92514>>>>>>>    End_Function
92515>>>>>>>
92515>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92515>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92517>>>>>>>        Handle hTable
92517>>>>>>>        String sRoot sDriverID
92517>>>>>>>        Boolean bIsSQLTable
92517>>>>>>>        Integer iPos
92517>>>>>>>
92517>>>>>>>        Move 0 to hTable
92518>>>>>>>        Move "" to sDriverID
92519>>>>>>>        Move False to bIsSQLTable
92520>>>>>>>
92520>>>>>>>        Repeat
92520>>>>>>>>
92520>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92523>>>>>>>            If (hTable > 0) Begin
92525>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92528>>>>>>>                If (sRoot contains ":") Begin
92530>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92531>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92532>>>>>>>                End
92532>>>>>>>>
92532>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92533>>>>>>>            End
92533>>>>>>>>
92533>>>>>>>
92533>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92535>>>>>>>
92535>>>>>>>        Function_Return sDriverID
92536>>>>>>>    End_Function
92537>>>>>>>
92537>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92539>>>>>>>        String sRootName
92539>>>>>>>        Boolean bIsSQL
92539>>>>>>>        Handle hTable
92539>>>>>>>
92539>>>>>>>        Move False to bIsSQL
92540>>>>>>>        Move 0 to hTable
92541>>>>>>>        Repeat
92541>>>>>>>>
92541>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92544>>>>>>>            If (hTable > 0) Begin
92546>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92549>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92550>>>>>>>                If (bIsSQL = True) Begin
92552>>>>>>>                    Move 0 to hTable
92553>>>>>>>                End
92553>>>>>>>>
92553>>>>>>>            End
92553>>>>>>>>
92553>>>>>>>        Until (hTable = 0)
92555>>>>>>>
92555>>>>>>>        Function_Return (bIsSQL = False)
92556>>>>>>>    End_Function
92557>>>>>>>
92557>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92557>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92559>>>>>>>        Function_Return False
92560>>>>>>>    End_Function
92561>>>>>>>
92561>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92563>>>>>>>        String  sRetval
92563>>>>>>>        String[] sOverlapFieldsArray
92564>>>>>>>        Integer iType iColumn iColumns
92564>>>>>>>        Boolean bOpen bOverlap
92564>>>>>>>
92564>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92567>>>>>>>        If (bOpen = False) Begin
92569>>>>>>>            Open hTable
92571>>>>>>>        End
92571>>>>>>>>
92571>>>>>>>
92571>>>>>>>        Move "" to sRetval
92572>>>>>>>
92572>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92575>>>>>>>
92575>>>>>>>        for iColumn from 0 to iColumns
92581>>>>>>>>
92581>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92584>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92586>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92589>>>>>>>                If (bOverlap) Begin
92591>>>>>>>                    If (sRetval <> "") Begin
92593>>>>>>>                        Append sRetval ","
92594>>>>>>>                    End
92594>>>>>>>>
92594>>>>>>>                    Append sRetval iColumn
92595>>>>>>>                End
92595>>>>>>>>
92595>>>>>>>            End
92595>>>>>>>>
92595>>>>>>>        Loop
92596>>>>>>>>
92596>>>>>>>
92596>>>>>>>        If (bOpen = False) Begin
92598>>>>>>>            Close hTable
92599>>>>>>>        End
92599>>>>>>>>
92599>>>>>>>
92599>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92600>>>>>>>
92600>>>>>>>        Function_Return sOverlapFieldsArray
92601>>>>>>>    End_Function
92602>>>>>>>
92602>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92604>>>>>>>        Handle hoRegistry hoODBCDriverNames
92604>>>>>>>        Boolean bExists bKeyOpened
92604>>>>>>>        String sKey
92604>>>>>>>        String[] sDrivers
92605>>>>>>>        Integer iDriverNames iDriverName
92605>>>>>>>
92605>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92606>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92607>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92608>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92609>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92610>>>>>>>        If (bExists) Begin
92612>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92613>>>>>>>            If (bKeyOpened) Begin
92615>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92616>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92617>>>>>>>                If (iDriverNames > 0) Begin
92619>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92620>>>>>>>                    Decrement iDriverNames
92621>>>>>>>                    for iDriverName from 0 to iDriverNames
92627>>>>>>>>
92627>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92628>>>>>>>                    Loop
92629>>>>>>>>
92629>>>>>>>                End
92629>>>>>>>>
92629>>>>>>>                Send CloseKey of hoRegistry
92630>>>>>>>            End
92630>>>>>>>>
92630>>>>>>>        End
92630>>>>>>>>
92630>>>>>>>        Send Destroy of hoRegistry
92631>>>>>>>
92631>>>>>>>        Function_Return sDrivers
92632>>>>>>>    End_Function
92633>>>>>>>
92633>>>>>>>    Procedure IncreaseSortBufferSize
92635>>>>>>>        String sNull
92635>>>>>>>        Integer iSortBufferSize
92635>>>>>>>        Boolean bBufferSet
92635>>>>>>>
92635>>>>>>>        Move "" to sNull
92636>>>>>>>        Move (1024 * 128) to iSortBufferSize
92637>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92642>>>>>>>
92642>>>>>>>    End_Procedure
92643>>>>>>>
92643>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92645>>>>>>>        Integer iLastIndex iIndex iNumSegments
92645>>>>>>>        Boolean bOK
92645>>>>>>>        String sDriverID
92645>>>>>>>
92645>>>>>>>        If (hTable > 0) Begin
92647>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92648>>>>>>>            Close hTable
92649>>>>>>>            Get OpenTableExclusive hTable to bOK
92650>>>>>>>            If (bOK = False) Begin
92652>>>>>>>                Procedure_Return
92653>>>>>>>            End
92653>>>>>>>>
92653>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92656>>>>>>>            Structure_Start hTable sDriverID
92657>>>>>>>                for iIndex from 1 to iLastIndex
92663>>>>>>>>
92663>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92666>>>>>>>                    If (iNumSegments > 0) Begin
92668>>>>>>>                        If (bSetToBatch = True) Begin
92670>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92673>>>>>>>                        End
92673>>>>>>>>
92673>>>>>>>                        Else Begin
92674>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92677>>>>>>>                        End
92677>>>>>>>>
92677>>>>>>>                    End
92677>>>>>>>>
92677>>>>>>>                Loop
92678>>>>>>>>
92678>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92680>>>>>>>        End
92680>>>>>>>>
92680>>>>>>>    End_Procedure
92681>>>>>>>
92681>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92683>>>>>>>        Handle hTable
92683>>>>>>>
92683>>>>>>>        Move 0 to hTable
92684>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92687>>>>>>>
92687>>>>>>>        Function_Return hTable
92688>>>>>>>    End_Function
92689>>>>>>>
92689>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92689>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92691>>>>>>>        Integer iCh
92691>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92692>>>>>>>            Write channel iCh sStmt
92694>>>>>>>        Send Seq_Close_Channel iCh
92695>>>>>>>    End_Procedure
92696>>>>>>>
92696>>>>>>>    // Returns the integer number for the passed Driver ID that is
92696>>>>>>>    // needed by some database API calls.
92696>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92698>>>>>>>        String  sCurrentDriver
92698>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92698>>>>>>>
92698>>>>>>>        Move 0 to iDriver
92699>>>>>>>
92699>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92702>>>>>>>        for iCount from 1 to iNumberOfDrivers
92708>>>>>>>>
92708>>>>>>>
92708>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92711>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92713>>>>>>>                Move iCount to iDriver
92714>>>>>>>            End
92714>>>>>>>>
92714>>>>>>>        Loop
92715>>>>>>>>
92715>>>>>>>
92715>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92715>>>>>>>        If (iDriver = 0) Begin
92717>>>>>>>            Move False to Err
92718>>>>>>>            Load_Driver sDriverID
92719>>>>>>>            If (Err = False) Begin
92721>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92724>>>>>>>            End
92724>>>>>>>>
92724>>>>>>>        End
92724>>>>>>>>
92724>>>>>>>
92724>>>>>>>        Function_Return iDriver
92725>>>>>>>    End_Function
92726>>>>>>>
92726>>>>>>>
92726>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92728>>>>>>>        String  sSqlServerClientVersionName
92728>>>>>>>        
92728>>>>>>>        Case Begin
92728>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92730>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92731>>>>>>>                Case Break
92732>>>>>>>
92732>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92735>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92736>>>>>>>                Case Break
92737>>>>>>>                
92737>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92740>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92741>>>>>>>                Case Break
92742>>>>>>>            
92742>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92745>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92746>>>>>>>                Case Break
92747>>>>>>>            
92747>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92750>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92751>>>>>>>                Case Break
92752>>>>>>>            
92752>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92755>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92756>>>>>>>                Case Break
92757>>>>>>>            
92757>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92760>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92761>>>>>>>                Case Break
92762>>>>>>>            
92762>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92765>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92766>>>>>>>                Case Break
92767>>>>>>>            
92767>>>>>>>            Case Else
92767>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92768>>>>>>>        Case End
92768>>>>>>>        
92768>>>>>>>        Function_Return sSqlServerClientVersionName
92769>>>>>>>    End_Function
92770>>>>>>>
92770>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92772>>>>>>>        String  sSqlServerClientDriverName
92772>>>>>>>        
92772>>>>>>>        Case Begin
92772>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92774>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92775>>>>>>>                Case Break
92776>>>>>>>
92776>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92779>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92780>>>>>>>                Case Break
92781>>>>>>>                
92781>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92784>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92785>>>>>>>                Case Break
92786>>>>>>>            
92786>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92789>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92790>>>>>>>                Case Break
92791>>>>>>>            
92791>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92794>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92795>>>>>>>                Case Break
92796>>>>>>>            
92796>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92799>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92800>>>>>>>                Case Break
92801>>>>>>>            
92801>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92804>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92805>>>>>>>                Case Break
92806>>>>>>>            
92806>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92809>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92810>>>>>>>                Case Break
92811>>>>>>>            
92811>>>>>>>            Case Else
92811>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92812>>>>>>>        Case End
92812>>>>>>>        
92812>>>>>>>        Function_Return sSqlServerClientDriverName
92813>>>>>>>    End_Function
92814>>>>>>>    
92814>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92816>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92816>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92816>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92816>>>>>>>        Boolean bOK
92816>>>>>>>        
92816>>>>>>>        Move "" to sRetval
92817>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92818>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92819>>>>>>>        Load_Driver MSSQLDRV_ID
92820>>>>>>>
92820>>>>>>>        // Loop through all loaded drivers.
92820>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92823>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92829>>>>>>>>
92829>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92832>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92834>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92835>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92838>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92839>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92840>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92841>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92842>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92844>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92845>>>>>>>                End                                
92845>>>>>>>>
92845>>>>>>>                Else Begin
92846>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92847>>>>>>>                End
92847>>>>>>>>
92847>>>>>>>            End
92847>>>>>>>>
92847>>>>>>>        Loop
92848>>>>>>>>
92848>>>>>>>        Send Destroy of hoCLIHandler  
92849>>>>>>>        Send Destroy of hoMSSQLHandler  
92850>>>>>>>        If (bShowErrorDialog = True) Begin
92852>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92853>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92855>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92856>>>>>>>                If (bExitProgram = True) Begin
92858>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92859>>>>>>>                End
92859>>>>>>>>
92859>>>>>>>                Send Stop_Box sRetval  
92860>>>>>>>                If (bExitProgram = True) Begin
92862>>>>>>>                    Send Exit_Application
92863>>>>>>>                End
92863>>>>>>>>
92863>>>>>>>            End
92863>>>>>>>>
92863>>>>>>>        End
92863>>>>>>>>
92863>>>>>>>        
92863>>>>>>>        Function_Return sRetval
92864>>>>>>>    End_Function  
92865>>>>>>>    
92865>>>>>>>    // Returns True if first "." separated string is greater than the second.
92865>>>>>>>    // It checks from left to right, one part of the string at a time.
92865>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92865>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92867>>>>>>>        String[] asVersion asSQLVersion          
92869>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92869>>>>>>>        
92869>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92870>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92871>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92872>>>>>>>        // Make sure the two arrays are of the same size:
92872>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92874>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92875>>>>>>>        End
92875>>>>>>>>
92875>>>>>>>        Decrement iSize
92876>>>>>>>        for iCount from 0 to iSize
92882>>>>>>>>
92882>>>>>>>            Move asVersion[iCount]    to iVersion
92883>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92884>>>>>>>            CompilerWarnings Off
92884>>>>>>>            If (iVersion > iSQLVersion) Break
92887>>>>>>>            CompilerWarnings On
92887>>>>>>>        Loop
92888>>>>>>>>
92888>>>>>>>        
92888>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92889>>>>>>>    End_Function
92890>>>>>>>
92890>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92890>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92890>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92890>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92892>>>>>>>        Integer iMode iErrorObject
92892>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92892>>>>>>>        String sTableName 
92892>>>>>>>        Handle hoCurrentErrorHandler
92892>>>>>>>        
92892>>>>>>>        Move False to bExitIfDebuggerActive
92893>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92895>>>>>>>            Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92896>>>>>>>        End
92896>>>>>>>>
92896>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92897>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92897>>>>>>>        // so we generate an error here:
92897>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92899>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92900>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92901>>>>>>>            If (iErrorObject <> 0) Begin
92903>>>>>>>                Move iErrorObject to Error_Object_Id
92904>>>>>>>            End
92904>>>>>>>>
92904>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92905>>>>>>>>
92905>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92906>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92907>>>>>>>            Function_Return False
92908>>>>>>>        End
92908>>>>>>>>
92908>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92911>>>>>>>        If (bOpened) Begin
92913>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92916>>>>>>>            If (iMode = DF_EXCLUSIVE) Begin
92918>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92919>>>>>>>                Function_Return True
92920>>>>>>>            End
92920>>>>>>>>
92920>>>>>>>            Close hTable
92921>>>>>>>        End
92921>>>>>>>>
92921>>>>>>>        Else Begin
92922>>>>>>>            Open hTable
92924>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92927>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92929>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92932>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92934>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92935>>>>>>>                    Function_Return True
92936>>>>>>>                End
92936>>>>>>>>
92936>>>>>>>            End
92936>>>>>>>>
92936>>>>>>>
92936>>>>>>>        End
92936>>>>>>>>
92936>>>>>>>
92936>>>>>>>        Close hTable
92937>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92939>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92942>>>>>>>
92942>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92943>>>>>>>        Function_Return bOpened
92944>>>>>>>    End_Function
92945>>>>>>>
92945>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92947>>>>>>>        String sConnectionID sConnectionString sDriverID
92947>>>>>>>        Boolean bExists bOK bSQLDriver
92947>>>>>>>        Handle hoCLI hoDriver
92947>>>>>>>        Integer iRetval
92947>>>>>>>        tSQLConnection SQLConnection
92947>>>>>>>        tSQLConnection SQLConnection
92947>>>>>>>
92947>>>>>>>        Get psDriverID to sDriverID
92948>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92949>>>>>>>        If (bSQLDriver = False) Begin
92951>>>>>>>            Function_Return True
92952>>>>>>>        End
92952>>>>>>>>
92952>>>>>>>
92952>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92953>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92954>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92955>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92956>>>>>>>
92956>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92957>>>>>>>        If (bExists = False) Begin
92959>>>>>>>            // We always start by deleting the current connection - if any - because the
92959>>>>>>>            // login details my have changed.
92959>>>>>>>            Get phoCLIHandler to hoCLI
92960>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92961>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92962>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92963>>>>>>>            If (bOk = False) Begin
92965>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92966>>>>>>>>
92966>>>>>>>                Function_Return False
92967>>>>>>>            End
92967>>>>>>>>
92967>>>>>>>            Move bOK to bExists
92968>>>>>>>        End
92968>>>>>>>>
92968>>>>>>>
92968>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92969>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92970>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92971>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92972>>>>>>>        Send Destroy of hoDriver
92973>>>>>>>
92973>>>>>>>        Function_Return (bExists = True)
92974>>>>>>>    End_Function
92975>>>>>>>
92975>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92975>>>>>>>    // It does not check Flexerrs, CodeType & CodeMast
92975>>>>>>>    // Returns: True if nobody else is running
92975>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92975>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92975>>>>>>>    //      tables are not locked as DataFlex tables are.
92975>>>>>>>    Function IsDatabaseInUse Returns Boolean
92977>>>>>>>        Handle  hTable
92977>>>>>>>        String  sRootName sDatabase sSchema sDriverID
92977>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92977>>>>>>>        Integer iCount iTables
92977>>>>>>>        String[] asTablesArray asTablesArrayEmpty
92979>>>>>>>        
92979>>>>>>>        Move 0 to iTables
92980>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92981>>>>>>>        Get AutoConnectionIDLogin to bOK
92982>>>>>>>        Get UtilFilelistNoOfTables to iTables
92983>>>>>>>        Set piPosition   of ghoProgressBar to 0
92984>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92985>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92986>>>>>>>        Close DF_ALL
92987>>>>>>>        Move 0 to hTable
92988>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92991>>>>>>>        Move False to bErr
92992>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92993>>>>>>>
92993>>>>>>>        Move True to bOK
92994>>>>>>>        Get psDriverID to sDriverID
92995>>>>>>>        Get psDatabase to sDatabase
92996>>>>>>>        Get psSchema   to sSchema
92997>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
92998>>>>>>>        Set pasSQLDataTables to asTablesArray
92999>>>>>>>        Repeat
92999>>>>>>>>
92999>>>>>>>            Set piPosition of ghoProgressBar to iCount
93000>>>>>>>            Increment iCount
93001>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93004>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
93005>>>>>>>
93005>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
93005>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
93006>>>>>>>            Move False to bOpen
93007>>>>>>>            // _UtilTableExists_Ex is a variant of "_UtilTableExists", but it needs that the pasSQLDataTables
93007>>>>>>>            // property has been set/updated before usage! This makes the loop much faster.
93007>>>>>>>            Get _UtilTableExists_Ex hTable to bExists
93008>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
93008>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
93010>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93011>>>>>>>                Open hTable
93013>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
93016>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93017>>>>>>>                If (bOpen = True) Begin
93019>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
93019>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
93020>>>>>>>                    If (bAlias = False) Begin
93022>>>>>>>                        Close hTable
93023>>>>>>>                        Get OpenTableExclusive hTable to bOpen
93024>>>>>>>                        If (bOpen = False) Begin
93026>>>>>>>                            Move False to bOK
93027>>>>>>>                        End
93027>>>>>>>>
93027>>>>>>>                    End
93027>>>>>>>>
93027>>>>>>>                End
93027>>>>>>>>
93027>>>>>>>            End
93027>>>>>>>>
93027>>>>>>>            Close hTable
93028>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93031>>>>>>>            If (bOK = False) ;                Break
93034>>>>>>>        Until (not(hTable))
93036>>>>>>>
93036>>>>>>>        // Reset the temporary used data tables property to blank:
93036>>>>>>>        Set pasSQLDataTables to asTablesArrayEmpty
93037>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93038>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
93039>>>>>>>        Move False to Err
93040>>>>>>>
93040>>>>>>>        Function_Return bOK
93041>>>>>>>    End_Function
93042>>>>>>>    
93042>>>>>>>    // Returns True if the passed table handle is open.
93042>>>>>>>    Function IsOpen Handle hTable Returns Boolean
93044>>>>>>>        Boolean bIsOpen
93044>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93047>>>>>>>        Function_Return bIsOpen
93048>>>>>>>    End_Function
93049>>>>>>>    
93049>>>>>>>End_Class
93050>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
93050>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
93050>>>>>>>//
93050>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
93050>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
93050>>>>>>>// conjunction with constraint-clauses.
93050>>>>>>>//
93050>>>>>>>// SYNTAX:
93050>>>>>>>//
93050>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
93050>>>>>>>//    <Constraints...>
93050>>>>>>>//    {DO}
93050>>>>>>>//      <loop body>
93050>>>>>>>//  End_For_All
93050>>>>>>>//
93050>>>>>>>// This set of macros implements a constraint-oriented file enumeration
93050>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
93050>>>>>>>//
93050>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
93050>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93050>>>>>>>//   End_For_All
93050>>>>>>>//
93050>>>>>>>// To list only Customers with a Balance greater than their credit limit:
93050>>>>>>>//
93050>>>>>>>//   For_All Customer BY Index.1
93050>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
93050>>>>>>>//     DO
93050>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93050>>>>>>>//   End_For_All
93050>>>>>>>//
93050>>>>>>>// Constraint clauses are:
93050>>>>>>>//
93050>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
93050>>>>>>>//   CONSTRAIN <File> AS <Expression>
93050>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
93050>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
93050>>>>>>>//
93050>>>>>>>// For example, to list all customers with a bad status whose names start
93050>>>>>>>// with "A" and which have not made a payment in thirty days:
93050>>>>>>>//
93050>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
93050>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
93050>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
93050>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
93050>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
93050>>>>>>>//      DO
93050>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93050>>>>>>>//    End_For_All
93050>>>>>>>//
93050>>>>>>>
93050>>>>>>>
93050>>>>>>>//This command starts the loop process body when constraints are used;
93050>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
93050>>>>>>>//command line, and not on a line by itself
93050>>>>>>>//
93050>>>>>>>
93050>>>>>>>//Ends a For_All loop
93050>>>>>>>//
93050>>>>>>>
93050>>>>>>>
93050>>>>>
93050>>>>>
93050>>>>>Class cDbUpdateVersion is a cObject
93051>>>>>
93051>>>>>    Procedure Construct_Object    
93053>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion bUseIntFilesBackup
93053>>>>>        String[] aSQLQueryMessages
93054>>>>>        
93054>>>>>        Forward Send Construct_Object
93056>>>>>
93056>>>>>        // cDbUpdateHandler object event.
93056>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
93058>>>>>        If (bOnCreateExecuted = False) Begin    
93060>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93062>>>>>            If (bUseCustomDbVersion = False) Begin
93064>>>>>                Delegate Send AutoCreateDbVersionTable 
93066>>>>>            End
93066>>>>>>
93066>>>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
93067>>>>>            If (bUseIntFilesBackup = True) Begin
93069>>>>>                Delegate Send AutoCreateIntFilesTable
93071>>>>>            End    
93071>>>>>>
93071>>>>>            Delegate Send OnCreate
93073>>>>>            Delegate Set Private.pbOnCreateExecuted to True
93075>>>>>        End
93075>>>>>>
93075>>>>>
93075>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
93075>>>>>        // event was triggered, thus an actual change of the database was made.
93075>>>>>        Property Boolean pbVersionUpdate False
93076>>>>>
93076>>>>>        // This property must be manually set within each cDbUpdateVersion object
93076>>>>>        // by the programmer, to a consecutive number.
93076>>>>>        Property Number pnVersionNumber
93077>>>>>
93077>>>>>        Property Boolean pbUseConnectionID True
93078>>>>>        Property Boolean private.pbToANSI   True
93079>>>>>        Property Boolean private.pbRecnum   True
93080>>>>>        Property Boolean private.pbCopyData True
93081>>>>>        Property Boolean private.pbApiTableUpdateAuto False
93082>>>>>        Property Boolean private.pbCompareDate_DateTime False
93083>>>>>        Property Boolean private.pbCompareIndexAscending False
93084>>>>>        Property Boolean private.pbCompareIndexUppercase False
93085>>>>>        Property String private.psSchema
93086>>>>>        Property String private.psBaseTableSpace
93087>>>>>        Property String private.psLongTableSpace
93088>>>>>        Property String private.psIndexTableSpace
93089>>>>>
93089>>>>>        // Driver default value settings:
93089>>>>>        Property String private.psDriverDefaultValueASCII    ""
93090>>>>>        Property String private.psDriverDefaultValueBinary   ""
93091>>>>>        Property String private.psDriverDefaultValueDate     ""
93092>>>>>        Property String private.psDriverDefaultValueDateTime ""
93093>>>>>        Property String private.psDriverDefaultValueNumeric  ""
93094>>>>>        Property String private.psDriverDefaultValueText     ""
93095>>>>>
93095>>>>>        // Driver "nullability" settings:
93095>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
93096>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
93097>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
93098>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
93099>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
93100>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
93101>>>>>
93101>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
93101>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
93101>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
93101>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
93101>>>>>        // We reset it here for each cDbUpdateVersion object
93101>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
93103>>>>>    End_Procedure
93104>>>>>
93104>>>>>    // *** Main hook event message ***
93104>>>>>    // Place your database update logic here!
93104>>>>>    Procedure OnUpdate
93106>>>>>    End_Procedure
93107>>>>>
93107>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
93107>>>>>    // imported to the cDbUpdateHandler container class which should be a
93107>>>>>    // parent object to this object. To have the Studio's Property Panel
93107>>>>>    // "behave" aka show these properties we need to duplicate them in this
93107>>>>>    // class and "relay" them to the parent object.
93107>>>>>    Procedure Set pbToANSI Boolean bState
93109>>>>>        Set private.pbToANSI  to bState
93110>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93111>>>>>        Delegate Set pbToANSI to bState
93113>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93114>>>>>    End_Procedure
93115>>>>>
93115>>>>>    Function pbToANSI Returns Boolean
93117>>>>>        Function_Return (private.pbToAnsi(Self))
93118>>>>>    End_Function
93119>>>>>
93119>>>>>    Procedure Set pbRecnum Boolean bState
93121>>>>>        Set private.pbRecnum  to bState
93122>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93123>>>>>        Delegate Set pbRecnum to bState
93125>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93126>>>>>    End_Procedure
93127>>>>>
93127>>>>>    Function pbRecnum Returns Boolean
93129>>>>>        Function_Return (private.pbRecnum(Self))
93130>>>>>    End_Function
93131>>>>>
93131>>>>>    Procedure Set pbCopyData Boolean bState
93133>>>>>        Set private.pbCopyData  to bState
93134>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93135>>>>>        Delegate Set pbCopyData to bState
93137>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93138>>>>>    End_Procedure
93139>>>>>
93139>>>>>    Function pbCopyData Returns Boolean
93141>>>>>        Function_Return (private.pbCopyData(Self))
93142>>>>>    End_Function
93143>>>>>
93143>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
93143>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
93145>>>>>        Set private.pbApiTableUpdateAuto  to bState
93146>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93147>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
93148>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93149>>>>>    End_Procedure
93150>>>>>
93150>>>>>    Function pbApiTableUpdateAuto Returns Boolean
93152>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
93153>>>>>    End_Function
93154>>>>>
93154>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93156>>>>>        Set private.pbCompareDate_DateTime  to bState
93157>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93158>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93159>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93160>>>>>    End_Procedure
93161>>>>>
93161>>>>>    Function pbCompareDate_DateTime Returns Boolean
93163>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
93164>>>>>    End_Function
93165>>>>>
93165>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93167>>>>>        Set private.pbCompareIndexAscending  to bState
93168>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93169>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93170>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93171>>>>>    End_Procedure
93172>>>>>
93172>>>>>    Function pbCompareIndexAscending Returns Boolean
93174>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93175>>>>>    End_Function
93176>>>>>
93176>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93178>>>>>        Set private.pbCompareIndexUppercase  to bState
93179>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93180>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93181>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93182>>>>>    End_Procedure
93183>>>>>
93183>>>>>    Function pbCompareIndexUppercase Returns Boolean
93185>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93186>>>>>    End_Function
93187>>>>>
93187>>>>>    Procedure Set psSchema String sValue
93189>>>>>        Set private.psSchema  to sValue
93190>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93191>>>>>        Delegate Set psSchema to sValue
93193>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93194>>>>>    End_Procedure
93195>>>>>
93195>>>>>    // First retrieve the private value that might have been set in the object.
93195>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93195>>>>>    // it might have been specified in the SQLConnections.ini file.
93195>>>>>    Function psSchema Returns String
93197>>>>>        String sValue
93197>>>>>        Get private.psSchema to sValue
93198>>>>>        If (sValue = "") Begin
93200>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93201>>>>>        End
93201>>>>>>
93201>>>>>        Function_Return sValue
93202>>>>>    End_Function
93203>>>>>
93203>>>>>    Procedure Set psBaseTableSpace String sValue
93205>>>>>        Set private.psBaseTableSpace  to sValue
93206>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93207>>>>>        Delegate Set psBaseTableSpace to sValue
93209>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93210>>>>>    End_Procedure
93211>>>>>
93211>>>>>    // First retrieve the private value that might have been set in the object.
93211>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93211>>>>>    // it might have been specified in the SQLConnections.ini file.
93211>>>>>    Function psBaseTableSpace Returns String
93213>>>>>        String sValue
93213>>>>>        Get private.psBaseTableSpace to sValue
93214>>>>>        If (sValue = "") Begin
93216>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93217>>>>>        End
93217>>>>>>
93217>>>>>        Function_Return sValue
93218>>>>>    End_Function
93219>>>>>
93219>>>>>    Procedure Set psLongTableSpace String sValue
93221>>>>>        Set private.psLongTableSpace  to sValue
93222>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93223>>>>>        Delegate Set psLongTableSpace to sValue
93225>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93226>>>>>    End_Procedure
93227>>>>>
93227>>>>>    // First retrieve the private value that might have been set in the object.
93227>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93227>>>>>    // it might have been specified in the SQLConnections.ini file.
93227>>>>>    Function psLongTableSpace Returns String
93229>>>>>        String sValue
93229>>>>>        Get private.psLongTableSpace to sValue
93230>>>>>        If (sValue = "") Begin
93232>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93233>>>>>        End
93233>>>>>>
93233>>>>>        Function_Return sValue
93234>>>>>    End_Function
93235>>>>>
93235>>>>>    Procedure Set psIndexTableSpace String sValue
93237>>>>>        Set private.psIndexTableSpace  to sValue
93238>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93239>>>>>        Delegate Set psIndexTableSpace to sValue
93241>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93242>>>>>    End_Procedure
93243>>>>>
93243>>>>>    // First retrieve the private value that might have been set in the object.
93243>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93243>>>>>    // it might have been specified in the SQLConnections.ini file.
93243>>>>>    Function psIndexTableSpace Returns String
93245>>>>>        String sValue
93245>>>>>        Get private.psIndexTableSpace to sValue
93246>>>>>        If (sValue = "") Begin
93248>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93249>>>>>        End
93249>>>>>>
93249>>>>>        Function_Return sValue
93250>>>>>    End_Function
93251>>>>>
93251>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93253>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93254>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93255>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93257>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93258>>>>>    End_Procedure
93259>>>>>
93259>>>>>    // First retrieve the private value that might have been set in the object.
93259>>>>>    // If blank; get it from the parent object
93259>>>>>    Function psDriverDefaultValueASCII Returns String
93261>>>>>        String sValue
93261>>>>>        Get private.psDriverDefaultValueASCII to sValue
93262>>>>>        If (sValue = "") Begin
93264>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93266>>>>>        End
93266>>>>>>
93266>>>>>        Function_Return sValue
93267>>>>>    End_Function
93268>>>>>
93268>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93270>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93271>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93272>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93274>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93275>>>>>    End_Procedure
93276>>>>>
93276>>>>>    // First retrieve the private value that might have been set in the object.
93276>>>>>    // If blank; get it from the parent object
93276>>>>>    Function psDriverDefaultValueBinary Returns String
93278>>>>>        String sValue
93278>>>>>        Get private.psDriverDefaultValueBinary to sValue
93279>>>>>        If (sValue = "") Begin
93281>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93283>>>>>        End
93283>>>>>>
93283>>>>>        Function_Return sValue
93284>>>>>    End_Function
93285>>>>>
93285>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93287>>>>>        Set private.psDriverDefaultValueDate  to sValue
93288>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93289>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93291>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93292>>>>>    End_Procedure
93293>>>>>
93293>>>>>    // First retrieve the private value that might have been set in the object.
93293>>>>>    // If blank; get it from the parent object
93293>>>>>    Function psDriverDefaultValueDate Returns String
93295>>>>>        String sValue
93295>>>>>        Get private.psDriverDefaultValueDate to sValue
93296>>>>>        If (sValue = "") Begin
93298>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93300>>>>>        End
93300>>>>>>
93300>>>>>        Function_Return sValue
93301>>>>>    End_Function
93302>>>>>
93302>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93304>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93305>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93306>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93308>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93309>>>>>    End_Procedure
93310>>>>>
93310>>>>>    // First retrieve the private value that might have been set in the object.
93310>>>>>    // If blank; get it from the parent object
93310>>>>>    Function psDriverDefaultValueDateTime Returns String
93312>>>>>        String sValue
93312>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93313>>>>>        If (sValue = "") Begin
93315>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93317>>>>>        End
93317>>>>>>
93317>>>>>        Function_Return sValue
93318>>>>>    End_Function
93319>>>>>
93319>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93321>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93322>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93323>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93325>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93326>>>>>    End_Procedure
93327>>>>>
93327>>>>>    // First retrieve the private value that might have been set in the object.
93327>>>>>    // If blank; get it from the parent object
93327>>>>>    Function psDriverDefaultValueNumeric Returns String
93329>>>>>        String sValue
93329>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93330>>>>>        If (sValue = "") Begin
93332>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93334>>>>>        End
93334>>>>>>
93334>>>>>        Function_Return sValue
93335>>>>>    End_Function
93336>>>>>
93336>>>>>    Procedure Set psDriverDefaultValueText String sValue
93338>>>>>        Set private.psDriverDefaultValueText  to sValue
93339>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93340>>>>>        Delegate Set psDriverDefaultValueText to sValue
93342>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93343>>>>>    End_Procedure
93344>>>>>
93344>>>>>    // First retrieve the private value that might have been set in the object.
93344>>>>>    // If blank; get it from the parent object
93344>>>>>    Function psDriverDefaultValueText Returns String
93346>>>>>        String sValue
93346>>>>>        Get private.psDriverDefaultValueText to sValue
93347>>>>>        If (sValue = "") Begin
93349>>>>>            Delegate Get psDriverDefaultValueText to sValue
93351>>>>>        End
93351>>>>>>
93351>>>>>        Function_Return sValue
93352>>>>>    End_Function
93353>>>>>
93353>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93355>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93356>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93357>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93359>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93360>>>>>    End_Procedure
93361>>>>>
93361>>>>>    // First retrieve the private value that might have been set in the object.
93361>>>>>    // If blank; get it from the parent object
93361>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93363>>>>>        Boolean bState
93363>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93364>>>>>        If (bState = False) Begin
93366>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93368>>>>>        End
93368>>>>>>
93368>>>>>        Function_Return bState
93369>>>>>    End_Function
93370>>>>>
93370>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93372>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93373>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93374>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93376>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93377>>>>>    End_Procedure
93378>>>>>
93378>>>>>    // First retrieve the private value that might have been set in the object.
93378>>>>>    // If blank; get it from the parent object
93378>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93380>>>>>        Boolean bState
93380>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93381>>>>>        If (bState = False) Begin
93383>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93385>>>>>        End
93385>>>>>>
93385>>>>>        Function_Return bState
93386>>>>>    End_Function
93387>>>>>
93387>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93389>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93390>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93391>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93393>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93394>>>>>    End_Procedure
93395>>>>>
93395>>>>>    // First retrieve the private value that might have been set in the object.
93395>>>>>    // If blank; get it from the parent object
93395>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93397>>>>>        Boolean bState
93397>>>>>        Get private.pbDriverDefaultNullableDate to bState
93398>>>>>        If (bState = False) Begin
93400>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93402>>>>>        End
93402>>>>>>
93402>>>>>        Function_Return bState
93403>>>>>    End_Function
93404>>>>>
93404>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93406>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93407>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93408>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93410>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93411>>>>>    End_Procedure
93412>>>>>
93412>>>>>    // First retrieve the private value that might have been set in the object.
93412>>>>>    // If blank; get it from the parent object
93412>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93414>>>>>        Boolean bState
93414>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93415>>>>>        If (bState = False) Begin
93417>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93419>>>>>        End
93419>>>>>>
93419>>>>>        Function_Return bState
93420>>>>>    End_Function
93421>>>>>
93421>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93423>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93424>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93425>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93427>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93428>>>>>    End_Procedure
93429>>>>>
93429>>>>>    // First retrieve the private value that might have been set in the object.
93429>>>>>    // If blank; get it from the parent object
93429>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93431>>>>>        Boolean bState
93431>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93432>>>>>        If (bState = False) Begin
93434>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93436>>>>>        End
93436>>>>>>
93436>>>>>        Function_Return bState
93437>>>>>    End_Function
93438>>>>>
93438>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93440>>>>>        Set private.pbDriverDefaultNullableText  to bState
93441>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93442>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93444>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93445>>>>>    End_Procedure
93446>>>>>
93446>>>>>    // First retrieve the private value that might have been set in the object.
93446>>>>>    // If blank; get it from the parent object
93446>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93448>>>>>        Boolean bState
93448>>>>>        Get private.pbDriverDefaultNullableText to bState
93449>>>>>        If (bState = False) Begin
93451>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93453>>>>>        End
93453>>>>>>
93453>>>>>        Function_Return bState
93454>>>>>    End_Function
93455>>>>>
93455>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93457>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93457>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93457>>>>>
93457>>>>>        Get psDriverID to sDriverID
93458>>>>>        Get psSchema to sSchema
93459>>>>>
93459>>>>>        Get psBaseTableSpace to sBaseTableSpace
93460>>>>>        If (sBaseTableSpace <> "") Begin
93462>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93463>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93465>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93466>>>>>        End
93466>>>>>>
93466>>>>>
93466>>>>>        Get psLongTableSpace to sLongTableSpace
93467>>>>>        If (sLongTableSpace <> "") Begin
93469>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93470>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93472>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93473>>>>>        End
93473>>>>>>
93473>>>>>
93473>>>>>        Get psIndexTableSpace to sIndexTableSpace
93474>>>>>        If (sIndexTableSpace <> "") Begin
93476>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93477>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93479>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93480>>>>>        End
93480>>>>>>
93480>>>>>
93480>>>>>        Get pbUseConnectionID to bUseConnectionID
93481>>>>>        Get pbToANSI          to bToANSI
93482>>>>>        Get pbRecnum          to bRecnum
93483>>>>>        Get pbCopyData        to bCopyData
93484>>>>>
93484>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93485>>>>>
93485>>>>>        Function_Return bOK
93486>>>>>    End_Function
93487>>>>>
93487>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93487>>>>>//        Boolean bOK bExists
93487>>>>>//        String sDataPath sBackupFolder
93487>>>>>//        
93487>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93487>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93487>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93487>>>>>//        Get vFolderFormat sDataPath to sDataPath
93487>>>>>//        
93487>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93487>>>>>//        If (bExists = False) Begin
93487>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93487>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93487>>>>>//            If (bExists = False) Begin
93487>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93487>>>>>//                Function_Return False
93487>>>>>//            End                                                                                                                                            
93487>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93487>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93487>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93487>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93487>>>>>//        End
93487>>>>>//        
93487>>>>>//        Set Message_Text of ghoStatusPanel to ""
93487>>>>>//        Function_Return bOK
93487>>>>>//    End_Function
93487>>>>>//
93487>>>>>    // This is automatically called after the OnUpdate
93487>>>>>    // event has been executed. It will automatically update the
93487>>>>>    // version database field/column with the "pnVersionNumber"
93487>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93487>>>>>    Procedure UpdateVersionColumnValue
93489>>>>>        Number nVersion nCurrentValue
93489>>>>>        Integer hTable iColumn
93489>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93489>>>>>
93489>>>>>        Move False to Err
93490>>>>>        Move 0 to LastErr
93491>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93491>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93491>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93493>>>>>        Get pbVersionUpdate to bVersionUpdate
93494>>>>>
93494>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93496>>>>>            Get pnVersionNumber to nVersion
93497>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93499>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93501>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93501>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93501>>>>>            Close DF_ALL DF_PERMANENT
93502>>>>>
93502>>>>>            Open hTable
93504>>>>>
93504>>>>>            // It is then the developer responsibility to take care of finding
93504>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93504>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93506>>>>>            If (bUseCustomDbVersion = True) Begin
93508>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93510>>>>>            End
93510>>>>>>
93510>>>>>
93510>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93513>>>>>            If (nCurrentValue < nVersion) Begin
93515>>>>>                Lock
93516>>>>>>
93516>>>>>                    If (bUseCustomDbVersion = False) Begin
93518>>>>>                        Vfind hTable Recnum GE                            
93520>>>>>                    End
93520>>>>>>
93520>>>>>                    Set_Field_Value hTable iColumn to nVersion
93523>>>>>                    SaveRecord hTable
93524>>>>>                Unlock
93525>>>>>>
93525>>>>>            End
93525>>>>>>
93525>>>>>            Close hTable
93526>>>>>        End
93526>>>>>>
93526>>>>>    End_Procedure
93527>>>>>
93527>>>>>// Property of the container object (cDbUpdateHandler)
93527>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93527>>>>>
93527>>>>>    Procedure End_Construct_Object
93529>>>>>        Forward Send End_Construct_Object
93531>>>>>        Send ProcessUpdate True
93532>>>>>    End_Procedure
93533>>>>>    
93533>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93535>>>>>        Number nVersion nCurrentValue
93535>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
93535>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
93535>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
93535>>>>>        String sObjectName
93535>>>>>        tDbVersionInfo[] dbVersionInfoArray
93535>>>>>        tDbVersionInfo[] dbVersionInfoArray
93536>>>>>
93536>>>>>        Move 0 to nCurrentValue
93537>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93539>>>>>
93539>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
93541>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
93543>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
93545>>>>>            If (iErrorObject <> 0) Begin
93547>>>>>                Move iErrorObject to Error_Object_Id
93548>>>>>            End
93548>>>>>>
93548>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
93549>>>>>>
93549>>>>>            Send Exit_Application
93550>>>>>        End
93550>>>>>>
93550>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93550>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93550>>>>>        // one database update is depended on an earlier update and that earlier version
93550>>>>>        // update was never executed it could lead to disastrous results.
93550>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93550>>>>>        Get pnVersionNumber to nVersion
93551>>>>>        If (nVersion < 0) Begin
93553>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93554>>>>>            Move (Name(Self)) to sObjectName
93555>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93556>>>>>>
93556>>>>>            Send Exit_Application
93557>>>>>        End
93557>>>>>>
93557>>>>>
93557>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93557>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93557>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93559>>>>>        If (bOnPreUpdateExecuted = False) Begin
93561>>>>>            Delegate Send OnPreUpdate
93563>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93565>>>>>        End
93565>>>>>>
93565>>>>>        
93565>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93567>>>>>        
93567>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93569>>>>>        If (bUseCustomDbVersion = True) Begin
93571>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93572>>>>>            If (bTableExists = False) Begin
93574>>>>>                Delegate Send OnCreateCustomDbVersionTable
93576>>>>>            End
93576>>>>>>
93576>>>>>        End
93576>>>>>>
93576>>>>>        
93576>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93576>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93576>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93578>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93580>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93581>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93582>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93583>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93585>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93587>>>>>        End
93587>>>>>>
93587>>>>>
93587>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93589>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93591>>>>>
93591>>>>>        Open hTable
93593>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93596>>>>>        If (bOpened = False) Begin
93598>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93599>>>>>            Send Exit_Application
93600>>>>>        End
93600>>>>>>
93600>>>>>        
93600>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93600>>>>>        // in case we take care of it here.
93600>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93603>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93605>>>>>            Vfind hTable 0 GT
93607>>>>>        End
93607>>>>>>
93607>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93610>>>>>        If (bSystemTable = True) Begin
93612>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93615>>>>>        End
93615>>>>>>
93615>>>>>        Else Begin
93616>>>>>            If (bUseCustomDbVersion = True) Begin
93618>>>>>                Send OnFindVersionRecord
93619>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93622>>>>>            End
93622>>>>>>
93622>>>>>        End
93622>>>>>>
93622>>>>>
93622>>>>>        Close hTable
93623>>>>>
93623>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93623>>>>>        // If not set we do nothing.
93623>>>>>        If (nCurrentValue < nVersion) Begin
93625>>>>>
93625>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93625>>>>>            // execution of database update code. So if true _and_ one error
93625>>>>>            // has already occured; we're out of here.
93625>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93627>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93629>>>>>            If (bStopOnFirstError = True) Begin
93631>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93633>>>>>                    Procedure_Return
93634>>>>>                End
93634>>>>>>
93634>>>>>            End
93634>>>>>>
93634>>>>>
93634>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93634>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93636>>>>>
93636>>>>>            // If the parent property pbContinueOnError = False, an update
93636>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93636>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93638>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93640>>>>>                Procedure_Return
93641>>>>>            End
93641>>>>>>
93641>>>>>
93641>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93643>>>>>
93643>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93644>>>>>
93644>>>>>            // *** Programmer's main hook event for database update functions:
93644>>>>>            Send OnUpdate
93645>>>>>
93645>>>>>            Set pbVersionUpdate to True
93646>>>>>            Send UpdateVersionColumnValue
93647>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93649>>>>>        End
93649>>>>>>
93649>>>>>
93649>>>>>    End_Procedure
93650>>>>>
93650>>>>>End_Class
93651>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93651>>>>>//****************************************************************************
93651>>>>>// $Module type: Class
93651>>>>>// $Module name: cDbUpdateUserCount.pkg
93651>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93651>>>>>//
93651>>>>>//               Collected from DAW's newsgroups.
93651>>>>>//
93651>>>>>// Description : It uses the windows API to lock bytes in a file.
93651>>>>>//               If the application or PC craches it will release the lock
93651>>>>>//               automatically.
93651>>>>>//
93651>>>>>// Note 1      : It will count the number of running app's, so if a
93651>>>>>//               user starts the app twice on one machine it will count as two users.
93651>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93651>>>>>//               However, to not conflict with any other usage of this class it was
93651>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93651>>>>>//               and cDbUpdateVersion classes)
93651>>>>>//
93651>>>>>// $Rev History:
93651>>>>>//    2008-10-17  Module header created (Militaty data format)
93651>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93651>>>>>//                for easy translation to other languages.
93651>>>>>//                Added the tUserCount struct for easier passing of parameters.
93651>>>>>//                Added the ApplicationPath message.
93651>>>>>//****************************************************************************
93651>>>>>Use LanguageText.pkg
93651>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93651>>>>>>>Use GlobalFunctionsProcedures.pkg
93651>>>>>>>// Sample:
93651>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93651>>>>>>>
93651>>>>>>>
93651>>>>>>>// Symbols used by UserCounting
93651>>>>>>>    Define GENERIC_READ         for |CI$80000000
93651>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93651>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93651>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93651>>>>>>>    Define CREATE_NEW           for 1
93651>>>>>>>    Define CREATE_ALWAYS        for 2
93651>>>>>>>    Define OPEN_EXISTING        for 3
93651>>>>>>>    Define OPEN_ALWAYS          for 4
93651>>>>>>>    Define TRUNCATE_EXISTING    for 5
93651>>>>>>>    Define FILE_BEGIN           for 0
93651>>>>>>>    Define FILE_CURRENT         for 1
93651>>>>>>>    Define FILE_END             for 2
93651>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93651>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93651>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93651>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93651>>>>>>>    Define _MAX_PATH  for 260
93651>>>>>>>    Define _MAX_DRIVE for 3
93651>>>>>>>    Define _MAX_DIR   for 256
93651>>>>>>>    Define _MAX_FNAME for 256
93651>>>>>>>    Define _MAX_EXT   for 256
93651>>>>>>>
93651>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93652>>>>>>>
93652>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93653>>>>>>>
93653>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93654>>>>>>>
93654>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93655>>>>>>>
93655>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93656>>>>>>>
93656>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93657>>>>>>>
93657>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93658>>>>>>>
93658>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93659>>>>>>>// Sample:
93659>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93659>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93661>>>>>>>    Boolean bReturn
93661>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93662>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93663>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93664>>>>>>>    Function_Return bReturn
93665>>>>>>>End_Function
93666>>>>>Use vWin32fh.pkg
93666>>>>>Use seq_chnl.pkg
93666>>>>>
93666>>>>>// User interface constant strings:
93666>>>>>    Define CS_UserCountError            for "User count error:"
93666>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93666>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93666>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93666>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>
93666>>>>>    Struct tUserCount
93666>>>>>        Integer iUserCount
93666>>>>>        Integer iError
93666>>>>>        String  sErrorTxt
93666>>>>>    End_Struct
93666>>>>>
93666>>>>>    Define CI_UserCountMaxUsers for 9999
93666>>>>>
93666>>>>>Class cDbUpdateUserCount is a cObject
93667>>>>>    Procedure Construct_Object
93669>>>>>        Forward Send Construct_Object
93671>>>>>
93671>>>>>        Property String  psLockFileName
93672>>>>>        Property Integer piMaxUsers
93673>>>>>        Property Boolean pbCheckDataFlexUserCount True
93674>>>>>
93674>>>>>        Property Handle  phUserCountFile
93675>>>>>        Property Integer pdwLockPosition
93676>>>>>    End_Procedure
93677>>>>>
93677>>>>>    Function IsProgramRunning Returns Boolean
93679>>>>>        tUserCount UserCount
93679>>>>>        tUserCount UserCount
93679>>>>>
93679>>>>>        Get CheckUserCount to UserCount
93680>>>>>
93680>>>>>        Function_Return (UserCount.iUserCount > 1)
93681>>>>>    End_Function
93682>>>>>
93682>>>>>    // Returns the full path of the Application (no trailing "\")
93682>>>>>    Function ApplicationPath Returns String
93684>>>>>        String sApplicationFileName sPath
93684>>>>>        Integer iNumChars iRetval
93684>>>>>
93684>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93685>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93686>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93687>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93688>>>>>        Move (CString(sApplicationFileName)) to sPath
93689>>>>>
93689>>>>>        Function_Return sPath
93690>>>>>    End_Function
93691>>>>>
93691>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93693>>>>>        Handle  hFile
93693>>>>>        Pointer pFileName
93693>>>>>        String sPath sFile
93693>>>>>        Integer iCh
93693>>>>>
93693>>>>>        Move (Addressof(sFileName)) to pFileName
93694>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93695>>>>>
93695>>>>>        // If lock file doesn't exist, create it.
93695>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93697>>>>>            Get ApplicationPath to sPath
93698>>>>>            Get vFolderFormat sPath to sPath
93699>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93700>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93701>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93703>>>>>                Function_Return 0
93704>>>>>            End
93704>>>>>>
93704>>>>>            Direct_Output channel iCh sFile
93706>>>>>                Write channel iCh ""
93708>>>>>            Send Seq_Close_Channel iCh
93709>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93710>>>>>        End
93710>>>>>>
93710>>>>>
93710>>>>>        Function_Return hFile
93711>>>>>    End_Function
93712>>>>>
93712>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93714>>>>>        Integer iReturnValue 
93714>>>>>        Boolean bOK
93714>>>>>
93714>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93715>>>>>        If (iReturnValue = 0) Begin
93717>>>>>            Move False to bOK
93718>>>>>        End
93718>>>>>>
93718>>>>>        Else Begin
93719>>>>>            Move True to bOK
93720>>>>>        End
93720>>>>>>
93720>>>>>        Function_Return bOK
93721>>>>>    End_Function
93722>>>>>
93722>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93724>>>>>        Integer iReturnValue
93724>>>>>        Boolean bOK
93724>>>>>
93724>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93725>>>>>        If (iReturnValue = 0) Begin
93727>>>>>            Move False to bOK
93728>>>>>        End
93728>>>>>>
93728>>>>>        Else Begin
93729>>>>>            Move True to bOK
93730>>>>>        End           
93730>>>>>>
93730>>>>>        Function_Return bOK
93731>>>>>    End_Function
93732>>>>>
93732>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93734>>>>>        dWord dwCurrPos
93734>>>>>
93734>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93735>>>>>        Function_Return dwCurrPos
93736>>>>>    End_Function
93737>>>>>
93737>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93739>>>>>        DWord dwCurrPos
93739>>>>>
93739>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93740>>>>>        Function_Return dwCurrPos
93741>>>>>    End_Function
93742>>>>>
93742>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93744>>>>>        Integer iReturnValue                               
93744>>>>>        Boolean bOK
93744>>>>>        String  sBuffer
93744>>>>>        Pointer pBuffer
93744>>>>>        String  sSize
93744>>>>>        Pointer pSize
93744>>>>>
93744>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93745>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93746>>>>>
93746>>>>>        Move (Repeat((Character(0)),4)) to sSize
93747>>>>>        Move (AddressOf(sSize)) to pSize
93748>>>>>
93748>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93749>>>>>        If (iReturnValue = 0) Begin
93751>>>>>            Move False to bOK
93752>>>>>        End
93752>>>>>>
93752>>>>>        Else Begin
93753>>>>>            Move True to bOK
93754>>>>>        End                 
93754>>>>>>
93754>>>>>        Function_Return bOK
93755>>>>>    End_Function
93756>>>>>
93756>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93758>>>>>        Integer iReturnValue
93758>>>>>
93758>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93759>>>>>        Function_Return iReturnValue
93760>>>>>    End_Function
93761>>>>>
93761>>>>>    Procedure DoCheckUserCount
93763>>>>>        tUserCount UserCount
93763>>>>>        tUserCount UserCount
93763>>>>>
93763>>>>>        Get CheckUserCount to UserCount
93764>>>>>        // If all is fine, we're done.
93764>>>>>        If (UserCount.iError = 0) Begin
93766>>>>>            Procedure_Return
93767>>>>>        End
93767>>>>>>
93767>>>>>
93767>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93768>>>>>
93768>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93770>>>>>            Abort
93771>>>>>>
93771>>>>>        End
93771>>>>>>
93771>>>>>    End_Procedure
93772>>>>>
93772>>>>>    Function CheckUserCount Returns tUserCount
93774>>>>>        Handle  hFile
93774>>>>>        String  sPath sFile
93774>>>>>        Integer iResult
93774>>>>>        DWord   dwFilePos
93774>>>>>        Integer bLocked
93774>>>>>        Integer iMaxUsers
93774>>>>>        Integer iCurUser
93774>>>>>        tUserCount UserCount
93774>>>>>        tUserCount UserCount
93774>>>>>
93774>>>>>        Move 0 to UserCount.iError
93775>>>>>
93775>>>>>        Get phUserCountFile to hFile
93776>>>>>        If (not(hFile)) Begin
93778>>>>>            Get ApplicationPath to sPath
93779>>>>>            Get vFolderFormat sPath to sPath
93780>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93781>>>>>            Get OpenUserCountFile sFile to hFile
93782>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93784>>>>>                Move 1 to UserCount.iUserCount
93785>>>>>                Move 1 to UserCount.iError
93786>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93787>>>>>                Function_Return UserCount
93788>>>>>            End
93788>>>>>>
93788>>>>>            Else Begin
93789>>>>>                Move False to bLocked
93790>>>>>                Set phUserCountFile to hFile
93791>>>>>                Get piMaxUsers to iMaxUsers
93792>>>>>
93792>>>>>                // Set Filepointer to beginning of the file
93792>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93793>>>>>                If (dwFilePos = -1) Begin
93795>>>>>                    Move 1 to UserCount.iUserCount
93796>>>>>                    Move 2 to UserCount.iError
93797>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93798>>>>>                    Function_Return UserCount
93799>>>>>                End
93799>>>>>>
93799>>>>>                For iCurUser from 1 to iMaxUsers
93805>>>>>>
93805>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93806>>>>>                    If (not(iResult)) Begin  // byte is locked
93808>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93809>>>>>                        If (dwFilePos = -1) Begin
93811>>>>>                            Move 1 to UserCount.iUserCount
93812>>>>>                            Move 3 to UserCount.iError
93813>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93814>>>>>                            Function_Return UserCount
93815>>>>>                        End
93815>>>>>>
93815>>>>>                    End
93815>>>>>>
93815>>>>>                    Else Begin  // byte is not locked
93816>>>>>                        Set pdwLockPosition to dwFilePos
93817>>>>>                        Move True to bLocked
93818>>>>>                        Move iMaxUsers to iCurUser
93819>>>>>                    End
93819>>>>>>
93819>>>>>                Loop
93820>>>>>>
93820>>>>>                If (not(bLocked)) Begin
93822>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93823>>>>>                    Move 4 to UserCount.iError
93824>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93825>>>>>                    Function_Return UserCount
93826>>>>>                End
93826>>>>>>
93826>>>>>            End
93826>>>>>>
93826>>>>>        End
93826>>>>>>
93826>>>>>
93826>>>>>        Function_Return UserCount
93827>>>>>    End_Function
93828>>>>>
93828>>>>>
93828>>>>>    Procedure DoReleaseUserCount
93830>>>>>        Integer iResult
93830>>>>>        Handle  hFile
93830>>>>>        DWord   dwLockPos
93830>>>>>
93830>>>>>        Get phUserCountFile to hFile
93831>>>>>        Get pdwLockPosition to dwLockPos
93832>>>>>        If (hFile) Begin
93834>>>>>            If (dwLockPos) Begin
93836>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93837>>>>>            End
93837>>>>>>
93837>>>>>            Get CloseUserCountFile hFile to iResult
93838>>>>>        End
93838>>>>>>
93838>>>>>    End_Procedure
93839>>>>>
93839>>>>>    Function CurrentNumberOfUsers Returns Integer
93841>>>>>        Handle  hFile
93841>>>>>        Integer iMaxUsers
93841>>>>>        DWord   dwFilePos
93841>>>>>        Integer iCurUser
93841>>>>>        Integer iResult
93841>>>>>        Integer iNumberOfLocks
93841>>>>>        String  sPath sFile
93841>>>>>
93841>>>>>        Move 0 to iNumberOfLocks
93842>>>>>
93842>>>>>        Get ApplicationPath to sPath
93843>>>>>        Get vFolderFormat sPath to sPath
93844>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93845>>>>>        Get OpenUserCountFile sFile to hFile
93846>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93848>>>>>            Send UserError CS_UnableToInitUserCountSys
93849>>>>>            Abort
93850>>>>>>
93850>>>>>        End
93850>>>>>>
93850>>>>>
93850>>>>>        If (hFile > 0) Begin
93852>>>>>            Get piMaxUsers To iMaxUsers
93853>>>>>
93853>>>>>            // Set Filepointer to beginning of the file
93853>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93854>>>>>            If (dwFilePos = -1) Begin
93856>>>>>                Send UserError CS_UnableResetUserCountSys
93857>>>>>                Abort
93858>>>>>>
93858>>>>>            End
93858>>>>>>
93858>>>>>            For iCurUser from 1 to iMaxUsers
93864>>>>>>
93864>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93865>>>>>                If (Not(iResult)) Begin  // byte is locked
93867>>>>>                    Increment iNumberOfLocks
93868>>>>>                End
93868>>>>>>
93868>>>>>                Else Begin  // byte is not locked
93869>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93870>>>>>                End
93870>>>>>>
93870>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93871>>>>>                If (dwFilePos = -1) Begin
93873>>>>>                    Send UserError CS_ErrorAdvancingPointer
93874>>>>>                    Abort
93875>>>>>>
93875>>>>>                End
93875>>>>>>
93875>>>>>            Loop
93876>>>>>>
93876>>>>>        End
93876>>>>>>
93876>>>>>        Get CloseUserCountFile hFile to iResult
93877>>>>>        Function_Return iNumberOfLocks
93878>>>>>    End_Function
93879>>>>>
93879>>>>>End_Class
93880>>>Use cDbUpdateFunctionLibrary.pkg
93880>>>
93880>>>//{ DataBindable=True }
93880>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93881>>>
93881>>>    Procedure Construct_Object
93883>>>        tUserCount UserCount
93883>>>        tUserCount UserCount
93883>>>        Integer iUserCount
93883>>>        Handle ho                     
93883>>>
93883>>>        Forward Send Construct_Object
93885>>>        Move Self to ghoDbUpdateHandler  
93886>>>        
93886>>>        // Latin1_General_CI_AS = General Insensitive collation
93886>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93886>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93886>>>        // Good read about which collation to select:
93886>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93886>>>        Property String psCollation "Latin1_General_CI_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93887>>>
93887>>>        // Struct array that will contain pnVersionNumbers & object id's of
93887>>>        // all child cDbVersion objects.
93887>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93888>>>
93888>>>        Property Integer Error_Processing_State False  // internal usage
93889>>>        
93889>>>        Property Boolean Private.pbDbVersionCheckDone False
93890>>>
93890>>>        Property Boolean pbUseCustomDbVersion False  
93891>>>        
93891>>>        // If this property = True _and_ no DbVersion table exists 
93891>>>        // when the framework is started, a DbVersion table will be created automatically.
93891>>>        Property Boolean pbAutoCreateDbVersionTable True
93892>>>
93892>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93892>>>        // the Filelist.cfg slot number indicated by this property will be used
93892>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93892>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93892>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93892>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93892>>>        Property Integer Private.piDbVersionFileNumber -1
93893>>>        Property Integer Private.piDbVersionFieldNumber 1
93894>>>
93894>>>        Property Handle  piIntFilesFileNumber -1
93895>>>        Property Boolean pbRestoreIntFilesNow False   
93896>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93896>>>        // also needs to be created in the ghoApplication object.
93896>>>        Property Boolean pbSaveIntFilesNow False
93897>>>        Property Boolean pbUseIntFilesBackup False   
93898>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93899>>>        
93899>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93899>>>        // that creates all library properties
93899>>>        Send CreateDbUpdateLibraryProperties
93900>>>
93900>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93901>>>
93901>>>        // Error handling:
93901>>>        Property Boolean Private.pbOnCreateExecuted False
93902>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93903>>>        Property Boolean Private.pbProcessingError False
93904>>>        Property Boolean pbDbUpdateErrorHasOccured False
93905>>>        // Don't touch. It is being used by the cDbUpdateVersion
93905>>>        // subclass to tell if that particular update was a success or not.
93905>>>        Property Boolean Private.pbUpdateVersionObjectError False
93906>>>        Property String[] paSQLQueryMessages
93907>>>        
93907>>>        Property Boolean pbExitIfDebuggerActive True
93908>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93909>>>        Move Self to Error_Object_Id
93910>>>        // Error handling:
93910>>>        // Temporarily redirect all errors to this object so we can silently
93910>>>        // log all errors that might appear while updating the database.
93910>>>        // We temporarily redirect all errors to this object so we can
93910>>>        // log and write errors to the log file. It will be reset after
93910>>>        // the database updates have been finished.
93910>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93911>>>
93911>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93912>>>
93912>>>        // Error Reporting Related
93912>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93912>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93913>>>
93913>>>        // If the pbContinueOnError = False, an update
93913>>>        // of another cDbUpdateVersion object will _not_ be
93913>>>        // performed if an error occured in a previous
93913>>>        // cDbUpdateVersion object.
93913>>>        Property Boolean pbContinueOnError False
93914>>>        // Stops execution in other cDbUpdateVersion objecs,
93914>>>        // if errors occurred in one cDbUpdateVersion object.
93914>>>        Property Boolean pbStopOnFirstError False
93915>>>        // If True errors that occured while updating the database
93915>>>        // will be shown in the default app for .txt files when done.
93915>>>        // Note: The log file will _always_ be created in the Data folder.
93915>>>        Property Boolean pbShowErrorLogPostRun True
93916>>>
93916>>>        // Be _very_ careful to set this property to true!
93916>>>        // If = True, no question will be asked if the update
93916>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93916>>>        // the error log won't be shown. The logfile itself will still be created though.
93916>>>        // You have to know what you're doing!
93916>>>        Property Boolean pbSilentMode False
93917>>>        
93917>>>        Property Boolean pbEnableCancelButton False
93918>>>
93918>>>        // Don't touch! Very private. The value is used by the error log to write for which
93918>>>        // cDbUpdateVersion object an error occured.
93918>>>        Property Number pnCurrentVersionUpdate 0
93919>>>
93919>>>        // The user counting logic is used to safe-guard agains anybody else is
93919>>>        // using the application when a database update is to be performed.
93919>>>        // (Garters & suspenders!)
93919>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93920>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93921>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93922>>>
93922>>>        // This lock file is used to guard against somebody else tries to start the
93922>>>        // application while updates are in progress.
93922>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93923>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93924>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93925>>>                                                                                      // Only the current user allowed.
93925>>>        // Properties for the table & column of a system file field/column where
93925>>>        // the database version update number gets saved.
93925>>>        Property Integer Private.Data_File  0
93926>>>        Property Integer Private.Data_Field 0
93927>>>
93927>>>        // Property that is used to indicate that we have already
93927>>>        // started the database update.
93927>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93928>>>
93928>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93928>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93928>>>        // change of the database has been made.
93928>>>        Property Boolean Private.pbDatabaseWasUpdated False
93929>>>
93929>>>        // We need to trigger the user counting system so that a bit in the
93929>>>        // user counting file is locked. This is to guard that not more than one user
93929>>>        // is currently runnning the program.
93929>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93930>>>
93930>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93931>>>        If (iUserCount > 0) Begin
93933>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93934>>>            Send Exit_Application
93935>>>        End
93935>>>>
93935>>>
93935>>>        Set pbHandleQueryErrors to False
93936>>>            
93936>>>        Property Handle phoSQLConnectionHandler 0
93937>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93937>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93937>>>        // etc information.
93937>>>        If (ghoSQLConnectionHandler = 0) Begin
93939>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93940>>>            Set phoSQLConnectionHandler to ho
93941>>>        End             
93941>>>>
93941>>>        
93941>>>        Set Icon to "Default.ico"
93942>>>    End_Procedure
93943>>>
93943>>>    Procedure End_Construct_Object
93945>>>        Forward Send End_Construct_Object
93947>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93949>>>            Send OnCreate
93950>>>            Set Private.pbOnCreateExecuted to True
93951>>>        End
93951>>>>
93951>>>        Send Cleanup
93952>>>    End_Procedure
93953>>>    
93953>>>    // Programmers hook event!
93953>>>    Procedure OnCreate
93955>>>    End_Procedure        
93956>>>                                 
93956>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93956>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93956>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93956>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93956>>>    //                                                
93956>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93956>>>    // cDbUpdateHandler object.
93956>>>    //
93956>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93956>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93956>>>    //
93956>>>    // If not done previously the piIntFilesFileNumber will be created and filled with data
93956>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93956>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93956>>>    // of Filelist.cfg is made for backup purposes.
93956>>>    //
93956>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93956>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93956>>>
93956>>>    // Note: Include_Resource is a compiler directive!
93956>>>    // It will embedd the Filelist.cfg from the developers machine
93956>>>    // into the executable.        
93956>>>    //
93956>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93956>>>    // when we get here and then the compiler can't embedd it!        
93956>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93956>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93956>>>    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
93958>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93958>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93958>>>        String sFileListZipFile sParam sProgram sFile 
93958>>>        Integer iDataPaths iCount iSize
93958>>>        Handle hTable hIntFilesTable                    
93958>>>        UChar[] asFileListArray 
93959>>>        String[] asSavedIntFile
93960>>>        tDUFIntFile[] DUFIntFiles
93960>>>        tDUFIntFile[] DUFIntFiles
93961>>>
93961>>>        // This will automatically create the piIntFilesFileNumber if not exists.
93961>>>        // It is used to save data from the current set of .int files.
93961>>>        // We do this on both developer & client machines.
93961>>>        Get IsIntFileTable to bIsIntFileTable
93962>>>        If (bIsIntFileTable = False) Begin
93964>>>            Send AutoCreateIntFilesTable
93965>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93966>>>            If (bOK = False) Begin
93968>>>                Function_Return False
93969>>>            End
93969>>>>
93969>>>        End                                                       
93969>>>>
93969>>>        
93969>>>        Get _UtilNumberOfFileListTables to iSize
93970>>>        Send StartStatusPanel "" "" iSize
93971>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
93972>>>
93972>>>        // Check Filelist.cfg & backup file
93972>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93973>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93974>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93975>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93976>>>
93976>>>        Move (IsDebuggerPresent()) to bDevelop
93977>>>        // Is this a client machine?
93977>>>        If (bDevelop = False) Begin
93979>>>            If (bNewer = True) Begin
93981>>>                // Create filelist.cfg from resource backup file.
93981>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93982>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93983>>>            End
93983>>>>
93983>>>        End
93983>>>>
93983>>>
93983>>>        Else If (bDevelop = True) Begin
93986>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93987>>>            If (bNewer = True) Begin
93989>>>                Get vDeleteFile sFileListNameBackup to bOK
93990>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93991>>>                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program." to sErrorText
93992>>>            End
93992>>>>
93992>>>        End
93992>>>>
93992>>>        
93992>>>        Move True to bResult 
93993>>>
93993>>>        Get piIntFilesFileNumber   to hIntFilesTable
93994>>>        Set Private.phCurrentTable to hIntFilesTable  
93995>>>        Set Private.piCurrentField to 1  
93996>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93997>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93998>>>
93998>>>        For iCount from 1 to iDataPaths
94004>>>>
94004>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
94005>>>            Get vFolderFormat sDataPath to sDataPath 
94006>>>            Get vFolderExists sDataPath to bExists
94007>>>            If (bExists = True) Begin                  
94009>>>                Move 0 to hTable
94010>>>                Repeat
94010>>>>
94010>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94013>>>                    If (hTable <> 0 and hTable <> 50) Begin
94015>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
94018>>>                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
94019>>>                        Send DoAdvance of ghoProgressBar
94020>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
94021>>>                        Get UtilTableIsAlias hTable to bIsAlias 
94022>>>                        If (bIsSQL = True and bIsAlias = False) Begin
94024>>>                            If (bIsSQL = True) Begin     
94026>>>                                Get _TableNameOnly sIntFileName to sIntFileName
94027>>>                                Move (sIntFileName + ".int")    to sIntFileName
94028>>>                                Get IsIntFileSaved sIntFileName to bSaved  
94029>>>                                Move True to bOK            
94030>>>                                
94030>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
94030>>>                                If (bSaved = False) Begin
94032>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
94033>>>                                    If (bOK = False) Begin
94035>>>                                        Move ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.") to sErrorText
94036>>>                                        Error DFERR_PROGRAM sErrorText
94037>>>>
94037>>>                                        Move False to bResult    
94038>>>                                    End
94038>>>>
94038>>>                                End         
94038>>>>
94038>>>                                Else Begin
94039>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
94040>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
94042>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
94043>>>                                        If (bOK = False) Begin
94045>>>                                            Move False to bResult
94046>>>                                            Move ("Could not update .int file data to the internal database table:" * String(sIntFileName)) to sErrorText
94047>>>                                            Error DFERR_PROGRAM sErrorText
94048>>>>
94048>>>                                        End
94048>>>>
94048>>>                                    End
94048>>>>
94048>>>                                End
94048>>>>
94048>>>                            End
94048>>>>
94048>>>                        End
94048>>>>
94048>>>                    End
94048>>>>
94048>>>                Until (hTable = 0)
94050>>>            End
94050>>>>
94050>>>        Loop       
94051>>>>
94051>>>        
94051>>>        Send StopStatusPanel
94052>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
94052>>>        If (bResult = False) Begin  
94054>>>            Function_Return False
94055>>>        End 
94055>>>>
94055>>>        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
94056>>>        Function_Return True
94057>>>    End_Function
94058>>>
94058>>>    // It checks that *.int files on disk corresponds with the content in the
94058>>>    // .int file backup table piIntFilesFileNumber.
94058>>>    Function RestoreIntFiles String ByRef sErrorText Returns Boolean
94060>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
94060>>>        String sPaths sDataPath sIntFileName 
94060>>>        String[] asSavedIntFile
94061>>>        Integer iDataPaths iCount iRetval iSize
94061>>>        Handle hTable hIntFilesTable
94061>>>
94061>>>        Get IsIntFileTable to bIsIntFileTable
94062>>>        If (bIsIntFileTable = False) Begin
94064>>>            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
94065>>>            Function_Return False
94066>>>        End
94066>>>>
94066>>>        
94066>>>        Get YesNo_Box "This will restore the content of all .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed and a backup Filelist.cfg will be installed.\n\n Continue?" to iRetval
94067>>>        If (iRetval <> MBR_Yes) Begin
94069>>>            Function_Return False
94070>>>        End
94070>>>>
94070>>>        
94070>>>        Get _UtilNumberOfFileListTables to iSize
94071>>>        Send StartStatusPanel "" "" iSize
94072>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
94073>>>
94073>>>        Move False to bRestored
94074>>>        Get piIntFilesFileNumber to hIntFilesTable
94075>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
94076>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
94077>>>
94077>>>        For iCount from 1 to iDataPaths
94083>>>>
94083>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
94084>>>            Get vFolderFormat sDataPath to sDataPath 
94085>>>            Get vFolderExists sDataPath to bExists
94086>>>            If (bExists = True) Begin                  
94088>>>                Move 0 to hTable
94089>>>                Repeat
94089>>>>
94089>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
94092>>>                    If (hTable <> 0) Begin
94094>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
94097>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
94098>>>                        Send DoAdvance of ghoProgressBar
94099>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
94100>>>                        If (bIsSQL = True) Begin     
94102>>>                            Get _TableNameOnly sIntFileName to sIntFileName
94103>>>                            Move (sIntFileName + ".int")    to sIntFileName
94104>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
94105>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
94107>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
94108>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
94109>>>                                If (bRestored = False and bOK = True) Begin
94111>>>                                    Move True to bRestored
94112>>>                                End
94112>>>>
94112>>>                                If (bOK = False) Begin 
94114>>>                                    Move ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName)) to sErrorText
94115>>>                                    Error DFERR_PROGRAM sErrorText
94116>>>>
94116>>>                                End
94116>>>>
94116>>>                            End
94116>>>>
94116>>>                        End
94116>>>>
94116>>>                    End
94116>>>>
94116>>>                Until (hTable = 0)
94118>>>            End
94118>>>>
94118>>>        Loop       
94119>>>>
94119>>>        
94119>>>        Send StopStatusPanel
94120>>>        Function_Return bRestored
94121>>>    End_Function
94122>>>
94122>>>    Function IsIntFileTable Returns Boolean
94124>>>        Boolean bExists bIsSQL
94124>>>        Handle hTable
94124>>>        String sLogicalName sRootName sFileName sDataPath
94124>>>
94124>>>        Get _UtilTableExists hTable to bExists
94125>>>        Get piIntFilesFileNumber to hTable
94126>>>        If (bExists = false and hTable > 0) Begin
94128>>>            Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
94131>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94134>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
94135>>>            If (bExists = True) Begin
94137>>>                Move (Pos(":", sRootName)) to bIsSQL
94138>>>                If (bIsSQL = True) Begin
94140>>>                    Move (sLogicalName + ".int") to sFileName
94141>>>                End
94141>>>>
94141>>>                Else Begin
94142>>>                    Move (sLogicalName + ".dat") to sFileName
94143>>>                End
94143>>>>
94143>>>                Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94144>>>                Get PathAtIndex of (phoWorkspace(ghoApplication))  sDataPath 1 to sDataPath
94145>>>                Get vFolderFormat sDataPath to sDataPath
94146>>>                File_Exist (sDataPath + sFileName) bExists
94147>>>            End
94147>>>>
94147>>>        End
94147>>>>
94147>>>        Function_Return bExists    
94148>>>    End_Function
94149>>>    
94149>>>    // To update currently saved IntFile data to the database.
94149>>>    // Because it is much easier, we first delete all current records and
94149>>>    // then saves the changed .int file to the database.
94149>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
94151>>>        Boolean bOK
94151>>>        Move False to bOK
94152>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94153>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
94154>>>        If (bOK = True) Begin
94156>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
94157>>>        End
94157>>>>
94157>>>        Function_Return bOK
94158>>>    End_Function
94159>>>    
94159>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
94159>>>    //       and thus we cannot compile.
94159>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
94161>>>        Handle hTable
94161>>>        Boolean bOK
94161>>>        Integer iColumn iIndex   
94161>>>        String sFileName
94161>>>        
94161>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94162>>>        Move False to bOK  
94163>>>        Get piIntFilesFileNumber to hTable
94164>>>        Move 2              to iColumn // This is the "InfFileName" field no.
94165>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94166>>>
94166>>>        Open hTable
94168>>>        Set_Field_Value hTable iColumn to sIntFileName
94171>>>        Vfind hTable iIndex GE
94173>>>        Get_Field_Value hTable iColumn to sFileName
94176>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
94178>>>            Move True to bOK    
94179>>>        End
94179>>>>
94179>>>        Close hTable
94180>>>        
94180>>>        Function_Return bOK       
94181>>>    End_Function   
94182>>>    
94182>>>    // Checks that the passed .int file is the same as what is saved in the database.
94182>>>    // If not same, the return string array will contain the read .int file,
94182>>>    // else the returned array will be empty.
94182>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
94184>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
94188>>>        Boolean bIsSame
94188>>>        
94188>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94189>>>        Get ReadIntFile sDataPath sIntFileName to asIntFileOrg   
94190>>>        Get RetrieveIntFileData sDataPath sIntFileName to asSavedIntFile
94191>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
94192>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
94193>>>        
94193>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
94194>>>        If (bIsSame = False) Begin
94196>>>            Move asIntFileOrg to asReturnIntFile    
94197>>>        End
94197>>>>
94197>>>        
94197>>>        Function_Return asReturnIntFile    
94198>>>    End_Function                                   
94199>>>    
94199>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
94201>>>        Handle hTable
94201>>>        Boolean bOK bErr
94201>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
94201>>>        Number iID
94201>>>        String sFileName
94201>>>        String[] asIntFile
94202>>>        
94202>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
94202>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94203>>>        
94203>>>        Move Err to bErr
94204>>>        Move False to Err
94205>>>        Move False to bOK
94206>>>        Get piIntFilesFileNumber to hTable  
94207>>>        Move 1              to iIDCol
94208>>>        Move 2              to iFileCol
94209>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94210>>>        Move 1              to iIDIdx   // Main ID index.
94211>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
94212>>>
94212>>>        Get ReadIntFile sPath sIntFileName to asIntFile
94213>>>        Move (SizeOfArray(asIntFile)) to iSize
94214>>>        If (iSize = 0) Begin
94216>>>            Function_Return False
94217>>>        End
94217>>>>
94217>>>        Decrement iSize
94218>>>        Open hTable  
94220>>>                  
94220>>>        // Find the last used ID no:
94220>>>        Fill_Field hTable iIDCol with DF_HIGH
94222>>>        Vfind hTable iIDIdx LE
94224>>>        Get_Field_Value hTable iIDCol to iID 
94227>>>        // This only happens the very first time we save a record.
94227>>>        If (iID = 999999999999) Begin
94229>>>            Move 0 to iID
94230>>>        End
94230>>>>
94230>>>        Increment iID
94231>>>        
94231>>>        Lock
94232>>>>
94232>>>            For iCount from 0 to iSize
94238>>>>
94238>>>                Clear hTable
94239>>>                Set_Field_Value hTable iIDCol   to iID     
94242>>>                Set_Field_Value hTable iFileCol to sIntFileName
94245>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94248>>>                SaveRecord hTable
94249>>>                Increment iID
94250>>>            Loop
94251>>>>
94251>>>        Unlock
94252>>>>
94252>>>        Close hTable
94253>>>        
94253>>>        Move (not(Err)) to bOK
94254>>>        Move bErr to Err
94255>>>        
94255>>>        Function_Return bOK
94256>>>    End_Function
94257>>>    
94257>>>    // Deletes all records for the passed sIntFileName value,
94257>>>    // from the piIntFilesFileNumber.
94257>>>    // Returns True if no errors occured.
94257>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94259>>>        Handle hTable
94259>>>        Boolean bOK bErr bFound
94259>>>        Integer iFileCol iIndex
94259>>>        String sVal
94259>>>        String[] asIntFile
94260>>>        
94260>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94261>>>        Move Err to bErr
94262>>>        Move False to Err
94263>>>        Move False to bOK
94264>>>        Move 2              to iFileCol
94265>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94266>>>        Get piIntFilesFileNumber to hTable  
94267>>>        Open hTable  
94269>>>                  
94269>>>        // Find the first record
94269>>>        Set_Field_Value hTable iFileCol to sIntFileName
94272>>>        Vfind hTable iIndex GE
94274>>>        Get_Field_Value hTable iFileCol to sVal
94277>>>        Move (Trim(Lowercase(sVal))) to sVal
94278>>>        Move (Found and sVal = sIntFileName) to bFound
94279>>>        While (bFound = True)
94283>>>            Delete hTable
94284>>>            Vfind hTable iIndex GT
94286>>>            Get_Field_Value hTable iFileCol to sVal
94289>>>            Move (Trim(Lowercase(sVal))) to sVal
94290>>>            Move (Found and sVal = sIntFileName) to bFound
94291>>>        Loop
94292>>>>
94292>>>        Unlock
94293>>>>
94293>>>        Close hTable
94294>>>        
94294>>>        Move (not(Err)) to bOK
94295>>>        Move bErr to Err
94296>>>        
94296>>>        Function_Return bOK
94297>>>    End_Function
94298>>>
94298>>>    // Returns all saved piIntFilesFileNumber records for the passed 
94298>>>    // sIntFileName value as a string array.
94298>>>    Function RetrieveIntFileData String sPath String sIntFileName Returns String[]
94300>>>        Handle hTable
94300>>>        Boolean bOK bErr bFound
94300>>>        Integer iFileCol iTextCol iIndex
94300>>>        String sVal sFileName
94300>>>        String[] asIntFile asEmptyArray
94302>>>        
94302>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94303>>>        Move Err to bErr
94304>>>        Move False to Err
94305>>>        Move False to bOK
94306>>>        Move 2              to iFileCol
94307>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94308>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94309>>>        Get piIntFilesFileNumber to hTable  
94310>>>        Open hTable  
94312>>>        
94312>>>        // Find the first record
94312>>>        Set_Field_Value hTable iFileCol to sIntFileName
94315>>>        Vfind hTable iIndex GE
94317>>>        Get_Field_Value hTable iFileCol to sFileName
94320>>>        Move (Trim(Lowercase(sFileName))) to sFileName
94321>>>        Move (Found and sFileName = sIntFileName) to bFound
94322>>>        While (bFound = True)
94326>>>            Get_Field_Value hTable iFileCol   to sFileName
94329>>>            Move (Trim(Lowercase(sFileName))) to sFileName
94330>>>            Move (Found and sFileName = sIntFileName) to bFound
94331>>>            If (bFound = True) Begin
94333>>>                Get_Field_Value hTable iTextCol to sVal
94336>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94337>>>            End
94337>>>>
94337>>>            Vfind hTable iIndex GT
94339>>>        Loop
94340>>>>
94340>>>        
94340>>>        Close hTable
94341>>>        Move (not(Err)) to bOK
94342>>>        If (bOK = False) Begin
94344>>>            Move asEmptyArray to asIntFile
94345>>>        End
94345>>>>
94345>>>        Move bErr to Err               
94346>>>        
94346>>>        Function_Return asIntFile
94347>>>    End_Function
94348>>>
94348>>>    // Reads the passed sIntFileName from disk and returns its value
94348>>>    // as a string array.
94348>>>    Function ReadIntFile String sPath String sIntFileName Returns String[]
94350>>>        String[] asIntFile       
94351>>>        String sFileName sLine
94351>>>        Integer iCh iSize iCount
94351>>>        
94351>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94352>>>        Get vFolderFormat sPath to sPath
94353>>>        If (not(sIntFileName contains ".")) Begin
94355>>>            Move (sIntFileName + ".int") to sIntFileName
94356>>>        End
94356>>>>
94356>>>        Move (sPath + sIntFileName) to sFileName
94357>>>        Get Seq_Open_input_Channel sFileName to iCh
94358>>>        If (iCh < 0) Begin
94360>>>            Function_Return asIntFile
94361>>>        End                                 
94361>>>>
94361>>>        
94361>>>        Repeat
94361>>>>
94361>>>            Readln channel iCh sLine
94363>>>            If (SeqEof = False) Begin
94365>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
94366>>>            End
94366>>>>
94366>>>        Until (SeqEof = True)
94368>>>        Send Seq_Close_Channel iCh    
94369>>>        
94369>>>        Function_Return asIntFile
94370>>>    End_Function
94371>>>    
94371>>>    // Reads the Filelist.cfg from memeory as a resource.
94371>>>    // The Filelist.cfg has been compiled into the program.
94371>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94373>>>        Integer iCh iCount
94373>>>        Number nByteCount
94373>>>        String[] asFileListArray sEmptyArray
94375>>>        String sLine
94375>>>        UChar[] uCharData
94376>>>        
94376>>>        Move False to Err
94377>>>        Get Seq_New_Channel to iCh
94378>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94380>>>            Error DFERR_PROGRAM 'No channel available...'
94381>>>>
94381>>>            Function_Return sEmptyArray
94382>>>        End
94382>>>>
94382>>>
94382>>>        // First decide the size of the script
94382>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94384>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94386>>>        Close_Input channel iCh
94388>>>        Send Seq_Release_Channel iCh
94389>>>
94389>>>        Function_Return uCharData
94390>>>    End_Function    
94391>>>    
94391>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94391>>>    // It does so by reading from a memory resource, as the file has
94391>>>    // been compiled into the program.
94391>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94393>>>        Boolean bOK bErr
94393>>>        Integer iSize iCh
94393>>>        
94393>>>        Move Err to bErr
94394>>>        Move False to Err
94395>>>        Move False to bOK
94396>>>        Move (SizeOfArray(asFileListArray)) to iSize
94397>>>        If (iSize = 0) Begin
94399>>>            Function_Return False
94400>>>        End
94400>>>>
94400>>>
94400>>>        Get Seq_New_Channel to iCh
94401>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94403>>>            Error DFERR_PROGRAM 'No channel available...'
94404>>>>
94404>>>            Function_Return False
94405>>>        End                      
94405>>>>
94405>>>        
94405>>>        Direct_Output channel iCh sFileListName
94407>>>        Writeln channel iCh asFileListArray
94410>>>                
94410>>>        Close_Input channel iCh
94412>>>        Send Seq_Release_Channel iCh
94413>>>        Move (not(Err)) to bOK
94414>>>        Move bErr to Err
94415>>>        
94415>>>        Function_Return bOK
94416>>>    End_Function
94417>>>
94417>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the piIntFilesFileNumber data table.
94417>>>    // It first deletes the .cch file (if any).
94417>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
94419>>>        Boolean bOK bFound bExists bErr
94419>>>        Integer iCh iSize iCount
94419>>>        String sFileName sCCHFileName sVal
94419>>>        String[] asIntFile
94420>>>        
94420>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94421>>>        Move Err to bErr   
94422>>>        Move False to Err
94423>>>        Move False to bOK
94424>>>
94424>>>        Get RetrieveIntFileData sDataPath sIntFileName to asIntFile
94425>>>        Move (SizeOfArray(asIntFile)) to iSize
94426>>>        If (iSize = 0) Begin
94428>>>            Function_Return False        
94429>>>        End                      
94429>>>>
94429>>>        Decrement iSize
94430>>>        
94430>>>        Get Seq_New_Channel to iCh
94431>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94433>>>            Function_Return False
94434>>>        End   
94434>>>>
94434>>>        
94434>>>        // Before we start to actually create the new .int file, make sure we delete
94434>>>        // the .cch file.                                     
94434>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94435>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94436>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94437>>>        If (bExists = True) Begin
94439>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94440>>>            If (bOK = False) Begin
94442>>>                Function_Return False
94443>>>            End
94443>>>>
94443>>>        End
94443>>>>
94443>>>        
94443>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94445>>>        For iCount from 0 to iSize
94451>>>>
94451>>>            Writeln channel iCh asIntFile[iCount]
94454>>>        Loop
94455>>>>
94455>>>        
94455>>>        Close_Input channel iCh
94457>>>        Send Seq_Release_Channel iCh
94458>>>        Move (not(Err)) to bOK
94459>>>        Move bErr to Err
94460>>>        
94460>>>        Function_Return bOK
94461>>>    End_Function   
94462>>>              
94462>>>    // Automatically writes .int files to disk that is missing.
94462>>>    // We only need to make this test this once, but because the message is called
94462>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94462>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94462>>>    Procedure AutoCreateIntFilesTable
94464>>>        Integer hTable 
94464>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
94464>>>        String sInfoTxt 
94464>>>        
94464>>>        Get piIntFilesFileNumber to hTable  
94465>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94466>>>        If (bIntFilesTablesCheckDone = True) Begin
94468>>>            Procedure_Return
94469>>>        End
94469>>>>
94469>>>
94469>>>        If (hTable < 1) Begin
94471>>>            Set Private.pbIntFilesTablesCheckDone to False
94472>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94473>>>            Error DFERR_PROGRAM "The piIntFilesFileNumber has been set! The property MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94474>>>>
94474>>>            Send Exit_Application
94475>>>        End
94475>>>>
94475>>>        
94475>>>        Get IsIntFileTable hTable to bTableExists
94476>>>        If (bTableExists = True) Begin
94478>>>            Set Private.pbIntFilesTablesCheckDone to True
94479>>>            Procedure_Return
94480>>>        End
94480>>>>
94480>>>
94480>>>        Send SubCreateIntFilesTable hTable
94481>>>    End_Procedure
94482>>>                
94482>>>    Procedure SubCreateIntFilesTable Handle hTable
94484>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94484>>>        Boolean bTableExists bOK bUseConnectionID bExists
94484>>>        tAPIColumn[] APIColumn
94484>>>        tAPIColumn[] APIColumn
94485>>>
94485>>>        Get IsIntFileTable hTable to bTableExists
94486>>>        If (bTableExists = True) Begin
94488>>>            Procedure_Return
94489>>>        End
94489>>>>
94489>>>
94489>>>        Move False to Err
94490>>>        Get psDriverID to sDriverID
94491>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94492>>>
94492>>>        Move CS_IntFilesTableLogicalName to sTableName
94493>>>
94493>>>        Move 1                  to APIColumn[0].iFieldNumber
94494>>>        Move "ID"               to APIColumn[0].sFieldName
94495>>>        Move DF_BCD             to APIColumn[0].iType
94496>>>        Move False              to APIColumn[0].bIsSQLType
94497>>>        Move 12                 to APIColumn[0].iLength
94498>>>        Move 0                  to APIColumn[0].iPrecision
94499>>>
94499>>>        Move 2                  to APIColumn[1].iFieldNumber
94500>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94501>>>        Move DF_ASCII           to APIColumn[1].iType
94502>>>        Move False              to APIColumn[1].bIsSQLType
94503>>>        Move 50                 to APIColumn[1].iLength
94504>>>        Move 0                  to APIColumn[1].iPrecision
94505>>>
94505>>>        Move 3                  to APIColumn[2].iFieldNumber
94506>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94507>>>        Move DF_ASCII           to APIColumn[2].iType
94508>>>        Move False              to APIColumn[2].bIsSQLType
94509>>>        Move 100                to APIColumn[2].iLength
94510>>>        Move 0                  to APIColumn[2].iPrecision
94511>>>
94511>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94512>>>        
94512>>>        If (bOK = True) Begin
94514>>>//        If (bOK = True and Err = False) Begin
94514>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94515>>>        End
94515>>>>
94515>>>        Else Begin
94516>>>            Set Private.pbIntFilesTablesCheckDone to False
94517>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94518>>>            Error DFERR_PROGRAM sInfoTxt
94519>>>>
94519>>>            Procedure_Return
94520>>>        End
94520>>>>
94520>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94521>>>        
94521>>>        Open hTable
94523>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94524>>>        If (bOK = True) Begin
94526>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94527>>>        End
94527>>>>
94527>>>        If (bOK = False) Begin
94529>>>            Set Private.pbIntFilesTablesCheckDone to False
94530>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94531>>>            Error DFERR_PROGRAM sInfoTxt
94532>>>>
94532>>>            Procedure_Return
94533>>>        End
94533>>>>
94533>>>        
94533>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94533>>>        If (sDriverID <> DATAFLEX_ID) Begin
94535>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94536>>>            Get vFolderFormat sDataPath to sDataPath
94537>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
94538>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
94539>>>            If (bExists = True) Begin
94541>>>                Move CS_IntFilesTableLogicalName to sTableName
94542>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94543>>>                If (bExists = True) Begin
94545>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94546>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94547>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94548>>>                End
94548>>>>
94548>>>            End
94548>>>>
94548>>>        End
94548>>>>
94548>>>        
94548>>>        Set Private.pbIntFilesTablesCheckDone to True
94549>>>    End_Procedure
94550>>>
94550>>>    Procedure AutoCreateDbVersionTable
94552>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94552>>>        Integer iDbVersionFileNumber
94552>>>
94552>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94553>>>        If (bDbVersionCheckDone = True) Begin
94555>>>            Procedure_Return
94556>>>        End
94556>>>>
94556>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94557>>>        If (bUseCustomDbVersion = True) Begin
94559>>>            Procedure_Return
94560>>>        End
94560>>>>
94560>>>
94560>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94561>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94562>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
94564>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94565>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94566>>>>
94566>>>            Send Exit_Application
94567>>>        End
94567>>>>
94567>>>
94567>>>        If (bAutoCreateDbVersionTable = True) Begin
94569>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94570>>>            If (bTableExists = True) Begin
94572>>>                Set Private.pbDbVersionCheckDone to True
94573>>>                Procedure_Return
94574>>>            End
94574>>>>
94574>>>            Send CreateDbVersionTable iDbVersionFileNumber
94575>>>        End
94575>>>>
94575>>>
94575>>>        // We only need to these DbVersion checks once, but because this message is called
94575>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94575>>>        // we use a property to only run these tests once.
94575>>>        Set Private.pbDbVersionCheckDone to True
94576>>>    End_Procedure
94577>>>
94577>>>    Procedure CreateDbVersionTable Handle hTable
94579>>>        String sTableName sColumnName sInfoTxt sDriverID 
94579>>>        Boolean bTableExists bOK bUseConnectionID
94579>>>        tAPIColumn[] APIColumn
94579>>>        tAPIColumn[] APIColumn
94580>>>
94580>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94581>>>        If (bTableExists = True) Begin
94583>>>            Procedure_Return
94584>>>        End
94584>>>>
94584>>>
94584>>>        Get psDriverID to sDriverID
94585>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94586>>>
94586>>>        Move "DbVersion"        to sTableName
94587>>>        Move 1                  to APIColumn[0].iFieldNumber
94588>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94589>>>        Move DF_BCD             to APIColumn[0].iType
94590>>>        Move False              to APIColumn[0].bIsSQLType
94591>>>        Move 4                  to APIColumn[0].iLength
94592>>>        Move 2                  to APIColumn[0].iPrecision
94593>>>
94593>>>        Move False to Err                                
94594>>>        
94594>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94594>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94594>>>        Set psDriverID to DATAFLEX_ID
94595>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94596>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94597>>>        Set psDriverID to sDriverID
94598>>>        
94598>>>        If (bOK = True and Err = False) Begin
94600>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94601>>>        End
94601>>>>
94601>>>        Else Begin
94602>>>            Move "The DbVersion table creation failed!" to sInfoTxt
94603>>>        End
94603>>>>
94603>>>
94603>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94604>>>    End_Procedure
94605>>>
94605>>>    Procedure Set pbVerboseState Boolean bVerboseState
94607>>>        Handle ho
94607>>>        Get phoLogFile to ho
94608>>>        Set pbVerboseState of ho to bVerboseState
94609>>>    End_Procedure
94610>>>
94610>>>    Function pbVerboseState Returns Boolean
94612>>>        Boolean bVerboseState
94612>>>        Handle ho
94612>>>        Get phoLogFile to ho
94613>>>        Get pbVerboseState of ho to bVerboseState
94614>>>        Function_Return bVerboseState
94615>>>    End_Function
94616>>>
94616>>>    // Callback functionality used when e.g. calling driver functions directly.
94616>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94616>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94618>>>        Integer iPerc
94618>>>        Number nReady nTotal nVersion
94618>>>        Boolean bVerboseState
94618>>>        Handle hoLogFile
94618>>>
94618>>>        Get pbVerboseState to bVerboseState
94619>>>        Get pnCurrentVersionUpdate to nVersion
94620>>>        Get phoLogFile     to hoLogFile
94621>>>        Send DoAdvance of ghoProgressBar
94622>>>
94622>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94624>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94625>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94626>>>        End
94626>>>>
94626>>>        If (sCallback_Text contains "Creating index") Begin
94628>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94629>>>        End
94629>>>>
94629>>>        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
94631>>>            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94632>>>        End
94632>>>>
94632>>>        If (iCallback_Type <> DF_Message_Progress_Value) Begin
94634>>>            Set Message_Text of ghoStatusPanel to sCallback_Text
94635>>>            Set Action_Text  of ghoStatusPanel to ""
94636>>>        End
94636>>>>
94636>>>
94636>>>        Case Begin
94636>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94638>>>                Set Action_Text  of ghoStatusPanel to ""
94639>>>                Case Break
94640>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94643>>>                //*** Interpret numbers
94643>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94644>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94645>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94646>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94647>>>                Set piPosition of ghoProgressBar to iPerc
94648>>>                Case Break
94649>>>//            Case Else
94649>>>//                Set Message_Text of ghoStatusPanel to ""
94649>>>//                Set Action_Text  of ghoStatusPanel to ""
94649>>>        Case End
94649>>>
94649>>>        Send ProcessEvents of ghoStatusPanel
94650>>>        Function_Return False
94651>>>    End_Function
94652>>>
94652>>>    // This was made to be a procedure/function pair so we
94652>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94652>>>
94652>>>    Procedure Set piDbType Integer iDbType
94654>>>        If (ghoSQLConnectionHandler = 0) Begin
94656>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94657>>>>
94657>>>            Procedure_Return
94658>>>        End
94658>>>>
94658>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94659>>>    End_Procedure
94660>>>
94660>>>    Function piDbType Returns Integer
94662>>>        Integer iDbType
94662>>>        If (ghoSQLConnectionHandler = 0) Begin
94664>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94665>>>>
94665>>>            Function_Return ""
94666>>>        End
94666>>>>
94666>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94667>>>        Function_Return iDbType
94668>>>    End_Function
94669>>>
94669>>>    Procedure Set psDriverID String sDriverID
94671>>>        If (ghoSQLConnectionHandler = 0) Begin
94673>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94674>>>>
94674>>>            Procedure_Return
94675>>>        End
94675>>>>
94675>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94676>>>    End_Procedure
94677>>>
94677>>>    Function psDriverID Returns String
94679>>>        String sValue
94679>>>        If (ghoSQLConnectionHandler = 0) Begin
94681>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94682>>>>
94682>>>            Function_Return ""
94683>>>        End
94683>>>>
94683>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94684>>>        Function_Return sValue
94685>>>    End_Function
94686>>>    
94686>>>    Procedure Set pbUseDriverCacheFiles Boolean bUseDriverCacheFiles
94688>>>        If (ghoSQLConnectionHandler = 0) Begin
94690>>>            Procedure_Return
94691>>>        End  
94691>>>>
94691>>>        Set Private.pbUseDriverCacheFiles of ghoSQLConnectionHandler to bUseDriverCacheFiles
94692>>>    End_Procedure
94693>>>
94693>>>    Function pbUseDriverCacheFiles Returns Boolean
94695>>>        String sDriverID
94695>>>        Integer iDriver
94695>>>        Boolean bUseDriverCacheFiles        
94695>>>        Move True to bUseDriverCacheFiles
94696>>>        If (ghoSQLConnectionHandler = 0) Begin
94698>>>            Function_Return False
94699>>>        End
94699>>>>
94699>>>        Get psDriverID of ghoSQLConnectionHandler to sDriverID
94700>>>        If (sDriverID = DATAFLEX_ID) Begin
94702>>>            Function_Return False
94703>>>        End
94703>>>>
94703>>>        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
94704>>>        If (iDriver <> 0) Begin
94706>>>            Get_Attribute DF_DRIVER_USE_CACHE of iDriver to bUseDriverCacheFiles 
94709>>>        End
94709>>>>
94709>>>        Function_Return bUseDriverCacheFiles 
94710>>>    End_Function
94711>>>
94711>>>    Procedure Set pbIgnoreDriverUcaseSupport Boolean bState
94713>>>        If (ghoSQLConnectionHandler = 0) Begin
94715>>>            Procedure_Return
94716>>>        End  
94716>>>>
94716>>>        Set Private.pbIgnoreDriverUcaseSupport of ghoSQLConnectionHandler to bState
94717>>>    End_Procedure
94718>>>
94718>>>    Function pbIgnoreDriverUcaseSupport Returns Boolean
94720>>>        String sDriverID
94720>>>        Integer iDriver
94720>>>        Boolean bIgnoreDriverUcaseSupport        
94720>>>        Move True to bIgnoreDriverUcaseSupport
94721>>>        If (ghoSQLConnectionHandler = 0) Begin
94723>>>            Function_Return False
94724>>>        End
94724>>>>
94724>>>        Get psDriverID of ghoSQLConnectionHandler to sDriverID
94725>>>        If (sDriverID = DATAFLEX_ID) Begin
94727>>>            Function_Return False
94728>>>        End
94728>>>>
94728>>>        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
94729>>>        If (iDriver <> 0) Begin
94731>>>            Get_Attribute DF_DRIVER_IGNORE_UCASE_SUPPORT of iDriver to bIgnoreDriverUcaseSupport 
94734>>>        End
94734>>>>
94734>>>        Function_Return bIgnoreDriverUcaseSupport 
94735>>>    End_Function
94736>>>
94736>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94738>>>        If (ghoSQLConnectionHandler = 0) Begin
94740>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94741>>>>
94741>>>            Procedure_Return
94742>>>        End
94742>>>>
94742>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94743>>>    End_Procedure
94744>>>
94744>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94746>>>        Integer iRetval
94746>>>        If (ghoSQLConnectionHandler = 0) Begin
94748>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94749>>>>
94749>>>            Function_Return 2
94750>>>        End
94750>>>>
94750>>>
94750>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94751>>>        Function_Return iRetval
94752>>>    End_Function
94753>>>
94753>>>    Procedure Set psConnectionID String sValue
94755>>>        If (ghoSQLConnectionHandler = 0) Begin
94757>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94758>>>>
94758>>>            Procedure_Return
94759>>>        End
94759>>>>
94759>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94760>>>    End_Procedure
94761>>>
94761>>>    Function psConnectionID Returns String
94763>>>        String sValue
94763>>>        If (ghoSQLConnectionHandler = 0) Begin
94765>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94766>>>>
94766>>>            Function_Return ""
94767>>>        End
94767>>>>
94767>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94768>>>
94768>>>        Function_Return sValue
94769>>>    End_Function
94770>>>
94770>>>    // These "properties" are settings of the cCLIHandler class, but are being
94770>>>    // relayed to the ghoSQLConnectionHandler object
94770>>>    // simply by changing one of its parameters.
94770>>>    Procedure Set psServer String sValue
94772>>>        If (ghoSQLConnectionHandler = 0) Begin
94774>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94775>>>>
94775>>>            Procedure_Return
94776>>>        End
94776>>>>
94776>>>        Set psServer of ghoSQLConnectionHandler to sValue
94777>>>    End_Procedure
94778>>>
94778>>>    Function psServer Returns String
94780>>>        String sValue
94780>>>        If (ghoSQLConnectionHandler = 0) Begin
94782>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94783>>>>
94783>>>            Function_Return ""
94784>>>        End
94784>>>>
94784>>>        Get psServer of ghoSQLConnectionHandler to sValue
94785>>>
94785>>>        Function_Return sValue
94786>>>    End_Function
94787>>>
94787>>>    Procedure Set psDatabase String sValue
94789>>>        If (ghoSQLConnectionHandler = 0) Begin
94791>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94792>>>>
94792>>>            Procedure_Return
94793>>>        End
94793>>>>
94793>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94794>>>    End_Procedure
94795>>>
94795>>>    Function psDatabase Returns String
94797>>>        String sValue
94797>>>        If (ghoSQLConnectionHandler = 0) Begin
94799>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94800>>>>
94800>>>            Function_Return ""
94801>>>        End
94801>>>>
94801>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94802>>>
94802>>>        Function_Return sValue
94803>>>    End_Function
94804>>>
94804>>>    Procedure Set psUserID String sValue
94806>>>        If (ghoSQLConnectionHandler = 0) Begin
94808>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94809>>>>
94809>>>            Procedure_Return
94810>>>        End
94810>>>>
94810>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94811>>>    End_Procedure
94812>>>
94812>>>    Function psUserID Returns String
94814>>>        String sValue
94814>>>        If (ghoSQLConnectionHandler = 0) Begin
94816>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94817>>>>
94817>>>            Function_Return ""
94818>>>        End
94818>>>>
94818>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94819>>>
94819>>>        Function_Return sValue
94820>>>    End_Function
94821>>>
94821>>>    Procedure Set psPassword String sValue
94823>>>        If (ghoSQLConnectionHandler = 0) Begin
94825>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94826>>>>
94826>>>            Procedure_Return
94827>>>        End
94827>>>>
94827>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94828>>>    End_Procedure
94829>>>
94829>>>    Function psPassword Returns String
94831>>>        String sValue
94831>>>        If (ghoSQLConnectionHandler = 0) Begin
94833>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94834>>>>
94834>>>            Function_Return ""
94835>>>        End
94835>>>>
94835>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94836>>>
94836>>>        Function_Return sValue
94837>>>    End_Function
94838>>>
94838>>>    Procedure Set pbTrusted Boolean bValue
94840>>>        If (ghoSQLConnectionHandler = 0) Begin
94842>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94843>>>>
94843>>>            Procedure_Return
94844>>>        End
94844>>>>
94844>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94845>>>    End_Procedure
94846>>>
94846>>>    Function pbTrusted Returns Boolean
94848>>>        Boolean bValue
94848>>>        If (ghoSQLConnectionHandler = 0) Begin
94850>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94851>>>>
94851>>>            Function_Return False
94852>>>        End
94852>>>>
94852>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94853>>>
94853>>>        Function_Return bValue
94854>>>    End_Function
94855>>>
94855>>>    Procedure Set psConnectionString String sValue
94857>>>        If (ghoSQLConnectionHandler = 0) Begin
94859>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94860>>>>
94860>>>            Procedure_Return
94861>>>        End
94861>>>>
94861>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94862>>>    End_Procedure
94863>>>
94863>>>    Function psConnectionString Returns String
94865>>>        String sValue
94865>>>        If (ghoSQLConnectionHandler = 0) Begin
94867>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94868>>>>
94868>>>            Function_Return ""
94869>>>        End
94869>>>>
94869>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94870>>>
94870>>>        Function_Return sValue
94871>>>    End_Function
94872>>>
94872>>>    Function piConnectionOptions Returns Integer
94874>>>        Integer iValue
94874>>>        If (ghoSQLConnectionHandler = 0) Begin
94876>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94877>>>>
94877>>>            Function_Return 0
94878>>>        End
94878>>>>
94878>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94879>>>
94879>>>        Function_Return iValue
94880>>>    End_Function
94881>>>
94881>>>
94881>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94883>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94884>>>    End_Procedure
94885>>>
94885>>>    Function pbCheckDataFlexUserCount Returns Boolean
94887>>>        Boolean bState
94887>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94888>>>        Function_Return bState
94889>>>    End_Function
94890>>>
94890>>>    Procedure Set psLogTextFile String sValue
94892>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94893>>>    End_Procedure
94894>>>
94894>>>    Function psLogTextFile Returns String
94896>>>        String sValue
94896>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94897>>>        Function_Return sValue
94898>>>    End_Function
94899>>>
94899>>>    Procedure Set psEditorProgram String sValue
94901>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94902>>>    End_Procedure
94903>>>
94903>>>    Function psEditorProgram Returns String
94905>>>        String sValue
94905>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94906>>>        Function_Return sValue
94907>>>    End_Function
94908>>>
94908>>>    Procedure Set pbUseDataTableLog Boolean bState
94910>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94911>>>    End_Procedure
94912>>>
94912>>>    Function pbUseDataTableLog Returns Boolean
94914>>>        Boolean bState
94914>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94915>>>        Function_Return bState
94916>>>    End_Function
94917>>>
94917>>>    Procedure Set pbQuickWrite Boolean bState
94919>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94920>>>    End_Procedure
94921>>>
94921>>>    Function pbQuickWrite Returns Boolean
94923>>>        Boolean bState
94923>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94924>>>        Function_Return bState
94925>>>    End_Function
94926>>>
94926>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94928>>>        Boolean bUpdateVersionObjectError bVerboseState
94928>>>        Integer iSize iCount
94928>>>        Number nVersion
94928>>>        String[] aSQLQueryMessages
94929>>>
94929>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94930>>>        Set Private.pbDatabaseWasUpdated to bState
94931>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94931>>>        // to the log that it was OK.
94931>>>        If (bUpdateVersionObjectError = False) Begin
94933>>>            Get pnCurrentVersionUpdate to nVersion
94934>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94935>>>        End
94935>>>>
94935>>>
94935>>>        Get pbVerboseState to bVerboseState
94936>>>        If (bVerboseState = True) Begin
94938>>>            Get paSQLQueryMessages to aSQLQueryMessages
94939>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94940>>>            Decrement iSize
94941>>>            For iCount from 0 to iSize
94947>>>>
94947>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94948>>>            Loop
94949>>>>
94949>>>        End
94949>>>>
94949>>>
94949>>>    End_Procedure 
94950>>>
94950>>>    // Returns the current DbVersion value (system table)
94950>>>    // Note: If the DbVersion table doesn't exist yet,
94950>>>    //       it will return -1.
94950>>>    Function CurrentDbVersion Returns Number
94952>>>        Boolean bInUse bActive
94952>>>        Integer iStatus iColumn
94952>>>        Number nVersion
94952>>>        Handle hTable
94952>>>        
94952>>>        Move -1 to nVersion
94953>>>        Get piDbVersionFileNumber  to hTable
94954>>>        Get piDbVersionFieldNumber to iColumn
94955>>>        Get _UtilTableNumberIsInUse hTable to bInUse
94956>>>        If (bInUse = True) Begin
94958>>>            Open hTable
94960>>>            Get_Attribute DF_FILE_STATUS of hTable to iStatus
94963>>>            If (iStatus = DF_FILE_INACTIVE) Begin
94965>>>                Vfind hTable 0 GT
94967>>>            End
94967>>>>
94967>>>            Get_Field_Value hTable iColumn to nVersion
94970>>>        End
94970>>>>
94970>>>        Function_Return nVersion
94971>>>    End_Function
94972>>>         
94972>>>    
94972>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94974>>>        Set Private.piDbVersionFileNumber to iFileNumber
94975>>>    End_Procedure                                         
94976>>>    
94976>>>    Function piDbVersionFileNumber Returns Integer
94978>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94979>>>    End_Function
94980>>>
94980>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94982>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94983>>>    End_Procedure                                         
94984>>>    
94984>>>    Function piDbVersionFieldNumber Returns Integer
94986>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94987>>>    End_Function
94988>>>
94988>>>    Function pbDatabaseWasUpdated Returns Boolean
94990>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94991>>>    End_Function
94992>>>    
94992>>>    // Takes a string array as parameter and returns a new
94992>>>    // string array without any empty rows and all rows trimmed.
94992>>>    // This is e.g. used by the HasIntFileChanged message to compare
94992>>>    // two .int file arrays. 
94992>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
94994>>>        Integer iSize iCount iRow
94994>>>        String sVal        
94994>>>        String[] asRetValArray
94995>>>        
94995>>>        Move (SizeOfArray(asIntFile)) to iSize
94996>>>        If (iSize = 0) Begin
94998>>>            Function_Return asRetValArray
94999>>>        End                          
94999>>>>
94999>>>        Decrement iSize         
95000>>>        Move 0 to iRow
95001>>>        
95001>>>        For iCount from 0  to iSize
95007>>>>
95007>>>            Move asIntFile[iCount] to sVal
95008>>>            Move (Trim(sVal)) to sVal
95009>>>            If (sVal <> "") Begin
95011>>>                Move sVal to asRetValArray[iRow]
95012>>>                Increment iRow        
95013>>>            End
95013>>>>
95013>>>        Loop
95014>>>>
95014>>>        
95014>>>        Function_Return asRetValArray
95015>>>    End_Function
95016>>>    
95016>>>    //
95016>>>    Procedure ReinitializeFramework  
95018>>>        tDbVersionInfo[] aDbVersionInfoArray
95018>>>        tDbVersionInfo[] aDbVersionInfoArray
95019>>>        Handle hoDbVersionObject
95019>>>        Integer iSize iCount
95019>>>        
95019>>>        Set Private.pbDatabaseUpdateStarted to False
95020>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
95021>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
95022>>>        Decrement iSize
95023>>>        
95023>>>        For iCount from 0 to iSize
95029>>>>
95029>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
95030>>>            Send ProcessUpdate                  of hoDbVersionObject False
95031>>>        Loop
95032>>>>
95032>>>        Send Cleanup
95033>>>    End_Procedure
95034>>>    
95034>>>    Procedure StartStatusPanel String sMsg String sMsg2 Integer iSze
95036>>>        Integer iSize
95036>>>        String sMessage sMessage2
95036>>>        
95036>>>        // Make it optional to pass an argument
95036>>>        If (num_arguments > 0) Begin
95038>>>            Move sMsg to sMessage
95039>>>        End
95039>>>>
95039>>>
95039>>>        // Make it optional to pass a second argument
95039>>>        If (num_arguments > 1) Begin
95041>>>            Move sMsg2 to sMessage2
95042>>>        End
95042>>>>
95042>>>
95042>>>        Move 0 to iSize
95043>>>        // Make it optional to pass a third argument
95043>>>        If (num_arguments > 2) Begin
95045>>>            Move iSze to iSize
95046>>>        End                   
95046>>>>
95046>>>        If (iSize = -1) Begin
95048>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
95049>>>        End
95049>>>>
95049>>>        If (iSize <> 0) Begin
95051>>>            Set Progress_Bar_Visible_State of ghoStatusPanel to True
95052>>>            Set piMaximum                  of ghoStatusPanel to iSize 
95053>>>            Set piAdvanceBy                of ghoStatusPanel to 1
95054>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to True
95055>>>        End
95055>>>>
95055>>>
95055>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
95056>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) sMessage sMessage2 
95057>>>        Send Update_StatusPanel of ghoStatusPanel ""
95058>>>        Send Start_StatusPanel of ghoStatusPanel
95059>>>    End_Procedure
95060>>>    
95060>>>    Procedure StopStatusPanel 
95062>>>        Send Stop_StatusPanel of ghoStatusPanel
95063>>>    End_Procedure
95064>>>    
95064>>>    // This event is triggered by the cDbUpdateVersion child class when
95064>>>    // a database change is to be started, and is considered private.
95064>>>    // It is only executed once for the first cDbUpateVersion object!
95064>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
95066>>>        Boolean bDatabaseUpdateStarted bOK bExists bCheckDataFlexUserCount
95066>>>        Integer iRetval iDataFlexUsers iUserCount
95066>>>        Handle hoUserCountSystem
95066>>>        tUserCount UserCount
95066>>>        tUserCount UserCount
95066>>>        DateTime dtUpdateStarted
95066>>>        tSQLConnection SQLConnection
95066>>>        tSQLConnection SQLConnection
95066>>>
95066>>>        // *Important:* If we already started the update; we do no further checking.
95066>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
95067>>>        If (bDatabaseUpdateStarted = True) Begin
95069>>>            Procedure_Return
95070>>>        End
95070>>>>
95070>>>
95070>>>        // If not silent mode; Ask user if OK to start database update.
95070>>>        If (pbSilentMode(Self) = False) Begin
95072>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
95073>>>            If (iRetval <> MBR_Yes) Begin
95075>>>                Send Exit_Application
95076>>>            End
95076>>>>
95076>>>        End
95076>>>>
95076>>>        
95076>>>        Send StartStatusPanel "" "" 1
95077>>>        // This will save the status of all open tables including Master/Alias settings,
95077>>>        // so we can restore them later;
95077>>>        Send SaveOpenTables
95078>>>
95078>>>        Move 0 to iDataFlexUsers
95079>>>        // Make various tests to check that the database is not in use.
95079>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bOK
95080>>>        // We also use our own user counting mechanism to guard against the
95080>>>        // database isn't opened already as we need exclusive access to the tables.:
95080>>>        Get phoUserCountSystem to hoUserCountSystem
95081>>>        Get CheckUserCount of hoUserCountSystem to UserCount
95082>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
95083>>>
95083>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
95084>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
95084>>>        If (bCheckDataFlexUserCount = True) Begin
95086>>>            Get_Current_User_Count to iDataFlexUsers
95087>>>            // For some reason DataFlex - in some cases - might think that 2 users
95087>>>            // are in use while debugging from the Studio.
95087>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
95089>>>                Decrement iDataFlexUsers
95090>>>            End
95090>>>>
95090>>>        End 
95090>>>>
95090>>>        Else Begin
95091>>>            Move 1 to iDataFlexUsers 
95092>>>            Move 1 to iUserCount
95093>>>            Move True to bOK
95094>>>        End
95094>>>>
95094>>>
95094>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
95096>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
95097>>>            If (iRetval <> MBR_Yes) Begin
95099>>>                Send Exit_Application
95100>>>            End
95100>>>>
95100>>>        End
95100>>>>
95100>>>
95100>>>        If (bOK = False or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
95102>>>            Send Stop_Box CS_DUF_DatabaseInUseText
95103>>>            Send Exit_Application
95104>>>        End
95104>>>>
95104>>>
95104>>>        // This will put a look on the DbUpdateLock.ucf file.
95104>>>        // It is released when the update process is finished
95104>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
95105>>>
95105>>>        Move (CurrentDateTime()) to dtUpdateStarted
95106>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
95107>>>        Set Private.pbDatabaseUpdateStarted to True
95108>>>
95108>>>        // We need to close all tables before starting to make changes.
95108>>>        Close DF_ALL DF_PERMANENT
95109>>>
95109>>>        // If these properties has not exclicitly been set in the object, set them
95109>>>        // to settings from the SQLConnections.ini file;
95109>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95110>>>        If (psSchema(Self) = "") Begin
95112>>>            Set psSchema            to SQLConnection.sSchema
95113>>>        End
95113>>>>
95113>>>        If (psBaseTableSpace(Self) = "") Begin
95115>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
95116>>>        End
95116>>>>
95116>>>        If (psLongTableSpace(Self) = "") Begin
95118>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
95119>>>        End
95119>>>>
95119>>>        If (psIndexTableSpace(Self) = "") Begin
95121>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
95122>>>        End
95122>>>>
95122>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
95124>>>            Procedure_Return
95125>>>        End
95125>>>>
95125>>>
95125>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
95126>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
95128>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95129>>>            Send StopStatusPanel
95130>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
95130>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
95131>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
95131>>>            Send Exit_Application
95132>>>        End
95132>>>>
95132>>>    End_Procedure
95133>>>
95133>>>    // *** Hook message for pre-processing ***
95133>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
95133>>>    // Aka, when another table than the standard "DbVersion" is used.
95133>>>    Procedure OnCreateCustomDbVersionTable
95135>>>    End_Procedure
95136>>>    
95136>>>    // *** Hook message for pre-processing ***
95136>>>    // The programmer can use this event for putting code that
95136>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
95136>>>    // child objects are executed.
95136>>>    Procedure OnPreUpdate
95138>>>    End_Procedure
95139>>>
95139>>>    // *** Hook message for post-processing ***
95139>>>    // The programmer should use this event for putting code that
95139>>>    // needs to be executed _after_ all database updates have finished.
95139>>>    Procedure OnPostUpdate
95141>>>    End_Procedure
95142>>>
95142>>>    // *** Hook message for custom DbVersion record find ***
95142>>>    // The programmer can use this event for putting code that
95142>>>    // needs to be executed to find a *custom* DbVersion table record.
95142>>>    // By default the DbVersion table is used but this can be
95142>>>    // customized by adding this line to the code;
95142>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
95142>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
95142>>>    //       to save the current database version to. Only if you use your own
95142>>>    //       table _and_ it is not a system table (contains only one record).
95142>>>    Procedure OnFindVersionRecord
95144>>>        // Open MyTable
95144>>>        // Move xx to MyTable.Field1
95144>>>        // Move yy to MyTable.Field2
95144>>>        // Find le MyTable by Index.x
95144>>>    End_Procedure
95145>>>
95145>>>    // Hook event for writing header error text (pre-update) to
95145>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
95145>>>    // Don't forget to Open the table first (!) as all
95145>>>    // tables have been closed at this stage.
95145>>>    // The start date & time is passed.
95145>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
95147>>>    End_Procedure
95148>>>
95148>>>    // Hook event to log errors to a database table.
95148>>>    // Only called if the pbUseDataTableLog = True.
95148>>>    // Don't forget to Open the table first (!) as all
95148>>>    // tables have been closed at this stage.
95148>>>    // If pbQuickWrite = True the DbUpdateErrorArray
95148>>>    // will contain just one row, as it is called for each error
95148>>>    // that occurred. Else it is called once at the end after all updates
95148>>>    // have run and contains all errors.
95148>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
95150>>>    End_Procedure
95151>>>
95151>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
95151>>>    Procedure Cleanup
95153>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
95153>>>        String sErrorText
95153>>>        
95153>>>        Move "" to sErrorText
95154>>>        Send AutoCreateDbVersionTable
95155>>>        Send RestoreOpenTables
95156>>>
95156>>>        // The function library have two purposes; one is to use it in the
95156>>>        // Database Update Framework, but it can also be used on its own.
95156>>>        // If that is the case it has its own error handling system, which
95156>>>        // we temporarily disbled when running updates because we have
95156>>>        // error handling/logging here too... We now restore its setting.
95156>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
95158>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
95159>>>        End
95159>>>>
95159>>>        Set pbHandleQueryErrors to True
95160>>>
95160>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
95161>>>        Get pbDbUpdateErrorHasOccured to bError
95162>>>        // Note: We make backup of .int files even if an error occured.
95162>>>        If (bDatabaseWasUpdated = True) Begin
95164>>>            // Check/create/update *.int files backup table:
95164>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
95165>>>            If (bUseIntFilesBackup = True) Begin
95167>>>                Get SaveUpdateIntFiles (&sErrorText) to bOK
95168>>>                If (bOK = False) Begin
95170>>>                    Send LogError sErrorText True
95171>>>                End
95171>>>>
95171>>>                Else If (sErrorText <> "") Begin
95174>>>                    Send LogError sErrorText False
95175>>>                End
95175>>>>
95175>>>            End
95175>>>>
95175>>>        End            
95175>>>>
95175>>>            
95175>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
95177>>>
95177>>>            // We should always create the log as it also contains info about
95177>>>            // the update being successful.
95177>>>            Send WriteErrorLog of (phoLogFile(Self))
95178>>>
95178>>>            // This is a programmer's hook message:
95178>>>            Send OnPostUpdate
95179>>>
95179>>>            Send StopStatusPanel
95180>>>            If (pbSilentMode(Self) = False) Begin
95182>>>                If (bError = True) Begin
95184>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
95186>>>                        Send ShowErrorLog of (phoLogFile(Self))
95187>>>                    End
95187>>>>
95187>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
95188>>>                    Send Exit_Application
95189>>>                End
95189>>>>
95189>>>                Else Begin
95190>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
95192>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
95193>>>                    End
95193>>>>
95193>>>                    Else Begin
95194>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
95195>>>                    End
95195>>>>
95195>>>                End
95195>>>>
95195>>>            End
95195>>>>
95195>>>        End
95195>>>>
95195>>>
95195>>>        // Restore the standard error handler:
95195>>>        Get piOrgErrorHandlerID to Error_Object_Id
95196>>>    End_Procedure
95197>>>
95197>>>    // We do this _before_ we close the database to make changes, and save
95197>>>    // all 'Master' & 'Alias' tables settings so we can restore when
95197>>>    // we reopen the database.
95197>>>    Procedure SaveOpenTables
95199>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95199>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95200>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
95201>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95202>>>    End_Procedure
95203>>>
95203>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
95203>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
95203>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
95205>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95205>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95206>>>        Integer hTable iMasterAliasType iSize
95206>>>        Boolean bOpen
95206>>>
95206>>>        Move 0 to hTable
95207>>>        Repeat
95207>>>>
95207>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95210>>>            If (hTable <> 0) Begin
95212>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95215>>>                If (bOpen = True) Begin
95217>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
95220>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95221>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
95222>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
95223>>>                End
95223>>>>
95223>>>            End
95223>>>>
95223>>>        Until (hTable = 0)
95225>>>
95225>>>        Function_Return aDbUpdateHandlerMasterAlias
95226>>>    End_Function
95227>>>
95227>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
95227>>>    // Takes one parameter:
95227>>>    //   A struct array with all master & alias
95227>>>    Procedure RestoreOpenTables
95229>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95229>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95230>>>        Integer hTable iFileAlias iSize iCount
95230>>>        Boolean bOpen
95230>>>        String sRootName
95230>>>
95230>>>        Move 0 to hTable
95231>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95232>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95233>>>        Decrement iSize
95234>>>        For iCount from 0 to iSize
95240>>>>
95240>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
95241>>>            // We also need to check that the table hasn't been removed...
95241>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95244>>>            If (hTable <> 0 and sRootName <> "") Begin
95246>>>                Open hTable
95248>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95251>>>                If (bOpen = True) Begin
95253>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
95254>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95256>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
95259>>>                    End
95259>>>>
95259>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95262>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
95265>>>                    End
95265>>>>
95265>>>                End
95265>>>>
95265>>>            End
95265>>>>
95265>>>        Loop
95266>>>>
95266>>>    End_Procedure
95267>>>
95267>>>    // This checks for both duplicate pnVersionNumbers _and_ that
95267>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
95267>>>    Procedure CheckForDuplicates Number nVersion
95269>>>        tDbVersionInfo[] DbVersionInfoArray
95269>>>        tDbVersionInfo[] DbVersionInfoArray
95270>>>        Integer iCount iSize iHits iDuplicateIndex
95270>>>        Number nCompare
95270>>>        Handle hObject1 hObject2
95270>>>        String sObjectName1 sObjectName2
95270>>>        Boolean bObjectOrderError
95270>>>
95270>>>        Get paDbVersionInfoArray to DbVersionInfoArray
95271>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
95272>>>        Decrement iSize
95273>>>        Move 0 to iHits
95274>>>        Move 0 to nCompare
95275>>>        Move False to bObjectOrderError
95276>>>        For iCount from 0 to iSize
95282>>>>
95282>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95284>>>                Increment iHits
95285>>>                If (iHits > 1) Begin
95287>>>                    Move iCount to iDuplicateIndex
95288>>>                    If (nCompare <> 0) Begin
95290>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95291>>>                    End
95291>>>>
95291>>>                End
95291>>>>
95291>>>            End
95291>>>>
95291>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95292>>>        Loop
95293>>>>
95293>>>        If (iHits > 1) Begin
95295>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95296>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95297>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95298>>>            Move (Name(hObject1)) to sObjectName1
95299>>>            Move (Name(hObject2)) to sObjectName2
95300>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95301>>>>
95301>>>            Send Exit_Application
95302>>>        End
95302>>>>
95302>>>        Else If (bObjectOrderError = True) Begin
95305>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95306>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95307>>>>
95307>>>            Send Exit_Application
95308>>>        End
95308>>>>
95308>>>    End_Procedure
95309>>>
95309>>>    // We take care of all errors in the Error_Report below and
95309>>>    // collect them all to an array property. So just ignore any
95309>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95309>>>    // in some other package.
95309>>>    Procedure Ignore_Error Integer iError
95311>>>    End_Procedure
95312>>>
95312>>>    Procedure Trap_Error Integer iError
95314>>>    End_Procedure
95315>>>
95315>>>    // Build complete error description from Flexerrs and user error message.
95315>>>    Function Error_Description Integer Error# String ErrMsg Returns String
95317>>>        String Full_Error_Text
95317>>>        
95317>>>        Move (Trim(ErrMsg)) to ErrMsg
95318>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
95319>>>        
95319>>>        If (ErrMsg <> "") Begin
95321>>>            
95321>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
95323>>>                // Make sure last character of error text is a separating symbol.
95323>>>                // if not, add a "." So we have format of "error-text. error-detail"
95323>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95326>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95327>>>            End
95327>>>>
95327>>>            Else ;                Move ErrMsg to Full_Error_Text
95329>>>            
95329>>>        End
95329>>>>
95329>>>        
95329>>>        Function_Return Full_Error_Text
95330>>>    End_Function
95331>>>
95331>>>    // While we update the database we collect all errors in
95331>>>    // the struct array paDbUpdateErrorArray.
95331>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95333>>>        Number nVersion
95333>>>        Handle hoLogFile 
95333>>>        
95333>>>        If (Private.pbProcessingError(Self)) Begin
95335>>>            Procedure_Return
95336>>>        End
95336>>>>
95336>>>
95336>>>        // The UtilTableNameFromHandleToString function does a:
95336>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95336>>>        // and it generates an error if the table is of the embedded type.
95336>>>        // As we don't want to trigger an error in that very specific case,
95336>>>        // we just ignore it here.
95336>>>        //
95336>>>        // If no report mode, just set the err indicator to false.
95336>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95338>>>            Set Private.pbProcessingError to False
95339>>>            Procedure_Return
95340>>>        End
95340>>>>
95340>>>
95340>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95342>>>            Set Private.pbProcessingError to False
95343>>>            Procedure_Return
95344>>>        End
95344>>>>
95344>>>
95344>>>        Set Private.pbProcessingError to True
95345>>>        Set Private.pbUpdateVersionObjectError to True
95346>>>
95346>>>        Set pbDbUpdateErrorHasOccured to True
95347>>>        Get pnCurrentVersionUpdate to nVersion
95348>>>        Get phoLogFile to hoLogFile
95349>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95350>>>
95350>>>        Set Private.pbProcessingError to False
95351>>>    End_Procedure
95352>>>
95352>>>End_Class
95353>
95353>Object oHtmlHelp is a cHtmlHelp
95355>    Set pbAlwaysOnTop to False
95356>
95356>    // Overriden class message to also handle internet HTML Help links;
95356>    // which in which case we should not try to find the path to the help file.
95356>    Function GetHelpFile Returns String
95359>        String sHelpFile
95359>
95359>        Get psHelpFile of ghoApplication to sHelpFile
95360>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95362>            Get_File_Path sHelpFile to sHelpFile
95363>        End
95363>        Function_Return sHelpFile
95364>    End_Function
95365>
95365>End_Object
95366>
95366>Object oApplication is a cApplication
95368>    Set peHelpType to htHtmlHelp
95369>
95369>    // Note: These help file settings gets changed by the Help toolbar button(s).
95369>    Set psHelpFile to "Developer5.chm"
95370>
95370>    Set pbPreserveEnvironment to True
95371>    Set psProduct to "Database Update Framework Lab"
95372>    Set psCompany to "RDC Tools International" 
95373>
95373>    Object oConnection is a cConnection
95375>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
95375>>>Use cLoginEncryption.pkg
95375>>>
95375>>>Object oLoginEncryption is a cLoginEncryption
95377>>>
95377>>>    // this must be created in your appsrc directory and must contain an encryption
95377>>>    // key that is set to psEncryptPassword. It will look something like this
95377>>>    //
95377>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95377>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95377>>>>// Studio generated login encryption key
95377>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95378>>>>
95378>>>    
95378>>>    // use this to register this object to your cConnection Object. This object
95378>>>    // must be created after the cConnection object
95378>>>    Move Self to ghoLoginEncryption
95379>>>End_Object
95380>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
95380>>>
95380>>>Use Windows.pkg
95380>>>Use cConnection.pkg
95380>>>Use dfLine.pkg
95380>>>
95380>>>Object oDatabaseLoginDialog is a ModalPanel
95382>>>    Set Label to "Database Login"
95383>>>    Set Location to 2 2
95384>>>    Set Size to 110 211
95385>>>    
95385>>>    Property String psId
95387>>>    Property Boolean pbOk False
95389>>>    Property Boolean pbChanged False
95391>>>    Property Boolean pbAllowRemember True
95393>>>    
95393>>>    // this registers this object with the cConnection object.
95393>>>    Move Self to ghoLoginConnectDialog
95394>>>    
95394>>>    Object oUserIDForm is a Form
95396>>>        Set Label to "User Name"
95397>>>        Set Size to 12 85
95398>>>        Set Location to 34 79
95399>>>        Set Label_Col_Offset to 64
95400>>>        Set peAnchors to anTopLeftRight
95401>>>    End_Object
95402>>>    
95402>>>    Object oPwdForm is a Form
95404>>>        Set Size to 12 85
95405>>>        Set Location to 49 79
95406>>>        Set Label_Col_Offset to 64
95407>>>        Set Password_State to True
95408>>>        Set peAnchors to anTopLeftRight
95409>>>        Set Label to "Password"
95410>>>    End_Object
95411>>>    
95411>>>    Object oTrustedConnection is a CheckBox
95413>>>        Set Size to 10 50
95414>>>        Set Location to 65 79
95415>>>        Set Label to "Trusted Connection"
95416>>>    End_Object
95417>>>    
95417>>>    Object oRemember is a CheckBox
95419>>>        Set Size to 10 50
95420>>>        Set Location to 79 14
95421>>>        Set Label to "Remember and don't ask again"
95422>>>        Set Checked_State to True
95423>>>    End_Object
95424>>>    
95424>>>    Object oLogin_btn is a Button
95426>>>        Set Label to "&Login"
95427>>>        Set Location to 92 102
95428>>>        Set peAnchors to anBottomRight
95429>>>        Set Default_State to True
95430>>>        
95430>>>        Procedure OnClick
95433>>>            Boolean bTrust
95433>>>            String sUser sPwd sConn sErr sId
95433>>>            Integer iError
95433>>>            Get psId to sId
95434>>>            Get Value of oUserIDForm to sUser
95435>>>            Get Value of oPwdForm to sPwd
95436>>>            Get Checked_State of oTrustedConnection to bTrust
95437>>>            
95437>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95438>>>            If (iError=0) Begin
95440>>>                Set pbOk to True
95441>>>                Set pbChanged to True
95442>>>                Send Close_Panel
95443>>>            End
95443>>>>
95443>>>            Else Begin
95444>>>                Get psErrorText of ghoConnection to sErr
95445>>>                Send UserError sErr "Login Error"
95446>>>            End
95446>>>>
95446>>>        End_Procedure
95447>>>    End_Object
95448>>>    
95448>>>    Object oCancel_btn is a Button
95450>>>        Set Label to "&Cancel"
95451>>>        Set Location to 92 157
95452>>>        Set peAnchors to anBottomRight
95453>>>        
95453>>>        Procedure OnClick
95456>>>            Send Close_Panel
95457>>>        End_Procedure
95458>>>    End_Object
95459>>>    
95459>>>    Object oConnectionIdInfo is a TextBox
95461>>>        Set Size to 10 50
95462>>>        Set Location to 4 14
95463>>>        Set Label to 'Connection Id='
95464>>>    End_Object
95465>>>    
95465>>>    Object oConnectionServerInfo is a TextBox
95467>>>        Set Size to 10 50
95468>>>        Set Location to 16 14
95469>>>        Set Label to 'Server'
95470>>>    End_Object
95471>>>    
95471>>>    Object oLineControl1 is a LineControl
95473>>>        Set Size to 2 202
95474>>>        Set Location to 29 5
95475>>>    End_Object
95476>>>    
95476>>>    Function LoginConnectIdDialog String sId Returns Boolean
95479>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95479>>>        String sUser sPwd sDescription
95479>>>        tConnection Connect
95479>>>        tConnection Connect
95479>>>        
95479>>>        Get pbAllowRemember to bAllowRemember
95480>>>        
95480>>>        
95480>>>        If not bAllowRemember Begin
95482>>>            Set Enabled_State of oRemember to bRemember
95483>>>            Set Visible_State of oRemember to bRemember
95484>>>        End
95484>>>>
95484>>>        
95484>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95485>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95486>>>        Set Value of oConnectionServerInfo to Connect.sString
95487>>>        
95487>>>        Set psId to sId
95488>>>        Set pbOk to False
95489>>>        Set pbChanged to False
95490>>>        Set Value of oUserIDForm to Connect.sUID
95491>>>        Set Value of oPwdForm to ""
95492>>>        
95492>>>        Send Popup
95493>>>        
95493>>>        Get pbOk to bOk
95494>>>        Get pbChanged to bChanged
95495>>>        If (bChanged and bOk) Begin
95497>>>            If bAllowRemember Begin
95499>>>                Get Checked_State of oRemember to bRemember
95500>>>                If bRemember Begin
95502>>>                    Get Checked_State of oTrustedConnection to bTrusted
95503>>>                    If not (bTrusted) Begin
95505>>>                        Get Value of oUserIDForm to sUser
95506>>>                        Get Value of oPwdForm to sPwd
95507>>>                    End
95507>>>>
95507>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95508>>>                End
95508>>>>
95508>>>            End
95508>>>>
95508>>>        End
95508>>>>
95508>>>        Function_Return bOk
95509>>>    End_Function
95510>>>    
95510>>>    
95510>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95511>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95512>>>End_Object
95513>>>
95513>    End_Object
95514>
95514>End_Object   
95515>
95515>Object oDbUpdateHandler is a cDbUpdateHandler 
95517>    Set piDbVersionFileNumber to 255
95518>    Set piDbVersionFieldNumber to 1
95519>    
95519>End_Object
95520>
95520>Object oCJSkinFramework is a cCJSkinFramework
95522>    Set pbLoadPreference to True
95523>End_Object
95524>
95524>Object oToolTipController is a cToolTipController
95526>    Set piDurationPopup to 10000
95527>    Set piMaxWidth to 500
95528>    Move Self to ghoToolTipController
95529>End_Object
95530>
95530>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95530>>>Use cCJStandardMenuItemClasses.pkg
95530>>>
95530>>>Object oEditContextMenu is a cCJContextMenu
95532>>>    
95532>>>    Move Self to Default_Form_Floating_Menu_ID
95533>>>    
95533>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95535>>>    End_Object
95536>>>    
95536>>>    Object oCutMenuItem is a cCJCutMenuItem
95538>>>        Set pbControlBeginGroup to True
95539>>>    End_Object
95540>>>    
95540>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95542>>>    End_Object
95543>>>
95543>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95545>>>    End_Object
95546>>>
95546>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95548>>>    End_Object
95549>>>
95549>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95551>>>        Set pbControlBeginGroup to True
95552>>>    End_Object
95553>>>
95553>>>End_Object
95554>>>
95554>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95554>>>Use Windows.pkg
95554>>>Use cCJStandardMenuItemClasses.pkg
95554>>>Use cCJDeoMenuItemClasses.pkg
95554>>>
95554>>>
95554>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95556>>>    
95556>>>    Move Self to Default_dbFloating_Menu_ID
95557>>>    
95557>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95559>>>    End_Object
95560>>>    
95560>>>    Object oCutMenuItem is a cCJCutMenuItem
95562>>>        Set pbControlBeginGroup to True
95563>>>    End_Object
95564>>>    
95564>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95566>>>    End_Object
95567>>>
95567>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95569>>>    End_Object
95570>>>
95570>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95572>>>    End_Object
95573>>>
95573>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95575>>>        Set pbControlBeginGroup to True
95576>>>    End_Object
95577>>>
95577>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95579>>>        Set pbControlBeginGroup to True
95580>>>    End_Object
95581>>>
95581>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95583>>>        Set pbControlBeginGroup to True
95584>>>    End_Object
95585>>>
95585>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95587>>>    End_Object
95588>>>
95588>>>    Object oClearMenuItem is a cCJClearMenuItem
95590>>>        Set pbControlBeginGroup to True
95591>>>    End_Object
95592>>>
95592>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95594>>>    End_Object
95595>>>
95595>>>    Object oSaveMenu is a cCJSaveMenuItem
95597>>>    End_Object
95598>>>    
95598>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95600>>>    End_Object
95601>>>
95601>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95603>>>        Set pbControlBeginGroup to True
95604>>>    End_Object
95605>>>
95605>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95607>>>    End_Object
95608>>>
95608>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95610>>>    End_Object
95611>>>
95611>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95613>>>    End_Object
95614>>>
95614>>>End_Object
95615>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\Lib\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95615>>>Use cCJCommandBarSystem.pkg
95615>>>Use Wingdi.pkg
95615>>>Use LanguageText.pkg
95615>>>
95615>>>// User interface constant strings:
95615>>>Define CS_NoSkinShort For "-None"
95615>>>Define CS_NoSkinLong  For "Do not use a skin"
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>
95615>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95616>>>
95616>>>    Procedure Construct_Object
95618>>>        Forward Send Construct_Object
95620>>>
95620>>>        Set peControlType to xtpControlComboBox
95621>>>
95621>>>        Property tSkinInformation[] pSkins
95622>>>
95622>>>    End_Procedure
95623>>>
95623>>>    Procedure End_Construct_Object
95625>>>        Forward Send End_Construct_Object
95627>>>    End_Procedure
95628>>>
95628>>>    // Custom array sort for the tSkinInformation struct array.
95628>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95628>>>    // Why?
95628>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95628>>>    // create a custom sort algorithm.
95628>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95628>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95628>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95628>>>    // randomly ordered. This custom sort method will take care of that.
95628>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95630>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95632>>>            Function_Return (GT)
95633>>>        End
95633>>>>
95633>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95635>>>            Function_Return (LT)
95636>>>        End
95636>>>>
95636>>>        Function_Return (EQ)
95637>>>    End_Function
95638>>>
95638>>>    Procedure OnCreateControl Handle hoObj
95640>>>        Forward Send OnCreateControl hoObj
95642>>>
95642>>>        Send LoadSkins
95643>>>        Send FillComboList hoObj
95644>>>    End_Procedure
95645>>>
95645>>>    // Load all skins. We will only look for skins in expected
95645>>>    // directory which is the Programs folder.
95645>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95645>>>    // This is not the case with the 'standard' VDF behaviour.
95645>>>    Procedure LoadSkins
95647>>>        Integer iCount iItems iSize
95647>>>        Boolean bFound
95647>>>        String sFile sIni sSkin
95647>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95647>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95649>>>        tSkinInformation NoneRow
95649>>>        tSkinInformation NoneRow
95649>>>
95649>>>        If (ghoSkinFramework > 0) Begin
95651>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95652>>>
95652>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95653>>>            Move CS_NoSkinShort to NoneRow.sName
95654>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95655>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95656>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95657>>>
95657>>>            // Get the currently loaded skin.
95657>>>            Get psSkinFile of ghoSkinFramework to sFile
95658>>>            Get psSkinIni  of ghoSkinFramework to sIni
95659>>>
95659>>>            // Remove all Extra Large and Large skins from the array.
95659>>>            Move (SizeOfArray(SkinsArray)) to iItems
95660>>>            Decrement iItems
95661>>>            For iCount From 0 to iItems
95667>>>>
95667>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95668>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95669>>>                If (bFound = False) Begin
95671>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95672>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95673>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95674>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95675>>>                End
95675>>>>
95675>>>            Loop
95676>>>>
95676>>>            Set pSkins to SkinsArrayNoLarge
95677>>>        End
95677>>>>
95677>>>    End_Procedure
95678>>>
95678>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95678>>>    Procedure FillComboList Handle hoCombo
95680>>>        Integer iCount iItems iCurrent iTxtEntentSize
95680>>>        String  sFile sIni sCurrSkin
95680>>>        String  sSkin sSkinText
95680>>>        tSkinInformation[] SkinsArray
95680>>>        tSkinInformation[] SkinsArray
95681>>>        Integer iSize
95681>>>
95681>>>        If (ghoSkinFramework < 1) Begin
95683>>>            Procedure_Return
95684>>>        End
95684>>>>
95684>>>
95684>>>        // Get the currently loaded skin.
95684>>>        Get psSkinFile of ghoSkinFramework to sFile
95685>>>        Get psSkinIni  of ghoSkinFramework to sIni
95686>>>        Get pSkins to SkinsArray
95687>>>        Move (SizeOfArray(SkinsArray)) to iItems
95688>>>        Decrement iItems
95689>>>        Send ComClear of hoCombo
95690>>>
95690>>>        For iCount From 0 to iItems
95696>>>>
95696>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95697>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95698>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95699>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95700>>>            Get Text_Extent sSkinText to iSize
95701>>>            If (iSize > iTxtEntentSize) Begin
95703>>>                Move iSize to iTxtEntentSize
95704>>>            End
95704>>>>
95704>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95705>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95707>>>                Move iCount to iCurrent
95708>>>            End
95708>>>>
95708>>>        Loop
95709>>>>
95709>>>
95709>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95710>>>        Set ComDropDownWidth of hoCombo  to iSize
95711>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95712>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95713>>>    End_Procedure
95714>>>
95714>>>    // Event for when an item is selected from the comboform
95714>>>    Procedure OnExecute Variant vCommandBarControl
95716>>>        Handle  hoCombo
95716>>>        Integer iSelection
95716>>>        String  sSkinFile sSkinIni
95716>>>        tSkinInformation[] SkinsArray
95716>>>        tSkinInformation[] SkinsArray
95717>>>
95717>>>        // Create and bind proxy control
95717>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95718>>>        // Get the current selection
95718>>>        Get ComListIndex of hoCombo to iSelection
95719>>>        Decrement iSelection
95720>>>        Get pSkins to SkinsArray
95721>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95722>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95723>>>
95723>>>        Send DoChangeSkin sSkinFile sSkinIni
95724>>>
95724>>>        // Dispose of the proxy control
95724>>>        Send Destroy of hoCombo
95725>>>    End_Procedure
95726>>>
95726>>>    // Send this message to change the current skin.
95726>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95728>>>        Handle hoClient
95728>>>
95728>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95729>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95730>>>        Send ApplySkin of ghoSkinFramework
95731>>>
95731>>>        // Note: The following line is essential for the resizing logic
95731>>>        // to function properly when changing a skin and a view is maximized.
95731>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95732>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95733>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95734>>>    End_Procedure
95735>>>
95735>>>    // Returns: DPI setting as an integer.
95735>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95735>>>    //                      iDPI=120 is "Medium setting" 125%
95735>>>    //                      iDPI= 144 is "Large setting" 150%
95735>>>    Function GetCurrentDPI Returns Integer
95737>>>        Handle hDC
95737>>>        Integer iPixelsX
95737>>>        Move (GetDC(0)) to hDC
95738>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95739>>>        Move (ReleaseDC(0, hDC)) to hDC
95740>>>        Function_Return iPixelsX
95741>>>    End_Function
95742>>>
95742>>>End_Class
95743>
95743>Object oMain is a Panel
95745>    Set Label to "Test Program - The Database Update Framework"
95746>    Set Location to 2 2
95747>    Set Size to 309 493
95748>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95749>    Set Icon to "TestTools.ico"
95750>
95750>    Property Handle phoViewMenu 0
95752>    Property Handle phoReportMenu 0
95754>
95754>    Object oCommandBarSystem is a cCJCommandBarSystem
95756>        Set pbTimerUpdate to True
95757>            Set pbAutoResizeIcons to True
95758>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95759>            Set peVisualTheme to xtpThemeOffice2013Publisher
95760>            Set pbLargeIcons to True
95761>
95761>        Procedure OnCreateCommandBars
95764>            Handle hoOptions
95764>            Forward Send OnCreateCommandBars
95766>                Get OptionsObject to hoOptions
95767>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95768>        End_Procedure
95769>
95769>
95769>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95772>        Set ComShowIcons of hoTabPaintManager to True
95773>
95773>        // This will truncate the middle part of long items
95773>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95774>    End_Procedure
95775>
95775>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95775>        // the previous tab workspace view.
95775>        Object oPreviousTabAction is a cCJAction
95777>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95778>            Procedure OnExecute Variant vCommandBarControl
95781>                Handle hoCommandBars hoClientArea
95781>                Forward Send OnExecute vCommandBarControl
95783>                Get CommandBarSystemObject to hoCommandBars
95784>                Get ClientAreaObject of hoCommandBars to hoClientArea
95785>                If hoClientArea Begin
95787>                    Send Switch_Next_View of hoClientArea
95788>                End
95788>            End_Procedure
95789>        End_Object
95790>
95790>        Object oToolBar is a cCJToolbar
95792>            Set psTitle to "Edit Toolbar"
95793>            Set pbGripper to False
95794>            Set peStretched to stStretch
95795>
95795>            Object oCutToolbarItem is a cCJCutMenuItem  
95797>                Set psImage to "ActionCut.ico"
95798>            End_Object
95799>
95799>            Object oCopyToolbarItem is a cCJCopyMenuItem
95801>                Set psImage to "ActionCopy.ico"
95802>            End_Object
95803>
95803>            Object oPasteToolbarItem is a cCJPasteMenuItem
95805>                Set psImage to "ActionPaste.ico"
95806>            End_Object
95807>
95807>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95809>                Set psImage to "ActionDelete.ico"
95810>                Set pbControlBeginGroup to True
95811>            End_Object
95812>
95812>            Object oTheme_tb is a cCJMenuItem
95814>                Set peControlType to xtpControlLabel
95815>                Set psCaption to "Theme:"
95816>                Set pbControlBeginGroup to True
95817>            End_Object
95818>
95818>            Object oThemeItem is a cCJMenuItem
95820>                Set peControlType to xtpControlComboBox
95821>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95822>
95822>                Procedure OnCreateControl Handle hoObj
95825>                    Integer iItem eTheme
95825>                    Set ComWidth of hoObj to 250
95826>                    Send FillComboList hoObj
95827>                    Get peVisualTheme to eTheme
95828>                    Get FindDataItem hoObj eTheme to iItem
95829>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95830>                End_Procedure
95831>
95831>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95834>                    Integer iCount i eTheme
95834>                    Get ComListCount of hoCombo to iCount
95835>                    For i from 1 to iCount
95841>                        Get ComItemData of hoCombo i to eTheme
95842>                        If (eTheme=eVal) Begin
95844>                            Send SetTheTheme eTheme
95845>                            Function_Return i
95846>                        End
95846>                    Loop
95847>                    Function_Return 0
95848>                End_Function
95849>
95849>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95852>                    Integer iCount
95852>                    Get ComListCount of hoCombo to iCount
95853>                    Increment iCount
95854>                    Send ComAddItem  of hoCombo sText iCount
95855>                    Set ComItemData  of hoCombo iCount to  eTheme
95856>                End_Procedure
95857>
95857>                Procedure FillComboList Handle hoCombo
95860>                    Send ComClear     of hoCombo
95861>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95862>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95863>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95864>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95865>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95866>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95867>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95868>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95869>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95870>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95871>    
95871>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95872>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95873>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95874>    
95874>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95875>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95876>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95877>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95878>    
95878>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95879>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95880>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95881>    
95881>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95882>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95883>    
95883>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95884>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95885>    
95885>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95886>    
95886>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95887>    
95887>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95888>                End_Procedure
95889>
95889>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95892>                    Handle hMessage hoCombo
95892>                    Integer iIndex
95892>                    // create and bind  proxy control
95892>                    Get CreateProxyControl vCommandBarControl to hoCombo
95893>                    // get the current selection
95893>                    Get ComListIndex of hoCombo to iIndex
95894>                    // note the index selections are 1 based
95894>                    If (iIndex > 0) Begin
95896>                        // get the ItemData for the selected item and send that message
95896>                        Get ComItemData of hoCombo iIndex to hMessage
95897>                        Function_Return hMessage
95898>                    End
95898>                    // dispose of the proxy control
95898>                    Send Destroy of hoCombo
95899>                    Function_Return 0
95900>                End_Function
95901>
95901>                Procedure OnExecute Variant vCommandBarControl
95904>                    Integer eTheme
95904>                    Integer iColor
95904>                    Get CurrentTheme vCommandBarControl to eTheme
95905>                    Set peVisualTheme of ghoCommandBars to eTheme
95906>                    Send ComRecalcLayout of ghoCommandBars
95907>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95908>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95910>                End_Procedure
95911>
95911>                Procedure SetTheTheme Integer eTheme
95914>                    Integer iColor
95914>                    Set peVisualTheme of ghoCommandBars to eTheme
95915>                    Send ComRecalcLayout of ghoCommandBars
95916>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95917>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95919>                End_Procedure
95920>
95920>                Function ConvertSystemColor Integer iColor Returns Integer
95923>                    Integer iSysColor
95923>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95925>                        Move clNone to iColor
95926>                    End
95926>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95929>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95930>                        Move (GetSysColor(iSysColor)) to iColor
95931>                    End
95931>                    Function_Return iColor
95932>                End_Function
95933>
95933>            End_Object
95934>
95934>            Object oAbout_MenuItem is a cCJMenuItem
95936>                Set psCaption to "About"
95937>                Set psToolTip to "About Info"
95938>                Set psDescription to "About the program"
95939>                Set psImage to "ActionAbout.ico"
95940>                Set pbControlBeginGroup to True
95941>                Procedure OnExecute Variant vCommandBarControl
95944>                    Forward Send OnExecute vCommandBarControl
95946>                    Send Activate_About of (Client_Id(ghoCommandBars))
95947>                End_Procedure
95948>            End_Object
95949>
95949>            Object oHelpMenuItem is a cCJHelpMenuItem
95951>                Set peControlType to xtpControlSplitButtonPopup
95952>                Set psImage to "ActionHelp.ico"
95953>
95953>                Procedure OnExecute Variant vCommandBarControl
95956>                    Forward Send OnExecute vCommandBarControl
95958>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95959>                    Send ShowProgramHelp
95960>                End_Procedure
95961>
95961>                Object oHelpMenuItemLocal is a cCJMenuItem
95963>                    Set psCaption to "Local HTML Help"
95964>                    Set psImage to "ActionHelp.ico"
95965>                    Procedure OnExecute Variant vCommandBarControl
95968>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95969>                        Send ShowProgramHelp
95970>                    End_Procedure
95971>                End_Object
95972>
95972>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95974>                    Set psCaption to "Internet Online HTML Help"
95975>                    Set psImage to "ActionHelp.ico"
95976>                    Procedure OnExecute Variant vCommandBarControl
95979>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95980>                    End_Procedure
95981>
95981>                End_Object
95982>            End_Object
95983>
95983>            Object oExitMenuItem is a cCJExitMenuItem
95985>                Set psImage to "ActionExit.ico"
95986>                Set psToolTip to "Exit application"
95987>                Set psDescription to "Exit the program (Alt+F4)"
95988>                Set pbControlBeginGroup to True
95989>            End_Object
95990>        End_Object
95991>
95991>//        Object oSpacerBar is a cCJToolbar
95991>//            Set pbDockNextTo to False
95991>//            Set pbShowExpandButton to False
95991>//            Set pbGripper to False
95991>//            Set peStretched to stStretch
95991>//            Set pbCustomizable to False
95991>//            Set pbCloseable to False
95991>//            Set pbEnableDocking to False
95991>//            Set pbHideWrap to True
95991>//
95991>//            Object oFiller is a cCJMenuItem
95991>//            End_Object
95991>//
95991>//        End_Object
95991>
95991>        Object oStatusBar is a cCJStatusBar
95993>
95993>            Object oStatusPane1 is a cCJStatusBarPane
95995>                Set piID to sbpIDIdlePane
95996>                Set pbStyleStretch to True
95997>            End_Object
95998>            Object oStatusPane2 is a cCJStatusBarPane
96000>                Set phoViewPane to Self
96001>                Set pbStyleStretch to True
96002>            End_Object
96003>
96003>        End_Object
96004>
96004>    End_Object
96005>
96005>    Object oClientArea is a ClientArea
96007>
96007>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
96007>
96007>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
96007>>>// This provides a quick and simple way to create an about package for a program.
96007>>>// You need to create a message inside you client area called Activate_About.
96007>>>// Within this message you should send the message DoAbout passing needed
96007>>>// string information.
96007>>>//
96007>>>//       Procedure Activate_About
96007>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
96007>>>//       End_Procedure
96007>>>//    where: sTitle =     Name of application. If none provided, uses caption
96007>>>//                        bar title
96007>>>//           sVersion   = Version Line. If none provided, will be blank
96007>>>//           sCopyRight = Copyright Line. If none provided, will be blank
96007>>>//           sAuthor    = Author name, blank if none provided
96007>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
96007>>>//                        is used.
96007>>>// It is expected that you will place this in your own object package. For
96007>>>// example an order about package may look like this:
96007>>>//
96007>>>//   // OrderAbout.pkg
96007>>>//   Use StdAbout.pkg
96007>>>//   Procedure Activate_About
96007>>>//      String sTitle sCopyright sVersion sAuthor
96007>>>//      Move "My Order Entry System" to sTitle
96007>>>//      Move "Version 2.1" to sVersion
96007>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
96007>>>//      Move "John Smith"  to sAuthor
96007>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
96007>>>//   end_procedure
96007>>>//   // end of file.
96007>>>
96007>>>Use DfAbout.pkg
96007>>>
96007>>>// *************************************************************************
96007>>>//  Public message. This is the default message. It is expected that you will
96007>>>//   create your own message to override this
96007>>>// *************************************************************************
96007>>>
96007>>>Procedure Activate_About
96010>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
96011>>>End_Procedure
96012>>>
96012>>>// *************************************************************************
96012>>>//  Public message. It is expected that you will send this message (most
96012>>>//  likely from Activate_About. This creates an about object, activates it
96012>>>//  and destroys it when done. It is not exepected that you will augment this.
96012>>>// *************************************************************************
96012>>>// Sample usage:
96012>>>//   The first two params will automatically be filled from the application settings if not provided.
96012>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
96012>>>
96012>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
96015>>>    Integer hoObj hoMain iArgs
96015>>>    String sValue
96015>>>
96015>>>    // Create object
96015>>>    Object About is an AboutDialog
96017>>>    // Uncomment these two lines if you would like to have a resizable About object.
96017>>>    //            Set Border_Style to Border_Thick
96017>>>    //            Set peAnchors to anAll
96017>>>
96017>>>    // Add checking for the number of arguments passed to avoid runtime errors
96017>>>    // if one of them is not passed. This makes the interface
96017>>>    // more flexible.
96017>>>        Move num_arguments to iArgs
96018>>>
96018>>>        // If no title is passed use the label of the main panel (if a main panel exists).
96018>>>        If (iArgs > 0 and sTitle = "") Begin
96020>>>            Get Main_Window of Desktop to hoMain
96021>>>            If hoMain Begin
96023>>>                Get Label of hoMain to sValue
96024>>>            End
96024>>>>
96024>>>        End
96024>>>>
96024>>>        Else If (iArgs > 0 and sTitle <> "") Begin
96027>>>            Move sTitle to sValue
96028>>>        End
96028>>>>
96028>>>        Else If (iArgs = 0) Begin
96031>>>            Get Main_Window of Desktop to hoMain
96032>>>            If hoMain Begin
96034>>>                Get Label of hoMain to sValue
96035>>>            End
96035>>>>
96035>>>        End
96035>>>>
96035>>>
96035>>>        If (sValue <> "") Begin
96037>>>            Send Add_LineLn sValue
96038>>>        End
96038>>>>
96038>>>        Move "" to sValue
96039>>>
96039>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
96039>>>        // For this to work the Project Properties Version must have been set in the Studio.
96039>>>        If (iArgs < 2) Begin
96041>>>            Move "" to sValue
96042>>>        End
96042>>>>
96042>>>        Else Begin
96043>>>            Move sVersion to sValue
96044>>>        End
96044>>>>
96044>>>        Set Version to sValue
96045>>>
96045>>>        If (iArgs > 2 and sCopyRight <> "") Begin
96047>>>            Send Add_LineLn sCopyRight
96048>>>        End
96048>>>>
96048>>>
96048>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
96048>>>        // else we do.
96048>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
96050>>>            Send Add_Line sAuthor
96051>>>        End
96051>>>>
96051>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
96054>>>            Send Add_LineLn sAuthor
96055>>>        End
96055>>>>
96055>>>
96055>>>        // Square bitmaps of 80x80 works best
96055>>>        If (iArgs > 4 and sBitmap <> "") Begin
96057>>>            Set Logo to sBitMap
96058>>>        End
96058>>>>
96058>>>
96058>>>        // Here starts handling of the five optional params:
96058>>>        If (iArgs = 6 and sParam6  <> "") Begin
96060>>>            Send Add_Line sParam6
96061>>>        End
96061>>>>
96061>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
96064>>>            Send Add_LineLn sParam6
96065>>>        End
96065>>>>
96065>>>
96065>>>        If (iArgs = 7 and sParam7  <> "") Begin
96067>>>            Send Add_Line sParam7
96068>>>        End
96068>>>>
96068>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
96071>>>            Send Add_LineLn sParam7
96072>>>        End
96072>>>>
96072>>>
96072>>>        If (iArgs = 8 and sParam8  <> "") Begin
96074>>>            Send Add_Line sParam8
96075>>>        End
96075>>>>
96075>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
96078>>>            Send Add_LineLn sParam8
96079>>>        End
96079>>>>
96079>>>
96079>>>        If (iArgs = 9 and sParam9  <> "") Begin
96081>>>            Send Add_Line sParam9
96082>>>        End
96082>>>>
96082>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
96085>>>            Send Add_LineLn sParam9
96086>>>        End
96086>>>>
96086>>>
96086>>>        If (iArgs = 10 and sParam10 <> "") Begin
96088>>>            Send Add_Line sParam10
96089>>>        End
96089>>>>
96089>>>
96089>>>        Move Self to hoObj
96090>>>    End_Object
96091>>>
96091>>>    Send Popup   of hoObj // Popup the about object
96092>>>    Send Destroy of hoObj // When done, it will be destroyed
96093>>>End_Procedure
96094>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
96094>>>Use Windows.pkg
96094>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
96094>>>>>Use Windows.pkg
96094>>>>>Use cCJGrid.pkg
96094>>>>>Use umPromptRelational.pkg
96094>>>>>
96094>>>>>Class cCJGridPromptList is a cCJGrid
96095>>>>>    
96095>>>>>    Procedure Construct_Object
96097>>>>>        Forward Send Construct_Object
96099>>>>>        
96099>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
96100>>>>>        Property Boolean Private_pbAutoOrdering True
96101>>>>>        Property Boolean pbAutoSearch True  // pops up search window
96102>>>>>        Property Integer peUpdateMode umPromptValue
96103>>>>>        Property Integer piUpdateColumn 0
96104>>>>>        Property Integer piInitialColumn -1
96105>>>>>        Property String  psSeedValue ''
96106>>>>>        Property Handle phmPromptUpdateCallback 0
96107>>>>>        Property Integer phoInvokingObject
96108>>>>>        
96108>>>>>        Property Boolean pbStoredAutoSeed
96109>>>>>        Property Boolean pbStoredAutoOrdering
96110>>>>>        Property Boolean pbStoredAutoSearch
96111>>>>>        Property Integer peStoredUpdateMode
96112>>>>>        Property Integer piStoredUpdateColumn
96113>>>>>        Property Integer piStoredInitialColumn
96114>>>>>        Property Handle  phmStoredPromptUpdateCallback
96115>>>>>        Property Boolean pbStoredSelectionEnable
96116>>>>>        Property Boolean pbStoredMultipleSelection
96117>>>>>        
96117>>>>>        // internally set by list
96117>>>>>        // these must be set upon closing the list and can be used for manual list updates
96117>>>>>        Property Boolean pbCanceled
96118>>>>>        Property Integer[] pSelectedRows
96119>>>>>        
96119>>>>>        Property Boolean pbNeedsNewOrdering
96120>>>>>        Property Boolean pbRequestSearch
96121>>>>>        Property tGridKeyPair[] pSearchKeys
96122>>>>>        
96122>>>>>        // these properties makes a prompt list a prompt list
96122>>>>>        // and should not be changed.
96122>>>>>        Set pbEditOnKeyNavigation to False
96123>>>>>        Set pbEditOnClick to False
96124>>>>>        Set pbReadOnly to True
96125>>>>>        Set pbFocusSubItems to True
96126>>>>>        
96126>>>>>        // these could maybe be changed
96126>>>>>        Set pbShadeSortColumn to True
96127>>>>>        Set pbHeaderReorders to True
96128>>>>>        Set pbHeaderTogglesDirection to True
96129>>>>>        Set pbHeaderSelectsColumn to True
96130>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
96131>>>>>        Set piFocusCellBackColor to clNone
96132>>>>>        Set piFocusCellForeColor to clNone
96133>>>>>        Set piFocusCellRectangleColor to clBlack
96134>>>>>        Set pbUseFocusCellRectangle to False
96135>>>>>        Set pbSelectionEnable to True
96136>>>>>        
96136>>>>>        On_Key kEnter Send Ok
96137>>>>>        On_Key kCancel Send Cancel
96138>>>>>        
96138>>>>>    End_Procedure
96139>>>>>    
96139>>>>>    // reorder list automatically on column change
96139>>>>>    // this also set pbFocusSubItems which is required to make the two states work
96139>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
96141>>>>>        Set Private_pbAutoOrdering to bAutoOrder
96142>>>>>        Set pbFocusSubItems to bAutoOrder
96143>>>>>    End_Procedure
96144>>>>>    
96144>>>>>    Function pbAutoOrdering Returns Boolean
96146>>>>>        Boolean bAutoOrder
96146>>>>>        Get Private_pbAutoOrdering to bAutoOrder
96147>>>>>        Function_Return bAutoOrder
96148>>>>>    End_Function
96149>>>>>    
96149>>>>>    // augmented to handle auto-ordering and invoking the search popup list
96149>>>>>    Procedure OnIdle
96151>>>>>        Boolean bNeedsReorder bSearch bOldToggle
96151>>>>>        Handle hoCol
96151>>>>>        Integer iKy1 iKy2 iCol
96151>>>>>        
96151>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
96152>>>>>        If bNeedsReorder Begin
96154>>>>>            Get SelectedColumn to iCol
96155>>>>>            If (iCol<>-1) Begin
96157>>>>>                
96157>>>>>                Get pbHeaderTogglesDirection to bOldToggle
96158>>>>>                Set pbHeaderTogglesDirection to False
96159>>>>>                Send HeaderReorder iCol
96160>>>>>                Set pbHeaderTogglesDirection to bOldToggle
96161>>>>>                
96161>>>>>                Set pbNeedsNewOrdering to False
96162>>>>>            End
96162>>>>>>
96162>>>>>        End
96162>>>>>>
96162>>>>>        
96162>>>>>        Get pbRequestSearch to bSearch
96163>>>>>        If bSearch Begin
96165>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
96166>>>>>        End
96166>>>>>>
96166>>>>>        
96166>>>>>        Forward Send OnIdle
96168>>>>>    End_Procedure
96169>>>>>    
96169>>>>>    Procedure OnStoreDefaults
96171>>>>>        Integer iVal
96171>>>>>        Boolean bVal
96171>>>>>        
96171>>>>>        Get pbAutoSeed to bVal
96172>>>>>        Set pbStoredAutoSeed to bVal
96173>>>>>        
96173>>>>>        Get pbAutoOrdering to bVal
96174>>>>>        Set pbStoredAutoOrdering to bVal
96175>>>>>        
96175>>>>>        Get pbAutoSearch to bVal
96176>>>>>        Set pbStoredAutoSearch to bVal
96177>>>>>        
96177>>>>>        Get peUpdateMode to iVal
96178>>>>>        Set peStoredUpdateMode to iVal
96179>>>>>        
96179>>>>>        Get piUpdateColumn to iVal
96180>>>>>        Set piStoredUpdateColumn to iVal
96181>>>>>        
96181>>>>>        Get piInitialColumn to iVal
96182>>>>>        Set piStoredInitialColumn to iVal
96183>>>>>        
96183>>>>>        Get phmPromptUpdateCallback to iVal
96184>>>>>        Set phmStoredPromptUpdateCallback to iVal
96185>>>>>        
96185>>>>>        Get pbSelectionEnable to bVal
96186>>>>>        Set pbStoredSelectionEnable to bVal
96187>>>>>        
96187>>>>>        Get pbMultipleSelection to bVal
96188>>>>>        Set pbStoredMultipleSelection to bVal
96189>>>>>        
96189>>>>>    End_Procedure
96190>>>>>    
96190>>>>>    Procedure OnRestoreDefaults
96192>>>>>        Integer iVal
96192>>>>>        Boolean bVal
96192>>>>>        
96192>>>>>        Get pbStoredAutoSeed to bVal
96193>>>>>        Set pbAutoSeed to bVal
96194>>>>>        
96194>>>>>        Get pbStoredAutoOrdering to bVal
96195>>>>>        Set pbAutoOrdering to bVal
96196>>>>>        
96196>>>>>        Get pbStoredAutoSearch to bVal
96197>>>>>        Set pbAutoSearch to bVal
96198>>>>>        
96198>>>>>        Get peStoredUpdateMode to iVal
96199>>>>>        Set peUpdateMode to iVal
96200>>>>>        
96200>>>>>        Get piStoredUpdateColumn to iVal
96201>>>>>        Set piUpdateColumn to iVal
96202>>>>>        
96202>>>>>        Get piStoredInitialColumn to iVal
96203>>>>>        Set piInitialColumn to iVal
96204>>>>>        
96204>>>>>        Get phmStoredPromptUpdateCallback to iVal
96205>>>>>        Set phmPromptUpdateCallback to iVal
96206>>>>>        
96206>>>>>        Get pbStoredSelectionEnable to bVal
96207>>>>>        Set pbSelectionEnable to bVal
96208>>>>>        
96208>>>>>        Get pbStoredMultipleSelection to bVal
96209>>>>>        Set pbMultipleSelection to bVal
96210>>>>>        
96210>>>>>    End_Procedure
96211>>>>>    
96211>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
96211>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
96211>>>>>    // Suitable for augmentation
96211>>>>>    Procedure OnSeedData
96213>>>>>        Integer iUpdateColumn iSortColumn
96213>>>>>        Boolean bSeed bAuto
96213>>>>>        String sValue
96213>>>>>        Handle hoCol
96213>>>>>        
96213>>>>>        Get piUpdateColumn to iUpdateColumn
96214>>>>>        Get psSeedValue to sValue
96215>>>>>        Get pbAutoSeed to bSeed
96216>>>>>        Get piSortColumn to iSortColumn
96217>>>>>        Get pbAutoOrdering to bAuto
96218>>>>>        // if not yet sorted and this is auto ordering we will
96218>>>>>        // sort the data for the search column. We do this to make the
96218>>>>>        // column search GE logic work properly.
96218>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
96220>>>>>            Get ColumnObject iUpdateColumn to hoCol
96221>>>>>            Send SortGridByColumn hoCol False
96222>>>>>        End
96222>>>>>>
96222>>>>>        
96222>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
96224>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
96225>>>>>        End
96225>>>>>>
96225>>>>>        Else Begin
96226>>>>>            Send MovetoFirstRow
96227>>>>>        End
96227>>>>>>
96227>>>>>        
96227>>>>>    End_Procedure
96228>>>>>    
96228>>>>>    Procedure OnMoveValueOutByValue
96230>>>>>        String sValue
96230>>>>>        Handle hoInvokingObject hoCol  hoDataSource
96230>>>>>        Integer iRow iCol
96230>>>>>        Integer[] SelRowsIndexes
96231>>>>>        
96231>>>>>        Get phoInvokingObject to hoInvokingObject
96232>>>>>        Get pSelectedRows to SelRowsIndexes
96233>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
96235>>>>>            Get piUpdateColumn to iCol
96236>>>>>            Get ColumnObject iCol to hoCol
96237>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
96238>>>>>            Set Value of hoInvokingObject to sValue
96239>>>>>            Set Item_Changed_State of hoInvokingObject to True
96240>>>>>        End
96240>>>>>>
96240>>>>>    End_Procedure
96241>>>>>    
96241>>>>>    Procedure OnMoveValueOutByCustom
96243>>>>>    End_Procedure
96244>>>>>    
96244>>>>>    // augment to popup a search window when allowed
96244>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
96246>>>>>        Boolean bSubFocus bAutoSearch bChar
96246>>>>>        Integer iVal
96246>>>>>        
96246>>>>>        Get pbFocusSubItems to bSubFocus
96247>>>>>        Get pbAutoSearch to bAutoSearch
96248>>>>>        Forward Send OnComKeyDown llKeyCode llShift
96250>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
96252>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
96254>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
96255>>>>>                Move (iVal<>0) to bChar
96256>>>>>            End
96256>>>>>>
96256>>>>>            If bChar Begin
96258>>>>>                // this can get called multiple times before a search dialog pops up
96258>>>>>                Send AddToSearchKeys llKeyCode llShift
96259>>>>>            End
96259>>>>>>
96259>>>>>        End
96259>>>>>>
96259>>>>>    End_Procedure
96260>>>>>    
96260>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
96262>>>>>        Boolean bAutoSearch
96262>>>>>        Integer iKeyCode iShiftCode
96262>>>>>        Get pbAutoSearch to bAutoSearch
96263>>>>>        If bAutoSearch Begin
96265>>>>>            // this can get called multiple times before a search dialog pops up
96265>>>>>            Get piLastKey to iKeyCode
96266>>>>>            Get piLastKey2 to iShiftCode
96267>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
96268>>>>>        End
96268>>>>>>
96268>>>>>        Move True to llCancel
96269>>>>>    End_Procedure
96270>>>>>    
96270>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
96272>>>>>        Send ClearSearchRequest // kill any deferred search popup
96273>>>>>        Forward Send OnComRowDblClick llRow llItem
96275>>>>>    End_Procedure
96276>>>>>    
96276>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
96278>>>>>        Send Ok
96279>>>>>    End_Procedure
96280>>>>>    
96280>>>>>    
96280>>>>>    // we don't want a menu for prompt lists
96280>>>>>    Function CreateContextMenu Returns Handle
96282>>>>>        Function_Return 0
96283>>>>>    End_Function
96284>>>>>    
96284>>>>>    // if we use auto-ordering, change the order when the column changes
96284>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96286>>>>>        Boolean bAutoOrder
96286>>>>>        Forward Send ColumnChanged iOld iNew
96288>>>>>        Get pbAutoOrdering to bAutoOrder
96289>>>>>        If bAutoOrder Begin
96291>>>>>            // will be reordered in idle event
96291>>>>>            Set pbNeedsNewOrdering to True
96292>>>>>        End
96292>>>>>>
96292>>>>>    End_Procedure
96293>>>>>    
96293>>>>>    
96293>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96295>>>>>        Integer eMode
96295>>>>>        Integer[] SelRowsIndexes
96296>>>>>        Set pbCanceled to True // assume cancel unless changed
96297>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96298>>>>>        Get peUpdateMode to eMode
96299>>>>>        If (eMode<>umPromptNonInvoking) Begin
96301>>>>>            Send OnStoreDefaults
96302>>>>>        End
96302>>>>>>
96302>>>>>        Send InitializePromptList
96303>>>>>        Forward Send Add_Focus hoParent
96305>>>>>        Send LoadData
96306>>>>>        Set psSeedValue to ""
96307>>>>>    End_Procedure
96308>>>>>    
96308>>>>>    // called before the list is activated.
96308>>>>>    Procedure InitializePromptList
96310>>>>>        Integer hoInvokingObject
96310>>>>>        Boolean bAutoColumn bAutoSeed
96310>>>>>        Integer i iOldMode eUpdateMode
96310>>>>>        String sValue
96310>>>>>        
96310>>>>>        Get peUpdateMode to eUpdateMode
96311>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96313>>>>>            Get Focus of Desktop to hoInvokingObject
96314>>>>>            If (hoInvokingObject<=Desktop) Begin
96316>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96317>>>>>>
96317>>>>>                Procedure_Return
96318>>>>>            End
96318>>>>>>
96318>>>>>            
96318>>>>>            Set phoInvokingObject to hoInvokingObject
96319>>>>>            
96319>>>>>            Send Prompt_Callback to hoInvokingObject Self
96320>>>>>            Get peUpdateMode to eUpdateMode
96321>>>>>        End
96321>>>>>>
96321>>>>>        
96321>>>>>        Send ClearSearchRequest // clear the search keys
96322>>>>>        Set pbNeedsNewOrdering to False
96323>>>>>        
96323>>>>>        Get pbAutoSeed to bAutoSeed
96324>>>>>        
96324>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96326>>>>>            Get Value of hoInvokingObject to sValue
96327>>>>>            Set psSeedValue to sValue
96328>>>>>        End
96328>>>>>>
96328>>>>>        
96328>>>>>    End_Procedure
96329>>>>>    
96329>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96329>>>>>    Procedure LoadData
96331>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96331>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96331>>>>>        Integer eUpdateMode
96331>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96331>>>>>        
96331>>>>>        Get phoDataSource to hoDataSource
96332>>>>>        Get peUpdateMode to eUpdateMode
96333>>>>>        Get phoInvokingObject to hoInvokingObject
96334>>>>>        Get pbAutoSeed to bAutoSeed
96335>>>>>        Get piInitialColumn to iInitialColumn
96336>>>>>        Get piUpdateColumn to iUpdateColumn
96337>>>>>        Get RowCount of hoDataSource to iRows
96338>>>>>        
96338>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96338>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96338>>>>>        If (iInitialColumn=-1) Begin
96340>>>>>            Move iUpdateColumn to iInitialColumn
96341>>>>>        End
96341>>>>>>
96341>>>>>        If (iInitialColumn>=0) Begin
96343>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96344>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96345>>>>>        End
96345>>>>>>
96345>>>>>        Send OnSeedData // find a good starting place for the row
96346>>>>>        Get pbFocusSubItems to bSubFocus
96347>>>>>        If bSubFocus Begin
96349>>>>>            // if column focus, which is normal, go to initialcolumn
96349>>>>>            If hoInitialColumn Begin
96351>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96352>>>>>            End
96352>>>>>>
96352>>>>>            Else Begin
96353>>>>>                Send MoveToFirstEnterableColumn
96354>>>>>            End
96354>>>>>>
96354>>>>>        End
96354>>>>>>
96354>>>>>        
96354>>>>>    End_Procedure
96355>>>>>    
96355>>>>>    // This is only called in a successful close
96355>>>>>    Procedure ClosePromptList
96357>>>>>        Handle hoDataSource hoInvokingObject
96357>>>>>        Handle hmCallBack
96357>>>>>        Integer iRow eUpdateMode
96357>>>>>        Integer[] SelRowsIndexes
96358>>>>>        
96358>>>>>        Get phoDataSource to hoDataSource
96359>>>>>        Get phoInvokingObject to hoInvokingObject
96360>>>>>        
96360>>>>>        If (pbMultipleSelection(Self)) Begin
96362>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96363>>>>>        End
96363>>>>>>
96363>>>>>        Else Begin
96364>>>>>            Get SelectedRow of hoDataSource to iRow
96365>>>>>            If (iRow<>-1) Begin
96367>>>>>                Move iRow to SelRowsIndexes[0]
96368>>>>>            End
96368>>>>>>
96368>>>>>        End
96368>>>>>>
96368>>>>>        
96368>>>>>        Set pbCanceled to False
96369>>>>>        Set pSelectedRows to SelRowsIndexes
96370>>>>>        
96370>>>>>        Get peUpdateMode to eUpdateMode
96371>>>>>        // if non-invoking there is by definition, no move value out
96371>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96373>>>>>            
96373>>>>>            If (eUpdateMode=umPromptValue) Begin
96375>>>>>                Send OnMoveValueOutByValue
96376>>>>>            End
96376>>>>>>
96376>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96379>>>>>                Send OnMoveValueOutByCustom
96380>>>>>            End
96380>>>>>>
96380>>>>>            Get phmPromptUpdateCallback to hmCallBack
96381>>>>>            If hmCallBack Begin
96383>>>>>                Send hmCallBack of hoInvokingObject Self
96384>>>>>            End
96384>>>>>>
96384>>>>>        End
96384>>>>>>
96384>>>>>        
96384>>>>>        Send Close_Panel
96385>>>>>    End_Procedure
96386>>>>>    
96386>>>>>    // augment to send OnRestoreDefaults.
96386>>>>>    Procedure Release_Focus
96388>>>>>        Integer eUpdateMode
96388>>>>>        Get peUpdateMode to eUpdateMode
96389>>>>>        Forward Send Release_Focus
96391>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96393>>>>>            Send OnRestoreDefaults
96394>>>>>        End
96394>>>>>>
96394>>>>>    End_Procedure
96395>>>>>    
96395>>>>>    Function SelectedRowIds Returns RowID[]
96397>>>>>        RowID[] SelectedRowids
96398>>>>>        Integer[] SelectedRows
96399>>>>>        Integer i iRows
96399>>>>>        Handle hoDataSource
96399>>>>>        Get phoDataSource to hoDataSource
96400>>>>>        Get pSelectedRows to SelectedRows
96401>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96402>>>>>        For i from 0 to (iRows-1)
96408>>>>>>
96408>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96409>>>>>        Loop
96410>>>>>>
96410>>>>>        Function_Return SelectedRowids
96411>>>>>    End_Function
96412>>>>>    
96412>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96414>>>>>        String[] SelectedValues
96415>>>>>        Integer[] SelectedRows
96416>>>>>        Integer i iRows
96416>>>>>        Handle hoCol
96416>>>>>        Get ColumnObject iCol to hoCol
96417>>>>>        Get pSelectedRows to SelectedRows
96418>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96419>>>>>        For i from 0 to (iRows-1)
96425>>>>>>
96425>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96426>>>>>        Loop
96427>>>>>>
96427>>>>>        Function_Return SelectedValues
96428>>>>>    End_Function
96429>>>>>    
96429>>>>>    Procedure Ok Returns Integer
96431>>>>>        Send ClosePromptList
96432>>>>>    End_Procedure
96433>>>>>    
96433>>>>>    Procedure Cancel Returns Integer
96435>>>>>        Send Close_Panel
96436>>>>>    End_Procedure
96437>>>>>    
96437>>>>>    Procedure Search
96439>>>>>        Send Activate // give focus back to list so focus things are correct
96440>>>>>        Send Request_Search 0 0
96441>>>>>    End_Procedure
96442>>>>>    
96442>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96442>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96442>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96442>>>>>    Procedure Request_SearchEx
96444>>>>>        tGridKeyPair[] Keys
96444>>>>>        tGridKeyPair[] Keys
96445>>>>>        Integer iCol
96445>>>>>        Handle hoCol hoSearchDialog
96445>>>>>        Boolean bOk
96445>>>>>        String sValue
96445>>>>>        
96445>>>>>        Get piSortColumn to iCol
96446>>>>>        If (iCol<>-1) Begin
96448>>>>>            Get ColumnObject iCol to hoCol
96449>>>>>            Get pSearchKeys to Keys
96450>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96451>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96452>>>>>            If bOk Begin
96454>>>>>                Send RequestFindColumnValue iCol sValue True 0
96455>>>>>            End
96455>>>>>>
96455>>>>>            Send Destroy of hoSearchDialog
96456>>>>>        End
96456>>>>>>
96456>>>>>        Send ClearSearchRequest // clear the search keys
96457>>>>>    End_Procedure
96458>>>>>    
96458>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96458>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96460>>>>>        tGridKeyPair[] Keys
96460>>>>>        tGridKeyPair[] Keys
96461>>>>>        tGridKeyPair KeyPair
96461>>>>>        tGridKeyPair KeyPair
96461>>>>>        Set pbRequestSearch to True
96462>>>>>        Move iKeyCode to KeyPair.KeyCode
96463>>>>>        Move iShiftCode to KeyPair.ShiftCode
96464>>>>>        Get pSearchKeys to Keys
96465>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96466>>>>>        Set pSearchKeys to Keys
96467>>>>>    End_Procedure
96468>>>>>    
96468>>>>>    Procedure ClearSearchRequest
96470>>>>>        tGridKeyPair[] SearchKeys
96470>>>>>        tGridKeyPair[] SearchKeys
96471>>>>>        Set pSearchKeys to SearchKeys
96472>>>>>        Set pbRequestSearch to False
96473>>>>>    End_Procedure
96474>>>>>    
96474>>>>>End_Class
96475>>>>>
96475>>>Use cDbUpdateFunctionLibrary.pkg
96475>>>Use MSSqldrv.pkg
96475>>>Use db2_drv.pkg
96475>>>Use odbc_drv.pkg
96475>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96475>>>>>//****************************************************************************
96475>>>>>// $Module type: Class
96475>>>>>// $Module name: cRDCModalPanel
96475>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96475>>>>>// Created     : 2014-03-17 @ 12:33
96475>>>>>//
96475>>>>>// Description :
96475>>>>>//
96475>>>>>// $Rev History:
96475>>>>>//    2014-03-17  Module header created
96475>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96475>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96475>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96475>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96475>>>>>// in the help folder for more details.
96475>>>>>//
96475>>>>>//****************************************************************************
96475>>>>>Use Windows.pkg
96475>>>>>Use cCJCommandBarSystem.pkg   
96475>>>>>Use cCJSkinFramework.pkg
96475>>>>>
96475>>>>>Class cRDCModalPanel is a ModalPanel
96476>>>>>
96476>>>>>    Procedure Construct_Object
96478>>>>>        Forward Send Construct_Object
96480>>>>>
96480>>>>>        Set Maximize_Icon to True
96481>>>>>        Set Minimize_Icon to False
96482>>>>>        Set Border_Style to Border_Thick
96483>>>>>        Set Locate_Mode to Center_On_Parent
96484>>>>>
96484>>>>>        Property String Private_Icon
96485>>>>>        Property Handle phoDialogCommandbar
96486>>>>>    End_Procedure
96487>>>>>
96487>>>>>    Procedure Set Icon String sIcon
96489>>>>>        Forward Set Icon to sIcon
96491>>>>>        Set Private_Icon to sIcon
96492>>>>>    End_Procedure
96493>>>>>
96493>>>>>    Function Icon Returns String
96495>>>>>        String sIcon
96495>>>>>        Get Private_Icon to sIcon
96496>>>>>        Function_Return sIcon
96497>>>>>    End_Function
96498>>>>>
96498>>>>>    Procedure Page Integer iPageObject
96500>>>>>        String sIcon
96500>>>>>        Integer hWnd
96500>>>>>        
96500>>>>>        Forward Send Page iPageObject
96502>>>>>        Get Private_Icon to sIcon
96503>>>>>        If (sIcon <> "") Begin
96505>>>>>            Set Icon to sIcon
96506>>>>>        End
96506>>>>>>
96506>>>>>
96506>>>>>        Get Window_Handle to hWnd
96507>>>>>
96507>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96509>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96510>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96511>>>>>        End
96511>>>>>>
96511>>>>>    End_Procedure
96512>>>>>
96512>>>>>    // Put a status bar at the bottom of the panel, which makes
96512>>>>>    // status_help work and puts a gripper in the lower right corner.
96512>>>>>    Procedure End_Construct_Object
96514>>>>>        Integer iStyle iSize iOffset
96514>>>>>
96514>>>>>        Forward Send End_Construct_Object
96516>>>>>
96516>>>>>        Get Border_Style to iStyle
96517>>>>>        Move 8 to iOffset
96518>>>>>        If (iStyle = Border_Thick) Begin
96520>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96522>>>>>                Object oStatusBar is a cCJStatusBar
96524>>>>>                    Set phoDialogCommandbar to Self
96525>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96527>>>>>                        Set piId to sbpIDIdlePane
96528>>>>>                        Set pbStyleStretch to True
96529>>>>>                    End_Object
96530>>>>>                End_Object
96531>>>>>            End_Object
96532>>>>>            Get Size to iSize
96533>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96534>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96535>>>>>        End
96535>>>>>>
96535>>>>>
96535>>>>>    End_Procedure
96536>>>>>
96536>>>>>    Procedure Popup
96538>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96539>>>>>        Forward Send Popup
96541>>>>>    End_Procedure
96542>>>>>
96542>>>>>End_Class
96543>>>
96543>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96545>>>    Set Label to "SQL Database Selection"
96546>>>    Set Size to 119 183
96547>>>    Set piMinSize to 89 170
96548>>>    Set Location to 2 2
96549>>>    Set Border_Style to Border_Thick
96550>>>    Set Icon to "DatabaseLookup.ico"
96551>>>
96551>>>    Property String[] psTheData
96553>>>
96553>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96555>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96557>>>        End_Object
96558>>>    End
96558>>>>
96558>>>
96558>>>    Object oSelList is a cCJGridPromptList
96560>>>        Set Size to 89 167
96561>>>        Set Location to 6 6
96562>>>        Set peAnchors to anAll
96563>>>        Set pbAllowColumnRemove to False
96564>>>        Set pbUseAlternateRowBackgroundColor to True
96565>>>        Set pbGrayIfDisable to False
96566>>>        Set pbHeaderReorders to False
96567>>>        Set pbHeaderSelectsColumn to False
96568>>>        Set pbHeaderTogglesDirection to False
96569>>>        Set pbShadeSortColumn to False
96570>>>        Set piFocusCellBackColor to clDkGray
96571>>>
96571>>>        Object oName is a cCJGridColumn
96573>>>            Set piWidth to 334
96574>>>            Set psCaption to "Database Name"
96575>>>        End_Object
96576>>>
96576>>>        Procedure Activating
96579>>>            tDataSourceRow[] MyData
96579>>>            tDataSourceRow[] MyData
96580>>>            Handle hoDataSource
96580>>>            String[] sTheData
96581>>>            Integer iCount iSize
96581>>>
96581>>>            Send Cursor_Wait of Cursor_Control
96582>>>            Forward Send Activating
96584>>>
96584>>>            Get psTheData to sTheData
96585>>>            Move (SizeOfArray(sTheData)) to iSize
96586>>>            Decrement iSize
96587>>>            For iCount from 0 to iSize
96593>>>>
96593>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96594>>>            Loop
96595>>>>
96595>>>
96595>>>            Get phoDataSource to hoDataSource
96596>>>            Send InitializeData of hoDataSource MyData
96597>>>            Send Cursor_Ready of Cursor_Control
96598>>>        End_Procedure
96599>>>
96599>>>    End_Object
96600>>>
96600>>>    Object oOK_Btn is a Button
96602>>>        Set Size to 14 50
96603>>>        Set Label    to "&OK"
96604>>>        Set Location to 98 68
96605>>>        Set peAnchors To anBottomRight
96606>>>
96606>>>        Procedure OnClick
96609>>>            Send Ok of oSelList
96610>>>        End_Procedure
96611>>>
96611>>>    End_Object
96612>>>
96612>>>    Object oCancel_Btn is a Button
96614>>>        Set Size to 14 50
96615>>>        Set Label    to "&Cancel"
96616>>>        Set Location to 98 123
96617>>>        Set peAnchors to anBottomRight
96618>>>
96618>>>        Procedure OnClick
96621>>>            Send Close_Panel
96622>>>        End_Procedure
96623>>>
96623>>>    End_Object
96624>>>
96624>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96625>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96626>>>End_Object
96627>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96627>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96627>>>Use Windows.pkg
96627>>>Use vWin32fh.pkg
96627>>>
96627>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96629>>>    Set Size to 104 298
96630>>>    Set Label to "SQL Database Backup"
96631>>>    Set piMinSize to 89 211
96632>>>    Set Location to 2 4
96633>>>    Set Border_Style To Border_Thick
96634>>>
96634>>>    Property Boolean pbOK False
96636>>>    Property String  psDatabase
96638>>>    Property String  psPath
96640>>>    Property String  psBackupName
96642>>>
96642>>>    Object oDatabase_fm is a Form
96644>>>        Set Size to 13 204
96645>>>        Set Location to 14 71
96646>>>        Set Label_Justification_Mode to JMode_Right
96647>>>        Set Label_Col_Offset to 2
96648>>>        Set Label to "Database Name"
96649>>>        Set Enabled_State to False
96650>>>        Set peAnchors to anTopLeftRight
96651>>>
96651>>>        Procedure Page Integer iPageObject
96654>>>            String sValue
96654>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96655>>>            Set Value to sValue
96656>>>            Set psDatabase to sValue
96657>>>            Forward Send Page iPageObject
96659>>>        End_Procedure
96660>>>
96660>>>    End_Object
96661>>>
96661>>>    Object oBackupName_fm is a Form
96663>>>        Set Size to 13 204
96664>>>        Set Location to 29 71
96665>>>        Set Label_Justification_Mode to JMode_Right
96666>>>        Set Label_Col_Offset to 2
96667>>>        Set Label to "Backup Name"
96668>>>        Set peAnchors to anTopLeftRight
96669>>>
96669>>>        Procedure Page Integer iPageObject
96672>>>            String sValue
96672>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96673>>>            Set Value to sValue
96674>>>            Forward Send Page iPageObject
96676>>>        End_Procedure
96677>>>
96677>>>        Procedure OnChange
96680>>>            String sValue
96680>>>            Get Value to sValue
96681>>>            Set psBackupName to sValue
96682>>>        End_Procedure
96683>>>
96683>>>    End_Object
96684>>>
96684>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96686>>>        Set Size to 10 50
96687>>>        Set Location to 50 71
96688>>>        Set Label to "Use Default SQL Backup Folder"
96689>>>        Set Checked_State to True
96690>>>
96690>>>        Procedure OnChange
96693>>>            Boolean bChecked
96693>>>            Get Checked_State to bChecked
96694>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96695>>>        End_Procedure
96696>>>
96696>>>    End_Object
96697>>>
96697>>>    Object oPath_fm is a Form
96699>>>        Set Size to 13 204
96700>>>        Set Location to 62 71
96701>>>        Set Label_Justification_Mode to JMode_Right
96702>>>        Set Label_Col_Offset to 2
96703>>>        Set Label to "Path"
96704>>>        Set Prompt_Button_Mode to PB_PromptOn
96705>>>        Set peAnchors to anTopLeftRight
96706>>>        Set Enabled_State to False
96707>>>
96707>>>        Procedure Page Integer iPageObject
96710>>>            String sValue
96710>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96711>>>            Get vFolderFormat sValue to sValue
96712>>>            Move (sValue + "Backup") to sValue
96713>>>            Set Value to sValue
96714>>>            Forward Send Page iPageObject
96716>>>        End_Procedure
96717>>>
96717>>>        Procedure Prompt
96720>>>            String sPath sFileMask sRetval
96720>>>
96720>>>            Get Value to sPath
96721>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96722>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96723>>>            If (sRetval <> "") Begin
96725>>>                Get ParseFolderName sRetval to sPath
96726>>>                If (Right(sPath, 1) ="\") Begin
96728>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96729>>>                End
96729>>>>
96729>>>                Set Value to sPath
96730>>>            End
96730>>>>
96730>>>        End_Procedure
96731>>>
96731>>>        Procedure OnChange
96734>>>            String sValue
96734>>>            Get Value to sValue
96735>>>            Set psPath to sValue
96736>>>        End_Procedure
96737>>>
96737>>>    End_Object
96738>>>
96738>>>    Object oOK_Btn is a Button
96740>>>        Set Label    to "&OK"
96741>>>        Set Location to 81 169
96742>>>        Set peAnchors to anBottomRight
96743>>>
96743>>>        Procedure OnClick
96746>>>            Set pbOK to True
96747>>>            Send Close_Panel
96748>>>        End_Procedure
96749>>>
96749>>>    End_Object
96750>>>
96750>>>    Object oCancel_Btn is a Button
96752>>>        Set Label    to "&Cancel"
96753>>>        Set Location to 81 224
96754>>>        Set peAnchors to anBottomRight
96755>>>
96755>>>        Procedure OnClick
96758>>>            Set pbOK to False
96759>>>            Send Close_Panel
96760>>>        End_Procedure
96761>>>
96761>>>    End_Object
96762>>>
96762>>>    Object oButton1 is a Button
96764>>>        Set Size to 14 96
96765>>>        Set Location to 80 32
96766>>>        Set Label to "Enum table types"
96767>>>        Set Visible_State to False
96768>>>        
96768>>>        Procedure OnClick
96771>>>            String sDriverID
96771>>>            tSQLConnection SQLConnection
96771>>>            tSQLConnection SQLConnection
96771>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96772>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96773>>>        End_Procedure
96774>>>
96774>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96777>>>            Handle hoCLIHandler
96777>>>            Integer iNumTables iTableCount
96777>>>
96777>>>            Get Create U_cCLIHandler to hoCLIhandler
96778>>>            If (hoCLIHandler > 0) Begin
96780>>>                Set psDriverID of hoCLIHandler to sDriver
96781>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96782>>>                For iTableCount from 1 to iNumTables
96788>>>>
96788>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96790>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96792>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96794>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96796>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96796>>>//                    For iColumnCount from 1 to iNumColumns
96796>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96796>>>//                    Loop
96796>>>                    Showln
96797>>>                Loop
96798>>>>
96798>>>                Send Destroy of hoCLIHandler
96799>>>            End
96799>>>>
96799>>>        End_Procedure
96800>>>
96800>>>    End_Object
96801>>>
96801>>>    Procedure Page Integer iPageObject
96804>>>        Set Icon to "DbBackup.ico"
96805>>>        Forward Send Page iPageObject
96807>>>    End_Procedure
96808>>>
96808>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96809>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96810>>>
96810>>>End_Object
96811>>>
96811>>>// *** General purpose access method for this dialog ***
96811>>>Function MakeSQLDatabaseBackup Returns Boolean
96814>>>    Handle ho
96814>>>    Boolean bOK bDefault
96814>>>    String sDatabase sPath sBackupName
96814>>>
96814>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96815>>>    Set pbOK of ho to False
96816>>>    Send Popup of ho
96817>>>
96817>>>    Get pbOk of ho to bOK
96818>>>    If (bOK = True) Begin
96820>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96821>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96822>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96823>>>        If (bDefault = False) Begin
96825>>>            Get Value of (oPath_fm(ho)) to sPath
96826>>>        End
96826>>>>
96826>>>        Send StartStatusPanel "The Database Update Framework" "Backup of SQL Database" 100
96827>>>
96827>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96828>>>
96828>>>        Send StopStatusPanel
96829>>>    End
96829>>>>
96829>>>
96829>>>    Function_Return bOK
96830>>>End_Function
96831>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96831>>>Use Windows.pkg
96831>>>Use DFClient.pkg
96831>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96831>>>>>// Provides support for db aware scrolling containers.
96831>>>>>// Scrolling containers is provided by creating two objects,
96831>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96831>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96831>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96831>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96831>>>>>
96831>>>>>Use DFClient.pkg
96831>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96831>>>>>>>// Mixin classes for scrolling container support:
96831>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96831>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96831>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96831>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96831>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96831>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96831>>>>>>>
96831>>>>>>>Use Windows.pkg
96831>>>>>>>Use Winuser.pkg
96831>>>>>>>Use tWinStructs.pkg
96831>>>>>>>
96831>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96831>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96831>>>>>>>// support for the scrolling client area mixin object.
96831>>>>>>>
96831>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96832>>>>>>>    
96832>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96834>>>>>>>        
96834>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96835>>>>>>>        Set Border_Style to Border_None
96836>>>>>>>        
96836>>>>>>>        Property Boolean pbAutoScroll True
96837>>>>>>>        Property Boolean pbAutoScrollFocus True
96838>>>>>>>        Property Integer piAutoScrollMarginX 5
96839>>>>>>>        Property Integer piAutoScrollMarginY 5
96840>>>>>>>        Property Integer piAutoScrollMinX 0
96841>>>>>>>        Property Integer piAutoScrollMinY 0
96842>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96843>>>>>>>        
96843>>>>>>>        
96843>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96844>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96845>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96846>>>>>>>        // keeps track of scrolling
96846>>>>>>>        Property Integer piCurrentVertScrolled 0
96847>>>>>>>        Property Integer piCurrentHorzScrolled 0
96848>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96849>>>>>>>        Delegate Set phoScrollingClientArea to Self
96851>>>>>>>        
96851>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96851>>>>>>>        Property Boolean pbTabWorkspaceView False
96852>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96852>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96853>>>>>>>    End_Procedure
96854>>>>>>>    
96854>>>>>>>    // low level event sent from windows.
96854>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96856>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96856>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96857>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96858>>>>>>>        If (wParam<0) Begin
96860>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96861>>>>>>>        End
96861>>>>>>>>
96861>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96862>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96863>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96863>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96864>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96865>>>>>>>        // If we have enough Clicks send OnMouseWheel
96865>>>>>>>        If (iClicks<>0) Begin
96867>>>>>>>            Send OnMouseWheel iClicks iKeys
96868>>>>>>>        End
96868>>>>>>>>
96868>>>>>>>        // tell windows that we've handled the event.
96868>>>>>>>        Set Windows_Override_State to True
96869>>>>>>>    End_Procedure
96870>>>>>>>    
96870>>>>>>>    
96870>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96870>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96872>>>>>>>        Integer iLineScrollUnit
96872>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96873>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96874>>>>>>>    End_Procedure
96875>>>>>>>    
96875>>>>>>>    // should be sent by WM_VSCROLL
96875>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96877>>>>>>>        Boolean bOk
96877>>>>>>>        tWinScrollInfo ScrollInfo
96877>>>>>>>        tWinScrollInfo ScrollInfo
96877>>>>>>>        Integer iLineScrollUnit
96877>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96878>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96879>>>>>>>        If bOk Begin
96881>>>>>>>            
96881>>>>>>>            Case Begin
96881>>>>>>>                Case (iType=SB_PAGEDOWN)
96883>>>>>>>                    Send VScroll ScrollInfo.nPage
96884>>>>>>>                    Case Break
96885>>>>>>>                
96885>>>>>>>                Case (iType=SB_PAGEUP)
96888>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96889>>>>>>>                    Case Break
96890>>>>>>>                
96890>>>>>>>                Case (iType=SB_LINEDOWN)
96893>>>>>>>                    Send VScroll iLineScrollUnit
96894>>>>>>>                    Case Break
96895>>>>>>>                
96895>>>>>>>                Case (iType=SB_LINEUP)
96898>>>>>>>                    Send VScroll (-iLineScrollUnit)
96899>>>>>>>                    Case Break
96900>>>>>>>                
96900>>>>>>>                Case (iType=SB_BOTTOM)
96903>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96904>>>>>>>                    Case Break
96905>>>>>>>                
96905>>>>>>>                Case (iType=SB_Top)
96908>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96909>>>>>>>                    Case Break
96910>>>>>>>                
96910>>>>>>>                Case (iType=SB_THUMBPOSITION)
96913>>>>>>>                    Case Break
96914>>>>>>>                
96914>>>>>>>                Case (iType=SB_THUMBTRACK)
96917>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96918>>>>>>>                    Case Break
96919>>>>>>>            Case End
96919>>>>>>>        End
96919>>>>>>>>
96919>>>>>>>    End_Procedure
96920>>>>>>>    
96920>>>>>>>    // should be sent by WM_HSCROLL
96920>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96922>>>>>>>        Boolean bOk
96922>>>>>>>        tWinScrollInfo ScrollInfo
96922>>>>>>>        tWinScrollInfo ScrollInfo
96922>>>>>>>        Integer iLineScrollUnit
96922>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96923>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96924>>>>>>>        If bOk Begin
96926>>>>>>>            
96926>>>>>>>            Case Begin
96926>>>>>>>                Case (iType=SB_PAGEDOWN)
96928>>>>>>>                    Send hScroll ScrollInfo.nPage
96929>>>>>>>                    Case Break
96930>>>>>>>                
96930>>>>>>>                Case (iType=SB_PAGEUP)
96933>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96934>>>>>>>                    Case Break
96935>>>>>>>                
96935>>>>>>>                Case (iType=SB_LINEDOWN)
96938>>>>>>>                    Send hScroll iLineScrollUnit
96939>>>>>>>                    Case Break
96940>>>>>>>                
96940>>>>>>>                Case (iType=SB_LINEUP)
96943>>>>>>>                    Send hScroll (-iLineScrollUnit)
96944>>>>>>>                    Case Break
96945>>>>>>>                
96945>>>>>>>                Case (iType=SB_BOTTOM)
96948>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96949>>>>>>>                    Case Break
96950>>>>>>>                
96950>>>>>>>                Case (iType=SB_Top)
96953>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96954>>>>>>>                    Case Break
96955>>>>>>>                
96955>>>>>>>                Case (iType=SB_THUMBPOSITION)
96958>>>>>>>                    Case Break
96959>>>>>>>                
96959>>>>>>>                Case (iType=SB_THUMBTRACK)
96962>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96963>>>>>>>                    Case Break
96964>>>>>>>            Case End
96964>>>>>>>        End
96964>>>>>>>>
96964>>>>>>>    End_Procedure
96965>>>>>>>    
96965>>>>>>>    
96965>>>>>>>    // this calls SetScrollInfo with proper info
96965>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96967>>>>>>>        tWinScrollInfo ScrollInfo
96967>>>>>>>        tWinScrollInfo ScrollInfo
96967>>>>>>>        Integer iVoid
96967>>>>>>>        Handle hWnd
96967>>>>>>>        Boolean bShow
96967>>>>>>>        
96967>>>>>>>        Delegate Get Window_Handle to hWnd
96969>>>>>>>        If (hWnd <> 0) Begin
96971>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96972>>>>>>>            
96972>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96973>>>>>>>            Get pbShowDisabledScrollBar to bShow
96974>>>>>>>            If bShow Begin
96976>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96977>>>>>>>            End
96977>>>>>>>>
96977>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96978>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96979>>>>>>>            Move iPageSize to ScrollInfo.nPage
96980>>>>>>>            Move 0 to ScrollInfo.nPos
96981>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96982>>>>>>>            
96982>>>>>>>        End
96982>>>>>>>>
96982>>>>>>>    End_Procedure
96983>>>>>>>    
96983>>>>>>>    // this wraps GetScrollInfo
96983>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96985>>>>>>>        Boolean bOk
96985>>>>>>>        Handle hWnd
96985>>>>>>>        
96985>>>>>>>        Delegate Get Window_Handle to hWnd
96987>>>>>>>        If (hWnd <> 0) Begin
96989>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96990>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96991>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96992>>>>>>>        End
96992>>>>>>>>
96992>>>>>>>        Function_Return bOk
96993>>>>>>>    End_Function
96994>>>>>>>    
96994>>>>>>>    // this wraps SetScrollPos
96994>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96996>>>>>>>        Integer iVoid
96996>>>>>>>        Handle hWnd
96996>>>>>>>        
96996>>>>>>>        Delegate Get Window_Handle to hWnd
96998>>>>>>>        If (hWnd <> 0) Begin
97000>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
97001>>>>>>>        End
97001>>>>>>>>
97001>>>>>>>    End_Procedure
97002>>>>>>>    
97002>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
97002>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
97002>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
97004>>>>>>>        Send ScrollClientArea
97005>>>>>>>    End_Procedure
97006>>>>>>>    
97006>>>>>>>    // augment to handle the scrolling area initialization.
97006>>>>>>>    Procedure Add_Focus Handle hoParent
97008>>>>>>>        Forward Send Add_Focus hoParent
97010>>>>>>>        // at this the scrolling container and client area should both be paged.
97010>>>>>>>        // child objects ae also paged with initial anchors applied
97010>>>>>>>        Send CalculateAutoScrollMinimums
97011>>>>>>>    End_Procedure
97012>>>>>>>    
97012>>>>>>>    Procedure Page Integer iPage
97014>>>>>>>        Forward Send Page iPage
97016>>>>>>>        If iPage Begin
97018>>>>>>>            // at this the scrolling container and client area should both be paged
97018>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
97018>>>>>>>            // the child items are paged (else they may get anchored oddly)
97018>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
97018>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
97018>>>>>>>            // before they were really needed. This should be more accurate
97018>>>>>>>            Send SetScrollBarInfo True 0 0 0
97019>>>>>>>            Send SetScrollBarInfo False 0 0 0
97020>>>>>>>        End
97020>>>>>>>>
97020>>>>>>>    End_Procedure
97021>>>>>>>    
97021>>>>>>>    // determine scrolling minimums and set the client area as required.
97021>>>>>>>    
97021>>>>>>>    Procedure CalculateAutoScrollMinimums
97023>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
97023>>>>>>>        Integer iAutoMinX iAutoMinY
97023>>>>>>>        Boolean bAutoScroll
97023>>>>>>>        Handle hoNext hoFirst
97023>>>>>>>        
97023>>>>>>>        Get pbAutoScroll to bAutoScroll
97024>>>>>>>        Get piAutoScrollMinX to iAutoMinX
97025>>>>>>>        Get piAutoScrollMinY to iAutoMinY
97026>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
97027>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
97028>>>>>>>        Move (Low(iSiz)) to iAutoMinX
97029>>>>>>>        Set piMinimumHeight to iAutoMinY
97030>>>>>>>        Set piMinimumWidth to iAutoMinX
97031>>>>>>>        
97031>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
97033>>>>>>>            
97033>>>>>>>            Get Next_Level to hoFirst
97034>>>>>>>            Move hoFirst to hoNext
97035>>>>>>>            If (hoFirst) Begin
97037>>>>>>>                Repeat
97037>>>>>>>>
97037>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
97038>>>>>>>                    Get GuiLocation of hoNext to iLoc
97039>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
97040>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
97041>>>>>>>                    Get Next_Focus of hoNext to hoNext
97042>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
97044>>>>>>>                
97044>>>>>>>                If (iAutoMinY=0) Begin
97046>>>>>>>                    Get piAutoScrollMarginY to iMargin
97047>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
97048>>>>>>>                End
97048>>>>>>>>
97048>>>>>>>                
97048>>>>>>>                If (iAutoMinX=0) Begin
97050>>>>>>>                    Get piAutoScrollMarginX to iMargin
97051>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
97052>>>>>>>                    
97052>>>>>>>                End
97052>>>>>>>>
97052>>>>>>>            End
97052>>>>>>>>
97052>>>>>>>        End
97052>>>>>>>>
97052>>>>>>>        
97052>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
97052>>>>>>>        Broadcast Set pbAnchorCreated to False
97054>>>>>>>        Send ScrollClientArea
97055>>>>>>>        // after the scroll set up, reinitialize all anchors.
97055>>>>>>>        Broadcast Send DoCreateAnchors
97057>>>>>>>    End_Procedure
97058>>>>>>>    
97058>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
97058>>>>>>>    // work of scrolling.
97058>>>>>>>    
97058>>>>>>>    Procedure ScrollClientArea
97060>>>>>>>        Integer iSiz
97060>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
97060>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
97060>>>>>>>        Integer iSzY iSzX iLocX iLocY
97060>>>>>>>        
97060>>>>>>>        Delegate Get GuiClientSize to iSiz
97062>>>>>>>        Move (Hi(iSiz)) to iHeight
97063>>>>>>>        Move (Low(iSiz)) to iWidth
97064>>>>>>>        
97064>>>>>>>        // Vertical scrolling
97064>>>>>>>        
97064>>>>>>>        Get piMinimumHeight to iOrig
97065>>>>>>>        Get piMinimumWidth to iWOrig
97066>>>>>>>        
97066>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
97068>>>>>>>            
97068>>>>>>>            If (iOrig<>0) Begin
97070>>>>>>>                Get piCurrentVertScrolled to iHCur
97071>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
97071>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
97073>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
97074>>>>>>>                    Set piCurrentVertScrolled to iHCur
97075>>>>>>>                End
97075>>>>>>>>
97075>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
97077>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
97078>>>>>>>                    Send SetScrollBarPosInfo True iHCur
97079>>>>>>>                End
97079>>>>>>>>
97079>>>>>>>                Else Begin
97080>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
97081>>>>>>>                End
97081>>>>>>>>
97081>>>>>>>            End
97081>>>>>>>>
97081>>>>>>>            
97081>>>>>>>            // Horiz scrolling
97081>>>>>>>            
97081>>>>>>>            Get piCurrentHorzScrolled to iWCur
97082>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
97082>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
97084>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
97085>>>>>>>                Set piCurrentHorzScrolled to iWCur
97086>>>>>>>            End
97086>>>>>>>>
97086>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
97088>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
97089>>>>>>>                Send SetScrollBarPosInfo False iWCur
97090>>>>>>>            End
97090>>>>>>>>
97090>>>>>>>            Else Begin
97091>>>>>>>                Send SetScrollBarInfo False 0 0 0
97092>>>>>>>            End
97092>>>>>>>>
97092>>>>>>>        End
97092>>>>>>>>
97092>>>>>>>        
97092>>>>>>>        // this could change depending on scrollbars appearing or not
97092>>>>>>>        Delegate Get GuiClientSize to iSiz
97094>>>>>>>        
97094>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
97094>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
97094>>>>>>>        // This is required to make anchors work sensibly
97094>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
97095>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
97096>>>>>>>        Move (-iHCur) to iLocY
97097>>>>>>>        Move (-iWCur) to iLocX
97098>>>>>>>        
97098>>>>>>>        // Allow chance to make modifications
97098>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
97099>>>>>>>        
97099>>>>>>>        Set GuiSize to iSzY iSzX
97100>>>>>>>        // if we've scrolled, we need to reposition the container
97100>>>>>>>        Set GuiLocation to iLocY iLocX
97101>>>>>>>    End_Procedure
97102>>>>>>>    
97102>>>>>>>    // note that scrolling never changes the size of the scrolling client.
97102>>>>>>>    // this way, it does not interfere with anchors.
97102>>>>>>>    
97102>>>>>>>    Procedure VScroll Integer iDelta
97104>>>>>>>        Integer iHeight iCur iOrig iSiz
97104>>>>>>>        Delegate Get GuiClientSize to iSiz
97106>>>>>>>        Move (hi(iSiz)) to iHeight
97107>>>>>>>        Get piCurrentVertScrolled to iCur
97108>>>>>>>        Get piMinimumHeight to iOrig
97109>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
97111>>>>>>>            Procedure_Return
97112>>>>>>>        End
97112>>>>>>>>
97112>>>>>>>        // make sure delta is within range
97112>>>>>>>        If (iDelta+iCur<0) Begin
97114>>>>>>>            Move (-iCur) to iDelta
97115>>>>>>>        End
97115>>>>>>>>
97115>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97118>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97119>>>>>>>        End
97119>>>>>>>>
97119>>>>>>>        If (iDelta=0) ;            Procedure_Return
97122>>>>>>>        
97122>>>>>>>        Move (iCur + iDelta) to iCur
97123>>>>>>>        Set piCurrentVertScrolled to iCur
97124>>>>>>>        Send SetScrollBarPosInfo True iCur
97125>>>>>>>        Get GuiLocation to iSiz
97126>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
97127>>>>>>>        Send ScrollClientArea
97128>>>>>>>    End_Procedure
97129>>>>>>>    
97129>>>>>>>    
97129>>>>>>>    Procedure HScroll Integer iDelta
97131>>>>>>>        Integer iHeight iCur iOrig iSiz
97131>>>>>>>        Delegate Get GuiClientSize to iSiz
97133>>>>>>>        Move (low(iSiz)) to iHeight
97134>>>>>>>        Get piCurrentHorzScrolled to iCur
97135>>>>>>>        Get piMinimumWidth to iOrig
97136>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
97138>>>>>>>            Procedure_Return
97139>>>>>>>        End
97139>>>>>>>>
97139>>>>>>>        If (iDelta+iCur<0) Begin
97141>>>>>>>            Move (-iCur) to iDelta
97142>>>>>>>        End
97142>>>>>>>>
97142>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97145>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97146>>>>>>>        End
97146>>>>>>>>
97146>>>>>>>        If (iDelta=0) ;            Procedure_Return
97149>>>>>>>        
97149>>>>>>>        Move (iCur + iDelta) to iCur
97150>>>>>>>        Set piCurrentHorzScrolled to iCur
97151>>>>>>>        Send SetScrollBarPosInfo False iCur
97152>>>>>>>        Get GuiLocation to iSiz
97153>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
97154>>>>>>>        Send ScrollClientArea
97155>>>>>>>    End_Procedure
97156>>>>>>>    
97156>>>>>>>    // make sure client is a 0,0
97156>>>>>>>    Procedure ScrollHome
97158>>>>>>>        Send SetVScrollbox SB_TOP 0
97159>>>>>>>        Send SetHScrollbox SB_TOP 0
97160>>>>>>>    End_Procedure
97161>>>>>>>    
97161>>>>>>>    // get relative GUI location of this object to the parent one passed.
97161>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
97163>>>>>>>        Integer ivoid
97163>>>>>>>        tWinRect Rect0 Rect1
97163>>>>>>>        tWinRect Rect0 Rect1
97163>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
97164>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
97165>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
97166>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
97167>>>>>>>    End_Procedure
97168>>>>>>>    
97168>>>>>>>    // This scrolls this object into visual range.
97168>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
97170>>>>>>>        Handle hoScrollingContainer
97170>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
97170>>>>>>>        Integer iViewHeight iViewWidth
97170>>>>>>>        Integer iRelLocHeight iRelLocWidth
97170>>>>>>>        Integer iSize iControlHeight iControlWidth
97170>>>>>>>        Integer iScroll
97170>>>>>>>        Integer iMarginX iMarginY
97170>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
97170>>>>>>>        
97170>>>>>>>        Get piAutoScrollMarginX to iMarginX
97171>>>>>>>        Get piAutoScrollMarginY to iMarginY
97172>>>>>>>        
97172>>>>>>>        // the scrolling container
97172>>>>>>>        Move Self to hoScrollingContainer
97173>>>>>>>        // the amount the SC is currently scrolled
97173>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
97174>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
97175>>>>>>>        
97175>>>>>>>        // size of view's client area (this is the viewport area)
97175>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
97176>>>>>>>        Move (hi(iSize)) to iViewHeight
97177>>>>>>>        Move (low(iSize)) to iViewWidth
97178>>>>>>>        
97178>>>>>>>        // get this object's location relative to the scrolling container
97178>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
97179>>>>>>>        
97179>>>>>>>        // we expect that the client size is the window size but just in case
97179>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
97180>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
97181>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
97182>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
97183>>>>>>>        
97183>>>>>>>        // the outer size of the control object
97183>>>>>>>        Get GUIWindowSize of hoControl to iSize
97184>>>>>>>        Move (hi(iSize)) to iControlHeight
97185>>>>>>>        Move (low(iSize)) to iControlWidth
97186>>>>>>>        
97186>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
97186>>>>>>>        
97186>>>>>>>        // Vertical Scroll
97186>>>>>>>        
97186>>>>>>>        // Vertical Scroll down
97186>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
97186>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
97188>>>>>>>            
97188>>>>>>>            // set scroll amount so that the bottom of the control is visible
97188>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
97189>>>>>>>            
97189>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
97189>>>>>>>            // top of the object appears at the bottom
97189>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
97191>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
97192>>>>>>>            End
97192>>>>>>>>
97192>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
97192>>>>>>>            If (iScroll>0) Begin
97194>>>>>>>                Send VScroll of hoScrollingContainer iScroll
97195>>>>>>>            End
97195>>>>>>>>
97195>>>>>>>        End
97195>>>>>>>>
97195>>>>>>>        // else vertical scroll up
97195>>>>>>>        // We scroll if the top of the object is not visible.
97195>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
97198>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
97198>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
97199>>>>>>>            If (iScroll<0) Begin
97201>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
97202>>>>>>>            End
97202>>>>>>>>
97202>>>>>>>        End
97202>>>>>>>>
97202>>>>>>>        
97202>>>>>>>        // Horizonal Scroll
97202>>>>>>>        
97202>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
97202>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
97204>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
97205>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
97207>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
97208>>>>>>>            End
97208>>>>>>>>
97208>>>>>>>            If (iScroll>0) Begin
97210>>>>>>>                Send HScroll of hoScrollingContainer iScroll
97211>>>>>>>            End
97211>>>>>>>>
97211>>>>>>>        End
97211>>>>>>>>
97211>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
97213>>>>>>>            // if this can fit by moving all the way to left, do so.
97213>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
97215>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97216>>>>>>>            End
97216>>>>>>>>
97216>>>>>>>            Else Begin
97217>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97218>>>>>>>            End
97218>>>>>>>>
97218>>>>>>>            If (iScroll<0) Begin
97220>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97221>>>>>>>            End
97221>>>>>>>>
97221>>>>>>>        End
97221>>>>>>>>
97221>>>>>>>        
97221>>>>>>>        
97221>>>>>>>    End_Procedure
97222>>>>>>>    
97222>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97222>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97224>>>>>>>        Boolean bScrollOnFocus
97224>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97225>>>>>>>        If bScrollOnFocus Begin
97227>>>>>>>            Send ScrollObjectInRange hoControl
97228>>>>>>>        End
97228>>>>>>>>
97228>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97230>>>>>>>    End_Procedure
97231>>>>>>>    
97231>>>>>>>    
97231>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97233>>>>>>>        Boolean bCenter
97233>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97234>>>>>>>        Function_Return bCenter
97235>>>>>>>    End_Function
97236>>>>>>>    
97236>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97238>>>>>>>        Boolean bTabWorkspaceView
97238>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
97239>>>>>>>        If bTabWorkspaceView Begin
97241>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
97242>>>>>>>        End
97242>>>>>>>>
97242>>>>>>>    End_Procedure
97243>>>>>>>    
97243>>>>>>>    Function ParentView Returns Handle
97245>>>>>>>        Function_Return (Parent(Parent(Self)))
97246>>>>>>>    End_Function
97247>>>>>>>    
97247>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97249>>>>>>>        Integer iSize iMax iDiff
97249>>>>>>>        Handle hoView
97249>>>>>>>        Boolean bCenter bModal
97249>>>>>>>        Get ParentView to hoView
97250>>>>>>>        Get Block_Mouse_State of hoView to bModal
97251>>>>>>>        If not bModal Begin
97253>>>>>>>            Get CenterTabWorkspaceView to bCenter
97254>>>>>>>            Get GuiSize of hoView to iSize
97255>>>>>>>            Get piMaxSize of hoView to iMax
97256>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97257>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97259>>>>>>>                If bCenter Begin
97261>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97262>>>>>>>                End
97262>>>>>>>>
97262>>>>>>>                Move (Low(iMax)) to iWidth
97263>>>>>>>            End
97263>>>>>>>>
97263>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97265>>>>>>>                If bCenter Begin
97267>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97268>>>>>>>                    Move (iLocy min 25) to  iLocY
97269>>>>>>>                End
97269>>>>>>>>
97269>>>>>>>                Move (Hi(imax)) to iHeight
97270>>>>>>>            End
97270>>>>>>>>
97270>>>>>>>        End
97270>>>>>>>>
97270>>>>>>>    End_Procedure
97271>>>>>>>    
97271>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97271>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97271>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97271>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97271>>>>>>>    // This should almost always yield the right answer.
97271>>>>>>>    // This is called by the scrolling container's end_constructor
97271>>>>>>>    Procedure AutoSetTabWorkspaceView
97273>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97273>>>>>>>        Handle hoParent
97273>>>>>>>        Integer iSize
97273>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97274>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97276>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97277>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97277>>>>>>>            // change this after the commandbar is paged.
97277>>>>>>>            If (bTabView) Begin
97279>>>>>>>                Get ParentView to hoParent
97280>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97281>>>>>>>                If (bIsView) Begin
97283>>>>>>>                    // set this as a tab workspace view
97283>>>>>>>                    Set pbTabWorkspaceView to True
97284>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97284>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97284>>>>>>>                    Set pbAutoScroll to True
97285>>>>>>>                    
97285>>>>>>>                End
97285>>>>>>>>
97285>>>>>>>            End
97285>>>>>>>>
97285>>>>>>>        End
97285>>>>>>>>
97285>>>>>>>    End_Procedure
97286>>>>>>>    
97286>>>>>>>End_Class
97287>>>>>>>
97287>>>>>>>// Container scrolling class support. Nothing in here is public
97287>>>>>>>Class cScrollingContainerMixin is a Mixin
97288>>>>>>>    
97288>>>>>>>    Procedure Define_cScrollingContainerMixin
97290>>>>>>>        Forward Set Border_Style to Border_None
97292>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97293>>>>>>>        Forward Set peAnchors to anAll
97295>>>>>>>        
97295>>>>>>>        // forcing scrollbars right away seems to make painting better
97295>>>>>>>        Set Window_Style WS_HSCROLL to True
97296>>>>>>>        Set Window_Style WS_VSCROLL to True
97297>>>>>>>        
97297>>>>>>>        Property Handle phoScrollingClientArea 0
97298>>>>>>>    End_Procedure
97299>>>>>>>    
97299>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97299>>>>>>>    Procedure Set peAnchors Integer eAnchors
97301>>>>>>>    End_Procedure
97302>>>>>>>    
97302>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97302>>>>>>>    Procedure Set Border_Style Integer eStyle
97304>>>>>>>    End_Procedure
97305>>>>>>>    
97305>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97305>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97307>>>>>>>        Handle hoClient
97307>>>>>>>        Get phoScrollingClientArea to hoClient
97308>>>>>>>        If hoClient Begin
97310>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97311>>>>>>>        End
97311>>>>>>>>
97311>>>>>>>    End_Procedure
97312>>>>>>>    
97312>>>>>>>    // should be sent by WM_VSCROLL
97312>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97314>>>>>>>        Handle hoClient
97314>>>>>>>        Get phoScrollingClientArea to hoClient
97315>>>>>>>        If hoClient Begin
97317>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97318>>>>>>>        End
97318>>>>>>>>
97318>>>>>>>    End_Procedure
97319>>>>>>>    
97319>>>>>>>    // should be sent by WM_HSCROLL
97319>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97321>>>>>>>        Handle hoClient
97321>>>>>>>        Get phoScrollingClientArea to hoClient
97322>>>>>>>        If hoClient Begin
97324>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97325>>>>>>>        End
97325>>>>>>>>
97325>>>>>>>    End_Procedure
97326>>>>>>>    
97326>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97326>>>>>>>    // After this is set, anchors will handle any further resizing.
97326>>>>>>>    Procedure Page Integer iState
97328>>>>>>>        Integer iSiz iHeight iWidth
97328>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97328>>>>>>>        Boolean bGroup
97328>>>>>>>        Handle hoClient
97328>>>>>>>        If (iState =1) Begin
97330>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97332>>>>>>>            // We have special code to support groups because they
97332>>>>>>>            // draw a border inside of the client rectangle
97332>>>>>>>            If bGroup Begin
97334>>>>>>>                Get Physical_FontSize to iFontSize
97335>>>>>>>                Move (Hi(iFontSize)) to iTop
97336>>>>>>>                Move 2 to iLeft
97337>>>>>>>                Move 2 to iRight
97338>>>>>>>                Move 2 to iBottom
97339>>>>>>>            End
97339>>>>>>>>
97339>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97339>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97339>>>>>>>            // makes anchors work properly with unpaged tab-pages
97339>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97341>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97342>>>>>>>            Set GuiLocation to iTop iLeft
97343>>>>>>>            Send Adjust_Logicals
97344>>>>>>>        End
97344>>>>>>>>
97344>>>>>>>        Forward Send Page iState
97346>>>>>>>    End_Procedure
97347>>>>>>>    
97347>>>>>>>    Procedure End_Construct_Object
97349>>>>>>>        Handle hoClient
97349>>>>>>>        Forward Send End_Construct_Object
97351>>>>>>>        Get phoScrollingClientArea to hoClient
97352>>>>>>>        If (hoClient) Begin
97354>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97355>>>>>>>        End
97355>>>>>>>>
97355>>>>>>>    End_Procedure
97356>>>>>>>    
97356>>>>>>>End_Class
97357>>>>>
97357>>>>>Class cDbScrollingClientArea is a dbContainer3d
97358>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97359>>>>>    Procedure Construct_Object
97361>>>>>        Forward Send Construct_Object
97363>>>>>        Send Define_cScrollingClientAreaMixin
97364>>>>>    End_Procedure
97365>>>>>End_Class
97366>>>>>
97366>>>>>
97366>>>>>
97366>>>>>Class cDbScrollingContainer is a dbContainer3d
97367>>>>>    Import_Class_Protocol cScrollingContainerMixin
97368>>>>>    Procedure Construct_Object
97370>>>>>        Forward Send Construct_Object
97372>>>>>        Send Define_cScrollingContainerMixin
97373>>>>>    End_Procedure
97374>>>>>End_Class
97375>>>Use cDbUpdateFunctionLibrary.pkg
97375>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\Lib\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97375>>>>>//****************************************************************************
97375>>>>>// $Module type: Package
97375>>>>>// $Module name: cRDCButtonDPI.pkg
97375>>>>>//
97375>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97375>>>>>// Copyright (c) 2013 RDC Tools International
97375>>>>>// E-mail      : support@rdctools.com
97375>>>>>// Web-site    : http://www.rdctools.com
97375>>>>>//
97375>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97375>>>>>//
97375>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97375>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97375>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97375>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97375>>>>>// in the help folder for more details.
97375>>>>>//
97375>>>>>//****************************************************************************
97375>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\Lib\RDCToolsLib\AppSrc\cRDCButton.pkg)
97375>>>>>>>//****************************************************************************
97375>>>>>>>// $Module type: Package
97375>>>>>>>// $Module name: cRDCButton.pkg
97375>>>>>>>//
97375>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97375>>>>>>>// Copyright (c) 2013 RDC Tools International
97375>>>>>>>// E-mail      : support@rdctools.com
97375>>>>>>>// Web-site    : http://www.rdctools.com
97375>>>>>>>//
97375>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97375>>>>>>>//
97375>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97375>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97375>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97375>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97375>>>>>>>// in the help folder for more details.
97375>>>>>>>//
97375>>>>>>>//****************************************************************************
97375>>>>>>>Use Windows.pkg
97375>>>>>>>Use Enclient.pkg
97375>>>>>>>Use errornum.inc
97375>>>>>>>
97375>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97376>>>>>>>    Procedure Construct_Object
97378>>>>>>>        Forward Send Construct_Object
97380>>>>>>>
97380>>>>>>>    End_Procedure
97381>>>>>>>
97381>>>>>>>    Procedure OnIdle
97383>>>>>>>        Delegate Send DoUpdate
97385>>>>>>>    End_Procedure
97386>>>>>>>
97386>>>>>>>End_Class
97387>>>>>>>
97387>>>>>>>Class cRDCButton is a Button
97388>>>>>>>
97388>>>>>>>    Procedure Construct_Object
97390>>>>>>>        Forward Send Construct_Object
97392>>>>>>>
97392>>>>>>>        Property Boolean pbAutoEnable True
97393>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97394>>>>>>>
97394>>>>>>>        Property Boolean pbEnabled True
97395>>>>>>>
97395>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97396>>>>>>>    End_Procedure
97397>>>>>>>
97397>>>>>>>    Procedure CancelIfPopupObject
97399>>>>>>>        Boolean bIsInPopupObject
97399>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97401>>>>>>>        If (bIsInPopupObject = True) Begin
97403>>>>>>>            Send Close_Panel
97404>>>>>>>        End
97404>>>>>>>>
97404>>>>>>>    End_Procedure
97405>>>>>>>
97405>>>>>>>    Procedure End_Construct_Object
97407>>>>>>>        String sTooltip sStatus_Help
97407>>>>>>>
97407>>>>>>>        Forward Send End_Construct_Object
97409>>>>>>>
97409>>>>>>>        Get psToolTip   to sTooltip
97410>>>>>>>        Get Status_Help to sStatus_Help
97411>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97413>>>>>>>            Set psToolTip to sStatus_Help
97414>>>>>>>        End
97414>>>>>>>>
97414>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97416>>>>>>>            Set Status_Help to sToolTip
97417>>>>>>>        End
97417>>>>>>>>
97417>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97418>>>>>>>    End_Procedure
97419>>>>>>>
97419>>>>>>>    Procedure DoUpdate
97421>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97423>>>>>>>            Procedure_Return
97424>>>>>>>        End
97424>>>>>>>>
97424>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97425>>>>>>>    End_Procedure
97426>>>>>>>
97426>>>>>>>    Function IsEnabled Returns Boolean
97428>>>>>>>        Boolean bEnabled
97428>>>>>>>        Get pbEnabled to bEnabled
97429>>>>>>>        Function_Return bEnabled
97430>>>>>>>    End_Function
97431>>>>>>>
97431>>>>>>>    // Enable the idle handler timer when the button is activated
97431>>>>>>>    Procedure Activating
97433>>>>>>>        Forward Send Activating
97435>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97436>>>>>>>    End_Procedure
97437>>>>>>>
97437>>>>>>>    // Disable the idle handler when the button is deactivated
97437>>>>>>>    Procedure Deactivating
97439>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97440>>>>>>>        Forward Send Deactivating
97442>>>>>>>    End_Procedure
97443>>>>>>>
97443>>>>>>>End_Class
97444>>>>>
97444>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97444>>>>>Class cRDCButtonDPI is a cRDCButton
97445>>>>>    Procedure Construct_Object
97447>>>>>        Integer iIconSize
97447>>>>>        Forward Send Construct_Object
97449>>>>>        Set piImageMarginLeft to 10
97450>>>>>    End_Procedure
97451>>>>>
97451>>>>>    // Returns: DPI setting as an integer.
97451>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97451>>>>>    //                      iDPI=120 is "Medium setting" 125%
97451>>>>>    //                      iDPI= 144 is "Large setting" 150%
97451>>>>>    Function GetCurrentDPI Returns Integer
97453>>>>>        Handle hDC
97453>>>>>        Integer iPixelsX
97453>>>>>        Move (GetDC(0)) to hDC
97454>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97455>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97456>>>>>        Function_Return iPixelsX
97457>>>>>    End_Function
97458>>>>>
97458>>>>>    Function GetCorrectIconSize Returns Integer
97460>>>>>        Integer iPixelsX iIndex iSize
97460>>>>>        Integer[] iaSizes
97461>>>>>
97461>>>>>        Move 16 to iaSizes[0]
97462>>>>>        Move 24 to iaSizes[1]
97463>>>>>        Move 32 to iaSizes[2]
97464>>>>>        Move 48 to iaSizes[3]
97465>>>>>        Move 64 to iaSizes[4]
97466>>>>>
97466>>>>>        Get piImageSize to iSize  // the "100%" size
97467>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97468>>>>>        Move (0 max iIndex) to iIndex
97469>>>>>        Get GetCurrentDPI to iPixelsX
97470>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97470>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97470>>>>>        // will increment iIndex as many times as we need here.
97470>>>>>        Case Begin
97470>>>>>            Case (iPixelsX > 144)
97472>>>>>                Increment iIndex
97473>>>>>            Case (iPixelsX = 144)
97476>>>>>                Increment iIndex
97477>>>>>            Case (iPixelsX = 120)
97480>>>>>                Increment iIndex
97481>>>>>        Case End
97481>>>>>        Move (iIndex min 4) to iIndex
97482>>>>>        Function_Return iaSizes[iIndex]
97483>>>>>    End_Function
97484>>>>>
97484>>>>>    Procedure Set psToolTip String sToolTip
97486>>>>>        String sStatusHelp
97486>>>>>
97486>>>>>        Get Status_Help to sStatusHelp
97487>>>>>        If (sStatusHelp = "") Begin
97489>>>>>            Set Status_Help to sToolTip
97490>>>>>        End
97490>>>>>>
97490>>>>>
97490>>>>>        Forward Set psToolTip to sToolTip
97492>>>>>    End_Procedure
97493>>>>>
97493>>>>>End_Class
97494>>>Use DatabaseSelection.dg
97494>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97494>>>>>Use Windows.pkg
97494>>>>>Use cCJGridPromptList.pkg
97494>>>>>Use MSSqldrv.pkg
97494>>>>>Use db2_drv.pkg
97494>>>>>Use odbc_drv.pkg    
97494>>>>>Use cRDCModalPanel.pkg
97494>>>>>Use cDbUpdateFunctionLibrary.pkg
97494>>>>>
97494>>>>>Object oServerSelection_sl is a cRDCModalPanel
97496>>>>>    Set Size to 105 225
97497>>>>>    Set Label to "Database Server/DSN Selection"
97498>>>>>    Set piMinSize to 89 211
97499>>>>>    Set Location to 2 2
97500>>>>>    Set Icon to "ServerLookup.ico"
97501>>>>>
97501>>>>>    Property String[] psTheData
97503>>>>>
97503>>>>>    Object oSelList is a cCJGridPromptList
97505>>>>>        Set Size to 72 215
97506>>>>>        Set Location to 6 6
97507>>>>>        Set peAnchors to anAll
97508>>>>>        Set pbAllowColumnRemove to False
97509>>>>>        Set pbUseAlternateRowBackgroundColor to True
97510>>>>>        Set pbGrayIfDisable to False
97511>>>>>        Set pbHeaderReorders to False
97512>>>>>        Set pbHeaderSelectsColumn to False
97513>>>>>        Set pbHeaderTogglesDirection to False
97514>>>>>        Set pbShadeSortColumn to False
97515>>>>>        Set piFocusCellBackColor to clDkGray
97516>>>>>
97516>>>>>        Object oName is a cCJGridColumn
97518>>>>>            Set piWidth to 358
97519>>>>>            Set psCaption to "Name"
97520>>>>>        End_Object
97521>>>>>
97521>>>>>        Procedure Activating
97524>>>>>            tDataSourceRow[] MyData
97524>>>>>            tDataSourceRow[] MyData
97525>>>>>            Handle hoDataSource
97525>>>>>            String[] sTheData
97526>>>>>            Integer iCount iSize
97526>>>>>
97526>>>>>            Send Cursor_Wait of Cursor_Control
97527>>>>>            Get psTheData to sTheData
97528>>>>>            Move (SizeOfArray(sTheData)) to iSize
97529>>>>>            Decrement iSize
97530>>>>>            For iCount from 0 to iSize
97536>>>>>>
97536>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97537>>>>>            Loop
97538>>>>>>
97538>>>>>
97538>>>>>            Forward Send Activating
97540>>>>>
97540>>>>>            Get phoDataSource to hoDataSource
97541>>>>>            Send InitializeData of hoDataSource MyData
97542>>>>>            Send Cursor_Ready of Cursor_Control
97543>>>>>        End_Procedure
97544>>>>>
97544>>>>>    End_Object
97545>>>>>
97545>>>>>    Object oOK_Btn is a Button
97547>>>>>        Set Size to 14 50
97548>>>>>        Set Label    to "&OK"
97549>>>>>        Set Location to 85 116
97550>>>>>        Set peAnchors To anBottomRight
97551>>>>>
97551>>>>>        Procedure OnClick
97554>>>>>            Send Ok of oSelList
97555>>>>>        End_Procedure
97556>>>>>
97556>>>>>    End_Object
97557>>>>>
97557>>>>>    Object oCancel_Btn is a Button
97559>>>>>        Set Size to 14 50
97560>>>>>        Set Label    to "&Cancel"
97561>>>>>        Set Location to 85 171
97562>>>>>        Set peAnchors to anBottomRight
97563>>>>>
97563>>>>>        Procedure OnClick
97566>>>>>            Send Close_Panel
97567>>>>>        End_Procedure
97568>>>>>
97568>>>>>    End_Object
97569>>>>>
97569>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97570>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97571>>>>>End_Object
97572>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97572>>>>>Use Windows.pkg
97572>>>>>Use cCJGridPromptList.pkg
97572>>>>>Use cDbUpdateFunctionLibrary.pkg
97572>>>>>Use MSSqldrv.pkg
97572>>>>>Use db2_drv.pkg
97572>>>>>Use odbc_drv.pkg
97572>>>>>Use cCJGridColumn.pkg
97572>>>>>
97572>>>>>Object oSQLConnections is a ModalPanel
97574>>>>>    Set Label to "SQL Connections"
97575>>>>>    Set Size to 121 397
97576>>>>>    Set piMinSize to 89 185
97577>>>>>    Set Location to 2 2
97578>>>>>    Set Border_Style to Border_Thick
97579>>>>>
97579>>>>>    Property tSQLConnection[] psTheData
97581>>>>>
97581>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
97581>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97581>>>>>//        End_Object
97581>>>>>//    End
97581>>>>>
97581>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97583>>>>>        Set Size to 90 377
97584>>>>>        Set Location to 6 6
97585>>>>>        Set peAnchors to anAll
97586>>>>>        Set pbAllowColumnRemove to False
97587>>>>>        Set pbUseAlternateRowBackgroundColor to True
97588>>>>>        Set pbGrayIfDisable to False
97589>>>>>        Set pbHeaderReorders to False
97590>>>>>        Set pbHeaderSelectsColumn to False
97591>>>>>        Set pbHeaderTogglesDirection to False
97592>>>>>        Set pbShadeSortColumn to False
97593>>>>>        Set piFocusCellBackColor to clDkGray  
97594>>>>>        Set pbRestoreLayout to True
97595>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97596>>>>>
97596>>>>>        Object oID_Col is a cCJGridColumn
97598>>>>>            Set piWidth to 132
97599>>>>>            Set psCaption to "ID"
97600>>>>>        End_Object
97601>>>>>
97601>>>>>        Object oDbType_Col is a cCJGridColumn
97603>>>>>            Set piWidth to 182
97604>>>>>            Set psCaption to "Database Type"
97605>>>>>        End_Object
97606>>>>>
97606>>>>>        Object oServer_Col is a cCJGridColumn
97608>>>>>            Set piWidth to 296
97609>>>>>            Set psCaption to "Server/DSN"
97610>>>>>        End_Object
97611>>>>>
97611>>>>>        Object oDatabase_Col is a cCJGridColumn
97613>>>>>            Set piWidth to 211
97614>>>>>            Set psCaption to "Database"
97615>>>>>        End_Object
97616>>>>>
97616>>>>>        Object oDriverID_Col is a cCJGridColumn
97618>>>>>            Set piWidth to 121
97619>>>>>            Set psCaption to "Driver ID"
97620>>>>>        End_Object
97621>>>>>
97621>>>>>        Procedure Activating
97624>>>>>            tDataSourceRow[] MyData
97624>>>>>            tDataSourceRow[] MyData
97625>>>>>            Handle hoDataSource
97625>>>>>            Integer iCount iSize iPos
97625>>>>>            String sDriverID sConnectionID sValue
97625>>>>>            tSQLConnection[] sTheData
97625>>>>>            tSQLConnection[] sTheData
97626>>>>>
97626>>>>>            Send Cursor_Wait of Cursor_Control
97627>>>>>            Forward Send Activating
97629>>>>>
97629>>>>>            Get psTheData to sTheData
97630>>>>>            Move (SizeOfArray(sTheData)) to iSize
97631>>>>>            Decrement iSize
97632>>>>>            For iCount from 0 to iSize
97638>>>>>>
97638>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97639>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97640>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97641>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97642>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97643>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97644>>>>>            Loop
97645>>>>>>
97645>>>>>
97645>>>>>            Get phoDataSource to hoDataSource
97646>>>>>            Send InitializeData of hoDataSource MyData
97647>>>>>            Send Cursor_Ready of Cursor_Control
97648>>>>>        End_Procedure
97649>>>>>
97649>>>>>    End_Object
97650>>>>>
97650>>>>>    Object oOK_Btn is a Button
97652>>>>>        Set Label    to "&OK"
97653>>>>>        Set Location to 101 280
97654>>>>>        Set peAnchors to anBottomRight
97655>>>>>
97655>>>>>        Procedure OnClick
97658>>>>>            Send Ok of oSelListSQLConnections
97659>>>>>        End_Procedure
97660>>>>>
97660>>>>>    End_Object
97661>>>>>
97661>>>>>    Object oCancel_Btn is a Button
97663>>>>>        Set Label    to "&Cancel"
97664>>>>>        Set Location to 101 335
97665>>>>>        Set peAnchors to anBottomRight
97666>>>>>
97666>>>>>        Procedure OnClick
97669>>>>>            Send Close_Panel
97670>>>>>        End_Procedure
97671>>>>>
97671>>>>>    End_Object
97672>>>>>
97672>>>>>    Procedure Page Integer iPageObject
97675>>>>>        Set Icon to "SQLConnections.ico"
97676>>>>>        Forward Send Page iPageObject
97678>>>>>    End_Procedure
97679>>>>>
97679>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97680>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97681>>>>>End_Object
97682>>>
97682>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97692>>>>
97692>>>Object oSQLConnections_vw is a dbView
97694>>>    Set Border_Style to Border_Thick
97695>>>    Set Size to 251 427
97696>>>    Set Location to 2 2
97697>>>    Set Label to "SQL Connections"
97698>>>    Set pbAutoActivate to True
97699>>>    Set Icon to "SQLConnections.ico"
97700>>>
97700>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97702>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97704>>>
97704>>>            Object oCurrentSettings_grp is a Group
97706>>>                Set Size to 232 402
97707>>>                Set Location to 6 12
97708>>>                Set Label to "Current Connection Settings"
97709>>>                Set peAnchors to anAll
97710>>>
97710>>>                Object oConnectionID_fm is a Form
97712>>>                    Set Size to 12 100
97713>>>                    Set Location to 12 68
97714>>>                    Set Label to "Connection ID"
97715>>>                    Set Label_Col_Offset to 2
97716>>>                    Set Label_Justification_Mode to JMode_Right
97717>>>                    Set Prompt_Button_Mode to PB_PromptOn
97718>>>                    Set Prompt_Object to (oSQLConnections(Self))
97719>>>
97719>>>                    Procedure Prompt
97722>>>                        String[] sTheData
97723>>>                        String sCurrentVal sNewVal
97723>>>                        Handle hoIniFile ho
97723>>>                        Integer iSize iCount
97723>>>                        tSQLConnection[] SQLConnectionArray
97723>>>                        tSQLConnection[] SQLConnectionArray
97724>>>
97724>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97725>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97726>>>                        Get Value to sCurrentVal
97727>>>                        Get Prompt_Object to ho
97728>>>                        Set psTheData of ho to SQLConnectionArray
97729>>>
97729>>>                        Forward Send Prompt
97731>>>                        Get Value to sNewVal
97732>>>                        If (sCurrentVal <> sNewVal) Begin
97734>>>                            Send Cursor_Wait of Cursor_Control
97735>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97736>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97738>>>                            Send Cursor_Ready of Cursor_Control
97739>>>                            Send KeyAction of oTestLogin_btn
97740>>>                        End
97740>>>>
97740>>>                    End_Procedure   
97741>>>                    
97741>>>                    Procedure PromptUpdate Handle hoPrompt
97744>>>                        String[] sSelectedNames                    
97745>>>                
97745>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97746>>>                        If (SizeOfArray(sSelectedNames)) Begin
97748>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97749>>>                            Delegate Send Page True // Broadcast sends refresh
97751>>>                        End
97751>>>>
97751>>>                    End_Procedure   
97752>>>
97752>>>                    Procedure Prompt_Callback Handle hoPrompt
97755>>>                        String sServer
97755>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97756>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97757>>>                        Get Value of oServer_fm to sServer
97758>>>                        Set psSeedValue of hoPrompt to sServer
97759>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97760>>>                    End_Procedure
97761>>>
97761>>>                    Procedure Refresh
97764>>>                        String sValue
97764>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97765>>>                        Set Value to sValue
97766>>>                    End_Procedure
97767>>>
97767>>>                End_Object
97768>>>
97768>>>                Object oDriverID_cf is a ComboForm
97770>>>                    Set Size to 12 91
97771>>>                    Set Location to 12 222
97772>>>                    Set Label_Col_Offset to 2
97773>>>                    Set Label_Justification_Mode to JMode_Right
97774>>>                    Set Label to "Driver ID"
97775>>>                    Set Entry_State to False
97776>>>                    Set Enabled_State to False
97777>>>
97777>>>                    Procedure Combo_Fill_List
97780>>>                        Send Combo_Add_Item MSSQLDRV_ID
97781>>>                        Send Combo_Add_Item DB2_DRV_ID
97782>>>                        Send Combo_Add_Item ODBC_DRV_ID
97783>>>                    End_Procedure
97784>>>
97784>>>                    Procedure OnChange
97787>>>                        String sValue sOrgValue
97787>>>                        Boolean bEnabled bChecked
97787>>>
97787>>>                        Get Value to sValue
97788>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97789>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97791>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97792>>>                        End
97792>>>>
97792>>>                        Move (sValue <> "None") to bEnabled
97793>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97795>>>                        Set Enabled_State to False
97796>>>                        Set Enabled_State of oConnectionString_fm to False
97797>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97798>>>
97798>>>                        Get Checked_State of oTrusted_cb  to bChecked
97799>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97800>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97801>>>                    End_Procedure
97802>>>
97802>>>                    Procedure Refresh
97805>>>                        String sValue
97805>>>
97805>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97806>>>                        Set Value to sValue
97807>>>                    End_Procedure
97808>>>
97808>>>                End_Object
97809>>>
97809>>>                Object oServer_fm is a Form
97811>>>                    Set Size to 12 100
97812>>>                    Set Location to 26 68
97813>>>                    Set Label to "Server"
97814>>>                    Set Label_Col_Offset to 2
97815>>>                    Set Label_Justification_Mode to JMode_Right
97816>>>                    Set Prompt_Button_Mode to PB_PromptOn
97817>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97818>>>
97818>>>                    Procedure Refresh
97821>>>                        String sValue
97821>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97822>>>                        Set Value to sValue
97823>>>                    End_Procedure
97824>>>
97824>>>                    Procedure Prompt
97827>>>                        String[] sTheData
97828>>>                        String sDriverID
97828>>>                        Handle ho
97828>>>
97828>>>                        Send Cursor_Wait of Cursor_Control
97829>>>                        Get Prompt_Object to ho
97830>>>                        Get Value of oDriverID_cf to sDriverID
97831>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97832>>>                        Set psTheData of ho to sTheData
97833>>>                        Send Cursor_Ready of Cursor_Control
97834>>>
97834>>>                        Forward Send Prompt
97836>>>                    End_Procedure
97837>>>
97837>>>                End_Object
97838>>>
97838>>>                Object oDatabase_fm is a Form
97840>>>                    Set Size to 12 91
97841>>>                    Set Location to 26 222
97842>>>                    Set Label to "Database"
97843>>>                    Set Label_Col_Offset to 2
97844>>>                    Set Label_Justification_Mode to JMode_Right
97845>>>                    Set Prompt_Button_Mode to PB_PromptOn
97846>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97847>>>                    Set peAnchors to anNone
97848>>>                    Set Entry_State to False
97849>>>
97849>>>                    Procedure Refresh
97852>>>                        String sDatabase
97852>>>
97852>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97853>>>                        Set Value to sDatabase
97854>>>                    End_Procedure
97855>>>
97855>>>                    Procedure Prompt
97858>>>                        String[] sTheData
97859>>>                        Handle ho
97859>>>                        String sDriverID
97859>>>
97859>>>                        Get Value of oDriverID_cf to sDriverID
97860>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97861>>>
97861>>>                        Get Prompt_Object to ho
97862>>>                        Set psTheData of ho to sTheData
97863>>>
97863>>>                        Forward Send Prompt
97865>>>                    End_Procedure
97866>>>
97866>>>                    Procedure OnChange
97869>>>                        String sValue sOrgValue
97869>>>                        Get Value to sValue
97870>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97871>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97873>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97874>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97875>>>                            Set Value of oConnectionString_fm to sValue
97876>>>                        End
97876>>>>
97876>>>                    End_Procedure
97877>>>
97877>>>                End_Object
97878>>>
97878>>>                Object oTrusted_cb is a CheckBox
97880>>>                    Set Size to 10 50
97881>>>                    Set Location to 45 68
97882>>>                    Set Label to "Use Trusted Connection"
97883>>>
97883>>>                    Procedure Refresh
97886>>>                        Boolean bValue
97886>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97887>>>                        Set Checked_State to bValue
97888>>>                    End_Procedure
97889>>>
97889>>>                    Procedure OnChange
97892>>>                        Boolean bChecked
97892>>>
97892>>>                        Get Checked_State to bChecked
97893>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97894>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97895>>>                    End_Procedure
97896>>>
97896>>>                End_Object
97897>>>
97897>>>                Object oUserID_fm is a Form
97899>>>                    Set Size to 12 100
97900>>>                    Set Location to 57 68
97901>>>                    Set Label to "UserID"
97902>>>                    Set Label_Col_Offset to 2
97903>>>                    Set Label_Justification_Mode to JMode_Right
97904>>>
97904>>>                    Procedure Refresh
97907>>>                        String sValue
97907>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97908>>>                        Set Value to sValue
97909>>>                    End_Procedure
97910>>>
97910>>>                End_Object
97911>>>
97911>>>                Object oPassword_fm is a Form
97913>>>                    Set Size to 12 91
97914>>>                    Set Location to 57 222
97915>>>                    Set Label to "Password"
97916>>>                    Set Label_Col_Offset to 2
97917>>>                    Set Label_Justification_Mode to JMode_Right
97918>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97918>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97919>>>                    Set Password_State to True
97920>>>
97920>>>                    Procedure Refresh
97923>>>                        String sValue
97923>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97924>>>                        Set Value to sValue
97925>>>                    End_Procedure
97926>>>
97926>>>                End_Object
97927>>>
97927>>>                Object oViewPassword_btn is a cRDCButtonDPI
97929>>>                    Set Size to 12 19
97930>>>                    Set Location to 57 317
97931>>>                    Set psToolTip to "Toggle password"
97932>>>                    Set psImage to "ViewPassword.ico"
97933>>>                    Set piImageMarginLeft to 0
97934>>>
97934>>>                    Procedure OnClick
97937>>>                        Boolean bState
97937>>>                        Get Password_State of oPassword_fm to bState
97938>>>                        Send Page_Object   of oPassword_fm False
97939>>>                        Set Password_State of oPassword_fm to (not(bState))
97940>>>                        Send Page_Object   of oPassword_fm True
97941>>>                    End_Procedure
97942>>>
97942>>>                End_Object
97943>>>
97943>>>                Object oTestLogin_btn is a cRDCButtonDPI
97945>>>                    Set Size to 12 56
97946>>>                    Set Location to 57 340
97947>>>                    Set Label to "Test Login"
97948>>>                    Set peAnchors to anNone
97949>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97950>>>                    Set FontWeight to fw_Bold
97951>>>                    Set psImage to "ActionLogin.ico"
97952>>>                    Set piImageMarginLeft to 0
97953>>>
97953>>>                    Procedure OnClick
97956>>>                        tSQLConnection SQLConnection
97956>>>                        tSQLConnection SQLConnection
97956>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97956>>>                        Boolean bTrusted bLoginSuccessful
97956>>>                        Integer iDriverID
97956>>>                        Handle hoDriver
97956>>>
97956>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97957>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97958>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97959>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97960>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97961>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97962>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97963>>>
97963>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97964>>>
97964>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97965>>>                        If (iDriverID = 0) Begin
97967>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97968>>>                            Procedure_Return
97969>>>                        End
97969>>>>
97969>>>
97969>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97972>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97973>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97974>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97975>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97976>>>                        Send Destroy   of hoDriver
97977>>>
97977>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97978>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97980>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97981>>>                            Set Value of oConnectionString_fm to sConnectionString
97982>>>                            Send Info_Box "Login Successful!"
97983>>>                        End
97983>>>>
97983>>>                        Else Begin
97984>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97985>>>                        End
97985>>>>
97985>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97987>>>                        Move 0 to LastErr
97988>>>                    End_Procedure
97989>>>
97989>>>                End_Object
97990>>>
97990>>>                Object oConnectionString_fm is a Form
97992>>>                    Set Size to 12 328
97993>>>                    Set Location to 82 68
97994>>>                    Set Label to "Connection String"    
97995>>>                    Set Label_Col_Offset to 2
97996>>>                    Set Label_Justification_Mode to JMode_Right
97997>>>                    Set peAnchors to anTopLeftRight
97998>>>                    Set Enabled_State to False
97999>>>
97999>>>                    Procedure Refresh
98002>>>                        String sValue
98002>>>                        tSQLConnection SQLConnection
98002>>>                        tSQLConnection SQLConnection
98002>>>
98002>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98003>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98004>>>                        Set Value to sValue
98005>>>                    End_Procedure
98006>>>
98006>>>                End_Object
98007>>>
98007>>>                Object oInfo_tb is a TextBox
98009>>>                    Set Auto_Size_State to False
98010>>>                    Set Size to 18 303
98011>>>                    Set Location to 106 8
98012>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
98013>>>                    Set Justification_Mode to JMode_Left
98014>>>                    Set FontItalics to True
98015>>>                End_Object
98016>>>
98016>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
98018>>>                    Set Size to 21 83
98019>>>                    Set Location to 106 315
98020>>>                    Set Label to "SQL Connections"
98021>>>                    Set peAnchors to anNone
98022>>>                    Set psImage to "SQLConnections.ico"
98023>>>
98023>>>                    Procedure OnClick 
98026>>>                        Runprogram Background "DUFSQLConnections.exe"
98027>>>                    End_Procedure
98028>>>
98028>>>                End_Object
98029>>>
98029>>>                Object oGetCollation_btn is a Button
98031>>>                    Set Size to 27 91
98032>>>                    Set Location to 154 38
98033>>>                    Set Label to 'Get Database Collation'
98034>>>                
98034>>>                    Procedure OnClick
98037>>>                        String sCollation sDatabase
98037>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
98038>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
98039>>>                        Set Value of oGetCollation_fm to sCollation
98040>>>                    End_Procedure
98041>>>                
98041>>>                End_Object
98042>>>
98042>>>                Object oGetCollation_fm is a Form
98044>>>                    Set Size to 12 148
98045>>>                    Set Location to 162 143
98046>>>                    Set Label to "Current SQL Collation Name"
98047>>>                    Set Label_Col_Offset to 0
98048>>>                    Set Label_Row_Offset to 1
98049>>>                    Set Label_Justification_Mode to JMode_Top
98050>>>                End_Object
98051>>>        
98051>>>                Object oSetCollation_btn is a Button
98053>>>                    Set Size to 27 91
98054>>>                    Set Location to 188 38
98055>>>                    Set Label to "Set Database Collation"
98056>>>                
98056>>>                    Procedure OnClick
98059>>>                        String sCollation sDatabase sErrorText
98059>>>                        Boolean bOK
98059>>>                        Integer iRetval  
98059>>>                        tSqlErrorArray aSqlErrorArray
98059>>>                        tSqlErrorArray aSqlErrorArray
98059>>>                        
98059>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
98060>>>                        Get Value of oSetCollation_fm to sCollation
98061>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
98062>>>                        If (iRetval <> MBR_Yes) Begin
98064>>>                            Procedure_Return
98065>>>                        End
98065>>>>
98065>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
98066>>>                        If (bOK = True) Begin
98068>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
98069>>>                        End
98069>>>>
98069>>>                        Else Begin                   
98070>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
98071>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
98072>>>                            Move (sErrorText + "\n")                  to sErrorText
98073>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
98074>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
98075>>>                        End
98075>>>>
98075>>>
98075>>>                    End_Procedure
98076>>>                
98076>>>                End_Object
98077>>>
98077>>>                Object oSetCollation_fm is a Form
98079>>>                    Set Size to 12 148
98080>>>                    Set Location to 197 143
98081>>>                    Set Label to "New SQL Collation Name"
98082>>>                    Set Label_Col_Offset to 0
98083>>>                    Set Label_Row_Offset to 1
98084>>>                    Set Label_Justification_Mode to JMode_Top
98085>>>                End_Object
98086>>>
98086>>>                Procedure Page Integer iPageObject
98089>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
98091>>>                    Forward Send Page iPageObject
98093>>>                End_Procedure
98094>>>
98094>>>            End_Object
98095>>>
98095>>>        End_Object
98096>>>        
98096>>>    End_Object
98097>>>
98097>>>End_Object
98098>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
98098>>>Use Windows.pkg
98098>>>Use DFClient.pkg
98098>>>Use Dfspnfrm.pkg
98098>>>Use cDbScrollingContainer.pkg
98098>>>Use cRDCButtonDPI.pkg
98098>>>Use cDbUpdateFunctionLibrary.pkg
98098>>>Use SQLDatabaseBackup.dg
98098>>>
98098>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
98108>>>>
98108>>>Object oSQLFunctions_vw is a dbView
98110>>>    Set Border_Style to Border_Thick
98111>>>    Set Size to 260 426
98112>>>    Set Location to -4 2
98113>>>    Set Label to "Functions"
98114>>>    Set pbAutoActivate to True
98115>>>    Set Icon to "Sql.ico"
98116>>>
98116>>>    Procedure OnSetFocus
98119>>>        String sValue
98119>>>        tSQLConnection SQLConnection
98119>>>        tSQLConnection SQLConnection
98119>>>
98119>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98120>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
98121>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98122>>>        Set Value of oSQLConnectionString_fm to sValue
98123>>>    End_Procedure
98124>>>
98124>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98126>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98128>>>
98128>>>            Object oSQLFunctionTests_grp is a Group
98130>>>                Set Size to 243 402
98131>>>                Set Location to 7 12
98132>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
98133>>>                Set peAnchors to anAll
98134>>>
98134>>>                Object oSQLConnectionString_fm is a Form
98136>>>                    Set Size to 12 375
98137>>>                    Set Location to 23 14
98138>>>                    Set Label to "Current Connection String Settings:"
98139>>>                    Set Label_Col_Offset to 0
98140>>>                    Set Label_Justification_Mode to JMode_Top
98141>>>                    Set peAnchors to anTopLeftRight
98142>>>                    Set Enabled_State to False
98143>>>                    Set Label_Row_Offset to 1
98144>>>                End_Object
98145>>>
98145>>>                Object oSQLDatabase_fm is a Form
98147>>>                    Set Size to 12 86
98148>>>                    Set Location to 50 14
98149>>>                    Set Label to "Database:"
98150>>>                    Set Label_Col_Offset to 0
98151>>>                    Set Label_Justification_Mode to JMode_Top
98152>>>                    Set Label_Row_Offset to 1
98153>>>                    Set FontWeight to fw_Bold
98154>>>                    Set Enabled_State to False
98155>>>                End_Object
98156>>>
98156>>>                Object oDriverID2_cf is a ComboForm
98158>>>                    Set Size to 12 91
98159>>>                    Set Location to 50 121
98160>>>                    Set Label_Col_Offset to 0
98161>>>                    Set Label_Justification_Mode to JMode_Top
98162>>>                    Set Label to "Driver ID:"
98163>>>                    Set Entry_State to False
98164>>>                    Set Enabled_State to False
98165>>>                    Set Label_Row_Offset to 1
98166>>>
98166>>>                    Procedure Combo_Fill_List
98169>>>                        Send Combo_Add_Item MSSQLDRV_ID
98170>>>                        Send Combo_Add_Item DB2_DRV_ID
98171>>>                        Send Combo_Add_Item ODBC_DRV_ID
98172>>>                    End_Procedure
98173>>>
98173>>>                    Procedure Refresh
98176>>>                        String sValue
98176>>>
98176>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98177>>>                        Set Value to sValue
98178>>>                    End_Procedure
98179>>>
98179>>>                End_Object
98180>>>
98180>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
98182>>>                    Set Size to 12 109
98183>>>                    Set Location to 50 220
98184>>>                    Set Label to "Backup MS-SQL Database"
98185>>>                    Set psImage to "DbBackup.ico"
98186>>>
98186>>>                    Procedure OnClick
98189>>>                        Boolean bOK
98189>>>
98189>>>                        // SQLDatabaseBackup dialog:
98189>>>                        Get MakeSQLDatabaseBackup to bOK
98190>>>
98190>>>                        If (bOK = True) Begin
98192>>>                            Send Info_Box "The backup of the database was successful!"
98193>>>                        End
98193>>>>
98193>>>                        Else Begin
98194>>>                            Send Info_Box "The database was not backup up"
98195>>>                        End
98195>>>>
98195>>>                    End_Procedure
98196>>>
98196>>>                End_Object
98197>>>
98197>>>                Object oDatabaseInfo_tb is a TextBox
98199>>>                    Set Auto_Size_State to False
98200>>>                    Set Size to 25 96
98201>>>                    Set Location to 64 14
98202>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98203>>>                    Set Justification_Mode to JMode_Left
98204>>>                End_Object
98205>>>
98205>>>                Object oSQLInfo_tb is a TextBox
98207>>>                    Set Auto_Size_State to False
98208>>>                    Set Size to 37 270
98209>>>                    Set Location to 76 118
98210>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
98211>>>                    Set Justification_Mode to JMode_Left
98212>>>                End_Object
98213>>>
98213>>>                Object oSQLTableName_cf is a ComboForm
98215>>>                    Set Size to 12 96
98216>>>                    Set Location to 106 14
98217>>>                    Set Label_Col_Offset to 0
98218>>>                    Set Label_Justification_Mode to JMode_Top
98219>>>                    Set Label to "Select Table:"
98220>>>                    Set Label_Row_Offset to 1
98221>>>                    Set Entry_State to False
98222>>>
98222>>>                    Procedure OnDropDown
98225>>>                        Send DoCombo_Fill_List
98226>>>                    End_Procedure
98227>>>
98227>>>                    Procedure OnCloseUp
98230>>>                        Send Delete_Data of oSQLColumnName_cf
98231>>>                    End_Procedure
98232>>>
98232>>>                    Procedure DoCombo_Fill_List
98235>>>                        String[] sTablesArray
98236>>>                        String sDriverID
98236>>>                        Integer iCount iSize
98236>>>
98236>>>                        Send Delete_Data
98237>>>                        Get Value of oDriverID2_cf to sDriverID
98238>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
98239>>>                        Move (SizeOfArray(sTablesArray)) to iSize
98240>>>                        Decrement iSize
98241>>>                        For iCount from 0 to iSize
98247>>>>
98247>>>                            Send Combo_Add_Item sTablesArray[iCount]
98248>>>                        Loop
98249>>>>
98249>>>                    End_Procedure
98250>>>
98250>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
98250>>>                    // Augmented Value function.
98250>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
98250>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
98250>>>                    Function Value Integer iItem Returns String
98253>>>                        String sValue
98253>>>                        Get WinCombo_Current_Item to iItem
98254>>>                        Get WinCombo_Value iItem  to sValue
98255>>>                        Function_Return sValue
98256>>>                    End_Function
98257>>>
98257>>>                End_Object
98258>>>
98258>>>                Object oSQLColumnName_cf is a ComboForm
98260>>>                    Set Size to 12 96
98261>>>                    Set Location to 134 14
98262>>>                    Set Label_Col_Offset to 0
98263>>>                    Set Label_Justification_Mode to JMode_Top
98264>>>                    Set Label to "Select Column:"
98265>>>                    Set Label_Row_Offset to 1
98266>>>                    Set Entry_State to False
98267>>>
98267>>>                    Procedure DoCombo_Fill_List
98270>>>                        String[] sColumnsArray
98271>>>                        String sTableName sDriverID
98271>>>                        Integer iCount iSize
98271>>>
98271>>>                        Send Delete_Data
98272>>>                        Get Value of oDriverID2_cf    to sDriverID
98273>>>                        Get Value of oSQLTableName_cf to sTableName
98274>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
98275>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
98276>>>                        Decrement iSize
98277>>>                        For iCount from 0 to iSize
98283>>>>
98283>>>                            Send Combo_Add_Item sColumnsArray[iCount]
98284>>>                        Loop
98285>>>>
98285>>>                        If (iSize > 1) Begin
98287>>>                            Set Current_Item to 1
98288>>>                        End
98288>>>>
98288>>>                    End_Procedure
98289>>>
98289>>>                    Procedure OnDropDown
98292>>>                        Send DoCombo_Fill_List
98293>>>                    End_Procedure
98294>>>                End_Object
98295>>>
98295>>>                Object oSQLRenameColumnTo_fm is a Form
98297>>>                    Set Size to 12 96
98298>>>                    Set Location to 134 116
98299>>>                    Set Label_Col_Offset to 0
98300>>>                    Set Label_Justification_Mode to JMode_Top
98301>>>                    Set Label to "Rename Column To:"
98302>>>                    Set Label_Row_Offset to 1
98303>>>                    Set Value to "NewColumnName"
98304>>>                End_Object
98305>>>
98305>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
98307>>>                    Set Size to 12 69
98308>>>                    Set Location to 134 220
98309>>>                    Set Label to "Rename Column"
98310>>>                    Set psToolTip to "Test of SQLColumnRename function"
98311>>>                    Set MultiLineState to True
98312>>>
98312>>>                    Procedure OnClick
98315>>>                        Boolean bOk
98315>>>                        Handle hTable
98315>>>                        String sTableName sColumnName sNewColumnName sDriverID
98315>>>
98315>>>                        Get Value of oSQLTableName_cf to sTableName
98316>>>                        If (sTableName = "") Begin
98318>>>                            Send Info_Box "You need to select a table first..."
98319>>>                            Procedure_Return
98320>>>                        End
98320>>>>
98320>>>                        Get Value of oSQLColumnName_cf to sColumnName
98321>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
98323>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
98324>>>                            Procedure_Return
98325>>>                        End
98325>>>>
98325>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
98326>>>                        If (Trim(sNewColumnName) = "") Begin
98328>>>                            Send Info_Box "You need to enter a column name to rename to..."
98329>>>                            Procedure_Return
98330>>>                        End
98330>>>>
98330>>>
98330>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98331>>>                        If (hTable = 0) Begin
98333>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98334>>>                            Procedure_Return
98335>>>                        End
98335>>>>
98335>>>
98335>>>                        Get Value of oDriverID2_cf to sDriverID
98336>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98337>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98338>>>                        If (bOk = True) Begin
98340>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98340>>>                            Send Delete_Data of oSQLColumnName_cf
98341>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98342>>>                        End
98342>>>>
98342>>>                        Else Begin
98343>>>                            Send Info_Box "Nope, that didn't work..."
98344>>>                        End
98344>>>>
98344>>>
98344>>>                    End_Procedure
98345>>>
98345>>>                End_Object
98346>>>
98346>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98348>>>                    Set Size to 12 91
98349>>>                    Set Location to 134 297
98350>>>                    Set Label to "Drop Column"
98351>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98352>>>                    Set psImage to "DeleteColumn.ico"
98353>>>
98353>>>                    Procedure OnClick
98356>>>                        Boolean bOk
98356>>>                        String sTableName sColumnName sDriverID
98356>>>                        Integer iRetval
98356>>>
98356>>>                        Get Value of oDriverID2_cf              to sDriverID
98357>>>                        Get Value of oSQLTableName_cf           to sTableName
98358>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98359>>>
98359>>>                        If (sTableName = "" or sColumnName = "") Begin
98361>>>                            Send Info_Box "You first need to select a table and a column."
98362>>>                            Procedure_Return
98363>>>                        End
98363>>>>
98363>>>
98363>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98364>>>                        If (iRetval <> MBR_Yes) Begin
98366>>>                            Procedure_Return
98367>>>                        End
98367>>>>
98367>>>
98367>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98368>>>
98368>>>                        If (bOk = True) Begin
98370>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98370>>>                            Send Delete_Data of oSQLColumnName_cf
98371>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98372>>>                        End
98372>>>>
98372>>>                        Else Begin
98373>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98374>>>                            Procedure_Return
98375>>>                        End
98375>>>>
98375>>>
98375>>>                    End_Procedure
98376>>>
98376>>>                End_Object
98377>>>
98377>>>                Object oSQLAddColumnName_fm is a Form
98379>>>                    Set Size to 12 96
98380>>>                    Set Location to 177 14
98381>>>                    Set Label_Col_Offset to 0
98382>>>                    Set Label_Justification_Mode to JMode_Top
98383>>>                    Set Label to "Column Name:"
98384>>>                    Set Label_Row_Offset to 1
98385>>>                    Set Value to "NewColumn"
98386>>>                End_Object
98387>>>
98387>>>                Object oSQLColumnType_cf is a ComboForm
98389>>>                    Set Size to 12 96
98390>>>                    Set Location to 177 116
98391>>>                    Set Label_Col_Offset to 0
98392>>>                    Set Label_Justification_Mode to JMode_Top
98393>>>                    Set Label_Row_Offset to 1
98394>>>                    Set Label to "Type:"
98395>>>                    Set Entry_State to False
98396>>>
98396>>>                    Procedure Combo_Fill_List
98399>>>                        tColumnType[] ColumnTypeArray
98399>>>                        tColumnType[] ColumnTypeArray
98400>>>                        Integer iSize iCount iDbType
98400>>>                        String sDriverID
98400>>>
98400>>>                        Send Delete_Data
98401>>>                        Get Value of oDriverID2_cf to sDriverID
98402>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98403>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98404>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98405>>>                        Decrement iSize
98406>>>                        For iCount from 0 to iSize
98412>>>>
98412>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98413>>>                        Loop
98414>>>>
98414>>>                        If (iSize > 0) Begin
98416>>>                            Set Value to ColumnTypeArray[0].sSQLType
98417>>>                        End
98417>>>>
98417>>>                    End_Procedure
98418>>>
98418>>>                    Procedure OnChange
98421>>>                        Integer iType iSize iDec
98421>>>                        tSQLConnection SQLConnection
98421>>>                        tSQLConnection SQLConnection
98421>>>                        Boolean bFixed
98421>>>
98421>>>                        Get SelectedType to iType
98422>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98423>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98424>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98425>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98426>>>
98426>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98427>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98428>>>                        Set Value         of oSQLLength_sf   to iSize
98429>>>                        If (iDec = 0) Begin
98431>>>                            Set Value     of oSQLDecimals_sf to ""
98432>>>                        End
98432>>>>
98432>>>                        Else Begin
98433>>>                            Set Value     of oSQLDecimals_sf to iDec
98434>>>                        End
98434>>>>
98434>>>                        If (bFixed = False) Begin
98436>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98437>>>                        End
98437>>>>
98437>>>                    End_Procedure
98438>>>
98438>>>                    Function SelectedType Returns Integer
98441>>>                        String sValue sDriverID
98441>>>                        Integer iType iDbType
98441>>>
98441>>>                        Get Value to sValue
98442>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98443>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98444>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98445>>>
98445>>>                        Function_Return iType
98446>>>                    End_Function
98447>>>
98447>>>                End_Object
98448>>>
98448>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98450>>>                    Set Size to 12 69
98451>>>                    Set Location to 177 220
98452>>>                    Set Label to "Add Column"
98453>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98454>>>                    Set psImage to "AddColumn.ico"
98455>>>
98455>>>                    Procedure OnClick
98458>>>                        Boolean bOk bInitialize
98458>>>                        Handle hTable
98458>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98458>>>                        Integer iType iLength iDecimals
98458>>>
98458>>>                        Get Value of oDriverID2_cf              to sDriverID
98459>>>                        Get Value of oSQLTableName_cf           to sTableName
98460>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98461>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98462>>>                        Get Value         of oSQLColumnType_cf  to sType
98463>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98464>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98465>>>                        Get Value         of oSQLLength_sf      to iLength
98466>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98467>>>
98467>>>                        If (sTableName <> "") Begin
98469>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98470>>>                            If (hTable = 0) Begin
98472>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98473>>>                            End
98473>>>>
98473>>>                        End
98473>>>>
98473>>>                        If (hTable = 0) Begin
98475>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98476>>>                            Procedure_Return
98477>>>                        End
98477>>>>
98477>>>                        If (sColumnName = "") Begin
98479>>>                            Send Info_Box "You need to enter a column name"
98480>>>                            Procedure_Return
98481>>>                        End
98481>>>>
98481>>>
98481>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98482>>>
98482>>>                        If (bOk = True) Begin
98484>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98485>>>                        End
98485>>>>
98485>>>                        Else Begin
98486>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98487>>>                            Procedure_Return
98488>>>                        End
98488>>>>
98488>>>
98488>>>                    End_Procedure
98489>>>
98489>>>                End_Object
98490>>>
98490>>>//                Object oTest_btn is a cRDCButtonDPI
98490>>>//                    Set Size to 13 92
98490>>>//                    Set Location to 177 298
98490>>>//                    Set Label to "Test SQL script button"
98490>>>//
98490>>>//                    Procedure OnClick
98490>>>//                        Boolean bOK
98490>>>//                        String sTableName sColumnName
98490>>>//
98490>>>//                        Get Value of oSQLTableName_cf      to sTableName
98490>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98490>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98490>>>//
98490>>>//                    End_Procedure
98490>>>//
98490>>>//                End_Object
98490>>>
98490>>>                Object oSQLLength_sf is a SpinForm
98492>>>                    Set Label to "Length:"
98493>>>                    Set Size to 12 40
98494>>>                    Set Location to 202 16
98495>>>                    Set Label_Col_Offset to 0
98496>>>                    Set Label_Justification_Mode to JMode_Top
98497>>>                    Set Label_Row_Offset to 1
98498>>>                    Set Value to "10"
98499>>>                    Set Maximum_Position to 500
98500>>>                    Set Minimum_Position to 1
98501>>>                End_Object
98502>>>
98502>>>                Object oSQLDecimals_sf is a SpinForm
98504>>>                    Set Label to "Decimals:"
98505>>>                    Set Size to 12 33
98506>>>                    Set Location to 202 60
98507>>>                    Set Label_Col_Offset to 0
98508>>>                    Set Label_Justification_Mode to JMode_Top
98509>>>                    Set Label_Row_Offset to 1
98510>>>                    Set Value to "0"
98511>>>                    Set Maximum_Position to 16
98512>>>                    Set Minimum_Position to 1
98513>>>                End_Object
98514>>>
98514>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98516>>>                    Set Size to 12 85
98517>>>                    Set Location to 202 116
98518>>>                    Set Label to "Initialize Column Value"
98519>>>
98519>>>                    Procedure OnChange
98522>>>                        Boolean bChecked
98522>>>
98522>>>                        Get Checked_State to bChecked
98523>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98524>>>                    End_Procedure
98525>>>
98525>>>                End_Object
98526>>>
98526>>>                Object oSQLColumnValue_fm is a Form
98528>>>                    Set Size to 12 96
98529>>>                    Set Location to 218 116
98530>>>                    Set Label_Col_Offset to 2
98531>>>                    Set Label_Justification_Mode to JMode_Right
98532>>>                    Set Label to "Column Value"
98533>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98534>>>                    Set Enabled_State to False
98535>>>                End_Object
98536>>>
98536>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98538>>>                    Set Size to 12 91
98539>>>                    Set Location to 116 297
98540>>>                    Set Label to "Test Enum SQL Relations"
98541>>>
98541>>>                    Procedure OnClick
98544>>>                        tSQLRelation[] SQLRelationArray
98544>>>                        tSQLRelation[] SQLRelationArray
98545>>>                        String sTableName sDriverID
98545>>>                        Integer iSize iCount
98545>>>
98545>>>                        Get Value of oDriverID2_cf to sDriverID
98546>>>                        Get Value of oSQLTableName_cf to sTableName
98547>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98548>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98549>>>                        Decrement iSize
98550>>>                        For iCount from 0 to iSize
98556>>>>
98556>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98565>>>                        Loop
98566>>>>
98566>>>                        If (iSize < 1) Begin
98568>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98569>>>                        End
98569>>>>
98569>>>
98569>>>                    End_Procedure
98570>>>
98570>>>                End_Object
98571>>>
98571>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98573>>>                    Set Size to 12 101
98574>>>                    Set Location to 177 297
98575>>>                    Set Label to "Enumerate Logged In Users"
98576>>>
98576>>>                    Procedure OnClick
98579>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98579>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98580>>>                        String sDriverID sDatabase
98580>>>                        Integer iSize iCount
98580>>>
98580>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98581>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98582>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98583>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98584>>>                        Decrement iSize
98585>>>
98585>>>                        Showln "SQL User Name" " and Program:"
98588>>>                        For iCount from 0 to iSize
98594>>>>
98594>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98598>>>                        Loop
98599>>>>
98599>>>                    End_Procedure
98600>>>
98600>>>                End_Object
98601>>>
98601>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98603>>>                    Set Size to 12 101
98604>>>                    Set Location to 193 297
98605>>>                    Set Label to "Is Table or View?"
98606>>>
98606>>>                    Procedure OnClick
98609>>>                        String sDriverID sTableName
98609>>>                        Handle hTable
98609>>>                        Boolean bViewTableType
98609>>>
98609>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98610>>>                        Get Value of oSQLTableName_cf to sTableName
98611>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98612>>>                        If (hTable = 0) Begin
98614>>>                            Procedure_Return
98615>>>                        End
98615>>>>
98615>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98616>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98617>>>                    End_Procedure
98618>>>
98618>>>                End_Object
98619>>>
98619>>>            End_Object
98620>>>
98620>>>        End_Object
98621>>>
98621>>>    End_Object
98622>>>
98622>>>End_Object
98623>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98623>>>Use Windows.pkg
98623>>>Use DFClient.pkg
98623>>>Use Dfspnfrm.pkg
98623>>>Use Dfline.pkg
98623>>>Use cDbScrollingContainer.pkg
98623>>>Use cRDCButtonDPI.pkg
98623>>>Use cDbUpdateFunctionLibrary.pkg
98623>>>
98623>>>Define CI_Table1_FileNo for 401
98623>>>Define CI_View1_FileNo  for 402
98623>>>
98623>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98633>>>>
98633>>>Object oAPIFunctions_vw is a dbView
98635>>>    Set Border_Style to Border_Thick
98636>>>    Set Size to 237 424
98637>>>    Set Location to 17 2
98638>>>    Set Label to "API Functions"
98639>>>    Set pbAutoActivate to True
98640>>>    Set Icon to "APIFunctions.ico"
98641>>>
98641>>>    Property String psTableName ""
98643>>>
98643>>>    Procedure OnSetFocus
98646>>>        String sValue
98646>>>        tSQLConnection SQLConnection
98646>>>        tSQLConnection SQLConnection
98646>>>
98646>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98647>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98648>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98649>>>        Set Value of oApiConnectionString_fm to sValue
98650>>>    End_Procedure
98651>>>
98651>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98653>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98655>>>
98655>>>            Object oApiFunctions_grp is a Group
98657>>>                Set Size to 222 402
98658>>>                Set Location to 6 12
98659>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98660>>>                Set peAnchors to anAll
98661>>>
98661>>>                Object oApiConnectionString_fm is a Form
98663>>>                    Set Size to 12 368
98664>>>                    Set Location to 23 14
98665>>>                    Set Label to "Current Connection String Settings:"
98666>>>                    Set Label_Col_Offset to 0
98667>>>                    Set Label_Justification_Mode to JMode_Top
98668>>>                    Set peAnchors to anTopLeftRight
98669>>>                    Set Enabled_State to False
98670>>>                    Set Label_Row_Offset to 1
98671>>>                End_Object
98672>>>
98672>>>                Object oApiDatabase_fm is a Form
98674>>>                    Set Size to 12 86
98675>>>                    Set Location to 50 14
98676>>>                    Set Label to "Database:"
98677>>>                    Set Label_Col_Offset to 0
98678>>>                    Set Label_Justification_Mode to JMode_Top
98679>>>                    Set Label_Row_Offset to 1
98680>>>                    Set Enabled_State to False
98681>>>                    Set FontWeight to fw_Bold
98682>>>//                    Set Label_FontWeight to fw_Bold
98682>>>
98682>>>                    Procedure Page Integer iPageObject
98685>>>                        String sValue
98685>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98686>>>                        Set Value to sValue
98687>>>
98687>>>                        Forward Send Page iPageObject
98689>>>                    End_Procedure
98690>>>
98690>>>                End_Object
98691>>>
98691>>>                Object oDriverID3_cf is a ComboForm
98693>>>                    Set Size to 12 91
98694>>>                    Set Location to 51 121
98695>>>                    Set Label_Col_Offset to 0
98696>>>                    Set Label_Justification_Mode to JMode_Top
98697>>>                    Set Label to "Driver ID:"
98698>>>                    Set Entry_State to False
98699>>>                    Set Enabled_State to False
98700>>>                    Set Label_Row_Offset to 1
98701>>>                    Set Enabled_State to False
98702>>>
98702>>>                    Procedure Combo_Fill_List
98705>>>                        Send Combo_Add_Item MSSQLDRV_ID
98706>>>                        Send Combo_Add_Item DB2_DRV_ID
98707>>>                        Send Combo_Add_Item ODBC_DRV_ID
98708>>>                    End_Procedure
98709>>>
98709>>>                    Procedure Refresh
98712>>>                        String sValue
98712>>>
98712>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98713>>>                        Set Value to sValue
98714>>>                    End_Procedure
98715>>>
98715>>>                End_Object
98716>>>
98716>>>                Object oDatabaseInfo_tb is a TextBox
98718>>>                    Set Auto_Size_State to False
98719>>>                    Set Size to 25 96
98720>>>                    Set Location to 64 14
98721>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98722>>>                    Set Justification_Mode to JMode_Left
98723>>>                End_Object
98724>>>
98724>>>                Object oApiTableName_fm is a Form
98726>>>                    Set Size to 12 77
98727>>>                    Set Location to 114 14
98728>>>                    Set Label_Col_Offset to 0
98729>>>                    Set Label_Justification_Mode to JMode_Top
98730>>>                    Set Label to "Table Name:"
98731>>>                    Set Label_Row_Offset to 1
98732>>>                    Set Value to "NewTable"
98733>>>                    Procedure OnChange
98736>>>                        String sValue
98736>>>                        Get Value to sValue
98737>>>                        Set psTableName to sValue
98738>>>                    End_Procedure
98739>>>                    Send OnChange
98740>>>                End_Object
98741>>>
98741>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98743>>>                    Set Size to 12 69
98744>>>                    Set Location to 114 271
98745>>>                    Set Label to "Add Table"
98746>>>                    Set psImage to "ActionAddTable.ico"
98747>>>
98747>>>                    Procedure OnClick
98750>>>                        Boolean bOk
98750>>>                        Handle hTable
98750>>>                        String sTableName sDriverID
98750>>>
98750>>>                        Get Value of oDriverID3_cf to sDriverID
98751>>>                        Get Value of oApiTableName_fm to sTableName
98752>>>                        Move (Trim(sTableName)) to sTableName
98753>>>                        If (sTableName = "") Begin
98755>>>                            Send Info_Box "You first need to enter a table name."
98756>>>                            Procedure_Return
98757>>>                        End
98757>>>>
98757>>>
98757>>>                        Send Cursor_Wait of Cursor_Control
98758>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98759>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98760>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98761>>>                        If (bOk = True) Begin
98763>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98764>>>                        End
98764>>>>
98764>>>                        Else Begin
98765>>>                            Send Cursor_Ready of Cursor_Control
98766>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98767>>>                            Procedure_Return
98768>>>                        End
98768>>>>
98768>>>
98768>>>                    End_Procedure
98769>>>
98769>>>                End_Object
98770>>>
98770>>>                Object oApiAddColumn_fm is a Form
98772>>>                    Set Size to 12 77
98773>>>                    Set Location to 141 14
98774>>>                    Set Label_Col_Offset to 0
98775>>>                    Set Label_Justification_Mode to JMode_Top
98776>>>                    Set Label to "Column Name:"
98777>>>                    Set Label_Row_Offset to 1
98778>>>                    Set Value to "NewColumn"
98779>>>                End_Object
98780>>>
98780>>>                Object oApiColumnType_cf is a ComboForm
98782>>>                    Set Size to 12 85
98783>>>                    Set Location to 141 96
98784>>>                    Set Label_Col_Offset to 0
98785>>>                    Set Label_Justification_Mode to JMode_Top
98786>>>                    Set Label_Row_Offset to 1
98787>>>                    Set Label to "Type:"
98788>>>                    Set Entry_State to False
98789>>>
98789>>>                    Procedure Combo_Fill_List
98792>>>                        tColumnType[] ColumnTypeArray
98792>>>                        tColumnType[] ColumnTypeArray
98793>>>                        Integer iSize iCount
98793>>>
98793>>>                        Send Delete_Data
98794>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98795>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98796>>>                        Decrement iSize
98797>>>                        For iCount from 0 to iSize
98803>>>>
98803>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98804>>>                        Loop
98805>>>>
98805>>>                        Set Value to ColumnTypeArray[0].sSQLType
98806>>>                    End_Procedure
98807>>>
98807>>>                    Procedure OnChange
98810>>>                        Integer iType iSize iDec
98810>>>                        tSQLConnection SQLConnection
98810>>>                        tSQLConnection SQLConnection
98810>>>                        Boolean bFixed
98810>>>
98810>>>                        Get SelectedType to iType
98811>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98812>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98813>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98814>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98815>>>
98815>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98816>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98817>>>                        Set Value         of oApiLength_sf   to iSize
98818>>>                        If (iDec = 0) Begin
98820>>>                            Set Value     of oApiDecimals_sf to ""
98821>>>                        End
98821>>>>
98821>>>                        Else Begin
98822>>>                            Set Value     of oApiDecimals_sf to iDec
98823>>>                        End
98823>>>>
98823>>>                        If (bFixed = False) Begin
98825>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98826>>>                        End
98826>>>>
98826>>>                    End_Procedure
98827>>>
98827>>>                    Function SelectedType Returns Integer
98830>>>                        String sValue
98830>>>                        Integer iType
98830>>>
98830>>>                        Get Value to sValue
98831>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98832>>>
98832>>>                        Function_Return iType
98833>>>                    End_Function
98834>>>
98834>>>                End_Object
98835>>>
98835>>>                Object oApiLength_sf is a SpinForm
98837>>>                    Set Label to "Length:"
98838>>>                    Set Size to 12 35
98839>>>                    Set Location to 141 186
98840>>>                    Set Label_Col_Offset to 0
98841>>>                    Set Label_Justification_Mode to JMode_Top
98842>>>                    Set Label_Row_Offset to 1
98843>>>                    Set Value to "10"
98844>>>                    Set Maximum_Position to 500
98845>>>                    Set Minimum_Position to 1
98846>>>                End_Object
98847>>>
98847>>>                Object oApiDecimals_sf is a SpinForm
98849>>>                    Set Label to "Decimals:"
98850>>>                    Set Size to 12 33
98851>>>                    Set Location to 141 225
98852>>>                    Set Label_Col_Offset to 0
98853>>>                    Set Label_Justification_Mode to JMode_Top
98854>>>                    Set Label_Row_Offset to 1
98855>>>                    Set Value to "0"
98856>>>                    Set Maximum_Position to 16
98857>>>                    Set Minimum_Position to 1
98858>>>                End_Object
98859>>>
98859>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98861>>>                    Set Size to 12 69
98862>>>                    Set Location to 141 271
98863>>>                    Set Label to "Add Column"
98864>>>                    Set psToolTip to "ApiColumnAdd function"
98865>>>                    Set psImage to "ActionAddColumn.ico"
98866>>>
98866>>>                    Procedure OnClick
98869>>>                        Boolean bOk
98869>>>                        Handle hTable
98869>>>                        String sTableName sColumnName sType sDriverID
98869>>>                        Integer iType iLength iDecimals
98869>>>
98869>>>                        Get Value of oDriverID3_cf            to sDriverID
98870>>>                        Get Value of oApiTableName_fm         to sTableName
98871>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98872>>>                        Get SelectedType of oApiColumnType_cf to iType
98873>>>                        Get Value        of oApiLength_sf     to iLength
98874>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98875>>>
98875>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98876>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98877>>>                        If (hTable = 0) Begin
98879>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98880>>>                            Procedure_Return
98881>>>                        End
98881>>>>
98881>>>                        If (sColumnName = "") Begin
98883>>>                            Send Info_Box "You need to enter a column name"
98884>>>                            Procedure_Return
98885>>>                        End
98885>>>>
98885>>>
98885>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98886>>>                        If (bOk = True) Begin
98888>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98889>>>                        End
98889>>>>
98889>>>                        Else Begin
98890>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98891>>>                            Procedure_Return
98892>>>                        End
98892>>>>
98892>>>
98892>>>                    End_Procedure
98893>>>
98893>>>                End_Object
98894>>>
98894>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98896>>>                    Set Size to 26 77
98897>>>                    Set Location to 184 14
98898>>>                    Set Label to "Create 'New' Table with Three Columns"
98899>>>                    Set MultiLineState to True
98900>>>                    Set psImage to "ActionAddTable.ico"
98901>>>
98901>>>                    Procedure OnClick
98904>>>                        Boolean bOk
98904>>>                        Handle hTable
98904>>>                        String sTableName sDriverID
98904>>>
98904>>>                        Get Value of oDriverID3_cf to sDriverID
98905>>>                        Get Value of oApiTableName_fm to sTableName
98906>>>                        Move (Trim(sTableName)) to sTableName
98907>>>                        If (sTableName = "") Begin
98909>>>                            Send Info_Box "You first need to enter a table name."
98910>>>                            Procedure_Return
98911>>>                        End
98911>>>>
98911>>>
98911>>>                        Send Cursor_Wait of Cursor_Control
98912>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98913>>>
98913>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98914>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98915>>>                        If (bOk = True) Begin
98917>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98918>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98919>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98920>>>                        End
98920>>>>
98920>>>                        Send Cursor_Ready of Cursor_Control
98921>>>
98921>>>                        If (bOk = True) Begin
98923>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98924>>>                        End
98924>>>>
98924>>>                        Else Begin
98925>>>                            Send Cursor_Ready of Cursor_Control
98926>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98927>>>                            Procedure_Return
98928>>>                        End
98928>>>>
98928>>>
98928>>>                    End_Procedure
98929>>>
98929>>>                End_Object
98930>>>
98930>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98932>>>                    Set Size to 26 77
98933>>>                    Set Location to 184 96
98934>>>                    Set Label to "Remove 'New' Table"
98935>>>                    Set psImage to "ActionDeleteTable.ico"
98936>>>                    Set MultiLineState to True
98937>>>
98937>>>                    Procedure OnClick
98940>>>                        Boolean bOk
98940>>>                        Integer iRetval
98940>>>                        Handle hTable
98940>>>                        String sTableName sDriverID
98940>>>
98940>>>                        Get Value of oDriverID3_cf to sDriverID
98941>>>                        Get Value of oApiTableName_fm to sTableName
98942>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98943>>>                        If (iRetval = MBR_Yes) Begin
98945>>>                            Send Cursor_Wait of Cursor_Control
98946>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98947>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98948>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98949>>>                            Send Cursor_Ready of Cursor_Control
98950>>>                            If (bOk = True) Begin
98952>>>                                Send Info_Box "Table removed"
98953>>>                            End
98953>>>>
98953>>>                            Else Begin
98954>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98955>>>                            End
98955>>>>
98955>>>                        End
98955>>>>
98955>>>                    End_Procedure
98956>>>
98956>>>                End_Object
98957>>>
98957>>>                Object oLineControl1 is a LineControl
98959>>>                    Set Size to 2 387
98960>>>                    Set Location to 96 6
98961>>>                    Set peAnchors to anTopLeftRight
98962>>>                End_Object
98963>>>
98963>>>                Object oLineControl2 is a LineControl
98965>>>                    Set Size to 3 248
98966>>>                    Set Location to 171 9
98967>>>                End_Object
98968>>>
98968>>>                Object oTestError_fm is a Form
98970>>>                    Set Size to 13 64
98971>>>                    Set Location to 186 180
98972>>>                    Set Form_Datatype to 0 
98973>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98974>>>                End_Object
98975>>>
98975>>>Register_Function FetchErrorDescription Integer iError Returns String
98975>>>                Object oFindErrorText_Btn is a Button
98977>>>                    Set Size to 13 70
98978>>>                    Set Location to 186 248
98979>>>                    Set Label to "Find Error Text"
98980>>>                
98980>>>                    Procedure OnClick
98983>>>                        String sRetval
98983>>>                        Integer iError 
98983>>>                        Handle hoLogFile
98983>>>                        
98983>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98984>>>                        Get Value of oTestError_fm to iError
98985>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98986>>>                        Set Value of oErrorText_fm to sRetval    
98987>>>                    End_Procedure
98988>>>                
98988>>>                End_Object
98989>>>
98989>>>                Object oErrorText_fm is a Form
98991>>>                    Set Size to 13 213
98992>>>                    Set Location to 202 180
98993>>>                End_Object
98994>>>
98994>>>            End_Object
98995>>>
98995>>>        End_Object
98996>>>
98996>>>    End_Object
98997>>>
98997>>>End_Object
98998>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98998>>>
98998>>>Use Windows.pkg
98998>>>Use DFClient.pkg
98998>>>Use Dfline.pkg
98998>>>Use cDbScrollingContainer.pkg
98998>>>Use cRDCButtonDPI.pkg
98998>>>Use cDbUpdateFunctionLibrary.pkg
98998>>>Use Dftreevw.pkg
98998>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98998>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98998>>>>>//
98998>>>>>// This program is free software; you can redistribute it and/or
98998>>>>>// modify it under the terms of the GNU General Public License
98998>>>>>// as published by the Free Software Foundation; version 2
98998>>>>>// of the License.
98998>>>>>
98998>>>>>// This program is distributed in the hope that it will be useful,
98998>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98998>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98998>>>>>// GNU General Public License for more details.
98998>>>>>
98998>>>>>// You should have received a copy of the GNU General Public License
98998>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98998>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98998>>>>>Use Windows.pkg
98998>>>>>
98998>>>>>Object oWorkingMessagePanel is a ToolPanel
99000>>>>>    Set Label    to "Working"
99001>>>>>    Set Size to 48 150
99002>>>>>    Set Locate_Mode to CENTER_ON_PARENT
99003>>>>>    Set Popup_State to True
99004>>>>>
99004>>>>>    Object oWorkingMessage is a Textbox
99006>>>>>        Set Label to "Working message..."
99007>>>>>        Set Location to 15 5
99008>>>>>        Set Size to 27 123
99009>>>>>        Set Auto_Size_State to False
99010>>>>>        Set Justification_Mode to JMode_Center
99011>>>>>        Set FontWeight to fw_Bold
99012>>>>>    End_Object
99013>>>>>
99013>>>>>End_Object
99014>>>>>
99014>>>>>Procedure StartWorkingMessage Global String sText
99016>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
99017>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
99018>>>>>    Send Popup of (oWorkingMessagePanel(Self))
99019>>>>>End_Procedure
99020>>>>>
99020>>>>>Procedure StopWorkingMessage Global
99022>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
99023>>>>>End_Procedure
99024>>>Use DUFStatusPanel.pkg
99024>>>Use cCharTranslate.pkg
99024>>>
99024>>>Struct tFilelistDUF
99024>>>    Integer iFileNumber
99024>>>    String sLogicalName
99024>>>    String sRootName
99024>>>    String sDisplayName
99024>>>End_Struct
99024>>>
99024>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
99034>>>>
99034>>>Object oUtilFunctions_vw is a dbView
99036>>>    Set Border_Style to Border_Thick
99037>>>    Set Size to 291 428
99038>>>    Set Location to 2 1
99039>>>    Set Label to "Utility Functions"
99040>>>    Set pbAutoActivate to True
99041>>>    Set Icon to "TestTools.ico"
99042>>>    Set pbAcceptDropFiles to True
99043>>>
99043>>>    Object oScrollingContainer1 is a cDbScrollingContainer
99045>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
99047>>>
99047>>>            Object oSQL_grp is a Group
99049>>>                Set Size to 88 402
99050>>>                Set Location to 7 12
99051>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
99052>>>                Set peAnchors to anTopLeftRight
99053>>>
99053>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
99055>>>                    Set Size to 14 219
99056>>>                    Set Location to 13 13
99057>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
99058>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
99059>>>                    Set psImage to "ActionCreateDatabase.ico"
99060>>>
99060>>>                    Procedure OnClick
99063>>>                        String sInfoText sDriverID
99063>>>                        Boolean bOK
99063>>>                        TimeSpan tsTotalQueryTime
99063>>>                        Integer iRetval
99063>>>
99063>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
99063>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
99063>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
99063>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
99064>>>                        If (iRetval <> MBR_Yes) Begin
99066>>>                            Procedure_Return
99067>>>                        End
99067>>>>
99067>>>
99067>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
99068>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
99070>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
99071>>>                            Procedure_Return
99072>>>                        End
99072>>>>
99072>>>
99072>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
99073>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
99074>>>                        Send StopWorkingMessage
99075>>>
99075>>>                        If (bOK = True) Begin
99077>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
99078>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
99079>>>                        End
99079>>>>
99079>>>
99079>>>                        Else Begin
99080>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
99081>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
99082>>>                        End
99082>>>>
99082>>>
99082>>>                        Send Info_Box sInfoText
99083>>>                    End_Procedure
99084>>>
99084>>>                End_Object
99085>>>
99085>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
99087>>>                    Set Size to 14 219
99088>>>                    Set Location to 33 13
99089>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
99090>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
99091>>>                    Set psImage to "ActionCreateDatabase.ico"
99092>>>
99092>>>                    Procedure OnClick
99095>>>                        String sInfoText sDriverID
99095>>>                        Boolean bOK
99095>>>                        TimeSpan tsTotalQueryTime
99095>>>                        Integer iRetval
99095>>>
99095>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
99095>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
99095>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
99095>>>
99095>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
99096>>>                        If (iRetval <> MBR_Yes) Begin
99098>>>                            Procedure_Return
99099>>>                        End
99099>>>>
99099>>>
99099>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
99100>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
99102>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
99103>>>                            Procedure_Return
99104>>>                        End
99104>>>>
99104>>>
99104>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
99105>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
99106>>>                        Send StopWorkingMessage
99107>>>
99107>>>                        If (bOK = True) Begin
99109>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
99110>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
99111>>>                        End
99111>>>>
99111>>>
99111>>>                        Else Begin
99112>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
99113>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
99114>>>                        End
99114>>>>
99114>>>
99114>>>                        Send Info_Box sInfoText
99115>>>                    End_Procedure
99116>>>
99116>>>                End_Object
99117>>>
99117>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
99119>>>                    Set Size to 14 219
99120>>>                    Set Location to 53 13
99121>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
99122>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
99123>>>                    Set psImage to "ActionCreateDatabase.ico"
99124>>>
99124>>>                    Procedure OnClick
99127>>>                        String sInfoText sDriverID
99127>>>                        Boolean bOK
99127>>>                        TimeSpan tsTotalQueryTime
99127>>>                        Integer iRetval
99127>>>
99127>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
99127>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
99127>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
99127>>>
99127>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
99128>>>                        If (iRetval <> MBR_Yes) Begin
99130>>>                            Procedure_Return
99131>>>                        End
99131>>>>
99131>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
99132>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
99134>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
99135>>>                            Procedure_Return
99136>>>                        End
99136>>>>
99136>>>
99136>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
99137>>>
99137>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
99138>>>
99138>>>                        Send StopWorkingMessage
99139>>>                        If (bOK = True) Begin
99141>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
99142>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
99143>>>                        End
99143>>>>
99143>>>
99143>>>                        Else Begin
99144>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
99145>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
99146>>>                        End
99146>>>>
99146>>>
99146>>>                        Send Info_Box sInfoText
99147>>>                    End_Procedure
99148>>>
99148>>>                End_Object
99149>>>
99149>>>                Object oInfo_tb is a TextBox
99151>>>                    Set Auto_Size_State to False
99152>>>                    Set Size to 25 158
99153>>>                    Set Location to 53 238
99154>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
99155>>>                    Set Justification_Mode to JMode_Left
99156>>>                    Set peAnchors to anTopLeftRight
99157>>>                End_Object
99158>>>
99158>>>        //  This will choke the computer so don't try it!
99158>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
99158>>>        //            Set Size to 14 312
99158>>>        //            Set Location to 97 45
99158>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
99158>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
99158>>>        //
99158>>>        //            Procedure OnClick
99158>>>        //                String sInfoText
99158>>>        //                Boolean bOK
99158>>>        //                TimeSpan tsTotalQueryTime
99158>>>        //                Integer iRetval
99158>>>        //
99158>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
99158>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
99158>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
99158>>>        //Procedure_Return
99158>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
99158>>>        //                If (iRetval <> MBR_Yes) Begin
99158>>>        //                    Procedure_Return
99158>>>        //                End
99158>>>        //
99158>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
99158>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
99158>>>        //                Send StopWorkingMessage
99158>>>        //
99158>>>        //                If (bOK = True) Begin
99158>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
99158>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
99158>>>        //                End
99158>>>        //
99158>>>        //                Else Begin
99158>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
99158>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
99158>>>        //                End
99158>>>        //
99158>>>        //                Send Info_Box sInfoText
99158>>>        //            End_Procedure
99158>>>        //
99158>>>        //        End_Object
99158>>>
99158>>>            End_Object
99159>>>
99159>>>            Object oChangeIntFiles_grp is a Group
99161>>>                Set Size to 65 402
99162>>>                Set Location to 102 12
99163>>>                Set Label to "Change Old .int files to use Connection ID's"
99164>>>                Set peAnchors to anTopLeftRight
99165>>>
99165>>>                Object oSelectDataPath_fm is a Form
99167>>>                    Set Size to 12 300
99168>>>                    Set Location to 22 13
99169>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
99170>>>                    Set Label_Col_Offset to 0
99171>>>                    Set Label_Row_Offset to 1
99172>>>                    Set Label_Justification_Mode to JMode_Top
99173>>>
99173>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99173>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99173>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
99174>>>                    Set peAnchors to anTopLeftRight
99175>>>
99175>>>                    Procedure Prompt
99178>>>                        String sPath sFileMask sRetval
99178>>>
99178>>>                        Get psDataPathFirstPart to sPath
99179>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
99180>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
99181>>>                        If (sRetval <> "") Begin
99183>>>                            Get ParseFolderName sRetval to sPath
99184>>>                            If (Right(sPath, 1) ="\") Begin
99186>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
99187>>>                            End
99187>>>>
99187>>>                            Set Value to sPath
99188>>>                        End
99188>>>>
99188>>>                    End_Procedure
99189>>>
99189>>>                    // Returns the first datapath found in the psDataPath property.
99189>>>                    // The returned path always ends with a "\"
99189>>>                    Function psDataPathFirstPart Returns String
99192>>>                        String sDataPath
99192>>>                        Integer iCount
99192>>>
99192>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
99193>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
99194>>>                        If (iCount > 1) Begin
99196>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
99197>>>                        End
99197>>>>
99197>>>                        If (sDataPath <> "") Begin
99199>>>                            Get vFolderFormat sDataPath to sDataPath
99200>>>                        End
99200>>>>
99200>>>
99200>>>                        Function_Return sDataPath
99201>>>                    End_Function
99202>>>
99202>>>                End_Object
99203>>>
99203>>>                Object oSelectFolder_btn is a cRDCButtonDPI
99205>>>                    Set Size to 13 73
99206>>>                    Set Location to 22 320
99207>>>                    Set Label to "Select Folder"
99208>>>                    Set psToolTip to "Please select an .int file from the data folder"
99209>>>                    Set peAnchors to anTopRight
99210>>>                    Set psImage to "ActionOpen.ico"
99211>>>
99211>>>                    Procedure OnClick
99214>>>                        Send Prompt to oSelectDataPath_fm
99215>>>                    End_Procedure
99216>>>
99216>>>                End_Object
99217>>>
99217>>>                Object oConnectionID_fm is a Form
99219>>>                    Set Size to 13 111
99220>>>                    Set Location to 38 202
99221>>>                    Set Label_Col_Offset to 2
99222>>>                    Set Label_Justification_Mode to JMode_Right
99223>>>                    Set Label to "Change to DFConnID:"
99224>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
99225>>>                    Set peAnchors to anTopRight
99226>>>                End_Object
99227>>>
99227>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
99229>>>                    Set Size to 13 68
99230>>>                    Set Location to 38 320
99231>>>                    Set Label to "GO !"
99232>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
99233>>>                    Set FontWeight to fw_Bold
99234>>>                    Set peAnchors to anTopRight
99235>>>
99235>>>                    Procedure OnClick
99238>>>                        String sDataPath sConnectionID
99238>>>                        Boolean bExists bActive
99238>>>                        Integer iRetval iChangedFiles
99238>>>
99238>>>                        Get Value of oSelectDataPath_fm to sDataPath
99239>>>                        Get vFolderExists sDataPath to bExists
99240>>>                        If (bExists = False) Begin
99242>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
99243>>>                            Procedure_Return
99244>>>                        End
99244>>>>
99244>>>                        Get Value of oConnectionID_fm to sConnectionID
99245>>>                        Move (Trim(sConnectionID)) to sConnectionID
99246>>>                        If (sConnectionID = "") Begin
99248>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
99249>>>                            Procedure_Return
99250>>>                        End
99250>>>>
99250>>>
99250>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
99251>>>                        If (iRetval <> MBR_Yes) Begin
99253>>>                            Procedure_Return
99254>>>                        End
99254>>>>
99254>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
99255>>>                        If (iRetval <> MBR_Yes) Begin
99257>>>                            Procedure_Return
99258>>>                        End
99258>>>>
99258>>>
99258>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
99259>>>                        If (iRetval <> 0) Begin
99261>>>                            Send Info_Box "Could not delete .cch files!"
99262>>>                            Procedure_Return
99263>>>                        End
99263>>>>
99263>>>
99263>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
99264>>>                        Send Start_StatusPanel of ghoStatusPanel
99265>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
99266>>>
99266>>>                        Get Active_State of ghoStatusPanel to bActive
99267>>>                        If (bActive = False) Begin
99269>>>                            Send Info_Box "Process interupted..."
99270>>>                        End
99270>>>>
99270>>>                        Else Begin
99271>>>                            Send Stop_StatusPanel of ghoStatusPanel
99272>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
99273>>>                        End
99273>>>>
99273>>>                    End_Procedure
99274>>>
99274>>>                End_Object
99275>>>
99275>>>            End_Object
99276>>>
99276>>>            Object oRemoveFilelistDriverIDs_grp is a Group
99278>>>                Set Size to 59 402
99279>>>                Set Location to 171 12
99280>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
99281>>>                Set peAnchors to anTopLeftRight
99282>>>//                Set TextColor to clGreen
99282>>>//
99282>>>//                Procedure Page Integer iPage
99282>>>//                    Integer ia iz
99282>>>//                    Forward Send Page iPage
99282>>>//                    Move 0 to iz
99282>>>//                    Move (AddressOf(iz)) to ia
99282>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
99282>>>//                End_Procedure
99282>>>
99282>>>                Object oFilelistPath_fm is a Form
99284>>>                    Set Size to 13 299
99285>>>                    Set Location to 22 13
99286>>>                    Set Label to "Path and Filelist.cfg Name:"
99287>>>                    Set Label_Col_Offset to 0
99288>>>                    Set Label_Row_Offset to 1
99289>>>                    Set Label_Justification_Mode to JMode_Top
99290>>>
99290>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99290>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99290>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
99291>>>                    Set peAnchors to anTopLeftRight
99292>>>
99292>>>                    Procedure Prompt
99295>>>                        String sFileName sPath sFileMask sRetval
99295>>>
99295>>>                        Get Value to sFileName
99296>>>                        Get ParseFolderName sFileName to sPath
99297>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
99298>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
99299>>>                        If (sRetval <> "") Begin
99301>>>                            Set Value to sRetval
99302>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
99305>>>                        End
99305>>>>
99305>>>                    End_Procedure
99306>>>
99306>>>                    Procedure OnCreate
99309>>>                        String sFilelist
99309>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
99312>>>                        Set Value to sFilelist
99313>>>                    End_Procedure
99314>>>                    Send OnCreate
99315>>>
99315>>>                End_Object
99316>>>
99316>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
99318>>>                    Set Size to 13 73
99319>>>                    Set Location to 22 319
99320>>>                    Set Label to "Select Filelist.cfg"
99321>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
99322>>>                    Set peAnchors to anTopRight
99323>>>
99323>>>                    Procedure OnClick
99326>>>                        Send Prompt to oFilelistPath_fm
99327>>>                    End_Procedure
99328>>>
99328>>>                End_Object
99329>>>
99329>>>                Object oInfo_tb is a TextBox
99331>>>                    Set Size to 9 207
99332>>>                    Set Location to 40 138
99333>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99334>>>                    Set peAnchors to anTopRight
99335>>>                End_Object
99336>>>
99336>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99338>>>                    Set Size to 13 68
99339>>>                    Set Location to 38 319
99340>>>                    Set Label to "GO !"
99341>>>                    Set FontWeight to fw_Bold
99342>>>                    Set peAnchors to anTopRight
99343>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99344>>>
99344>>>                    Procedure OnClick
99347>>>                        String sFileList
99347>>>                        Integer iRetval iCount
99347>>>                        Boolean bExits
99347>>>
99347>>>                        Get Value of oFilelistPath_fm to sFileList
99348>>>                        Get vFilePathExists sFileList to bExits
99349>>>                        If (bExits = False) Begin
99351>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99352>>>                            Procedure_Return
99353>>>                        End
99353>>>>
99353>>>
99353>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99354>>>                        If (iRetval <> MBR_Yes) Begin
99356>>>                            Procedure_Return
99357>>>                        End
99357>>>>
99357>>>                        Send Cursor_Wait of Cursor_Control
99358>>>
99358>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99359>>>
99359>>>                        Send Cursor_Ready of Cursor_Control
99360>>>                        If (iCount <> 0) Begin
99362>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99363>>>                        End
99363>>>>
99363>>>                        Else Begin
99364>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99365>>>                        End
99365>>>>
99365>>>
99365>>>                    End_Procedure
99366>>>
99366>>>                End_Object
99367>>>
99367>>>            End_Object
99368>>>
99368>>>            Object oOutput_grp is a Group
99370>>>                Set Size to 47 402
99371>>>                Set Location to 234 12
99372>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99373>>>                Set peAnchors to anTopLeftRight
99374>>>
99374>>>                Object oOutput_rg is a RadioGroup
99376>>>                    Set Location to 18 13
99377>>>                    Set Size to 25 288
99378>>>                    Set Label to "Filelist Output Order"
99379>>>
99379>>>                    Object oRadio1 is a Radio
99381>>>                        Set Label to "Filelist Number"
99382>>>                        Set Size to 10 61
99383>>>                        Set Location to 10 7
99384>>>                    End_Object
99385>>>
99385>>>                    Object oRadio2 is a Radio
99387>>>                        Set Label to "Logical Name"
99388>>>                        Set Size to 10 61
99389>>>                        Set Location to 10 77
99390>>>                    End_Object
99391>>>
99391>>>                    Object oRadio3 is a Radio
99393>>>                        Set Label to "Root Name"
99394>>>                        Set Size to 10 61
99395>>>                        Set Location to 10 147
99396>>>                    End_Object
99397>>>
99397>>>                    Object oRadio4 is a Radio
99399>>>                        Set Label to "Display Name"
99400>>>                        Set Size to 10 62
99401>>>                        Set Location to 10 213
99402>>>                    End_Object
99403>>>
99403>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99406>>>                        Forward Send Notify_Select_State iToItem iFromItem
99408>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99409>>>                    End_Procedure
99410>>>
99410>>>                End_Object
99411>>>                
99411>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99413>>>                    Set Size to 13 78
99414>>>                    Set Location to 26 315
99415>>>                    Set Label to "Print to Filelist.txt"
99416>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99417>>>                    Set psImage to "ActionDocument.ico"
99418>>>
99418>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99420>>>
99420>>>                    // Custom array sort function.
99420>>>                    // iSortOrder = 0 -> Filelist number order
99420>>>                    // iSortOrder = 1 -> Logical name order
99420>>>                    // iSortOrder = 2 -> Root name order
99420>>>                    // iSortOrder = 3 -> Display name order
99420>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99423>>>                        Integer iSortOrder
99423>>>
99423>>>                        Get piSortOrder to iSortOrder
99424>>>
99424>>>                        Case Begin
99424>>>                            Case (iSortOrder = 0)
99426>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99428>>>                                    Function_Return (GT)
99429>>>                                End
99429>>>>
99429>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99431>>>                                    Function_Return (LT)
99432>>>                                End
99432>>>>
99432>>>                                Function_Return (EQ)
99433>>>                            Case (iSortOrder = 1)
99436>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99438>>>                                    Function_Return (GT)
99439>>>                                End
99439>>>>
99439>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99441>>>                                    Function_Return (LT)
99442>>>                                End
99442>>>>
99442>>>                                Function_Return (EQ)
99443>>>                            Case (iSortOrder = 2)
99446>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99448>>>                                    Function_Return (GT)
99449>>>                                End
99449>>>>
99449>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99451>>>                                    Function_Return (LT)
99452>>>                                End
99452>>>>
99452>>>                                Function_Return (EQ)
99453>>>                            Case (iSortOrder = 3)
99456>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99458>>>                                    Function_Return (GT)
99459>>>                                End
99459>>>>
99459>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99461>>>                                    Function_Return (LT)
99462>>>                                End
99462>>>>
99462>>>                                Function_Return (EQ)
99463>>>                        Case End
99463>>>
99463>>>                    End_Function
99464>>>
99464>>>                    Procedure OnClick
99467>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99467>>>                        Integer iCh iCount iSize
99467>>>                        Handle hTable
99467>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99467>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99469>>>
99469>>>                        Get Value of oFilelistPath_fm to sFileList
99470>>>                        Move (Trim(sFileList)) to sFileList
99471>>>                        If (sFileList = "") Begin
99473>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99474>>>                            Procedure_Return
99475>>>                        End
99475>>>>
99475>>>
99475>>>                        Get ParseFolderName sFileList to sPath
99476>>>                        Get vFolderFormat sPath to sPath
99477>>>                        Get ParseFileName sFileList to sOutputName
99478>>>                        Get ParseFileExtension sFileList to sExt
99479>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99480>>>                        Move (sOutputName + "txt")           to sOutputName
99481>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99482>>>                        If (iCh < 0) Begin
99484>>>                            Procedure_Return
99485>>>                        End
99485>>>>
99485>>>
99485>>>                        Move 0 to hTable
99486>>>                        Writeln channel iCh sFileList
99489>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99492>>>                        Writeln channel iCh "==================================================================================================="
99495>>>                        Writeln channel iCh
99497>>>
99497>>>                        Move 0 to iCount
99498>>>                        Repeat
99498>>>>
99498>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99501>>>                            If (hTable > 0) Begin
99503>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99504>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99507>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99510>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99513>>>                                Increment iCount
99514>>>                            End
99514>>>>
99514>>>                        Until (hTable = 0)
99516>>>
99516>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99517>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99518>>>                        Decrement iSize
99519>>>
99519>>>                        For iCount from 0 to iSize
99525>>>>
99525>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99526>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99527>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99528>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99529>>>
99529>>>                            Get PadLeft (String(hTable))        09 to sTable
99530>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99531>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99532>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99533>>>
99533>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99539>>>                        Loop
99540>>>>
99540>>>
99540>>>                        Writeln channel iCh "==================================================================================================="
99543>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99547>>>                        Close_Output
99548>>>
99548>>>                        Send vShellExecute "open" sOutputName "" sPath
99549>>>                    End_Procedure
99550>>>
99550>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99553>>>                        String sChar
99553>>>
99553>>>                        If (Num_Arguments >= 3) Begin
99555>>>                            Move sOptChar to sChar
99556>>>                        End
99556>>>>
99556>>>                        Else Begin
99557>>>                            Move " " to sChar
99558>>>                        End
99558>>>>
99558>>>
99558>>>                        While (Length(sString) < iLength)
99562>>>                            Move (sChar + sString) to sString
99563>>>                        Loop
99564>>>>
99564>>>
99564>>>                        Function_Return sString
99565>>>                    End_Function
99566>>>
99566>>>                End_Object
99567>>>            End_Object
99568>>>
99568>>>        End_Object
99569>>>
99569>>>    End_Object
99570>>>
99570>>>    Procedure OnFileDropped String sFilename Boolean bLast
99573>>>        String sTest
99573>>>        Forward Send OnFileDropped sFilename bLast
99575>>>        If (bLast = True) Begin
99577>>>            Get ParseFileName sFilename to sTest
99578>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99580>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99581>>>                Procedure_Return
99582>>>            End
99582>>>>
99582>>>            Set Value of oFilelistPath_fm to sFilename
99583>>>        End
99583>>>>
99583>>>    End_Procedure
99584>>>
99584>>>End_Object
99585>
99585>        Procedure Activate_About
99588>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99589>        End_Procedure
99590>
99590>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99591>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99592>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99593>    End_Object
99594>
99594>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99594>    // in the oHtmlHelp object, so we need to explitetly send the message
99594>    // to that object.
99594>    Procedure ShowProgramHelp
99597>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99598>    End_Procedure
99599>
99599>    On_Key Key_F1 Send ShowProgramHelp
99600>End_Object
99601>
99601>// *** Note: If you get a compile error: "Can't include the resource COMPILEHEADER.H",
99601>//     you will need to compile the "WriteDateTimeHeaderFile" program first. ***
99601>Start_UI
99602>
Including Resources...
Summary
Memory Available: 59780042752
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52977
Total Resources: 11
Total Commands : 99601
Total Windows  : 0
Total Pages    : 0
Static Data    : 849411
Message area   : 640323
Total Blocks   : 80928
