Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 61808320512
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set piIntFilesFileNumber to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo sErrorText
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Send RestoreIntFiles
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible 
74835>>>>>        Set Visible_State of oOverallProgress_tb to bVisible
74836>>>>>    End_Procedure
74837>>>>>
74837>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74840>>>>>        Boolean bVisible
74840>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74841>>>>>        Function_Return (bVisible)
74842>>>>>    End_Function
74843>>>>>
74843>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74843>>>>>    // objects defined within this instance of the status panel.
74843>>>>>
74843>>>>>    // note: all of the messages that change text should be forwarded
74843>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74843>>>>>
74843>>>>>    Procedure Set Message_Text String sText
74846>>>>>        Set Label of oMessageTxt to sText
74847>>>>>        Forward Set Message_Text to sText
74849>>>>>    End_Procedure
74850>>>>>
74850>>>>>    Function Message_Text Returns String
74853>>>>>        Function_Return (Label(oMessageTxt))
74854>>>>>    End_Function
74855>>>>>
74855>>>>>    Procedure Set Action_Text String sText
74858>>>>>        Set Label of oActionTxt to sText
74859>>>>>        Forward Set Action_Text to sText
74861>>>>>    End_Procedure
74862>>>>>
74862>>>>>    Function Action_Text Returns String
74865>>>>>        Function_Return (Label(oActionTxt))
74866>>>>>    End_Function
74867>>>>>
74867>>>>>    Procedure Set Button_Text String sText
74870>>>>>        Set Label of oStopButton to sText
74871>>>>>        Forward Set Button_Text to sText
74873>>>>>    End_Procedure
74874>>>>>
74874>>>>>    Function Button_Text Returns String
74877>>>>>        Function_Return (Label(oStopButton))
74878>>>>>    End_Function
74879>>>>>
74879>>>>>    Procedure Set Title_Text String sText
74882>>>>>        Set Label of oTitleTxt to sText
74883>>>>>        Forward Set Title_Text to sText
74885>>>>>    End_Procedure
74886>>>>>
74886>>>>>    Function Title_Text Returns String
74889>>>>>        Function_Return (Label(oTitleTxt))
74890>>>>>    End_Function
74891>>>>>
74891>>>>>    Procedure Set TableName_Text String sText
74894>>>>>        Set Label of oTableNameTxt to sText
74895>>>>>    End_Procedure
74896>>>>>
74896>>>>>    Function TableName_Text Returns String
74899>>>>>        Function_Return (Label(oTableNameTxt))
74900>>>>>    End_Function
74901>>>>>
74901>>>>>    Procedure Set License_Text String sText
74904>>>>>//        Set Label of oLicense_txt to sText
74904>>>>>    End_Procedure 
74905>>>>>    
74905>>>>>    Procedure Set piMaximum Integer iSize
74908>>>>>        Set piMaximum of ghoProgressBar to iSize
74909>>>>>    End_Procedure  
74910>>>>>    
74910>>>>>    Procedure Set piAdvanceBy Integer iCount
74913>>>>>        Set piAdvanceBy of ghoProgressBar to iCount
74914>>>>>    End_Procedure
74915>>>>>
74915>>>>>    Procedure DoAdvance
74918>>>>>        Send DoAdvance of ghoProgressBar
74919>>>>>    End_Procedure
74920>>>>>    
74920>>>>>    // gets called when status panel is activated passing whether a button
74920>>>>>    // should appear
74920>>>>>    Procedure EnableCancelButton Boolean bEnable
74923>>>>>        Boolean bVisible
74923>>>>>        Get Cancel_Button_Visible_State to bVisible
74924>>>>>        If (bEnable = False) Begin
74926>>>>>            Set Visible_State of oStopButton to bVisible
74927>>>>>        End
74927>>>>>>
74927>>>>>        Set Enabled_State of oStopButton to bEnable
74928>>>>>    End_Procedure
74929>>>>>
74929>>>>>    Procedure Reset_StatusPanel
74932>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74933>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74934>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74935>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74936>>>>>    End_Procedure
74937>>>>>
74937>>>>>//    Object oProgressBar is a cProgressBar
74937>>>>>//        Move Self to ghoProgressBar
74937>>>>>//        Set Location to 1 25
74937>>>>>//        Set Size to 9 173
74937>>>>>//        Set piMinimum        to 0
74937>>>>>//        Set piMaximum        to 2000
74937>>>>>//        Set piAdvanceBy      to 100
74937>>>>>//        Set pbSmooth to True
74937>>>>>//
74937>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74937>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74937>>>>>//        // color will show correctly.
74937>>>>>//        Procedure Page Integer iPageObject
74937>>>>>//            Handle hWin
74937>>>>>//            Forward Send Page iPageObject
74937>>>>>//            If (ghoSkinFramework <> 0) Begin
74937>>>>>//                Get Window_Handle to hWin
74937>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74937>>>>>//            End
74937>>>>>//        End_Procedure
74937>>>>>//    End_Object
74937>>>>>
74937>>>>>End_Object
74938>>>>>
74938>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74938>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74938>>>>>//
74938>>>>>Use VdfBase.pkg
74938>>>>>Use cApplication.pkg
74938>>>>>Use seq_chnl.pkg
74938>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74938>>>>>>>// This code is part of VDF GUIdance
74938>>>>>>>// Visit us @ http://www.vdf-guidance.com
74938>>>>>>>// e-Mail us @ info@vdf-guidance.com
74938>>>>>>>// VDF GUIdance is a mutual project of
74938>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74938>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74938>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74938>>>>>>>//
74938>>>>>>>//
74938>>>>>>>// *** Windows 32bit file handling wrapper class ***
74938>>>>>>>//
74938>>>>>>>
74938>>>>>>>
74938>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74938>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74938>>>>>>>>>//***************************************************************************
74938>>>>>>>>>//*
74938>>>>>>>>>//* Class:        cvSaveAsDialog
74938>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74938>>>>>>>>>//*
74938>>>>>>>>>//***************************************************************************
74938>>>>>>>>>
74938>>>>>>>>>Use File_dlg.pkg
74938>>>>>>>>>
74938>>>>>>>>>// *WvA: 13-01-1999 Created
74938>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74938>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74938>>>>>>>>>// file_name.
74938>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74939>>>>>>>>>
74939>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74941>>>>>>>>>        Forward Send Construct_Object iImage_Id
74943>>>>>>>>>        Set HideReadOnly_State to True
74944>>>>>>>>>    End_Procedure
74945>>>>>>>>>
74945>>>>>>>>>    Function SelectedFileName Returns String
74947>>>>>>>>>        String sFileName
74947>>>>>>>>>        Move "" to sFileName
74948>>>>>>>>>        If (Show_Dialog(Self)) Begin
74950>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74951>>>>>>>>>        End
74951>>>>>>>>>>
74951>>>>>>>>>        Function_Return sFileName
74952>>>>>>>>>    End_Function
74953>>>>>>>>>End_Class
74954>>>>>>>>>
74954>>>>>>>>>// *WvA: 13-01-1999 Created
74954>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74954>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74954>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74954>>>>>>>>>//                   file-open dialog
74954>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74956>>>>>>>>>    String sSelectedFile
74956>>>>>>>>>    Integer hoOpenFileDialog
74956>>>>>>>>>
74956>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74958>>>>>>>>>
74958>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74959>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74960>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74961>>>>>>>>>
74961>>>>>>>>>        Move Self       to hoOpenFileDialog
74962>>>>>>>>>    End_Object
74963>>>>>>>>>
74963>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74964>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74965>>>>>>>>>    Function_Return sSelectedFile
74966>>>>>>>>>End_Function
74967>>>>>>>>>
74967>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74968>>>>>>>>>
74968>>>>>>>>>    Procedure Construct_Object
74970>>>>>>>>>        Forward Send Construct_Object
74972>>>>>>>>>        Set HideReadOnly_State to True
74973>>>>>>>>>    End_Procedure
74974>>>>>>>>>
74974>>>>>>>>>    Function SelectedFileName Returns String
74976>>>>>>>>>        String sFileName
74976>>>>>>>>>        Move "" to sFileName
74977>>>>>>>>>        If (Show_Dialog(Self)) Begin
74979>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74980>>>>>>>>>        End
74980>>>>>>>>>>
74980>>>>>>>>>        Function_Return sFileName
74981>>>>>>>>>    End_Function
74982>>>>>>>>>
74982>>>>>>>>>End_Class
74983>>>>>>>>>
74983>>>>>>>>>// Added optional default filename as suggested by Nils
74983>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74985>>>>>>>>>    String sSelectedFile
74985>>>>>>>>>    Integer hoDialog
74985>>>>>>>>>
74985>>>>>>>>>    Move "" to sSelectedFile
74986>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74987>>>>>>>>>    If (hoDialog) Begin
74989>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74989>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74990>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74991>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74992>>>>>>>>>        If (Num_Arguments = 4) Begin
74994>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74995>>>>>>>>>        End
74995>>>>>>>>>>
74995>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74996>>>>>>>>>        Send Destroy of hoDialog
74997>>>>>>>>>    End
74997>>>>>>>>>>
74997>>>>>>>>>    Function_Return sSelectedFile
74998>>>>>>>>>End_Function
74999>>>>>>>Use Seq_chnl.pkg
74999>>>>>>>
74999>>>>>>>Use windows.pkg
74999>>>>>>>Use Dll.pkg
74999>>>>>>>
74999>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
74999>>>>>>>>>// This code is part of VDF GUIdance
74999>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74999>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74999>>>>>>>>>// VDF GUIdance is a mutual project of
74999>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74999>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74999>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74999>>>>>>>>>//
74999>>>>>>>>>//
74999>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74999>>>>>>>>>// Unicode variant
74999>>>>>>>>>
74999>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
74999>>>>>>>>>>>//TH-Header
74999>>>>>>>>>>>//*****************************************************************************************
74999>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74999>>>>>>>>>>>// All rights reserved.
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74999>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74999>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74999>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74999>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// Contents:
74999>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74999>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74999>>>>>>>>>>>//*****************************************************************************************
74999>>>>>>>>>>>//TH-RevisionStart
74999>>>>>>>>>>>//TH-RevisionEnd
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74999>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define vMax_Path     For |CI260
74999>>>>>>>>>>>Define vMinChar      For |CI$80
74999>>>>>>>>>>>Define vMaxChar      For |CI$7F
74999>>>>>>>>>>>Define vMinShort     For |CI$8000
74999>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74999>>>>>>>>>>>Define vMinLong      For |CI$80000000
74999>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74999>>>>>>>>>>>Define vMaxByte      For |CI$FF
74999>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74999>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>// For FindFirstFile
74999>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74999>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74999>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74999>>>>>>>>>>>
74999>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74999>>>>>>>>>>>// the API-call ShellExecute is used.
74999>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74999>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74999>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74999>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74999>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74999>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74999>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74999>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74999>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74999>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74999>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74999>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74999>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74999>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>// C-Structure
74999>>>>>>>>>>>//typedef struct _browseinfo {
74999>>>>>>>>>>>//    HWND hwndOwner;
74999>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74999>>>>>>>>>>>//    LPSTR pszDisplayName;
74999>>>>>>>>>>>//    LPCSTR lpszTitle;
74999>>>>>>>>>>>//    UINT ulFlags;
74999>>>>>>>>>>>//    BFFCALLBACK lpfn;
74999>>>>>>>>>>>//    LPARAM lParam;
74999>>>>>>>>>>>//    int iImage;
74999>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74999>>>>>>>>>>>
74999>>>>>>>>>>>//declare C structure struct_browseinfo
74999>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74999>>>>>>>>>>>Struct tvBrowseInfo
74999>>>>>>>>>>>  Handle    hWndOwner
74999>>>>>>>>>>>  Pointer   pIDLRoot
74999>>>>>>>>>>>  Pointer   pszDisplayName
74999>>>>>>>>>>>  Pointer   lpszTitle
74999>>>>>>>>>>>  DWord     ulFlags
74999>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
74999>>>>>>>>>>>  Pointer   lpfnCallback
74999>>>>>>>>>>>  LongPtr   lParam
74999>>>>>>>>>>>  DWord     iImage
74999>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
74999>>>>>>>>>>>End_Struct // tvBrowseInfo
74999>>>>>>>>>>>
74999>>>>>>>>>>>// Browsing for directory.
74999>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74999>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74999>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74999>>>>>>>>>>>                                            // The callback function can set the status text by
74999>>>>>>>>>>>                                            // sending messages to the dialog box.
74999>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74999>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74999>>>>>>>>>>>
74999>>>>>>>>>>>// message from browser
74999>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74999>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74999>>>>>>>>>>>
74999>>>>>>>>>>>// messages to browser
74999>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74999>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74999>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75000>>>>>>>>>>>
75000>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75001>>>>>>>>>>>
75001>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>Struct tvSecurity_attributes
75002>>>>>>>>>>>  DWord   nLength
75002>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
75002>>>>>>>>>>>  Pointer lpDescriptor
75002>>>>>>>>>>>  Integer bInheritHandle
75002>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
75002>>>>>>>>>>>End_Struct // tvSecurity_attributes
75002>>>>>>>>>>>
75002>>>>>>>>>>>//nLength:
75002>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75002>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75002>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75002>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75002>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75002>>>>>>>>>>>//
75002>>>>>>>>>>>//lpSecurityDescriptor:
75002>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75002>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75002>>>>>>>>>>>// descriptor of the calling process.
75002>>>>>>>>>>>//
75002>>>>>>>>>>>//bInheritHandle:
75002>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75002>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>// BOOL CreateDirectory(
75002>>>>>>>>>>>//    LPCTSTR lpPathName,
75002>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75002>>>>>>>>>>>//   );
75002>>>>>>>>>>>//
75002>>>>>>>>>>>// lpPathName
75002>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75002>>>>>>>>>>>//  to be created.
75002>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75002>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75002>>>>>>>>>>>// lpSecurityAttributes
75002>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75002>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75002>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75002>>>>>>>>>>>// Returns:
75002>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75002>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75002>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75003>>>>>>>>>>>
75003>>>>>>>>>>>
75003>>>>>>>>>>>// lpPathName
75003>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75003>>>>>>>>>>>//  to be removed.
75003>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75003>>>>>>>>>>>// Returns:
75003>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75003>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75003>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75004>>>>>>>>>>>// executable file or a document file.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Operation can be one of the following:
75004>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75004>>>>>>>>>>>//            The file can be an executable file or a document file.
75004>>>>>>>>>>>//            The file can be a folder to open.
75004>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75004>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75004>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75004>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Return Values:
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75004>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75004>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// The following table lists these error values:
75004>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75004>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75004>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75004>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75004>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75004>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75004>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75004>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75004>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75004>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75004>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75004>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75004>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75004>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75004>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75005>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75005>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75005>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75005>>>>>>>>>>>
75005>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75005>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75005>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75005>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75005>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75005>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75005>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75005>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75005>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75005>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75005>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75005>>>>>>>>>>>
75005>>>>>>>>>>>Struct tvShFileOpStruct
75005>>>>>>>>>>>  Handle   hWnd
75005>>>>>>>>>>>  UInteger wFunc
75005>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
75005>>>>>>>>>>>  Pointer  pFrom
75005>>>>>>>>>>>  Pointer  pTo
75005>>>>>>>>>>>  Short    fFlags
75005>>>>>>>>>>>  Integer  fAnyOperationsAborted
75005>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
75005>>>>>>>>>>>  Pointer  hNameMappings
75005>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75005>>>>>>>>>>>End_Struct // tvShFileOpStruct
75005>>>>>>>>>>>
75005>>>>>>>>>>>// hwnd
75005>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// wFunc
75005>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75005>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75005>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75005>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75005>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// pFrom
75005>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75005>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// pTo
75005>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75005>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75005>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75005>>>>>>>>>>>//   double null-terminated.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// fAnyOperationsAborted
75005>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75005>>>>>>>>>>>//   were completed or FALSE otherwise.
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75005>>>>>>>>>>>// This can be a file or a folder.
75005>>>>>>>>>>>// With thanks to Andrew S Kaplan
75005>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75006>>>>>>>>>>>
75006>>>>>>>>>>>
75006>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75006>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75007>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75007>>>>>>>>>>>//   Pointer lpPathName ;
75007>>>>>>>>>>>//   Pointer lpPrefixString ;
75007>>>>>>>>>>>//   Integer uUnique ;
75007>>>>>>>>>>>//   Pointer lpTempFileName ;
75007>>>>>>>>>>>//   Returns Integer
75007>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75007>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75008>>>>>>>>>>>
75008>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75009>>>>>>>>>>>
75009>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75010>>>>>>>>>>>
75010>>>>>>>>>>>// from:
75010>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75010>>>>>>>>>>>//
75010>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75010>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75010>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75010>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75010>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75010>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75010>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75010>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75010>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75010>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75010>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75010>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75010>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75010>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75010>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75010>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75010>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75010>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75010>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75010>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75010>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75010>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75010>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75010>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75010>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75010>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75010>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75010>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75010>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75010>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75010>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75010>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75010>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75010>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75010>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75010>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75010>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75010>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75010>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75010>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75010>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75010>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75010>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75010>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75010>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75010>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75010>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75010>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75010>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75010>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75010>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75010>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75010>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75010>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75010>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>//HRESULT SHGetFolderPath(
75010>>>>>>>>>>>//    HWND hwndOwner,
75010>>>>>>>>>>>//    int nFolder,
75010>>>>>>>>>>>//    HANDLE hToken,
75010>>>>>>>>>>>//    DWORD dwFlags,
75010>>>>>>>>>>>//    LPTSTR pszPath
75010>>>>>>>>>>>//);
75010>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75010>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75010>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75010>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75010>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75010>>>>>>>>>>>//
75010>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>Struct tvWin32FindData
75011>>>>>>>>>>> Dword            dwFileAttributes
75011>>>>>>>>>>> Dword            ftCreationLowDateTime
75011>>>>>>>>>>> Dword            ftCreationHighDateTime
75011>>>>>>>>>>> dword            ftLastAccessLowDateTime
75011>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75011>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75011>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75011>>>>>>>>>>> Dword            nFileSizeHigh
75011>>>>>>>>>>> Dword            nFileSizeLow
75011>>>>>>>>>>> Dword            dwReserved0
75011>>>>>>>>>>> Dword            dwReserved1
75011>>>>>>>>>>> Short[vMax_Path] cFileName
75011>>>>>>>>>>> Short[14]        cAlternateFileName
75011>>>>>>>>>>>End_Struct
75011>>>>>>>>>>>
75011>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75011>>>>>>>>>>>// lpFileName      : address of name of file to search for
75011>>>>>>>>>>>// lpFindFileData  : address of returned information
75011>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75012>>>>>>>>>>>
75012>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75012>>>>>>>>>>>// hFindFile       : handle of search
75012>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75012>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75013>>>>>>>>>>>
75013>>>>>>>>>>>
75013>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75013>>>>>>>>>>>//  hFindFile      : file search handle
75013>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>Struct tvFileTime
75014>>>>>>>>>>>  DWord dwLowDateTime
75014>>>>>>>>>>>  DWord dwHighDateTime
75014>>>>>>>>>>>End_Struct
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>Struct tvSystemTime
75014>>>>>>>>>>>  UShort wYear
75014>>>>>>>>>>>  UShort wMonth
75014>>>>>>>>>>>  UShort wDayOfWeek
75014>>>>>>>>>>>  UShort wDay
75014>>>>>>>>>>>  UShort wHour
75014>>>>>>>>>>>  UShort wMinute
75014>>>>>>>>>>>  UShort wSecond
75014>>>>>>>>>>>  UShort wMilliSeconds
75014>>>>>>>>>>>End_Struct
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75014>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75014>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75014>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75015>>>>>>>>>>>
75015>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75015>>>>>>>>>>>// This function formats the time in a picture-string passed
75015>>>>>>>>>>>//
75015>>>>>>>>>>>// Picture      Meaning
75015>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75015>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75015>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75015>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75015>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75015>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75015>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75015>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75015>>>>>>>>>>>//    t         One character time marker string, such as A or P
75015>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75015>>>>>>>>>>>//
75015>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75015>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75015>>>>>>>>>>>
75015>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75016>>>>>>>>>>>// This function formats the date in a picture-string passed
75016>>>>>>>>>>>//
75016>>>>>>>>>>>// Picture      Meaning
75016>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75016>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75016>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75016>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75016>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75016>>>>>>>>>>>//              value associated with the specified locale.
75016>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75016>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75016>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75016>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75016>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75016>>>>>>>>>>>//              associated with the specified locale.
75016>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75016>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75016>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75016>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75016>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75016>>>>>>>>>>>//              does not have an associated era or period string.
75016>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75016>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75016>>>>>>>>>>>
75016>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75017>>>>>>>>>>>
75017>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75017>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75017>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75017>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75017>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75017>>>>>>>>>>>
75017>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75017>>>>>>>>>>>//
75017>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75017>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75017>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75017>>>>>>>>>>>
75017>>>>>>>>>>>
75017>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>>// **WvA: 20-02-2004
75018>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75018>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75018>>>>>>>>>>>// incorrectly into an unsigned integer.
75018>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75018>>>>>>>>>>>// It does smell a bit fishy though
75018>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75018>>>>>>>>>>>
75018>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75018>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75018>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75018>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75018>>>>>>>>>>>
75018>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75018>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75018>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75018>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>> // Courtesy Of Steve Walter,
75018>>>>>>>>>>> // USA Software, Inc
75018>>>>>>>>>>> // Format a disk
75018>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75018>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75019>>>>>>>>>>>
75019>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75019>>>>>>>>>>>
75019>>>>>>>>>>>// SHCreateDirectoryEx
75019>>>>>>>>>>>
75019>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75019>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75019>>>>>>>>>>>//
75019>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75019>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75019>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75019>>>>>>>>>>>//
75019>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75019>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75019>>>>>>>>>>>//        ERROR_CANCELLED.
75019>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75019>>>>>>>>>>>
75019>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75019>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75019>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75019>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75019>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75019>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75019>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75019>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75019>>>>>>>>>>>
75019>>>>>>>>>>>//        int SHCreateDirectoryEx(
75019>>>>>>>>>>>//            HWND hwnd,
75019>>>>>>>>>>>//            LPCTSTR pszPath,
75019>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75019>>>>>>>>>>>//        );
75019>>>>>>>>>>>
75019>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75020>>>>>>>>>>>
75020>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75021>>>>>>>>>
75021>>>>>>>>>
75021>>>>>>>>>
75021>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75021>>>>>>>>>// This also works with UNC path encoding and wildcards
75021>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75023>>>>>>>>>    Boolean bFolderExists
75023>>>>>>>>>    Boolean bStop
75023>>>>>>>>>    String  sFolder sTmp
75023>>>>>>>>>    Integer iCh
75023>>>>>>>>>
75023>>>>>>>>>    If (sFolderName = "") Begin
75025>>>>>>>>>        Function_Return False
75026>>>>>>>>>    End
75026>>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>    Move True  to bFolderExists
75027>>>>>>>>>    Move False to bStop
75028>>>>>>>>>    Move "dir:" to sFolder
75029>>>>>>>>>    Append sFolder sFolderName
75030>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75031>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75033>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75034>>>>>>>>>>
75034>>>>>>>>>        Function_Return False
75035>>>>>>>>>    End
75035>>>>>>>>>>
75035>>>>>>>>>    Direct_Input channel iCh sFolder
75037>>>>>>>>>    Repeat
75037>>>>>>>>>>
75037>>>>>>>>>        Readln channel iCh sTmp
75039>>>>>>>>>        Move (SeqEof) to bStop
75040>>>>>>>>>        If (Trim(sTmp)="") Begin
75042>>>>>>>>>            Move False to bFolderExists
75043>>>>>>>>>        End
75043>>>>>>>>>>
75043>>>>>>>>>        Else Begin
75044>>>>>>>>>            Move True to bFolderExists
75045>>>>>>>>>            Move True to bStop
75046>>>>>>>>>        End
75046>>>>>>>>>>
75046>>>>>>>>>    Until (bStop)
75048>>>>>>>>>    Close_Input channel iCh
75050>>>>>>>>>    Send Seq_Release_Channel iCh
75051>>>>>>>>>    Function_Return bFolderExists
75052>>>>>>>>>End_Function
75053>>>>>>>>>
75053>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75053>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75055>>>>>>>>>    String  sPath
75055>>>>>>>>>    WString sFolder sTitle
75055>>>>>>>>>    Pointer lpItemIdList
75055>>>>>>>>>    Integer iFolderSelected iRetval
75055>>>>>>>>>    tvBrowseInfo BrowseInfo
75055>>>>>>>>>    tvBrowseInfo BrowseInfo
75055>>>>>>>>>
75055>>>>>>>>>    Move "" to sPath
75056>>>>>>>>>    If (sDialogTitle<>"") Begin
75058>>>>>>>>>        Move sDialogTitle to sTitle
75059>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75059>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75059>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75059>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75059>>>>>>>>>        // selected it will always be valid.
75059>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75060>>>>>>>>>    End
75060>>>>>>>>>>
75060>>>>>>>>>
75060>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75061>>>>>>>>>
75061>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75061>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75061>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75062>>>>>>>>>
75062>>>>>>>>>    // null 128 chars into var (make space)
75062>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75063>>>>>>>>>
75063>>>>>>>>>    // select folder
75063>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75064>>>>>>>>>    // get selected folder name
75064>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75065>>>>>>>>>
75065>>>>>>>>>    // release memory resources that are used by the ItemIdList
75065>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75066>>>>>>>>>
75066>>>>>>>>>    If (iFolderSelected<>0) Begin
75068>>>>>>>>>        Move (CString(sFolder)) to sPath
75069>>>>>>>>>    End
75069>>>>>>>>>>
75069>>>>>>>>>    Function_Return  sPath
75070>>>>>>>>>End_Function
75071>>>>>>>>>
75071>>>>>>>>>// returns 0 if the folder is created.
75071>>>>>>>>>//         1 if the API-call returned an error.
75071>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75073>>>>>>>>>    Integer  iRetval bFolderCreated
75073>>>>>>>>>    WString  sFolder
75073>>>>>>>>>    tvSecurity_attributes SA
75073>>>>>>>>>    tvSecurity_attributes SA
75073>>>>>>>>>
75073>>>>>>>>>    Move False to bFolderCreated
75074>>>>>>>>>    If (sNewFolder <> "") Begin
75076>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75077>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75078>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75079>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75080>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75081>>>>>>>>>    End
75081>>>>>>>>>>
75081>>>>>>>>>
75081>>>>>>>>>    If (bFolderCreated=false) Begin
75083>>>>>>>>>        Move 1 to iRetVal
75084>>>>>>>>>    End
75084>>>>>>>>>>
75084>>>>>>>>>    Function_Return iRetVal
75085>>>>>>>>>End_Function
75086>>>>>>>>>
75086>>>>>>>>>// **WvA: 03-02-2002 Function created.
75086>>>>>>>>>// With this function one can remove a directory.
75086>>>>>>>>>// returns 0 if the folder is removed.
75086>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75086>>>>>>>>>//         2 if the folder did not exist
75086>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75086>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75088>>>>>>>>>    Boolean bRemoved
75088>>>>>>>>>    WString sPath
75088>>>>>>>>>    Integer iRetval
75088>>>>>>>>>
75088>>>>>>>>>    Move 0     to iRetVal
75089>>>>>>>>>    Move False to bRemoved
75090>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75091>>>>>>>>>    If (sFolder="") Begin
75093>>>>>>>>>        Move 3 to iRetVal
75094>>>>>>>>>    End
75094>>>>>>>>>>
75094>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75096>>>>>>>>>        Move 2 to iRetVal
75097>>>>>>>>>    End
75097>>>>>>>>>>
75097>>>>>>>>>    If (iRetVal=0) Begin
75099>>>>>>>>>        // null MAX_PATH chars into var (make space)
75099>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75100>>>>>>>>>        //
75100>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75101>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75102>>>>>>>>>    End
75102>>>>>>>>>>
75102>>>>>>>>>
75102>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75104>>>>>>>>>        Move 1 to iRetVal
75105>>>>>>>>>    End
75105>>>>>>>>>>
75105>>>>>>>>>    Function_Return iRetVal
75106>>>>>>>>>End_Function
75107>>>>>>>>>
75107>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75107>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75107>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75107>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75109>>>>>>>>>    Handle  hInstance hWnd
75109>>>>>>>>>    // remove any leading/trailing spaces in the string
75109>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75110>>>>>>>>>    Move (Trim(sPath))     to sPath
75111>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75111>>>>>>>>>    Append sOperation   (Character(0))
75112>>>>>>>>>    Append sDocument    (Character(0))
75113>>>>>>>>>    Append sParameters  (Character(0))
75114>>>>>>>>>    Append sPath        (Character(0))
75115>>>>>>>>>
75115>>>>>>>>>    Get Window_Handle to hWnd
75116>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75117>>>>>>>>>    If (hInstance <= 32) Begin
75119>>>>>>>>>        Send vDDE_Error_Handler hInstance
75120>>>>>>>>>    End
75120>>>>>>>>>>
75120>>>>>>>>>End_Procedure
75121>>>>>>>>>
75121>>>>>>>>>Class cShellFileOperations is a Array
75122>>>>>>>>>
75122>>>>>>>>>    Procedure Construct_Object
75124>>>>>>>>>        Forward Send Construct_Object
75126>>>>>>>>>        Property Integer piDeleteFlags        0
75127>>>>>>>>>        Property Integer piCopyFlags          0
75128>>>>>>>>>        Property Integer piMoveFlags          0
75129>>>>>>>>>        Property Integer piRenameFlags        0
75130>>>>>>>>>
75130>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75131>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75132>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75133>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75134>>>>>>>>>    End_Procedure
75135>>>>>>>>>
75135>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75135>>>>>>>>>    // files supplied.
75135>>>>>>>>>    //
75135>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75137>>>>>>>>>        Integer  iRetVal
75137>>>>>>>>>        Integer  iUserAbort
75137>>>>>>>>>        WString  wsSource wsDestination
75137>>>>>>>>>        tvShFileOpStruct FOS
75137>>>>>>>>>        tvShFileOpStruct FOS
75137>>>>>>>>>
75137>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75138>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75139>>>>>>>>>
75139>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75141>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75142>>>>>>>>>        End
75142>>>>>>>>>>
75142>>>>>>>>>
75142>>>>>>>>>        Move eOperation            to FOS.wFunc
75143>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75144>>>>>>>>>        Move iFlags                to FOS.fFlags
75145>>>>>>>>>
75145>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75146>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75147>>>>>>>>>        If (iUserAbort <> 0) Begin
75149>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75150>>>>>>>>>        End
75150>>>>>>>>>>
75150>>>>>>>>>        Function_Return (iRetVal)
75151>>>>>>>>>    End_Function
75152>>>>>>>>>
75152>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75154>>>>>>>>>        Integer  iRetVal
75154>>>>>>>>>        Integer  iFlags
75154>>>>>>>>>
75154>>>>>>>>>        Get piDeleteFlags to iFlags
75155>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75156>>>>>>>>>        Function_Return iRetVal
75157>>>>>>>>>    End_Function
75158>>>>>>>>>
75158>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75160>>>>>>>>>        Integer  iRetVal
75160>>>>>>>>>        Integer  iFlags
75160>>>>>>>>>
75160>>>>>>>>>        Get piCopyFlags to iFlags
75161>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75162>>>>>>>>>        Function_Return iRetVal
75163>>>>>>>>>    End_Function
75164>>>>>>>>>
75164>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75166>>>>>>>>>        Integer  iRetVal
75166>>>>>>>>>        Integer  iFlags
75166>>>>>>>>>
75166>>>>>>>>>        Get piMoveFlags to iFlags
75167>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75168>>>>>>>>>        Function_Return iRetVal
75169>>>>>>>>>    End_Function
75170>>>>>>>>>
75170>>>>>>>>>    // Rename a file or folder
75170>>>>>>>>>    // Returns a nonzero value if the operation failed.
75170>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75172>>>>>>>>>        Integer  iRetVal
75172>>>>>>>>>        Integer  iFlags
75172>>>>>>>>>
75172>>>>>>>>>        Get piRenameFlags to iFlags
75173>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75174>>>>>>>>>        Function_Return iRetVal
75175>>>>>>>>>    End_Function
75176>>>>>>>>>
75176>>>>>>>>>
75176>>>>>>>>>    //Example:
75176>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75176>>>>>>>>>    //                                          mode.
75176>>>>>>>>>
75176>>>>>>>>>End_Class
75177>>>>>>>>>
75177>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75179>>>>>>>>>End_Object
75180>>>>>>>>>
75180>>>>>>>>>// Restore to the old way of working with the shell file operations.
75180>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75180>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75180>>>>>>>>>Procedure vWin32fhCompatibilityMode
75182>>>>>>>>>    Integer hoSFO
75182>>>>>>>>>    Integer iFlags
75182>>>>>>>>>
75182>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75183>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75184>>>>>>>>>
75184>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75185>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75186>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75187>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75188>>>>>>>>>End_Procedure
75189>>>>>>>>>
75189>>>>>>>>>// Delete a file or folder
75189>>>>>>>>>// Returns a nonzero value if the operation failed.
75189>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75191>>>>>>>>>    Integer  iRetVal
75191>>>>>>>>>
75191>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75192>>>>>>>>>    Function_Return iRetVal
75193>>>>>>>>>End_Function
75194>>>>>>>>>
75194>>>>>>>>>// Copy a file or folder
75194>>>>>>>>>// Returns a nonzero value if the operation failed.
75194>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75196>>>>>>>>>    Integer  iRetVal
75196>>>>>>>>>
75196>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75197>>>>>>>>>    Function_Return iRetVal
75198>>>>>>>>>End_Function
75199>>>>>>>>>
75199>>>>>>>>>// Move a file or folder
75199>>>>>>>>>// Returns a nonzero value if the operation failed.
75199>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75201>>>>>>>>>    Integer  iRetVal
75201>>>>>>>>>
75201>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75202>>>>>>>>>    Function_Return iRetVal
75203>>>>>>>>>End_Function
75204>>>>>>>>>
75204>>>>>>>>>// Rename a file or folder
75204>>>>>>>>>// Returns a nonzero value if the operation failed.
75204>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75206>>>>>>>>>    Integer  iRetVal
75206>>>>>>>>>
75206>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75207>>>>>>>>>    Function_Return iRetVal
75208>>>>>>>>>End_Function
75209>>>>>>>>>
75209>>>>>>>>>Function vGetWindowsDirectory Returns String
75211>>>>>>>>>    WString wDirectory
75211>>>>>>>>>    Integer iRetVal
75211>>>>>>>>>
75211>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75212>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75213>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75215>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75216>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75217>>>>>>>>>    End
75217>>>>>>>>>>
75217>>>>>>>>>    Function_Return (CString(wDirectory))
75218>>>>>>>>>End_Function
75219>>>>>>>>>
75219>>>>>>>>>Function vGetTempPath Returns String
75221>>>>>>>>>    Integer iRetVal
75221>>>>>>>>>    WString wTempPath
75221>>>>>>>>>
75221>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75222>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75223>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75225>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75226>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75227>>>>>>>>>    End
75227>>>>>>>>>>
75227>>>>>>>>>    Function_Return (CString(wTempPath))
75228>>>>>>>>>End_Function
75229>>>>>>>>>
75229>>>>>>>>>// Courtesy of Marco Kuipers
75229>>>>>>>>>Function vMakeTempFile Returns String
75231>>>>>>>>>    Integer iRetval
75231>>>>>>>>>    String  sTempPath
75231>>>>>>>>>    String  sTempFileName
75231>>>>>>>>>    String  sPrefixString
75231>>>>>>>>>    WString wsTempFileName
75231>>>>>>>>>
75231>>>>>>>>>    Get vGetTempPath to sTempPath
75232>>>>>>>>>    If (sTempPath = "") Begin
75234>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75235>>>>>>>>>        If (sTempPath<>"") Begin
75237>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75238>>>>>>>>>        End
75238>>>>>>>>>>
75238>>>>>>>>>    End
75238>>>>>>>>>>
75238>>>>>>>>>
75238>>>>>>>>>    If (sTempPath = "") Begin
75240>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75240>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75240>>>>>>>>>        Get_Current_Directory to sTempPath
75241>>>>>>>>>    End
75241>>>>>>>>>>
75241>>>>>>>>>
75241>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75242>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75244>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75245>>>>>>>>>>
75245>>>>>>>>>    End
75245>>>>>>>>>>
75245>>>>>>>>>
75245>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75246>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75247>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75248>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75250>>>>>>>>>    //Get ShowLastError to iRetval
75250>>>>>>>>>        Move "" to sTempFileName
75251>>>>>>>>>    End
75251>>>>>>>>>>
75251>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75252>>>>>>>>>    Function_Return sTempFileName
75253>>>>>>>>>End_Function
75254>>>>>>>>>
75254>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75254>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75254>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75254>>>>>>>>>// does not take care of that.
75254>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75256>>>>>>>>>    Integer iRetVal
75256>>>>>>>>>    String  sTempFileName
75256>>>>>>>>>    WString wTempFileName
75256>>>>>>>>>
75256>>>>>>>>>    Move (sPath+Character(0))   to sPath
75257>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75258>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75259>>>>>>>>>
75259>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75260>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75261>>>>>>>>>    Function_Return sTempFileName
75262>>>>>>>>>End_Function
75263>>>>>>>>>
75263>>>>>>>>>//
75263>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75263>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75263>>>>>>>>>//
75263>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75265>>>>>>>>>    Integer iVoid
75265>>>>>>>>>    Handle  hWnd
75265>>>>>>>>>    String  sFolder
75265>>>>>>>>>    WString wFolder
75265>>>>>>>>>
75265>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75266>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75267>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75268>>>>>>>>>    Move (CString(wFolder)) to sFolder
75269>>>>>>>>>    Function_Return sFolder
75270>>>>>>>>>End_Function
75271>>>>>>>>>
75271>>>>>>>>>// Courtesy Of Vincent Oorsprong
75271>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75273>>>>>>>>>    String  sFileDateTime
75273>>>>>>>>>    WString wFormattedTime wFormattedDate
75273>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75273>>>>>>>>>    tvFileTime   FileTime
75273>>>>>>>>>    tvFileTime   FileTime
75273>>>>>>>>>    tvSystemTime SystemTime
75273>>>>>>>>>    tvSystemTime SystemTime
75273>>>>>>>>>
75273>>>>>>>>>    Move "" to sFileDateTime
75274>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75275>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75276>>>>>>>>>
75276>>>>>>>>>    Move 0 to SystemTime.wYear
75277>>>>>>>>>
75277>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75278>>>>>>>>>    If (iSuccess = 1) Begin
75280>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75281>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75282>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75283>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75284>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75285>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75286>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75287>>>>>>>>>    End
75287>>>>>>>>>>
75287>>>>>>>>>    Function_Return sFileDateTime
75288>>>>>>>>>End_Function
75289>>>>>>>>>
75289>>>>>>>>>// **WvA:
75289>>>>>>>>>// A windows replacement for the standard function FileExists.
75289>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75289>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75289>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75289>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75289>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75291>>>>>>>>>    String  sDirSep
75291>>>>>>>>>    Handle  hFindFile
75291>>>>>>>>>    Integer iVoid
75291>>>>>>>>>    tvWin32FindData FindData
75291>>>>>>>>>    tvWin32FindData FindData
75291>>>>>>>>>
75291>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75292>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75293>>>>>>>>>
75293>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75295>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75295>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75296>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75300>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75301>>>>>>>>>        Loop
75302>>>>>>>>>>
75302>>>>>>>>>
75302>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75303>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75304>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75305>>>>>>>>>    End
75305>>>>>>>>>>
75305>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75306>>>>>>>>>End_Function
75307>>>>>>>>>
75307>>>>>>>>>
75307>>>>>>>>>//
75307>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75307>>>>>>>>>// Returns -1 if folder doesn't exist.
75307>>>>>>>>>// The files "." and ".." are not counted.
75307>>>>>>>>>//
75307>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75309>>>>>>>>>    Boolean bFound
75309>>>>>>>>>    Handle  hFindFile
75309>>>>>>>>>    Integer iCount  iVoid
75309>>>>>>>>>    Integer iSuccess
75309>>>>>>>>>    String  sFileName
75309>>>>>>>>>    tvWin32FindData FindData
75309>>>>>>>>>    tvWin32FindData FindData
75309>>>>>>>>>
75309>>>>>>>>>    Move -1 to iCount
75310>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75311>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75312>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75313>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75314>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75315>>>>>>>>>    If (bFound) Begin
75317>>>>>>>>>        Move 0 to iCount
75318>>>>>>>>>    End
75318>>>>>>>>>>
75318>>>>>>>>>    While (bFound)
75322>>>>>>>>>        Increment iCount
75323>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75324>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75326>>>>>>>>>            Decrement iCount
75327>>>>>>>>>        End
75327>>>>>>>>>>
75327>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75328>>>>>>>>>        Move (iSuccess<>0) to bFound
75329>>>>>>>>>    Loop
75330>>>>>>>>>>
75330>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75331>>>>>>>>>    Function_Return iCount
75332>>>>>>>>>End_Function
75333>>>>>>>>>
75333>>>>>>>>>// Create the folder, including intermediate directories.
75333>>>>>>>>>// Don't panic if the folder already exists.
75333>>>>>>>>>// Michael Mullan June 2009.
75333>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75335>>>>>>>>>    String  sFolder
75335>>>>>>>>>    Integer iRetval iFolderCreated
75335>>>>>>>>>    tvSecurity_attributes SA
75335>>>>>>>>>    tvSecurity_attributes SA
75335>>>>>>>>>
75335>>>>>>>>>    Move 0 to iFolderCreated
75336>>>>>>>>>
75336>>>>>>>>>    // null MAX_PATH chars into var (make space)
75336>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75337>>>>>>>>>    If (sNewFolder <> "") Begin
75339>>>>>>>>>
75339>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75340>>>>>>>>>        Move  0  to SA.lpDescriptor
75341>>>>>>>>>        Move  1  to SA.bInheritHandle
75342>>>>>>>>>
75342>>>>>>>>>        //
75342>>>>>>>>>        Move (sNewFolder+"") to sFolder
75343>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75344>>>>>>>>>    End
75344>>>>>>>>>>
75344>>>>>>>>>
75344>>>>>>>>>    If (iFolderCreated <> 0) Begin
75346>>>>>>>>>        Move 1 to iRetVal
75347>>>>>>>>>        Case Begin
75347>>>>>>>>>            Case (iFolderCreated = 161)
75349>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75350>>>>>>>>>>
75350>>>>>>>>>                Case Break
75351>>>>>>>>>            Case (iFolderCreated = 206)
75354>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75355>>>>>>>>>>
75355>>>>>>>>>                Case Break
75356>>>>>>>>>            Case (iFolderCreated = 3)
75359>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75360>>>>>>>>>>
75360>>>>>>>>>                Case Break
75361>>>>>>>>>            Case (iFolderCreated = 80)
75364>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75365>>>>>>>>>                Case Break
75366>>>>>>>>>            Case (iFolderCreated = 183)
75369>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75370>>>>>>>>>                Case Break
75371>>>>>>>>>            Case (iFolderCreated = 1223)
75374>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75375>>>>>>>>>>
75375>>>>>>>>>                Case Break
75376>>>>>>>>>            Case Else
75376>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75377>>>>>>>>>>
75377>>>>>>>>>        Case End
75377>>>>>>>>>    End
75377>>>>>>>>>>
75377>>>>>>>>>    Function_Return iRetVal
75378>>>>>>>>>End_Function
75379>>>>>>>>>
75379>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75381>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75381>>>>>>>>>    Integer iFileSize iVoid
75381>>>>>>>>>    Handle  hFindFile
75381>>>>>>>>>    tvWin32FindData FindData
75381>>>>>>>>>    tvWin32FindData FindData
75381>>>>>>>>>
75381>>>>>>>>>    Move (sFileName+"") to sFileName
75382>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75383>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75384>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75386>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75387>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75388>>>>>>>>>    End
75388>>>>>>>>>>
75388>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75389>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75390>>>>>>>>>
75390>>>>>>>>>    Function_Return iFileSize
75391>>>>>>>>>End_Function
75392>>>>>>>>>
75392>>>>>>>>>//
75392>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75392>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75392>>>>>>>>>//
75392>>>>>>>>>//=============================================================================
75392>>>>>>>>>// Verifies that a path is a valid directory.
75392>>>>>>>>>//
75392>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75392>>>>>>>>>//
75392>>>>>>>>>// Parameters:
75392>>>>>>>>>//      sPath - Address of the path to verify.
75392>>>>>>>>>//=============================================================================
75392>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75394>>>>>>>>>    Integer iResult
75394>>>>>>>>>    Boolean bRetVal
75394>>>>>>>>>
75394>>>>>>>>>    Move false to bRetVal
75395>>>>>>>>>    Move (sPath - Character (0)) to sPath
75396>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75397>>>>>>>>>    If (iResult<>0) Begin
75399>>>>>>>>>        Move True to bRetVal
75400>>>>>>>>>    End
75400>>>>>>>>>>
75400>>>>>>>>>
75400>>>>>>>>>    Function_Return bRetVal
75401>>>>>>>>>End_Function
75402>>>>>>>>>
75402>>>>>>>
75402>>>>>>>//
75402>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75402>>>>>>>// If sStopChar has no occurences in the string an empty string is
75402>>>>>>>// returned.
75402>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75404>>>>>>>    String  sRetVal
75404>>>>>>>    String  sChar
75404>>>>>>>    Integer iLength
75404>>>>>>>    Integer iPos
75404>>>>>>>    Boolean bStopChar
75404>>>>>>>    Move "" to sRetval
75405>>>>>>>    Move (Length(sFrom)) to iLength
75406>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75408>>>>>>>        Move iLength   to iPos
75409>>>>>>>        Move (False)   to bStopChar
75410>>>>>>>        While Not bStopChar
75414>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75415>>>>>>>            Decrement iPos
75416>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75418>>>>>>>                Move (True) to bStopChar
75419>>>>>>>            End
75419>>>>>>>>
75419>>>>>>>            Else Begin
75420>>>>>>>                Move (sChar+sRetVal) to sRetVal
75421>>>>>>>            End
75421>>>>>>>>
75421>>>>>>>        Loop
75422>>>>>>>>
75422>>>>>>>    End
75422>>>>>>>>
75422>>>>>>>    Function_Return sRetVal
75423>>>>>>>End_Function
75424>>>>>>>
75424>>>>>>>// Pre:  sFileName contains the complete path of the file.
75424>>>>>>>// Post: returns the complete path of the file.
75424>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75424>>>>>>>Function ParseFolderName Global String sFileName Returns String
75426>>>>>>>    String sFile
75426>>>>>>>    String sFolderName
75426>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75426>>>>>>>
75426>>>>>>>    Move "" to sFolderName
75427>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75428>>>>>>>    If sDirSep In sFileName Begin
75430>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75431>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75432>>>>>>>    End
75432>>>>>>>>
75432>>>>>>>    Else If ":" In sFileName Begin
75435>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75436>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75437>>>>>>>    End
75437>>>>>>>>
75437>>>>>>>    Function_Return sFolderName
75438>>>>>>>End_Function
75439>>>>>>>
75439>>>>>>>// Pre:  sFileName contains the complete path of the file.
75439>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75439>>>>>>>Function ParseFileName Global String sFileName Returns String
75441>>>>>>>    String sFolderName
75441>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75441>>>>>>>
75441>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75442>>>>>>>    Get ParseFolderName sFileName to sFolderName
75443>>>>>>>    If (sFolderName <> "") Begin
75445>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75446>>>>>>>    End
75446>>>>>>>>
75446>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75447>>>>>>>    Function_Return sFilename
75448>>>>>>>End_Function
75449>>>>>>>
75449>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75449>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75449>>>>>>>//       return "bak" as the extension and not "gif"
75449>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75449>>>>>>>//       such as "html" or "java"
75449>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75451>>>>>>>    String  sFileExtension
75451>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75452>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75453>>>>>>>    Function_Return sFileExtension
75454>>>>>>>End_Function
75455>>>>>>>
75455>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75455>>>>>>>
75455>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75457>>>>>>>    String sMessage
75457>>>>>>>    Case Begin
75457>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75459>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75460>>>>>>>            Case Break
75461>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75464>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75465>>>>>>>            Case Break
75466>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75469>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75470>>>>>>>            Case Break
75471>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75474>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75475>>>>>>>            Case Break
75476>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75479>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75480>>>>>>>            Case Break
75481>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75484>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75485>>>>>>>            Case Break
75486>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75489>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75490>>>>>>>            Case Break
75491>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75494>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75495>>>>>>>            Case Break
75496>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75499>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75500>>>>>>>            Case Break
75501>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75504>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75505>>>>>>>            Case Break
75506>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75509>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75510>>>>>>>            Case Break
75511>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75514>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75515>>>>>>>            Case Break
75516>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75519>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75520>>>>>>>            Case Break
75521>>>>>>>        Case Else
75521>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75522>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75523>>>>>>>            Case Break
75524>>>>>>>    Case End
75524>>>>>>>    Function_Return sMessage
75525>>>>>>>End_Function
75526>>>>>>>
75526>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75528>>>>>>>    String sMessage
75528>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75529>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75530>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75531>>>>>>>End_Procedure
75532>>>>>>>
75532>>>>>>>
75532>>>>>>>// This function informs the user that he entered a yet unknown folder and
75532>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75532>>>>>>>// Choice: "Yes" - this creates the folder
75532>>>>>>>//                 if successful, the function returns false
75532>>>>>>>//                 else it will be true.
75532>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75532>>>>>>>//                 For example: to stop a save
75532>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75532>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75532>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75534>>>>>>>    Integer bIsNotValid
75534>>>>>>>    Integer iUsers_Choice
75534>>>>>>>    String  sMessage
75534>>>>>>>
75534>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75536>>>>>>>        Move "The folder '" to sMessage
75537>>>>>>>        Append sMessage sFolderName
75538>>>>>>>        Append sMessage "' does not yet exist,\n"
75539>>>>>>>        Append sMessage "Do you want to create it now?"
75540>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75541>>>>>>>        Case Begin
75541>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75543>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75544>>>>>>>                If bIsNotValid Begin
75546>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75547>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75549>>>>>>>                    Send Info_Box sMessage "Info"
75550>>>>>>>                End
75550>>>>>>>>
75550>>>>>>>                Case Break
75551>>>>>>>            Case (iUsers_Choice = MBR_No)
75554>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75555>>>>>>>                Case Break
75556>>>>>>>        Case End
75556>>>>>>>    End
75556>>>>>>>>
75556>>>>>>>    Function_Return bIsNotValid
75557>>>>>>>End_Function
75558>>>>>>>
75558>>>>>>>// **WvA
75558>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75558>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75558>>>>>>>// The folder may contain a drive letter or UNC encoding.
75558>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75560>>>>>>>    String sDirSep
75560>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75561>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75562>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75564>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75565>>>>>>>    End
75565>>>>>>>>
75565>>>>>>>    Function_Return sFolderName
75566>>>>>>>End_Function
75567>>>>>>>
75567>>>>>>>//
75567>>>>>>>// Gets the parent path of the currently supplied path
75567>>>>>>>// Returns "" when we are at the root folder.
75567>>>>>>>//
75567>>>>>>>Function vParentPath Global String sPath Returns String
75569>>>>>>>    String sStrip sDirSep
75569>>>>>>>
75569>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75570>>>>>>>    Move (Trim(sPath)) to sPath
75571>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75573>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75574>>>>>>>    End
75574>>>>>>>>
75574>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75576>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75577>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75578>>>>>>>    End
75578>>>>>>>>
75578>>>>>>>    Else Begin
75579>>>>>>>        Move "" to sPath
75580>>>>>>>    End
75580>>>>>>>>
75580>>>>>>>    Function_Return sPath
75581>>>>>>>End_Function
75582>>>>>Use DUFLanguageConstants.inc
75582>>>>>
75582>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75582>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75582>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75582>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75582>>>>>
75582>>>>>Struct tDUFIntFile
75582>>>>>    Integer iID
75582>>>>>    String sIntFileName
75582>>>>>    String sIntLineText
75582>>>>>End_Struct
75582>>>>>
75582>>>>>Struct tDbVersionInfo
75582>>>>>    Number nVersionNumber
75582>>>>>    Handle hObject
75582>>>>>End_Struct
75582>>>>>
75582>>>>>Struct tDbUpdateError
75582>>>>>    Number nUpdateVersion
75582>>>>>    Integer iError
75582>>>>>    String  sOrgErrorText
75582>>>>>    String  sErrorText
75582>>>>>    Integer iErrorLine
75582>>>>>    Boolean bError  
75582>>>>>    Handle  hTable 
75582>>>>>    String  sTableRootName
75582>>>>>    Integer iField
75582>>>>>    Boolean bShortFormat
75582>>>>>End_Struct
75582>>>>>
75582>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75582>>>>>//  DF_FILE_IS_MASTER if master
75582>>>>>//  DF_FILE_IS_ALIAS if alias
75582>>>>>Struct tDbUpdateHandlerMasterAlias
75582>>>>>    Handle hTable
75582>>>>>    Integer iMode
75582>>>>>End_Struct
75582>>>>>
75582>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75582>>>>>Enumeration_List
75582>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75582>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75582>>>>>End_Enumeration_List
75582>>>>>
75582>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75582>>>>>
75582>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75582>>>>>// communicate with the object from anywhere in a program.
75582>>>>>    Global_Variable Handle ghoDbUpdateHandler
75582>>>>>    Move 0 to ghoDbUpdateHandler
75583>>>>>
75583>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75583>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75583>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75583>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75583>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75583>>>>>//    Declare_Datafile DbVersion
75583>>>>>//#ENDIF
75583>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75583>>>>>//****************************************************************************
75583>>>>>// $Module type: Class
75583>>>>>// $Module name: cDbUpdateLogFile
75583>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75583>>>>>// Web-site    : http://www.rdctools.com
75583>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75583>>>>>//
75583>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75583>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75583>>>>>//               that this class is to change; each developer can decide if the errors instead
75583>>>>>//               should be saved to a database table, or something entirely different.
75583>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75583>>>>>//
75583>>>>>// $Rev History:
75583>>>>>//    2016-10-05  Module header created
75583>>>>>//****************************************************************************
75583>>>>>Use UI
75583>>>>>Use vWin32fh.pkg
75583>>>>>
75583>>>>>
75583>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75583>>>>>
75583>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75583>>>>>
75583>>>>>Class cDbUpdateLogFile is a cObject
75584>>>>>
75584>>>>>    Procedure Construct_Object
75586>>>>>        Forward Send Construct_Object
75588>>>>>
75588>>>>>        // Error handling:
75588>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75589>>>>>        Property Integer piChannel -1
75590>>>>>
75590>>>>>        // This property is set by the cDbUpdateHandler object,
75590>>>>>        // when the update process starts.
75590>>>>>        Property DateTime pdtUpdateStart
75591>>>>>
75591>>>>>        // Gets set to False if the log contains data
75591>>>>>        Property Boolean pbEmptyLogFile True
75592>>>>>
75592>>>>>        // Gets set to True after the error log header text
75592>>>>>        // has been written.
75592>>>>>        Property Boolean pbHeaderWritten False
75593>>>>>
75593>>>>>        // If all activities should be logged- not just errors.
75593>>>>>        Property Boolean pbVerboseState False
75594>>>>>
75594>>>>>        // File name for the error log where all errors
75594>>>>>        // after a run is written to (appended).
75594>>>>>        // It is saved in the Data folder.
75594>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75595>>>>>        // If this property is set to "" in object code, the
75595>>>>>        // "shell" command parameter will be used to let Windows decide
75595>>>>>        // with which program to open the logfile.
75595>>>>>        Property String psEditorProgram ""
75596>>>>>
75596>>>>>        Property Boolean pbUseDataTableLog False
75597>>>>>
75597>>>>>        // If true an error will be written to file immediately when
75597>>>>>        // it occurs. This can be handy if a large update generates a lots
75597>>>>>        // of errors and the application crasches before finished, thus
75597>>>>>        // the errors will not be written.
75597>>>>>        Property Boolean pbQuickWrite True
75598>>>>>    End_Procedure
75599>>>>>
75599>>>>>    Procedure End_Construct_Object
75601>>>>>        Forward Send End_Construct_Object
75603>>>>>
75603>>>>>    End_Procedure
75604>>>>>
75604>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75606>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75606>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75608>>>>>        Boolean bShortFormat
75608>>>>>        Integer iSize
75608>>>>>        Handle hCurrentTable
75608>>>>>        Integer iCurrentField           
75608>>>>>        String sOrgErrorText sTableRootName
75608>>>>>        
75608>>>>>        Move False to bShortFormat
75609>>>>>        If (num_arguments > 5) Begin
75611>>>>>            Move bShortFormatIn to bShortFormat
75612>>>>>        End
75612>>>>>>
75612>>>>>        // Only do once.
75612>>>>>        If (pbHeaderWritten(Self) = False) Begin
75614>>>>>            Send WriteHeaderData
75615>>>>>            Set pbHeaderWritten to True
75616>>>>>        End
75616>>>>>>
75616>>>>>
75616>>>>>        Get Private.phCurrentTable to hCurrentTable  
75617>>>>>        Get Private.piCurrentField to iCurrentField  
75618>>>>>        If (iError > 0) Begin
75620>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75623>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75624>>>>>        End
75624>>>>>>
75624>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75625>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75626>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75627>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75628>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75629>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75630>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75631>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75632>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75633>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75634>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75635>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75636>>>>>
75636>>>>>        If (bError = False) Begin
75638>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75639>>>>>        End
75639>>>>>>
75639>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75640>>>>>
75640>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75642>>>>>            If (pbQuickWrite(Self) = True) Begin
75644>>>>>                Send OnWriteRow_DataTable
75645>>>>>                // If we are writing error for error flush the
75645>>>>>                // error array when latest error has been written.
75645>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75646>>>>>            End
75646>>>>>>
75646>>>>>            Procedure_Return
75647>>>>>        End
75647>>>>>>
75647>>>>>        Else Begin
75648>>>>>            If (pbQuickWrite(Self) = True) Begin
75650>>>>>                Send WriteErrorLog
75651>>>>>                // Flush the error log array
75651>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty 
75652>>>>>            End
75652>>>>>>
75652>>>>>        End
75652>>>>>>
75652>>>>>    End_Procedure   
75653>>>>>    
75653>>>>>    Function FetchErrorDescription Integer iError Returns String
75655>>>>>        String sErrorText         
75655>>>>>        Move "" to sErrorText
75656>>>>>        If (iError > 0) Begin
75658>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75659>>>>>        End
75659>>>>>>
75659>>>>>        Function_Return sErrorText
75660>>>>>    End_Function
75661>>>>>
75661>>>>>    // Hook procedure for writing header text prior starting the update work to
75661>>>>>    // a database table. This does nothing by default.
75661>>>>>    // Don't forget to Open your "error log table" first (!) as all
75661>>>>>    // tables have been closed at this stage. Put anything
75661>>>>>    // you want to indicate that the update process is just started.
75661>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75663>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75665>>>>>    End_Procedure
75666>>>>>
75666>>>>>    Procedure OnWriteRow_DataTable
75668>>>>>        tDbUpdateError[] DbUpdateErrorArray
75668>>>>>        tDbUpdateError[] DbUpdateErrorArray
75669>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75670>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75672>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75674>>>>>        End
75674>>>>>>
75674>>>>>    End_Procedure
75675>>>>>
75675>>>>>    Function psLogTextFileWithPath Returns String
75677>>>>>        String sPath sFileName sFullFileName
75677>>>>>        
75677>>>>>        Get psDataPathFirstPart to sPath
75678>>>>>        Get psLogTextFile to sFileName
75679>>>>>        Move (sPath + sFileName) to sFullFileName
75680>>>>>        Function_Return sFullFileName
75681>>>>>    End_Function                     
75682>>>>>    
75682>>>>>    Procedure WriteHeaderData
75684>>>>>        String sFileName
75684>>>>>        Integer iCh iSize
75684>>>>>        Boolean bQuickWrite
75684>>>>>        DateTime dtUpdateStart
75684>>>>>
75684>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75685>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75687>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75688>>>>>            Procedure_Return
75689>>>>>        End
75689>>>>>>
75689>>>>>
75689>>>>>        Get piChannel to iCh
75690>>>>>        If (iCh < 0) Begin
75692>>>>>            Get Seq_New_Channel to iCh
75693>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75695>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75696>>>>>>
75696>>>>>                Procedure_Return
75697>>>>>            End
75697>>>>>>
75697>>>>>            Set piChannel to iCh
75698>>>>>        End
75698>>>>>>
75698>>>>>
75698>>>>>        Get psLogTextFileWithPath to sFileName
75699>>>>>        Get vWin32_APIFileSize sFileName to iSize
75700>>>>>        Get pbQuickWrite to bQuickWrite
75701>>>>>        
75701>>>>>        If (bQuickWrite = True) Begin
75703>>>>>            Append_Output channel iCh sFileName
75705>>>>>                If (bQuickWrite = True) Begin
75707>>>>>                    If (iSize = 0) Begin
75709>>>>>                        Write channel iCh C_BOM_UTF8
75711>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75714>>>>>                        Set pbEmptyLogFile to False
75715>>>>>                    End
75715>>>>>>
75715>>>>>                    Writeln channel iCh
75717>>>>>                    Writeln channel iCh ("*** Database Update Started:      " + String(dtUpdateStart))
75720>>>>>                End
75720>>>>>>
75720>>>>>            Close_Output channel iCh
75722>>>>>        End
75722>>>>>>
75722>>>>>    End_Procedure
75723>>>>>
75723>>>>>    // Returns the first datapath found in the psDataPath property.
75723>>>>>    // The returned path always ends with a "\"
75723>>>>>    Function psDataPathFirstPart Returns String
75725>>>>>        String sDataPath
75725>>>>>        Integer iCount
75725>>>>>
75725>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75726>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75727>>>>>        If (iCount > 1) Begin
75729>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75730>>>>>        End
75730>>>>>>
75730>>>>>        If (sDataPath <> "") Begin
75732>>>>>            Get vFolderFormat sDataPath to sDataPath
75733>>>>>        End
75733>>>>>>
75733>>>>>
75733>>>>>        Function_Return sDataPath
75734>>>>>    End_Function
75735>>>>>
75735>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75735>>>>>    Procedure WriteErrorLog
75737>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75737>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75738>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75738>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75738>>>>>        Boolean bUseDataTable bQuickWrite
75738>>>>>        DateTime dtUpdateStart dtUpdateEnd
75738>>>>>        TimeSpan tsElapsed
75738>>>>>        Number nVersion                                  
75738>>>>>        Handle hTable
75738>>>>>
75738>>>>>        If (pbHeaderWritten(Self) = False) Begin
75740>>>>>            Send WriteHeaderData
75741>>>>>            Set pbHeaderWritten to True
75742>>>>>        End
75742>>>>>>
75742>>>>>
75742>>>>>        Get pbUseDataTableLog to bUseDataTable
75743>>>>>        If (bUseDataTable = True) Begin
75745>>>>>            Send OnWriteRow_DataTable
75746>>>>>            Procedure_Return
75747>>>>>        End
75747>>>>>>
75747>>>>>
75747>>>>>        Get piChannel to iCh
75748>>>>>        If (iCh < 0) Begin
75750>>>>>            Get Seq_New_Channel to iCh
75751>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75753>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75754>>>>>>
75754>>>>>                Procedure_Return
75755>>>>>            End
75755>>>>>>
75755>>>>>            Set piChannel to iCh
75756>>>>>        End
75756>>>>>>
75756>>>>>
75756>>>>>        Get psLogTextFileWithPath to sFileName
75757>>>>>
75757>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75758>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75759>>>>>        Decrement iSize
75760>>>>>
75760>>>>>        Get pdtUpdateStart to dtUpdateStart
75761>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75763>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75764>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75765>>>>>        End
75765>>>>>>
75765>>>>>        Get pbQuickWrite to bQuickWrite
75766>>>>>
75766>>>>>        Append_Output channel iCh sFileName
75768>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75770>>>>>            Writeln channel iCh ("*** Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75773>>>>>        End
75773>>>>>>
75773>>>>>        Else If (bQuickWrite = False) Begin
75776>>>>>            Writeln channel iCh
75778>>>>>            Writeln channel iCh ("*** Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75781>>>>>        End   
75781>>>>>>
75781>>>>>        If (iSize >= 0) Begin
75783>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75785>>>>>//                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75785>>>>>                Writeln channel iCh "[Err No:] [Version:] [Status Text:]"
75788>>>>>            End
75788>>>>>>
75788>>>>>        End
75788>>>>>>
75788>>>>>
75788>>>>>        For iCount from 0 to iSize  
75794>>>>>>
75794>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75795>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75796>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75797>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75798>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75799>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75800>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75801>>>>>            
75801>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75802>>>>>            If (iError = 0) Begin
75804>>>>>                Move " Info  " to sErrorNo
75805>>>>>            End
75805>>>>>>
75805>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75807>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75808>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75808>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75809>>>>>            End
75809>>>>>>
75809>>>>>            Else Begin
75810>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75811>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75811>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText) to sText
75812>>>>>            End
75812>>>>>>
75812>>>>>            Writeln channel iCh sText
75815>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75817>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75818>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75819>>>>>                Writeln channel iCh sOrgErrorText
75822>>>>>            End
75822>>>>>>
75822>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75824>>>>>                Writeln channel iCh
75826>>>>>            End
75826>>>>>>
75826>>>>>        Loop
75827>>>>>>
75827>>>>>        Close_Output channel iCh
75829>>>>>
75829>>>>>        Send Seq_Release_Channel iCh
75830>>>>>        Set piChannel to -1
75831>>>>>
75831>>>>>    End_Procedure
75832>>>>>
75832>>>>>    // The character to pad is optional. If nothing, spaces are used.
75832>>>>>    // Example:
75832>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75832>>>>>    //  or:
75832>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75832>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75832>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75834>>>>>        String sChar
75834>>>>>
75834>>>>>        If (Num_Arguments >= 3) Begin
75836>>>>>            Move sOptChar to sChar
75837>>>>>        End
75837>>>>>>
75837>>>>>        Else Begin
75838>>>>>            Move " " to sChar
75839>>>>>        End
75839>>>>>>
75839>>>>>
75839>>>>>        While (Length(sString) < iLength)
75843>>>>>            Move (sChar + sString) to sString
75844>>>>>        Loop
75845>>>>>>
75845>>>>>
75845>>>>>        Function_Return sString
75846>>>>>    End_Function
75847>>>>>
75847>>>>>    Procedure ShowErrorLog
75849>>>>>        String sPath sFileName sEditorProgram
75849>>>>>        Boolean bExists
75849>>>>>
75849>>>>>        Get psLogTextFileWithPath to sFileName
75850>>>>>        Get vFilePathExists sFileName to bExists
75851>>>>>        If (bExists = True) Begin
75853>>>>>            Get psEditorProgram to sEditorProgram
75854>>>>>            If (sEditorProgram <> "") Begin
75856>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75857>>>>>            End
75857>>>>>>
75857>>>>>            Else Begin
75858>>>>>                Runprogram Shell Background sFileName
75859>>>>>            End
75859>>>>>>
75859>>>>>        End
75859>>>>>>
75859>>>>>        Else Begin
75860>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75861>>>>>        End
75861>>>>>>
75861>>>>>    End_Procedure
75862>>>>>
75862>>>>>End_Class
75863>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75863>>>>>//****************************************************************************
75863>>>>>// $Module type: Class
75863>>>>>// $Module name: cDbUpdateVersion
75863>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75863>>>>>//
75863>>>>>// Description : Child class to cDbUpdateHandler.
75863>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75863>>>>>//               Set the pnVersionNumber to a version number.
75863>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75863>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75863>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75863>>>>>//
75863>>>>>// $Rev History:
75863>>>>>//    2016-09-27  Module header created
75863>>>>>//****************************************************************************
75863>>>>>Use UI
75863>>>>>Use DUFLanguageConstants.inc
75863>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75863>>>>>>>//****************************************************************************
75863>>>>>>>// $Module type: Class
75863>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75863>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75863>>>>>>>//
75863>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75863>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75863>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75863>>>>>>>//               with the help of Sql-scripts.
75863>>>>>>>//
75863>>>>>>>// $Rev History:
75863>>>>>>>//    2014-09-05  Module header created
75863>>>>>>>//
75863>>>>>>>//****************************************************************************
75863>>>>>>>//
75863>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75863>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75863>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75863>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75863>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75863>>>>>>>//
75863>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75863>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75863>>>>>>>
75863>>>>>>>
75863>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75863>>>>>>>// Determines for all DataFlex data types, which SQL native types will be used when creating new columns.
75863>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75863>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75863>>>>>>>//
75863>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75863>>>>>>>>>//****************************************************************************
75863>>>>>>>>>// $Module type: Class
75863>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75863>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75863>>>>>>>>>//
75863>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75863>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75863>>>>>>>>>//
75863>>>>>>>>>// $Rev History:
75863>>>>>>>>>//    2023-11-06  Module header created
75863>>>>>>>>>//
75863>>>>>>>>>//****************************************************************************
75863>>>>>>>>>Use cApplication.pkg
75863>>>>>>>>>Use seq_chnl.pkg
75863>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75863>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75863>>>>>>>>>Use Dfcursor.pkg
75863>>>>>>>>>Use DUFStatusPanel.pkg
75863>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75863>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75863>>>>>>>>>>>//
75863>>>>>>>>>>>// We need to create a mixin class for the library.
75863>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75863>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75863>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75863>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75863>>>>>>>>>>>//
75863>>>>>>>>>>>Use VdfBase.pkg
75863>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75863>>>>>>>>>>>>>Use Unicode.Pkg
75863>>>>>>>>>>>>>
75863>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75864>>>>>>>>>>>>>
75864>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75865>>>>>>>>>>>>>
75865>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75866>>>>>>>>>>>>>
75866>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75867>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75869>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75869>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75869>>>>>>>>>>>>>    String sUUID
75869>>>>>>>>>>>>>    
75869>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75870>>>>>>>>>>>>>    
75870>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75871>>>>>>>>>>>>>    
75871>>>>>>>>>>>>>    If (iRetval = 0) Begin
75873>>>>>>>>>>>>>        Move 0 to pUUIDStr
75874>>>>>>>>>>>>>        
75874>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75875>>>>>>>>>>>>>        If (iRetval = 0) Begin
75877>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75878>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75879>>>>>>>>>>>>>            
75879>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75880>>>>>>>>>>>>>        End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    
75880>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75881>>>>>>>>>>>>>    
75881>>>>>>>>>>>>>    Function_Return sUUID
75882>>>>>>>>>>>>>End_Function
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75883>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75885>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75885>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75885>>>>>>>>>>>>>    String sUUID
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75886>>>>>>>>>>>>>    
75886>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    If (iRetval = 0) Begin
75889>>>>>>>>>>>>>        Move 0 to pUUIDStr
75890>>>>>>>>>>>>>        
75890>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75891>>>>>>>>>>>>>        If (iRetval = 0) Begin
75893>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75894>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75895>>>>>>>>>>>>>            
75895>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75896>>>>>>>>>>>>>        End
75896>>>>>>>>>>>>>>
75896>>>>>>>>>>>>>    End
75896>>>>>>>>>>>>>>
75896>>>>>>>>>>>>>    
75896>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75897>>>>>>>>>>>>>    
75897>>>>>>>>>>>>>    Function_Return sUUID
75898>>>>>>>>>>>>>End_Function
75899>>>>>>>>>>>Use cli.pkg
75899>>>>>>>>>>>Use sql.pkg
75899>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75899>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75899>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75899>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>Use Cli.pkg
75899>>>>>>>>>>>>>Use SQL.pkg
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Driver Indentification
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Error number constants
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>// SQL Server spcific types.
75899>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75899>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75899>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75899>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>// SQL Server spcific types.
75899>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75899>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75899>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75899>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75899>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75899>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75899>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75899>>>>>>>>>>>>>//
75899>>>>>>>>>>>>>//     Setup a constraint for a file.
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75900>>>>>>>>>>>>>    
75900>>>>>>>>>>>>>    Procedure Construct_Object
75902>>>>>>>>>>>>>        Forward Send Construct_Object
75904>>>>>>>>>>>>>        
75904>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75905>>>>>>>>>>>>>    End_Procedure
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75906>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75908>>>>>>>>>>>>>        String  sItem
75908>>>>>>>>>>>>>        Integer iStart
75908>>>>>>>>>>>>>        Integer iEnd
75908>>>>>>>>>>>>>        
75908>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75911>>>>>>>>>>>>>        
75911>>>>>>>>>>>>>        Send Delete_Data to hoStore
75912>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75913>>>>>>>>>>>>>        While (iStart > 0)
75917>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75918>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75921>>>>>>>>>>>>>            Else Begin
75922>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75923>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75924>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75927>>>>>>>>>>>>>                
75927>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75930>>>>>>>>>>>>>                
75930>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75933>>>>>>>>>>>>>            End
75933>>>>>>>>>>>>>>
75933>>>>>>>>>>>>>        Loop
75934>>>>>>>>>>>>>>
75934>>>>>>>>>>>>>        
75934>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75935>>>>>>>>>>>>>    End_Procedure
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    //   Call the driver's browse connect function
75936>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75938>>>>>>>>>>>>>        String  sDriver
75938>>>>>>>>>>>>>        String  sOutConnStr
75938>>>>>>>>>>>>>        Integer iArg
75938>>>>>>>>>>>>>        Integer iRetval
75938>>>>>>>>>>>>>        
75938>>>>>>>>>>>>>        Get psDriverID to sDriver
75939>>>>>>>>>>>>>        If (sDriver <> "") Begin
75941>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75942>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75947>>>>>>>>>>>>>        End
75947>>>>>>>>>>>>>>
75947>>>>>>>>>>>>>        
75947>>>>>>>>>>>>>        Function_Return sOutConnStr
75948>>>>>>>>>>>>>    End_Function// BrowseConnect
75949>>>>>>>>>>>>>    
75949>>>>>>>>>>>>>    
75949>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75951>>>>>>>>>>>>>        String  sDriver
75951>>>>>>>>>>>>>        String  sOutConnStr
75951>>>>>>>>>>>>>        Integer iArg
75951>>>>>>>>>>>>>        Integer iRetval
75951>>>>>>>>>>>>>        
75951>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75952>>>>>>>>>>>>>        
75952>>>>>>>>>>>>>        Get psDriverID to sDriver
75953>>>>>>>>>>>>>        If (sDriver <> "") Begin
75955>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75956>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75961>>>>>>>>>>>>>        End
75961>>>>>>>>>>>>>>
75961>>>>>>>>>>>>>        
75961>>>>>>>>>>>>>        Function_Return sOutConnStr
75962>>>>>>>>>>>>>    End_Function// BrowseConnect
75963>>>>>>>>>>>>>    
75963>>>>>>>>>>>>>    
75963>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75965>>>>>>>>>>>>>        String  sServerList
75965>>>>>>>>>>>>>        Integer iNumServers
75965>>>>>>>>>>>>>        Integer iDriver
75965>>>>>>>>>>>>>        Integer iClientVersion
75965>>>>>>>>>>>>>        String  sDriver
75965>>>>>>>>>>>>>        
75965>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75966>>>>>>>>>>>>>        
75966>>>>>>>>>>>>>        If (iDriver) Begin
75968>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75971>>>>>>>>>>>>>            
75971>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75972>>>>>>>>>>>>>            
75972>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75973>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75975>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75976>>>>>>>>>>>>>            End
75976>>>>>>>>>>>>>>
75976>>>>>>>>>>>>>            Else Begin
75977>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75978>>>>>>>>>>>>>            End
75978>>>>>>>>>>>>>>
75978>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75979>>>>>>>>>>>>>        End
75979>>>>>>>>>>>>>>
75979>>>>>>>>>>>>>        
75979>>>>>>>>>>>>>        Function_Return iNumServers
75980>>>>>>>>>>>>>    End_Function
75981>>>>>>>>>>>>>    
75981>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75981>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75981>>>>>>>>>>>>>    //   This may take a long time.
75981>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75981>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75983>>>>>>>>>>>>>        Integer iNumServers
75983>>>>>>>>>>>>>        Integer iNetworkLocal
75983>>>>>>>>>>>>>        
75983>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75984>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75985>>>>>>>>>>>>>
75985>>>>>>>>>>>>>        Function_Return iNumServers
75986>>>>>>>>>>>>>    End_Function
75987>>>>>>>>>>>>>    
75987>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75987>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75987>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75987>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75989>>>>>>>>>>>>>        Integer iNumServers
75989>>>>>>>>>>>>>        Integer iNetworkLocal
75989>>>>>>>>>>>>>        
75989>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75990>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75991>>>>>>>>>>>>>        
75991>>>>>>>>>>>>>        Function_Return iNumServers
75992>>>>>>>>>>>>>    End_Function
75993>>>>>>>>>>>>>    
75993>>>>>>>>>>>>>    //   Enumerate database in a given server.
75993>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75995>>>>>>>>>>>>>        Integer hoSQL
75995>>>>>>>>>>>>>        String  sConnect
75995>>>>>>>>>>>>>        String  sDatabase
75995>>>>>>>>>>>>>        Integer hdbc
75995>>>>>>>>>>>>>        Integer hstmt
75995>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75995>>>>>>>>>>>>>        
75995>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75998>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76001>>>>>>>>>>>>>        
76001>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76004>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76006>>>>>>>>>>>>>
76006>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76007>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76010>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
76012>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76013>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
76014>>>>>>>>>>>>>        End
76014>>>>>>>>>>>>>>
76014>>>>>>>>>>>>>        
76014>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76016>>>>>>>>>>>>>            Move Current_Object to hoSQL
76017>>>>>>>>>>>>>        End_Object
76018>>>>>>>>>>>>>        
76018>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76020>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76021>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76023>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76024>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76026>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76026>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76026>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76026>>>>>>>>>>>>>                    //   stay the same.
76026>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76027>>>>>>>>>>>>>                    Send SQLCall to hstmt
76028>>>>>>>>>>>>>                    Repeat
76028>>>>>>>>>>>>>>
76028>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76029>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76031>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76032>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76033>>>>>>>>>>>>>                        End
76033>>>>>>>>>>>>>>
76033>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76035>>>>>>>>>>>>>                    
76035>>>>>>>>>>>>>                    Send SQLClose to hstmt
76036>>>>>>>>>>>>>                End
76036>>>>>>>>>>>>>>
76036>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76037>>>>>>>>>>>>>            End
76037>>>>>>>>>>>>>>
76037>>>>>>>>>>>>>        End
76037>>>>>>>>>>>>>>
76037>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76038>>>>>>>>>>>>>        
76038>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76039>>>>>>>>>>>>>    End_Function
76040>>>>>>>>>>>>>    
76040>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76042>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76042>>>>>>>>>>>>>        
76042>>>>>>>>>>>>>        Case Begin
76042>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76044>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76045>>>>>>>>>>>>>                Case Break
76046>>>>>>>>>>>>>            
76046>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76049>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76050>>>>>>>>>>>>>                Case Break
76051>>>>>>>>>>>>>                
76051>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76054>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76055>>>>>>>>>>>>>                Case Break
76056>>>>>>>>>>>>>            
76056>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76059>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76060>>>>>>>>>>>>>                Case Break
76061>>>>>>>>>>>>>            
76061>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76064>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76065>>>>>>>>>>>>>                Case Break
76066>>>>>>>>>>>>>            
76066>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76069>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76070>>>>>>>>>>>>>                Case Break
76071>>>>>>>>>>>>>            
76071>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76074>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76075>>>>>>>>>>>>>                Case Break
76076>>>>>>>>>>>>>            
76076>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76079>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76080>>>>>>>>>>>>>                Case Break
76081>>>>>>>>>>>>>            
76081>>>>>>>>>>>>>            Case Else
76081>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76082>>>>>>>>>>>>>        Case End
76082>>>>>>>>>>>>>        
76082>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76083>>>>>>>>>>>>>    End_Function
76084>>>>>>>>>>>>>
76084>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76086>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76086>>>>>>>>>>>>>        
76086>>>>>>>>>>>>>        Case Begin
76086>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76088>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76089>>>>>>>>>>>>>                Case Break
76090>>>>>>>>>>>>>
76090>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76093>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76094>>>>>>>>>>>>>                Case Break
76095>>>>>>>>>>>>>                
76095>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76098>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76099>>>>>>>>>>>>>                Case Break
76100>>>>>>>>>>>>>            
76100>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76103>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76104>>>>>>>>>>>>>                Case Break
76105>>>>>>>>>>>>>            
76105>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76108>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76109>>>>>>>>>>>>>                Case Break
76110>>>>>>>>>>>>>            
76110>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76113>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76114>>>>>>>>>>>>>                Case Break
76115>>>>>>>>>>>>>            
76115>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76118>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76119>>>>>>>>>>>>>                Case Break
76120>>>>>>>>>>>>>            
76120>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76123>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76124>>>>>>>>>>>>>                Case Break
76125>>>>>>>>>>>>>            
76125>>>>>>>>>>>>>            Case Else
76125>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76126>>>>>>>>>>>>>        Case End
76126>>>>>>>>>>>>>        
76126>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76127>>>>>>>>>>>>>    End_Function
76128>>>>>>>>>>>>>    
76128>>>>>>>>>>>>>End_Class
76129>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76129>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76129>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76129>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76129>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>Use Cli.pkg
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Driver attributes
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Driver Indentification
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Error number constants
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Call driver function identifiers
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// DB2 specific data types
76129>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76129>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76129>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76129>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76129>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76129>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76129>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76129>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Extra DB2 commands
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76129>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76130>>>>>>>>>>>>>    
76130>>>>>>>>>>>>>    Procedure Construct_Object
76132>>>>>>>>>>>>>        Forward Send Construct_Object
76134>>>>>>>>>>>>>        
76134>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76135>>>>>>>>>>>>>    End_Procedure
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76136>>>>>>>>>>>>>    Procedure SeedDataSources
76138>>>>>>>>>>>>>        String  sDriver
76138>>>>>>>>>>>>>        String  sVoid
76138>>>>>>>>>>>>>        Integer iRetval
76138>>>>>>>>>>>>>        
76138>>>>>>>>>>>>>        Get psDriverID to sDriver
76139>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76146>>>>>>>>>>>>>    End_Procedure
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    // Call the driver's data sources function
76147>>>>>>>>>>>>>    Function DataSources Returns String
76149>>>>>>>>>>>>>        String  sDriver
76149>>>>>>>>>>>>>        String  sDataSource
76149>>>>>>>>>>>>>        String  sDescription
76149>>>>>>>>>>>>>        Integer iLength
76149>>>>>>>>>>>>>        Integer iRetval
76149>>>>>>>>>>>>>        
76149>>>>>>>>>>>>>        Get psDriverID to sDriver
76150>>>>>>>>>>>>>        If (sDriver <> "") Begin
76152>>>>>>>>>>>>>            Move 8192 to iLength
76153>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76154>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76155>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76160>>>>>>>>>>>>>        End
76160>>>>>>>>>>>>>>
76160>>>>>>>>>>>>>        
76160>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76163>>>>>>>>>>>>>        Else ;            Function_Return ""
76165>>>>>>>>>>>>>    End_Function
76166>>>>>>>>>>>>>    
76166>>>>>>>>>>>>>End_Class
76167>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76167>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76167>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76167>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>Use Cli.pkg
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Driver Indentification
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Error number constants
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Call driver function identifiers
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76168>>>>>>>>>>>>>    
76168>>>>>>>>>>>>>    Procedure Construct_Object
76170>>>>>>>>>>>>>        Forward Send Construct_Object
76172>>>>>>>>>>>>>        
76172>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76173>>>>>>>>>>>>>    End_Procedure
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76174>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76176>>>>>>>>>>>>>        String  sDriver
76176>>>>>>>>>>>>>        String  sVoid
76176>>>>>>>>>>>>>        Integer iRetval
76176>>>>>>>>>>>>>        
76176>>>>>>>>>>>>>        Get psDriverID to sDriver
76177>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76184>>>>>>>>>>>>>    End_Procedure
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    // Call the driver's data sources function
76185>>>>>>>>>>>>>    Function DataSources Returns String
76187>>>>>>>>>>>>>        String  sDriver
76187>>>>>>>>>>>>>        String  sDataSource
76187>>>>>>>>>>>>>        String  sDescription
76187>>>>>>>>>>>>>        Integer iLength
76187>>>>>>>>>>>>>        Integer iRetval
76187>>>>>>>>>>>>>        
76187>>>>>>>>>>>>>        Get psDriverID to sDriver
76188>>>>>>>>>>>>>        If (sDriver <> "") Begin
76190>>>>>>>>>>>>>            Move 8192 to iLength
76191>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76192>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76193>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76198>>>>>>>>>>>>>        End
76198>>>>>>>>>>>>>>
76198>>>>>>>>>>>>>        
76198>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76201>>>>>>>>>>>>>        Else ;            Function_Return ""
76203>>>>>>>>>>>>>    End_Function
76204>>>>>>>>>>>>>    
76204>>>>>>>>>>>>>End_Class
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76205>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76205>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76205>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76205>>>>>>>>>>>>>Use Ui
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Driver Indentification
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>// Driver attributes
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Call_Driver functions ID's
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to create all vars which may be needed
76205>>>>>>>>>>>>>// in other commands.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76205>>>>>>>>>>>>>// File must have been opened.
76205>>>>>>>>>>>>>// Filenumber needs to be passed.
76205>>>>>>>>>>>>>// To clear set the owner to "".
76205>>>>>>>>>>>>>// Examples:
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76205>>>>>>>>>>>>>// To clear:
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76205>>>>>>>>>>>>>// options.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to parse for Callback
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76205>>>>>>>>>>>>>// File must have been opened.
76205>>>>>>>>>>>>>// Filenumber needs to be passed.
76205>>>>>>>>>>>>>// Examples:
76205>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76205>>>>>>>>>>>>>// which will be tries when opening files.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76205>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76205>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76205>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to change the transaction type.
76205>>>>>>>>>>>>>// Valid types are:
76205>>>>>>>>>>>>>//     DFBTRTT_NONE
76205>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76205>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get the current transaction type.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set explicit_locking
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get explicit locking
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76205>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76206>>>>>>>>>>>>>    
76206>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76208>>>>>>>>>>>>>        Forward Send Construct_object iImage
76210>>>>>>>>>>>>>        
76210>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76211>>>>>>>>>>>>>    End_Procedure
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76212>>>>>>>>>>>>>    //
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    Function CKRevision Returns String
76214>>>>>>>>>>>>>        String  sDriverID
76214>>>>>>>>>>>>>        String  sRevision
76214>>>>>>>>>>>>>        String  sVoid
76214>>>>>>>>>>>>>        Integer iRetval
76214>>>>>>>>>>>>>        
76214>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76214>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76214>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76214>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76215>>>>>>>>>>>>>        Get psDriverID to sDriverID
76216>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76217>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76222>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76223>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76225>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76225>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76226>>>>>>>>>>>>>        End
76226>>>>>>>>>>>>>>
76226>>>>>>>>>>>>>        Function_Return sRevision
76227>>>>>>>>>>>>>    End_Function
76228>>>>>>>>>>>>>    
76228>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76230>>>>>>>>>>>>>        String  sDriverID
76230>>>>>>>>>>>>>        String  sVoid1
76230>>>>>>>>>>>>>        String  sVoid2
76230>>>>>>>>>>>>>        Integer iRetval
76230>>>>>>>>>>>>>        
76230>>>>>>>>>>>>>        Get psDriverID to sDriverID
76231>>>>>>>>>>>>>        
76231>>>>>>>>>>>>>        Move 0 to iRetval
76232>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76232>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76232>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76232>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76233>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76238>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76239>>>>>>>>>>>>>        
76239>>>>>>>>>>>>>        Function_Return iRetval
76240>>>>>>>>>>>>>    End_Function
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76241>>>>>>>>>>>>>    //
76241>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76241>>>>>>>>>>>>>    //
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76243>>>>>>>>>>>>>        Integer iPartRev
76243>>>>>>>>>>>>>        Integer iCurrentPart
76243>>>>>>>>>>>>>        Integer iSeparatorPos
76243>>>>>>>>>>>>>        
76243>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76246>>>>>>>>>>>>>        
76246>>>>>>>>>>>>>        Move 0 to iCurrentPart
76247>>>>>>>>>>>>>        Repeat
76247>>>>>>>>>>>>>>
76247>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76248>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76250>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76251>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76252>>>>>>>>>>>>>                Increment iCurrentPart
76253>>>>>>>>>>>>>            End
76253>>>>>>>>>>>>>>
76253>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76256>>>>>>>>>>>>>                Move sRevision to iPartRev
76257>>>>>>>>>>>>>                Move "" to sRevision
76258>>>>>>>>>>>>>                Increment iCurrentPart
76259>>>>>>>>>>>>>            End
76259>>>>>>>>>>>>>>
76259>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76261>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76263>>>>>>>>>>>>>        
76263>>>>>>>>>>>>>        Function_Return iPartRev
76264>>>>>>>>>>>>>    End_Function
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    //
76265>>>>>>>>>>>>>    //  Returns the major revision of the CK
76265>>>>>>>>>>>>>    //
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76267>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76268>>>>>>>>>>>>>    End_Function
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76269>>>>>>>>>>>>>    //
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76271>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76272>>>>>>>>>>>>>    End_Function
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    //  Returns the release revision of the CK
76273>>>>>>>>>>>>>    //
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76275>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76276>>>>>>>>>>>>>    End_Function
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    //  Returns the major revision of the CK
76277>>>>>>>>>>>>>    //
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76279>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76280>>>>>>>>>>>>>    End_Function
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76281>>>>>>>>>>>>>    //
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76283>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76286>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76289>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76292>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76295>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76298>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76302>>>>>>>>>>>>>            End
76302>>>>>>>>>>>>>>
76302>>>>>>>>>>>>>        End
76302>>>>>>>>>>>>>>
76302>>>>>>>>>>>>>        
76302>>>>>>>>>>>>>        Function_Return (False)
76303>>>>>>>>>>>>>    End_Function
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76304>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76304>>>>>>>>>>>>>    //   in the following format:
76304>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76304>>>>>>>>>>>>>    //   possible values for <type>:
76304>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76304>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76304>>>>>>>>>>>>>    //       C for client cache engine
76304>>>>>>>>>>>>>    //       D for DOS workstation
76304>>>>>>>>>>>>>    //       N for client Requester
76304>>>>>>>>>>>>>    //       S for NetWare server
76304>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76304>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   example:
76304>>>>>>>>>>>>>    //       8.50.T
76304>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76304>>>>>>>>>>>>>    //   32-bits Windows server.
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76304>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76304>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    //  Returns the version information of the
76304>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        String  sDriverID
76306>>>>>>>>>>>>>        String  sVersion
76306>>>>>>>>>>>>>        String  sVoid
76306>>>>>>>>>>>>>        Integer iRetval
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76306>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76306>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76306>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76307>>>>>>>>>>>>>        Get psDriverID to sDriverID
76308>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76309>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76314>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76315>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76317>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76317>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76318>>>>>>>>>>>>>        End
76318>>>>>>>>>>>>>>
76318>>>>>>>>>>>>>        Function_Return sVersion
76319>>>>>>>>>>>>>    End_Function
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        String  sDriverID
76322>>>>>>>>>>>>>        String  sVersion
76322>>>>>>>>>>>>>        String  sVoid
76322>>>>>>>>>>>>>        Integer iRetval
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76322>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76322>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76322>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76323>>>>>>>>>>>>>        Get psDriverID to sDriverID
76324>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76325>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76330>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76331>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76333>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76333>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76334>>>>>>>>>>>>>        End
76334>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>        Function_Return sVersion
76335>>>>>>>>>>>>>    End_Function
76336>>>>>>>>>>>>>    
76336>>>>>>>>>>>>>    //  Returns the version information of the
76336>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76336>>>>>>>>>>>>>    
76336>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76338>>>>>>>>>>>>>        
76338>>>>>>>>>>>>>        String  sDriverID
76338>>>>>>>>>>>>>        String  sVersion
76338>>>>>>>>>>>>>        String  sVoid
76338>>>>>>>>>>>>>        Integer iRetval
76338>>>>>>>>>>>>>        
76338>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76338>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76338>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76338>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76339>>>>>>>>>>>>>        Get psDriverID to sDriverID
76340>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76341>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76346>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76347>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76349>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76349>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76350>>>>>>>>>>>>>        End
76350>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>        Function_Return sVersion
76351>>>>>>>>>>>>>    End_Function
76352>>>>>>>>>>>>>    
76352>>>>>>>>>>>>>End_Class
76353>>>>>>>>>>>>>
76353>>>>>>>>>>>>>
76353>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76353>>>>>>>>>>>>>//****************************************************************************
76353>>>>>>>>>>>>>// $Module type: Include file
76353>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76353>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76353>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76353>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76353>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76353>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76353>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76353>>>>>>>>>>>>>// in the help folder for more details.
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>Use Winkern.pkg
76353>>>>>>>>>>>>>Use cIniFile.pkg
76353>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76353>>>>>>>>>>>>>>>Use VdfBase.pkg
76353>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76353>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76353>>>>>>>>>>>>>>>>>// Algorithm classes
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Algorithm types
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Generic sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// RSA sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// DSS sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// DES sub_ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76353>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76353>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// RC2 sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Hash sub ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76353>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76353>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// secure channel sub ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76353>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76353>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76353>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76353>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76353>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76353>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76353>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76353>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76353>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76353>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76353>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76353>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76353>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76353>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76353>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76353>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76353>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76353>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76353>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76353>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76353>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76353>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Providers
76353>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76353>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76353>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76353>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76353>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76353>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76353>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76353>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76353>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76353>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76353>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76353>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76353>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76353>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76353>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76353>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76353>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76353>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76353>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76353>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76353>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76353>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Provider types
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76353>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76353>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76353>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76353>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76353>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76353>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76353>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76353>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76353>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76353>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// KP_MODE
76353>>>>>>>>>>>>>>>>>// KP_MODE
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76353>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76353>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76353>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76353>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76353>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76353>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76353>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76353>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76353>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76353>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76353>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76353>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76353>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76353>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76353>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76353>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76353>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76353>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76353>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76353>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76353>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76353>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76353>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76353>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76353>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76353>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76353>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76353>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76353>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76353>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76353>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76353>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76353>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76353>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76353>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76353>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76353>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76353>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76353>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76353>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76353>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76353>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76353>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76353>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76353>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76353>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// key BLOB types
76353>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76353>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76353>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76353>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76353>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76353>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76353>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76353>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// KP_PADDING
76353>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76353>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76353>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76353>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76353>>>>>>>>>>>>>>>>>    UChar    bType
76353>>>>>>>>>>>>>>>>>    UChar    bVersion
76353>>>>>>>>>>>>>>>>>    UShort   reserved
76353>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76353>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76353>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76353>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76353>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76353>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76353>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76353>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76353>>>>>>>>>>>>>>>>>    DWord cbInnerString
76353>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76353>>>>>>>>>>>>>>>>>    DWord cbOuterString
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76353>>>>>>>>>>>>>>>>>    UChar   bType
76353>>>>>>>>>>>>>>>>>    UChar   bVersion
76353>>>>>>>>>>>>>>>>>    Short   reserved
76353>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct CryptoBlob
76353>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76353>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76353>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76353>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76353>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76354>>>>>>>>>>>>>>>>>
76354>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76354>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76356>>>>>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>>>>>    Boolean bResult
76356>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76356>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76356>>>>>>>>>>>>>>>>>
76356>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76357>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76358>>>>>>>>>>>>>>>>>    
76358>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76359>>>>>>>>>>>>>>>>>
76359>>>>>>>>>>>>>>>>>    Function_Return bResult
76360>>>>>>>>>>>>>>>>>End_Function
76361>>>>>>>>>>>>>>>>>
76361>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76362>>>>>>>>>>>>>>>>>
76362>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76363>>>>>>>>>>>>>>>>>
76363>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76364>>>>>>>>>>>>>>>>>
76364>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76365>>>>>>>>>>>>>>>>>
76365>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76366>>>>>>>>>>>>>>>>>
76366>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76367>>>>>>>>>>>>>>>>>
76367>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76368>>>>>>>>>>>>>>>>>
76368>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76369>>>>>>>>>>>>>>>>>
76369>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76370>>>>>>>>>>>>>>>>>    
76370>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76371>>>>>>>>>>>>>>>>>
76371>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76372>>>>>>>>>>>>>>>>>
76372>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76373>>>>>>>>>>>>>>>>>
76373>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76374>>>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76375>>>>>>>>>>>>>>>>>    
76375>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76376>>>>>>>>>>>>>>>>>    
76376>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76377>>>>>>>>>>>>>>>
76377>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76378>>>>>>>>>>>>>>>    
76378>>>>>>>>>>>>>>>    Procedure Construct_Object
76380>>>>>>>>>>>>>>>        Forward Send Construct_Object
76382>>>>>>>>>>>>>>>        
76382>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76383>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76384>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76385>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76386>>>>>>>>>>>>>>>        
76386>>>>>>>>>>>>>>>        // Private properties
76386>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76387>>>>>>>>>>>>>>>        
76387>>>>>>>>>>>>>>>        // Block cipher properties
76387>>>>>>>>>>>>>>>        Property UChar[]    paKey
76388>>>>>>>>>>>>>>>        Property UChar[]    paIV
76389>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76390>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76391>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76392>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76393>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76394>>>>>>>>>>>>>>>    End_Procedure
76395>>>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>>>    // Acquire key container handle
76395>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76397>>>>>>>>>>>>>>>        Integer iProvider
76397>>>>>>>>>>>>>>>        WString wProvider
76397>>>>>>>>>>>>>>>        Handle hProv
76397>>>>>>>>>>>>>>>        Boolean bOk
76397>>>>>>>>>>>>>>>        Pointer pProv
76397>>>>>>>>>>>>>>>        
76397>>>>>>>>>>>>>>>        Move 0 to hProv
76398>>>>>>>>>>>>>>>        Get piProvider to iProvider
76399>>>>>>>>>>>>>>>        Get psProvider to wProvider
76400>>>>>>>>>>>>>>>        
76400>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76400>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76402>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76403>>>>>>>>>>>>>>>        End
76403>>>>>>>>>>>>>>>>
76403>>>>>>>>>>>>>>>        Else Begin
76404>>>>>>>>>>>>>>>            Move 0 to pProv
76405>>>>>>>>>>>>>>>        End
76405>>>>>>>>>>>>>>>>
76405>>>>>>>>>>>>>>>        
76405>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76405>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76406>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76408>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76409>>>>>>>>>>>>>>>        End
76409>>>>>>>>>>>>>>>>
76409>>>>>>>>>>>>>>>        
76409>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76411>>>>>>>>>>>>>>>            // Fallback to original
76411>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76412>>>>>>>>>>>>>>>            
76412>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76414>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76415>>>>>>>>>>>>>>>            End
76415>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>        End
76415>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76416>>>>>>>>>>>>>>>        
76416>>>>>>>>>>>>>>>        Function_Return hProv
76417>>>>>>>>>>>>>>>    End_Function
76418>>>>>>>>>>>>>>>    
76418>>>>>>>>>>>>>>>    // Releases key container handle
76418>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76420>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76421>>>>>>>>>>>>>>>    End_Function
76422>>>>>>>>>>>>>>>    
76422>>>>>>>>>>>>>>>    // Creates hash object
76422>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76424>>>>>>>>>>>>>>>        Integer iAlgorithm
76424>>>>>>>>>>>>>>>        Handle hHash
76424>>>>>>>>>>>>>>>        Boolean bOk
76424>>>>>>>>>>>>>>>        
76424>>>>>>>>>>>>>>>        Move 0 to hHash
76425>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76426>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76427>>>>>>>>>>>>>>>        
76427>>>>>>>>>>>>>>>        Function_Return hHash
76428>>>>>>>>>>>>>>>    End_Function
76429>>>>>>>>>>>>>>>    
76429>>>>>>>>>>>>>>>    // Destroys the hash object
76429>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76431>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76432>>>>>>>>>>>>>>>    End_Function
76433>>>>>>>>>>>>>>>    
76433>>>>>>>>>>>>>>>    // Adds data to hash object
76433>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76435>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76436>>>>>>>>>>>>>>>    End_Function
76437>>>>>>>>>>>>>>>    
76437>>>>>>>>>>>>>>>    // Generates session key
76437>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76439>>>>>>>>>>>>>>>        Integer iAlgorithm
76439>>>>>>>>>>>>>>>        Handle hKey
76439>>>>>>>>>>>>>>>        Boolean bOk
76439>>>>>>>>>>>>>>>        
76439>>>>>>>>>>>>>>>        Move 0 to hKey
76440>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76441>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76442>>>>>>>>>>>>>>>        
76442>>>>>>>>>>>>>>>        Function_Return hKey
76443>>>>>>>>>>>>>>>    End_Function
76444>>>>>>>>>>>>>>>    
76444>>>>>>>>>>>>>>>    // Imports a plain text key
76444>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76446>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76446>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76446>>>>>>>>>>>>>>>        Boolean   bSuccess
76446>>>>>>>>>>>>>>>        Handle    hKey
76446>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76446>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76447>>>>>>>>>>>>>>>        Integer iVoid
76447>>>>>>>>>>>>>>>        
76447>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76448>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76449>>>>>>>>>>>>>>>        
76449>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76450>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76451>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76452>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76453>>>>>>>>>>>>>>>        
76453>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76454>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76455>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76456>>>>>>>>>>>>>>>        
76456>>>>>>>>>>>>>>>        Move 0 to hKey
76457>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76458>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76460>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76461>>>>>>>>>>>>>>>        End
76461>>>>>>>>>>>>>>>>
76461>>>>>>>>>>>>>>>        
76461>>>>>>>>>>>>>>>        Function_Return hKey
76462>>>>>>>>>>>>>>>    End_Function
76463>>>>>>>>>>>>>>>    
76463>>>>>>>>>>>>>>>    // Destroys the key
76463>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76465>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76466>>>>>>>>>>>>>>>    End_Function
76467>>>>>>>>>>>>>>>    
76467>>>>>>>>>>>>>>>    // Retrieves key data
76467>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76469>>>>>>>>>>>>>>>        Integer iBuffer iLen
76469>>>>>>>>>>>>>>>        Boolean bOk
76469>>>>>>>>>>>>>>>        
76469>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76470>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76471>>>>>>>>>>>>>>>        Function_Return iBuffer
76472>>>>>>>>>>>>>>>    End_Function
76473>>>>>>>>>>>>>>>    
76473>>>>>>>>>>>>>>>    // Retrieves a hash value
76473>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76475>>>>>>>>>>>>>>>        UChar[] ucHash
76476>>>>>>>>>>>>>>>        Integer liResult
76476>>>>>>>>>>>>>>>        DWord   dwDataLen
76476>>>>>>>>>>>>>>>        
76476>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76477>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76478>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76481>>>>>>>>>>>>>>>        
76481>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76482>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76483>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76486>>>>>>>>>>>>>>>        
76486>>>>>>>>>>>>>>>        Function_Return ucHash
76487>>>>>>>>>>>>>>>    End_Function
76488>>>>>>>>>>>>>>>
76488>>>>>>>>>>>>>>>    // Encrypts data
76488>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76490>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76490>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76490>>>>>>>>>>>>>>>        Boolean bOk
76490>>>>>>>>>>>>>>>        
76490>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76491>>>>>>>>>>>>>>>        If (hProv) Begin
76493>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76494>>>>>>>>>>>>>>>            If (hHash) Begin
76496>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76497>>>>>>>>>>>>>>>                If (bOk) Begin
76499>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76500>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76501>>>>>>>>>>>>>>>                End
76501>>>>>>>>>>>>>>>>
76501>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76502>>>>>>>>>>>>>>>            End
76502>>>>>>>>>>>>>>>>
76502>>>>>>>>>>>>>>>            
76502>>>>>>>>>>>>>>>            If (hKey) Begin
76504>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76504>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76505>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76506>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76507>>>>>>>>>>>>>>>                
76507>>>>>>>>>>>>>>>                //  Reserve space in string
76507>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76509>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76510>>>>>>>>>>>>>>>                End
76510>>>>>>>>>>>>>>>>
76510>>>>>>>>>>>>>>>                
76510>>>>>>>>>>>>>>>                //  Call to really decrypt
76510>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76511>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76511>>>>>>>>>>>>>>>                //Move "" to sData
76511>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76511>>>>>>>>>>>>>>>                //End
76511>>>>>>>>>>>>>>>                
76511>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76512>>>>>>>>>>>>>>>            End 
76512>>>>>>>>>>>>>>>>
76512>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76513>>>>>>>>>>>>>>>        End 
76513>>>>>>>>>>>>>>>>
76513>>>>>>>>>>>>>>>        Function_Return ucData
76514>>>>>>>>>>>>>>>    End_Function
76515>>>>>>>>>>>>>>>    
76515>>>>>>>>>>>>>>>    // Decrypts data
76515>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76517>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76517>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76517>>>>>>>>>>>>>>>        Boolean bOk
76517>>>>>>>>>>>>>>>        
76517>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76518>>>>>>>>>>>>>>>        If (hProv) Begin
76520>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76521>>>>>>>>>>>>>>>            If (hHash) Begin
76523>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76524>>>>>>>>>>>>>>>                If (bOk) Begin
76526>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76527>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76528>>>>>>>>>>>>>>>                End
76528>>>>>>>>>>>>>>>>
76528>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76529>>>>>>>>>>>>>>>            End
76529>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>            
76529>>>>>>>>>>>>>>>            If (hKey) Begin
76531>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76532>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76533>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76533>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76535>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76536>>>>>>>>>>>>>>>                End
76536>>>>>>>>>>>>>>>>
76536>>>>>>>>>>>>>>>                
76536>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76537>>>>>>>>>>>>>>>            End
76537>>>>>>>>>>>>>>>>
76537>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76538>>>>>>>>>>>>>>>        End
76538>>>>>>>>>>>>>>>>
76538>>>>>>>>>>>>>>>        Function_Return ucData
76539>>>>>>>>>>>>>>>    End_Function
76540>>>>>>>>>>>>>>>    
76540>>>>>>>>>>>>>>>    // Creates a key
76540>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76542>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76542>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76542>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76542>>>>>>>>>>>>>>>        Boolean bOk
76542>>>>>>>>>>>>>>>        Handle hKey
76542>>>>>>>>>>>>>>>        UChar[] aKey
76543>>>>>>>>>>>>>>>
76543>>>>>>>>>>>>>>>        Get paKey to aKey
76544>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76545>>>>>>>>>>>>>>>        Get piKeyType to iType
76546>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76547>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76548>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76549>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76550>>>>>>>>>>>>>>>        
76550>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76551>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76557>>>>>>>>>>>>>>>>
76557>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76558>>>>>>>>>>>>>>>        Loop
76559>>>>>>>>>>>>>>>>
76559>>>>>>>>>>>>>>>        
76559>>>>>>>>>>>>>>>        Move 0 to hKey
76560>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76561>>>>>>>>>>>>>>>        Function_Return hKey
76562>>>>>>>>>>>>>>>    End_Function
76563>>>>>>>>>>>>>>>    
76563>>>>>>>>>>>>>>>    // Sets the key parameters
76563>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76565>>>>>>>>>>>>>>>        Integer iPadding iMode
76565>>>>>>>>>>>>>>>        Boolean bOk
76565>>>>>>>>>>>>>>>        UChar[] aIV
76566>>>>>>>>>>>>>>>        
76566>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76566>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76566>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76566>>>>>>>>>>>>>>>        //Loop
76566>>>>>>>>>>>>>>>
76566>>>>>>>>>>>>>>>        // Set initialization vector
76566>>>>>>>>>>>>>>>        Get paIV to aIV
76567>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76568>>>>>>>>>>>>>>>        If (bOk) Begin
76570>>>>>>>>>>>>>>>            // Set padding
76570>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76571>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76572>>>>>>>>>>>>>>>            If (bOk) Begin
76574>>>>>>>>>>>>>>>                // Set move
76574>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76575>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76576>>>>>>>>>>>>>>>            End
76576>>>>>>>>>>>>>>>>
76576>>>>>>>>>>>>>>>        End
76576>>>>>>>>>>>>>>>>
76576>>>>>>>>>>>>>>>        Function_Return bOk        
76577>>>>>>>>>>>>>>>    End_Function
76578>>>>>>>>>>>>>>>    
76578>>>>>>>>>>>>>>>    // Encrypts using block cipher
76578>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76580>>>>>>>>>>>>>>>        Handle hProv hKey
76580>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76580>>>>>>>>>>>>>>>        Boolean bOk
76580>>>>>>>>>>>>>>>        
76580>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76581>>>>>>>>>>>>>>>        If (hProv) Begin
76583>>>>>>>>>>>>>>>            // Create key
76583>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76584>>>>>>>>>>>>>>>            If (hKey) Begin
76586>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76587>>>>>>>>>>>>>>>                If (bOk) Begin
76589>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76589>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76590>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76591>>>>>>>>>>>>>>>                    
76591>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76592>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76593>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76594>>>>>>>>>>>>>>>                End
76594>>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76595>>>>>>>>>>>>>>>            End
76595>>>>>>>>>>>>>>>>
76595>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76596>>>>>>>>>>>>>>>        End
76596>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>        Function_Return ucData
76597>>>>>>>>>>>>>>>    End_Function
76598>>>>>>>>>>>>>>>    
76598>>>>>>>>>>>>>>>    // Decrypts using block cipher
76598>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76600>>>>>>>>>>>>>>>        Handle hProv hKey
76600>>>>>>>>>>>>>>>        Integer iLen
76600>>>>>>>>>>>>>>>        Boolean bOk
76600>>>>>>>>>>>>>>>        
76600>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76601>>>>>>>>>>>>>>>        If (hProv) Begin
76603>>>>>>>>>>>>>>>            // Create key
76603>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76604>>>>>>>>>>>>>>>            If (hKey) Begin
76606>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76607>>>>>>>>>>>>>>>                If (bOk) Begin
76609>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76610>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76611>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76612>>>>>>>>>>>>>>>                End
76612>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76613>>>>>>>>>>>>>>>            End
76613>>>>>>>>>>>>>>>>
76613>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76614>>>>>>>>>>>>>>>        End
76614>>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>        Function_Return ucData
76615>>>>>>>>>>>>>>>    End_Function
76616>>>>>>>>>>>>>>>    
76616>>>>>>>>>>>>>>>    
76616>>>>>>>>>>>>>>>    //  Generates random data.
76616>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76618>>>>>>>>>>>>>>>        Handle hProv
76618>>>>>>>>>>>>>>>        UChar[] uaResult
76619>>>>>>>>>>>>>>>        Boolean bRes
76619>>>>>>>>>>>>>>>        
76619>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76620>>>>>>>>>>>>>>>        
76620>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76621>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76622>>>>>>>>>>>>>>>        
76622>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76623>>>>>>>>>>>>>>>        
76623>>>>>>>>>>>>>>>        Function_Return uaResult
76624>>>>>>>>>>>>>>>    End_Function
76625>>>>>>>>>>>>>>>    
76625>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76625>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76627>>>>>>>>>>>>>>>        String sResult
76627>>>>>>>>>>>>>>>        UChar[] ucData
76628>>>>>>>>>>>>>>>        Pointer pBase64
76628>>>>>>>>>>>>>>>        Integer iVoid
76628>>>>>>>>>>>>>>>        
76628>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76629>>>>>>>>>>>>>>>        
76629>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76630>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76631>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76632>>>>>>>>>>>>>>>        
76632>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76633>>>>>>>>>>>>>>>    End_Function
76634>>>>>>>>>>>>>>>    
76634>>>>>>>>>>>>>>>End_Class
76635>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76635>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76635>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76635>>>>>>>>>>>>>>>//> strings.
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76635>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76635>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76635>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76635>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76635>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>Use VdfBase.pkg
76635>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76635>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76636>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76637>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>// Structure
76638>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76638>>>>>>>>>>>>>>>    Pointer pData
76638>>>>>>>>>>>>>>>    Integer iLength
76638>>>>>>>>>>>>>>>End_Struct 
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76640>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76641>>>>>>>>>>>>>>>
76641>>>>>>>>>>>>>>>
76641>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76644>>>>>>>>>>>>>>>        Address pBase64
76644>>>>>>>>>>>>>>>        String sResult
76644>>>>>>>>>>>>>>>        Integer iVoid
76644>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76645>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76646>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76647>>>>>>>>>>>>>>>        Function_Return sResult
76648>>>>>>>>>>>>>>>    End_Function
76649>>>>>>>>>>>>>>>
76649>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76652>>>>>>>>>>>>>>>        Address pBinary
76652>>>>>>>>>>>>>>>        String sBinary
76652>>>>>>>>>>>>>>>        Integer iVoid iLen
76652>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76653>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76654>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76655>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76656>>>>>>>>>>>>>>>        Function_Return sBinary
76657>>>>>>>>>>>>>>>    End_Function
76658>>>>>>>>>>>>>>>
76658>>>>>>>>>>>>>>>End_Object
76659>>>>>>>>>>>>>Use MSSqldrv.pkg
76659>>>>>>>>>>>>>Use db2_drv.pkg
76659>>>>>>>>>>>>>Use odbc_drv.pkg
76659>>>>>>>>>>>>>Use DFBtrDrv.pkg
76659>>>>>>>>>>>>>Use vWin32fh.pkg
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76659>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76659>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76659>>>>>>>>>>>>>// Note: If a new type is added to the list,
76659>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76659>>>>>>>>>>>>>//       so that it is filled with all SQL
76659>>>>>>>>>>>>>//       keywords for that new type.
76659>>>>>>>>>>>>>Enum_List  
76659>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76659>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76659>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76659>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76659>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76659>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76659>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76659>>>>>>>>>>>>>End_Enum_List
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76659>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76659>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76659>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76659>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76659>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76659>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76659>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76659>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76659>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// SQLConnection.ini constants:
76659>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76659>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76659>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76659>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// DF 19 ini-file settings:
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76659>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76659>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76659>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76659>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76659>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76659>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76659>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76659>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76659>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76659>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Database Update Framework extended settings:
76659>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76659>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76659>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76659>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tSQLConnection
76659>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76659>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76659>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76659>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76659>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76659>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76659>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76659>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76659>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76659>>>>>>>>>>>>>    String sPassword                // 10. Password
76659>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76659>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76659>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76659>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76659>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76659>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76659>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tFilelist
76659>>>>>>>>>>>>>    String sRootName
76659>>>>>>>>>>>>>    String sLogicalName
76659>>>>>>>>>>>>>    String sDisplayName    
76659>>>>>>>>>>>>>    String sNoDriverRootname
76659>>>>>>>>>>>>>    String sDriver
76659>>>>>>>>>>>>>    Handle hTable
76659>>>>>>>>>>>>>    Boolean bIsSystemFile 
76659>>>>>>>>>>>>>    Boolean bErrorOpening
76659>>>>>>>>>>>>>    Boolean bIsAlias
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tFilelistLogicalName
76659>>>>>>>>>>>>>    String sLogicalName
76659>>>>>>>>>>>>>    String sNoDriverRootname
76659>>>>>>>>>>>>>    String sRootName
76659>>>>>>>>>>>>>    String sDisplayName    
76659>>>>>>>>>>>>>    String sDriver
76659>>>>>>>>>>>>>    Handle hTable
76659>>>>>>>>>>>>>    Boolean bIsSystemFile 
76659>>>>>>>>>>>>>    Boolean bErrorOpening
76659>>>>>>>>>>>>>    Boolean bIsAlias
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76659>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76659>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76659>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76659>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLScriptArray
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76660>>>>>>>>>>>>>    Integer iOrgArgumentSize
76660>>>>>>>>>>>>>    String[] sSQLScriptArray
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSqlErrorArray
76660>>>>>>>>>>>>>    String[]  sSqlErrorArray
76660>>>>>>>>>>>>>    String[]  sSqlStatementArray
76660>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSqlColumnNew
76660>>>>>>>>>>>>>    String  sBaseColumnName
76660>>>>>>>>>>>>>    String  sBaseTableName
76660>>>>>>>>>>>>>    String  sLabel
76660>>>>>>>>>>>>>    Integer iSqlType
76660>>>>>>>>>>>>>    Integer iSize
76660>>>>>>>>>>>>>    Integer iPrecision
76660>>>>>>>>>>>>>    Integer iDFType
76660>>>>>>>>>>>>>    Integer iDFNativeType
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tColumnType
76660>>>>>>>>>>>>>    Integer iSQLType
76660>>>>>>>>>>>>>    String  sSQLType
76660>>>>>>>>>>>>>    Boolean bCanEditSize
76660>>>>>>>>>>>>>    Integer iDefaultSize
76660>>>>>>>>>>>>>    Integer iMinSize
76660>>>>>>>>>>>>>    Number  nMaxSize
76660>>>>>>>>>>>>>    String  sDataFlexType
76660>>>>>>>>>>>>>    Integer iDataFlexType
76660>>>>>>>>>>>>>    Boolean bNativeDataType
76660>>>>>>>>>>>>>    String  sPrecision
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76660>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76660>>>>>>>>>>>>>// keywords.
76660>>>>>>>>>>>>>Struct tSQLKeyWords
76660>>>>>>>>>>>>>    Integer iSQLWord
76660>>>>>>>>>>>>>    Integer iSQLDbType
76660>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLRelation
76660>>>>>>>>>>>>>    Integer iFileNumber
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFileName
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLLoggedInUser
76660>>>>>>>>>>>>>    String sUser
76660>>>>>>>>>>>>>    String sProgram
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76660>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76660>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76660>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76660>>>>>>>>>>>>>// Note: If a new type is added to the list,
76660>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76660>>>>>>>>>>>>>//       so that it is filled with all SQL
76660>>>>>>>>>>>>>//       keywords for that new type.
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76660>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76660>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76660>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76660>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76660>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76660>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76660>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76660>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76660>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76660>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76660>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76660>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76660>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76660>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76660>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76660>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76660>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76660>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76660>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76660>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76660>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76660>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// These are not defined pre DF 18:
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLIntTableInfo
76660>>>>>>>>>>>>>    String sDriverName
76660>>>>>>>>>>>>>    String sServerName
76660>>>>>>>>>>>>>    String sDatabaseName
76660>>>>>>>>>>>>>    String sSchemaName
76660>>>>>>>>>>>>>    Boolean bRecnumTable
76660>>>>>>>>>>>>>    Integer iPrimaryIndex
76660>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76660>>>>>>>>>>>>>    String sTableCharacterFormat
76660>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76660>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76660>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76660>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76660>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76660>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76660>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76660>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76660>>>>>>>>>>>>>    String sFileIndexTablespace
76660>>>>>>>>>>>>>    String sFileLongTablespace
76660>>>>>>>>>>>>>    String sTableTablespace
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    Integer iFieldIndex
76660>>>>>>>>>>>>>    Integer iFieldRelatedFile
76660>>>>>>>>>>>>>    Integer iFieldRelatedField
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    Integer iIndexNumberSegments
76660>>>>>>>>>>>>>    Integer iIndexSegmentField1
76660>>>>>>>>>>>>>    Integer iIndexSegmentField2
76660>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76660>>>>>>>>>>>>>    String  sIndexName
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIColumn
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>    Integer iType
76660>>>>>>>>>>>>>    String  sType
76660>>>>>>>>>>>>>    Integer iLength
76660>>>>>>>>>>>>>    Integer iPrecision
76660>>>>>>>>>>>>>    Integer iOptions
76660>>>>>>>>>>>>>    Boolean bIsSQLType
76660>>>>>>>>>>>>>    Boolean bAllowNULL
76660>>>>>>>>>>>>>    String  sDefaultValue
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIColumnCompare
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sFieldNameFrom
76660>>>>>>>>>>>>>    Integer iTypeFrom
76660>>>>>>>>>>>>>    String  sTypeFrom
76660>>>>>>>>>>>>>    Integer iLengthFrom
76660>>>>>>>>>>>>>    Integer iPrecisionFrom
76660>>>>>>>>>>>>>    Integer iOptionsFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76660>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76660>>>>>>>>>>>>>    String  sDefaultValueFrom
76660>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76660>>>>>>>>>>>>>    Boolean bCancelFrom
76660>>>>>>>>>>>>>    Boolean bErrorFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    Integer iFieldNumberTo
76660>>>>>>>>>>>>>    String  sFieldNameTo
76660>>>>>>>>>>>>>    Integer iTypeTo
76660>>>>>>>>>>>>>    String  sTypeTo
76660>>>>>>>>>>>>>    Integer iLengthTo
76660>>>>>>>>>>>>>    Integer iPrecisionTo
76660>>>>>>>>>>>>>    Integer iOptionsTo
76660>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76660>>>>>>>>>>>>>    Boolean bAllowNULLTo
76660>>>>>>>>>>>>>    String  sDefaultValueTo
76660>>>>>>>>>>>>>    Boolean bShouldChangeTo
76660>>>>>>>>>>>>>    Boolean bCancelTo
76660>>>>>>>>>>>>>    Boolean bErrorTo
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIRelation
76660>>>>>>>>>>>>>    Handle  hTableFrom
76660>>>>>>>>>>>>>    Integer iColumnFrom
76660>>>>>>>>>>>>>    Handle  hTableTo
76660>>>>>>>>>>>>>    Integer iColumnTo
76660>>>>>>>>>>>>>    String  sLogicalNameFrom
76660>>>>>>>>>>>>>    String  sLogicalNameTo
76660>>>>>>>>>>>>>    String  sFieldNameFrom
76660>>>>>>>>>>>>>    String  sFieldNameTo
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIRelationCompare
76660>>>>>>>>>>>>>    // Common:
76660>>>>>>>>>>>>>    Handle  hTableFrom
76660>>>>>>>>>>>>>    Integer iColumnFrom
76660>>>>>>>>>>>>>    Handle  hTableTo
76660>>>>>>>>>>>>>    Integer iColumnTo
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76660>>>>>>>>>>>>>    String  sLogicalNameTo_From
76660>>>>>>>>>>>>>    String  sFieldNameFrom_From
76660>>>>>>>>>>>>>    String  sFieldNameTo_From
76660>>>>>>>>>>>>>    Boolean bShouldChange_From
76660>>>>>>>>>>>>>    Boolean bCancel_From
76660>>>>>>>>>>>>>    Boolean bError_From
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76660>>>>>>>>>>>>>    String  sLogicalNameTo_To
76660>>>>>>>>>>>>>    String  sFieldNameFrom_To
76660>>>>>>>>>>>>>    String  sFieldNameTo_To
76660>>>>>>>>>>>>>    Boolean bShouldChange_To
76660>>>>>>>>>>>>>    Boolean bCancel_To
76660>>>>>>>>>>>>>    Boolean bError_To
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndexSegment
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>    Boolean bUppercase
76660>>>>>>>>>>>>>    Boolean bAscending
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndex
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    Integer iPrimaryIndex
76660>>>>>>>>>>>>>    String  sSQLIndexName
76660>>>>>>>>>>>>>    Integer iSQLIndexType
76660>>>>>>>>>>>>>    Boolean bIsSQLClustered
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndexCompare
76660>>>>>>>>>>>>>    // Common:
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76660>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76660>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76660>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76660>>>>>>>>>>>>>    Boolean bCancelFrom
76660>>>>>>>>>>>>>    Boolean bErrorFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76660>>>>>>>>>>>>>    String  sSQLIndexNameTo
76660>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76660>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76660>>>>>>>>>>>>>    Boolean bShouldChangeTo
76660>>>>>>>>>>>>>    Boolean bCancelTo
76660>>>>>>>>>>>>>    Boolean bErrorTo
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableNameInfo
76660>>>>>>>>>>>>>    Integer iTableNumber
76660>>>>>>>>>>>>>    String  sRootName
76660>>>>>>>>>>>>>    String  sLogicalName
76660>>>>>>>>>>>>>    String  sDisplayName
76660>>>>>>>>>>>>>    String  sDriverID
76660>>>>>>>>>>>>>    Boolean bIsAlias
76660>>>>>>>>>>>>>    Boolean bIsSQL
76660>>>>>>>>>>>>>    Boolean bIsSystemFile
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76660>>>>>>>>>>>>>    Integer iTableNumber
76660>>>>>>>>>>>>>    // FROM
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sRootNameFrom
76660>>>>>>>>>>>>>    String  sLogicalNameFrom
76660>>>>>>>>>>>>>    String  sDisplayNameFrom
76660>>>>>>>>>>>>>    String  sDriverIDFrom
76660>>>>>>>>>>>>>    Boolean bIsAliasFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLFrom
76660>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    String  sRootNameTo
76660>>>>>>>>>>>>>    String  sLogicalNameTo
76660>>>>>>>>>>>>>    String  sDisplayNameTo
76660>>>>>>>>>>>>>    String  sDriverIDTo
76660>>>>>>>>>>>>>    Boolean bIsAliasTo
76660>>>>>>>>>>>>>    Boolean bIsSQLTo
76660>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITable
76660>>>>>>>>>>>>>    Handle hTable
76660>>>>>>>>>>>>>    Boolean bFromTable
76660>>>>>>>>>>>>>    Boolean bToTable
76660>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76660>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76660>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76660>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76660>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76660>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76660>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76660>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableCompare
76660>>>>>>>>>>>>>    Handle hTable
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    // Both:
76660>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76660>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76660>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76660>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76660>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76660>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76660>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76660>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76660>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76660>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76660>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableBooleans
76660>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76660>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76660>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76660>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76660>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76660>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76660>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76660>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76660>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76660>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76660>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76660>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76660>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76660>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76660>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76660>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76660>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76660>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76660>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76660>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76660>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76660>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76660>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76660>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76660>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76660>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76660>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76660>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76660>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76660>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76660>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76660>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76660>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76660>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76660>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76660>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76660>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76660>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76660>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76660>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76660>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76660>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76660>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76660>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76660>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76660>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>
76660>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76661>>>>>>>>>>>
76661>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76663>>>>>>>>>>>        Handle hoSQLManagerMT
76663>>>>>>>>>>>
76663>>>>>>>>>>>        Property String private.psUseDatabase ""
76664>>>>>>>>>>>
76664>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76664>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76665>>>>>>>>>>>        Property Integer private.piCurrentField 0
76666>>>>>>>>>>>
76666>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76667>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76668>>>>>>>>>>>
76668>>>>>>>>>>>        Property Handle phoSQLManagerMT
76669>>>>>>>>>>>
76669>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76670>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76671>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76672>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76673>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76674>>>>>>>>>>>
76674>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76675>>>>>>>>>>>
76675>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76676>>>>>>>>>>>        Property String[] paSQLFetchResults
76677>>>>>>>>>>>
76677>>>>>>>>>>>        // Error handling
76677>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76678>>>>>>>>>>>        Property Boolean pbSqlError False
76679>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76680>>>>>>>>>>>        Property Boolean pbProcessingError False
76681>>>>>>>>>>>
76681>>>>>>>>>>>        // Statistics on query
76681>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76682>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76683>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76684>>>>>>>>>>>        Property Integer piColumns 0
76685>>>>>>>>>>>        Property Integer piRows 0
76686>>>>>>>>>>>        Property Integer piRowType 0
76687>>>>>>>>>>>        Property String[] paQueryMessages
76688>>>>>>>>>>>        Property String psSQLStatementString
76689>>>>>>>>>>>
76689>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76690>>>>>>>>>>>
76690>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76691>>>>>>>>>>>
76691>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76691>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76691>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76691>>>>>>>>>>>        Property Integer piChunkMax 500
76692>>>>>>>>>>>
76692>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76692>>>>>>>>>>>        Send SetupSQLKeywordArray
76693>>>>>>>>>>>    End_Procedure
76694>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76694>>>>>>>>>>>>
76694>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76696>>>>>>>>>>>>    Integer iStart iEnd
76696>>>>>>>>>>>>    String sRetval
76696>>>>>>>>>>>>
76696>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76697>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76698>>>>>>>>>>>>    If (iStart = 0) Begin
76700>>>>>>>>>>>>        Function_Return ""
76701>>>>>>>>>>>>    End
76701>>>>>>>>>>>>>
76701>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76702>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76703>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76705>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76706>>>>>>>>>>>>    End
76706>>>>>>>>>>>>>
76706>>>>>>>>>>>>    Else Begin
76707>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76708>>>>>>>>>>>>    End
76708>>>>>>>>>>>>>
76708>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76710>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76711>>>>>>>>>>>>        Decrement iEnd
76712>>>>>>>>>>>>    End
76712>>>>>>>>>>>>>
76712>>>>>>>>>>>>    If (iEnd <> 0) Begin
76714>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76715>>>>>>>>>>>>    End
76715>>>>>>>>>>>>>
76715>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76716>>>>>>>>>>>>
76716>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76717>>>>>>>>>>>>End_Function
76718>>>>>>>>>>>>
76718>>>>>>>>>>>>
76718>>>>>>>>>>>
76718>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76718>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76720>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76722>>>>>>>>>>>            Function_Return (EQ)
76723>>>>>>>>>>>        End
76723>>>>>>>>>>>>
76723>>>>>>>>>>>        Function_Return (GT)
76724>>>>>>>>>>>    End_Function
76725>>>>>>>>>>>
76725>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76725>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76727>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76730>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76733>>>>>>>>>>>
76733>>>>>>>>>>>        Function_Return (EQ)
76734>>>>>>>>>>>    End_Function
76735>>>>>>>>>>>
76735>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76737>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76737>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76738>>>>>>>>>>>        Integer iSize
76738>>>>>>>>>>>
76738>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76739>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76740>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76741>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76742>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76743>>>>>>>>>>>
76743>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76744>>>>>>>>>>>    End_Procedure
76745>>>>>>>>>>>
76745>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76745>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76745>>>>>>>>>>>    // have slightly different wording.
76745>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76745>>>>>>>>>>>    // needs to be done for every keyword group below.
76745>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76747>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76747>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76749>>>>>>>>>>>
76749>>>>>>>>>>>        // This should only be called once; but in case it is
76749>>>>>>>>>>>        // we delete the array first.
76749>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76750>>>>>>>>>>>
76750>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76750>>>>>>>>>>>        //
76750>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76751>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76752>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76753>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76754>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76755>>>>>>>>>>>
76755>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76756>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76757>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76758>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76759>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76760>>>>>>>>>>>
76760>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76761>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76762>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76763>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76764>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76765>>>>>>>>>>>
76765>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76766>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76767>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76768>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76769>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76770>>>>>>>>>>>
76770>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76771>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76772>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76773>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76774>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76775>>>>>>>>>>>
76775>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76776>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76777>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76778>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76779>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76780>>>>>>>>>>>
76780>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76781>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76782>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76783>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76784>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76785>>>>>>>>>>>
76785>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76786>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76787>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76788>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76789>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76790>>>>>>>>>>>
76790>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76791>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76792>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76793>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76794>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76795>>>>>>>>>>>
76795>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76796>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76797>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76798>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76799>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76800>>>>>>>>>>>
76800>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76801>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76802>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76803>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76804>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76805>>>>>>>>>>>
76805>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76806>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76807>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76808>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76809>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76810>>>>>>>>>>>
76810>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76811>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76812>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76813>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76814>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76815>>>>>>>>>>>
76815>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76819>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76820>>>>>>>>>>>
76820>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76821>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76822>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76823>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76824>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76825>>>>>>>>>>>
76825>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76826>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76827>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76828>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76829>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76830>>>>>>>>>>>
76830>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76831>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76832>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76833>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76834>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76835>>>>>>>>>>>
76835>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76836>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76837>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76838>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76839>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76840>>>>>>>>>>>
76840>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76841>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76842>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76844>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76845>>>>>>>>>>>
76845>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76846>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76847>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76848>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76849>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76850>>>>>>>>>>>
76850>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76851>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76852>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76853>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76854>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76855>>>>>>>>>>>
76855>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76856>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76857>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76858>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76859>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76860>>>>>>>>>>>
76860>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76861>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76862>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76863>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76864>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76865>>>>>>>>>>>
76865>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76866>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76867>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76868>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76869>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76870>>>>>>>>>>>
76870>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76871>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76872>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76873>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76875>>>>>>>>>>>
76875>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76876>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76877>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76878>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76879>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76880>>>>>>>>>>>
76880>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76881>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76882>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76883>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76884>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76885>>>>>>>>>>>
76885>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76886>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76887>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76888>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76889>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76890>>>>>>>>>>>
76890>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76891>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76892>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76893>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76894>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76895>>>>>>>>>>>
76895>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76896>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76897>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76898>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76899>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76900>>>>>>>>>>>
76900>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76901>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76902>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76903>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76904>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76905>>>>>>>>>>>
76905>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76906>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76907>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76908>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76909>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76910>>>>>>>>>>>
76910>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76911>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76912>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76913>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76914>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76915>>>>>>>>>>>
76915>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76916>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76917>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76918>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76919>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76920>>>>>>>>>>>
76920>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76921>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76922>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76923>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76924>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76925>>>>>>>>>>>
76925>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76926>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76927>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76928>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76929>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76930>>>>>>>>>>>
76930>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76931>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76932>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76933>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76934>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76935>>>>>>>>>>>
76935>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76936>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76937>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76938>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76939>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76940>>>>>>>>>>>
76940>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76941>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76942>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76943>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76944>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76945>>>>>>>>>>>
76945>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76946>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76947>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76948>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76949>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76950>>>>>>>>>>>
76950>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76951>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76952>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76953>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76954>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76955>>>>>>>>>>>
76955>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76956>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76957>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76958>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76959>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76960>>>>>>>>>>>
76960>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76961>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76962>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76963>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76964>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76965>>>>>>>>>>>
76965>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76966>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76967>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76968>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76969>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76970>>>>>>>>>>>
76970>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76970>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76971>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76972>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76973>>>>>>>>>>>
76973>>>>>>>>>>>    End_Procedure
76974>>>>>>>>>>>
76974>>>>>>>>>>>End_Class
76975>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76975>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>// $Module type: Class
76975>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76975>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76975>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76975>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76975>>>>>>>>>>>//
76975>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76975>>>>>>>>>>>//
76975>>>>>>>>>>>// $Rev History:
76975>>>>>>>>>>>//    2015-08-11  Module header created
76975>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76975>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76975>>>>>>>>>>>//                Added better error handling.
76975>>>>>>>>>>>//                Added a decompose message for the connection string.
76975>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76975>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76975>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76975>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76975>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76975>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76975>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>Use cli.pkg
76975>>>>>>>>>>>Use MSSqldrv.pkg
76975>>>>>>>>>>>Use db2_drv.pkg
76975>>>>>>>>>>>Use odbc_drv.pkg
76975>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76975>>>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>>>// $Module type: Class
76975>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76975>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76975>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76975>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76975>>>>>>>>>>>>>//               properties of that object.
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76975>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76975>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76975>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76975>>>>>>>>>>>>>// in the help folder for more details.
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76975>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76975>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76975>>>>>>>>>>>>>>>
76975>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76976>>>>>>>>>>>>>>>    Procedure Construct_Object
76978>>>>>>>>>>>>>>>        Forward Send Construct_Object
76980>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76981>>>>>>>>>>>>>>>    End_Procedure
76982>>>>>>>>>>>>>>>
76982>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76984>>>>>>>>>>>>>>>        String sRetval
76984>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76986>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76987>>>>>>>>>>>>>>>        End                                        
76987>>>>>>>>>>>>>>>>
76987>>>>>>>>>>>>>>>        Else Begin
76988>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76989>>>>>>>>>>>>>>>        End
76989>>>>>>>>>>>>>>>>
76989>>>>>>>>>>>>>>>            
76989>>>>>>>>>>>>>>>        Function_Return sRetval
76990>>>>>>>>>>>>>>>    End_Function
76991>>>>>>>>>>>>>>>
76991>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76993>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76993>>>>>>>>>>>>>>>        Integer iClientVersion
76993>>>>>>>>>>>>>>>        
76993>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76994>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76995>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76996>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76998>>>>>>>>>>>>>>>            Move "" to sDatabase
76999>>>>>>>>>>>>>>>        End
76999>>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>        
76999>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77001>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77002>>>>>>>>>>>>>>>        End
77002>>>>>>>>>>>>>>>>
77002>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77004>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77005>>>>>>>>>>>>>>>        End
77005>>>>>>>>>>>>>>>>
77005>>>>>>>>>>>>>>>        Else Begin
77006>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77007>>>>>>>>>>>>>>>        End
77007>>>>>>>>>>>>>>>>
77007>>>>>>>>>>>>>>>        
77007>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77009>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77010>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
77012>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77013>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
77014>>>>>>>>>>>>>>>            End
77014>>>>>>>>>>>>>>>>
77014>>>>>>>>>>>>>>>        End
77014>>>>>>>>>>>>>>>>
77014>>>>>>>>>>>>>>>        
77014>>>>>>>>>>>>>>>        Function_Return sConnect
77015>>>>>>>>>>>>>>>    End_Function
77016>>>>>>>>>>>>>>>
77016>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77018>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77018>>>>>>>>>>>>>>>        String sDriverID
77018>>>>>>>>>>>>>>>
77018>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77019>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77021>>>>>>>>>>>>>>>            Function_Return True
77022>>>>>>>>>>>>>>>        End
77022>>>>>>>>>>>>>>>>
77022>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77023>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77025>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77026>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77028>>>>>>>>>>>>>>>        End
77028>>>>>>>>>>>>>>>>
77028>>>>>>>>>>>>>>>        Else Begin
77029>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77031>>>>>>>>>>>>>>>        End
77031>>>>>>>>>>>>>>>>
77031>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77032>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77033>>>>>>>>>>>>>>>    End_Function
77034>>>>>>>>>>>>>>>
77034>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77036>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77036>>>>>>>>>>>>>>>        String sDriver
77036>>>>>>>>>>>>>>>        
77036>>>>>>>>>>>>>>>        Move 0 to iDriver
77037>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77040>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77042>>>>>>>>>>>>>>>            Load_Driver sDriverID
77043>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77046>>>>>>>>>>>>>>>        End
77046>>>>>>>>>>>>>>>>
77046>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77052>>>>>>>>>>>>>>>>
77052>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77055>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77057>>>>>>>>>>>>>>>                Move iCount to iDriver
77058>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77059>>>>>>>>>>>>>>>            End
77059>>>>>>>>>>>>>>>>
77059>>>>>>>>>>>>>>>        Loop
77060>>>>>>>>>>>>>>>>
77060>>>>>>>>>>>>>>>    
77060>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77060>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77062>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77065>>>>>>>>>>>>>>>        End
77065>>>>>>>>>>>>>>>>
77065>>>>>>>>>>>>>>>        Function_Return iClientVersion
77066>>>>>>>>>>>>>>>    End_Function
77067>>>>>>>>>>>>>>>    
77067>>>>>>>>>>>>>>>End_Class
77068>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77069>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77071>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77072>>>>>>>>>>>>>>>    End_Function
77073>>>>>>>>>>>>>>>
77073>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77075>>>>>>>>>>>>>>>        Integer iClientVersion
77075>>>>>>>>>>>>>>>        String sConnect
77075>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77075>>>>>>>>>>>>>>>        
77075>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77076>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77078>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77079>>>>>>>>>>>>>>>        End
77079>>>>>>>>>>>>>>>>
77079>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77081>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77082>>>>>>>>>>>>>>>        End
77082>>>>>>>>>>>>>>>>
77082>>>>>>>>>>>>>>>        Else Begin
77083>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77084>>>>>>>>>>>>>>>        End
77084>>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77085>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77087>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77088>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77089>>>>>>>>>>>>>>>        End
77089>>>>>>>>>>>>>>>>
77089>>>>>>>>>>>>>>>        
77089>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77091>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77092>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77093>>>>>>>>>>>>>>>    End_Function
77094>>>>>>>>>>>>>>>
77094>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77096>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77096>>>>>>>>>>>>>>>        String sDriver
77096>>>>>>>>>>>>>>>        
77096>>>>>>>>>>>>>>>        Move 0 to iDriver
77097>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77100>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77102>>>>>>>>>>>>>>>            Load_Driver sDriverID
77103>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77106>>>>>>>>>>>>>>>        End
77106>>>>>>>>>>>>>>>>
77106>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77112>>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77115>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77117>>>>>>>>>>>>>>>                Move iCount to iDriver
77118>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77119>>>>>>>>>>>>>>>            End
77119>>>>>>>>>>>>>>>>
77119>>>>>>>>>>>>>>>        Loop
77120>>>>>>>>>>>>>>>>
77120>>>>>>>>>>>>>>>    
77120>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77120>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77122>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77125>>>>>>>>>>>>>>>        End
77125>>>>>>>>>>>>>>>>
77125>>>>>>>>>>>>>>>        Function_Return iClientVersion
77126>>>>>>>>>>>>>>>    End_Function
77127>>>>>>>>>>>>>>>    
77127>>>>>>>>>>>>>>>End_Class
77128>>>>>>>>>>>>>>>
77128>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77129>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77131>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77131>>>>>>>>>>>>>>>        String sDriverID
77131>>>>>>>>>>>>>>>
77131>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77132>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77133>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77135>>>>>>>>>>>>>>>            Function_Return True
77136>>>>>>>>>>>>>>>        End
77136>>>>>>>>>>>>>>>>
77136>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77137>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77139>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77141>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77142>>>>>>>>>>>>>>>            End
77142>>>>>>>>>>>>>>>>
77142>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77145>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77146>>>>>>>>>>>>>>>            End
77146>>>>>>>>>>>>>>>>
77146>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77148>>>>>>>>>>>>>>>        End
77148>>>>>>>>>>>>>>>>
77148>>>>>>>>>>>>>>>        Else Begin
77149>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77151>>>>>>>>>>>>>>>        End
77151>>>>>>>>>>>>>>>>
77151>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77152>>>>>>>>>>>>>>>
77152>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77153>>>>>>>>>>>>>>>    End_Function
77154>>>>>>>>>>>>>>>End_Class
77155>>>>>>>>>>>>>>>
77155>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77156>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77158>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77158>>>>>>>>>>>>>>>        String sDriverID
77158>>>>>>>>>>>>>>>
77158>>>>>>>>>>>>>>>        Move False to Err
77159>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77160>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77162>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77163>>>>>>>>>>>>>>>        End
77163>>>>>>>>>>>>>>>>
77163>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77166>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77167>>>>>>>>>>>>>>>    End_Function
77168>>>>>>>>>>>>>>>End_Class
77169>>>>>>>>>>>>>>>
77169>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77170>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77172>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77172>>>>>>>>>>>>>>>        String sDriverID
77172>>>>>>>>>>>>>>>
77172>>>>>>>>>>>>>>>        Move False to Err
77173>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77174>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77174>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77174>>>>>>>>>>>>>>>//        End
77174>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77176>>>>>>>>>>>>>>>
77176>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77177>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77178>>>>>>>>>>>>>>>    End_Function
77179>>>>>>>>>>>>>>>End_Class
77180>>>>>>>>>>>>>>>
77180>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77181>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77183>>>>>>>>>>>>>>>        Function_Return ""
77184>>>>>>>>>>>>>>>    End_Function
77185>>>>>>>>>>>>>>>End_Class
77186>>>>>>>>>>>>>>>
77186>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77187>>>>>>>>>>>>>>>    Procedure Construct_Object
77189>>>>>>>>>>>>>>>        Forward Send Construct_Object
77191>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77192>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77193>>>>>>>>>>>>>>>    End_Procedure
77194>>>>>>>>>>>>>>>
77194>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77196>>>>>>>>>>>>>>>        String sDriverID sObjectName
77196>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77196>>>>>>>>>>>>>>>
77196>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77197>>>>>>>>>>>>>>>        Case Begin
77197>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77199>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77200>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77201>>>>>>>>>>>>>>>                Case Break
77202>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77205>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77206>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77207>>>>>>>>>>>>>>>                Case Break
77208>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77211>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77212>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77213>>>>>>>>>>>>>>>                Case Break               
77214>>>>>>>>>>>>>>>            Case Else
77214>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77214>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77215>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77216>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77217>>>>>>>>>>>>>>>        Case End
77217>>>>>>>>>>>>>>>
77217>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77218>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77219>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77220>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77221>>>>>>>>>>>>>>>
77221>>>>>>>>>>>>>>>        Function_Return hoDriver
77222>>>>>>>>>>>>>>>    End_Function
77223>>>>>>>>>>>>>>>
77223>>>>>>>>>>>>>>>    Procedure DestroyDriver
77225>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77227>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77228>>>>>>>>>>>>>>>        End
77228>>>>>>>>>>>>>>>>
77228>>>>>>>>>>>>>>>    End_Procedure
77229>>>>>>>>>>>>>>>
77229>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77231>>>>>>>>>>>>>>>        String sConnect
77231>>>>>>>>>>>>>>>        Handle hoDriver
77231>>>>>>>>>>>>>>>
77231>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77232>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77234>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77235>>>>>>>>>>>>>>>        End
77235>>>>>>>>>>>>>>>>
77235>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77236>>>>>>>>>>>>>>>        Send DestroyDriver
77237>>>>>>>>>>>>>>>        Function_Return sConnect
77238>>>>>>>>>>>>>>>    End_Function
77239>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77241>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77241>>>>>>>>>>>>>>>        Handle hoDriver
77241>>>>>>>>>>>>>>>
77241>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77242>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77244>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77245>>>>>>>>>>>>>>>        End
77245>>>>>>>>>>>>>>>>
77245>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77246>>>>>>>>>>>>>>>        Send DestroyDriver
77247>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77248>>>>>>>>>>>>>>>    End_Function
77249>>>>>>>>>>>>>>>
77249>>>>>>>>>>>>>>>End_Class
77250>>>>>>>>>>>>>
77250>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77250>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77250>>>>>>>>>>>>>>>
77250>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77251>>>>>>>>>>>>>>>    
77251>>>>>>>>>>>>>>>    Procedure Construct_Object
77253>>>>>>>>>>>>>>>        Forward Send Construct_Object
77255>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77255>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77256>>>>>>>>>>>>>>>        
77256>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77258>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77259>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77260>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77261>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77262>>>>>>>>>>>>>>>        End_Object
77263>>>>>>>>>>>>>>>    End_Procedure
77264>>>>>>>>>>>>>>>    
77264>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77264>>>>>>>>>>>>>>>    // hidden mechanism desired.
77264>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77266>>>>>>>>>>>>>>>        String sPassword
77266>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77267>>>>>>>>>>>>>>>        Function_Return sPassword
77268>>>>>>>>>>>>>>>    End_Function
77269>>>>>>>>>>>>>>>    
77269>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77269>>>>>>>>>>>>>>>    //
77269>>>>>>>>>>>>>>>    // Params:
77269>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77269>>>>>>>>>>>>>>>    // Returns:
77269>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77269>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77271>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77271>>>>>>>>>>>>>>>        UChar[] ucBinary
77272>>>>>>>>>>>>>>>        Pointer pBase64
77272>>>>>>>>>>>>>>>        Integer iVoid
77272>>>>>>>>>>>>>>>        
77272>>>>>>>>>>>>>>>        //  Encrypt Key
77272>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77273>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77275>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77276>>>>>>>>>>>>>>>>
77276>>>>>>>>>>>>>>>        End
77276>>>>>>>>>>>>>>>>
77276>>>>>>>>>>>>>>>        
77276>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77277>>>>>>>>>>>>>>>        
77277>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77279>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77280>>>>>>>>>>>>>>>>
77280>>>>>>>>>>>>>>>            Function_Return ""
77281>>>>>>>>>>>>>>>        End
77281>>>>>>>>>>>>>>>>
77281>>>>>>>>>>>>>>>        
77281>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77281>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77282>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77283>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77284>>>>>>>>>>>>>>>        
77284>>>>>>>>>>>>>>>        Function_Return sBase64
77285>>>>>>>>>>>>>>>    End_Function
77286>>>>>>>>>>>>>>>    
77286>>>>>>>>>>>>>>>    
77286>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77286>>>>>>>>>>>>>>>    //
77286>>>>>>>>>>>>>>>    // Params:
77286>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77286>>>>>>>>>>>>>>>    // Returns:
77286>>>>>>>>>>>>>>>    //   Readable plain text password
77286>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77288>>>>>>>>>>>>>>>        String sEncryptPassword
77288>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77290>>>>>>>>>>>>>>>        Boolean bIsHex
77290>>>>>>>>>>>>>>>        Integer iLen iVoid
77290>>>>>>>>>>>>>>>        Pointer pBinary
77290>>>>>>>>>>>>>>>        
77290>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77292>>>>>>>>>>>>>>>            //  Decode from Base64
77292>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77293>>>>>>>>>>>>>>>            
77293>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77294>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77295>>>>>>>>>>>>>>>                        
77295>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77296>>>>>>>>>>>>>>>            
77296>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77296>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77297>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77298>>>>>>>>>>>>>>>        End
77298>>>>>>>>>>>>>>>>
77298>>>>>>>>>>>>>>>        
77298>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77299>>>>>>>>>>>>>>>    End_Function
77300>>>>>>>>>>>>>>>End_Class
77301>>>>>>>>>>>>>
77301>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77302>>>>>>>>>>>>>    Procedure Construct_Object
77304>>>>>>>>>>>>>        Forward Send Construct_Object
77306>>>>>>>>>>>>>
77306>>>>>>>>>>>>>        Property String Private_psIniFilePath
77307>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77308>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77309>>>>>>>>>>>>>
77309>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77310>>>>>>>>>>>>>
77310>>>>>>>>>>>>>        // *** You really want to change this value! ***
77310>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77310>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77311>>>>>>>>>>>>>
77311>>>>>>>>>>>>>    End_Procedure
77312>>>>>>>>>>>>>
77312>>>>>>>>>>>>>    Procedure End_Construct_Object
77314>>>>>>>>>>>>>        Forward Send End_Construct_Object
77316>>>>>>>>>>>>>    End_Procedure
77317>>>>>>>>>>>>>
77317>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77319>>>>>>>>>>>>>        String sIniFile
77319>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77320>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77321>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77322>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77323>>>>>>>>>>>>>    End_Procedure
77324>>>>>>>>>>>>>
77324>>>>>>>>>>>>>    Function psIniFilePath Returns String
77326>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77327>>>>>>>>>>>>>    End_Function
77328>>>>>>>>>>>>>
77328>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77330>>>>>>>>>>>>>        String sPath
77330>>>>>>>>>>>>>        Get psIniFilePath to sPath
77331>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77332>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77333>>>>>>>>>>>>>    End_Procedure
77334>>>>>>>>>>>>>
77334>>>>>>>>>>>>>    Function psIniFileName Returns String
77336>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77337>>>>>>>>>>>>>    End_Function
77338>>>>>>>>>>>>>
77338>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77338>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77338>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77338>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77340>>>>>>>>>>>>>        String sIniFile sPath
77340>>>>>>>>>>>>>
77340>>>>>>>>>>>>>        Get psIniFilePath to sPath
77341>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77342>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77343>>>>>>>>>>>>>        Set psFileName to sIniFile
77344>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77345>>>>>>>>>>>>>    End_Procedure
77346>>>>>>>>>>>>>
77346>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77346>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77346>>>>>>>>>>>>>    // Returns the value
77346>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77348>>>>>>>>>>>>>        String sValue sIniFile sPath
77348>>>>>>>>>>>>>
77348>>>>>>>>>>>>>        Get psIniFilePath to sPath
77349>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77350>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77351>>>>>>>>>>>>>        Set psFileName to sIniFile
77352>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77353>>>>>>>>>>>>>
77353>>>>>>>>>>>>>        Function_Return sValue
77354>>>>>>>>>>>>>    End_Function
77355>>>>>>>>>>>>>
77355>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77355>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77357>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77360>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77363>>>>>>>>>>>>>
77363>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77366>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77369>>>>>>>>>>>>>
77369>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77372>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77375>>>>>>>>>>>>>
77375>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77378>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77381>>>>>>>>>>>>>
77381>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77384>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77387>>>>>>>>>>>>>
77387>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77390>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77393>>>>>>>>>>>>>
77393>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77396>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77399>>>>>>>>>>>>>
77399>>>>>>>>>>>>>        Function_Return (EQ)
77400>>>>>>>>>>>>>    End_Function
77401>>>>>>>>>>>>>
77401>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77403>>>>>>>>>>>>>        Handle hoSections
77403>>>>>>>>>>>>>        Integer iItems
77403>>>>>>>>>>>>>
77403>>>>>>>>>>>>>        Send ReadSections hoSections
77404>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77405>>>>>>>>>>>>>        Function_Return iItems
77406>>>>>>>>>>>>>    End_Function
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>    // The normal connection string looks something like this;
77407>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77407>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77407>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77407>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77407>>>>>>>>>>>>>//        String sSection
77407>>>>>>>>>>>>>//        Integer iCount
77407>>>>>>>>>>>>>//
77407>>>>>>>>>>>>>//        Move False to Err
77407>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77407>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77407>>>>>>>>>>>>>//        Increment iCount
77407>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77407>>>>>>>>>>>>>//
77407>>>>>>>>>>>>>//        Function_Return (Err = False)
77407>>>>>>>>>>>>>//    End_Function
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77409>>>>>>>>>>>>>        Integer iCount
77409>>>>>>>>>>>>>        Boolean bExists
77409>>>>>>>>>>>>>        String sSection
77409>>>>>>>>>>>>>
77409>>>>>>>>>>>>>        Move False to Err
77410>>>>>>>>>>>>>        Move 1 to iCount
77411>>>>>>>>>>>>>        Get psIniSectionName to sSection
77412>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77413>>>>>>>>>>>>>        While (bExists = True)
77417>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77418>>>>>>>>>>>>>            Increment iCount
77419>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77420>>>>>>>>>>>>>        Loop
77421>>>>>>>>>>>>>>
77421>>>>>>>>>>>>>        Function_Return (Err = False)
77422>>>>>>>>>>>>>    End_Function
77423>>>>>>>>>>>>>
77423>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77425>>>>>>>>>>>>>        Integer iCount
77425>>>>>>>>>>>>>        String sSection
77425>>>>>>>>>>>>>        Boolean bExists
77425>>>>>>>>>>>>>
77425>>>>>>>>>>>>>        Move False to Err
77426>>>>>>>>>>>>>        Move 1 to iCount
77427>>>>>>>>>>>>>        Get psIniSectionName to sSection
77428>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77429>>>>>>>>>>>>>        While (bExists = True)
77433>>>>>>>>>>>>>            If (iCount = iItem) Begin
77435>>>>>>>>>>>>>                Send DeleteSection sSection
77436>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77436>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77437>>>>>>>>>>>>>            End
77437>>>>>>>>>>>>>>
77437>>>>>>>>>>>>>            Increment iCount
77438>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77439>>>>>>>>>>>>>        Loop
77440>>>>>>>>>>>>>>
77440>>>>>>>>>>>>>
77440>>>>>>>>>>>>>        Function_Return (Err = False)
77441>>>>>>>>>>>>>    End_Function
77442>>>>>>>>>>>>>
77442>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77442>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77442>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77444>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77444>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77445>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77445>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77445>>>>>>>>>>>>>        Integer iIndex
77445>>>>>>>>>>>>>
77445>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77446>>>>>>>>>>>>>        If (iIndex = -1) Begin
77448>>>>>>>>>>>>>            Move True to SQLConnection.bError
77449>>>>>>>>>>>>>            Function_Return SQLConnection
77450>>>>>>>>>>>>>        End
77450>>>>>>>>>>>>>>
77450>>>>>>>>>>>>>
77450>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77451>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77452>>>>>>>>>>>>>
77452>>>>>>>>>>>>>        Function_Return SQLConnection
77453>>>>>>>>>>>>>    End_Function
77454>>>>>>>>>>>>>
77454>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77454>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77456>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77456>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77457>>>>>>>>>>>>>        Integer iRetval iCount iSize
77457>>>>>>>>>>>>>        String sValue
77457>>>>>>>>>>>>>        Boolean bExists
77457>>>>>>>>>>>>>
77457>>>>>>>>>>>>>        Move -1 to iRetval
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77459>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77460>>>>>>>>>>>>>        Decrement iSize
77461>>>>>>>>>>>>>        For iCount from 0 to iSize
77467>>>>>>>>>>>>>>
77467>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77468>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77469>>>>>>>>>>>>>            If (bExists) Begin
77471>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77472>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77473>>>>>>>>>>>>>            End
77473>>>>>>>>>>>>>>
77473>>>>>>>>>>>>>        Loop
77474>>>>>>>>>>>>>>
77474>>>>>>>>>>>>>
77474>>>>>>>>>>>>>        Function_Return iRetval
77475>>>>>>>>>>>>>    End_Function
77476>>>>>>>>>>>>>
77476>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77476>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77476>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77478>>>>>>>>>>>>>        Integer iCount iSize iItems
77478>>>>>>>>>>>>>        String sValue
77478>>>>>>>>>>>>>        Boolean bExists
77478>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77478>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77479>>>>>>>>>>>>>
77479>>>>>>>>>>>>>        Move 0 to iItems
77480>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77481>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77482>>>>>>>>>>>>>        Decrement iSize
77483>>>>>>>>>>>>>        For iCount from 0 to iSize
77489>>>>>>>>>>>>>>
77489>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77490>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77491>>>>>>>>>>>>>            If (bExists) Begin
77493>>>>>>>>>>>>>                Increment iItems
77494>>>>>>>>>>>>>            End
77494>>>>>>>>>>>>>>
77494>>>>>>>>>>>>>        Loop
77495>>>>>>>>>>>>>>
77495>>>>>>>>>>>>>
77495>>>>>>>>>>>>>        Function_Return (iItems > 1)
77496>>>>>>>>>>>>>    End_Function
77497>>>>>>>>>>>>>
77497>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77497>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77499>>>>>>>>>>>>>        Boolean bOK
77499>>>>>>>>>>>>>        Integer iSize iCount
77499>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77499>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77500>>>>>>>>>>>>>        tSQLConnection SQLConnection
77500>>>>>>>>>>>>>        tSQLConnection SQLConnection
77500>>>>>>>>>>>>>        String sConnectionString
77500>>>>>>>>>>>>>
77500>>>>>>>>>>>>>        Move False to Err
77501>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77502>>>>>>>>>>>>>
77502>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77503>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77504>>>>>>>>>>>>>        Decrement iSize
77505>>>>>>>>>>>>>        // Set all current connection to inactive.
77505>>>>>>>>>>>>>        For iCount from 0 to iSize
77511>>>>>>>>>>>>>>
77511>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77512>>>>>>>>>>>>>        Loop
77513>>>>>>>>>>>>>>
77513>>>>>>>>>>>>>
77513>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77514>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77515>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77516>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77517>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77518>>>>>>>>>>>>>
77518>>>>>>>>>>>>>        Function_Return (bOK = True)
77519>>>>>>>>>>>>>    End_Function
77520>>>>>>>>>>>>>
77520>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77520>>>>>>>>>>>>>    // Returns True if successful.
77520>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77522>>>>>>>>>>>>>        Boolean bOK
77522>>>>>>>>>>>>>        Integer iItem iSize iCount
77522>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77522>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77523>>>>>>>>>>>>>
77523>>>>>>>>>>>>>        Move False to Err
77524>>>>>>>>>>>>>        Move -1 to iItem
77525>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77526>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77527>>>>>>>>>>>>>        Decrement iSize
77528>>>>>>>>>>>>>        // Set all current connection to inactive.
77528>>>>>>>>>>>>>        For iCount from 0 to iSize
77534>>>>>>>>>>>>>>
77534>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77535>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77537>>>>>>>>>>>>>                Move iCount to iItem
77538>>>>>>>>>>>>>            End
77538>>>>>>>>>>>>>>
77538>>>>>>>>>>>>>        Loop
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>
77539>>>>>>>>>>>>>        If (iItem <> -1) Begin
77541>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77542>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77543>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77544>>>>>>>>>>>>>        End
77544>>>>>>>>>>>>>>
77544>>>>>>>>>>>>>
77544>>>>>>>>>>>>>        Function_Return (bOK = True)
77545>>>>>>>>>>>>>    End_Function
77546>>>>>>>>>>>>>
77546>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77548>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77548>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77549>>>>>>>>>>>>>        String sSection sValue
77549>>>>>>>>>>>>>        Integer iCount
77549>>>>>>>>>>>>>        Boolean bExists
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>        Get psIniSectionName to sSection
77550>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77551>>>>>>>>>>>>>        If (bExists = False) Begin
77553>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77554>>>>>>>>>>>>>        End
77554>>>>>>>>>>>>>>
77554>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77555>>>>>>>>>>>>>        If (bExists = True) Begin
77557>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        End
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77559>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77560>>>>>>>>>>>>>
77560>>>>>>>>>>>>>        While (bExists = True)                 
77564>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77564>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77564>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77564>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77564>>>>>>>>>>>>>
77564>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77565>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77566>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77567>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77568>>>>>>>>>>>>>
77568>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77568>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77569>>>>>>>>>>>>>            If (sValue = "99") Begin
77571>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77572>>>>>>>>>>>>>            End
77572>>>>>>>>>>>>>>
77572>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77573>>>>>>>>>>>>>
77573>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77574>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77575>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77577>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77578>>>>>>>>>>>>>            End
77578>>>>>>>>>>>>>>
77578>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77580>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77581>>>>>>>>>>>>>            End
77581>>>>>>>>>>>>>>
77581>>>>>>>>>>>>>
77581>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77582>>>>>>>>>>>>>
77582>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77583>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77584>>>>>>>>>>>>>
77584>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77585>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77586>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77588>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77589>>>>>>>>>>>>>            End
77589>>>>>>>>>>>>>>
77589>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77590>>>>>>>>>>>>>
77590>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77590>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77591>>>>>>>>>>>>>
77591>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77592>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77593>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77594>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77595>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77596>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77597>>>>>>>>>>>>>
77597>>>>>>>>>>>>>            Increment iCount
77598>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77599>>>>>>>>>>>>>        Loop
77600>>>>>>>>>>>>>>
77600>>>>>>>>>>>>>
77600>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77600>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77602>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77603>>>>>>>>>>>>>        End
77603>>>>>>>>>>>>>>
77603>>>>>>>>>>>>>
77603>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77604>>>>>>>>>>>>>    End_Function
77605>>>>>>>>>>>>>
77605>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77607>>>>>>>>>>>>>        Integer iCount iSize
77607>>>>>>>>>>>>>        Boolean bOK
77607>>>>>>>>>>>>>        String sSection sValue
77607>>>>>>>>>>>>>
77607>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77607>>>>>>>>>>>>>        Move 0 to iCount
77608>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77609>>>>>>>>>>>>>        If (bOK = False) Begin
77611>>>>>>>>>>>>>            Function_Return False
77612>>>>>>>>>>>>>        End
77612>>>>>>>>>>>>>>
77612>>>>>>>>>>>>>
77612>>>>>>>>>>>>>        Move False to Err
77613>>>>>>>>>>>>>        Get psIniSectionName to sSection
77614>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77614>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77615>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77616>>>>>>>>>>>>>        Decrement iSize
77617>>>>>>>>>>>>>
77617>>>>>>>>>>>>>        For iCount from 0 to iSize
77623>>>>>>>>>>>>>>
77623>>>>>>>>>>>>>            // DF 19 compatible settings:
77623>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77624>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77625>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77626>>>>>>>>>>>>>            
77626>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77627>>>>>>>>>>>>>
77627>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77628>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77630>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77631>>>>>>>>>>>>>            End
77631>>>>>>>>>>>>>>
77631>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77632>>>>>>>>>>>>>
77632>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77634>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77635>>>>>>>>>>>>>            End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>
77635>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77636>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77637>>>>>>>>>>>>>
77637>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77637>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77638>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77639>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77640>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77641>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77642>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77643>>>>>>>>>>>>>        Loop
77644>>>>>>>>>>>>>>
77644>>>>>>>>>>>>>
77644>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77645>>>>>>>>>>>>>    End_Function
77646>>>>>>>>>>>>>
77646>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77646>>>>>>>>>>>>>    //
77646>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77646>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77646>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77648>>>>>>>>>>>>>        String sRetval
77648>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77650>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77651>>>>>>>>>>>>>        End
77651>>>>>>>>>>>>>>
77651>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77653>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77654>>>>>>>>>>>>>        End
77654>>>>>>>>>>>>>>
77654>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77656>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77657>>>>>>>>>>>>>        End
77657>>>>>>>>>>>>>>
77657>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77659>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77660>>>>>>>>>>>>>        End
77660>>>>>>>>>>>>>>
77660>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77662>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77663>>>>>>>>>>>>>        End
77663>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77665>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77666>>>>>>>>>>>>>        End
77666>>>>>>>>>>>>>>
77666>>>>>>>>>>>>>        Function_Return sRetval
77667>>>>>>>>>>>>>    End_Function
77668>>>>>>>>>>>>>
77668>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77668>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77668>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77670>>>>>>>>>>>>>        Integer iRetval
77670>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77672>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77673>>>>>>>>>>>>>        End
77673>>>>>>>>>>>>>>
77673>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77675>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77676>>>>>>>>>>>>>        End
77676>>>>>>>>>>>>>>
77676>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77678>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77679>>>>>>>>>>>>>        End
77679>>>>>>>>>>>>>>
77679>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77681>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77682>>>>>>>>>>>>>        End
77682>>>>>>>>>>>>>>
77682>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77684>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77685>>>>>>>>>>>>>        End
77685>>>>>>>>>>>>>>
77685>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77687>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77688>>>>>>>>>>>>>        End
77688>>>>>>>>>>>>>>
77688>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77690>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77691>>>>>>>>>>>>>        End
77691>>>>>>>>>>>>>>
77691>>>>>>>>>>>>>        Function_Return iRetval
77692>>>>>>>>>>>>>    End_Function
77693>>>>>>>>>>>>>
77693>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77693>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77693>>>>>>>>>>>>>    // the SQL Connection program's grid.
77693>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77695>>>>>>>>>>>>>        String sRetval
77695>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77697>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77698>>>>>>>>>>>>>        End
77698>>>>>>>>>>>>>>
77698>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77700>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77701>>>>>>>>>>>>>        End
77701>>>>>>>>>>>>>>
77701>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77703>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77704>>>>>>>>>>>>>        End
77704>>>>>>>>>>>>>>
77704>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77706>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77707>>>>>>>>>>>>>        End
77707>>>>>>>>>>>>>>
77707>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77709>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77710>>>>>>>>>>>>>        End
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77712>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77713>>>>>>>>>>>>>        End
77713>>>>>>>>>>>>>>
77713>>>>>>>>>>>>>        Function_Return sRetval
77714>>>>>>>>>>>>>    End_Function
77715>>>>>>>>>>>>>
77715>>>>>>>>>>>>>    // Pass a driver id and the function will return
77715>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77715>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77715>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77717>>>>>>>>>>>>>        Integer iRetval
77717>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77719>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77720>>>>>>>>>>>>>        End
77720>>>>>>>>>>>>>>
77720>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77722>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77723>>>>>>>>>>>>>        End
77723>>>>>>>>>>>>>>
77723>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77725>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77726>>>>>>>>>>>>>        End
77726>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77728>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77729>>>>>>>>>>>>>        End
77729>>>>>>>>>>>>>>
77729>>>>>>>>>>>>>        Function_Return iRetval
77730>>>>>>>>>>>>>    End_Function
77731>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77731>>>>>>>>>>>>>>
77731>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77733>>>>>>>>>>>>>>    Integer iStart iEnd
77733>>>>>>>>>>>>>>    String sRetval
77733>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77734>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77735>>>>>>>>>>>>>>    If (iStart = 0) Begin
77737>>>>>>>>>>>>>>        Function_Return ""
77738>>>>>>>>>>>>>>    End
77738>>>>>>>>>>>>>>>
77738>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77739>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77740>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77742>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77743>>>>>>>>>>>>>>    End
77743>>>>>>>>>>>>>>>
77743>>>>>>>>>>>>>>    Else Begin
77744>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77745>>>>>>>>>>>>>>    End
77745>>>>>>>>>>>>>>>
77745>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77747>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77748>>>>>>>>>>>>>>        Decrement iEnd
77749>>>>>>>>>>>>>>    End
77749>>>>>>>>>>>>>>>
77749>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77751>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77752>>>>>>>>>>>>>>    End
77752>>>>>>>>>>>>>>>
77752>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77753>>>>>>>>>>>>>>
77753>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77754>>>>>>>>>>>>>>End_Function
77755>>>>>>>>>>>>>>
77755>>>>>>>>>>>>>>
77755>>>>>>>>>>>>>
77755>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77757>>>>>>>>>>>>>        String sConnect
77757>>>>>>>>>>>>>        Handle hoDriver
77757>>>>>>>>>>>>>
77757>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77758>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77759>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77760>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77761>>>>>>>>>>>>>        Send Destroy of hoDriver
77762>>>>>>>>>>>>>
77762>>>>>>>>>>>>>        Function_Return sConnect
77763>>>>>>>>>>>>>    End_Function
77764>>>>>>>>>>>>>
77764>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77764>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77766>>>>>>>>>>>>>        String sConnect
77766>>>>>>>>>>>>>
77766>>>>>>>>>>>>>        Case Begin
77766>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77768>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77769>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77771>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77772>>>>>>>>>>>>>                End
77772>>>>>>>>>>>>>>
77772>>>>>>>>>>>>>                Case Break
77773>>>>>>>>>>>>>
77773>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77776>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77778>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77779>>>>>>>>>>>>>                End
77779>>>>>>>>>>>>>>
77779>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77782>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77783>>>>>>>>>>>>>                End
77783>>>>>>>>>>>>>>
77783>>>>>>>>>>>>>
77783>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77785>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77786>>>>>>>>>>>>>                End
77786>>>>>>>>>>>>>>
77786>>>>>>>>>>>>>                Case Break
77787>>>>>>>>>>>>>
77787>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77790>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77791>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77793>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77794>>>>>>>>>>>>>                End
77794>>>>>>>>>>>>>>
77794>>>>>>>>>>>>>                Case Break
77795>>>>>>>>>>>>>
77795>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77798>>>>>>>>>>>>>                Break
77799>>>>>>>>>>>>>
77799>>>>>>>>>>>>>            Case Else
77799>>>>>>>>>>>>>                Move "" to sConnect
77800>>>>>>>>>>>>>        Case End
77800>>>>>>>>>>>>>
77800>>>>>>>>>>>>>        Function_Return sConnect
77801>>>>>>>>>>>>>    End_Function
77802>>>>>>>>>>>>>
77802>>>>>>>>>>>>>    // Use Base64
77802>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77804>>>>>>>>>>>>>        String sRetval
77804>>>>>>>>>>>>>        Handle hoLoginEncryption
77804>>>>>>>>>>>>>
77804>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77805>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77806>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77807>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77808>>>>>>>>>>>>>          
77808>>>>>>>>>>>>>        Function_Return sRetval
77809>>>>>>>>>>>>>    End_Function
77810>>>>>>>>>>>>>
77810>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77812>>>>>>>>>>>>>        String sRetval
77812>>>>>>>>>>>>>        Handle hoLoginEncryption
77812>>>>>>>>>>>>>
77812>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77813>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77814>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77815>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77816>>>>>>>>>>>>>
77816>>>>>>>>>>>>>        Function_Return sRetval
77817>>>>>>>>>>>>>    End_Function
77818>>>>>>>>>>>>>
77818>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77818>>>>>>>>>>>>>    Function ApplicationPath Returns String
77820>>>>>>>>>>>>>        String sApplicationFileName sPath
77820>>>>>>>>>>>>>        Integer iNumChars iRetval
77820>>>>>>>>>>>>>
77820>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77821>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77822>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77823>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77824>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77825>>>>>>>>>>>>>
77825>>>>>>>>>>>>>        Function_Return sPath
77826>>>>>>>>>>>>>    End_Function
77827>>>>>>>>>>>>>
77827>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77827>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77827>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77827>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77829>>>>>>>>>>>>>        Boolean bExists
77829>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77829>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77830>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77830>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77830>>>>>>>>>>>>>        
77830>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77831>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77832>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77833>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77834>>>>>>>>>>>>>        If (bExists = True) Begin
77836>>>>>>>>>>>>>            Function_Return sProgramsPath
77837>>>>>>>>>>>>>        End                      
77837>>>>>>>>>>>>>>
77837>>>>>>>>>>>>>    
77837>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77838>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77840>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77841>>>>>>>>>>>>>        End                                              
77841>>>>>>>>>>>>>>
77841>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77842>>>>>>>>>>>>>        
77842>>>>>>>>>>>>>        Move False to bExists
77843>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77844>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77845>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77846>>>>>>>>>>>>>        Decrement iSize       
77847>>>>>>>>>>>>>        
77847>>>>>>>>>>>>>        For iCount from 0 to iSize
77853>>>>>>>>>>>>>>
77853>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77854>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77855>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77856>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77857>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77863>>>>>>>>>>>>>>
77863>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77864>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77865>>>>>>>>>>>>>                // Check if there are more than one path specified;
77865>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77866>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77868>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77869>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77875>>>>>>>>>>>>>>
77875>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77876>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77877>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77878>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77879>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77880>>>>>>>>>>>>>                        If (bExists = True) Begin
77882>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77883>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77884>>>>>>>>>>>>>                            Move iSize to iCount
77885>>>>>>>>>>>>>                        End                                                    
77885>>>>>>>>>>>>>>
77885>>>>>>>>>>>>>                    Loop
77886>>>>>>>>>>>>>>
77886>>>>>>>>>>>>>                End
77886>>>>>>>>>>>>>>
77886>>>>>>>>>>>>>                Else Begin
77887>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77888>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77889>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77890>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77891>>>>>>>>>>>>>                    If (bExists = True) Begin
77893>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77894>>>>>>>>>>>>>                        Move iSize to iCount
77895>>>>>>>>>>>>>                    End                                                    
77895>>>>>>>>>>>>>>
77895>>>>>>>>>>>>>                End
77895>>>>>>>>>>>>>>
77895>>>>>>>>>>>>>            Loop
77896>>>>>>>>>>>>>>
77896>>>>>>>>>>>>>            If (bExists = False) Begin
77898>>>>>>>>>>>>>                Move "" to sPath    
77899>>>>>>>>>>>>>            End
77899>>>>>>>>>>>>>>
77899>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77900>>>>>>>>>>>>>        Loop        
77901>>>>>>>>>>>>>>
77901>>>>>>>>>>>>>        Send Destroy of hoPaths
77902>>>>>>>>>>>>>        
77902>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77902>>>>>>>>>>>>>        If (sPath = "") Begin
77904>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77905>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77906>>>>>>>>>>>>>        End                  
77906>>>>>>>>>>>>>>
77906>>>>>>>>>>>>>        
77906>>>>>>>>>>>>>        Function_Return sPath    
77907>>>>>>>>>>>>>    End_Function
77908>>>>>>>>>>>>>    
77908>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77908>>>>>>>>>>>>>    // with one or more .ws file names.
77908>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77908>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77908>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77908>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77910>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77912>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77912>>>>>>>>>>>>>        Integer iCh iSize
77912>>>>>>>>>>>>>        Boolean bExists      
77912>>>>>>>>>>>>>        Handle hoIniFile 
77912>>>>>>>>>>>>>        
77912>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77913>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77914>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77916>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77917>>>>>>>>>>>>>        End                                              
77917>>>>>>>>>>>>>>
77917>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77918>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77919>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77920>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77921>>>>>>>>>>>>>        
77921>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77921>>>>>>>>>>>>>        // read the name of the .ws file name.
77921>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77922>>>>>>>>>>>>>        If (bExists = True) Begin
77924>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77925>>>>>>>>>>>>>            If (iCh < 0) Begin
77927>>>>>>>>>>>>>                Function_Return asSWSFiles
77928>>>>>>>>>>>>>            End                                 
77928>>>>>>>>>>>>>>
77928>>>>>>>>>>>>>            
77928>>>>>>>>>>>>>            Repeat
77928>>>>>>>>>>>>>>
77928>>>>>>>>>>>>>                Readln channel iCh sFile
77930>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77932>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77933>>>>>>>>>>>>>                End
77933>>>>>>>>>>>>>>
77933>>>>>>>>>>>>>            Until (SeqEof = True)
77935>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77936>>>>>>>>>>>>>            
77936>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77937>>>>>>>>>>>>>            If (iSize <> 0) Begin
77939>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77940>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77940>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77940>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77941>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77942>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77943>>>>>>>>>>>>>                If (sFile <> "") Begin
77945>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77946>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77947>>>>>>>>>>>>>                    File_Exist sFile bExists
77948>>>>>>>>>>>>>                    If (bExists = True) Begin
77950>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77951>>>>>>>>>>>>>                    End
77951>>>>>>>>>>>>>>
77951>>>>>>>>>>>>>                End
77951>>>>>>>>>>>>>>
77951>>>>>>>>>>>>>                Send Destroy of hoIniFile
77952>>>>>>>>>>>>>            End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>        End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>        
77952>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77952>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77954>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77955>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77956>>>>>>>>>>>>>            If (bExists = False) Begin
77958>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77959>>>>>>>>>>>>>            End
77959>>>>>>>>>>>>>>
77959>>>>>>>>>>>>>        
77959>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77960>>>>>>>>>>>>>            If (iCh < 0) Begin
77962>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77963>>>>>>>>>>>>>            End                                 
77963>>>>>>>>>>>>>>
77963>>>>>>>>>>>>>            
77963>>>>>>>>>>>>>            Repeat
77963>>>>>>>>>>>>>>
77963>>>>>>>>>>>>>                Readln channel iCh sFile
77965>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77967>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77968>>>>>>>>>>>>>                End
77968>>>>>>>>>>>>>>
77968>>>>>>>>>>>>>            Until (SeqEof = True)
77970>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77971>>>>>>>>>>>>>        End
77971>>>>>>>>>>>>>>
77971>>>>>>>>>>>>>        
77971>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77972>>>>>>>>>>>>>    End_Function
77973>>>>>>>>>>>>>
77973>>>>>>>>>>>>>End_Class
77974>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77974>>>>>>>>>>>Use vWin32fh.pkg
77974>>>>>>>>>>>
77974>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77974>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77974>>>>>>>>>>>
77974>>>>>>>>>>>// We're making references to this object handle so we need it defined
77974>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77974>>>>>>>>>>>
77974>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77974>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77975>>>>>>>>>>>
77975>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77976>>>>>>>>>>>
77976>>>>>>>>>>>    Procedure Construct_Object
77978>>>>>>>>>>>        Handle ho
77978>>>>>>>>>>>        Forward Send Construct_Object
77980>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77981>>>>>>>>>>>
77981>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77982>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77983>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77984>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77985>>>>>>>>>>>        
77985>>>>>>>>>>>
77985>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77985>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77985>>>>>>>>>>>        // methods to this class.
77985>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77986>>>>>>>>>>>        Property Boolean pbToANSI          True
77987>>>>>>>>>>>        Property Boolean pbRecnum          True
77988>>>>>>>>>>>        Property Boolean pbCopyData        True
77989>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77990>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77991>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77992>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77993>>>>>>>>>>>
77993>>>>>>>>>>>        // Driver default value settings:
77993>>>>>>>>>>>        // Note: When the object is created the corresponding values
77993>>>>>>>>>>>        // from the driver .int files are read.
77993>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77993>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77994>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77995>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77996>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77997>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77998>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77999>>>>>>>>>>>
77999>>>>>>>>>>>        // Driver "nullability" settings:
77999>>>>>>>>>>>        // Note: When the object is created the corresponding values
77999>>>>>>>>>>>        // from the driver .int files are read.
77999>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77999>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
78000>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
78001>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
78002>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
78003>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78004>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
78005>>>>>>>>>>>
78005>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
78005>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
78005>>>>>>>>>>>        //     driver interfaces.
78005>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
78005>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
78005>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
78006>>>>>>>>>>>
78006>>>>>>>>>>>    End_Procedure
78007>>>>>>>>>>>
78007>>>>>>>>>>>    Procedure End_Construct_Object
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>
78009>>>>>>>>>>>        Forward Send End_Construct_Object
78011>>>>>>>>>>>
78011>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
78011>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
78012>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78013>>>>>>>>>>>    End_Procedure
78014>>>>>>>>>>>
78014>>>>>>>>>>>    // *** Properties ***
78014>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78014>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
78014>>>>>>>>>>>    // merely here for conveniance.
78014>>>>>>>>>>>    //
78014>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
78014>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
78014>>>>>>>>>>>    // This struct property contains all the connection data.
78014>>>>>>>>>>>    //
78014>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78016>>>>>>>>>>>        Boolean bOK
78016>>>>>>>>>>>
78016>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78017>>>>>>>>>>>
78017>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78017>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78019>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78019>>>>>>>>>>>            Procedure_Return
78020>>>>>>>>>>>        End
78020>>>>>>>>>>>>
78020>>>>>>>>>>>
78020>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78020>>>>>>>>>>>        // be logged in already and don't want to do it again.
78020>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78022>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78022>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78022>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78023>>>>>>>>>>>            If (bOK = False) Begin
78025>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78026>>>>>>>>>>>>
78026>>>>>>>>>>>            End
78026>>>>>>>>>>>>
78026>>>>>>>>>>>        End
78026>>>>>>>>>>>>
78026>>>>>>>>>>>
78026>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78026>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78027>>>>>>>>>>>
78027>>>>>>>>>>>    End_Procedure
78028>>>>>>>>>>>
78028>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78028>>>>>>>>>>>    // attempt to load the driver.
78028>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78028>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78030>>>>>>>>>>>        Boolean bOK
78030>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78031>>>>>>>>>>>        Function_Return bOK
78032>>>>>>>>>>>    End_Function
78033>>>>>>>>>>>
78033>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78033>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78035>>>>>>>>>>>        String sAttributeValue sServer
78035>>>>>>>>>>>        Integer iDriverID
78035>>>>>>>>>>>        Boolean bNULL bSQLDriver
78035>>>>>>>>>>>        Handle hDatabase
78035>>>>>>>>>>>        
78035>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78036>>>>>>>>>>>        If (bSQLDriver = False) Begin
78038>>>>>>>>>>>            Procedure_Return
78039>>>>>>>>>>>        End                                      
78039>>>>>>>>>>>>
78039>>>>>>>>>>>        
78039>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78040>>>>>>>>>>>        
78040>>>>>>>>>>>        // ToDo: Testing!
78040>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78040>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78040>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78040>>>>>>>>>>>
78040>>>>>>>>>>>        // Driver default values for various data types:
78040>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78043>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78044>>>>>>>>>>>
78044>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78047>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78048>>>>>>>>>>>
78048>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78051>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78052>>>>>>>>>>>
78052>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78055>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78056>>>>>>>>>>>
78056>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78059>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78060>>>>>>>>>>>
78060>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78063>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78064>>>>>>>>>>>
78064>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78064>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78067>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78068>>>>>>>>>>>
78068>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78071>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78072>>>>>>>>>>>
78072>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78075>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78076>>>>>>>>>>>
78076>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78079>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78080>>>>>>>>>>>
78080>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78083>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78084>>>>>>>>>>>
78084>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78087>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78088>>>>>>>>>>>
78088>>>>>>>>>>>    End_Procedure
78089>>>>>>>>>>>
78089>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78091>>>>>>>>>>>        Boolean bOK bIsDaw
78091>>>>>>>>>>>        String sConnectionString
78091>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78091>>>>>>>>>>>        Integer iDriverID
78091>>>>>>>>>>>
78091>>>>>>>>>>>        Move False to bOK
78092>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78093>>>>>>>>>>>
78093>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78094>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78095>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78096>>>>>>>>>>>        If (iDriverID = 0) Begin
78098>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78099>>>>>>>>>>>            Function_Return False
78100>>>>>>>>>>>        End
78100>>>>>>>>>>>>
78100>>>>>>>>>>>
78100>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78103>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78104>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78105>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78106>>>>>>>>>>>        Send Destroy   of hoDriver
78107>>>>>>>>>>>
78107>>>>>>>>>>>        Function_Return bOK
78108>>>>>>>>>>>    End_Function
78109>>>>>>>>>>>
78109>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78112>>>>>>>>>>>        Function_Return SQLConnection
78113>>>>>>>>>>>    End_Function
78114>>>>>>>>>>>
78114>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>
78116>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78117>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78119>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78120>>>>>>>>>>>        End
78120>>>>>>>>>>>>
78120>>>>>>>>>>>
78120>>>>>>>>>>>        // Else we might want to change the current connection ID
78120>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78123>>>>>>>>>>>            Move False to Err
78124>>>>>>>>>>>            Logout SQLConnection.sDriverID
78125>>>>>>>>>>>            // This will also make a login to the new server.
78125>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78126>>>>>>>>>>>        End
78126>>>>>>>>>>>>
78126>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78127>>>>>>>>>>>    End_Procedure
78128>>>>>>>>>>>
78128>>>>>>>>>>>    Function psConnectionID Returns String
78130>>>>>>>>>>>        tSQLConnection SQLConnection
78130>>>>>>>>>>>        tSQLConnection SQLConnection
78130>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78131>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78132>>>>>>>>>>>    End_Function
78133>>>>>>>>>>>
78133>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78133>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78133>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78133>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78133>>>>>>>>>>>    Procedure Set psDriverID String sValue
78135>>>>>>>>>>>        tSQLConnection SQLConnection
78135>>>>>>>>>>>        tSQLConnection SQLConnection
78135>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78136>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78137>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78138>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78140>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78141>>>>>>>>>>>        End
78141>>>>>>>>>>>>
78141>>>>>>>>>>>    End_Procedure
78142>>>>>>>>>>>
78142>>>>>>>>>>>    Function psDriverID Returns String
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78145>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78147>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78148>>>>>>>>>>>        End
78148>>>>>>>>>>>>
78148>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78149>>>>>>>>>>>    End_Function
78150>>>>>>>>>>>
78150>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78152>>>>>>>>>>>        tSQLConnection SQLConnection
78152>>>>>>>>>>>        tSQLConnection SQLConnection
78152>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78153>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78154>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78155>>>>>>>>>>>    End_Procedure
78156>>>>>>>>>>>
78156>>>>>>>>>>>    Function psConnectionString Returns String
78158>>>>>>>>>>>        tSQLConnection SQLConnection
78158>>>>>>>>>>>        tSQLConnection SQLConnection
78158>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78159>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78160>>>>>>>>>>>    End_Function
78161>>>>>>>>>>>
78161>>>>>>>>>>>    Procedure Set psServer String sValue
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78164>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78165>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78166>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78167>>>>>>>>>>>    End_Procedure
78168>>>>>>>>>>>
78168>>>>>>>>>>>    Function psServer Returns String
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78171>>>>>>>>>>>        Function_Return SQLConnection.sServer
78172>>>>>>>>>>>    End_Function
78173>>>>>>>>>>>
78173>>>>>>>>>>>    Procedure Set psDatabase String sValue
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78176>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78177>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78178>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78179>>>>>>>>>>>    End_Procedure
78180>>>>>>>>>>>
78180>>>>>>>>>>>    Function psDatabase Returns String
78182>>>>>>>>>>>        tSQLConnection SQLConnection
78182>>>>>>>>>>>        tSQLConnection SQLConnection
78182>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78183>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78184>>>>>>>>>>>    End_Function
78185>>>>>>>>>>>
78185>>>>>>>>>>>    Procedure Set psUserID String sValue
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78188>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78189>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78190>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78191>>>>>>>>>>>    End_Procedure
78192>>>>>>>>>>>
78192>>>>>>>>>>>    Function psUserID Returns String
78194>>>>>>>>>>>        tSQLConnection SQLConnection
78194>>>>>>>>>>>        tSQLConnection SQLConnection
78194>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78195>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78196>>>>>>>>>>>    End_Function
78197>>>>>>>>>>>
78197>>>>>>>>>>>    // This is the uncrypted password
78197>>>>>>>>>>>    Procedure Set psPassword String sValue
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78200>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78201>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78202>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78203>>>>>>>>>>>    End_Procedure
78204>>>>>>>>>>>
78204>>>>>>>>>>>    Function psPassword Returns String
78206>>>>>>>>>>>        tSQLConnection SQLConnection
78206>>>>>>>>>>>        tSQLConnection SQLConnection
78206>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78207>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78208>>>>>>>>>>>    End_Function
78209>>>>>>>>>>>
78209>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78211>>>>>>>>>>>        tSQLConnection SQLConnection
78211>>>>>>>>>>>        tSQLConnection SQLConnection
78211>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78212>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78213>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78214>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78215>>>>>>>>>>>    End_Procedure
78216>>>>>>>>>>>
78216>>>>>>>>>>>    Function pbTrusted Returns Boolean
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78219>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78220>>>>>>>>>>>    End_Function
78221>>>>>>>>>>>
78221>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78221>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78221>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78221>>>>>>>>>>>    //     the central pSQLConnection "hub".
78221>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78223>>>>>>>>>>>        tSQLConnection SQLConnection
78223>>>>>>>>>>>        tSQLConnection SQLConnection
78223>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78224>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78225>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78226>>>>>>>>>>>    End_Procedure
78227>>>>>>>>>>>
78227>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78230>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78231>>>>>>>>>>>    End_Function
78232>>>>>>>>>>>
78232>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78234>>>>>>>>>>>        tSQLConnection SQLConnection
78234>>>>>>>>>>>        tSQLConnection SQLConnection
78234>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78235>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78236>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78237>>>>>>>>>>>    End_Procedure
78238>>>>>>>>>>>
78238>>>>>>>>>>>    Function piDbType Returns Integer
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78241>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78242>>>>>>>>>>>    End_Function
78243>>>>>>>>>>>
78243>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78245>>>>>>>>>>>        tSQLConnection SQLConnection
78245>>>>>>>>>>>        tSQLConnection SQLConnection
78245>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78246>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78247>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78248>>>>>>>>>>>    End_Procedure
78249>>>>>>>>>>>
78249>>>>>>>>>>>    Function psBaseTableSpace Returns String
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78252>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78253>>>>>>>>>>>    End_Function
78254>>>>>>>>>>>
78254>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78256>>>>>>>>>>>        tSQLConnection SQLConnection
78256>>>>>>>>>>>        tSQLConnection SQLConnection
78256>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78257>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78258>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78259>>>>>>>>>>>    End_Procedure
78260>>>>>>>>>>>
78260>>>>>>>>>>>    Function psIndexTableSpace Returns String
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78263>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78264>>>>>>>>>>>    End_Function
78265>>>>>>>>>>>
78265>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78268>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78269>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78270>>>>>>>>>>>    End_Procedure
78271>>>>>>>>>>>
78271>>>>>>>>>>>    Function psLongTableSpace Returns String
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78274>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78275>>>>>>>>>>>    End_Function
78276>>>>>>>>>>>
78276>>>>>>>>>>>    Procedure Set psSchema String sValue
78278>>>>>>>>>>>        tSQLConnection SQLConnection
78278>>>>>>>>>>>        tSQLConnection SQLConnection
78278>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78279>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78280>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78281>>>>>>>>>>>    End_Procedure
78282>>>>>>>>>>>
78282>>>>>>>>>>>    Function psSchema Returns String
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78285>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78286>>>>>>>>>>>    End_Function
78287>>>>>>>>>>>
78287>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78289>>>>>>>>>>>        tSQLConnection SQLConnection
78289>>>>>>>>>>>        tSQLConnection SQLConnection
78289>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78290>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78291>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78292>>>>>>>>>>>    End_Procedure
78293>>>>>>>>>>>
78293>>>>>>>>>>>    Function pbEnabled Returns Boolean
78295>>>>>>>>>>>        tSQLConnection SQLConnection
78295>>>>>>>>>>>        tSQLConnection SQLConnection
78295>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78296>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78297>>>>>>>>>>>    End_Function
78298>>>>>>>>>>>
78298>>>>>>>>>>>
78298>>>>>>>>>>>    // ************************************
78298>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78300>>>>>>>>>>>        tSQLConnection SQLConnection
78300>>>>>>>>>>>        tSQLConnection SQLConnection
78300>>>>>>>>>>>
78300>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78300>>>>>>>>>>>        // deferr reading SQL connection values until later.
78300>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78302>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78302>>>>>>>>>>>            If (ghoConnection > 0) Begin
78304>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78305>>>>>>>>>>>            End
78305>>>>>>>>>>>>
78305>>>>>>>>>>>
78305>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78305>>>>>>>>>>>            // object is used.
78305>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78307>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78308>>>>>>>>>>>            End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>        End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>
78308>>>>>>>>>>>        Function_Return SQLConnection
78309>>>>>>>>>>>    End_Function
78310>>>>>>>>>>>
78310>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78310>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78312>>>>>>>>>>>        tConnection Connection
78312>>>>>>>>>>>        tConnection Connection
78312>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78312>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78312>>>>>>>>>>>        Integer iRetval iDbType
78312>>>>>>>>>>>        Boolean bOK bConnected
78312>>>>>>>>>>>        String sConnectionID
78312>>>>>>>>>>>
78312>>>>>>>>>>>            tConnection[] Connections
78312>>>>>>>>>>>            tConnection[] Connections
78313>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78313>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78313>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78313>>>>>>>>>>>            //   we then generate an error and abort the program...
78313>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78314>>>>>>>>>>>            If (bOK = False) Begin
78316>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78317>>>>>>>>>>>>
78317>>>>>>>>>>>                Abort
78318>>>>>>>>>>>>
78318>>>>>>>>>>>            End
78318>>>>>>>>>>>>
78318>>>>>>>>>>>            If (sConnectionID = "") Begin
78320>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78321>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78323>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78324>>>>>>>>>>>                End
78324>>>>>>>>>>>>
78324>>>>>>>>>>>            End
78324>>>>>>>>>>>>
78324>>>>>>>>>>>
78324>>>>>>>>>>>            Move 0 to iRetval
78325>>>>>>>>>>>            // DAW DF19 connection info:
78325>>>>>>>>>>>            // We first check that the connection is OK:
78325>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78326>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78326>>>>>>>>>>>            If (iRetval = -1) Begin
78328>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78329>>>>>>>>>>>            End
78329>>>>>>>>>>>>
78329>>>>>>>>>>>
78329>>>>>>>>>>>            If (sConnectionID <> "") Begin
78331>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78332>>>>>>>>>>>            End
78332>>>>>>>>>>>>
78332>>>>>>>>>>>            If (Connection.sId = "") Begin
78334>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78335>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78336>>>>>>>>>>>            End
78336>>>>>>>>>>>>
78336>>>>>>>>>>>
78336>>>>>>>>>>>            // DUF connection info struct property:
78336>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78337>>>>>>>>>>>
78337>>>>>>>>>>>            Move Connection.sId to sConnectionID
78338>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78339>>>>>>>>>>>
78339>>>>>>>>>>>            If (bConnected = False) Begin
78341>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78342>>>>>>>>>>>                If (iRetval <> 0) Begin
78344>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78345>>>>>>>>>>>                    Send Exit_Application
78346>>>>>>>>>>>                End
78346>>>>>>>>>>>>
78346>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78347>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78347>>>>>>>>>>>                // been changed in the DAW db login dialog.
78347>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78348>>>>>>>>>>>            End
78348>>>>>>>>>>>>
78348>>>>>>>>>>>
78348>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78349>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78350>>>>>>>>>>>
78350>>>>>>>>>>>            // Not used in DUF:
78350>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78350>>>>>>>>>>>
78350>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78351>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78352>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78353>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78354>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78355>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78356>>>>>>>>>>>
78356>>>>>>>>>>>            // Not used in DUF:
78356>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78356>>>>>>>>>>>
78356>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78356>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78356>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78358>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78359>>>>>>>>>>>            End
78359>>>>>>>>>>>>
78359>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78361>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78362>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78364>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78365>>>>>>>>>>>                End
78365>>>>>>>>>>>>
78365>>>>>>>>>>>            End
78365>>>>>>>>>>>>
78365>>>>>>>>>>>
78365>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78366>>>>>>>>>>>
78366>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78366>>>>>>>>>>>            // the value from the driver id:
78366>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78367>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78369>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78369>>>>>>>>>>>            Get piDbType                                     to iDbType
78370>>>>>>>>>>>            End
78370>>>>>>>>>>>>
78370>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78372>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78373>>>>>>>>>>>            End
78373>>>>>>>>>>>>
78373>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78374>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78375>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78376>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78377>>>>>>>>>>>
78377>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78377>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78378>>>>>>>>>>>
78378>>>>>>>>>>>        Function_Return SQLConnection
78379>>>>>>>>>>>    End_Function
78380>>>>>>>>>>>
78380>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78380>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78380>>>>>>>>>>>    // connection id for a particular driver.
78380>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78380>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78380>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78380>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78380>>>>>>>>>>>    // connections of the DAW cConnect class.
78380>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78382>>>>>>>>>>>        tConnection[] ConnIdArray
78382>>>>>>>>>>>        tConnection[] ConnIdArray
78383>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78383>>>>>>>>>>>        Boolean bEnabled bFound
78383>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78383>>>>>>>>>>>
78383>>>>>>>>>>>        Move False to bFound
78384>>>>>>>>>>>        If (ghoConnection > 0) Begin
78386>>>>>>>>>>>
78386>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78386>>>>>>>>>>>            Get psDriverID to sDriverID
78387>>>>>>>>>>>
78387>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78388>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78388>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78389>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78390>>>>>>>>>>>            Decrement iSize
78391>>>>>>>>>>>            For iCount from 0 to iSize
78397>>>>>>>>>>>>
78397>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78398>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78399>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78400>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78400>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78400>>>>>>>>>>>                If (sConnectionID = "") Begin
78402>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78403>>>>>>>>>>>                End
78403>>>>>>>>>>>>
78403>>>>>>>>>>>                Else Begin
78404>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78406>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78407>>>>>>>>>>>                    End
78407>>>>>>>>>>>>
78407>>>>>>>>>>>                End
78407>>>>>>>>>>>>
78407>>>>>>>>>>>
78407>>>>>>>>>>>                If (bFound = True) Begin
78409>>>>>>>>>>>                    Increment iConnectionIDCounter
78410>>>>>>>>>>>                End
78410>>>>>>>>>>>>
78410>>>>>>>>>>>            Loop
78411>>>>>>>>>>>>
78411>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78412>>>>>>>>>>>            If (bFound = True) Begin
78414>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78415>>>>>>>>>>>            End
78415>>>>>>>>>>>>
78415>>>>>>>>>>>        End
78415>>>>>>>>>>>>
78415>>>>>>>>>>>
78415>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78415>>>>>>>>>>>        // but no DFConn.ini record has been created.
78415>>>>>>>>>>>        If (iSize = -1) Begin
78417>>>>>>>>>>>            Move True to bFound
78418>>>>>>>>>>>        End
78418>>>>>>>>>>>>
78418>>>>>>>>>>>
78418>>>>>>>>>>>        Function_Return bFound
78419>>>>>>>>>>>    End_Function
78420>>>>>>>>>>>
78420>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78420>>>>>>>>>>>    // create a connection to the server.
78420>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78422>>>>>>>>>>>        String sPath sFileName
78422>>>>>>>>>>>        Boolean bExists bActive
78422>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78422>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78423>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78423>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78423>>>>>>>>>>>        Handle hoIniFile
78423>>>>>>>>>>>        Integer iSize iCount iRetval
78423>>>>>>>>>>>
78423>>>>>>>>>>>        Get psIniFilePath to sPath
78424>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78425>>>>>>>>>>>        If (sPath = "") Begin
78427>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78428>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78429>>>>>>>>>>>        End
78429>>>>>>>>>>>>
78429>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78430>>>>>>>>>>>        Get psIniFileName to sFileName
78431>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78432>>>>>>>>>>>
78432>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78433>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78434>>>>>>>>>>>        If (iSize = 0) Begin
78436>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78436>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78436>>>>>>>>>>>            // in the cApplication object.
78436>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78437>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78439>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78440>>>>>>>>>>>            End
78440>>>>>>>>>>>>
78440>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78441>>>>>>>>>>>            Move 1 to iSize
78442>>>>>>>>>>>        End
78442>>>>>>>>>>>>
78442>>>>>>>>>>>
78442>>>>>>>>>>>        Move False to bActive
78443>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78443>>>>>>>>>>>        Decrement iSize
78444>>>>>>>>>>>        For iCount from 0 to iSize
78450>>>>>>>>>>>>
78450>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78451>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78453>>>>>>>>>>>                Move True to bActive
78454>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78455>>>>>>>>>>>            End
78455>>>>>>>>>>>>
78455>>>>>>>>>>>        Loop
78456>>>>>>>>>>>>
78456>>>>>>>>>>>
78456>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78456>>>>>>>>>>>        If (bActive = False) Begin
78458>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78459>>>>>>>>>>>        End
78459>>>>>>>>>>>>
78459>>>>>>>>>>>
78459>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78460>>>>>>>>>>>
78460>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78461>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78462>>>>>>>>>>>
78462>>>>>>>>>>>        Function_Return SQLConnection
78463>>>>>>>>>>>    End_Function
78464>>>>>>>>>>>
78464>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78466>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78467>>>>>>>>>>>    End_Procedure
78468>>>>>>>>>>>
78468>>>>>>>>>>>    Function psIniFilePath Returns String
78470>>>>>>>>>>>        String sRetval
78470>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78471>>>>>>>>>>>        Function_Return sRetval
78472>>>>>>>>>>>    End_Function
78473>>>>>>>>>>>
78473>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78475>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78476>>>>>>>>>>>    End_Procedure
78477>>>>>>>>>>>
78477>>>>>>>>>>>    Function psIniFileName Returns String
78479>>>>>>>>>>>        String sRetval
78479>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78480>>>>>>>>>>>        Function_Return sRetval
78481>>>>>>>>>>>    End_Function
78482>>>>>>>>>>>
78482>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78484>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78485>>>>>>>>>>>    End_Procedure
78486>>>>>>>>>>>
78486>>>>>>>>>>>    Function psIniSectionName Returns String
78488>>>>>>>>>>>        String sRetval
78488>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78489>>>>>>>>>>>        Function_Return sRetval
78490>>>>>>>>>>>    End_Function
78491>>>>>>>>>>>
78491>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78493>>>>>>>>>>>        Handle ho
78493>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78494>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78495>>>>>>>>>>>    End_Procedure
78496>>>>>>>>>>>
78496>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78498>>>>>>>>>>>        Handle ho
78498>>>>>>>>>>>        String sRetval
78498>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78499>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78500>>>>>>>>>>>        Function_Return sRetval
78501>>>>>>>>>>>    End_Function
78502>>>>>>>>>>>
78502>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78504>>>>>>>>>>>        Handle ho
78504>>>>>>>>>>>        Boolean bRetval
78504>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78505>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78506>>>>>>>>>>>        Function_Return bRetval
78507>>>>>>>>>>>    End_Function
78508>>>>>>>>>>>
78508>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78510>>>>>>>>>>>        Handle ho
78510>>>>>>>>>>>        Boolean bRetval
78510>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78511>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78512>>>>>>>>>>>        Function_Return bRetval
78513>>>>>>>>>>>    End_Function
78514>>>>>>>>>>>
78514>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78516>>>>>>>>>>>        Handle ho
78516>>>>>>>>>>>        String sRetval
78516>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78517>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78518>>>>>>>>>>>        Function_Return sRetval
78519>>>>>>>>>>>    End_Function
78520>>>>>>>>>>>
78520>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78522>>>>>>>>>>>        Handle ho
78522>>>>>>>>>>>        String sRetval
78522>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78523>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78524>>>>>>>>>>>        Function_Return sRetval
78525>>>>>>>>>>>    End_Function
78526>>>>>>>>>>>
78526>>>>>>>>>>>    // *** Main Connection Message ***
78526>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78528>>>>>>>>>>>        Handle hoDriver
78528>>>>>>>>>>>        String sConnectionString sError
78528>>>>>>>>>>>        Boolean bLoginSuccessful
78528>>>>>>>>>>>
78528>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78529>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78530>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78531>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78532>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78534>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78535>>>>>>>>>>>>
78535>>>>>>>>>>>            If (bExitProgram = True) Begin
78537>>>>>>>>>>>                Send Exit_Application
78538>>>>>>>>>>>            End
78538>>>>>>>>>>>>
78538>>>>>>>>>>>        End
78538>>>>>>>>>>>>
78538>>>>>>>>>>>        Send Destroy of hoDriver
78539>>>>>>>>>>>    End_Procedure
78540>>>>>>>>>>>
78540>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78542>>>>>>>>>>>        Integer iRetval
78542>>>>>>>>>>>        Handle hoCLI
78542>>>>>>>>>>>        String sDriverID
78542>>>>>>>>>>>
78542>>>>>>>>>>>        Get psDriverID to sDriverID
78543>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78544>>>>>>>>>>>        If (hoCLI <> 0) Begin
78546>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78547>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78548>>>>>>>>>>>            Send Destroy of hoCLI
78549>>>>>>>>>>>        End
78549>>>>>>>>>>>>
78549>>>>>>>>>>>
78549>>>>>>>>>>>        Function_Return iRetval
78550>>>>>>>>>>>    End_Function
78551>>>>>>>>>>>
78551>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78553>>>>>>>>>>>        tSQLConnection SQLConnection
78553>>>>>>>>>>>        tSQLConnection SQLConnection
78553>>>>>>>>>>>
78553>>>>>>>>>>>        Set psDriverID to sDriverID
78554>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78555>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78556>>>>>>>>>>>    End_Procedure
78557>>>>>>>>>>>
78557>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78557>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78557>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78557>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78557>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78557>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78557>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78557>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78559>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78559>>>>>>>>>>>        Handle hoCLI
78559>>>>>>>>>>>        String sID
78559>>>>>>>>>>>
78559>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78561>>>>>>>>>>>            Procedure_Return
78562>>>>>>>>>>>        End
78562>>>>>>>>>>>>
78562>>>>>>>>>>>
78562>>>>>>>>>>>        Move 0 to iResult
78563>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78564>>>>>>>>>>>        If (hoCLI <> 0) Begin
78566>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78567>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78568>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78571>>>>>>>>>>>            Decrement iNumConn
78572>>>>>>>>>>>            For iConn from 0 to iNumConn
78578>>>>>>>>>>>>
78578>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78581>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78583>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78584>>>>>>>>>>>                End
78584>>>>>>>>>>>>
78584>>>>>>>>>>>            Loop
78585>>>>>>>>>>>>
78585>>>>>>>>>>>            Send Destroy of hoCLI
78586>>>>>>>>>>>        End
78586>>>>>>>>>>>>
78586>>>>>>>>>>>
78586>>>>>>>>>>>    End_Procedure
78587>>>>>>>>>>>
78587>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78589>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78589>>>>>>>>>>>        Handle hoCLI
78589>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78589>>>>>>>>>>>        tSQLConnection SQLConnection
78589>>>>>>>>>>>        tSQLConnection SQLConnection
78589>>>>>>>>>>>        Boolean bTrusted
78589>>>>>>>>>>>
78589>>>>>>>>>>>        Move 0 to iResult
78590>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78591>>>>>>>>>>>        If (hoCLI <> 0) Begin
78593>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78594>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78595>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78598>>>>>>>>>>>            Decrement iNumConn
78599>>>>>>>>>>>            For iConn from 0 to iNumConn
78605>>>>>>>>>>>>
78605>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78608>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78610>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78611>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78614>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78617>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78618>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78621>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78622>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78623>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78624>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78625>>>>>>>>>>>
78625>>>>>>>>>>>                    Case Begin
78625>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78627>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78628>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78629>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78630>>>>>>>>>>>                            Case Break
78631>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78634>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78635>>>>>>>>>>>                            Case Break
78636>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78639>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78640>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78642>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78643>>>>>>>>>>>                            End
78643>>>>>>>>>>>>
78643>>>>>>>>>>>                            Case Break
78644>>>>>>>>>>>                        Case Else
78644>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78645>>>>>>>>>>>>
78645>>>>>>>>>>>                            Case Break
78646>>>>>>>>>>>                    Case End
78646>>>>>>>>>>>                End
78646>>>>>>>>>>>>
78646>>>>>>>>>>>            Loop
78647>>>>>>>>>>>>
78647>>>>>>>>>>>            Send Destroy of hoCLI
78648>>>>>>>>>>>        End
78648>>>>>>>>>>>>
78648>>>>>>>>>>>
78648>>>>>>>>>>>        Function_Return SQLConnection
78649>>>>>>>>>>>    End_Function
78650>>>>>>>>>>>
78650>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78652>>>>>>>>>>>        String  sCurrentDriver
78652>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78652>>>>>>>>>>>
78652>>>>>>>>>>>        Move 0 to iDriver
78653>>>>>>>>>>>        Move 0 to iCount
78654>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78657>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78663>>>>>>>>>>>>
78663>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78666>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78668>>>>>>>>>>>                Function_Return iCount
78669>>>>>>>>>>>            End
78669>>>>>>>>>>>>
78669>>>>>>>>>>>        Loop
78670>>>>>>>>>>>>
78670>>>>>>>>>>>
78670>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78670>>>>>>>>>>>        If (iDriver = 0) Begin
78672>>>>>>>>>>>            Move 0 to LastErr
78673>>>>>>>>>>>            Load_Driver sDriverID
78674>>>>>>>>>>>            // If driver could not be loaded.
78674>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78676>>>>>>>>>>>                Move -1 to iCount
78677>>>>>>>>>>>            End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>        End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>        Function_Return iCount
78678>>>>>>>>>>>    End_Function
78679>>>>>>>>>>>
78679>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78679>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78681>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78681>>>>>>>>>>>        Boolean bTrusted bSilent
78681>>>>>>>>>>>        Integer iRetval
78681>>>>>>>>>>>
78681>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78682>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78683>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78684>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78685>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78686>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78687>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78688>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78689>>>>>>>>>>>
78689>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78690>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78690>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78691>>>>>>>>>>>    End_Procedure
78692>>>>>>>>>>>
78692>>>>>>>>>>>    // Called when the object is constructed.
78692>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78692>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78692>>>>>>>>>>>    // the database is needed.
78692>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78694>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78694>>>>>>>>>>>        Integer iDriver iRetval
78694>>>>>>>>>>>        Handle hoCLI
78694>>>>>>>>>>>        Boolean bOK bSilent
78694>>>>>>>>>>>
78694>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78695>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78696>>>>>>>>>>>        Get psConnectionString to sConnectionString
78697>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78697>>>>>>>>>>>        Get psDriverID to sDriverID
78698>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78699>>>>>>>>>>>        If (bOK = False) Begin
78701>>>>>>>>>>>            Function_Return False
78702>>>>>>>>>>>        End
78702>>>>>>>>>>>>
78702>>>>>>>>>>>
78702>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78703>>>>>>>>>>>        // If driver not loaded; load it.
78703>>>>>>>>>>>        If (iDriver = 0) Begin
78705>>>>>>>>>>>            Load_Driver sDriverID
78706>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78707>>>>>>>>>>>        End
78707>>>>>>>>>>>>
78707>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78707>>>>>>>>>>>        If (iDriver = 0) Begin
78709>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78710>>>>>>>>>>>>
78710>>>>>>>>>>>            Function_Return False
78711>>>>>>>>>>>        End           
78711>>>>>>>>>>>>
78711>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78714>>>>>>>>>>>        
78714>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78715>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78716>>>>>>>>>>>        // Delete the connection first; in case it exists
78716>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78717>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78718>>>>>>>>>>>        Send Destroy of hoCLI
78719>>>>>>>>>>>
78719>>>>>>>>>>>        Function_Return (iRetval = 0)
78720>>>>>>>>>>>    End_Function
78721>>>>>>>>>>>
78721>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78723>>>>>>>>>>>        Boolean bOK
78723>>>>>>>>>>>
78723>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78724>>>>>>>>>>>
78724>>>>>>>>>>>        If (bOK = False) Begin
78726>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78727>>>>>>>>>>>>
78727>>>>>>>>>>>            Function_Return False
78728>>>>>>>>>>>        End
78728>>>>>>>>>>>>
78728>>>>>>>>>>>
78728>>>>>>>>>>>        Function_Return True
78729>>>>>>>>>>>    End_Function
78730>>>>>>>>>>>
78730>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78732>>>>>>>>>>>        Boolean bOK
78732>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78733>>>>>>>>>>>        Function_Return bOK
78734>>>>>>>>>>>    End_Function
78735>>>>>>>>>>>
78735>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78737>>>>>>>>>>>        Handle hoIniFile
78737>>>>>>>>>>>        String sConnect
78737>>>>>>>>>>>
78737>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78738>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78739>>>>>>>>>>>
78739>>>>>>>>>>>        Function_Return sConnect
78740>>>>>>>>>>>    End_Function
78741>>>>>>>>>>>
78741>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78741>>>>>>>>>>>    // Pass a complete driver connection string
78741>>>>>>>>>>>    // Returns the following as a struct:
78741>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78741>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78741>>>>>>>>>>>    //
78741>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78743>>>>>>>>>>>        tSQLConnection SQLConnection
78743>>>>>>>>>>>        tSQLConnection SQLConnection
78743>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78743>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78743>>>>>>>>>>>        Integer iPos
78743>>>>>>>>>>>
78743>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78744>>>>>>>>>>>        If (bOK = False) Begin
78746>>>>>>>>>>>            Function_Return SQLConnection
78747>>>>>>>>>>>        End
78747>>>>>>>>>>>>
78747>>>>>>>>>>>
78747>>>>>>>>>>>        Move False to bTrusted
78748>>>>>>>>>>>        Move False to bSilent
78749>>>>>>>>>>>
78749>>>>>>>>>>>        Case Begin
78749>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78751>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78752>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78753>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78754>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78755>>>>>>>>>>>                If (bTrusted = False) Begin
78757>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78758>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78759>>>>>>>>>>>                End
78759>>>>>>>>>>>>
78759>>>>>>>>>>>                Case Break
78760>>>>>>>>>>>
78760>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78763>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78765>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78766>>>>>>>>>>>                End
78766>>>>>>>>>>>>
78766>>>>>>>>>>>                Else Begin
78767>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78768>>>>>>>>>>>                End
78768>>>>>>>>>>>>
78768>>>>>>>>>>>
78768>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78769>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78770>>>>>>>>>>>                If (bTrusted = False) Begin
78772>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78773>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78774>>>>>>>>>>>                End
78774>>>>>>>>>>>>
78774>>>>>>>>>>>                Case Break
78775>>>>>>>>>>>
78775>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78778>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78779>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78780>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78781>>>>>>>>>>>                Case Break
78782>>>>>>>>>>>
78782>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78785>>>>>>>>>>>                Break
78786>>>>>>>>>>>        Case End
78786>>>>>>>>>>>
78786>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78787>>>>>>>>>>>
78787>>>>>>>>>>>        // bSilent?
78787>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78788>>>>>>>>>>>        If (iPos = 0) Begin
78790>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78791>>>>>>>>>>>        End
78791>>>>>>>>>>>>
78791>>>>>>>>>>>        If (iPos = 0) Begin
78793>>>>>>>>>>>            Move "0"                                                            to sValue
78794>>>>>>>>>>>        End
78794>>>>>>>>>>>>
78794>>>>>>>>>>>        Else Begin
78795>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78796>>>>>>>>>>>        End
78796>>>>>>>>>>>>
78796>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78797>>>>>>>>>>>
78797>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78798>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78799>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78800>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78801>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78802>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78803>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78804>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78805>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78806>>>>>>>>>>>
78806>>>>>>>>>>>        Function_Return SQLConnection
78807>>>>>>>>>>>    End_Function
78808>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78808>>>>>>>>>>>>
78808>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78810>>>>>>>>>>>>    Integer iStart iEnd
78810>>>>>>>>>>>>    String sRetval
78810>>>>>>>>>>>>
78810>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78811>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78812>>>>>>>>>>>>    If (iStart = 0) Begin
78814>>>>>>>>>>>>        Function_Return ""
78815>>>>>>>>>>>>    End
78815>>>>>>>>>>>>>
78815>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78816>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78817>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78819>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78820>>>>>>>>>>>>    End
78820>>>>>>>>>>>>>
78820>>>>>>>>>>>>    Else Begin
78821>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78822>>>>>>>>>>>>    End
78822>>>>>>>>>>>>>
78822>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78824>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78825>>>>>>>>>>>>        Decrement iEnd
78826>>>>>>>>>>>>    End
78826>>>>>>>>>>>>>
78826>>>>>>>>>>>>    If (iEnd <> 0) Begin
78828>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78829>>>>>>>>>>>>    End
78829>>>>>>>>>>>>>
78829>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78830>>>>>>>>>>>>
78830>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78831>>>>>>>>>>>>End_Function
78832>>>>>>>>>>>>
78832>>>>>>>>>>>>
78832>>>>>>>>>>>
78832>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78832>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78834>>>>>>>>>>>        Handle ho
78834>>>>>>>>>>>        Integer iIndex
78834>>>>>>>>>>>        Boolean bRetval bOK
78834>>>>>>>>>>>        tSQLConnection SQLConnection
78834>>>>>>>>>>>        tSQLConnection SQLConnection
78834>>>>>>>>>>>
78834>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78835>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78836>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78837>>>>>>>>>>>        If (iIndex = -1) Begin
78839>>>>>>>>>>>            Function_Return False
78840>>>>>>>>>>>        End
78840>>>>>>>>>>>>
78840>>>>>>>>>>>
78840>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78841>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78842>>>>>>>>>>>        If (ghoConnection > 0) Begin
78844>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78845>>>>>>>>>>>            If (iIndex <> -1) Begin
78847>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78848>>>>>>>>>>>            End
78848>>>>>>>>>>>>
78848>>>>>>>>>>>        End
78848>>>>>>>>>>>>
78848>>>>>>>>>>>
78848>>>>>>>>>>>        Function_Return bRetval
78849>>>>>>>>>>>    End_Function
78850>>>>>>>>>>>
78850>>>>>>>>>>>    Procedure Set pbDFConnid Boolean bState
78852>>>>>>>>>>>        Set pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78853>>>>>>>>>>>    End_Procedure
78854>>>>>>>>>>>    
78854>>>>>>>>>>>    Function pbDFConnid Returns Boolean
78856>>>>>>>>>>>        Boolean bState
78856>>>>>>>>>>>        Get pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78857>>>>>>>>>>>        Function_Return bState
78858>>>>>>>>>>>    End_Function
78859>>>>>>>>>>>
78859>>>>>>>>>>>End_Class
78860>>>>>>>>>Use vWin32fh.pkg
78860>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78860>>>>>>>>>>>Use LanguageText.pkg
78860>>>>>>>>>>>Use Windows.pkg
78860>>>>>>>>>>>Use Dfclient.pkg
78860>>>>>>>>>>>Use DFbitmap.pkg
78860>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78860>>>>>>>>>>>Use cRichEdit.pkg
78860>>>>>>>>>>>Use cTextEdit.pkg
78860>>>>>>>>>>>Use cRichEdit.pkg
78860>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78860>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78860>>>>>>>>>>>>>>>Use VDFBase.pkg
78860>>>>>>>>>>>>>>>
78860>>>>>>>>>>>>>>>Class cFormatter is an cObject
78861>>>>>>>>>>>>>>>    
78861>>>>>>>>>>>>>>>    Procedure Construct_object
78863>>>>>>>>>>>>>>>        Integer iCh
78863>>>>>>>>>>>>>>>        Forward Send construct_object
78865>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78866>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78867>>>>>>>>>>>>>>>        
78867>>>>>>>>>>>>>>>        Property String  psLeft
78868>>>>>>>>>>>>>>>        Property String  psright
78869>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78870>>>>>>>>>>>>>>>        Property Integer piPoints
78871>>>>>>>>>>>>>>>        
78871>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78872>>>>>>>>>>>>>>>        Property String  psCurPosright
78873>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78874>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78875>>>>>>>>>>>>>>>        
78875>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78876>>>>>>>>>>>>>>>        Property String  psCurNegright
78877>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78878>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78879>>>>>>>>>>>>>>>        
78879>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78880>>>>>>>>>>>>>>>        Property String  psNumPosright
78881>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78882>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78883>>>>>>>>>>>>>>>        
78883>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78884>>>>>>>>>>>>>>>        Property String  psNumNegright
78885>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78886>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78887>>>>>>>>>>>>>>>        
78887>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78888>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78889>>>>>>>>>>>>>>>        
78889>>>>>>>>>>>>>>>    End_Procedure
78890>>>>>>>>>>>>>>>    
78890>>>>>>>>>>>>>>>    // internal
78890>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78890>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78892>>>>>>>>>>>>>>>        
78892>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78892>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78892>>>>>>>>>>>>>>>        
78892>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78892>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78892>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78893>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78894>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78895>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78896>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78897>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78898>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78899>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78900>>>>>>>>>>>>>>>        
78900>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78901>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78904>>>>>>>>>>>>>>>        
78904>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78905>>>>>>>>>>>>>>>        
78905>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78906>>>>>>>>>>>>>>>        
78906>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78906>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78907>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78908>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78909>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78910>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78911>>>>>>>>>>>>>>>        
78911>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78913>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78914>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78916>>>>>>>>>>>>>>>                Move -2 to iDigits
78917>>>>>>>>>>>>>>>                Increment i
78918>>>>>>>>>>>>>>>            End
78918>>>>>>>>>>>>>>>>
78918>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78922>>>>>>>>>>>>>>>                Increment i
78923>>>>>>>>>>>>>>>            Loop
78924>>>>>>>>>>>>>>>>
78924>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78925>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78928>>>>>>>>>>>>>>>            //
78928>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78929>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78933>>>>>>>>>>>>>>>                Increment i
78934>>>>>>>>>>>>>>>            Loop
78935>>>>>>>>>>>>>>>>
78935>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78936>>>>>>>>>>>>>>>        End
78936>>>>>>>>>>>>>>>>
78936>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78937>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78938>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78939>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78941>>>>>>>>>>>>>>>                Move sFmt to sLeft
78942>>>>>>>>>>>>>>>                Move ""   to sRight
78943>>>>>>>>>>>>>>>            End
78943>>>>>>>>>>>>>>>>
78943>>>>>>>>>>>>>>>            Else Begin
78944>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78945>>>>>>>>>>>>>>>                Move 1 to i
78946>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78950>>>>>>>>>>>>>>>                    Increment i
78951>>>>>>>>>>>>>>>                Loop
78952>>>>>>>>>>>>>>>>
78952>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78953>>>>>>>>>>>>>>>            End
78953>>>>>>>>>>>>>>>>
78953>>>>>>>>>>>>>>>        End
78953>>>>>>>>>>>>>>>>
78953>>>>>>>>>>>>>>>        // set temporary format properties and exit
78953>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78954>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78955>>>>>>>>>>>>>>>        Set psRight        to sRight
78956>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78957>>>>>>>>>>>>>>>    End_Procedure
78958>>>>>>>>>>>>>>>    
78958>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78958>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78958>>>>>>>>>>>>>>>    //
78958>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78958>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78960>>>>>>>>>>>>>>>        String sPos sNeg
78960>>>>>>>>>>>>>>>        Integer iPos
78960>>>>>>>>>>>>>>>        
78960>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78961>>>>>>>>>>>>>>>        If iPos Begin
78963>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78964>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78965>>>>>>>>>>>>>>>        End
78965>>>>>>>>>>>>>>>>
78965>>>>>>>>>>>>>>>        Else Begin
78966>>>>>>>>>>>>>>>            Move sFmt         to sPos
78967>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78968>>>>>>>>>>>>>>>        End
78968>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>        Send ParseFormat sPos
78969>>>>>>>>>>>>>>>        If bCurrency Begin
78971>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78972>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78973>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78974>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78975>>>>>>>>>>>>>>>        End
78975>>>>>>>>>>>>>>>>
78975>>>>>>>>>>>>>>>        Else Begin
78976>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78977>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78978>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78979>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78980>>>>>>>>>>>>>>>        End
78980>>>>>>>>>>>>>>>>
78980>>>>>>>>>>>>>>>        
78980>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78981>>>>>>>>>>>>>>>        If bCurrency Begin
78983>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78984>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78985>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78986>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78987>>>>>>>>>>>>>>>        End
78987>>>>>>>>>>>>>>>>
78987>>>>>>>>>>>>>>>        Else Begin
78988>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78989>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78990>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78991>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78992>>>>>>>>>>>>>>>        End
78992>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>    End_Procedure
78993>>>>>>>>>>>>>>>    
78993>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78993>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78995>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78995>>>>>>>>>>>>>>>        Integer iDec iLen iCh
78995>>>>>>>>>>>>>>>        
78995>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78998>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78999>>>>>>>>>>>>>>>        
78999>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
79000>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
79001>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
79002>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
79003>>>>>>>>>>>>>>>        // format for decimal separator
79003>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
79006>>>>>>>>>>>>>>>        
79006>>>>>>>>>>>>>>>        // format for thousand sep.
79006>>>>>>>>>>>>>>>        If bSep Begin
79008>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
79011>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
79012>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
79013>>>>>>>>>>>>>>>            While (iLen>3)
79017>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79018>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79019>>>>>>>>>>>>>>>            Loop
79020>>>>>>>>>>>>>>>>
79020>>>>>>>>>>>>>>>        End
79020>>>>>>>>>>>>>>>>
79020>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79020>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79023>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79024>>>>>>>>>>>>>>>    End_Function
79025>>>>>>>>>>>>>>>    
79025>>>>>>>>>>>>>>>    // Public: Format for currency
79025>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79027>>>>>>>>>>>>>>>        String  sLeft sRight
79027>>>>>>>>>>>>>>>        Integer bSep
79027>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79029>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79030>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79031>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79032>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79035>>>>>>>>>>>>>>>        End
79035>>>>>>>>>>>>>>>>
79035>>>>>>>>>>>>>>>        Else Begin
79036>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79037>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79038>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79039>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79042>>>>>>>>>>>>>>>        End
79042>>>>>>>>>>>>>>>>
79042>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79043>>>>>>>>>>>>>>>    End_Function
79044>>>>>>>>>>>>>>>    
79044>>>>>>>>>>>>>>>    // Public: Format for numeric
79044>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79046>>>>>>>>>>>>>>>        String  sLeft sRight
79046>>>>>>>>>>>>>>>        Integer bSep
79046>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79048>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79049>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79050>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79051>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79054>>>>>>>>>>>>>>>        End
79054>>>>>>>>>>>>>>>>
79054>>>>>>>>>>>>>>>        Else Begin
79055>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79056>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79057>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79058>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79061>>>>>>>>>>>>>>>        End
79061>>>>>>>>>>>>>>>>
79061>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79062>>>>>>>>>>>>>>>    End_Function
79063>>>>>>>>>>>>>>>    
79063>>>>>>>>>>>>>>>    
79063>>>>>>>>>>>>>>>    // Public: Format passing format string
79063>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79065>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79065>>>>>>>>>>>>>>>        String  sLeft sRight
79065>>>>>>>>>>>>>>>        Integer iPoints bSep
79065>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79066>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79067>>>>>>>>>>>>>>>        Case Begin
79067>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79070>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79074>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79078>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79080>>>>>>>>>>>>>>>        Case End
79080>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79081>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79082>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79083>>>>>>>>>>>>>>>        Get psRight        to sRight
79084>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79085>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79086>>>>>>>>>>>>>>>    End_Function
79087>>>>>>>>>>>>>>>    
79087>>>>>>>>>>>>>>>End_Class
79088>>>>>>>>>>>>>
79088>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79088>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79089>>>>>>>>>>>>>
79089>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79091>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79092>>>>>>>>>>>>>End_Function
79093>>>>>>>>>>>>>
79093>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79095>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79096>>>>>>>>>>>>>End_Function
79097>>>>>>>>>>>>>
79097>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79099>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79100>>>>>>>>>>>>>End_Function
79101>>>>>>>>>>>>>
79101>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79103>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79104>>>>>>>>>>>>>End_Procedure
79105>>>>>>>>>>>>>
79105>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79107>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79108>>>>>>>>>>>>>End_Procedure
79109>>>>>>>>>>>>>
79109>>>>>>>>>>>>>
79109>>>>>>>>>>>Use tWinStructs.pkg
79109>>>>>>>>>>>
79109>>>>>>>>>>>Use cli.pkg
79109>>>>>>>>>>>Use DFBTRDRV.PKG
79109>>>>>>>>>>>Use MSSqldrv.pkg
79109>>>>>>>>>>>Use db2_drv.pkg
79109>>>>>>>>>>>Use odbc_drv.pkg
79109>>>>>>>>>>>Use seq_chnl.pkg
79109>>>>>>>>>>>
79109>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79109>>>>>>>>>>>Register_Function Help_filename Returns String
79109>>>>>>>>>>>Register_Function GetHelpFile Returns String
79109>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** Constant Declarations: ***
79109>>>>>>>>>>>//
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// System icon menu constants. If the upper left hand
79109>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79109>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79109>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79109>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79109>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79109>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79109>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79109>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79109>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79109>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79109>>>>>>>>>>>
79109>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79109>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79109>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79109>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79109>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79109>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** Struct Declarations: ***
79109>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79109>>>>>>>>>>>    DWord   cbSize
79109>>>>>>>>>>>    Integer fMask
79109>>>>>>>>>>>    Handle  hwnd
79109>>>>>>>>>>>    Pointer lpVerb
79109>>>>>>>>>>>    Pointer lpFile
79109>>>>>>>>>>>    Pointer lpParameters
79109>>>>>>>>>>>    Pointer lpDirectory
79109>>>>>>>>>>>    Integer nShow
79109>>>>>>>>>>>    Integer iMissingAlignment1
79109>>>>>>>>>>>    Pointer hInstApp
79109>>>>>>>>>>>    Pointer lpIDList
79109>>>>>>>>>>>    Pointer lpClass
79109>>>>>>>>>>>    Handle  hkeyClass
79109>>>>>>>>>>>    DWord   dwHotKey
79109>>>>>>>>>>>    Integer iMissingAlignment2
79109>>>>>>>>>>>    Handle  hIconMonitor // Union
79109>>>>>>>>>>>    //Handle  hMonitor     // Union
79109>>>>>>>>>>>    Handle  hProcess
79109>>>>>>>>>>>End_Struct
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79109>>>>>>>>>>>//Type MEMORYSTATUS
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79109>>>>>>>>>>>//End_Type
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** External Function calls: ***
79109>>>>>>>>>>>//
79109>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79110>>>>>>>>>>>
79110>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79111>>>>>>>>>>>
79111>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79111>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79112>>>>>>>>>>>
79112>>>>>>>>>>>    // Wrapper Function WNetGetUser
79112>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79114>>>>>>>>>>>
79114>>>>>>>>>>>        DWord   dwResult
79114>>>>>>>>>>>        UWide   uwName uwUserName
79114>>>>>>>>>>>        UWide   uwName uwUserName
79114>>>>>>>>>>>
79114>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79115>>>>>>>>>>>
79115>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79116>>>>>>>>>>>
79116>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79117>>>>>>>>>>>
79117>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79118>>>>>>>>>>>
79118>>>>>>>>>>>        Function_Return dwResult
79119>>>>>>>>>>>    End_Function
79120>>>>>>>>>>>
79120>>>>>>>>>>>
79120>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79121>>>>>>>>>>>
79121>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79122>>>>>>>>>>>
79122>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79123>>>>>>>>>>>
79123>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79124>>>>>>>>>>>
79124>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79125>>>>>>>>>>>
79125>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79125>>>>>>>>>>>
79125>>>>>>>>>>>Function ComputerName Desktop Returns String
79127>>>>>>>>>>>    String sName
79127>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79128>>>>>>>>>>>>
79128>>>>>>>>>>>    Function_Return sName
79129>>>>>>>>>>>End_Function
79130>>>>>>>>>>>
79130>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79132>>>>>>>>>>>    WString wName
79132>>>>>>>>>>>    Integer iRetval iLength
79132>>>>>>>>>>>
79132>>>>>>>>>>>    Move 0 to iLength
79133>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79134>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79135>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79136>>>>>>>>>>>
79136>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79138>>>>>>>>>>>        Function_Return (CString (wName))
79139>>>>>>>>>>>    End
79139>>>>>>>>>>>>
79139>>>>>>>>>>>
79139>>>>>>>>>>>    Function_Return "User Unknown"
79140>>>>>>>>>>>End_Function
79141>>>>>>>>>>>
79141>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79143>>>>>>>>>>>    String sClient sDriver sClientDriver
79143>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79143>>>>>>>>>>>    Handle hoMsqlDrv
79143>>>>>>>>>>>
79143>>>>>>>>>>>    Move 0 to iDriver
79144>>>>>>>>>>>    Move "" to sClient
79145>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79148>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79154>>>>>>>>>>>>
79154>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79157>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79159>>>>>>>>>>>            Move iCount to iDriver
79160>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79161>>>>>>>>>>>        End
79161>>>>>>>>>>>>
79161>>>>>>>>>>>    Loop
79162>>>>>>>>>>>>
79162>>>>>>>>>>>
79162>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79162>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79164>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79167>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79168>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79169>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79170>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79171>>>>>>>>>>>    End
79171>>>>>>>>>>>>
79171>>>>>>>>>>>
79171>>>>>>>>>>>    Function_Return sClient
79172>>>>>>>>>>>End_Function
79173>>>>>>>>>>>
79173>>>>>>>>>>>// *** Class Declarations: ***
79173>>>>>>>>>>>//
79173>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79174>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79176>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79177>>>>>>>>>>>    End_Procedure
79178>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79180>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79182>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79183>>>>>>>>>>>    End_Procedure
79184>>>>>>>>>>>End_Class
79185>>>>>>>>>>>
79185>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79186>>>>>>>>>>>    Procedure Construct_Object
79188>>>>>>>>>>>        Forward Send Construct_Object
79190>>>>>>>>>>>        Property Handle phoEditorHandle
79191>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79192>>>>>>>>>>>    End_Procedure
79193>>>>>>>>>>>
79193>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79195>>>>>>>>>>>        Handle hoEditor
79195>>>>>>>>>>>        Boolean bCanCopy
79195>>>>>>>>>>>        Address aEditorAddress
79195>>>>>>>>>>>
79195>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79196>>>>>>>>>>>        Send Select_All of hoEditor
79197>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79198>>>>>>>>>>>        If (bCanCopy = True) Begin
79200>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79201>>>>>>>>>>>            Send Copy   of hoEditor
79202>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79202>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79203>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79204>>>>>>>>>>>        End
79204>>>>>>>>>>>>
79204>>>>>>>>>>>    End_Procedure
79205>>>>>>>>>>>End_Class
79206>>>>>>>>>>>
79206>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79207>>>>>>>>>>>    Procedure Construct_Object
79209>>>>>>>>>>>        Forward Send Construct_Object
79211>>>>>>>>>>>
79211>>>>>>>>>>>        Set Size to 100 245
79212>>>>>>>>>>>        Set Location to 6 6
79213>>>>>>>>>>>        Set Border_Style to Border_None
79214>>>>>>>>>>>        Set Read_Only_State to True
79215>>>>>>>>>>>        Set pbWrap to True
79216>>>>>>>>>>>        Set peAnchors to anAll
79217>>>>>>>>>>>    End_Procedure
79218>>>>>>>>>>>
79218>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79218>>>>>>>>>>>
79218>>>>>>>>>>>    Procedure AppendTextLn String sText
79220>>>>>>>>>>>        String sWorkspaceWSFile
79220>>>>>>>>>>>
79220>>>>>>>>>>>        // Only works for English:
79220>>>>>>>>>>>        If (ghoApplication > 0) Begin
79222>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79224>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79225>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79226>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79227>>>>>>>>>>>            End
79227>>>>>>>>>>>>
79227>>>>>>>>>>>        End
79227>>>>>>>>>>>>
79227>>>>>>>>>>>        Send AppendText sText
79228>>>>>>>>>>>        Send AppendText (character(10))
79229>>>>>>>>>>>    End_Procedure
79230>>>>>>>>>>>
79230>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79230>>>>>>>>>>>    //    information box
79230>>>>>>>>>>>    Procedure Show_Current_Directory
79232>>>>>>>>>>>        String sDir
79232>>>>>>>>>>>
79232>>>>>>>>>>>        Get_Current_Directory To sDir
79233>>>>>>>>>>>
79233>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79234>>>>>>>>>>>    End_Procedure
79235>>>>>>>>>>>
79235>>>>>>>>>>>    Procedure Show_Windows_Directory
79237>>>>>>>>>>>        String sWindir
79237>>>>>>>>>>>
79237>>>>>>>>>>>        Get_Windows_Directory To sWindir
79238>>>>>>>>>>>
79238>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79239>>>>>>>>>>>    End_Procedure
79240>>>>>>>>>>>
79240>>>>>>>>>>>    Procedure Show_Current_User
79242>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79243>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79244>>>>>>>>>>>    End_Procedure
79245>>>>>>>>>>>
79245>>>>>>>>>>>    Procedure Show_Number_Format
79247>>>>>>>>>>>        Integer iFormat
79247>>>>>>>>>>>        String sFormatText
79247>>>>>>>>>>>
79247>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79250>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79251>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79252>>>>>>>>>>>
79252>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79255>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79256>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79257>>>>>>>>>>>    End_Procedure
79258>>>>>>>>>>>
79258>>>>>>>>>>>    Procedure Show_Filelist_Name
79260>>>>>>>>>>>        String sFilename
79260>>>>>>>>>>>
79260>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79263>>>>>>>>>>>
79263>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79264>>>>>>>>>>>    End_Procedure
79265>>>>>>>>>>>
79265>>>>>>>>>>>    Procedure Show_Lock_Delay
79267>>>>>>>>>>>        Integer iLockdelay
79267>>>>>>>>>>>
79267>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79270>>>>>>>>>>>
79270>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79271>>>>>>>>>>>    End_Procedure
79272>>>>>>>>>>>
79272>>>>>>>>>>>    Procedure Show_Lock_Timeout
79274>>>>>>>>>>>        Integer iLockTimeout
79274>>>>>>>>>>>
79274>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79277>>>>>>>>>>>
79277>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79278>>>>>>>>>>>    End_Procedure
79279>>>>>>>>>>>
79279>>>>>>>>>>>    Procedure Show_Screen_Size
79281>>>>>>>>>>>        Integer iYscreensize iXscreensize
79281>>>>>>>>>>>
79281>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79282>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79283>>>>>>>>>>>
79283>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79284>>>>>>>>>>>    End_Procedure
79285>>>>>>>>>>>
79285>>>>>>>>>>>    Procedure Show_Page_Size
79287>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79288>>>>>>>>>>>    End_procedure
79289>>>>>>>>>>>
79289>>>>>>>>>>>    Procedure Show_Date
79291>>>>>>>>>>>        Date dToday
79291>>>>>>>>>>>
79291>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79292>>>>>>>>>>>
79292>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79293>>>>>>>>>>>    End_procedure
79294>>>>>>>>>>>
79294>>>>>>>>>>>    Procedure Show_Date_Format
79296>>>>>>>>>>>        Integer iDateFormat
79296>>>>>>>>>>>        String sDateFormat
79296>>>>>>>>>>>
79296>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79299>>>>>>>>>>>        Case Begin
79299>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79301>>>>>>>>>>>                Move C_$USA To sDateFormat
79302>>>>>>>>>>>                Case Break
79303>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79306>>>>>>>>>>>                Move C_$European To sDateFormat
79307>>>>>>>>>>>                Case Break
79308>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79311>>>>>>>>>>>                Move C_$Military To sDateFormat
79312>>>>>>>>>>>                Case Break
79313>>>>>>>>>>>            Case Else
79313>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79314>>>>>>>>>>>                Case Break
79315>>>>>>>>>>>        Case End
79315>>>>>>>>>>>
79315>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79316>>>>>>>>>>>    End_Procedure
79317>>>>>>>>>>>
79317>>>>>>>>>>>    // 2013-08-14 NGS
79317>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79317>>>>>>>>>>>    Procedure Show_Systemresources
79319>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79319>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79319>>>>>>>>>>>        Integer iRetval
79319>>>>>>>>>>>        Number nValue
79319>>>>>>>>>>>        String sValue
79319>>>>>>>>>>>
79319>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79320>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79321>>>>>>>>>>>        If (iRetval = 0) Begin
79323>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79324>>>>>>>>>>>            Procedure_Return
79325>>>>>>>>>>>        End
79325>>>>>>>>>>>>
79325>>>>>>>>>>>
79325>>>>>>>>>>>        Send AppendTextLn ""
79326>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79327>>>>>>>>>>>
79327>>>>>>>>>>>        // Show memory in Gigabytes:
79327>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79328>>>>>>>>>>>        Move (Round(nValue)) to nValue
79329>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79330>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79331>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79332>>>>>>>>>>>
79332>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79332>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79333>>>>>>>>>>>        Move (Round(nValue)) to nValue
79334>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79335>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79336>>>>>>>>>>>
79336>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79336>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79337>>>>>>>>>>>        Move (Round(nValue)) to nValue
79338>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79339>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79340>>>>>>>>>>>
79340>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79340>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79341>>>>>>>>>>>        Move (Round(nValue)) to nValue
79342>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79343>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79344>>>>>>>>>>>
79344>>>>>>>>>>>        // Add an empty row after the memory information:
79344>>>>>>>>>>>        Send AppendTextLn ""
79345>>>>>>>>>>>    End_Procedure
79346>>>>>>>>>>>
79346>>>>>>>>>>>    Procedure Show_Registration
79348>>>>>>>>>>>        String sRegName
79348>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79348>>>>>>>>>>>
79348>>>>>>>>>>>        Registration sRegName iSN
79349>>>>>>>>>>>>
79349>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79350>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79351>>>>>>>>>>>
79351>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79352>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79353>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79354>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79355>>>>>>>>>>>    End_Procedure
79356>>>>>>>>>>>
79356>>>>>>>>>>>    //****************************************************************************
79356>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79356>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79356>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79356>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79356>>>>>>>>>>>    // information To be displayed
79356>>>>>>>>>>>    //****************************************************************************
79356>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79356>>>>>>>>>>>
79356>>>>>>>>>>>    Procedure Show_ServicePack
79358>>>>>>>>>>>        String sKey sVersion sDataFlex
79358>>>>>>>>>>>        Handle hoRegistry
79358>>>>>>>>>>>        Boolean bExists bOpened
79358>>>>>>>>>>>
79358>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79359>>>>>>>>>>>
79359>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79360>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79361>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79362>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79363>>>>>>>>>>>
79363>>>>>>>>>>>        If (bExists) Begin
79365>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79366>>>>>>>>>>>        End
79366>>>>>>>>>>>>
79366>>>>>>>>>>>        Else Begin
79367>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79368>>>>>>>>>>>        End
79368>>>>>>>>>>>>
79368>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79369>>>>>>>>>>>        If (bExists) Begin
79371>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79372>>>>>>>>>>>            If (bOpened) Begin
79374>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79375>>>>>>>>>>>                If (bExists) Begin
79377>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79378>>>>>>>>>>>                End
79378>>>>>>>>>>>>
79378>>>>>>>>>>>                Send CloseKey of hoRegistry
79379>>>>>>>>>>>            End
79379>>>>>>>>>>>>
79379>>>>>>>>>>>        End
79379>>>>>>>>>>>>
79379>>>>>>>>>>>        Send Destroy of hoRegistry
79380>>>>>>>>>>>
79380>>>>>>>>>>>        If (sVersion <> "") Begin
79382>>>>>>>>>>>           Send AppendTextLn sVersion
79383>>>>>>>>>>>           Send AppendTextLn ""
79384>>>>>>>>>>>        End
79384>>>>>>>>>>>>
79384>>>>>>>>>>>    End_Procedure
79385>>>>>>>>>>>
79385>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79387>>>>>>>>>>>        Integer hoWorkspace
79387>>>>>>>>>>>
79387>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79389>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79390>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79392>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79393>>>>>>>>>>>            End
79393>>>>>>>>>>>>
79393>>>>>>>>>>>        End
79393>>>>>>>>>>>>
79393>>>>>>>>>>>    End_Procedure
79394>>>>>>>>>>>
79394>>>>>>>>>>>    //****************************************************************************
79394>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79394>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79394>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79394>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79394>>>>>>>>>>>    // the information To be displayed
79394>>>>>>>>>>>    //****************************************************************************
79394>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79394>>>>>>>>>>>
79394>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79396>>>>>>>>>>>        If (ghoConnection > 0) Begin
79398>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79399>>>>>>>>>>>            Send AppendTextLn ""
79400>>>>>>>>>>>        End
79400>>>>>>>>>>>>
79400>>>>>>>>>>>    End_Procedure
79401>>>>>>>>>>>
79401>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79403>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79404>>>>>>>>>>>    End_Function
79405>>>>>>>>>>>
79405>>>>>>>>>>>    Procedure Show_Versions
79407>>>>>>>>>>>        Integer iVersion iRevision iBuild
79407>>>>>>>>>>>
79407>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79409>>>>>>>>>>>
79409>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79410>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79411>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79412>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
79413>>>>>>>>>>>    End_Procedure
79414>>>>>>>>>>>
79414>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79416>>>>>>>>>>>        Boolean bOK
79416>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79417>>>>>>>>>>>        Function_Return bOK
79418>>>>>>>>>>>    End_Function
79419>>>>>>>>>>>
79419>>>>>>>>>>>    //***
79419>>>>>>>>>>>    //*** BW
79419>>>>>>>>>>>    //*** Procedure: Show_Drivers
79419>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79419>>>>>>>>>>>    //***
79419>>>>>>>>>>>
79419>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79419>>>>>>>>>>>//    #Warning -3
79419>>>>>>>>>>>//#ENDIF
79419>>>>>>>>>>>    Procedure Show_Drivers
79421>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79421>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79421>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79421>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79421>>>>>>>>>>>
79421>>>>>>>>>>>        Move False to bStudioLicense
79422>>>>>>>>>>>
79422>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79423>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79424>>>>>>>>>>>
79424>>>>>>>>>>>        // For testing purposes:
79424>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79424>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79424>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79424>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79424>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79424>>>>>>>>>>>//
79424>>>>>>>>>>>        Move False to Err
79425>>>>>>>>>>>
79425>>>>>>>>>>>        // Loop through all loaded drivers.
79425>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79428>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79430>>>>>>>>>>>            Send AppendTextLn ""
79431>>>>>>>>>>>        End
79431>>>>>>>>>>>>
79431>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79437>>>>>>>>>>>>
79437>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79438>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79441>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79442>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79443>>>>>>>>>>>
79443>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79445>>>>>>>>>>>
79445>>>>>>>>>>>                // Pervasive/Btrieve database
79445>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79447>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79448>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79449>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79451>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79452>>>>>>>>>>>                    End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79453>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79455>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79456>>>>>>>>>>>                    End
79456>>>>>>>>>>>>
79456>>>>>>>>>>>                End
79456>>>>>>>>>>>>
79456>>>>>>>>>>>
79456>>>>>>>>>>>                Else Begin
79457>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79458>>>>>>>>>>>                    Move 0 to iNumServers
79459>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79461>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79464>>>>>>>>>>>                    End
79464>>>>>>>>>>>>
79464>>>>>>>>>>>
79464>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79466>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79468>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79469>>>>>>>>>>>                        End
79469>>>>>>>>>>>>
79469>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79470>>>>>>>>>>>                    End
79470>>>>>>>>>>>>
79470>>>>>>>>>>>
79470>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79470>>>>>>>>>>>                    // Studio licens is in use and there is no
79470>>>>>>>>>>>                    // number of max users defined because the driver is
79470>>>>>>>>>>>                    // relying on the info from the VDF license.
79470>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79472>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79473>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79474>>>>>>>>>>>                    End
79474>>>>>>>>>>>>
79474>>>>>>>>>>>                End
79474>>>>>>>>>>>>
79474>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79475>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79477>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79478>>>>>>>>>>>                End
79478>>>>>>>>>>>>
79478>>>>>>>>>>>                If (iNumServers <> 0) Begin
79480>>>>>>>>>>>                    For iCount from 1 to iNumServers
79486>>>>>>>>>>>>
79486>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79489>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79491>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79492>>>>>>>>>>>                        End
79492>>>>>>>>>>>>
79492>>>>>>>>>>>                    Loop
79493>>>>>>>>>>>>
79493>>>>>>>>>>>                End
79493>>>>>>>>>>>>
79493>>>>>>>>>>>            End
79493>>>>>>>>>>>>
79493>>>>>>>>>>>        Loop
79494>>>>>>>>>>>>
79494>>>>>>>>>>>
79494>>>>>>>>>>>        Send AppendTextLn ""
79495>>>>>>>>>>>        If (bStudioLicense = False) Begin
79497>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79498>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79499>>>>>>>>>>>        End
79499>>>>>>>>>>>>
79499>>>>>>>>>>>        Else Begin
79500>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79501>>>>>>>>>>>        End
79501>>>>>>>>>>>>
79501>>>>>>>>>>>        Send Destroy of hoCLIHandler
79502>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79503>>>>>>>>>>>    End_Procedure
79504>>>>>>>>>>>
79504>>>>>>>>>>>    Procedure Show_HelpFile
79506>>>>>>>>>>>        String sHelpFile
79506>>>>>>>>>>>        Integer eHelpType
79506>>>>>>>>>>>
79506>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79508>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79509>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79511>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79512>>>>>>>>>>>            End
79512>>>>>>>>>>>>
79512>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79515>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79516>>>>>>>>>>>            End
79516>>>>>>>>>>>>
79516>>>>>>>>>>>            Else Begin
79517>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79518>>>>>>>>>>>            End
79518>>>>>>>>>>>>
79518>>>>>>>>>>>
79518>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79519>>>>>>>>>>>        End
79519>>>>>>>>>>>>
79519>>>>>>>>>>>    End_Procedure
79520>>>>>>>>>>>
79520>>>>>>>>>>>    Procedure Show_EnterAsTab
79522>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79522>>>>>>>>>>>        String sText
79522>>>>>>>>>>>
79522>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79524>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79525>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79527>>>>>>>>>>>                Move "True" To sText
79528>>>>>>>>>>>            End
79528>>>>>>>>>>>>
79528>>>>>>>>>>>            Else Begin
79529>>>>>>>>>>>                Move "False" To sText
79530>>>>>>>>>>>            End
79530>>>>>>>>>>>>
79530>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79531>>>>>>>>>>>        End
79531>>>>>>>>>>>>
79531>>>>>>>>>>>    End_Procedure
79532>>>>>>>>>>>
79532>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79532>>>>>>>>>>>    //    found systeminformation
79532>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79534>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79536>>>>>>>>>>>
79536>>>>>>>>>>>        Send Delete_Data
79537>>>>>>>>>>>
79537>>>>>>>>>>>        Set Changed_State To False
79538>>>>>>>>>>>        Set Read_Only_State To True
79539>>>>>>>>>>>
79539>>>>>>>>>>>        Send Show_Registration
79540>>>>>>>>>>>        Send Show_Drivers
79541>>>>>>>>>>>        Send Show_ServicePack
79542>>>>>>>>>>>        Send Show_Versions
79543>>>>>>>>>>>        Send AppendTextLn ""
79544>>>>>>>>>>>
79544>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79546>>>>>>>>>>>            Send Show_WorkSpaceInformation
79547>>>>>>>>>>>            Send Show_HelpFile
79548>>>>>>>>>>>            Send AppendTextLn ""
79549>>>>>>>>>>>        End
79549>>>>>>>>>>>>
79549>>>>>>>>>>>        Else Begin
79550>>>>>>>>>>>            Send AppendTextLn ""
79551>>>>>>>>>>>        End
79551>>>>>>>>>>>>
79551>>>>>>>>>>>
79551>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79553>>>>>>>>>>>            Send Show_ConnectionIdInformation
79554>>>>>>>>>>>        End
79554>>>>>>>>>>>>
79554>>>>>>>>>>>
79554>>>>>>>>>>>        Send Show_Current_User
79555>>>>>>>>>>>        Send Show_Windows_Directory
79556>>>>>>>>>>>        Send Show_Current_Directory
79557>>>>>>>>>>>
79557>>>>>>>>>>>        // This is already shown in the workspace details,
79557>>>>>>>>>>>        // unless no workspace object is present:
79557>>>>>>>>>>>        If (ghoApplication = 0) Begin
79559>>>>>>>>>>>            Send Show_Filelist_Name
79560>>>>>>>>>>>        End
79560>>>>>>>>>>>>
79560>>>>>>>>>>>
79560>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79562>>>>>>>>>>>            Send AppendTextLn ""
79563>>>>>>>>>>>            Send Show_EnterAsTab
79564>>>>>>>>>>>        End
79564>>>>>>>>>>>>
79564>>>>>>>>>>>
79564>>>>>>>>>>>        Send Show_Screen_Size
79565>>>>>>>>>>>        Send Show_Page_Size
79566>>>>>>>>>>>        Send Show_Number_Format
79567>>>>>>>>>>>        Send Show_Date_Format
79568>>>>>>>>>>>        Send Show_Lock_Delay
79569>>>>>>>>>>>        Send Show_Lock_Timeout
79570>>>>>>>>>>>        Send Show_Date
79571>>>>>>>>>>>        Send Show_Systemresources
79572>>>>>>>>>>>        Send Beginning_of_Data
79573>>>>>>>>>>>
79573>>>>>>>>>>>        Set Icon to 'default.ico'
79574>>>>>>>>>>>    End_Procedure
79575>>>>>>>>>>>End_Class
79576>>>>>>>>>>>
79576>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79577>>>>>>>>>>>    Procedure Construct_Object
79579>>>>>>>>>>>        Forward Send Construct_Object
79581>>>>>>>>>>>
79581>>>>>>>>>>>        Set Label to C_$SystemInformation
79582>>>>>>>>>>>        Set Size to 140 267
79583>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79584>>>>>>>>>>>        Set Border_Style to Border_Thick
79585>>>>>>>>>>>        Set Sysmenu_Icon to False
79586>>>>>>>>>>>
79586>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79586>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79587>>>>>>>>>>>
79587>>>>>>>>>>>        // 2014-09-14 NGS
79587>>>>>>>>>>>        // Added a container object around the cTexteditor
79587>>>>>>>>>>>        // object to get a border around the text.
79587>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79589>>>>>>>>>>>            Set Location to 2 4
79590>>>>>>>>>>>            Set Size to 110 255
79591>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79592>>>>>>>>>>>            Set Color to clWhite
79593>>>>>>>>>>>            Set peAnchors to anAll
79594>>>>>>>>>>>
79594>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79596>>>>>>>>>>>            End_Object
79597>>>>>>>>>>>
79597>>>>>>>>>>>        End_Object
79598>>>>>>>>>>>
79598>>>>>>>>>>>        Object oCloseButton is a Button
79600>>>>>>>>>>>            Set Label to C_$Close
79601>>>>>>>>>>>            Set Location to 120 210
79602>>>>>>>>>>>            CompilerWarnings Off
79602>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79603>>>>>>>>>>>            CompilerWarnings On
79603>>>>>>>>>>>            Set Default_State To True
79604>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79604>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79604>>>>>>>>>>>            // for that situation.
79604>>>>>>>>>>>            Set peAnchors to anBottomRight
79605>>>>>>>>>>>        End_Object
79606>>>>>>>>>>>
79606>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79608>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79609>>>>>>>>>>>            Set Size to 14 50
79610>>>>>>>>>>>            Set Location to 120 158
79611>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79611>>>>>>>>>>>            // we might as well prepare the object for it.
79611>>>>>>>>>>>            Set peAnchors to anBottomRight
79612>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79613>>>>>>>>>>>        End_Object
79614>>>>>>>>>>>
79614>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79615>>>>>>>>>>>    End_Procedure
79616>>>>>>>>>>>
79616>>>>>>>>>>>    Procedure Page Integer iPageObject
79618>>>>>>>>>>>        Handle hMenu
79618>>>>>>>>>>>        Integer iPrevState
79618>>>>>>>>>>>
79618>>>>>>>>>>>        Forward Send Page iPageObject
79620>>>>>>>>>>>
79620>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79620>>>>>>>>>>>        //
79620>>>>>>>>>>>    End_Procedure
79621>>>>>>>>>>>
79621>>>>>>>>>>>End_Class
79622>>>>>>>>>>>
79622>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79623>>>>>>>>>>>    Procedure Construct_Object
79625>>>>>>>>>>>        Forward Send Construct_Object
79627>>>>>>>>>>>
79627>>>>>>>>>>>        Property String psContentText
79628>>>>>>>>>>>
79628>>>>>>>>>>>        Set Size to 77 153
79629>>>>>>>>>>>        Set Location to 8 60
79630>>>>>>>>>>>        Set Read_Only_State to True
79631>>>>>>>>>>>        Set Skip_State to True
79632>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79632>>>>>>>>>>>        // or 1/20 of a printer's point.
79632>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79633>>>>>>>>>>>        Set Border_Style  to Border_None
79634>>>>>>>>>>>    End_Procedure
79635>>>>>>>>>>>
79635>>>>>>>>>>>    // Adds a line of text to the edit object
79635>>>>>>>>>>>    Procedure Add_Line String sText
79637>>>>>>>>>>>        String sContentText
79637>>>>>>>>>>>        Get psContentText to sContentText
79638>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79639>>>>>>>>>>>        Set psContentText to sContentText
79640>>>>>>>>>>>    End_Procedure
79641>>>>>>>>>>>
79641>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79641>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79641>>>>>>>>>>>    // because the object isn't paged yet when we add these
79641>>>>>>>>>>>    // values and the COM edit object needs to be paged
79641>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79641>>>>>>>>>>>    Procedure Add_LineLn String sText
79643>>>>>>>>>>>        String sContentText sCR
79643>>>>>>>>>>>
79643>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79644>>>>>>>>>>>        Get psContentText to sContentText
79645>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79646>>>>>>>>>>>        Set psContentText to sContentText
79647>>>>>>>>>>>    End_Procedure
79648>>>>>>>>>>>
79648>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79650>>>>>>>>>>>        String sLinkText
79650>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79651>>>>>>>>>>>        Send Show_HomePage sLinkText
79652>>>>>>>>>>>    End_Procedure
79653>>>>>>>>>>>
79653>>>>>>>>>>>    Procedure Page Integer iPageObject
79655>>>>>>>>>>>        String sContentText
79655>>>>>>>>>>>
79655>>>>>>>>>>>        Forward Send Page iPageObject
79657>>>>>>>>>>>        Get psContentText to sContentText
79658>>>>>>>>>>>        Send AppendText sContentText
79659>>>>>>>>>>>        send Beginning_of_Data
79660>>>>>>>>>>>    End_Procedure
79661>>>>>>>>>>>
79661>>>>>>>>>>>End_Class
79662>>>>>>>>>>>
79662>>>>>>>>>>>Class AboutDialog is a ModalPanel
79663>>>>>>>>>>>    Procedure Construct_Object
79665>>>>>>>>>>>
79665>>>>>>>>>>>        Forward Send Construct_Object
79667>>>>>>>>>>>
79667>>>>>>>>>>>        Set Label to C_$About
79668>>>>>>>>>>>        Set Size to 118 230
79669>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79670>>>>>>>>>>>        Set Border_Style to Border_Thick
79671>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79672>>>>>>>>>>>
79672>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79674>>>>>>>>>>>        End_Object
79675>>>>>>>>>>>
79675>>>>>>>>>>>        Object oBox is a Container3d
79677>>>>>>>>>>>            Set Border_Style to Border_Normal
79678>>>>>>>>>>>            Set Size to 90 220
79679>>>>>>>>>>>            Set Location to 4 5
79680>>>>>>>>>>>            Set Color to clWhite
79681>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79681>>>>>>>>>>>            // we might as well prepare the object for it.
79681>>>>>>>>>>>            Set peAnchors to anAll
79682>>>>>>>>>>>
79682>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79684>>>>>>>>>>>                Set Border_Style To Border_None
79685>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79686>>>>>>>>>>>                Set Color to clWhite
79687>>>>>>>>>>>                Set Size to 45 50
79688>>>>>>>>>>>                Set Location to 0 3
79689>>>>>>>>>>>            End_Object
79690>>>>>>>>>>>
79690>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79692>>>>>>>>>>>                Set Border_Style to Border_None
79693>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79694>>>>>>>>>>>                Set Color to clWhite
79695>>>>>>>>>>>                Set Size to 30 55
79696>>>>>>>>>>>                Set Location to 50 3
79697>>>>>>>>>>>            End_Object
79698>>>>>>>>>>>
79698>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79700>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79700>>>>>>>>>>>                // we might as well prepare the object for it.
79700>>>>>>>>>>>                Set peAnchors to anAll
79701>>>>>>>>>>>            End_Object
79702>>>>>>>>>>>
79702>>>>>>>>>>>            // These objects are here for backwards compatability only.
79702>>>>>>>>>>>            // They are not used.
79702>>>>>>>>>>>            Object oProductName is a TextBox
79704>>>>>>>>>>>                Set Label To C_$ProductName
79705>>>>>>>>>>>                Set Size To 10 45
79706>>>>>>>>>>>                Set Location To 8 53
79707>>>>>>>>>>>                Set Visible_State to False
79708>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79709>>>>>>>>>>>            End_Object
79710>>>>>>>>>>>
79710>>>>>>>>>>>            Object oVersion is a TextBox
79712>>>>>>>>>>>                Set Label To C_$Version
79713>>>>>>>>>>>                Set Size To 10 25
79714>>>>>>>>>>>                Set Location To 21 53
79715>>>>>>>>>>>                Set Visible_State to False
79716>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79717>>>>>>>>>>>            End_Object
79718>>>>>>>>>>>
79718>>>>>>>>>>>            Object oCopyright is a TextBox
79720>>>>>>>>>>>                Set Label To C_$Copyright
79721>>>>>>>>>>>                Set Size To 10 31
79722>>>>>>>>>>>                Set Location To 34 53
79723>>>>>>>>>>>                Set Visible_State to False
79724>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79725>>>>>>>>>>>            End_Object
79726>>>>>>>>>>>
79726>>>>>>>>>>>            Object oAuthor is a TextBox
79728>>>>>>>>>>>                Set Label To C_$Author
79729>>>>>>>>>>>                Set Size To 10 22
79730>>>>>>>>>>>                Set Location To 46 53
79731>>>>>>>>>>>                Set Visible_State to False
79732>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79733>>>>>>>>>>>            End_Object
79734>>>>>>>>>>>
79734>>>>>>>>>>>        End_Object
79735>>>>>>>>>>>
79735>>>>>>>>>>>        Object oOKButton is a Button
79737>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79738>>>>>>>>>>>            Set Location to 98 176
79739>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79739>>>>>>>>>>>            // we might as well prepare the object for it.
79739>>>>>>>>>>>            Set peAnchors to anBottomRight
79740>>>>>>>>>>>        End_Object
79741>>>>>>>>>>>
79741>>>>>>>>>>>        Object oSysInfoButton is a Button
79743>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79744>>>>>>>>>>>            Set Location to 98 123
79745>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79745>>>>>>>>>>>            // we might as well prepare the object for it.
79745>>>>>>>>>>>            Set peAnchors to anBottomRight
79746>>>>>>>>>>>        End_Object
79747>>>>>>>>>>>
79747>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79749>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79750>>>>>>>>>>>            Set Size to 14 50
79751>>>>>>>>>>>            Set Location to 98 70
79752>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79752>>>>>>>>>>>            // we might as well prepare the object for it.
79752>>>>>>>>>>>            Set peAnchors to anBottomRight
79753>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79754>>>>>>>>>>>        End_Object
79755>>>>>>>>>>>
79755>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79756>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79757>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79758>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79758>>>>>>>>>>>    End_Procedure
79759>>>>>>>>>>>
79759>>>>>>>>>>>    Procedure Page Integer iPageObject
79761>>>>>>>>>>>        Handle hMenu
79761>>>>>>>>>>>        Integer iPrevState
79761>>>>>>>>>>>
79761>>>>>>>>>>>        Forward Send Page iPageObject
79763>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79763>>>>>>>>>>>        Set Icon to "Default.ico"
79764>>>>>>>>>>>
79764>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79764>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79765>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79766>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79766>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79766>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79767>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79768>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79769>>>>>>>>>>>        // The "Close" menu command may be good to have.
79769>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79769>>>>>>>>>>>    End_Procedure
79770>>>>>>>>>>>
79770>>>>>>>>>>>    Procedure Set ProductName String sText
79772>>>>>>>>>>>        Set Value of oProductName to sText
79773>>>>>>>>>>>    End_Procedure
79774>>>>>>>>>>>
79774>>>>>>>>>>>    Procedure Set Copyright String sText
79776>>>>>>>>>>>        Set Value of oCopyright to sText
79777>>>>>>>>>>>    End_Procedure
79778>>>>>>>>>>>
79778>>>>>>>>>>>    Procedure Set Author String sText
79780>>>>>>>>>>>        Set Value of oAuthor to sText
79781>>>>>>>>>>>    End_Procedure
79782>>>>>>>>>>>
79782>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79782>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79782>>>>>>>>>>>    //       program as a pre-compile!
79782>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79782>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79782>>>>>>>>>>>
79782>>>>>>>>>>>    Procedure Set Version String sVersion
79784>>>>>>>>>>>        Handle hoVersionInfo
79784>>>>>>>>>>>        Boolean bIncluded
79784>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79784>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79784>>>>>>>>>>>
79784>>>>>>>>>>>        If (sVersion = "") Begin
79786>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79786>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79786>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79788>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79789>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79791>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79792>>>>>>>>>>>                    If (bIncluded) Begin
79794>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79795>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79796>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79797>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79798>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79799>>>>>>>>>>>                    End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>                End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>            End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>        End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>
79799>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79799>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79800>>>>>>>>>>>        Readln sCompileDateAndTime
79801>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79802>>>>>>>>>>>        If (iPos <> 0) Begin
79804>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79805>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79806>>>>>>>>>>>        End
79806>>>>>>>>>>>>
79806>>>>>>>>>>>        Close_Input
79807>>>>>>>>>>>
79807>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79809>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79810>>>>>>>>>>>        End
79810>>>>>>>>>>>>
79810>>>>>>>>>>>
79810>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79811>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79813>>>>>>>>>>>            If (sCertInfo <> "") Begin
79815>>>>>>>>>>>                Send Add_LineLn sCertInfo
79816>>>>>>>>>>>            End
79816>>>>>>>>>>>>
79816>>>>>>>>>>>            Else Begin
79817>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79818>>>>>>>>>>>            End
79818>>>>>>>>>>>>
79818>>>>>>>>>>>        End
79818>>>>>>>>>>>>
79818>>>>>>>>>>>    End_Procedure
79819>>>>>>>>>>>
79819>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79821>>>>>>>>>>>        Boolean bIsDate
79821>>>>>>>>>>>        String sGoodCharacters sChar
79821>>>>>>>>>>>        Integer iCount iLength
79821>>>>>>>>>>>
79821>>>>>>>>>>>        Move True to bIsDate
79822>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79823>>>>>>>>>>>        Move (Length(sDate)) to iLength
79824>>>>>>>>>>>        For iCount from 1 to iLength
79830>>>>>>>>>>>>
79830>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79831>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79832>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79833>>>>>>>>>>>            If (bIsDate = False) Begin
79835>>>>>>>>>>>                Move iLength to iCount
79836>>>>>>>>>>>            End
79836>>>>>>>>>>>>
79836>>>>>>>>>>>        Loop
79837>>>>>>>>>>>>
79837>>>>>>>>>>>        Function_Return bIsDate
79838>>>>>>>>>>>    End_Function
79839>>>>>>>>>>>
79839>>>>>>>>>>>    Function GetCompileDate Returns Date
79841>>>>>>>>>>>        Date dCompileDate
79841>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79841>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79841>>>>>>>>>>>        Boolean bIsValid   
79841>>>>>>>>>>>        
79841>>>>>>>>>>>        Move 0 to dCompileDate
79842>>>>>>>>>>>        // Get full path to the current running executable
79842>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79843>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79844>>>>>>>>>>>
79844>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79844>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79845>>>>>>>>>>>
79845>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79847>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79848>>>>>>>>>>>        If (iPos > 0) Begin
79850>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79850>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79851>>>>>>>>>>>
79851>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79851>>>>>>>>>>>            // change the format and then move the string to the date variable.
79851>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79854>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79857>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79858>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79860>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79861>>>>>>>>>>>            End
79861>>>>>>>>>>>>
79861>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79862>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79863>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79866>>>>>>>>>>>        End
79866>>>>>>>>>>>>
79866>>>>>>>>>>>        Else Begin
79867>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79868>>>>>>>>>>>>
79868>>>>>>>>>>>        End
79868>>>>>>>>>>>>
79868>>>>>>>>>>>
79868>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79869>>>>>>>>>>>
79869>>>>>>>>>>>        Function_Return dCompileDate
79870>>>>>>>>>>>    End_Function
79871>>>>>>>>>>>
79871>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79871>>>>>>>>>>>    // (the passed program), has been finished
79871>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79871>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79873>>>>>>>>>>>        Handle hProcess
79873>>>>>>>>>>>        Integer iVoid
79873>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79873>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79873>>>>>>>>>>>
79873>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79874>>>>>>>>>>>
79874>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79875>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79876>>>>>>>>>>>
79876>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79877>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79878>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79878>>>>>>>>>>>        Move 0                       to sInfo.nShow
79879>>>>>>>>>>>
79879>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79880>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79881>>>>>>>>>>>        If (hProcess) Begin
79883>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79884>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79885>>>>>>>>>>>        End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>    End_Procedure
79886>>>>>>>>>>>
79886>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79888>>>>>>>>>>>        String sDirSep
79888>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79889>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79890>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79892>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79893>>>>>>>>>>>        End
79893>>>>>>>>>>>>
79893>>>>>>>>>>>        Function_Return sPath
79894>>>>>>>>>>>    End_Function
79895>>>>>>>>>>>
79895>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79895>>>>>>>>>>>    // or there is a problem with the certificate.
79895>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79895>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79895>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79897>>>>>>>>>>>        Boolean bExists
79897>>>>>>>>>>>        String sPath sProgram sParams sRetval
79897>>>>>>>>>>>        Integer iCh
79897>>>>>>>>>>>
79897>>>>>>>>>>>        Move "" to sRetval
79898>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79899>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79900>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79901>>>>>>>>>>>        If (bExists = False) Begin
79903>>>>>>>>>>>            Function_Return "-1"
79904>>>>>>>>>>>        End
79904>>>>>>>>>>>>
79904>>>>>>>>>>>
79904>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79905>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79906>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79907>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79908>>>>>>>>>>>        Get Seq_New_Channel to iCh
79909>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79911>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79914>>>>>>>>>>>        Close_Output channel iCh
79916>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79916>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79917>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79919>>>>>>>>>>>            Readln channel iCh sRetval
79921>>>>>>>>>>>            Readln channel iCh sRetval
79923>>>>>>>>>>>            Readln channel iCh sRetval
79925>>>>>>>>>>>            Readln channel iCh sRetval
79927>>>>>>>>>>>        Close_Input channel iCh
79929>>>>>>>>>>>        Send Seq_Release_Channel iCh
79930>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79932>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79933>>>>>>>>>>>        End
79933>>>>>>>>>>>>
79933>>>>>>>>>>>        Else Begin
79934>>>>>>>>>>>            Move "" to sRetval
79935>>>>>>>>>>>        End
79935>>>>>>>>>>>>
79935>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79935>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79936>>>>>>>>>>>>
79936>>>>>>>>>>>        Function_Return sRetval
79937>>>>>>>>>>>    End_Function
79938>>>>>>>>>>>
79938>>>>>>>>>>>    Procedure Add_LineLn String sValue
79940>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79941>>>>>>>>>>>    End_Procedure
79942>>>>>>>>>>>
79942>>>>>>>>>>>    Procedure Add_Line String sValue
79944>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79945>>>>>>>>>>>    End_Procedure
79946>>>>>>>>>>>
79946>>>>>>>>>>>    Procedure Set Logo string sLogo
79948>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79948>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79949>>>>>>>>>>>    End_Procedure
79950>>>>>>>>>>>
79950>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79952>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79953>>>>>>>>>>>    End_Procedure
79954>>>>>>>>>>>
79954>>>>>>>>>>>    Procedure Show_Sysinfo
79956>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79957>>>>>>>>>>>    End_Procedure
79958>>>>>>>>>>>
79958>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79960>>>>>>>>>>>        Handle hWnd
79960>>>>>>>>>>>        Get Window_Handle to hWnd
79961>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79962>>>>>>>>>>>    End_Procedure
79963>>>>>>>>>>>
79963>>>>>>>>>>>End_Class
79964>>>>>>>>>
79964>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79966>>>>>>>>>    End_Function
79967>>>>>>>>>
79967>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
79967>>>>>>>>>
79967>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79968>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79969>>>>>>>>>>
79969>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79971>>>>>>>>>>    Integer iStart iEnd
79971>>>>>>>>>>    String sRetval
79971>>>>>>>>>>
79971>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79972>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79973>>>>>>>>>>    If (iStart = 0) Begin
79975>>>>>>>>>>        Function_Return ""
79976>>>>>>>>>>    End
79976>>>>>>>>>>>
79976>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79977>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79978>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79980>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79981>>>>>>>>>>    End
79981>>>>>>>>>>>
79981>>>>>>>>>>    Else Begin
79982>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79983>>>>>>>>>>    End
79983>>>>>>>>>>>
79983>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79985>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79986>>>>>>>>>>        Decrement iEnd
79987>>>>>>>>>>    End
79987>>>>>>>>>>>
79987>>>>>>>>>>    If (iEnd <> 0) Begin
79989>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79990>>>>>>>>>>    End
79990>>>>>>>>>>>
79990>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79991>>>>>>>>>>
79991>>>>>>>>>>    Function_Return (Trim(sRetval))
79992>>>>>>>>>>End_Function
79993>>>>>>>>>>
79993>>>>>>>>>>
79993>>>>>>>>>    
79993>>>>>>>>>    Procedure Construct_Object
79995>>>>>>>>>        Handle ho
79995>>>>>>>>>        Forward Send Construct_Object
79997>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79998>>>>>>>>>        
79998>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79999>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
80000>>>>>>>>>        Property String[] pasSQLDataTables
80001>>>>>>>>>        Property tFilelist[] pFileListArray  
80002>>>>>>>>>        Property tFilelist[] pErrorTables
80003>>>>>>>>>
80003>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
80003>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
80003>>>>>>>>>        // etc settings.
80003>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80005>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
80006>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
80007>>>>>>>>>            Set phoSQLConnectionHandler to ho
80008>>>>>>>>>        End
80008>>>>>>>>>>
80008>>>>>>>>>
80008>>>>>>>>>    End_Procedure
80009>>>>>>>>>
80009>>>>>>>>>    Procedure End_Construct_Object
80011>>>>>>>>>        Forward Send End_Construct_Object
80013>>>>>>>>>
80013>>>>>>>>>    End_Procedure
80014>>>>>>>>>
80014>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
80014>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
80014>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
80014>>>>>>>>>    // Good read about which collation to select:
80014>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
80014>>>>>>>>>    Procedure Set psCollation String sCollation
80016>>>>>>>>>        Set private.psCollation to sCollation
80017>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80019>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80020>>>>>>>>>        End
80020>>>>>>>>>>
80020>>>>>>>>>    End_Procedure
80021>>>>>>>>>
80021>>>>>>>>>    Function psCollation Returns String
80023>>>>>>>>>        String sCollation
80023>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80025>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80026>>>>>>>>>        End   
80026>>>>>>>>>>
80026>>>>>>>>>        Else Begin
80027>>>>>>>>>            Get private.psCollation to sCollation
80028>>>>>>>>>        End
80028>>>>>>>>>>
80028>>>>>>>>>        Function_Return sCollation
80029>>>>>>>>>    End_Function
80030>>>>>>>>>
80030>>>>>>>>>    // Array sorting helper functions:
80030>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80032>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80034>>>>>>>>>            Function_Return (EQ)
80035>>>>>>>>>        End
80035>>>>>>>>>>
80035>>>>>>>>>
80035>>>>>>>>>        Function_Return (GT)
80036>>>>>>>>>    End_Function
80037>>>>>>>>>
80037>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80039>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80042>>>>>>>>>
80042>>>>>>>>>        Function_Return (GT)
80043>>>>>>>>>    End_Function
80044>>>>>>>>>
80044>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80044>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80044>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80046>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80046>>>>>>>>>        Handle hTable
80046>>>>>>>>>        Boolean bIsSame
80046>>>>>>>>>
80046>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80047>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80048>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80051>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80052>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80055>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80058>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80059>>>>>>>>>
80059>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80061>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80062>>>>>>>>>        End
80062>>>>>>>>>>
80062>>>>>>>>>        Else Begin
80063>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80064>>>>>>>>>        End
80064>>>>>>>>>>
80064>>>>>>>>>
80064>>>>>>>>>        Function_Return bIsSame
80065>>>>>>>>>    End_Function
80066>>>>>>>>>
80066>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80068>>>>>>>>>        Integer iRetval
80068>>>>>>>>>        Move 1 to iRetval
80069>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80071>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80072>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80073>>>>>>>>>        End
80073>>>>>>>>>>
80073>>>>>>>>>        Function_Return (iRetval = 0)
80074>>>>>>>>>    End_Function
80075>>>>>>>>>
80075>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80077>>>>>>>>>        String sDirSep
80077>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80078>>>>>>>>>        Move (Trim(sPath)) to sPath
80079>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80081>>>>>>>>>            Move (sPath + sDirSep) to sPath
80082>>>>>>>>>        End
80082>>>>>>>>>>
80082>>>>>>>>>        Function_Return sPath
80083>>>>>>>>>    End_Function
80084>>>>>>>>>
80084>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80086>>>>>>>>>        Integer i iCols iItem
80086>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80086>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80087>>>>>>>>>
80087>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80088>>>>>>>>>        For i from 1 to iCols
80094>>>>>>>>>>
80094>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80095>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80096>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80097>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80098>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80099>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80100>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80101>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80102>>>>>>>>>        Loop
80103>>>>>>>>>>
80103>>>>>>>>>        Set piColumns to iCols
80104>>>>>>>>>        Set paQueryColumns to aQueryColumns
80105>>>>>>>>>    End_Procedure
80106>>>>>>>>>
80106>>>>>>>>>    // *** Property Messages ***
80106>>>>>>>>>    //
80106>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80106>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80106>>>>>>>>>    //
80106>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80108>>>>>>>>>        tSQLConnection SQLConnection
80108>>>>>>>>>        tSQLConnection SQLConnection
80108>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80110>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80110>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80111>>>>>>>>>>
80111>>>>>>>>>            Function_Return
80112>>>>>>>>>        End
80112>>>>>>>>>>
80112>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80113>>>>>>>>>        Function_Return SQLConnection
80114>>>>>>>>>    End_Function
80115>>>>>>>>>
80115>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80115>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80117>>>>>>>>>        Function_Return False
80118>>>>>>>>>    End_Function
80119>>>>>>>>>
80119>>>>>>>>>    Procedure Set psServer String sValue
80121>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80123>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80123>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80124>>>>>>>>>>
80124>>>>>>>>>            Procedure_Return
80125>>>>>>>>>        End
80125>>>>>>>>>>
80125>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80126>>>>>>>>>    End_Procedure
80127>>>>>>>>>
80127>>>>>>>>>    Function psServer Returns String
80129>>>>>>>>>        String sValue
80129>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80131>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80132>>>>>>>>>>
80132>>>>>>>>>            Function_Return
80133>>>>>>>>>        End
80133>>>>>>>>>>
80133>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80134>>>>>>>>>        Function_Return sValue
80135>>>>>>>>>    End_Function
80136>>>>>>>>>
80136>>>>>>>>>    Procedure Set psDatabase String sValue
80138>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80140>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80141>>>>>>>>>>
80141>>>>>>>>>            Procedure_Return
80142>>>>>>>>>        End
80142>>>>>>>>>>
80142>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80143>>>>>>>>>    End_Procedure
80144>>>>>>>>>
80144>>>>>>>>>    Function psDatabase Returns String
80146>>>>>>>>>        String sValue
80146>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80148>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80149>>>>>>>>>>
80149>>>>>>>>>            Function_Return
80150>>>>>>>>>        End
80150>>>>>>>>>>
80150>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80151>>>>>>>>>        Function_Return sValue
80152>>>>>>>>>    End_Function
80153>>>>>>>>>
80153>>>>>>>>>    Procedure Set psUserID String sValue
80155>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80157>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80158>>>>>>>>>>
80158>>>>>>>>>            Procedure_Return
80159>>>>>>>>>        End
80159>>>>>>>>>>
80159>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80160>>>>>>>>>    End_Procedure
80161>>>>>>>>>
80161>>>>>>>>>    Function psUserID Returns String
80163>>>>>>>>>        String sValue
80163>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80165>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80166>>>>>>>>>>
80166>>>>>>>>>            Function_Return
80167>>>>>>>>>        End
80167>>>>>>>>>>
80167>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80168>>>>>>>>>        Function_Return sValue
80169>>>>>>>>>    End_Function
80170>>>>>>>>>
80170>>>>>>>>>    Procedure Set psPassword String sValue
80172>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80174>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80175>>>>>>>>>>
80175>>>>>>>>>            Procedure_Return
80176>>>>>>>>>        End
80176>>>>>>>>>>
80176>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80177>>>>>>>>>    End_Procedure
80178>>>>>>>>>
80178>>>>>>>>>    Function psPassword Returns String
80180>>>>>>>>>        String sValue
80180>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80182>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80183>>>>>>>>>>
80183>>>>>>>>>            Function_Return
80184>>>>>>>>>        End
80184>>>>>>>>>>
80184>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80185>>>>>>>>>        Function_Return sValue
80186>>>>>>>>>    End_Function
80187>>>>>>>>>
80187>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80189>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80191>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80192>>>>>>>>>>
80192>>>>>>>>>            Procedure_Return
80193>>>>>>>>>        End
80193>>>>>>>>>>
80193>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80194>>>>>>>>>    End_Procedure
80195>>>>>>>>>
80195>>>>>>>>>    Function pbTrusted Returns Boolean
80197>>>>>>>>>        Boolean bValue
80197>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80199>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80200>>>>>>>>>>
80200>>>>>>>>>            Function_Return
80201>>>>>>>>>        End
80201>>>>>>>>>>
80201>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80202>>>>>>>>>        Function_Return bValue
80203>>>>>>>>>    End_Function
80204>>>>>>>>>
80204>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80206>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80208>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80209>>>>>>>>>>
80209>>>>>>>>>            Procedure_Return
80210>>>>>>>>>        End
80210>>>>>>>>>>
80210>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80211>>>>>>>>>    End_Procedure
80212>>>>>>>>>
80212>>>>>>>>>    Function pbSilentLogin Returns Boolean
80214>>>>>>>>>        Boolean bValue
80214>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80216>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80217>>>>>>>>>>
80217>>>>>>>>>            Function_Return
80218>>>>>>>>>        End
80218>>>>>>>>>>
80218>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80219>>>>>>>>>        Function_Return bValue
80220>>>>>>>>>    End_Function
80221>>>>>>>>>
80221>>>>>>>>>    Procedure Set psConnectionID String sValue
80223>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80225>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80226>>>>>>>>>>
80226>>>>>>>>>            Procedure_Return
80227>>>>>>>>>        End
80227>>>>>>>>>>
80227>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80228>>>>>>>>>    End_Procedure
80229>>>>>>>>>
80229>>>>>>>>>    Function psConnectionID Returns String
80231>>>>>>>>>        String sValue
80231>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80233>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80234>>>>>>>>>>
80234>>>>>>>>>            Function_Return
80235>>>>>>>>>        End
80235>>>>>>>>>>
80235>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80236>>>>>>>>>        Function_Return sValue
80237>>>>>>>>>    End_Function
80238>>>>>>>>>
80238>>>>>>>>>    Procedure Set psConnectionString String sValue
80240>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80242>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80243>>>>>>>>>>
80243>>>>>>>>>            Procedure_Return
80244>>>>>>>>>        End
80244>>>>>>>>>>
80244>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80245>>>>>>>>>    End_Procedure
80246>>>>>>>>>
80246>>>>>>>>>    Function psConnectionString Returns String
80248>>>>>>>>>        String sValue
80248>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80250>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80251>>>>>>>>>>
80251>>>>>>>>>            Function_Return
80252>>>>>>>>>        End
80252>>>>>>>>>>
80252>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80253>>>>>>>>>        Function_Return sValue
80254>>>>>>>>>    End_Function
80255>>>>>>>>>
80255>>>>>>>>>    // The normal connection string looks something like this;
80255>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80255>>>>>>>>>    // ...and the full connection string looks like this;
80255>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80255>>>>>>>>>    Function psFullConnectionString Returns String
80257>>>>>>>>>        String sConnectionID sConnectionString
80257>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80259>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80260>>>>>>>>>>
80260>>>>>>>>>            Function_Return
80261>>>>>>>>>        End
80261>>>>>>>>>>
80261>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80262>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80263>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80264>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80265>>>>>>>>>    End_Function
80266>>>>>>>>>
80266>>>>>>>>>    Function piConnectionOptions Returns Integer
80268>>>>>>>>>        Integer iValue
80268>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80270>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80271>>>>>>>>>>
80271>>>>>>>>>            Function_Return
80272>>>>>>>>>        End
80272>>>>>>>>>>
80272>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80273>>>>>>>>>        Function_Return iValue
80274>>>>>>>>>    End_Function
80275>>>>>>>>>
80275>>>>>>>>>    Procedure Set psSchema String sValue
80277>>>>>>>>>        tSQLConnection SQLConnection
80277>>>>>>>>>        tSQLConnection SQLConnection
80277>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80279>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80280>>>>>>>>>>
80280>>>>>>>>>            Procedure_Return
80281>>>>>>>>>        End
80281>>>>>>>>>>
80281>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80282>>>>>>>>>    End_Procedure
80283>>>>>>>>>
80283>>>>>>>>>    Function psSchema Returns String
80285>>>>>>>>>        String sRetval
80285>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80287>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80288>>>>>>>>>>
80288>>>>>>>>>            Function_Return
80289>>>>>>>>>        End
80289>>>>>>>>>>
80289>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80290>>>>>>>>>        Function_Return sRetval
80291>>>>>>>>>    End_Function
80292>>>>>>>>>
80292>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80294>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80296>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80297>>>>>>>>>>
80297>>>>>>>>>            Procedure_Return
80298>>>>>>>>>        End
80298>>>>>>>>>>
80298>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80299>>>>>>>>>    End_Procedure
80300>>>>>>>>>
80300>>>>>>>>>    Function psBaseTableSpace Returns String
80302>>>>>>>>>        String sRetval
80302>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80304>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80305>>>>>>>>>>
80305>>>>>>>>>            Function_Return
80306>>>>>>>>>        End
80306>>>>>>>>>>
80306>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80307>>>>>>>>>        Function_Return sRetval
80308>>>>>>>>>    End_Function
80309>>>>>>>>>
80309>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80311>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80313>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80314>>>>>>>>>>
80314>>>>>>>>>            Procedure_Return
80315>>>>>>>>>        End
80315>>>>>>>>>>
80315>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80316>>>>>>>>>    End_Procedure
80317>>>>>>>>>
80317>>>>>>>>>    Function psLongTableSpace Returns String
80319>>>>>>>>>        String sRetval
80319>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80321>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80322>>>>>>>>>>
80322>>>>>>>>>            Function_Return
80323>>>>>>>>>        End
80323>>>>>>>>>>
80323>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80324>>>>>>>>>        Function_Return sRetval
80325>>>>>>>>>    End_Function
80326>>>>>>>>>
80326>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80328>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80330>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80331>>>>>>>>>>
80331>>>>>>>>>            Procedure_Return
80332>>>>>>>>>        End
80332>>>>>>>>>>
80332>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80333>>>>>>>>>    End_Procedure
80334>>>>>>>>>
80334>>>>>>>>>    Function psIndexTableSpace Returns String
80336>>>>>>>>>        String sRetval
80336>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80338>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80339>>>>>>>>>>
80339>>>>>>>>>            Function_Return
80340>>>>>>>>>        End
80340>>>>>>>>>>
80340>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80341>>>>>>>>>        Function_Return sRetval
80342>>>>>>>>>    End_Function
80343>>>>>>>>>
80343>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80345>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80347>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80348>>>>>>>>>>
80348>>>>>>>>>            Procedure_Return
80349>>>>>>>>>        End
80349>>>>>>>>>>
80349>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80350>>>>>>>>>    End_Procedure
80351>>>>>>>>>
80351>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80353>>>>>>>>>        Boolean bState
80353>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80355>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80356>>>>>>>>>>
80356>>>>>>>>>            Function_Return
80357>>>>>>>>>        End
80357>>>>>>>>>>
80357>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80358>>>>>>>>>        Function_Return bState
80359>>>>>>>>>    End_Function
80360>>>>>>>>>
80360>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80362>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80364>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80365>>>>>>>>>>
80365>>>>>>>>>            Procedure_Return
80366>>>>>>>>>        End
80366>>>>>>>>>>
80366>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80367>>>>>>>>>    End_Procedure
80368>>>>>>>>>
80368>>>>>>>>>    Function pbToANSI Returns Boolean
80370>>>>>>>>>        Boolean bState
80370>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80372>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80373>>>>>>>>>>
80373>>>>>>>>>            Function_Return
80374>>>>>>>>>        End
80374>>>>>>>>>>
80374>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80375>>>>>>>>>        Function_Return bState
80376>>>>>>>>>    End_Function
80377>>>>>>>>>
80377>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80379>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80381>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80382>>>>>>>>>>
80382>>>>>>>>>            Procedure_Return
80383>>>>>>>>>        End
80383>>>>>>>>>>
80383>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80384>>>>>>>>>    End_Procedure
80385>>>>>>>>>
80385>>>>>>>>>    Function pbRecnum Returns Boolean
80387>>>>>>>>>        Boolean bState
80387>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80389>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80390>>>>>>>>>>
80390>>>>>>>>>            Function_Return
80391>>>>>>>>>        End
80391>>>>>>>>>>
80391>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80392>>>>>>>>>        Function_Return bState
80393>>>>>>>>>    End_Function
80394>>>>>>>>>
80394>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80396>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80398>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80399>>>>>>>>>>
80399>>>>>>>>>            Procedure_Return
80400>>>>>>>>>        End
80400>>>>>>>>>>
80400>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80401>>>>>>>>>    End_Procedure
80402>>>>>>>>>
80402>>>>>>>>>    Function pbCopyData Returns Boolean
80404>>>>>>>>>        Boolean bState
80404>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80406>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80407>>>>>>>>>>
80407>>>>>>>>>            Function_Return
80408>>>>>>>>>        End
80408>>>>>>>>>>
80408>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80409>>>>>>>>>        Function_Return bState
80410>>>>>>>>>    End_Function
80411>>>>>>>>>
80411>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80413>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80415>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80416>>>>>>>>>>
80416>>>>>>>>>            Procedure_Return
80417>>>>>>>>>        End
80417>>>>>>>>>>
80417>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80418>>>>>>>>>    End_Procedure
80419>>>>>>>>>
80419>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80421>>>>>>>>>        Boolean bState
80421>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80423>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80424>>>>>>>>>>
80424>>>>>>>>>            Function_Return
80425>>>>>>>>>        End
80425>>>>>>>>>>
80425>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80426>>>>>>>>>        Function_Return bState
80427>>>>>>>>>    End_Function
80428>>>>>>>>>
80428>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80430>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80432>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80433>>>>>>>>>>
80433>>>>>>>>>            Procedure_Return
80434>>>>>>>>>        End
80434>>>>>>>>>>
80434>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80435>>>>>>>>>    End_Procedure
80436>>>>>>>>>
80436>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80438>>>>>>>>>        Boolean bState
80438>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80440>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80441>>>>>>>>>>
80441>>>>>>>>>            Function_Return
80442>>>>>>>>>        End
80442>>>>>>>>>>
80442>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80443>>>>>>>>>        Function_Return bState
80444>>>>>>>>>    End_Function
80445>>>>>>>>>
80445>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80447>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80449>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80450>>>>>>>>>>
80450>>>>>>>>>            Procedure_Return
80451>>>>>>>>>        End
80451>>>>>>>>>>
80451>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80452>>>>>>>>>    End_Procedure
80453>>>>>>>>>
80453>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80455>>>>>>>>>        Boolean bState
80455>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80457>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80458>>>>>>>>>>
80458>>>>>>>>>            Function_Return
80459>>>>>>>>>        End
80459>>>>>>>>>>
80459>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80460>>>>>>>>>        Function_Return bState
80461>>>>>>>>>    End_Function
80462>>>>>>>>>
80462>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80464>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80466>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80467>>>>>>>>>>
80467>>>>>>>>>            Procedure_Return
80468>>>>>>>>>        End
80468>>>>>>>>>>
80468>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80469>>>>>>>>>    End_Procedure
80470>>>>>>>>>
80470>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80472>>>>>>>>>        Boolean bState
80472>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80474>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80475>>>>>>>>>>
80475>>>>>>>>>            Function_Return
80476>>>>>>>>>        End
80476>>>>>>>>>>
80476>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80477>>>>>>>>>        Function_Return bState
80478>>>>>>>>>    End_Function
80479>>>>>>>>>
80479>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80481>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80483>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80484>>>>>>>>>>
80484>>>>>>>>>            Procedure_Return
80485>>>>>>>>>        End
80485>>>>>>>>>>
80485>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80486>>>>>>>>>    End_Procedure
80487>>>>>>>>>
80487>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80489>>>>>>>>>        String sRetval
80489>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80491>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80492>>>>>>>>>>
80492>>>>>>>>>            Function_Return
80493>>>>>>>>>        End
80493>>>>>>>>>>
80493>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80494>>>>>>>>>        Function_Return sRetval
80495>>>>>>>>>    End_Function
80496>>>>>>>>>
80496>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80498>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80500>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80501>>>>>>>>>>
80501>>>>>>>>>            Procedure_Return
80502>>>>>>>>>        End
80502>>>>>>>>>>
80502>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80503>>>>>>>>>    End_Procedure
80504>>>>>>>>>
80504>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80506>>>>>>>>>        String sRetval
80506>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80508>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80509>>>>>>>>>>
80509>>>>>>>>>            Function_Return
80510>>>>>>>>>        End
80510>>>>>>>>>>
80510>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80511>>>>>>>>>        Function_Return sRetval
80512>>>>>>>>>    End_Function
80513>>>>>>>>>
80513>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80515>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80517>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80518>>>>>>>>>>
80518>>>>>>>>>            Procedure_Return
80519>>>>>>>>>        End
80519>>>>>>>>>>
80519>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80520>>>>>>>>>    End_Procedure
80521>>>>>>>>>
80521>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80523>>>>>>>>>        String sRetval
80523>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80525>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80526>>>>>>>>>>
80526>>>>>>>>>            Function_Return
80527>>>>>>>>>        End
80527>>>>>>>>>>
80527>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80528>>>>>>>>>        Function_Return sRetval
80529>>>>>>>>>    End_Function
80530>>>>>>>>>
80530>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80532>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80534>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80535>>>>>>>>>>
80535>>>>>>>>>            Procedure_Return
80536>>>>>>>>>        End
80536>>>>>>>>>>
80536>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80537>>>>>>>>>    End_Procedure
80538>>>>>>>>>
80538>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80540>>>>>>>>>        String sRetval
80540>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80542>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80543>>>>>>>>>>
80543>>>>>>>>>            Function_Return
80544>>>>>>>>>        End
80544>>>>>>>>>>
80544>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80545>>>>>>>>>        Function_Return sRetval
80546>>>>>>>>>    End_Function
80547>>>>>>>>>
80547>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80549>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80551>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80552>>>>>>>>>>
80552>>>>>>>>>            Procedure_Return
80553>>>>>>>>>        End
80553>>>>>>>>>>
80553>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80554>>>>>>>>>    End_Procedure
80555>>>>>>>>>
80555>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80557>>>>>>>>>        String sRetval
80557>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80559>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80560>>>>>>>>>>
80560>>>>>>>>>            Function_Return
80561>>>>>>>>>        End
80561>>>>>>>>>>
80561>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80562>>>>>>>>>        Function_Return sRetval
80563>>>>>>>>>    End_Function
80564>>>>>>>>>
80564>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80566>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80568>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80569>>>>>>>>>>
80569>>>>>>>>>            Procedure_Return
80570>>>>>>>>>        End
80570>>>>>>>>>>
80570>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80571>>>>>>>>>    End_Procedure
80572>>>>>>>>>
80572>>>>>>>>>    Function psDriverDefaultValueText Returns String
80574>>>>>>>>>        String sRetval
80574>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80576>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80577>>>>>>>>>>
80577>>>>>>>>>            Function_Return
80578>>>>>>>>>        End
80578>>>>>>>>>>
80578>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80579>>>>>>>>>        Function_Return sRetval
80580>>>>>>>>>    End_Function
80581>>>>>>>>>
80581>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80583>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80585>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80586>>>>>>>>>>
80586>>>>>>>>>            Procedure_Return
80587>>>>>>>>>        End
80587>>>>>>>>>>
80587>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80588>>>>>>>>>    End_Procedure
80589>>>>>>>>>
80589>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80591>>>>>>>>>        Boolean bState
80591>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80593>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80594>>>>>>>>>>
80594>>>>>>>>>            Function_Return
80595>>>>>>>>>        End
80595>>>>>>>>>>
80595>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80596>>>>>>>>>        Function_Return bState
80597>>>>>>>>>    End_Function
80598>>>>>>>>>
80598>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80600>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80602>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80603>>>>>>>>>>
80603>>>>>>>>>            Procedure_Return
80604>>>>>>>>>        End
80604>>>>>>>>>>
80604>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80605>>>>>>>>>    End_Procedure
80606>>>>>>>>>
80606>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80608>>>>>>>>>        Boolean bState
80608>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80610>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80611>>>>>>>>>>
80611>>>>>>>>>            Function_Return
80612>>>>>>>>>        End
80612>>>>>>>>>>
80612>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80613>>>>>>>>>        Function_Return bState
80614>>>>>>>>>    End_Function
80615>>>>>>>>>
80615>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80617>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80619>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80620>>>>>>>>>>
80620>>>>>>>>>            Procedure_Return
80621>>>>>>>>>        End
80621>>>>>>>>>>
80621>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80622>>>>>>>>>    End_Procedure
80623>>>>>>>>>
80623>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80625>>>>>>>>>        Boolean bState
80625>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80627>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80628>>>>>>>>>>
80628>>>>>>>>>            Function_Return
80629>>>>>>>>>        End
80629>>>>>>>>>>
80629>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80630>>>>>>>>>        Function_Return bState
80631>>>>>>>>>    End_Function
80632>>>>>>>>>
80632>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80634>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80636>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80637>>>>>>>>>>
80637>>>>>>>>>            Procedure_Return
80638>>>>>>>>>        End
80638>>>>>>>>>>
80638>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80639>>>>>>>>>    End_Procedure
80640>>>>>>>>>
80640>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80642>>>>>>>>>        Boolean bState
80642>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80644>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80645>>>>>>>>>>
80645>>>>>>>>>            Function_Return
80646>>>>>>>>>        End
80646>>>>>>>>>>
80646>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80647>>>>>>>>>        Function_Return bState
80648>>>>>>>>>    End_Function
80649>>>>>>>>>
80649>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80651>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80653>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80654>>>>>>>>>>
80654>>>>>>>>>            Procedure_Return
80655>>>>>>>>>        End
80655>>>>>>>>>>
80655>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80656>>>>>>>>>    End_Procedure
80657>>>>>>>>>
80657>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80659>>>>>>>>>        Boolean bState
80659>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80661>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80662>>>>>>>>>>
80662>>>>>>>>>            Function_Return
80663>>>>>>>>>        End
80663>>>>>>>>>>
80663>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80664>>>>>>>>>        Function_Return bState
80665>>>>>>>>>    End_Function
80666>>>>>>>>>
80666>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80668>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80670>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80671>>>>>>>>>>
80671>>>>>>>>>            Procedure_Return
80672>>>>>>>>>        End
80672>>>>>>>>>>
80672>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80673>>>>>>>>>    End_Procedure
80674>>>>>>>>>
80674>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80676>>>>>>>>>        Boolean bState
80676>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80678>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80679>>>>>>>>>>
80679>>>>>>>>>            Function_Return
80680>>>>>>>>>        End
80680>>>>>>>>>>
80680>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80681>>>>>>>>>        Function_Return bState
80682>>>>>>>>>    End_Function
80683>>>>>>>>>
80683>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80683>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80683>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80683>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80683>>>>>>>>>    Procedure Set psDriverID String sValue
80685>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80686>>>>>>>>>        Delegate Set psDriverID to sValue
80688>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80689>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80690>>>>>>>>>    End_Procedure
80691>>>>>>>>>
80691>>>>>>>>>    Function psDriverID Returns String
80693>>>>>>>>>        String sDriverID
80693>>>>>>>>>
80693>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80694>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80694>>>>>>>>>        Delegate Get psDriverID to sDriverID
80696>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80697>>>>>>>>>        Move False to Err
80698>>>>>>>>>
80698>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80698>>>>>>>>>        // probably used as "utilites" from a special made program and
80698>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80698>>>>>>>>>        If (sDriverID = "") Begin
80700>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80701>>>>>>>>>        End
80701>>>>>>>>>>
80701>>>>>>>>>        Function_Return sDriverID
80702>>>>>>>>>    End_Function
80703>>>>>>>>>
80703>>>>>>>>>    Procedure Set piDbType Integer iValue
80705>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80706>>>>>>>>>        Delegate Set piDbType to iValue
80708>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80709>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80710>>>>>>>>>    End_Procedure
80711>>>>>>>>>
80711>>>>>>>>>    Function piDbType Returns Integer
80713>>>>>>>>>        Integer iRetval
80713>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80714>>>>>>>>>        Function_Return iRetval
80715>>>>>>>>>    End_Function
80716>>>>>>>>>
80716>>>>>>>>>    // Returns the index for the passed sTableName
80716>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80716>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80718>>>>>>>>>        Integer iIndex iSize iCount iItem
80718>>>>>>>>>        String[] asTablesArray
80719>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80719>>>>>>>>>
80719>>>>>>>>>        Move -1 to iIndex
80720>>>>>>>>>        Get psConnectionString to sConnectionString
80721>>>>>>>>>        Get psDatabase to sDatabase
80722>>>>>>>>>        Get psSchema   to sSchema
80723>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
80724>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
80725>>>>>>>>>        If (iItem <> -1) Begin
80727>>>>>>>>>            Move iItem to iIndex
80728>>>>>>>>>        End
80728>>>>>>>>>>
80728>>>>>>>>>        Function_Return iIndex
80729>>>>>>>>>    End_Function
80730>>>>>>>>>
80730>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80730>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80732>>>>>>>>>        String[] sReturnArray
80733>>>>>>>>>        Boolean bOK
80733>>>>>>>>>
80733>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80734>>>>>>>>>        If (bOK = False) Begin
80736>>>>>>>>>            Function_Return sReturnArray
80737>>>>>>>>>        End
80737>>>>>>>>>>
80737>>>>>>>>>
80737>>>>>>>>>        Case Begin
80737>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80739>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80740>>>>>>>>>                Case Break
80741>>>>>>>>>
80741>>>>>>>>>            Case Else
80741>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80742>>>>>>>>>>
80742>>>>>>>>>                Case Break
80743>>>>>>>>>        Case End
80743>>>>>>>>>
80743>>>>>>>>>        Function_Return sReturnArray
80744>>>>>>>>>    End_Function
80745>>>>>>>>>
80745>>>>>>>>>    // Returns a string array with all tables for the current database.
80745>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80747>>>>>>>>>        String[] asReturnArray
80748>>>>>>>>>        String sConnectionString sSelect
80748>>>>>>>>>        Integer iSize iCount iDbType
80748>>>>>>>>>        Boolean bOK
80748>>>>>>>>>
80748>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80750>>>>>>>>>            Function_Return asReturnArray
80751>>>>>>>>>        End
80751>>>>>>>>>>
80751>>>>>>>>>
80751>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80752>>>>>>>>>        If (bOK = False) Begin
80754>>>>>>>>>            Function_Return asReturnArray
80755>>>>>>>>>        End
80755>>>>>>>>>>
80755>>>>>>>>>        If (sSchema = "") Begin
80757>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80758>>>>>>>>>        End
80758>>>>>>>>>>
80758>>>>>>>>>
80758>>>>>>>>>        Get psConnectionString to sConnectionString
80759>>>>>>>>>
80759>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80759>>>>>>>>>        // the dbType.
80759>>>>>>>>>        Get piDbType to iDbType
80760>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80762>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80764>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80765>>>>>>>>>            End
80765>>>>>>>>>>
80765>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80767>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80768>>>>>>>>>            End
80768>>>>>>>>>>
80768>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80770>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80771>>>>>>>>>            End
80771>>>>>>>>>>
80771>>>>>>>>>        End
80771>>>>>>>>>>
80771>>>>>>>>>
80771>>>>>>>>>        Case Begin
80771>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80773>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80774>>>>>>>>>                Case Break
80775>>>>>>>>>
80775>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80778>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80779>>>>>>>>>                Case Break
80780>>>>>>>>>
80780>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80783>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80784>>>>>>>>>                Case Break
80785>>>>>>>>>
80785>>>>>>>>>            Case Else
80785>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80786>>>>>>>>>>
80786>>>>>>>>>                Case Break
80787>>>>>>>>>        Case End
80787>>>>>>>>>
80787>>>>>>>>>        Function_Return asReturnArray
80788>>>>>>>>>    End_Function
80789>>>>>>>>>
80789>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80789>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80791>>>>>>>>>        String[] sReturnArray
80792>>>>>>>>>        Boolean bOK
80792>>>>>>>>>
80792>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80793>>>>>>>>>        If (bOK = False) Begin
80795>>>>>>>>>            Function_Return sReturnArray
80796>>>>>>>>>        End
80796>>>>>>>>>>
80796>>>>>>>>>
80796>>>>>>>>>        Case Begin
80796>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80798>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80799>>>>>>>>>                Case Break
80800>>>>>>>>>
80800>>>>>>>>>            Case Else
80800>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80801>>>>>>>>>>
80801>>>>>>>>>                Case Break
80802>>>>>>>>>        Case End
80802>>>>>>>>>
80802>>>>>>>>>        Function_Return sReturnArray
80803>>>>>>>>>    End_Function
80804>>>>>>>>>
80804>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80804>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80806>>>>>>>>>        String[] sReturnArray
80807>>>>>>>>>        String sConnectionString sSelect sSchema
80807>>>>>>>>>        Boolean bOK
80807>>>>>>>>>        Integer iDbType
80807>>>>>>>>>
80807>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80808>>>>>>>>>        If (bOK = False) Begin
80810>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80811>>>>>>>>>>
80811>>>>>>>>>            Function_Return sReturnArray
80812>>>>>>>>>        End
80812>>>>>>>>>>
80812>>>>>>>>>
80812>>>>>>>>>        Get psConnectionString to sConnectionString
80813>>>>>>>>>        Get psSchema to sSchema
80814>>>>>>>>>
80814>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80814>>>>>>>>>        // the dbType.
80814>>>>>>>>>        Get piDbType to iDbType
80815>>>>>>>>>
80815>>>>>>>>>        Case Begin
80815>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80817>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80819>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80820>>>>>>>>>                End
80820>>>>>>>>>>
80820>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80822>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80823>>>>>>>>>                End
80823>>>>>>>>>>
80823>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80825>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80826>>>>>>>>>                End
80826>>>>>>>>>>
80826>>>>>>>>>
80826>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80827>>>>>>>>>                Case Break
80828>>>>>>>>>
80828>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80831>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80832>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80833>>>>>>>>>                Case Break
80834>>>>>>>>>
80834>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80837>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80838>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80839>>>>>>>>>                Case Break
80840>>>>>>>>>
80840>>>>>>>>>            Case Else
80840>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80841>>>>>>>>>>
80841>>>>>>>>>                Case Break
80842>>>>>>>>>        Case End
80842>>>>>>>>>
80842>>>>>>>>>        Function_Return sReturnArray
80843>>>>>>>>>    End_Function
80844>>>>>>>>>
80844>>>>>>>>>
80844>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80844>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80846>>>>>>>>>        String[] asReturnArray asReturnArray2
80848>>>>>>>>>        String sConnectionString sSelect sSchema
80848>>>>>>>>>        Boolean bOK
80848>>>>>>>>>        Integer iCount iSize
80848>>>>>>>>>
80848>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80849>>>>>>>>>        If (bOK = False) Begin
80851>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80852>>>>>>>>>>
80852>>>>>>>>>            Function_Return asReturnArray
80853>>>>>>>>>        End
80853>>>>>>>>>>
80853>>>>>>>>>
80853>>>>>>>>>        Get psConnectionString to sConnectionString
80854>>>>>>>>>        Get psSchema to sSchema
80855>>>>>>>>>
80855>>>>>>>>>        Case Begin
80855>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80857>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80858>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80859>>>>>>>>>                Case Break
80860>>>>>>>>>
80860>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80863>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80864>>>>>>>>>>
80864>>>>>>>>>//                Move () to sSelect
80864>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80864>>>>>>>>>                Case Break
80865>>>>>>>>>
80865>>>>>>>>>            Case Else
80865>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80866>>>>>>>>>>
80866>>>>>>>>>                Case Break
80867>>>>>>>>>        Case End
80867>>>>>>>>>
80867>>>>>>>>>        Move (SizeOfArray(asReturnArray)) to iSize
80868>>>>>>>>>        Decrement iSize
80869>>>>>>>>>        For iCount from 0 to iSize
80875>>>>>>>>>>
80875>>>>>>>>>            If (Trim(asReturnArray[iCount]) <> "") Begin
80877>>>>>>>>>                Move asReturnArray[iCount] to asReturnArray2[SizeOfArray(asReturnArray2)]
80878>>>>>>>>>            End
80878>>>>>>>>>>
80878>>>>>>>>>        Loop
80879>>>>>>>>>>
80879>>>>>>>>>
80879>>>>>>>>>        Function_Return asReturnArray2
80880>>>>>>>>>    End_Function
80881>>>>>>>>>
80881>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80881>>>>>>>>>    // The format of the array is "TableName.FieldName"
80881>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80883>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80885>>>>>>>>>        tSQLRelation[] sRelationsArray
80885>>>>>>>>>        tSQLRelation[] sRelationsArray
80886>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80886>>>>>>>>>        Boolean bOK
80886>>>>>>>>>        Integer iCount iSize iLength
80886>>>>>>>>>
80886>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80887>>>>>>>>>        If (bOK = False) Begin
80889>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80890>>>>>>>>>>
80890>>>>>>>>>            Function_Return sRelationsArray
80891>>>>>>>>>        End
80891>>>>>>>>>>
80891>>>>>>>>>
80891>>>>>>>>>        Get psConnectionString to sConnectionString
80892>>>>>>>>>        Get psSchema to sSchema
80893>>>>>>>>>
80893>>>>>>>>>        Case Begin
80893>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80895>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80896>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80897>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80898>>>>>>>>>                Case Break
80899>>>>>>>>>
80899>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80902>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80903>>>>>>>>>>
80903>>>>>>>>>//                Move () to sSelect
80903>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80903>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80903>>>>>>>>>                Case Break
80904>>>>>>>>>
80904>>>>>>>>>            Case Else
80904>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80905>>>>>>>>>>
80905>>>>>>>>>                Case Break
80906>>>>>>>>>        Case End
80906>>>>>>>>>
80906>>>>>>>>>        Move (Length(sTableName)) to iLength
80907>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80908>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80909>>>>>>>>>        Decrement iSize
80910>>>>>>>>>        For iCount from 0 to iSize
80916>>>>>>>>>>
80916>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80918>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80919>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80920>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80921>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80922>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80923>>>>>>>>>            End
80923>>>>>>>>>>
80923>>>>>>>>>        Loop
80924>>>>>>>>>>
80924>>>>>>>>>
80924>>>>>>>>>        Function_Return sRelationsArray
80925>>>>>>>>>    End_Function
80926>>>>>>>>>
80926>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80928>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80928>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80929>>>>>>>>>        String[] sUsers sPrograms
80931>>>>>>>>>        String sSelect
80931>>>>>>>>>        Integer iSize iCount
80931>>>>>>>>>
80931>>>>>>>>>        Case Begin
80931>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80933>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80934>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80935>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80936>>>>>>>>>                Case Break
80937>>>>>>>>>            Case Else
80937>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80938>>>>>>>>>>
80938>>>>>>>>>        Case End
80938>>>>>>>>>
80938>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80939>>>>>>>>>        Decrement iSize
80940>>>>>>>>>        For iCount from 0 to iSize
80946>>>>>>>>>>
80946>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80947>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80948>>>>>>>>>        Loop
80949>>>>>>>>>>
80949>>>>>>>>>
80949>>>>>>>>>        Function_Return SQLLoggedInUser
80950>>>>>>>>>    End_Function
80951>>>>>>>>>
80951>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80951>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80951>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80953>>>>>>>>>        String[] sFilesData
80954>>>>>>>>>        Boolean bExists
80954>>>>>>>>>        Integer iCh
80954>>>>>>>>>        String sFileName sExt
80954>>>>>>>>>
80954>>>>>>>>>        Get vFolderExists sDataPath to bExists
80955>>>>>>>>>        If (bExists = True) Begin
80957>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80958>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80959>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80960>>>>>>>>>            Direct_Input channel iCh sDataPath
80962>>>>>>>>>                Repeat
80962>>>>>>>>>>
80962>>>>>>>>>                    Readln channel iCh sFileName
80964>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80965>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80967>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80969>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80970>>>>>>>>>                        End
80970>>>>>>>>>>
80970>>>>>>>>>                    End
80970>>>>>>>>>>
80970>>>>>>>>>                Until (SeqEof = True)
80972>>>>>>>>>            Close_Input channel iCh
80974>>>>>>>>>            Send Seq_Release_Channel iCh
80975>>>>>>>>>        End
80975>>>>>>>>>>
80975>>>>>>>>>        Function_Return sFilesData
80976>>>>>>>>>    End_Function
80977>>>>>>>>>
80977>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80977>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80979>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80979>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80979>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80979>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80979>>>>>>>>>        tSQLConnection SQLConnection
80979>>>>>>>>>        tSQLConnection SQLConnection
80979>>>>>>>>>        String[] asCollations
80980>>>>>>>>>        
80980>>>>>>>>>        If (sDriverID = "") Begin
80982>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80983>>>>>>>>>>
80983>>>>>>>>>            Function_Return asCollations
80984>>>>>>>>>        End
80984>>>>>>>>>>
80984>>>>>>>>>
80984>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80984>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80986>>>>>>>>>            Function_Return asCollations
80987>>>>>>>>>        End                 
80987>>>>>>>>>>
80987>>>>>>>>>
80987>>>>>>>>>        Get phoSQLManager to hoSQLManager
80988>>>>>>>>>        Get psConnectionID     to sConnectionID
80989>>>>>>>>>        Get psConnectionString to sConnectionString
80990>>>>>>>>>        Move 0 to LastErr
80991>>>>>>>>>
80991>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80992>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80993>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80994>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80996>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80997>>>>>>>>>>
80997>>>>>>>>>            Function_Return asCollations
80998>>>>>>>>>        End
80998>>>>>>>>>>
80998>>>>>>>>>
80998>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80999>>>>>>>>>
80999>>>>>>>>>        If (hStmt = 0) Begin
81001>>>>>>>>>            Send SqlDisconnect of hoSQLManager
81002>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
81003>>>>>>>>>>
81003>>>>>>>>>            Function_Return asCollations
81004>>>>>>>>>        End
81004>>>>>>>>>>
81004>>>>>>>>>
81004>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
81005>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
81006>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
81007>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
81008>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
81009>>>>>>>>>
81009>>>>>>>>>        // MS-SQL Syntax:  
81009>>>>>>>>>        // SELECT name, description
81009>>>>>>>>>        //   from sys.fn_helpcollations();
81009>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
81010>>>>>>>>>
81010>>>>>>>>>        Move 1 to iColumn
81011>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
81012>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
81013>>>>>>>>>        Repeat
81013>>>>>>>>>>
81013>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
81014>>>>>>>>>            If (iFetchResult <> 0) Begin
81016>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
81017>>>>>>>>>                If (sValue <> sPrevious) Begin         
81019>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81019>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81019>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81020>>>>>>>>>                    If (iPos <> 1) Begin
81022>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81023>>>>>>>>>                    End
81023>>>>>>>>>>
81023>>>>>>>>>                End
81023>>>>>>>>>>
81023>>>>>>>>>                Move sValue to sPrevious
81024>>>>>>>>>            End
81024>>>>>>>>>>
81024>>>>>>>>>        Until (iFetchResult = 0)
81026>>>>>>>>>        Send SQLClose of hStmt
81027>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81028>>>>>>>>>
81028>>>>>>>>>        Function_Return asCollations
81029>>>>>>>>>    End_Function
81030>>>>>>>>>
81030>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81030>>>>>>>>>    // for DAW drivers.
81030>>>>>>>>>    // Returns: A string array.
81030>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81032>>>>>>>>>        String[] sReturnArray
81033>>>>>>>>>        String sValue sPrevious
81033>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81033>>>>>>>>>        Integer iFetchResult iRows
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>
81033>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81034>>>>>>>>>
81034>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81036>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81037>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81038>>>>>>>>>
81038>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81040>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81041>>>>>>>>>                If (hstmt <> 0) Begin
81043>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81044>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81045>>>>>>>>>                    Repeat
81045>>>>>>>>>>
81045>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81046>>>>>>>>>                        If (iFetchResult <> 0) Begin
81048>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81049>>>>>>>>>                            If (sValue <> sPrevious) Begin
81051>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81052>>>>>>>>>                            End
81052>>>>>>>>>>
81052>>>>>>>>>                            Move sValue to sPrevious
81053>>>>>>>>>                        End
81053>>>>>>>>>>
81053>>>>>>>>>                    Until (iFetchResult = 0)
81055>>>>>>>>>                    Send SQLClose of hstmt
81056>>>>>>>>>                End
81056>>>>>>>>>>
81056>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81057>>>>>>>>>            End
81057>>>>>>>>>>
81057>>>>>>>>>        End
81057>>>>>>>>>>
81057>>>>>>>>>
81057>>>>>>>>>        Function_Return sReturnArray
81058>>>>>>>>>    End_Function
81059>>>>>>>>>
81059>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81061>>>>>>>>>        String[] sReturnArray
81062>>>>>>>>>        String sDataSource
81062>>>>>>>>>        Handle hoSQLHandler
81062>>>>>>>>>        Integer iItem
81062>>>>>>>>>
81062>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81063>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81064>>>>>>>>>
81064>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81065>>>>>>>>>
81065>>>>>>>>>        Repeat
81065>>>>>>>>>>
81065>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81066>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81067>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81068>>>>>>>>>            Increment iItem
81069>>>>>>>>>        Until (sDataSource = "")
81071>>>>>>>>>
81071>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81072>>>>>>>>>
81072>>>>>>>>>        Function_Return sReturnArray
81073>>>>>>>>>    End_Function
81074>>>>>>>>>
81074>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81076>>>>>>>>>        String[] sReturnArray
81077>>>>>>>>>        String sDataSource
81077>>>>>>>>>        Handle hoSQLHandler
81077>>>>>>>>>        Integer iItem
81077>>>>>>>>>
81077>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81078>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81079>>>>>>>>>
81079>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81080>>>>>>>>>
81080>>>>>>>>>        Repeat
81080>>>>>>>>>>
81080>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81081>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81083>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81084>>>>>>>>>                Increment iItem
81085>>>>>>>>>            End
81085>>>>>>>>>>
81085>>>>>>>>>        Until (sDataSource = "")
81087>>>>>>>>>
81087>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81088>>>>>>>>>
81088>>>>>>>>>        Function_Return sReturnArray
81089>>>>>>>>>    End_Function
81090>>>>>>>>>
81090>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81092>>>>>>>>>        String[] sDataSources
81093>>>>>>>>>        tSQLConnection SQLConnection
81093>>>>>>>>>        tSQLConnection SQLConnection
81093>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81093>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81094>>>>>>>>>        Integer iDataSources iCount iItem
81094>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81094>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81094>>>>>>>>>        Boolean bExists bKeyOpened
81094>>>>>>>>>
81094>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81095>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81096>>>>>>>>>        Move SQLConnection.sServer           to sServer
81097>>>>>>>>>
81097>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81097>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81099>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81100>>>>>>>>>            Set psFileName of hoIniFile to sServer
81101>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81102>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81103>>>>>>>>>            Send Destroy of hoIniFile
81104>>>>>>>>>        End
81104>>>>>>>>>>
81104>>>>>>>>>
81104>>>>>>>>>        // DSN - read DATABASE name from the registry
81104>>>>>>>>>        Else Begin
81105>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81106>>>>>>>>>
81106>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81106>>>>>>>>>            // most probably place the info is kept that we're after.
81106>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81107>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81108>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81109>>>>>>>>>            If (bExists = True) Begin
81111>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81112>>>>>>>>>            End
81112>>>>>>>>>>
81112>>>>>>>>>            Else Begin
81113>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81114>>>>>>>>>            End
81114>>>>>>>>>>
81114>>>>>>>>>
81114>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81115>>>>>>>>>            If (bExists) Begin
81117>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81118>>>>>>>>>                If (bKeyOpened) Begin
81120>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81121>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81122>>>>>>>>>                    If (iDataSources > 0) Begin
81124>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81125>>>>>>>>>                        Decrement iDataSources
81126>>>>>>>>>                        for iCount from 0 to iDataSources
81132>>>>>>>>>>
81132>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81133>>>>>>>>>                        Loop
81134>>>>>>>>>>
81134>>>>>>>>>                        Move 0 to iItem
81135>>>>>>>>>                        for iCount from 0 to iDataSources
81141>>>>>>>>>>
81141>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81142>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81143>>>>>>>>>                            If (bKeyOpened = True) Begin
81145>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81146>>>>>>>>>                                If (bExists = True) Begin
81148>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81149>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81150>>>>>>>>>                                    Increment iItem
81151>>>>>>>>>                                End
81151>>>>>>>>>>
81151>>>>>>>>>                            End
81151>>>>>>>>>>
81151>>>>>>>>>                        Loop
81152>>>>>>>>>>
81152>>>>>>>>>                    End
81152>>>>>>>>>>
81152>>>>>>>>>                    Send CloseKey of hoRegistry
81153>>>>>>>>>                    Send Destroy of hoODBCDataSources
81154>>>>>>>>>                End
81154>>>>>>>>>>
81154>>>>>>>>>            End
81154>>>>>>>>>>
81154>>>>>>>>>
81154>>>>>>>>>            // We then check the "User DNS" area in the registry.
81154>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81155>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81156>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81157>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81158>>>>>>>>>
81158>>>>>>>>>            If (bExists) Begin
81160>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81161>>>>>>>>>                If (bKeyOpened) Begin
81163>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81164>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81165>>>>>>>>>                    If (iDataSources > 0) Begin
81167>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81168>>>>>>>>>                        Decrement iDataSources
81169>>>>>>>>>                        for iCount from 0 to iDataSources
81175>>>>>>>>>>
81175>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81176>>>>>>>>>                        Loop
81177>>>>>>>>>>
81177>>>>>>>>>                        for iCount from 0 to iDataSources
81183>>>>>>>>>>
81183>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81184>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81185>>>>>>>>>                            If (bKeyOpened = True) Begin
81187>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81188>>>>>>>>>                                If (bExists = True) Begin
81190>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81191>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81192>>>>>>>>>                                    Increment iItem
81193>>>>>>>>>                                End
81193>>>>>>>>>>
81193>>>>>>>>>                            End
81193>>>>>>>>>>
81193>>>>>>>>>                        Loop
81194>>>>>>>>>>
81194>>>>>>>>>                    End
81194>>>>>>>>>>
81194>>>>>>>>>                    Send CloseKey of hoRegistry
81195>>>>>>>>>                    Send Destroy of hoODBCDataSources
81196>>>>>>>>>                End
81196>>>>>>>>>>
81196>>>>>>>>>            End
81196>>>>>>>>>>
81196>>>>>>>>>
81196>>>>>>>>>            Send Destroy of hoRegistry
81197>>>>>>>>>        End
81197>>>>>>>>>>
81197>>>>>>>>>
81197>>>>>>>>>        Function_Return sReturnArray
81198>>>>>>>>>    End_Function
81199>>>>>>>>>
81199>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81199>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81199>>>>>>>>>    // insert it for scriplets to come after the first one.
81199>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81201>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81201>>>>>>>>>        Integer iStart iEnd iDbType
81201>>>>>>>>>        Boolean bOK
81201>>>>>>>>>
81201>>>>>>>>>        Get piDbType to iDbType
81202>>>>>>>>>        Get psDriverID to sDriverID
81203>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81204>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81205>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81206>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81207>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81208>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81210>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81211>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81212>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81213>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81214>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81215>>>>>>>>>        End
81215>>>>>>>>>>
81215>>>>>>>>>        Else Begin
81216>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81217>>>>>>>>>
81217>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81217>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81219>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81220>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81221>>>>>>>>>            End
81221>>>>>>>>>>
81221>>>>>>>>>
81221>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81221>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81221>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81221>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81224>>>>>>>>>                // Make sure we only have one space between statements/words.
81224>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81225>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81226>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81227>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81228>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81229>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81231>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81232>>>>>>>>>                End
81232>>>>>>>>>>
81232>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81233>>>>>>>>>                // Remove data view as it already exists!
81233>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81234>>>>>>>>>            End
81234>>>>>>>>>>
81234>>>>>>>>>        End
81234>>>>>>>>>>
81234>>>>>>>>>
81234>>>>>>>>>        Function_Return sStmt
81235>>>>>>>>>    End_Function
81236>>>>>>>>>
81236>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81236>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81238>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81238>>>>>>>>>        Integer iRetval
81238>>>>>>>>>        Boolean bOK
81238>>>>>>>>>
81238>>>>>>>>>        Get psDriverID to sDriverID
81239>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81240>>>>>>>>>
81240>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81241>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81242>>>>>>>>>        Set psSQLStatementString to sSQLString
81243>>>>>>>>>
81243>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81243>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81243>>>>>>>>>        Move False to Err
81244>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81245>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81246>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81247>>>>>>>>>        Move 0 to LastErr
81248>>>>>>>>>
81248>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81248>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81249>>>>>>>>>
81249>>>>>>>>>        Function_Return (Err = False)
81250>>>>>>>>>    End_Function
81251>>>>>>>>>
81251>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81251>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81253>>>>>>>>>        String sRetval
81253>>>>>>>>>        Integer iDbType iIndex
81253>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81253>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81254>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81254>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81254>>>>>>>>>
81254>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81254>>>>>>>>>        Move "" to sRetval
81255>>>>>>>>>        Get piDbType to iDbType
81256>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81257>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81258>>>>>>>>>
81258>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81259>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81260>>>>>>>>>        If (iIndex >= 0) Begin
81262>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81263>>>>>>>>>        End
81263>>>>>>>>>>
81263>>>>>>>>>
81263>>>>>>>>>        Function_Return sRetval
81264>>>>>>>>>    End_Function
81265>>>>>>>>>
81265>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81265>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81267>>>>>>>>>        String[] sSQLScriptArray
81268>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81268>>>>>>>>>        Integer iSize iCount
81268>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81268>>>>>>>>>
81268>>>>>>>>>        Move False to bCommentStart
81269>>>>>>>>>        Move False to bCommentEnd
81270>>>>>>>>>        Move False to bDashComment
81271>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81272>>>>>>>>>        Move "*/"  to sCommentEnd
81273>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81274>>>>>>>>>
81274>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81275>>>>>>>>>        Decrement iSize
81276>>>>>>>>>        Move "" to sText
81277>>>>>>>>>
81277>>>>>>>>>        for iCount from 0 to iSize
81283>>>>>>>>>>
81283>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81284>>>>>>>>>            Move (Trim(sLine)) to sTmp
81285>>>>>>>>>            If (sTmp <> "") Begin
81287>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81288>>>>>>>>>                If (bCommentStart = False) Begin
81290>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81291>>>>>>>>>                    If (bCommentStart = False) Begin
81293>>>>>>>>>                    End
81293>>>>>>>>>>
81293>>>>>>>>>                End
81293>>>>>>>>>>
81293>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81294>>>>>>>>>                If (bCommentEnd = True) Begin
81296>>>>>>>>>                    Move False to bCommentStart
81297>>>>>>>>>                End
81297>>>>>>>>>>
81297>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81299>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81300>>>>>>>>>                End
81300>>>>>>>>>>
81300>>>>>>>>>            End
81300>>>>>>>>>>
81300>>>>>>>>>        Loop
81301>>>>>>>>>>
81301>>>>>>>>>
81301>>>>>>>>>        // Update the retval struct array:
81301>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81302>>>>>>>>>        Function_Return SqlScriptArray
81303>>>>>>>>>    End_Function
81304>>>>>>>>>
81304>>>>>>>>>    // Helper function that builds a string like;
81304>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81304>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81306>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81306>>>>>>>>>
81306>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81307>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81308>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81309>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81310>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81311>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81312>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81313>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81314>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81315>>>>>>>>>        Function_Return sRetval
81316>>>>>>>>>    End_Function
81317>>>>>>>>>
81317>>>>>>>>>    // Helper function to create a SQL statement like;
81317>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81317>>>>>>>>>    // Used for checking if an index exists.
81317>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81319>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81319>>>>>>>>>
81319>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81320>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81321>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81322>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81323>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81324>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81325>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81326>>>>>>>>>
81326>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81327>>>>>>>>>
81327>>>>>>>>>        Function_Return sRetval
81328>>>>>>>>>    End_Function
81329>>>>>>>>>
81329>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81329>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81329>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81331>>>>>>>>>        String sRetval
81331>>>>>>>>>        If (iLength <> 0) Begin
81333>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81334>>>>>>>>>            If (iDecimals <> 0) Begin
81336>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81337>>>>>>>>>            End
81337>>>>>>>>>>
81337>>>>>>>>>            Move (sRetval + ")") to sRetval
81338>>>>>>>>>        End
81338>>>>>>>>>>
81338>>>>>>>>>        Function_Return sRetval
81339>>>>>>>>>    End_Function
81340>>>>>>>>>
81340>>>>>>>>>    // Checks that the passed sDriverID is defined.
81340>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81340>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81342>>>>>>>>>        Boolean bOK
81342>>>>>>>>>        Integer iDriver
81342>>>>>>>>>
81342>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81344>>>>>>>>>            Function_Return False
81345>>>>>>>>>        End
81345>>>>>>>>>>
81345>>>>>>>>>
81345>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81346>>>>>>>>>
81346>>>>>>>>>        If (bOK = False) Begin
81348>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81349>>>>>>>>>>
81349>>>>>>>>>            Function_Return False
81350>>>>>>>>>        End
81350>>>>>>>>>>
81350>>>>>>>>>
81350>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81351>>>>>>>>>        If (iDriver = 0) Begin
81353>>>>>>>>>            Load_Driver sDriverID
81354>>>>>>>>>        End
81354>>>>>>>>>>
81354>>>>>>>>>
81354>>>>>>>>>        Function_Return True
81355>>>>>>>>>    End_Function
81356>>>>>>>>>
81356>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81356>>>>>>>>>    // This is only of concern for certain SQL data types.
81356>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81358>>>>>>>>>        Integer iLength
81358>>>>>>>>>        Boolean bOK bCheckTypeLength
81358>>>>>>>>>
81358>>>>>>>>>        If (num_arguments > 1) Begin
81360>>>>>>>>>            Move iLen to iLength
81361>>>>>>>>>        End
81361>>>>>>>>>>
81361>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81362>>>>>>>>>
81362>>>>>>>>>        If (bCheckTypeLength = True) Begin
81364>>>>>>>>>            Move (iLength > 0) to bOK
81365>>>>>>>>>        End
81365>>>>>>>>>>
81365>>>>>>>>>
81365>>>>>>>>>        Function_Return (bOK = True)
81366>>>>>>>>>    End_Function
81367>>>>>>>>>
81367>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81369>>>>>>>>>        String sVal sSchema sDriverID
81369>>>>>>>>>        Integer iDbType
81369>>>>>>>>>
81369>>>>>>>>>        If (Trim(sTableName) = "") Begin
81371>>>>>>>>>            Function_Return ""
81372>>>>>>>>>        End
81372>>>>>>>>>>
81372>>>>>>>>>
81372>>>>>>>>>        Get psDriverID to sDriverID
81373>>>>>>>>>        Get piDbType   to iDbType
81374>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81376>>>>>>>>>            Get psUserID to sSchema
81377>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81377>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81378>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81379>>>>>>>>>            Function_Return sTableName
81380>>>>>>>>>        End
81380>>>>>>>>>>
81380>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81382>>>>>>>>>            Get psDatabase to sVal
81383>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81384>>>>>>>>>            Function_Return sTableName
81385>>>>>>>>>        End
81385>>>>>>>>>>
81385>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81387>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81388>>>>>>>>>            Function_Return sTableName
81389>>>>>>>>>        End
81389>>>>>>>>>>
81389>>>>>>>>>
81389>>>>>>>>>        Get psSchema to sSchema
81390>>>>>>>>>        If (sSchema = "") Begin
81392>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81393>>>>>>>>>        End
81393>>>>>>>>>>
81393>>>>>>>>>
81393>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81394>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81396>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81398>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81399>>>>>>>>>            End
81399>>>>>>>>>>
81399>>>>>>>>>            Else Begin
81400>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81401>>>>>>>>>            End
81401>>>>>>>>>>
81401>>>>>>>>>        End
81401>>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>        Function_Return sTableName
81402>>>>>>>>>    End_Function
81403>>>>>>>>>
81403>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81403>>>>>>>>>    // the passed sFieldName has the correct spelling.
81403>>>>>>>>>    // Used with Embedded SQL statement calls.
81403>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81403>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81405>>>>>>>>>        String sRetval sValue sDriverID
81405>>>>>>>>>        String[] sColumnNamesArray
81406>>>>>>>>>        Integer iCount iColumns
81406>>>>>>>>>
81406>>>>>>>>>        Move "" to sRetval
81407>>>>>>>>>        Get psDriverID to sDriverID
81408>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81409>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81410>>>>>>>>>        Decrement iColumns
81411>>>>>>>>>
81411>>>>>>>>>        For iCount from 0 to iColumns
81417>>>>>>>>>>
81417>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81418>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81420>>>>>>>>>                Move sValue to sRetval
81421>>>>>>>>>                Move iColumns to iCount // We're done.
81422>>>>>>>>>            End
81422>>>>>>>>>>
81422>>>>>>>>>        Loop
81423>>>>>>>>>>
81423>>>>>>>>>
81423>>>>>>>>>        Function_Return sRetval
81424>>>>>>>>>    End_Function
81425>>>>>>>>>
81425>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81427>>>>>>>>>        String[] sReturnArray
81428>>>>>>>>>        Handle hoSQLHandler
81428>>>>>>>>>        Integer iCount iSize iItem
81428>>>>>>>>>        String sServer
81428>>>>>>>>>        tSQLConnection SQLConnection
81428>>>>>>>>>        tSQLConnection SQLConnection
81428>>>>>>>>>
81428>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81429>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81430>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81431>>>>>>>>>
81431>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81432>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81433>>>>>>>>>        Decrement iSize
81434>>>>>>>>>
81434>>>>>>>>>        For iCount from 0 to iSize
81440>>>>>>>>>>
81440>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81441>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81442>>>>>>>>>            Increment iItem
81443>>>>>>>>>        Loop
81444>>>>>>>>>>
81444>>>>>>>>>
81444>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81445>>>>>>>>>
81445>>>>>>>>>        Function_Return sReturnArray
81446>>>>>>>>>    End_Function
81447>>>>>>>>>
81447>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81449>>>>>>>>>        String[] sReturnArray
81450>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81450>>>>>>>>>        Handle hoSQLHandler
81450>>>>>>>>>        Integer iCount iSize iItem iPos
81450>>>>>>>>>        Boolean bOK
81450>>>>>>>>>        tSQLConnection SQLConnection
81450>>>>>>>>>        tSQLConnection SQLConnection
81450>>>>>>>>>
81450>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81451>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81453>>>>>>>>>            Function_Return sReturnArray
81454>>>>>>>>>        End
81454>>>>>>>>>>
81454>>>>>>>>>
81454>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81455>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81456>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81457>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81458>>>>>>>>>
81458>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81459>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81460>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81461>>>>>>>>>
81461>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81462>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81463>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81463>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81463>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81463>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81463>>>>>>>>>//                If (iPos > 0) Begin
81463>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81463>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81463>>>>>>>>>//                End
81463>>>>>>>>>//            End
81463>>>>>>>>>//        End
81463>>>>>>>>>
81463>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81464>>>>>>>>>        Move False to Err
81465>>>>>>>>>        Move 0 to iItem
81466>>>>>>>>>
81466>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81466>>>>>>>>>        For iCount from 1 to iSize
81472>>>>>>>>>>
81472>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81473>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81474>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81475>>>>>>>>>            If (sSchema = "") Begin
81477>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81478>>>>>>>>>            End
81478>>>>>>>>>>
81478>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81479>>>>>>>>>            Move (Trim(sTable)) to sTable
81480>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81482>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81483>>>>>>>>>            End
81483>>>>>>>>>>
81483>>>>>>>>>            Else Begin
81484>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81485>>>>>>>>>            End
81485>>>>>>>>>>
81485>>>>>>>>>            If (bOK = True) Begin
81487>>>>>>>>>                Move sTable to sReturnArray[iItem]
81488>>>>>>>>>                Increment iItem
81489>>>>>>>>>            End
81489>>>>>>>>>>
81489>>>>>>>>>        Loop
81490>>>>>>>>>>
81490>>>>>>>>>
81490>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81491>>>>>>>>>
81491>>>>>>>>>        Function_Return sReturnArray
81492>>>>>>>>>    End_Function
81493>>>>>>>>>
81493>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81495>>>>>>>>>        String[] sReturnArray
81496>>>>>>>>>        String sValue
81496>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81496>>>>>>>>>        Integer iRetval iCols iFetchResult
81496>>>>>>>>>        tSQLConnection SQLConnection
81496>>>>>>>>>        tSQLConnection SQLConnection
81496>>>>>>>>>
81496>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81497>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81498>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81499>>>>>>>>>
81499>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81501>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81502>>>>>>>>>            If (hStmt <> 0) Begin
81504>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81505>>>>>>>>>                If (sArgument <> "") Begin
81507>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81508>>>>>>>>>                End
81508>>>>>>>>>>
81508>>>>>>>>>
81508>>>>>>>>>                Send SqlCall             of hStmt
81509>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81510>>>>>>>>>                If (iRetval = 0) Begin
81512>>>>>>>>>                    Repeat
81512>>>>>>>>>>
81512>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81513>>>>>>>>>                        If (iCols > 0) Begin
81515>>>>>>>>>                            Repeat
81515>>>>>>>>>>
81515>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81516>>>>>>>>>                                If (iFetchResult <> 0) Begin
81518>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81519>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81520>>>>>>>>>                                End
81520>>>>>>>>>>
81520>>>>>>>>>                            Until (iFetchResult = 0)
81522>>>>>>>>>                        End
81522>>>>>>>>>>
81522>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81523>>>>>>>>>                    Until (iRetval = 0)
81525>>>>>>>>>                    Send SqlClose of hStmt
81526>>>>>>>>>                End
81526>>>>>>>>>>
81526>>>>>>>>>            End
81526>>>>>>>>>>
81526>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81527>>>>>>>>>        End
81527>>>>>>>>>>
81527>>>>>>>>>        Function_Return sReturnArray
81528>>>>>>>>>    End_Function
81529>>>>>>>>>
81529>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81531>>>>>>>>>        String sOrgFormat sNewFormat sRootName hTableName sPhysicalFileName sDriverID sDataPath
81531>>>>>>>>>        Boolean bOpened bOK
81531>>>>>>>>>
81531>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81531>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81531>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81531>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81531>>>>>>>>>        // proper .int files for the two tables.
81531>>>>>>>>>//        If (Uppercase(hTableName) = "CODETYPE" or Uppercase(hTableName) = "CODEMAST") Begin
81531>>>>>>>>>//            Function_Return True
81531>>>>>>>>>//        End
81531>>>>>>>>>
81531>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81534>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81535>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81536>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81537>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81538>>>>>>>>>
81538>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81538>>>>>>>>>//        Sleep 1  
81538>>>>>>>>>        Get _UtilDeleteCacheFile hTableName to bOK
81539>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81542>>>>>>>>>        If (bOpened = False) Begin
81544>>>>>>>>>            Open hTable
81546>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81549>>>>>>>>>        End
81549>>>>>>>>>>
81549>>>>>>>>>        If (bOpened = False) Begin
81551>>>>>>>>>            Function_Return False
81552>>>>>>>>>        End
81552>>>>>>>>>>
81552>>>>>>>>>
81552>>>>>>>>>        Get psDriverID to sDriverID
81553>>>>>>>>>
81553>>>>>>>>>        Move False to Err
81554>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81557>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81558>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81558>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81558>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81559>>>>>>>>>
81559>>>>>>>>>        Move False to Err
81560>>>>>>>>>
81560>>>>>>>>>        If (hTable > 0) Begin
81562>>>>>>>>>            Structure_Start hTable
81563>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81566>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81569>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81571>>>>>>>>>        End
81571>>>>>>>>>>
81571>>>>>>>>>        Else Begin
81572>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81575>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81578>>>>>>>>>        End
81578>>>>>>>>>>
81578>>>>>>>>>        Function_Return (Err = False)
81579>>>>>>>>>    End_Function
81580>>>>>>>>>
81580>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81580>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81582>>>>>>>>>        Handle hTable
81582>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81582>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81582>>>>>>>>>
81582>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81583>>>>>>>>>        If (bSameTableNames = True) Begin
81585>>>>>>>>>            Function_Return True
81586>>>>>>>>>        End
81586>>>>>>>>>>
81586>>>>>>>>>
81586>>>>>>>>>        Move True to bOK
81587>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81588>>>>>>>>>        Set Private.phCurrentTable              to hTable
81589>>>>>>>>>        
81589>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81592>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81594>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81597>>>>>>>>>        End
81597>>>>>>>>>>
81597>>>>>>>>>        
81597>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81600>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81602>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81605>>>>>>>>>        End
81605>>>>>>>>>>
81605>>>>>>>>>        
81605>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81608>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81610>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81613>>>>>>>>>        End
81613>>>>>>>>>>
81613>>>>>>>>>
81613>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81615>>>>>>>>>            Get psConnectionID to sConnectionID
81616>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81617>>>>>>>>>            If (bTableExists = True) Begin
81619>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81620>>>>>>>>>            End
81620>>>>>>>>>>
81620>>>>>>>>>            Else Begin
81621>>>>>>>>>                Get pbToANSI to bANSI
81622>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81623>>>>>>>>>            End
81623>>>>>>>>>>
81623>>>>>>>>>        End
81623>>>>>>>>>>
81623>>>>>>>>>
81623>>>>>>>>>        Function_Return bOK
81624>>>>>>>>>    End_Function
81625>>>>>>>>>
81625>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81625>>>>>>>>>    // It creates an .int file in the first Data folder of the psDataPath property. 
81625>>>>>>>>>    // It is important that the hTable can be opened.
81625>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81627>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81627>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString hTableName sSchemaName sANSI_OEM sNoDriverRootName
81627>>>>>>>>>        String[] asIndexArray
81628>>>>>>>>>        Integer iCount iCh iSize iPos
81628>>>>>>>>>
81628>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81629>>>>>>>>>        Get psConnectionString to sConnectionString
81630>>>>>>>>>
81630>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81631>>>>>>>>>        If (bANSI = False) Begin
81633>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81634>>>>>>>>>        End
81634>>>>>>>>>>
81634>>>>>>>>>
81634>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81635>>>>>>>>>        Get vFolderExists sDataPath to bOK
81636>>>>>>>>>        If (bOK = False) Begin
81638>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81639>>>>>>>>>>
81639>>>>>>>>>            Function_Return False
81640>>>>>>>>>        End
81640>>>>>>>>>>
81640>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81641>>>>>>>>>
81641>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName 
81644>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
81645>>>>>>>>>        If (iPos <> 0) Begin
81647>>>>>>>>>            Move (Mid(sRootName, Length(sRootName), iPos +1)) to sNoDriverRootName
81648>>>>>>>>>        End
81648>>>>>>>>>>
81648>>>>>>>>>        Else Begin
81649>>>>>>>>>            Move sRootName to sNoDriverRootName
81650>>>>>>>>>        End
81650>>>>>>>>>>
81650>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81653>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81654>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81655>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81656>>>>>>>>>
81656>>>>>>>>>        Get psSchema hTable to sSchemaName
81657>>>>>>>>>        If (sSchemaName = "") Begin
81659>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81660>>>>>>>>>        End
81660>>>>>>>>>>
81660>>>>>>>>>
81660>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81660>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81661>>>>>>>>>        If (bExists = True) Begin
81663>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81664>>>>>>>>>        End
81664>>>>>>>>>>
81664>>>>>>>>>
81664>>>>>>>>>        Get _UtilDeleteCacheFile sNoDriverRootName to bOK
81665>>>>>>>>>        Get _SqlUtilEnumerateIndexes sNoDriverRootName sDriverID to asIndexArray
81666>>>>>>>>>
81666>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81667>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81672>>>>>>>>>            If (bUseConnectionID = True) Begin
81674>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81681>>>>>>>>>            End
81681>>>>>>>>>>
81681>>>>>>>>>            Else Begin
81682>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81689>>>>>>>>>            End
81689>>>>>>>>>>
81689>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " hTableName
81694>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81699>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81699>>>>>>>>>            If (bSysFile = True) Begin
81701>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81706>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81711>>>>>>>>>            End
81711>>>>>>>>>>
81711>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81716>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81721>>>>>>>>>
81721>>>>>>>>>            If (bSysFile = False) Begin
81723>>>>>>>>>                Move (SizeOfArray(asIndexArray)) to iSize
81724>>>>>>>>>                Move (SortArray(asIndexArray)) to asIndexArray
81725>>>>>>>>>                If (iSize > 0) Begin
81727>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81730>>>>>>>>>                    Writeln channel iCh // Just an empty line
81732>>>>>>>>>                End
81732>>>>>>>>>>
81732>>>>>>>>>                Decrement iSize
81733>>>>>>>>>                for iCount from 0 to iSize
81739>>>>>>>>>>
81739>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81742>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(asIndexArray[iCount]))
81745>>>>>>>>>                    Writeln channel iCh
81747>>>>>>>>>                Loop
81748>>>>>>>>>>
81748>>>>>>>>>            End
81748>>>>>>>>>>
81748>>>>>>>>>        Send Seq_Close_Channel iCh 
81749>>>>>>>>>        
81749>>>>>>>>>        Open hTable
81751>>>>>>>>>        Structure_Start hTable sDriverID
81752>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE
81754>>>>>>>>>
81754>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81754>>>>>>>>>//        Sleep 1
81754>>>>>>>>>
81754>>>>>>>>>        Function_Return (bOK = True)
81755>>>>>>>>>    End_Function 
81756>>>>>>>>>    
81756>>>>>>>>>    // Simplier version of the _SqlUtilCreateIntFile. It can be used if there is something wrong with the .int file and it needs
81756>>>>>>>>>    // to be refreshed by the driver. 
81756>>>>>>>>>    Function _SqlUtilRefreshIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean        
81758>>>>>>>>>        String sOrgFormat sNewFormat
81758>>>>>>>>>        
81758>>>>>>>>>        Move False to Err
81759>>>>>>>>>        Open hTable
81761>>>>>>>>>        If (Err = True) Begin
81763>>>>>>>>>            Function_Return False
81764>>>>>>>>>        End
81764>>>>>>>>>>
81764>>>>>>>>>        
81764>>>>>>>>>        Structure_Start hTable
81765>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81767>>>>>>>>>    End_Function
81768>>>>>>>>>
81768>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81770>>>>>>>>>        String sDataPath sDriverID
81770>>>>>>>>>        Boolean bOK
81770>>>>>>>>>        Integer iPos
81770>>>>>>>>>
81770>>>>>>>>>        If (sTableName contains ".") Begin
81772>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81773>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
81774>>>>>>>>>        End
81774>>>>>>>>>>
81774>>>>>>>>>
81774>>>>>>>>>        Get psDriverID to sDriverID
81775>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81776>>>>>>>>>        // First delete the cache file:
81776>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81777>>>>>>>>>
81777>>>>>>>>>        Function_Return bOK
81778>>>>>>>>>    End_Function
81779>>>>>>>>>
81779>>>>>>>>>    // Collects all tables from the SQL Database backend and sets the pasSQLTables property.
81779>>>>>>>>>    Procedure UtilFillSQLTables
81781>>>>>>>>>        String[] asSQLTables
81782>>>>>>>>>        String sDataBase
81782>>>>>>>>>        Integer iSize iCount
81782>>>>>>>>>
81782>>>>>>>>>        Get psDatabase to sDataBase
81783>>>>>>>>>        Get _SqlUtilEnumerateTables MSSQLDRV_ID sDataBase "" to asSQLTables
81784>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81785>>>>>>>>>    End_Procedure 
81786>>>>>>>>>    
81786>>>>>>>>>    // This collects *all* filelist entries and sets the pFileListArray struct property.
81786>>>>>>>>>    Procedure UtilFillFileListStruct
81788>>>>>>>>>        tFilelist[] Tables
81788>>>>>>>>>        tFilelist[] Tables
81789>>>>>>>>>        String sRootName sLogicalName sDisplayName sDriver sNoDriverRootname
81789>>>>>>>>>        Handle hTable
81789>>>>>>>>>        Integer iItem iCount
81789>>>>>>>>>        Boolean bIsSystem bIsAlias bOpened
81789>>>>>>>>>        
81789>>>>>>>>>        Move 0 to iItem
81790>>>>>>>>>        Move 0 to hTable 
81791>>>>>>>>>        Repeat
81791>>>>>>>>>>
81791>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81794>>>>>>>>>            // 0 = no more table in Filelist.cfg, 50 = Flexerrs.
81794>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin  
81796>>>>>>>>>                Move False to Err
81797>>>>>>>>>                Move False to bIsSystem
81798>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81801>>>>>>>>>                Get _DriverIDFromRootName sRootName to sDriver
81802>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Reading table" * String(hTable) * "RootName =" * sRootName)
81803>>>>>>>>>                Send DoAdvance of ghoProgressBar
81804>>>>>>>>>                Send Ignore_All of Error_Object_Id
81805>>>>>>>>>                Open hTable
81807>>>>>>>>>                Get_Attribute DF_FILE_OPENED         of hTable to bOpened
81810>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
81813>>>>>>>>>                Send Trap_All of Error_Object_Id
81814>>>>>>>>>                Close hTable
81815>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81818>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81821>>>>>>>>>                Get _TableNameOnly sRootName to sNoDriverRootname
81822>>>>>>>>>                Move hTable              to Tables[iItem].hTable
81823>>>>>>>>>                Move sRootName           to Tables[iItem].sRootName
81824>>>>>>>>>                Move sLogicalName        to Tables[iItem].sLogicalName
81825>>>>>>>>>                Move sDisplayName        to Tables[iItem].sDisplayName
81826>>>>>>>>>                Move sNoDriverRootname   to Tables[iItem].sNoDriverRootname
81827>>>>>>>>>                Move sDriver             to Tables[iItem].sDriver 
81828>>>>>>>>>                Move bIsSystem           to Tables[iItem].bIsSystemFile
81829>>>>>>>>>                Move (bOpened = False)   to Tables[iItem].bErrorOpening
81830>>>>>>>>>                Get _IsAliasTable hTable to Tables[iItem].bIsAlias 
81831>>>>>>>>>                Move False to Err
81832>>>>>>>>>                Increment iItem
81833>>>>>>>>>            End
81833>>>>>>>>>>
81833>>>>>>>>>        Until (hTable = 0)
81835>>>>>>>>>        
81835>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81836>>>>>>>>>        Set pFileListArray to Tables
81837>>>>>>>>>    End_Procedure   
81838>>>>>>>>>    
81838>>>>>>>>>    // Special array search function for the tFilelistLogicalName struct.
81838>>>>>>>>>    // Used by e.g. UtilAliasToMasterTableHandle
81838>>>>>>>>>    Function CompareFileListTable tFilelistLogicalName FileListTable1 tFilelistLogicalName FileListTable2 Returns Integer
81840>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) < Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (LT)
81843>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) > Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (GT)
81846>>>>>>>>>
81846>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) < Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (LT)
81849>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) > Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (GT)
81852>>>>>>>>>            
81852>>>>>>>>>        Function_Return (EQ)
81853>>>>>>>>>    End_Function
81854>>>>>>>>>
81854>>>>>>>>>    // Finds the corresponding Master table for the passed Alias handle
81854>>>>>>>>>    Function UtilAliasToMasterTableHandle Handle hTable Returns Handle
81856>>>>>>>>>        Handle hMasterTable
81856>>>>>>>>>        String sDriver sRootNameAlias sNoDriverRootnameAlias
81856>>>>>>>>>        Boolean bIsAlias bFound bIsIntTable
81856>>>>>>>>>        Integer iSize iCount iItem 
81856>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81856>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81857>>>>>>>>>        tFilelistLogicalName FileListTable
81857>>>>>>>>>        tFilelistLogicalName FileListTable
81857>>>>>>>>>        
81857>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
81858>>>>>>>>>        If (bIsAlias = False) Begin
81860>>>>>>>>>            Function_Return 0
81861>>>>>>>>>        End
81861>>>>>>>>>>
81861>>>>>>>>>        
81861>>>>>>>>>        Move 0 to hMasterTable
81862>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameAlias 
81865>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
81866>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
81867>>>>>>>>>        Get pFilelistLogicalTables  to FilelistLogicalTables
81868>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sLogicalName
81869>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sNoDriverRootname
81870>>>>>>>>>        Move (SearchArray(FileListTable, FilelistLogicalTables, Self, (RefFunc(CompareFileListTable)))) to iItem
81871>>>>>>>>>        If (iItem = -1) Begin
81873>>>>>>>>>            Function_Return 0
81874>>>>>>>>>        End
81874>>>>>>>>>>
81874>>>>>>>>>        Move (Lowercase(sNoDriverRootnameAlias) = Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) and Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) = Lowercase(FilelistLogicalTables[iItem].sLogicalName)) to bFound
81875>>>>>>>>>        If (bFound = True) Begin
81877>>>>>>>>>            Move FilelistLogicalTables[iItem].hTable to hMasterTable
81878>>>>>>>>>            Function_Return hMasterTable
81879>>>>>>>>>        End
81879>>>>>>>>>>
81879>>>>>>>>>        
81879>>>>>>>>>        Function_Return hMasterTable
81880>>>>>>>>>    End_Function
81881>>>>>>>>>     
81881>>>>>>>>>    Function pFilelistLogicalTables Returns tFilelistLogicalName
81883>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81883>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81884>>>>>>>>>        tFilelist[] FileListTables
81884>>>>>>>>>        tFilelist[] FileListTables
81885>>>>>>>>>        Integer iSize iCount
81885>>>>>>>>>        
81885>>>>>>>>>        Get pFileListArray to FileListTables
81886>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
81887>>>>>>>>>        Decrement iSize
81888>>>>>>>>>        for iCount from 0 to iSize
81894>>>>>>>>>>
81894>>>>>>>>>            Move FileListTables[iCount].bErrorOpening       to FilelistLogicalTables[iCount].bErrorOpening    
81895>>>>>>>>>            Move FileListTables[iCount].bIsAlias            to FilelistLogicalTables[iCount].bIsAlias
81896>>>>>>>>>            Move FileListTables[iCount].bIsSystemFile       to FilelistLogicalTables[iCount].bIsSystemFile
81897>>>>>>>>>            Move FileListTables[iCount].hTable              to FilelistLogicalTables[iCount].hTable
81898>>>>>>>>>            Move FileListTables[iCount].sDisplayName        to FilelistLogicalTables[iCount].sDisplayName
81899>>>>>>>>>            Move FileListTables[iCount].sDriver             to FilelistLogicalTables[iCount].sDriver
81900>>>>>>>>>            Move FileListTables[iCount].sLogicalName        to FilelistLogicalTables[iCount].sLogicalName
81901>>>>>>>>>            Move FileListTables[iCount].sNoDriverRootname   to FilelistLogicalTables[iCount].sNoDriverRootname
81902>>>>>>>>>            Move FileListTables[iCount].sRootName           to FilelistLogicalTables[iCount].sRootName
81903>>>>>>>>>        Loop
81904>>>>>>>>>>
81904>>>>>>>>>        Move (SortArray(FilelistLogicalTables)) to FilelistLogicalTables
81905>>>>>>>>>        Function_Return FilelistLogicalTables
81906>>>>>>>>>    End_Function 
81907>>>>>>>>>    
81907>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81907>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81907>>>>>>>>>    // if it is an SQL table
81907>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81909>>>>>>>>>        Boolean bExists bIsSQLTable
81909>>>>>>>>>        String sDataPath sRootName
81909>>>>>>>>>
81909>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81910>>>>>>>>>        If (bExists = False) Begin
81912>>>>>>>>>            Function_Return False
81913>>>>>>>>>        End
81913>>>>>>>>>>
81913>>>>>>>>>
81913>>>>>>>>>        Move False to bIsSQLTable
81914>>>>>>>>>        If (hTable > 0) Begin
81916>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81919>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81920>>>>>>>>>        End
81920>>>>>>>>>>
81920>>>>>>>>>        If (bIsSQLTable = True) Begin
81922>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81923>>>>>>>>>            Function_Return bExists
81924>>>>>>>>>        End
81924>>>>>>>>>>
81924>>>>>>>>>        Else Begin
81925>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81926>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81927>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81928>>>>>>>>>        End
81928>>>>>>>>>>
81928>>>>>>>>>
81928>>>>>>>>>        Function_Return bExists
81929>>>>>>>>>    End_Function
81930>>>>>>>>>
81930>>>>>>>>>    // Note: This variant uses the pasSQLDataTables property!
81930>>>>>>>>>    //       Thus, that property needs to have been initialized before
81930>>>>>>>>>    //       calling.
81930>>>>>>>>>    // It checks that the SQL table exists on the SQL end, *or*
81930>>>>>>>>>    // if embedded database, that the .dat file exists on disk.
81930>>>>>>>>>    Function _UtilTableExists_Ex Handle hTable Returns Boolean
81932>>>>>>>>>        Boolean bExists bIsSQLTable
81932>>>>>>>>>        String sDataPath sRootName
81932>>>>>>>>>
81932>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81933>>>>>>>>>        If (bExists = False) Begin
81935>>>>>>>>>            Function_Return False
81936>>>>>>>>>        End
81936>>>>>>>>>>
81936>>>>>>>>>
81936>>>>>>>>>        Move False to bIsSQLTable
81937>>>>>>>>>        If (hTable > 0) Begin
81939>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81942>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81943>>>>>>>>>        End
81943>>>>>>>>>>
81943>>>>>>>>>        If (bIsSQLTable = True) Begin
81945>>>>>>>>>            Get _UtilTableIsSql_Ex hTable to bExists
81946>>>>>>>>>            Function_Return bExists
81947>>>>>>>>>        End
81947>>>>>>>>>>
81947>>>>>>>>>        Else Begin
81948>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81949>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81950>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81951>>>>>>>>>        End
81951>>>>>>>>>>
81951>>>>>>>>>
81951>>>>>>>>>        Function_Return bExists
81952>>>>>>>>>    End_Function
81953>>>>>>>>>
81953>>>>>>>>>    // Pass a table handle
81953>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81953>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81955>>>>>>>>>        Handle hTable
81955>>>>>>>>>        Boolean bFound
81955>>>>>>>>>
81955>>>>>>>>>        Move False to bFound
81956>>>>>>>>>        Move 0 to hTable
81957>>>>>>>>>        Repeat
81957>>>>>>>>>>
81957>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81960>>>>>>>>>            If (hTable > 0) Begin
81962>>>>>>>>>                If (hTable = hCheckTable) Begin
81964>>>>>>>>>                    Move True to bFound
81965>>>>>>>>>                End
81965>>>>>>>>>>
81965>>>>>>>>>            End
81965>>>>>>>>>>
81965>>>>>>>>>            If (bFound = True) ;                Break
81968>>>>>>>>>        Until (hTable = 0)
81970>>>>>>>>>
81970>>>>>>>>>        Function_Return bFound
81971>>>>>>>>>    End_Function
81972>>>>>>>>>
81972>>>>>>>>>    // Returns number of tables in filelist.cfg.
81972>>>>>>>>>    Function _UtilNumberOfFileListTables Returns Boolean
81974>>>>>>>>>        Handle hTable
81974>>>>>>>>>        Integer iCount
81974>>>>>>>>>
81974>>>>>>>>>        Move 0 to iCount
81975>>>>>>>>>        Move 0 to hTable
81976>>>>>>>>>        Repeat
81976>>>>>>>>>>
81976>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81979>>>>>>>>>            If (hTable > 0) Begin
81981>>>>>>>>>                Increment iCount
81982>>>>>>>>>            End
81982>>>>>>>>>>
81982>>>>>>>>>        Until (hTable = 0)
81984>>>>>>>>>
81984>>>>>>>>>        Function_Return iCount
81985>>>>>>>>>    End_Function
81986>>>>>>>>>
81986>>>>>>>>>    // DataFlex Embedded Database Data Types:
81986>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81986>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81988>>>>>>>>>        tColumnType[] ColumnType
81988>>>>>>>>>        tColumnType[] ColumnType
81989>>>>>>>>>        Integer i
81989>>>>>>>>>
81989>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81990>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81991>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81992>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81993>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81994>>>>>>>>>        Increment i
81995>>>>>>>>>
81995>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81996>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81997>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81998>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81999>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
82000>>>>>>>>>        Increment i
82001>>>>>>>>>
82001>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
82002>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
82003>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
82004>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
82005>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
82006>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82007>>>>>>>>>        Increment i
82008>>>>>>>>>
82008>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
82009>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
82010>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
82011>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
82012>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82013>>>>>>>>>        Increment i
82014>>>>>>>>>
82014>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
82015>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
82016>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
82017>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
82018>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82019>>>>>>>>>        Increment i
82020>>>>>>>>>
82020>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
82021>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
82022>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82023>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
82024>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
82025>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82026>>>>>>>>>        Increment i
82027>>>>>>>>>
82027>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
82028>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
82029>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
82030>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
82031>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
82032>>>>>>>>>
82032>>>>>>>>>        Function_Return ColumnType
82033>>>>>>>>>    End_Function
82034>>>>>>>>>
82034>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
82036>>>>>>>>>        tColumnType[] aColumnType
82036>>>>>>>>>        tColumnType[] aColumnType
82037>>>>>>>>>        Integer i
82037>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
82037>>>>>>>>>>// Generated By The Database Update Framework
82037>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\DB2_DRV_DriverDef.xml
82037>>>>>>>>>>// Driver COLUMN DATA TYPES
82037>>>>>>>>>>//
82037>>>>>>>>>>// Created: 2024-10-15 10:49:58,567
82037>>>>>>>>>>
82037>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82038>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82039>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82040>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82041>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82042>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82043>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82044>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82045>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82046>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82047>>>>>>>>>>            Increment i
82048>>>>>>>>>>
82048>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82049>>>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
82050>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82051>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82052>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82053>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82054>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82055>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82056>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82057>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82058>>>>>>>>>>            Increment i
82059>>>>>>>>>>
82059>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82060>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82061>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82062>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82063>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82064>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82065>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82066>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82067>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82068>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82069>>>>>>>>>>            Increment i
82070>>>>>>>>>>
82070>>>>>>>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
82071>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82072>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82073>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82074>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82075>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82076>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82077>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82078>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82079>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82080>>>>>>>>>>            Increment i
82081>>>>>>>>>>
82081>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82082>>>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
82083>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82084>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82085>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82086>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82087>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82088>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82089>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82090>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82091>>>>>>>>>>            Increment i
82092>>>>>>>>>>
82092>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82093>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82094>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82095>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82096>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82097>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82098>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82099>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82100>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82101>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82102>>>>>>>>>>            Increment i
82103>>>>>>>>>>
82103>>>>>>>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
82104>>>>>>>>>>            Move -350                                    to aColumnType[i].iSQLType
82105>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82106>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82107>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82108>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82109>>>>>>>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
82110>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82111>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82112>>>>>>>>>>            Move 1073741823                              to aColumnType[i].sPrecision
82113>>>>>>>>>>            Increment i
82114>>>>>>>>>>
82114>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82115>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82116>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82117>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82118>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82119>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82120>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82121>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82122>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82123>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82124>>>>>>>>>>            Increment i
82125>>>>>>>>>>
82125>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82126>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82127>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82128>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82129>>>>>>>>>>            Move 192898100                               to aColumnType[i].iDefaultSize
82130>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82131>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82132>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82133>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82134>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82135>>>>>>>>>>            Increment i
82136>>>>>>>>>>
82136>>>>>>>>>>            Move "graphic"                               to aColumnType[i].sSQLType
82137>>>>>>>>>>            Move -95                                     to aColumnType[i].iSQLType
82138>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82139>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82140>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82141>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82142>>>>>>>>>>            Move 127                                     to aColumnType[i].nMaxSize
82143>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82144>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82145>>>>>>>>>>            Move 127                                     to aColumnType[i].sPrecision
82146>>>>>>>>>>            Increment i
82147>>>>>>>>>>
82147>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82148>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82149>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82150>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82151>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82152>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82153>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82154>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82155>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82156>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82157>>>>>>>>>>            Increment i
82158>>>>>>>>>>
82158>>>>>>>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
82159>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82160>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82161>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82162>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82163>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82164>>>>>>>>>>            Move 32000                                   to aColumnType[i].nMaxSize
82165>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82166>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82167>>>>>>>>>>            Move 32000                                   to aColumnType[i].sPrecision
82168>>>>>>>>>>            Increment i
82169>>>>>>>>>>
82169>>>>>>>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
82170>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82171>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82172>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82173>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82174>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82175>>>>>>>>>>            Move 32700                                   to aColumnType[i].nMaxSize
82176>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82177>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82178>>>>>>>>>>            Move 32700                                   to aColumnType[i].sPrecision
82179>>>>>>>>>>            Increment i
82180>>>>>>>>>>
82180>>>>>>>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
82181>>>>>>>>>>            Move -97                                     to aColumnType[i].iSQLType
82182>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82183>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82184>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82185>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82186>>>>>>>>>>            Move 16350                                   to aColumnType[i].nMaxSize
82187>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82188>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82189>>>>>>>>>>            Move 16350                                   to aColumnType[i].sPrecision
82190>>>>>>>>>>            Increment i
82191>>>>>>>>>>
82191>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82192>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82193>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82194>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82195>>>>>>>>>>            Move 192897884                               to aColumnType[i].iDefaultSize
82196>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82197>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82198>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82199>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82200>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82201>>>>>>>>>>            Increment i
82202>>>>>>>>>>
82202>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82203>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82204>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82205>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82206>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82207>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82208>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82209>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82210>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82211>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82212>>>>>>>>>>            Increment i
82213>>>>>>>>>>
82213>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82214>>>>>>>>>>            Move 92                                      to aColumnType[i].iSQLType
82215>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82216>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82217>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82218>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82219>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82220>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82221>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82222>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82223>>>>>>>>>>            Increment i
82224>>>>>>>>>>
82224>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82225>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82226>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82227>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82228>>>>>>>>>>            Move 192898868                               to aColumnType[i].iDefaultSize
82229>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82230>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82231>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82232>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82233>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82234>>>>>>>>>>            Increment i
82235>>>>>>>>>>
82235>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82236>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82237>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82238>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82239>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82240>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82241>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82242>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82243>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82244>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82245>>>>>>>>>>            Increment i
82246>>>>>>>>>>
82246>>>>>>>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
82247>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82248>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82249>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82250>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82251>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82252>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82253>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82254>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82255>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82256>>>>>>>>>>            Increment i
82257>>>>>>>>>>
82257>>>>>>>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
82258>>>>>>>>>>            Move -96                                     to aColumnType[i].iSQLType
82259>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82260>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82261>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82262>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82263>>>>>>>>>>            Move 16336                                   to aColumnType[i].nMaxSize
82264>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82265>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82266>>>>>>>>>>            Move 16336                                   to aColumnType[i].sPrecision
82267>>>>>>>>>>            Increment i
82268>>>>>>>>>>
82268>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82269>>>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
82270>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82271>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82272>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82273>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82274>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82275>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82276>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82277>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82278>>>>>>>>>>            Increment i
82279>>>>>>>>>>
82279>>>>>>>>>>
82279>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82279>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82279>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82279>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82279>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82279>>>>>>>>>//        Increment i
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>//
82279>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82279>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82279>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82279>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82279>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82279>>>>>>>>>
82279>>>>>>>>>        Function_Return aColumnType
82280>>>>>>>>>    End_Function
82281>>>>>>>>>
82281>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82281>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82281>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82283>>>>>>>>>        tColumnType[] aColumnType
82283>>>>>>>>>        tColumnType[] aColumnType
82284>>>>>>>>>        Integer i
82284>>>>>>>>>
82284>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82286>>>>>>>>>>// Generated By The Database Update Framework
82286>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\MSSQLDRV_DriverDef.xml
82286>>>>>>>>>>// Driver COLUMN DATA TYPES
82286>>>>>>>>>>//
82286>>>>>>>>>>// Created: 2024-10-15 10:49:25,717
82286>>>>>>>>>>
82286>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82287>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82288>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82289>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82290>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82291>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82292>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82293>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82294>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82295>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82296>>>>>>>>>>            Increment i
82297>>>>>>>>>>
82297>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82298>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82299>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82300>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82301>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82302>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82303>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82304>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82305>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82306>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82307>>>>>>>>>>            Increment i
82308>>>>>>>>>>
82308>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82309>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82310>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82311>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82312>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82313>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82314>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82315>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82316>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82317>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82318>>>>>>>>>>            Increment i
82319>>>>>>>>>>
82319>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82320>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82321>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82322>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82323>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82324>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82325>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82326>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82327>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82328>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82329>>>>>>>>>>            Increment i
82330>>>>>>>>>>
82330>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82331>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82332>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82333>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82334>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82335>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82336>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82337>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82338>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82339>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82340>>>>>>>>>>            Increment i
82341>>>>>>>>>>
82341>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82342>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82343>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82344>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82345>>>>>>>>>>            Move 115808772                               to aColumnType[i].iDefaultSize
82346>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82347>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82348>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82349>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82350>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82351>>>>>>>>>>            Increment i
82352>>>>>>>>>>
82352>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82353>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82354>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82355>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82356>>>>>>>>>>            Move 115808868                               to aColumnType[i].iDefaultSize
82357>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82358>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82359>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82360>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82361>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82362>>>>>>>>>>            Increment i
82363>>>>>>>>>>
82363>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82364>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82365>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82366>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82367>>>>>>>>>>            Move 115808964                               to aColumnType[i].iDefaultSize
82368>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82369>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82370>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82371>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82372>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82373>>>>>>>>>>            Increment i
82374>>>>>>>>>>
82374>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82375>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82376>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82377>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82378>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82379>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82380>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82381>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82382>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82383>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82384>>>>>>>>>>            Increment i
82385>>>>>>>>>>
82385>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82386>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82387>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82388>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82389>>>>>>>>>>            Move 115808508                               to aColumnType[i].iDefaultSize
82390>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82391>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82392>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82393>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82394>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82395>>>>>>>>>>            Increment i
82396>>>>>>>>>>
82396>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82397>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82398>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82399>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82400>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82401>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82402>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82403>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82404>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82405>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82406>>>>>>>>>>            Increment i
82407>>>>>>>>>>
82407>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82408>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82409>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82410>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82411>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82412>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82413>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82414>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82415>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82416>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82417>>>>>>>>>>            Increment i
82418>>>>>>>>>>
82418>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82419>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82420>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82421>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82422>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82423>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82424>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82425>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82426>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82427>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82428>>>>>>>>>>            Increment i
82429>>>>>>>>>>
82429>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82430>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82431>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82432>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82433>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82434>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82435>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82436>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82437>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82438>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82439>>>>>>>>>>            Increment i
82440>>>>>>>>>>
82440>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82441>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82442>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82443>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82444>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82445>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82446>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82447>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82448>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82449>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82450>>>>>>>>>>            Increment i
82451>>>>>>>>>>
82451>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82452>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82453>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82454>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82455>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82456>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82457>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82458>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82459>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82460>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82461>>>>>>>>>>            Increment i
82462>>>>>>>>>>
82462>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82463>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82464>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82465>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82466>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82467>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82468>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82469>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82470>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82471>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82472>>>>>>>>>>            Increment i
82473>>>>>>>>>>
82473>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82474>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82475>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82476>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82477>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82478>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82479>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82480>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82481>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82482>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82483>>>>>>>>>>            Increment i
82484>>>>>>>>>>
82484>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82485>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82486>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82487>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82488>>>>>>>>>>            Move 115809924                               to aColumnType[i].iDefaultSize
82489>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82490>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82491>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82492>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82493>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82494>>>>>>>>>>            Increment i
82495>>>>>>>>>>
82495>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82496>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82497>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82498>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82499>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82500>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82501>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82502>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82503>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82504>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82505>>>>>>>>>>            Increment i
82506>>>>>>>>>>
82506>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82507>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82508>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82509>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82510>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82511>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82512>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82513>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82514>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82515>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82516>>>>>>>>>>            Increment i
82517>>>>>>>>>>
82517>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82518>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82519>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82520>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82521>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82522>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82523>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82524>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82525>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82526>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82527>>>>>>>>>>            Increment i
82528>>>>>>>>>>
82528>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82529>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82532>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82533>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82534>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82535>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82536>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82537>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82538>>>>>>>>>>            Increment i
82539>>>>>>>>>>
82539>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82540>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82543>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82544>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82545>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82546>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82547>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82548>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82549>>>>>>>>>>            Increment i
82550>>>>>>>>>>
82550>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82551>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82552>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82554>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82555>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82556>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82557>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82558>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82559>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82560>>>>>>>>>>            Increment i
82561>>>>>>>>>>
82561>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82562>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82563>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82565>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82566>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82567>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82568>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82569>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82570>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82571>>>>>>>>>>            Increment i
82572>>>>>>>>>>
82572>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82573>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82574>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82576>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82577>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82578>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82579>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82580>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82581>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82582>>>>>>>>>>            Increment i
82583>>>>>>>>>>
82583>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82584>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82585>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82587>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82588>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82589>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82590>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82591>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82592>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82593>>>>>>>>>>            Increment i
82594>>>>>>>>>>
82594>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82595>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82596>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82598>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82599>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82600>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82601>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82602>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82603>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82604>>>>>>>>>>            Increment i
82605>>>>>>>>>>
82605>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82606>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82609>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82610>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82611>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82612>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82613>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82614>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82615>>>>>>>>>>            Increment i
82616>>>>>>>>>>
82616>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82617>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82618>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82619>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82620>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82621>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82622>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82623>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82624>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82625>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82626>>>>>>>>>>            Increment i
82627>>>>>>>>>>
82627>>>>>>>>>>
82627>>>>>>>>>
82627>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>//
82627>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82627>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82627>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82627>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82627>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82627>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82627>>>>>>>>>//            Increment i
82627>>>>>>>>>
82627>>>>>>>>>        End
82627>>>>>>>>>>
82627>>>>>>>>>
82627>>>>>>>>>        Function_Return aColumnType
82628>>>>>>>>>    End_Function
82629>>>>>>>>>
82629>>>>>>>>>    // MySQL Data Types
82629>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82631>>>>>>>>>        tColumnType[] aColumnType
82631>>>>>>>>>        tColumnType[] aColumnType
82632>>>>>>>>>        Integer i
82632>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82632>>>>>>>>>>// Generated By The Database Update Framework
82632>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82632>>>>>>>>>>// Driver COLUMN DATA TYPES
82632>>>>>>>>>>//
82632>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82632>>>>>>>>>>
82632>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82633>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82634>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82635>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82636>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82637>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82638>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82639>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82640>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82641>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82642>>>>>>>>>>            Increment i
82643>>>>>>>>>>
82643>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82644>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82645>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82646>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82647>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82648>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82649>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82650>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82651>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82652>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82653>>>>>>>>>>            Increment i
82654>>>>>>>>>>
82654>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82655>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82656>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82657>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82658>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82659>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82660>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82661>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82662>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82663>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82664>>>>>>>>>>            Increment i
82665>>>>>>>>>>
82665>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82666>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82667>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82668>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82669>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82670>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82671>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82672>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82673>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82674>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82675>>>>>>>>>>            Increment i
82676>>>>>>>>>>
82676>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82677>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82678>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82679>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82680>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82681>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82682>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82683>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82684>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82685>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82686>>>>>>>>>>            Increment i
82687>>>>>>>>>>
82687>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82688>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82689>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82690>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82691>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82692>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82693>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82694>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82695>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82696>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82697>>>>>>>>>>            Increment i
82698>>>>>>>>>>
82698>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82699>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82700>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82701>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82702>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82703>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82704>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82705>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82706>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82707>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82708>>>>>>>>>>            Increment i
82709>>>>>>>>>>
82709>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82710>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82711>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82712>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82713>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82714>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82715>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82716>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82717>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82718>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82719>>>>>>>>>>            Increment i
82720>>>>>>>>>>
82720>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82721>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82722>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82723>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82724>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82725>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82726>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82727>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82728>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82729>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82730>>>>>>>>>>            Increment i
82731>>>>>>>>>>
82731>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82732>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82734>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82735>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82736>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82737>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82738>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82739>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82740>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82741>>>>>>>>>>            Increment i
82742>>>>>>>>>>
82742>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82743>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82744>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82745>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82746>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82747>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82748>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82749>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82750>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82751>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82752>>>>>>>>>>            Increment i
82753>>>>>>>>>>
82753>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82754>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82755>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82756>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82757>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82758>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82759>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82760>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82761>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82762>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82763>>>>>>>>>>            Increment i
82764>>>>>>>>>>
82764>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82765>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82766>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82767>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82768>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82769>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82770>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82771>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82772>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82773>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82774>>>>>>>>>>            Increment i
82775>>>>>>>>>>
82775>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82776>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82777>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82778>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82779>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82780>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82781>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82782>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82783>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82784>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82785>>>>>>>>>>            Increment i
82786>>>>>>>>>>
82786>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82787>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82788>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82789>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82790>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82791>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82792>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82793>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82794>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82795>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82796>>>>>>>>>>            Increment i
82797>>>>>>>>>>
82797>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82798>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82799>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82800>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82801>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82802>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82803>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82804>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82805>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82806>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82807>>>>>>>>>>            Increment i
82808>>>>>>>>>>
82808>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82809>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82810>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82811>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82812>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82813>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82814>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82815>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82816>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82817>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82818>>>>>>>>>>            Increment i
82819>>>>>>>>>>
82819>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82820>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82821>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82822>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82823>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82824>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82825>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82826>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82827>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82828>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82829>>>>>>>>>>            Increment i
82830>>>>>>>>>>
82830>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82831>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82834>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82835>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82836>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82837>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82838>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82839>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82840>>>>>>>>>>            Increment i
82841>>>>>>>>>>
82841>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82842>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82843>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82844>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82845>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82846>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82847>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82848>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82849>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82850>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82851>>>>>>>>>>            Increment i
82852>>>>>>>>>>
82852>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82853>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82854>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82855>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82856>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82857>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82858>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82859>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82860>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82861>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82862>>>>>>>>>>            Increment i
82863>>>>>>>>>>
82863>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82864>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82867>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82868>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82869>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82870>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82871>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82872>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82873>>>>>>>>>>            Increment i
82874>>>>>>>>>>
82874>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82875>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82876>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82878>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82879>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82880>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82881>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82882>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82883>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82884>>>>>>>>>>            Increment i
82885>>>>>>>>>>
82885>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82886>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82887>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82889>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82890>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82891>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82892>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82893>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82894>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82895>>>>>>>>>>            Increment i
82896>>>>>>>>>>
82896>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82897>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82898>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82900>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82901>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82902>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82903>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82904>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82905>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82906>>>>>>>>>>            Increment i
82907>>>>>>>>>>
82907>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82908>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82909>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82911>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82912>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82913>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82914>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82915>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82916>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82917>>>>>>>>>>            Increment i
82918>>>>>>>>>>
82918>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82919>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82920>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82921>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82922>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82923>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82924>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82925>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82926>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82927>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82928>>>>>>>>>>            Increment i
82929>>>>>>>>>>
82929>>>>>>>>>>
82929>>>>>>>>>
82929>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>//
82929>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82929>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82929>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82929>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82929>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82929>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82929>>>>>>>>>//        Increment i
82929>>>>>>>>>
82929>>>>>>>>>        Function_Return aColumnType
82930>>>>>>>>>    End_Function
82931>>>>>>>>>
82931>>>>>>>>>    // Oracle Data Types
82931>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82933>>>>>>>>>        tColumnType[] aColumnType
82933>>>>>>>>>        tColumnType[] aColumnType
82934>>>>>>>>>        Integer i
82934>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82934>>>>>>>>>>// Generated By The Database Update Framework
82934>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82934>>>>>>>>>>// Driver COLUMN DATA TYPES
82934>>>>>>>>>>//
82934>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82934>>>>>>>>>>
82934>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82935>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82936>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82937>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82938>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82939>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82940>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82941>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82942>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82943>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82944>>>>>>>>>>            Increment i
82945>>>>>>>>>>
82945>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82946>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82947>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82948>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82949>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82950>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82951>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82952>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82953>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82954>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82955>>>>>>>>>>            Increment i
82956>>>>>>>>>>
82956>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82957>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82958>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82959>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82960>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82961>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82962>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82963>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82964>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82965>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82966>>>>>>>>>>            Increment i
82967>>>>>>>>>>
82967>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82968>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82969>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82970>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82971>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82972>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82973>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82974>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82975>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82976>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82977>>>>>>>>>>            Increment i
82978>>>>>>>>>>
82978>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82979>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82980>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82981>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82982>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82983>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82984>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82985>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82986>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82987>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82988>>>>>>>>>>            Increment i
82989>>>>>>>>>>
82989>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82990>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82991>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82992>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82993>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82994>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82995>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82996>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82997>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82998>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82999>>>>>>>>>>            Increment i
83000>>>>>>>>>>
83000>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
83001>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
83002>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83003>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83004>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83005>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83006>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83007>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83008>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83009>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83010>>>>>>>>>>            Increment i
83011>>>>>>>>>>
83011>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83012>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83013>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83014>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83015>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83016>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83017>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83018>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83019>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83020>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83021>>>>>>>>>>            Increment i
83022>>>>>>>>>>
83022>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83023>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83024>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83025>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83026>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83027>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83028>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83029>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83030>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83031>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83032>>>>>>>>>>            Increment i
83033>>>>>>>>>>
83033>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83034>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83036>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83037>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83038>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83039>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83040>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83041>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83042>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83043>>>>>>>>>>            Increment i
83044>>>>>>>>>>
83044>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83045>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83048>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83050>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83051>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83052>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83053>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83054>>>>>>>>>>            Increment i
83055>>>>>>>>>>
83055>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83056>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83059>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83060>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83061>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83062>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83063>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83064>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83065>>>>>>>>>>            Increment i
83066>>>>>>>>>>
83066>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83067>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83068>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83070>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83071>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83072>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83073>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83074>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83075>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83076>>>>>>>>>>            Increment i
83077>>>>>>>>>>
83077>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83078>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83079>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83081>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83082>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83083>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83084>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83085>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83086>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83087>>>>>>>>>>            Increment i
83088>>>>>>>>>>
83088>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83089>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83090>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83092>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83093>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83094>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83095>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83096>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83097>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83098>>>>>>>>>>            Increment i
83099>>>>>>>>>>
83099>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83100>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83101>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83103>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83104>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83105>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83106>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83107>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83108>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83109>>>>>>>>>>            Increment i
83110>>>>>>>>>>
83110>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83111>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83112>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83114>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83115>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83116>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83117>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83118>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83119>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83120>>>>>>>>>>            Increment i
83121>>>>>>>>>>
83121>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83122>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83123>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83125>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83126>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83127>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83128>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83129>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83130>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83131>>>>>>>>>>            Increment i
83132>>>>>>>>>>
83132>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83133>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83134>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83135>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83136>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83137>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83138>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83139>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83140>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83141>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83142>>>>>>>>>>            Increment i
83143>>>>>>>>>>
83143>>>>>>>>>>
83143>>>>>>>>>
83143>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83143>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83143>>>>>>>>>//        Increment i
83143>>>>>>>>>//
83143>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83143>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83143>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83143>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83143>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83143>>>>>>>>>
83143>>>>>>>>>        Function_Return aColumnType
83144>>>>>>>>>    End_Function
83145>>>>>>>>>
83145>>>>>>>>>    // PostgreSQL Data Types
83145>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83147>>>>>>>>>        tColumnType[] aColumnType
83147>>>>>>>>>        tColumnType[] aColumnType
83148>>>>>>>>>        Integer i
83148>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83148>>>>>>>>>>// Generated By The Database Update Framework
83148>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83148>>>>>>>>>>// Driver COLUMN DATA TYPES
83148>>>>>>>>>>//
83148>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83148>>>>>>>>>>
83148>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83149>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83150>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83151>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83152>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83153>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83154>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83155>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83156>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83157>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83158>>>>>>>>>>            Increment i
83159>>>>>>>>>>
83159>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83160>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83161>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83162>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83163>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83164>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83165>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83166>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83167>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83168>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83169>>>>>>>>>>            Increment i
83170>>>>>>>>>>
83170>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83171>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83172>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83173>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83174>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83175>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83176>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83177>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83178>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83179>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83180>>>>>>>>>>            Increment i
83181>>>>>>>>>>
83181>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83182>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83183>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83184>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83185>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83186>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83187>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83188>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83189>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83190>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83191>>>>>>>>>>            Increment i
83192>>>>>>>>>>
83192>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83193>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83194>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83195>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83196>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83197>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83198>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83199>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83200>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83201>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83202>>>>>>>>>>            Increment i
83203>>>>>>>>>>
83203>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83204>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83205>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83206>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83207>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83208>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83209>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83210>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83211>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83212>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83213>>>>>>>>>>            Increment i
83214>>>>>>>>>>
83214>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83215>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83216>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83217>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83218>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83219>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83220>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83221>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83222>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83223>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83224>>>>>>>>>>            Increment i
83225>>>>>>>>>>
83225>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83226>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83227>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83228>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83229>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83230>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83231>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83232>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83233>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83234>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83235>>>>>>>>>>            Increment i
83236>>>>>>>>>>
83236>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83237>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83238>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83239>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83240>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83241>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83242>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83243>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83244>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83245>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83246>>>>>>>>>>            Increment i
83247>>>>>>>>>>
83247>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83248>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83249>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83250>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83251>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83252>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83253>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83254>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83255>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83256>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83257>>>>>>>>>>            Increment i
83258>>>>>>>>>>
83258>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83259>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83260>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83261>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83262>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83263>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83264>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83265>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83266>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83267>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83268>>>>>>>>>>            Increment i
83269>>>>>>>>>>
83269>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83270>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83271>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83272>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83273>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83274>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83275>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83276>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83277>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83278>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83279>>>>>>>>>>            Increment i
83280>>>>>>>>>>
83280>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83281>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83282>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83283>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83284>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83285>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83286>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83287>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83288>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83289>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83290>>>>>>>>>>            Increment i
83291>>>>>>>>>>
83291>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83292>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83293>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83294>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83295>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83296>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83297>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83298>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83299>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83300>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83301>>>>>>>>>>            Increment i
83302>>>>>>>>>>
83302>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83303>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83304>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83305>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83306>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83307>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83308>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83309>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83310>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83311>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83312>>>>>>>>>>            Increment i
83313>>>>>>>>>>
83313>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83314>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83315>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83316>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83317>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83318>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83319>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83320>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83321>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83322>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83323>>>>>>>>>>            Increment i
83324>>>>>>>>>>
83324>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83325>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83326>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83327>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83328>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83329>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83330>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83331>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83332>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83333>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83334>>>>>>>>>>            Increment i
83335>>>>>>>>>>
83335>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83336>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83337>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83338>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83339>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83340>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83341>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83342>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83343>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83344>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83345>>>>>>>>>>            Increment i
83346>>>>>>>>>>
83346>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83347>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83348>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83349>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83350>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83351>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83352>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83353>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83354>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83355>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83356>>>>>>>>>>            Increment i
83357>>>>>>>>>>
83357>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83358>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83359>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83360>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83361>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83362>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83363>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83364>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83365>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83366>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83367>>>>>>>>>>            Increment i
83368>>>>>>>>>>
83368>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83369>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83370>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83371>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83372>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83373>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83374>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83375>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83376>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83377>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83378>>>>>>>>>>            Increment i
83379>>>>>>>>>>
83379>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83380>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83381>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83382>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83383>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83384>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83385>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83386>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83387>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83388>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83389>>>>>>>>>>            Increment i
83390>>>>>>>>>>
83390>>>>>>>>>>
83390>>>>>>>>>
83390>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83390>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83390>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83390>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>//
83390>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83390>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83390>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83390>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83390>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83390>>>>>>>>>//        Increment i
83390>>>>>>>>>
83390>>>>>>>>>        Function_Return aColumnType
83391>>>>>>>>>    End_Function
83392>>>>>>>>>
83392>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83392>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83394>>>>>>>>>        Integer iValue iSize iCount iStart iItem
83394>>>>>>>>>        tColumnType[] ColumnTypeArray
83394>>>>>>>>>        tColumnType[] ColumnTypeArray
83395>>>>>>>>>        tColumnType RetvalType
83395>>>>>>>>>        tColumnType RetvalType
83395>>>>>>>>>        String sValue
83395>>>>>>>>>        Boolean bFrameworkDataFlexType
83395>>>>>>>>>
83395>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83396>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83397>>>>>>>>>
83397>>>>>>>>>        Move 0 to iStart
83398>>>>>>>>>        Move (Uppercase(sType)) to sType
83399>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83400>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83402>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83403>>>>>>>>>            Function_Return RetvalType
83404>>>>>>>>>        End
83404>>>>>>>>>>
83404>>>>>>>>>
83404>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83405>>>>>>>>>        Move iType to RetvalType.iSQLType
83406>>>>>>>>>        Move sType to RetvalType.sSQLType 
83407>>>>>>>>>        Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83408>>>>>>>>>        
83408>>>>>>>>>        If (iItem = -1) Begin
83410>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83411>>>>>>>>>            Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83412>>>>>>>>>        End
83412>>>>>>>>>>
83412>>>>>>>>>        If (iItem <> -1) Begin
83414>>>>>>>>>            Move ColumnTypeArray[iItem].sSQLType       to RetvalType.sSQLType
83415>>>>>>>>>            Move ColumnTypeArray[iItem].iSQLType       to RetvalType.iSQLType
83416>>>>>>>>>            Move ColumnTypeArray[iItem].sDataFlexType  to RetvalType.sDataFlexType
83417>>>>>>>>>            Move ColumnTypeArray[iItem].iDataFlexType  to RetvalType.iDataFlexType
83418>>>>>>>>>            Move ColumnTypeArray[iItem].sPrecision     to RetvalType.sPrecision
83419>>>>>>>>>            Move ColumnTypeArray[iItem].bCanEditSize   to RetvalType.bCanEditSize
83420>>>>>>>>>        End
83420>>>>>>>>>>
83420>>>>>>>>>
83420>>>>>>>>>        Function_Return RetvalType
83421>>>>>>>>>    End_Function
83422>>>>>>>>>
83422>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83422>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83424>>>>>>>>>        tColumnType[] ColumnType
83424>>>>>>>>>        tColumnType[] ColumnType
83425>>>>>>>>>
83425>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83425>>>>>>>>>        // the dbType.
83425>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83427>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83429>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83430>>>>>>>>>            End
83430>>>>>>>>>>
83430>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83432>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83433>>>>>>>>>            End
83433>>>>>>>>>>
83433>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83435>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83436>>>>>>>>>            End
83436>>>>>>>>>>
83436>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83438>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83439>>>>>>>>>            End
83439>>>>>>>>>>
83439>>>>>>>>>        End
83439>>>>>>>>>>
83439>>>>>>>>>
83439>>>>>>>>>        Case Begin
83439>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83441>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83442>>>>>>>>>                Case Break
83443>>>>>>>>>
83443>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83446>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83447>>>>>>>>>                Case Break
83448>>>>>>>>>
83448>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83451>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83452>>>>>>>>>                Case Break
83453>>>>>>>>>        Case End
83453>>>>>>>>>
83453>>>>>>>>>        Function_Return ColumnType
83454>>>>>>>>>    End_Function
83455>>>>>>>>>
83455>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83455>>>>>>>>>    // are mapped to a DUF data type.
83455>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83457>>>>>>>>>        tColumnType ColumnType
83457>>>>>>>>>        tColumnType ColumnType
83457>>>>>>>>>        String sDataType
83457>>>>>>>>>        Integer iDriverID iCount
83457>>>>>>>>>
83457>>>>>>>>>        Move 0 to iCount
83458>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83459>>>>>>>>>
83459>>>>>>>>>        Case Begin
83459>>>>>>>>>            // DF_ASCII
83459>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83461>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83463>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83466>>>>>>>>>                End
83466>>>>>>>>>>
83466>>>>>>>>>                Else Begin
83467>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83470>>>>>>>>>                End
83470>>>>>>>>>>
83470>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83471>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83472>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83473>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83474>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83475>>>>>>>>>                Case Break
83476>>>>>>>>>
83476>>>>>>>>>            // DF_BINARY
83476>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83479>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83481>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83484>>>>>>>>>                End
83484>>>>>>>>>>
83484>>>>>>>>>                Else Begin
83485>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83488>>>>>>>>>                End
83488>>>>>>>>>>
83488>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83489>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83490>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83491>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83492>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83493>>>>>>>>>                Case Break
83494>>>>>>>>>
83494>>>>>>>>>            // DF_DATE
83494>>>>>>>>>            Case (iType = DF_DATE_DUF)
83497>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83499>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83502>>>>>>>>>                End
83502>>>>>>>>>>
83502>>>>>>>>>                Else Begin
83503>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83506>>>>>>>>>                End
83506>>>>>>>>>>
83506>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83507>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83508>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83509>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83510>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83511>>>>>>>>>                Case Break
83512>>>>>>>>>
83512>>>>>>>>>            // DF_DATETIME
83512>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83515>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83517>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83520>>>>>>>>>                End
83520>>>>>>>>>>
83520>>>>>>>>>                Else Begin
83521>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83524>>>>>>>>>                End
83524>>>>>>>>>>
83524>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83525>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83526>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83527>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83528>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83529>>>>>>>>>                Case Break
83530>>>>>>>>>
83530>>>>>>>>>            // DF_NUMERIC
83530>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83530>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83530>>>>>>>>>            // we make them here all "Numeric"...
83530>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83530>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83530>>>>>>>>>            // End
83530>>>>>>>>>            // Else Begin
83530>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83530>>>>>>>>>            // End
83530>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83530>>>>>>>>>            Case (iType = DF_BCD_DUF)
83533>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83534>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83535>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83536>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83537>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83538>>>>>>>>>                Case Break
83539>>>>>>>>>
83539>>>>>>>>>            // DF_TEXT
83539>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83542>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83544>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83547>>>>>>>>>                End
83547>>>>>>>>>>
83547>>>>>>>>>                Else Begin
83548>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83551>>>>>>>>>                End
83551>>>>>>>>>>
83551>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83552>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83553>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83554>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83555>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83556>>>>>>>>>                Case Break
83557>>>>>>>>>
83557>>>>>>>>>            Case Else
83557>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83558>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83559>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83560>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83561>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83562>>>>>>>>>
83562>>>>>>>>>        Case End
83562>>>>>>>>>
83562>>>>>>>>>        Function_Return ColumnType
83563>>>>>>>>>    End_Function
83564>>>>>>>>>
83564>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83566>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83568>>>>>>>>>        Handle hTable
83568>>>>>>>>>        Integer iIndex
83568>>>>>>>>>        String sTableName
83568>>>>>>>>>        Boolean bFlexErrs
83568>>>>>>>>>
83568>>>>>>>>>        // a) Get the exception table array the developer has specified
83568>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83569>>>>>>>>>
83569>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83569>>>>>>>>>        Repeat
83569>>>>>>>>>>
83569>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83572>>>>>>>>>            If (hTable <> 0) Begin
83574>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83577>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83578>>>>>>>>>                If (bFlexErrs = False) Begin
83580>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83582>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83583>>>>>>>>>                        If (iIndex = -1) Begin
83585>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83586>>>>>>>>>                        End
83586>>>>>>>>>>
83586>>>>>>>>>                    End
83586>>>>>>>>>>
83586>>>>>>>>>                End
83586>>>>>>>>>>
83586>>>>>>>>>            End
83586>>>>>>>>>>
83586>>>>>>>>>        Until (hTable = 0)
83588>>>>>>>>>
83588>>>>>>>>>        Move 0 to hTable
83589>>>>>>>>>
83589>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83589>>>>>>>>>        Repeat
83589>>>>>>>>>>
83589>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83592>>>>>>>>>            If (hTable > 0) Begin
83594>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83597>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83598>>>>>>>>>                If (bFlexErrs = False) Begin
83600>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83601>>>>>>>>>                    If (iIndex = -1) Begin
83603>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83604>>>>>>>>>                    End
83604>>>>>>>>>>
83604>>>>>>>>>                End
83604>>>>>>>>>>
83604>>>>>>>>>            End
83604>>>>>>>>>>
83604>>>>>>>>>        Until (hTable = 0)
83606>>>>>>>>>
83606>>>>>>>>>        Function_Return iTablesArray
83607>>>>>>>>>    End_Function
83608>>>>>>>>>
83608>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83610>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83612>>>>>>>>>        Handle hTable
83612>>>>>>>>>        Integer iIndex
83612>>>>>>>>>        String sTableName
83612>>>>>>>>>        Boolean bFlexErrs
83612>>>>>>>>>
83612>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83613>>>>>>>>>        Move 0 to hTable
83614>>>>>>>>>
83614>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83614>>>>>>>>>        Repeat
83614>>>>>>>>>>
83614>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83617>>>>>>>>>            If (hTable > 0) Begin
83619>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83622>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83623>>>>>>>>>                If (bFlexErrs = False) Begin
83625>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83626>>>>>>>>>                    If (iIndex = -1) Begin
83628>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83629>>>>>>>>>                    End
83629>>>>>>>>>>
83629>>>>>>>>>                End
83629>>>>>>>>>>
83629>>>>>>>>>            End
83629>>>>>>>>>>
83629>>>>>>>>>        Until (hTable = 0)
83631>>>>>>>>>
83631>>>>>>>>>        Function_Return iTablesArray
83632>>>>>>>>>    End_Function
83633>>>>>>>>>
83633>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83635>>>>>>>>>        tAPIColumn NewAPIColumn
83635>>>>>>>>>        tAPIColumn NewAPIColumn
83635>>>>>>>>>
83635>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83636>>>>>>>>>        Move iType      to NewAPIColumn.iType
83637>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83638>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83639>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83640>>>>>>>>>
83640>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83641>>>>>>>>>
83641>>>>>>>>>        Function_Return aCurrent
83642>>>>>>>>>    End_Function
83643>>>>>>>>>
83643>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83645>>>>>>>>>        String sRetval sFieldName
83645>>>>>>>>>        Integer iCount iSize
83645>>>>>>>>>
83645>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83646>>>>>>>>>        Decrement iSize
83647>>>>>>>>>        For iCount from 0 to iSize
83653>>>>>>>>>>
83653>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83654>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83655>>>>>>>>>        Loop
83656>>>>>>>>>>
83656>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83657>>>>>>>>>
83657>>>>>>>>>        Function_Return sRetval
83658>>>>>>>>>    End_Function
83659>>>>>>>>>
83659>>>>>>>>>    // *** Miscellaneous other functions ***
83659>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83659>>>>>>>>>    //
83659>>>>>>>>>
83659>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83659>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83661>>>>>>>>>        Integer iPerc
83661>>>>>>>>>        Number nReady nTotal
83661>>>>>>>>>
83661>>>>>>>>>        Send DoAdvance of ghoProgressBar
83662>>>>>>>>>
83662>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83664>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83665>>>>>>>>>        End
83665>>>>>>>>>>
83665>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83667>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83668>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83669>>>>>>>>>        End
83669>>>>>>>>>>
83669>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83671>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83672>>>>>>>>>        End
83672>>>>>>>>>>
83672>>>>>>>>>
83672>>>>>>>>>        Case Begin
83672>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83674>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83675>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83676>>>>>>>>>                Case Break
83677>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83680>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83681>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83682>>>>>>>>>                Case Break
83683>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83686>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83687>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83688>>>>>>>>>                Case Break
83689>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83692>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83693>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83694>>>>>>>>>                Case Break
83695>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83698>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83699>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83700>>>>>>>>>                Case Break
83701>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83704>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83705>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83706>>>>>>>>>                Case Break
83707>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83710>>>>>>>>>                Send None
83711>>>>>>>>>                Case Break
83712>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83715>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83716>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83717>>>>>>>>>                Case Break
83718>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83721>>>>>>>>>                //*** Interpret numbers
83721>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83722>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83723>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83724>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83725>>>>>>>>>                Case Break
83726>>>>>>>>>            Case Else
83726>>>>>>>>>                Set Message_Text to ""
83727>>>>>>>>>                Set Action_Text  to ""
83728>>>>>>>>>        Case End
83728>>>>>>>>>
83728>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83729>>>>>>>>>        Function_Return False
83730>>>>>>>>>    End_Function
83731>>>>>>>>>
83731>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83731>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83733>>>>>>>>>        Function_Return False
83734>>>>>>>>>    End_Function
83735>>>>>>>>>
83735>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83735>>>>>>>>>    //
83735>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83735>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83735>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83735>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83735>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83735>>>>>>>>>    //   ALTER TABLE MyTable
83735>>>>>>>>>    //       REBUILD
83735>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83737>>>>>>>>>        Boolean bOK
83737>>>>>>>>>
83737>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83739>>>>>>>>>            Function_Return False
83740>>>>>>>>>        End
83740>>>>>>>>>>
83740>>>>>>>>>
83740>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83740>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83741>>>>>>>>>
83741>>>>>>>>>        Function_Return (bOK = True)
83742>>>>>>>>>    End_Function
83743>>>>>>>>>
83743>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83743>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83743>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83743>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83743>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83743>>>>>>>>>    //   ALTER TABLE MyTable
83743>>>>>>>>>    //       REBUILD
83743>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83745>>>>>>>>>        tSQLScriptArray SQLScriptArray
83745>>>>>>>>>        tSQLScriptArray SQLScriptArray
83745>>>>>>>>>        String sDriverID
83745>>>>>>>>>        Boolean bOK
83745>>>>>>>>>        Integer iSize iCount
83745>>>>>>>>>
83745>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83747>>>>>>>>>            Function_Return False
83748>>>>>>>>>        End
83748>>>>>>>>>>
83748>>>>>>>>>
83748>>>>>>>>>        Get psDriverID to sDriverID
83749>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83750>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83752>>>>>>>>>            Function_Return False
83753>>>>>>>>>        End
83753>>>>>>>>>>
83753>>>>>>>>>
83753>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83754>>>>>>>>>        Decrement iSize
83755>>>>>>>>>
83755>>>>>>>>>        For iCount from 0 to iSize
83761>>>>>>>>>>
83761>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83763>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83764>>>>>>>>>            End
83764>>>>>>>>>>
83764>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83766>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83767>>>>>>>>>            End
83767>>>>>>>>>>
83767>>>>>>>>>        Loop
83768>>>>>>>>>>
83768>>>>>>>>>
83768>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83769>>>>>>>>>
83769>>>>>>>>>        Function_Return (bOK = True)
83770>>>>>>>>>    End_Function
83771>>>>>>>>>
83771>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83771>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83771>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83771>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83773>>>>>>>>>        Integer iChannel iArgumentSize iCount
83773>>>>>>>>>        Number nByteCount
83773>>>>>>>>>        String sSQLScript
83773>>>>>>>>>        tSQLScriptArray SqlScriptArray
83773>>>>>>>>>        tSQLScriptArray SqlScriptArray
83773>>>>>>>>>        UChar[] uCharData
83774>>>>>>>>>
83774>>>>>>>>>        Move False to Err
83775>>>>>>>>>        Get Seq_New_Channel to iChannel
83776>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83778>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83779>>>>>>>>>>
83779>>>>>>>>>            Move True to SqlScriptArray.bError
83780>>>>>>>>>            Function_Return SqlScriptArray
83781>>>>>>>>>        End
83781>>>>>>>>>>
83781>>>>>>>>>
83781>>>>>>>>>        // First decide the size of the script
83781>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83783>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83785>>>>>>>>>        Close_Input channel iChannel
83787>>>>>>>>>
83787>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83788>>>>>>>>>        If (nByteCount  < 1) Begin
83790>>>>>>>>>            Send Seq_Release_Channel iChannel
83791>>>>>>>>>            Move True to SqlScriptArray.bError
83792>>>>>>>>>            Function_Return SqlScriptArray
83793>>>>>>>>>        End
83793>>>>>>>>>>
83793>>>>>>>>>
83793>>>>>>>>>        // If necessary change the string argument_size
83793>>>>>>>>>        // Read the script file from memory line-by-line
83793>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83795>>>>>>>>>            Move 0 to iCount
83796>>>>>>>>>            Repeat
83796>>>>>>>>>>
83796>>>>>>>>>                Readln channel iChannel sSQLScript
83798>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83799>>>>>>>>>                Increment iCount
83800>>>>>>>>>            Until (SeqEof = True)
83802>>>>>>>>>        Close_Input channel iChannel
83804>>>>>>>>>        Send Seq_Release_Channel iChannel
83805>>>>>>>>>
83805>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83805>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83806>>>>>>>>>
83806>>>>>>>>>        Function_Return SqlScriptArray
83807>>>>>>>>>    End_Function
83808>>>>>>>>>
83808>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83810>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83810>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83810>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83810>>>>>>>>>        String[] sMsg aSQLQueryMessages
83812>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83812>>>>>>>>>        TimeSpan tsQuery
83812>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83812>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83812>>>>>>>>>        tSQLConnection SQLConnection
83812>>>>>>>>>        tSQLConnection SQLConnection
83812>>>>>>>>>        Boolean bShowProgress
83812>>>>>>>>>
83812>>>>>>>>>        If (num_arguments > 4) Begin
83814>>>>>>>>>            Move bShowProgr to bShowProgress
83815>>>>>>>>>        End
83815>>>>>>>>>>
83815>>>>>>>>>        Get phoSQLManager to hoSql
83816>>>>>>>>>
83816>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83817>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83817>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83817>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83817>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83817>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83817>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83817>>>>>>>>>        Get piChunkMax to iChunkMax
83818>>>>>>>>>        Move 0 to iChunkCounter
83819>>>>>>>>>        Move "" to sStmt
83820>>>>>>>>>
83820>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83821>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83822>>>>>>>>>
83822>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83823>>>>>>>>>
83823>>>>>>>>>        Get phoSQLManager  to hoSQL
83824>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83826>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83828>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83829>>>>>>>>>                If (iPos > 0) Begin
83831>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83832>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83833>>>>>>>>>                End
83833>>>>>>>>>>
83833>>>>>>>>>            End
83833>>>>>>>>>>
83833>>>>>>>>>        End
83833>>>>>>>>>>
83833>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83834>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83835>>>>>>>>>
83835>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83837>>>>>>>>>            Move False to Err
83838>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83839>>>>>>>>>            If (hoStmt <> 0) Begin
83841>>>>>>>>>
83841>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83841>>>>>>>>>                If (bCreateScriptFile = True) Begin
83843>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83844>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83845>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83846>>>>>>>>>                    Get Seq_New_Channel to iOut
83847>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83849>>>>>>>>>                        Direct_Output channel iOut sExportFile
83851>>>>>>>>>                    End
83851>>>>>>>>>>
83851>>>>>>>>>                End
83851>>>>>>>>>>
83851>>>>>>>>>
83851>>>>>>>>>                // Record starting date/time stamp
83851>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83852>>>>>>>>>                // Turn on error handling if enabled
83852>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83854>>>>>>>>>                    Set pbSqlError to False
83855>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83856>>>>>>>>>                    Move Error_Object_Id to hoError
83857>>>>>>>>>                    Move Self to Error_Object_Id
83858>>>>>>>>>                End
83858>>>>>>>>>>
83858>>>>>>>>>
83858>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83859>>>>>>>>>                Decrement iRows
83860>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83862>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83863>>>>>>>>>                End
83863>>>>>>>>>>
83863>>>>>>>>>
83863>>>>>>>>>                for iCount from 0 to iRows
83869>>>>>>>>>>
83869>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83870>>>>>>>>>
83870>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83872>>>>>>>>>                        If (sSQLVal <> "") Begin
83874>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83875>>>>>>>>>                        End
83875>>>>>>>>>>
83875>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83876>>>>>>>>>                    End
83876>>>>>>>>>>
83876>>>>>>>>>
83876>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83876>>>>>>>>>                    // or if at the very end of the script.
83876>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83878>>>>>>>>>
83878>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83878>>>>>>>>>                        // instead of all in one go.
83878>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83879>>>>>>>>>
83879>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83881>>>>>>>>>                            Write channel iOut sStmt
83883>>>>>>>>>                        End
83883>>>>>>>>>>
83883>>>>>>>>>                        Move "" to sStmt
83884>>>>>>>>>                        Move 0 to iChunkCounter
83885>>>>>>>>>                    End
83885>>>>>>>>>>
83885>>>>>>>>>                    Increment iChunkCounter
83886>>>>>>>>>                Loop
83887>>>>>>>>>>
83887>>>>>>>>>
83887>>>>>>>>>                Repeat
83887>>>>>>>>>>
83887>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83889>>>>>>>>>                        Move hoError to Error_Object_Id
83890>>>>>>>>>                    End
83890>>>>>>>>>>
83890>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83891>>>>>>>>>
83891>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83892>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83893>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83894>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83895>>>>>>>>>                    Set piRows    to iRows
83896>>>>>>>>>                    Set piRowType to iRowType
83897>>>>>>>>>
83897>>>>>>>>>                    If (iMsgs <> 0) Begin
83899>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83901>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83902>>>>>>>>>                        End
83902>>>>>>>>>>
83902>>>>>>>>>                        for i from 1 to iMsgs
83908>>>>>>>>>>
83908>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83909>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83910>>>>>>>>>                            If (bShowProgress = True) Begin
83912>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83914>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83915>>>>>>>>>                                End
83915>>>>>>>>>>
83915>>>>>>>>>                                Else Begin
83916>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83918>>>>>>>>>                                End
83918>>>>>>>>>>
83918>>>>>>>>>                            End
83918>>>>>>>>>>
83918>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83919>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83920>>>>>>>>>                        Loop
83921>>>>>>>>>>
83921>>>>>>>>>
83921>>>>>>>>>
83921>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83923>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83924>>>>>>>>>                        End
83924>>>>>>>>>>
83924>>>>>>>>>                        Set paQueryMessages to sMsg
83925>>>>>>>>>                    End
83925>>>>>>>>>>
83925>>>>>>>>>
83925>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83926>>>>>>>>>                Until (iNextSet = 0)
83928>>>>>>>>>
83928>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83929>>>>>>>>>            End
83929>>>>>>>>>>
83929>>>>>>>>>
83929>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83930>>>>>>>>>            Set ptsQueryExec to tsQuery
83931>>>>>>>>>            Send SqlClose of hoStmt
83932>>>>>>>>>
83932>>>>>>>>>            If (bCreateScriptFile = True) Begin
83934>>>>>>>>>                Close_Output channel iOut
83936>>>>>>>>>                Send Seq_Release_Channel iOut
83937>>>>>>>>>            End
83937>>>>>>>>>>
83937>>>>>>>>>        End
83937>>>>>>>>>>
83937>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83938>>>>>>>>>
83938>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83939>>>>>>>>>    End_Function
83940>>>>>>>>>
83940>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83942>>>>>>>>>        tSQLScriptArray SQLScriptArray
83942>>>>>>>>>        tSQLScriptArray SQLScriptArray
83942>>>>>>>>>        String sDriverID sCollation
83942>>>>>>>>>        Boolean bOK
83942>>>>>>>>>        Integer iSize iCount
83942>>>>>>>>>
83942>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83944>>>>>>>>>            Function_Return False
83945>>>>>>>>>        End
83945>>>>>>>>>>
83945>>>>>>>>>
83945>>>>>>>>>        Get psDriverID  to sDriverID
83946>>>>>>>>>        Get psCollation to sCollation
83947>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83948>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83950>>>>>>>>>            Function_Return False
83951>>>>>>>>>        End
83951>>>>>>>>>>
83951>>>>>>>>>
83951>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83952>>>>>>>>>        Decrement iSize
83953>>>>>>>>>
83953>>>>>>>>>        For iCount from 0 to iSize
83959>>>>>>>>>>
83959>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83961>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83962>>>>>>>>>            End
83962>>>>>>>>>>
83962>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83964>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83965>>>>>>>>>            End
83965>>>>>>>>>>
83965>>>>>>>>>        Loop
83966>>>>>>>>>>
83966>>>>>>>>>
83966>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83967>>>>>>>>>
83967>>>>>>>>>        Function_Return (bOK = True)
83968>>>>>>>>>    End_Function
83969>>>>>>>>>
83969>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83971>>>>>>>>>        tSQLScriptArray SQLScriptArray
83971>>>>>>>>>        tSQLScriptArray SQLScriptArray
83971>>>>>>>>>        String sDriverID sCollation
83971>>>>>>>>>        Boolean bOK
83971>>>>>>>>>        Integer iSize iCount
83971>>>>>>>>>
83971>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83973>>>>>>>>>            Function_Return False
83974>>>>>>>>>        End
83974>>>>>>>>>>
83974>>>>>>>>>
83974>>>>>>>>>        Get psDriverID  to sDriverID
83975>>>>>>>>>        Get psCollation to sCollation
83976>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83977>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83979>>>>>>>>>            Function_Return False
83980>>>>>>>>>        End
83980>>>>>>>>>>
83980>>>>>>>>>
83980>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83981>>>>>>>>>        Decrement iSize
83982>>>>>>>>>
83982>>>>>>>>>        For iCount from 0 to iSize
83988>>>>>>>>>>
83988>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83990>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83991>>>>>>>>>            End
83991>>>>>>>>>>
83991>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83993>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83994>>>>>>>>>            End
83994>>>>>>>>>>
83994>>>>>>>>>        Loop
83995>>>>>>>>>>
83995>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83995>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83996>>>>>>>>>
83996>>>>>>>>>        Function_Return (bOK = True)
83997>>>>>>>>>    End_Function
83998>>>>>>>>>
83998>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84000>>>>>>>>>        Integer iMax iPos
84000>>>>>>>>>        String sName
84000>>>>>>>>>
84000>>>>>>>>>        Move (Lowercase(sField)) to sField
84001>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84004>>>>>>>>>        For iPos from 0 to iMax
84010>>>>>>>>>>
84010>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84013>>>>>>>>>            Move (Lowercase(sName)) to sName
84014>>>>>>>>>            If (sName = sField) Begin
84016>>>>>>>>>                Function_Return iPos
84017>>>>>>>>>            End
84017>>>>>>>>>>
84017>>>>>>>>>        Loop
84018>>>>>>>>>>
84018>>>>>>>>>        Function_Return -1
84019>>>>>>>>>    End_Function
84020>>>>>>>>>
84020>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84020>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84020>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84020>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84020>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84022>>>>>>>>>        String sID sConnString
84022>>>>>>>>>        Integer iDriver iNumConn iCount
84022>>>>>>>>>        Handle hoCLI
84022>>>>>>>>>        Boolean bOK
84022>>>>>>>>>
84022>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84023>>>>>>>>>        If (bOK = False) Begin
84025>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84026>>>>>>>>>>
84026>>>>>>>>>            Function_Return False
84027>>>>>>>>>        End
84027>>>>>>>>>>
84027>>>>>>>>>
84027>>>>>>>>>        Move False to bOK
84028>>>>>>>>>        Get phoCLIHandler to hoCLI
84029>>>>>>>>>        If (hoCLI <> 0) Begin
84031>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84032>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84033>>>>>>>>>
84033>>>>>>>>>            // If driver not loaded; load it.
84033>>>>>>>>>            If (iDriver = 0) Begin
84035>>>>>>>>>                Load_Driver sDriverID
84036>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84037>>>>>>>>>            End
84037>>>>>>>>>>
84037>>>>>>>>>            If (iDriver <> 0) Begin
84039>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84042>>>>>>>>>                Decrement iNumConn
84043>>>>>>>>>                For iCount from 0 to iNumConn
84049>>>>>>>>>>
84049>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84052>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84055>>>>>>>>>                    If (sID = sConnectionID) Begin
84057>>>>>>>>>                        Move True to bOK
84058>>>>>>>>>                    End
84058>>>>>>>>>>
84058>>>>>>>>>                Loop
84059>>>>>>>>>>
84059>>>>>>>>>            End
84059>>>>>>>>>>
84059>>>>>>>>>        End
84059>>>>>>>>>>
84059>>>>>>>>>
84059>>>>>>>>>        Function_Return bOK
84060>>>>>>>>>    End_Function
84061>>>>>>>>>
84061>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84063>>>>>>>>>        Boolean bOK
84063>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84064>>>>>>>>>        Function_Return bOK
84065>>>>>>>>>    End_Function
84066>>>>>>>>>
84066>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84068>>>>>>>>>        Integer iDriverIndex
84068>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84069>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84070>>>>>>>>>    End_Function
84071>>>>>>>>>
84071>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84071>>>>>>>>>    // attempt to load the driver.
84071>>>>>>>>>    // Returns true if the passed driver is SQL based.
84071>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84073>>>>>>>>>        Boolean bOK
84073>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84074>>>>>>>>>        Function_Return bOK
84075>>>>>>>>>    End_Function
84076>>>>>>>>>
84076>>>>>>>>>    // *** Error Handler ***
84076>>>>>>>>>    //
84076>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84076>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84076>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84078>>>>>>>>>        Integer iSize iErrorMode
84078>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84078>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84078>>>>>>>>>
84078>>>>>>>>>        If (pbProcessingError(Self)) Begin
84080>>>>>>>>>            Procedure_Return
84081>>>>>>>>>        End
84081>>>>>>>>>>
84081>>>>>>>>>
84081>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84082>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84084>>>>>>>>>            Set Private.pbProcessingError to False
84085>>>>>>>>>            Procedure_Return
84086>>>>>>>>>        End
84086>>>>>>>>>>
84086>>>>>>>>>
84086>>>>>>>>>        Set pbProcessingError to True
84087>>>>>>>>>        Set pbSqlError to True
84088>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84089>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84090>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84091>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84092>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84093>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84094>>>>>>>>>        Set pbProcessingError to False
84095>>>>>>>>>    End_Procedure
84096>>>>>>>>>
84096>>>>>>>>>    // *** Miscellanous Helper Functions ***
84096>>>>>>>>>    //
84096>>>>>>>>>    // Helper function. Takes a DF_FILE_ROOT_NAME value as parameter and
84096>>>>>>>>>    // returns the table name only; stripped of any prefix, path or filename extension.
84096>>>>>>>>>    Function _TableNameOnly String sTableName Returns String
84098>>>>>>>>>        Integer iPos
84098>>>>>>>>>        Move (Pos(":", sTableName)) to iPos
84099>>>>>>>>>        If (iPos <> 0) Begin
84101>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
84102>>>>>>>>>        End  
84102>>>>>>>>>>
84102>>>>>>>>>        Move (Pos(".int", Lowercase(sTableName))) to iPos
84103>>>>>>>>>        If (iPos <> 0) Begin
84105>>>>>>>>>            Move (Left(sTableName, (iPos -1))) to sTableName
84106>>>>>>>>>        End  
84106>>>>>>>>>>
84106>>>>>>>>>        Function_Return sTableName
84107>>>>>>>>>    End_Function
84108>>>>>>>>>
84108>>>>>>>>>    // Removes any prefix from a table name.
84108>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84108>>>>>>>>>    //         dbo.mytable returns mytable
84108>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84110>>>>>>>>>        Integer iPos
84110>>>>>>>>>        Move (Pos(":", sName)) to iPos
84111>>>>>>>>>        If (iPos <> 0) Begin
84113>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84114>>>>>>>>>        End
84114>>>>>>>>>>
84114>>>>>>>>>        Move (Pos(".", sName)) to iPos
84115>>>>>>>>>        If (iPos <> 0) Begin
84117>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84118>>>>>>>>>        End
84118>>>>>>>>>>
84118>>>>>>>>>        Function_Return sName
84119>>>>>>>>>    End_Function
84120>>>>>>>>>    
84120>>>>>>>>>    Function _DriverIDFromRootName String sRootName Returns String
84122>>>>>>>>>        String sDriverID
84122>>>>>>>>>        Integer iPos
84122>>>>>>>>>        Move DATAFLEX_ID to sDriverID
84123>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
84124>>>>>>>>>        If (iPos <> 0) Begin
84126>>>>>>>>>            Move (Left(sRootName, (iPos -1))) to sDriverID
84127>>>>>>>>>        End
84127>>>>>>>>>>
84127>>>>>>>>>        Function_Return sDriverID
84128>>>>>>>>>    End_Function
84129>>>>>>>>>    // Does the Rootname points to a .dat file?
84129>>>>>>>>>    Function _IsDatEntry Handle hTable Returns Boolean
84131>>>>>>>>>        Boolean bFound bIsIntEntry
84131>>>>>>>>>        String sRootName sNoDriverRootname sDriver
84131>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84134>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84135>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84136>>>>>>>>>        Get _IsIntEntry hTable to bIsIntEntry
84137>>>>>>>>>        Move (bIsIntEntry = False and sDriver = DATAFLEX_ID) to bFound
84138>>>>>>>>>        Function_Return bFound
84139>>>>>>>>>    End_Function
84140>>>>>>>>>
84140>>>>>>>>>    // Checks that the RootName points to a .dat file and that the .dat file exists on disk.
84140>>>>>>>>>    Function _DatFileExists Handle hTable Returns Boolean
84142>>>>>>>>>        Boolean bExists
84142>>>>>>>>>        String sDataPath sRootName sNoDriverRootname
84142>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84145>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84146>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84147>>>>>>>>>        File_Exist (sDataPath + "\" + sNoDriverRootname + ".dat") bExists
84148>>>>>>>>>        Function_Return bExists
84149>>>>>>>>>    End_Function
84150>>>>>>>>>    
84150>>>>>>>>>    // Does the Rootname contain a ".int" suffix.
84150>>>>>>>>>    Function _IsIntEntry Handle hTable Returns Boolean
84152>>>>>>>>>        Boolean bFound
84152>>>>>>>>>        String sRootName
84152>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84155>>>>>>>>>        Move (Lowercase(sRootName) contains ".int") to bFound
84156>>>>>>>>>        Function_Return bFound
84157>>>>>>>>>    End_Function
84158>>>>>>>>>
84158>>>>>>>>>    // Checks to see if the .int file actually exists in the Data folder.
84158>>>>>>>>>    Function _IntFileExists Handle hTable Returns Boolean
84160>>>>>>>>>        Boolean bExists bIsIntFile
84160>>>>>>>>>        String sDataPath sIntFileName
84160>>>>>>>>>        Integer iPos
84160>>>>>>>>>        
84160>>>>>>>>>        Move False to bExists
84161>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84162>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName
84165>>>>>>>>>        Get _TableNameOnly sIntFileName to sIntFileName
84166>>>>>>>>>        Move (Pos(".int", Lowercase(sIntFileName))) to iPos
84167>>>>>>>>>        If (iPos = 0) Begin
84169>>>>>>>>>            Move (sIntFileName + ".int") to sIntFileName
84170>>>>>>>>>        End
84170>>>>>>>>>>
84170>>>>>>>>>        File_Exist (sDataPath + "\" + sIntFileName) bExists
84171>>>>>>>>>        Function_Return bExists    
84172>>>>>>>>>    End_Function
84173>>>>>>>>>        
84173>>>>>>>>>    // Returns True if the hTable's RootName has a driver <> DataFlex
84173>>>>>>>>>    Function _IsSQLEntry Handle hTable Returns Boolean
84175>>>>>>>>>        Boolean bFound bIsIntFile
84175>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname sDriver
84175>>>>>>>>>        
84175>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84178>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84179>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84180>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84181>>>>>>>>>        Move (bIsIntFile = True or sDriver <> DATAFLEX_ID) to bFound
84182>>>>>>>>>        Function_Return bFound
84183>>>>>>>>>    End_Function
84184>>>>>>>>>
84184>>>>>>>>>    // This is used in place of the DF_FILE_OPENED table attribute, because
84184>>>>>>>>>    // the table then needs to be open, which takes time.
84184>>>>>>>>>    Function _IsAliasTable Handle hTable Returns Boolean
84186>>>>>>>>>        Boolean bFound bIsIntTable
84186>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname
84186>>>>>>>>>        
84186>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84189>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84192>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84193>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
84194>>>>>>>>>        // Do we have an Alias table?
84194>>>>>>>>>        Move (Lowercase(sLogicalName) <> Lowercase(sNoDriverRootname)) to bFound
84195>>>>>>>>>        Function_Return bFound
84196>>>>>>>>>    End_Function
84197>>>>>>>>>
84197>>>>>>>>>    // If the SQL table cannot be opened, we do this checking a bit different.
84197>>>>>>>>>    Function _IsSystemFile Handle hTable Returns Boolean
84199>>>>>>>>>        Boolean bIsSystem bIsSQL bExists
84199>>>>>>>>>        String sRootName sDataPath sDriver
84199>>>>>>>>>        String[] asIndexes
84200>>>>>>>>>        Move False to bIsSystem
84201>>>>>>>>>        
84201>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84204>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84205>>>>>>>>>        Get _TableNameOnly sRootName to sRootName
84206>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84207>>>>>>>>>        Get _IsSQLEntry hTable to bIsSQL
84208>>>>>>>>>        If (bIsSQL = False) Begin
84210>>>>>>>>>            File_Exist (sDataPath + "\" + sRootName + ".dat") bExists
84211>>>>>>>>>            If (bExists = True) Begin
84213>>>>>>>>>                Open (sDataPath + "\" + sRootName + ".dat") as hTable
84215>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem 
84218>>>>>>>>>                Close hTable
84219>>>>>>>>>            End
84219>>>>>>>>>>
84219>>>>>>>>>        End 
84219>>>>>>>>>>
84219>>>>>>>>>        Else Begin
84220>>>>>>>>>            Get _SqlUtilEnumerateIndexes sRootName sDriver to asIndexes
84221>>>>>>>>>            Move (SizeOfArray(asIndexes) = 0) to bIsSystem
84222>>>>>>>>>        End
84222>>>>>>>>>>
84222>>>>>>>>>        Function_Return bIsSystem
84223>>>>>>>>>    End_Function
84224>>>>>>>>>                          
84224>>>>>>>>>    // Removes any driver prefix and any .int suffix from the Rootname
84224>>>>>>>>>    // If any driver found, it will be placed in the ByRef param: sDriver.
84224>>>>>>>>>    Function _RemoveDriverFromRootName String sRootname String ByRef sDriver Returns String
84226>>>>>>>>>        String sNoDriverRootname
84226>>>>>>>>>        Integer iPos
84226>>>>>>>>>        
84226>>>>>>>>>        Move sRootname to sNoDriverRootname
84227>>>>>>>>>        Move (Pos(":", sRootname)) to iPos
84228>>>>>>>>>        If (iPos <> 0) Begin
84230>>>>>>>>>            Move (Left(sRootname, iPos -1)) to sDriver
84231>>>>>>>>>            Move (Mid(sRootname, Length(sRootname), iPos +1)) to sNoDriverRootname    
84232>>>>>>>>>        End
84232>>>>>>>>>>
84232>>>>>>>>>        Else Begin
84233>>>>>>>>>            Move DATAFLEX_ID to sDriver
84234>>>>>>>>>        End
84234>>>>>>>>>>
84234>>>>>>>>>        Move (Pos(".int", Lowercase(sNoDriverRootname))) to iPos
84235>>>>>>>>>        If (iPos <> 0) Begin
84237>>>>>>>>>            Move (Left(sNoDriverRootname, iPos -1)) to sNoDriverRootname
84238>>>>>>>>>        End
84238>>>>>>>>>>
84238>>>>>>>>>        Function_Return sNoDriverRootname    
84239>>>>>>>>>    End_Function
84240>>>>>>>>>
84240>>>>>>>>>    Function _CountFilelistSystemTables Returns Integer
84242>>>>>>>>>        tFilelist[] FileListTables
84242>>>>>>>>>        tFilelist[] FileListTables
84243>>>>>>>>>        Integer iCount iSize iItems
84243>>>>>>>>>        
84243>>>>>>>>>        Move 0 to iItems
84244>>>>>>>>>        Get pFileListArray to FileListTables
84245>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84246>>>>>>>>>        If (iSize <> 0) Begin
84248>>>>>>>>>            Decrement iSize
84249>>>>>>>>>            for iCount from 0 to iSize
84255>>>>>>>>>>
84255>>>>>>>>>                If (FileListTables[iCount].bIsSystemFile = True) Begin
84257>>>>>>>>>                    Increment iItems
84258>>>>>>>>>                End
84258>>>>>>>>>>
84258>>>>>>>>>            Loop
84259>>>>>>>>>>
84259>>>>>>>>>        End
84259>>>>>>>>>>
84259>>>>>>>>>        Function_Return iItems    
84260>>>>>>>>>    End_Function
84261>>>>>>>>>
84261>>>>>>>>>    Function _CountFileListAliasTables Returns Integer
84263>>>>>>>>>        tFilelist[] FileListTables
84263>>>>>>>>>        tFilelist[] FileListTables
84264>>>>>>>>>        Integer iCount iSize iItems
84264>>>>>>>>>        
84264>>>>>>>>>        Move 0 to iItems
84265>>>>>>>>>        Get pFileListArray to FileListTables
84266>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84267>>>>>>>>>        If (iSize <> 0) Begin
84269>>>>>>>>>            Decrement iSize
84270>>>>>>>>>            for iCount from 0 to iSize
84276>>>>>>>>>>
84276>>>>>>>>>                If (FileListTables[iCount].bIsAlias = True) Begin
84278>>>>>>>>>                    Increment iItems
84279>>>>>>>>>                End
84279>>>>>>>>>>
84279>>>>>>>>>            Loop
84280>>>>>>>>>>
84280>>>>>>>>>        End
84280>>>>>>>>>>
84280>>>>>>>>>        Function_Return iItems    
84281>>>>>>>>>    End_Function
84282>>>>>>>>>
84282>>>>>>>>>    Function _CountFileListMasterTables Returns Integer
84284>>>>>>>>>        String sRootName sLogicalName sDriver sNoDriverRootname
84284>>>>>>>>>        Handle hTable
84284>>>>>>>>>        Integer iSize iItems
84284>>>>>>>>>        Boolean bIsAlias bIsIntTable
84284>>>>>>>>>        
84284>>>>>>>>>        Move 0 to iItems
84285>>>>>>>>>        Move 0 to hTable 
84286>>>>>>>>>        Repeat
84286>>>>>>>>>>
84286>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84289>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84291>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84292>>>>>>>>>                If (bIsAlias = False) Begin
84294>>>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84297>>>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName                    
84300>>>>>>>>>                    Get _RemoveDriverFromRootName sRootName (&sDriver) to sNoDriverRootname
84301>>>>>>>>>                    Get _IsIntEntry hTable to bIsIntTable
84302>>>>>>>>>                    If (sDriver <> DATAFLEX_ID and Lowercase(sNoDriverRootname) = Lowercase(sLogicalName)) Begin
84304>>>>>>>>>                        Increment iItems
84305>>>>>>>>>                    End
84305>>>>>>>>>>
84305>>>>>>>>>                End
84305>>>>>>>>>>
84305>>>>>>>>>            End
84305>>>>>>>>>>
84305>>>>>>>>>        Until (hTable = 0)
84307>>>>>>>>>        
84307>>>>>>>>>        Function_Return iItems
84308>>>>>>>>>    End_Function
84309>>>>>>>>>
84309>>>>>>>>>    Function _CountFileListOpenErrors Returns Integer
84311>>>>>>>>>        tFilelist[] FileListTables
84311>>>>>>>>>        tFilelist[] FileListTables
84312>>>>>>>>>        Integer iCount iSize iItems
84312>>>>>>>>>        
84312>>>>>>>>>        Move 0 to iItems
84313>>>>>>>>>        Get pFileListArray to FileListTables
84314>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84315>>>>>>>>>        If (iSize <> 0) Begin
84317>>>>>>>>>            Decrement iSize
84318>>>>>>>>>            for iCount from 0 to iSize
84324>>>>>>>>>>
84324>>>>>>>>>                If (FileListTables[iCount].bErrorOpening = True) Begin
84326>>>>>>>>>                    Increment iItems
84327>>>>>>>>>                End
84327>>>>>>>>>>
84327>>>>>>>>>            Loop
84328>>>>>>>>>>
84328>>>>>>>>>        End
84328>>>>>>>>>>
84328>>>>>>>>>        Function_Return iItems    
84329>>>>>>>>>    End_Function 
84330>>>>>>>>>
84330>>>>>>>>>    // Checks all Alias Filelist entries for errors,
84330>>>>>>>>>    // and return them as a string array of RootNames.
84330>>>>>>>>>    Function _CountFileListAliasErrors Returns tFilelist[]
84332>>>>>>>>>        Integer iCount iItem
84332>>>>>>>>>        Handle hTable
84332>>>>>>>>>        Boolean bIsAlias bOK
84332>>>>>>>>>        String sRootName
84332>>>>>>>>>        tFilelist[] FileListArray
84332>>>>>>>>>        tFilelist[] FileListArray
84333>>>>>>>>>        
84333>>>>>>>>>        Move 0 to iCount
84334>>>>>>>>>        Move 0 to hTable
84335>>>>>>>>>        Repeat
84335>>>>>>>>>>
84335>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84338>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84340>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84341>>>>>>>>>                If (bIsAlias = True) Begin
84343>>>>>>>>>                    Get _FindAliasEntryError hTable to iItem
84344>>>>>>>>>                    If (iItem <> 0) Begin
84346>>>>>>>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84349>>>>>>>>>                        Move hTable    to FileListArray[iCount].hTable
84350>>>>>>>>>                        Move sRootName to FileListArray[iCount].sRootName
84351>>>>>>>>>                    End
84351>>>>>>>>>>
84351>>>>>>>>>                    Add iItem to iCount
84352>>>>>>>>>                End
84352>>>>>>>>>>
84352>>>>>>>>>            End
84352>>>>>>>>>>
84352>>>>>>>>>        Until (hTable = 0)
84354>>>>>>>>>        
84354>>>>>>>>>        Function_Return FileListArray
84355>>>>>>>>>    End_Function
84356>>>>>>>>>
84356>>>>>>>>>    // Helper function for _CountFileListAliasErrors.
84356>>>>>>>>>    // Checks to see if an Alias Filelist entry is correct
84356>>>>>>>>>    // What it does:
84356>>>>>>>>>    //  1. Checks that the Filelist entry is an Alias table
84356>>>>>>>>>    //  2. If an Alias, checks if the RootName points to a valid Table
84356>>>>>>>>>    Function _FindAliasEntryError Handle hTable Returns Integer
84358>>>>>>>>>        Handle hMasterTable
84358>>>>>>>>>        String sDataPath sDriver sLogicalNameAlias sRootNameAlias sNoDriverRootnameAlias sLogicalNameMaster sRootNameMaster sNoDriverRootnameMaster
84358>>>>>>>>>        Boolean bOK bFound bIsAlias bIsAliasSQL bIsMasterSQL bIsIntFile
84358>>>>>>>>>        Integer iRetval
84358>>>>>>>>>        
84358>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
84359>>>>>>>>>        If (bIsAlias = False) Begin
84361>>>>>>>>>            Function_Return 0
84362>>>>>>>>>        End
84362>>>>>>>>>>
84362>>>>>>>>>        
84362>>>>>>>>>        Move 0 to iRetval
84363>>>>>>>>>        Move False to bOK
84364>>>>>>>>>        Move False to bIsAliasSQL
84365>>>>>>>>>        Move False to bIsMasterSQL
84366>>>>>>>>>
84366>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84367>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootNameAlias
84370>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameAlias
84373>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
84374>>>>>>>>>        Get UtilAliasToMasterTableHandle hTable to hMasterTable
84375>>>>>>>>>        Move (hMasterTable <> 0) to bOK
84376>>>>>>>>>        If (bOK = True) Begin
84378>>>>>>>>>            Get _IsSQLEntry hTable       to bIsAliasSQL
84379>>>>>>>>>            Get _IsSQLEntry hMasterTable to bIsMasterSQL 
84380>>>>>>>>>            Move (bIsAliasSQL = bIsMasterSQL) to bOK
84381>>>>>>>>>        End
84381>>>>>>>>>>
84381>>>>>>>>>        
84381>>>>>>>>>        // Checks that the .int file exists in the Data folder
84381>>>>>>>>>        If (bIsIntFile = True) Begin
84383>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84384>>>>>>>>>            File_Exist (sDataPath + "\" + sNoDriverRootnameAlias) bOK
84385>>>>>>>>>        End
84385>>>>>>>>>>
84385>>>>>>>>>
84385>>>>>>>>>        If (bOK = False) Begin
84387>>>>>>>>>            Move 1 to iRetval
84388>>>>>>>>>        End
84388>>>>>>>>>>
84388>>>>>>>>>        Function_Return iRetval
84389>>>>>>>>>    End_Function
84390>>>>>>>>>        
84390>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84390>>>>>>>>>    // The returned path always ends with a "\"
84390>>>>>>>>>    Function psDataPathFirstPart Returns String
84392>>>>>>>>>        String sDataPath
84392>>>>>>>>>        Integer iCount
84392>>>>>>>>>
84392>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84393>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84394>>>>>>>>>        If (iCount > 1) Begin
84396>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84397>>>>>>>>>        End
84397>>>>>>>>>>
84397>>>>>>>>>        If (sDataPath <> "") Begin
84399>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84400>>>>>>>>>        End
84400>>>>>>>>>>
84400>>>>>>>>>
84400>>>>>>>>>        Function_Return sDataPath
84401>>>>>>>>>    End_Function
84402>>>>>>>>>
84402>>>>>>>>>    Function psLogTextFileWithPath Returns String
84404>>>>>>>>>        String sFileName
84404>>>>>>>>>        Handle hoLogFile
84404>>>>>>>>>        Get phoLogFile to hoLogFile
84405>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84406>>>>>>>>>        Function_Return sFileName
84407>>>>>>>>>    End_Function
84408>>>>>>>>>
84408>>>>>>>>>    Function phoLogFile Returns Handle
84410>>>>>>>>>        Handle hoLogFile   
84410>>>>>>>>>        Boolean bErr
84410>>>>>>>>>        
84410>>>>>>>>>        Move Err to bErr
84411>>>>>>>>>        Move 0 to hoLogFile
84412>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84413>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84414>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84416>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84417>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84418>>>>>>>>>        Move bErr to Err
84419>>>>>>>>>        
84419>>>>>>>>>        Function_Return hoLogFile
84420>>>>>>>>>    End_Function
84421>>>>>>>>>
84421>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84423>>>>>>>>>        Number nCurrentVersionUpdate
84423>>>>>>>>>
84423>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84424>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84426>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84427>>>>>>>>>
84427>>>>>>>>>        Function_Return nCurrentVersionUpdate
84428>>>>>>>>>    End_Function
84429>>>>>>>>>
84429>>>>>>>>>    Procedure LogError String sText Boolean bError
84431>>>>>>>>>        Handle hoLogFile
84431>>>>>>>>>        Number nCurrentVersionUpdate
84431>>>>>>>>>
84431>>>>>>>>>        Get phoLogFile to hoLogFile
84432>>>>>>>>>        If (hoLogFile = 0) Begin
84434>>>>>>>>>            Procedure_Return
84435>>>>>>>>>        End
84435>>>>>>>>>>
84435>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84436>>>>>>>>>
84436>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84437>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84438>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84439>>>>>>>>>    End_Procedure
84440>>>>>>>>>
84440>>>>>>>>>    Function pbContinueOnError Returns Boolean
84442>>>>>>>>>        Boolean bContinueOnError
84442>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84444>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84445>>>>>>>>>        End
84445>>>>>>>>>>
84445>>>>>>>>>        Function_Return bContinueOnError
84446>>>>>>>>>    End_Function
84447>>>>>>>>>
84447>>>>>>>>>
84447>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84449>>>>>>>>>        Integer iChIn iChOut // iCount
84449>>>>>>>>>        Boolean bExists
84449>>>>>>>>>        String sExistingColumn
84449>>>>>>>>>
84449>>>>>>>>>        Move False to bExists
84450>>>>>>>>>        Get Seq_New_Channel to iChIn
84451>>>>>>>>>        Get Seq_New_Channel to iChOut
84452>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84454>>>>>>>>>            Function_Return True
84455>>>>>>>>>        End
84455>>>>>>>>>>
84455>>>>>>>>>
84455>>>>>>>>>        Move False to Err
84456>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84456>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84458>>>>>>>>>        While (not(SeqEof))
84462>>>>>>>>>            Readln channel iChIn sExistingColumn
84464>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84466>>>>>>>>>                Move True to bExists
84467>>>>>>>>>            End
84467>>>>>>>>>>
84467>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84469>>>>>>>>>                Move True to SeqEof
84470>>>>>>>>>            End
84470>>>>>>>>>>
84470>>>>>>>>>        Loop
84471>>>>>>>>>>
84471>>>>>>>>>        Close_Input channel iChIn
84473>>>>>>>>>        Send Seq_Release_Channel iChIn
84474>>>>>>>>>
84474>>>>>>>>>        If (bExists = False) Begin
84476>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84478>>>>>>>>>            Writeln channel iChOut sColumnName
84481>>>>>>>>>            Close_Output channel iChOut
84483>>>>>>>>>            Send Seq_Release_Channel iChOut
84484>>>>>>>>>        End
84484>>>>>>>>>>
84484>>>>>>>>>
84484>>>>>>>>>        Function_Return (Err = False)
84485>>>>>>>>>    End_Function
84486>>>>>>>>>
84486>>>>>>>>>    // Changes source code files.
84486>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84486>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84486>>>>>>>>>    // to use a Connection ID.
84486>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84486>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84486>>>>>>>>>    // Returns True if no errors occured.
84486>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84488>>>>>>>>>        Integer iCh iRow iItems iCount
84488>>>>>>>>>        String sValue sRow
84488>>>>>>>>>        String[] sFileArray
84489>>>>>>>>>        Boolean bExists bIsActive bFileChange
84489>>>>>>>>>
84489>>>>>>>>>        Move False to Err
84490>>>>>>>>>        Move 0 to iRow
84491>>>>>>>>>        Move False to bFileChange
84492>>>>>>>>>
84492>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84494>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84495>>>>>>>>>        End
84495>>>>>>>>>>
84495>>>>>>>>>
84495>>>>>>>>>        Get vFilePathExists sFileName to bExists
84496>>>>>>>>>        If (bExists = False) Begin
84498>>>>>>>>>            If (bShowResult = True) Begin
84500>>>>>>>>>                If (bIsActive = True) Begin
84502>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84503>>>>>>>>>                End
84503>>>>>>>>>>
84503>>>>>>>>>                Else Begin
84504>>>>>>>>>                    Showln "File does not exist: " sFileName
84507>>>>>>>>>                End
84507>>>>>>>>>>
84507>>>>>>>>>            End
84507>>>>>>>>>>
84507>>>>>>>>>            Function_Return False
84508>>>>>>>>>        End
84508>>>>>>>>>>
84508>>>>>>>>>
84508>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84509>>>>>>>>>        If (iCh < 1) Begin
84511>>>>>>>>>            Function_Return False
84512>>>>>>>>>        End
84512>>>>>>>>>>
84512>>>>>>>>>
84512>>>>>>>>>        If (bShowResult = True) Begin
84514>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84516>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84517>>>>>>>>>                If (bIsActive = True) Begin
84519>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84520>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84521>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84522>>>>>>>>>                End
84522>>>>>>>>>>
84522>>>>>>>>>            End
84522>>>>>>>>>>
84522>>>>>>>>>            Else Begin
84523>>>>>>>>>                Showln ""
84525>>>>>>>>>                Showln "sFileName = " sFileName
84528>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84533>>>>>>>>>            End
84533>>>>>>>>>>
84533>>>>>>>>>        End
84533>>>>>>>>>>
84533>>>>>>>>>
84533>>>>>>>>>        While (not(SeqEof))
84537>>>>>>>>>            Readln channel iCh sRow
84539>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84541>>>>>>>>>                // Change the whole line to the new connection id:
84541>>>>>>>>>                Move sChangeTo to sRow 
84542>>>>>>>>>                Move True to bFileChange
84543>>>>>>>>>            End
84543>>>>>>>>>>
84543>>>>>>>>>            Move sRow to sFileArray[iRow]
84544>>>>>>>>>            Increment iRow
84545>>>>>>>>>        Loop
84546>>>>>>>>>>
84546>>>>>>>>>        Send Seq_Close_Channel iCh
84547>>>>>>>>>
84547>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84547>>>>>>>>>
84547>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84548>>>>>>>>>        If (iCh < 1) Begin
84550>>>>>>>>>            Function_Return False
84551>>>>>>>>>        End
84551>>>>>>>>>>
84551>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84552>>>>>>>>>        Decrement iItems
84553>>>>>>>>>
84553>>>>>>>>>        for iCount from 0 to iItems
84559>>>>>>>>>>
84559>>>>>>>>>            Move sFileArray[iCount] to sValue
84560>>>>>>>>>            Writeln channel iCh sValue
84563>>>>>>>>>        Loop
84564>>>>>>>>>>
84564>>>>>>>>>        Send Seq_Close_Channel iCh
84565>>>>>>>>>
84565>>>>>>>>>        Function_Return bFileChange
84566>>>>>>>>>    End_Function
84567>>>>>>>>>
84567>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84567>>>>>>>>>    // and opens it in "notepad.exe".
84567>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84567>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84567>>>>>>>>>    Procedure _UtilShowErrorList
84569>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84569>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84569>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84569>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84569>>>>>>>>>
84569>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84570>>>>>>>>>        Get vFolderFormat sPath to sPath
84571>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84572>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84573>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84574>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84575>>>>>>>>>            If (iRows > 0) Begin
84577>>>>>>>>>                Decrement iRows
84578>>>>>>>>>                for iCount from 0 to iRows
84584>>>>>>>>>>
84584>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84585>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84586>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84587>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84593>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84597>>>>>>>>>                Loop
84598>>>>>>>>>>
84598>>>>>>>>>            End
84598>>>>>>>>>>
84598>>>>>>>>>        Send Seq_Close_Channel iCh
84599>>>>>>>>>
84599>>>>>>>>>        If (iRows > 0) Begin
84601>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84602>>>>>>>>>        End
84602>>>>>>>>>>
84602>>>>>>>>>    End_Procedure
84603>>>>>>>>>
84603>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84603>>>>>>>>>    // and the table needs to exist as an SQL table.
84603>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84605>>>>>>>>>        String sRootName sDriverID
84605>>>>>>>>>        Boolean bIsSQL
84605>>>>>>>>>
84605>>>>>>>>>        Move False to bIsSQL
84606>>>>>>>>>        If (hTable > 0) Begin
84608>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84611>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84612>>>>>>>>>            If (bIsSQL = True) Begin
84614>>>>>>>>>                Get psDriverID to sDriverID
84615>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84616>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84617>>>>>>>>>            End
84617>>>>>>>>>>
84617>>>>>>>>>        End
84617>>>>>>>>>>
84617>>>>>>>>>
84617>>>>>>>>>        Function_Return bIsSQL
84618>>>>>>>>>    End_Function
84619>>>>>>>>>
84619>>>>>>>>>    // Note: This version uses the pasSQLDataTables array(!)
84619>>>>>>>>>    //       Thus that property needs to have been initialized before
84619>>>>>>>>>    //       calling this function.
84619>>>>>>>>>    Function _UtilTableIsSql_Ex Handle hTable Returns Boolean
84621>>>>>>>>>        String sRootName sDriverID
84621>>>>>>>>>        Boolean bIsSQL
84621>>>>>>>>>
84621>>>>>>>>>        Move False to bIsSQL
84622>>>>>>>>>        If (hTable > 0) Begin
84624>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84627>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84628>>>>>>>>>            If (bIsSQL = True) Begin
84630>>>>>>>>>                Get psDriverID to sDriverID
84631>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84632>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists_Ex sRootName sDriverID to bIsSQL
84633>>>>>>>>>            End
84633>>>>>>>>>>
84633>>>>>>>>>        End
84633>>>>>>>>>>
84633>>>>>>>>>
84633>>>>>>>>>        Function_Return bIsSQL
84634>>>>>>>>>    End_Function
84635>>>>>>>>>
84635>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84637>>>>>>>>>        Boolean bIsSQL
84637>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84638>>>>>>>>>        Function_Return bIsSQL
84639>>>>>>>>>    End_Function
84640>>>>>>>>>
84640>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84640>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84642>>>>>>>>>        String sDatabase sSchema sVal
84642>>>>>>>>>        Boolean bExists
84642>>>>>>>>>        String[] asTablesArray
84643>>>>>>>>>        Integer iItem
84643>>>>>>>>>
84643>>>>>>>>>        Move False to bExists
84644>>>>>>>>>        Get psDatabase to sDatabase
84645>>>>>>>>>        Get psSchema   to sSchema
84646>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84648>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84649>>>>>>>>>>
84649>>>>>>>>>            Function_Return False
84650>>>>>>>>>        End
84650>>>>>>>>>>
84650>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
84651>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84652>>>>>>>>>        If (iItem <> -1) Begin
84654>>>>>>>>>            Move True to bExists
84655>>>>>>>>>        End
84655>>>>>>>>>>
84655>>>>>>>>>        Function_Return bExists
84656>>>>>>>>>    End_Function
84657>>>>>>>>>
84657>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84657>>>>>>>>>    // This alternative is much faster as it first enumerates all SQL tables
84657>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists_Ex String sTableName String sDriverID Returns Boolean
84659>>>>>>>>>        String sDatabase sSchema sVal
84659>>>>>>>>>        Boolean bExists
84659>>>>>>>>>        String[] asTablesArray
84660>>>>>>>>>        Integer iItem
84660>>>>>>>>>
84660>>>>>>>>>        Move False to bExists
84661>>>>>>>>>        Get psDatabase to sDatabase
84662>>>>>>>>>        Get psSchema   to sSchema
84663>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84665>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84666>>>>>>>>>>
84666>>>>>>>>>            Function_Return False
84667>>>>>>>>>        End
84667>>>>>>>>>>
84667>>>>>>>>>        Get pasSQLDataTables to asTablesArray
84668>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84669>>>>>>>>>        If (iItem <> -1) Begin
84671>>>>>>>>>            Move True to bExists
84672>>>>>>>>>        End
84672>>>>>>>>>>
84672>>>>>>>>>        Function_Return bExists
84673>>>>>>>>>    End_Function
84674>>>>>>>>>
84674>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84674>>>>>>>>>    // that the embedded .dat file exists on disk.
84674>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84676>>>>>>>>>        Boolean bExists bIsEmbedded
84676>>>>>>>>>        String sDataPath sRootName
84676>>>>>>>>>
84676>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84677>>>>>>>>>        If (bExists = False) Begin
84679>>>>>>>>>            Function_Return False
84680>>>>>>>>>        End
84680>>>>>>>>>>
84680>>>>>>>>>
84680>>>>>>>>>        Move False to bIsEmbedded
84681>>>>>>>>>        If (hTable > 0) Begin
84683>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84686>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84687>>>>>>>>>        End
84687>>>>>>>>>>
84687>>>>>>>>>        If (bIsEmbedded = True) Begin
84689>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84690>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84691>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84692>>>>>>>>>        End
84692>>>>>>>>>>
84692>>>>>>>>>
84692>>>>>>>>>        Function_Return bIsEmbedded
84693>>>>>>>>>    End_Function
84694>>>>>>>>>
84694>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84694>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84696>>>>>>>>>        Date dDate
84696>>>>>>>>>        Integer iYY iHH iMM iSS
84696>>>>>>>>>        Boolean bExists
84696>>>>>>>>>        DateTime dtFileDateTime
84696>>>>>>>>>
84696>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84697>>>>>>>>>        Get vFilePathExists sFileName to bExists
84698>>>>>>>>>        If (bExists = True) Begin
84700>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84704>>>>>>>>>            Move dDate            to dtFileDateTime
84705>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84706>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84707>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84708>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84709>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84710>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84711>>>>>>>>>        End
84711>>>>>>>>>>
84711>>>>>>>>>
84711>>>>>>>>>        Function_Return dtFileDateTime
84712>>>>>>>>>    End_Function
84713>>>>>>>>>
84713>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84713>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84715>>>>>>>>>        Boolean bExists bIsNewer
84715>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84715>>>>>>>>>
84715>>>>>>>>>        Move False to bIsNewer
84716>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84717>>>>>>>>>        If (bExists = True) Begin
84719>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84720>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84721>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84722>>>>>>>>>        End
84722>>>>>>>>>>
84722>>>>>>>>>        Function_Return bIsNewer
84723>>>>>>>>>    End_Function
84724>>>>>>>>>
84724>>>>>>>>>End_Class
84725>>>>>>>
84725>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84725>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84726>>>>>>>
84726>>>>>>>    Procedure Construct_Object
84728>>>>>>>        Forward Send Construct_Object
84730>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84731>>>>>>>    End_Procedure
84732>>>>>>>
84732>>>>>>>    Procedure End_Construct_Object
84734>>>>>>>        Forward Send End_Construct_Object
84736>>>>>>>    End_Procedure
84737>>>>>>>
84737>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84737>>>>>>>    //
84737>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84737>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84739>>>>>>>        Function_Return False
84740>>>>>>>    End_Function
84741>>>>>>>
84741>>>>>>>    // Function for creating a new *Database*.
84741>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84741>>>>>>>    // Returns True if successful.
84741>>>>>>>    // ToDo: Currently only works for MS-SQL...
84741>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84743>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84743>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84743>>>>>>>        Handle hConnection hStmt hoSQLManager
84743>>>>>>>        Integer iFetchResult iDbType
84743>>>>>>>        Boolean bOK bExists
84743>>>>>>>
84743>>>>>>>        Get piDbType to iDbType
84744>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84746>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84747>>>>>>>>
84747>>>>>>>            Function_Return False
84748>>>>>>>        End
84748>>>>>>>>
84748>>>>>>>
84748>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84749>>>>>>>        If (bExists = True) Begin
84751>>>>>>>            Function_Return True
84752>>>>>>>        End
84752>>>>>>>>
84752>>>>>>>
84752>>>>>>>        Get phoSQLManager to hoSQLManager
84753>>>>>>>
84753>>>>>>>        Get psConnectionID     to sConnectionID
84754>>>>>>>        Get psConnectionString to sConnectionString
84755>>>>>>>        Move 0 to LastErr
84756>>>>>>>
84756>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84758>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84758>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84758>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84758>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84758>>>>>>>//                If (iPos > 0) Begin
84758>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84758>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84758>>>>>>>//                End
84758>>>>>>>//            End
84758>>>>>>>        End
84758>>>>>>>>
84758>>>>>>>
84758>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84759>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84760>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84761>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84763>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84764>>>>>>>>
84764>>>>>>>            Function_Return False
84765>>>>>>>        End
84765>>>>>>>>
84765>>>>>>>
84765>>>>>>>        Get SqlOpen of hConnection to hStmt
84766>>>>>>>
84766>>>>>>>        If (hStmt = 0) Begin
84768>>>>>>>            Send SqlDisconnect of hoSQLManager
84769>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84770>>>>>>>>
84770>>>>>>>            Function_Return False
84771>>>>>>>        End
84771>>>>>>>>
84771>>>>>>>
84771>>>>>>>        Get psCollation to sCollation
84772>>>>>>>
84772>>>>>>>        Case Begin
84772>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84774>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84775>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84776>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84777>>>>>>>
84777>>>>>>>                // Check if database exists
84777>>>>>>>                Send SqlExecDirect of hStmt sSQL
84778>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84779>>>>>>>                Send SqlClose of hStmt
84780>>>>>>>                Send SqlDisconnect of hConnection
84781>>>>>>>                // If database already exists we're out of here!
84781>>>>>>>                // Note that we return True as this is not an error.
84781>>>>>>>                If (iFetchResult > 0) Begin
84783>>>>>>>                    Function_Return True
84784>>>>>>>                End
84784>>>>>>>>
84784>>>>>>>                // Database doesn't exist, create it.
84784>>>>>>>                If (iFetchResult = 0) Begin
84786>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84787>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84788>>>>>>>                    If (sCollation <> "") Begin
84790>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84791>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84792>>>>>>>                    End
84792>>>>>>>>
84792>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84793>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84794>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84796>>>>>>>                        Function_Return False
84797>>>>>>>                    End
84797>>>>>>>>
84797>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84797>>>>>>>                    Sleep 1
84798>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84799>>>>>>>                End
84799>>>>>>>>
84799>>>>>>>                Case Break
84800>>>>>>>
84800>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84803>>>>>>>                // ToDo: How should this be set/checked?
84803>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84803>>>>>>>//                    Set psCollation to "utf8"
84803>>>>>>>//                End
84803>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84803>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84804>>>>>>>                Case Break
84805>>>>>>>
84805>>>>>>>            Case Else
84805>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84806>>>>>>>>
84806>>>>>>>        Case End
84806>>>>>>>
84806>>>>>>>        If (Err = False) Begin
84808>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84809>>>>>>>        End
84809>>>>>>>>
84809>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84809>>>>>>>        // the one we just created.
84809>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84811>>>>>>>            Set psDatabase to sDatabase
84812>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84812>>>>>>>            If (bPermanantly = True) Begin
84814>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84816>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84817>>>>>>>                End
84817>>>>>>>>
84817>>>>>>>            End
84817>>>>>>>>
84817>>>>>>>        End
84817>>>>>>>>
84817>>>>>>>
84817>>>>>>>        Function_Return (Err = False)
84818>>>>>>>    End_Function
84819>>>>>>>
84819>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84819>>>>>>>    // will be used.
84819>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84821>>>>>>>        Boolean bOK bExists bShowProgress bErr
84821>>>>>>>        String sStatement sDriverID
84821>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84821>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84821>>>>>>>        Integer iDbType
84821>>>>>>>
84821>>>>>>>        If (sDatabase = "") Begin
84823>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84824>>>>>>>>
84824>>>>>>>            Function_Return False
84825>>>>>>>        End
84825>>>>>>>>
84825>>>>>>>        If (sBackupName = "") Begin
84827>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84828>>>>>>>>
84828>>>>>>>            Function_Return False
84829>>>>>>>        End
84829>>>>>>>>
84829>>>>>>>
84829>>>>>>>        // Create backup-folder if it doesn't exist
84829>>>>>>>        Get vFolderExists sPath to bExists
84830>>>>>>>        If (bExists = False) Begin
84832>>>>>>>            Get vCreateDirectory sPath to bErr
84833>>>>>>>            If (bErr = True) Begin
84835>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84836>>>>>>>>
84836>>>>>>>                Function_Return False
84837>>>>>>>            End
84837>>>>>>>>
84837>>>>>>>        End
84837>>>>>>>>
84837>>>>>>>        // Make sure the path ends with a back-slash
84837>>>>>>>        If (sPath <> "") Begin
84839>>>>>>>            Get vFolderFormat sPath to sPath
84840>>>>>>>        End
84840>>>>>>>>
84840>>>>>>>
84840>>>>>>>        Get psDriverID to sDriverID
84841>>>>>>>        Get piDbType   to iDbType
84842>>>>>>>        If (num_arguments > 3) Begin
84844>>>>>>>            Move bShowProg to bShowProgress
84845>>>>>>>        End
84845>>>>>>>>
84845>>>>>>>
84845>>>>>>>        Case Begin
84845>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84847>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84847>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84847>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84848>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84849>>>>>>>
84849>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84850>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84851>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84852>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84853>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84854>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84855>>>>>>>                Case Break
84856>>>>>>>            Case Else
84856>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84857>>>>>>>        Case End
84857>>>>>>>
84857>>>>>>>        Function_Return bOK
84858>>>>>>>    End_Function
84859>>>>>>>
84859>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84861>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84861>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84861>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84861>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84861>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84861>>>>>>>        tSQLConnection SQLConnection
84861>>>>>>>        tSQLConnection SQLConnection
84861>>>>>>>
84861>>>>>>>        If (sDatabase = "") Begin
84863>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84864>>>>>>>>
84864>>>>>>>            Function_Return ""
84865>>>>>>>        End
84865>>>>>>>>
84865>>>>>>>
84865>>>>>>>        Move "" to sRetval
84866>>>>>>>        Get psDriverID to sDriverID
84867>>>>>>>        Get piDbType   to iDbType
84868>>>>>>>
84868>>>>>>>        Case Begin
84868>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84870>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84870>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84871>>>>>>>
84871>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84872>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84873>>>>>>>                Get phoSQLManager to hoSQLHandler
84874>>>>>>>
84874>>>>>>>                If (hoSQLHandler <> 0) Begin
84876>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84877>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84878>>>>>>>
84878>>>>>>>                    If (hoSQLConnect <> 0) Begin
84880>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84881>>>>>>>                        If (hstmt <> 0) Begin
84883>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84884>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84885>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84886>>>>>>>                            If (iFetchResult <> 0) Begin
84888>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84889>>>>>>>                            End
84889>>>>>>>>
84889>>>>>>>                            Send SQLClose of hstmt
84890>>>>>>>                        End
84890>>>>>>>>
84890>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84891>>>>>>>                    End
84891>>>>>>>>
84891>>>>>>>                End
84891>>>>>>>>
84891>>>>>>>                Case Break
84892>>>>>>>            Case Else
84892>>>>>>>                If (bSilent = False) Begin
84894>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84895>>>>>>>                End
84895>>>>>>>>
84895>>>>>>>        Case End
84895>>>>>>>
84895>>>>>>>        Function_Return sRetval
84896>>>>>>>    End_Function
84897>>>>>>>
84897>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84899>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84899>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84899>>>>>>>        Handle hConnection hStmt hoSQLManager
84899>>>>>>>        Integer iDbType // iFetchResult
84899>>>>>>>
84899>>>>>>>        If (sDatabase = "") Begin
84901>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84902>>>>>>>>
84902>>>>>>>            Function_Return False
84903>>>>>>>        End
84903>>>>>>>>
84903>>>>>>>
84903>>>>>>>        If (sSQLCollation = "") Begin
84905>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84906>>>>>>>>
84906>>>>>>>            Function_Return False
84907>>>>>>>        End
84907>>>>>>>>
84907>>>>>>>
84907>>>>>>>        Get psDriverID to sDriverID
84908>>>>>>>        Get piDbType   to iDbType
84909>>>>>>>
84909>>>>>>>        Get phoSQLManager to hoSQLManager
84910>>>>>>>        Get psConnectionID     to sConnectionID
84911>>>>>>>        Get psConnectionString to sConnectionString
84912>>>>>>>        Move 0 to LastErr
84913>>>>>>>
84913>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84914>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84915>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84916>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84918>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84919>>>>>>>>
84919>>>>>>>            Function_Return False
84920>>>>>>>        End
84920>>>>>>>>
84920>>>>>>>
84920>>>>>>>        Get SqlOpen of hConnection to hStmt
84921>>>>>>>
84921>>>>>>>        If (hStmt = 0) Begin
84923>>>>>>>            Send SqlDisconnect of hoSQLManager
84924>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84925>>>>>>>>
84925>>>>>>>            Function_Return False
84926>>>>>>>        End
84926>>>>>>>>
84926>>>>>>>
84926>>>>>>>        // Check if collation already exists
84926>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84927>>>>>>>        // If the current collate is the same as the new; do nothing.
84927>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84929>>>>>>>            Function_Return True
84930>>>>>>>        End
84930>>>>>>>>
84930>>>>>>>
84930>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84931>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84932>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84933>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84934>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84935>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84936>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84937>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84938>>>>>>>
84938>>>>>>>        // MS-SQL Syntax:
84938>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84938>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84938>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84938>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84939>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84940>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84941>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84941>>>>>>>
84941>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84942>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84943>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84944>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84946>>>>>>>           Function_Return False
84947>>>>>>>        End
84947>>>>>>>>
84947>>>>>>>
84947>>>>>>>        Function_Return (Err = False)
84948>>>>>>>    End_Function
84949>>>>>>>
84949>>>>>>>
84949>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84949>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84951>>>>>>>        Function_Return False
84952>>>>>>>    End_Function
84953>>>>>>>
84953>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84953>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84953>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84953>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84953>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84953>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84955>>>>>>>        Handle hToTable
84955>>>>>>>        Boolean bOK bExists bOpened bCopyData
84955>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84955>>>>>>>        tSQLConnection SQLConnection
84955>>>>>>>        tSQLConnection SQLConnection
84955>>>>>>>        Integer iPos iMaxRecords
84955>>>>>>>
84955>>>>>>>        Get psDriverID to sDriverID
84956>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84957>>>>>>>        If (bExists = False) Begin
84959>>>>>>>            Function_Return False
84960>>>>>>>        End
84960>>>>>>>>
84960>>>>>>>
84960>>>>>>>        If (num_arguments > 1) Begin
84962>>>>>>>            Move bCpyDat to bCopyData
84963>>>>>>>        End
84963>>>>>>>>
84963>>>>>>>        Else Begin
84964>>>>>>>            Move False to bCopyData
84965>>>>>>>        End
84965>>>>>>>>
84965>>>>>>>
84965>>>>>>>        Open hTable
84967>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84970>>>>>>>        If (bOpened = False) Begin
84972>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84973>>>>>>>>
84973>>>>>>>            Function_Return False
84974>>>>>>>        End
84974>>>>>>>>
84974>>>>>>>        Move 0 to hToTable
84975>>>>>>>
84975>>>>>>>        Move 16711679 to iMaxRecords
84976>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84979>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84980>>>>>>>        If (iPos > 0) Begin
84982>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84983>>>>>>>        End
84983>>>>>>>>
84983>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84986>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84987>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84988>>>>>>>
84988>>>>>>>        If (ghoProgressBar <> 0) Begin
84990>>>>>>>            Send DoAdvance of ghoProgressBar
84991>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84992>>>>>>>        End
84992>>>>>>>>
84992>>>>>>>
84992>>>>>>>        Move False to Err
84993>>>>>>>
84993>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84994>>>>>>>            Structure_Copy hTable to hToTable
84995>>>>>>>
84995>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84998>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
85001>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
85004>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
85007>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
85010>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85011>>>>>>>
85011>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85013>>>>>>>
85013>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85014>>>>>>>        Move (not(Err)) to bOK
85015>>>>>>>        If (bOK = True and bCopyData = True) Begin
85017>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
85018>>>>>>>        End
85018>>>>>>>>
85018>>>>>>>
85018>>>>>>>        // This must be after copying data...
85018>>>>>>>        If (Err = False) Begin
85020>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85023>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85026>>>>>>>        End
85026>>>>>>>>
85026>>>>>>>        Move (not(Err)) to bOK
85027>>>>>>>
85027>>>>>>>        Function_Return (bOK = True)
85028>>>>>>>    End_Function
85029>>>>>>>
85029>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
85029>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85029>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
85031>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
85031>>>>>>>        Integer iDbType
85031>>>>>>>        Boolean bExists
85031>>>>>>>
85031>>>>>>>        Get psDriverID to sDriverID
85032>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85033>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85034>>>>>>>        If (bExists = True) Begin
85036>>>>>>>            Function_Return False
85037>>>>>>>        End
85037>>>>>>>>
85037>>>>>>>
85037>>>>>>>        Get psDataPathFirstPart to sPath
85038>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85039>>>>>>>
85039>>>>>>>        Get piDbType to iDbType
85040>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85041>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85042>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85043>>>>>>>
85043>>>>>>>        Move False to Err
85044>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85045>>>>>>>
85045>>>>>>>        Function_Return (Err = False)
85046>>>>>>>    End_Function
85047>>>>>>>
85047>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
85047>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85047>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
85049>>>>>>>        String sSQLString sPath sCreateTable sDriverID
85049>>>>>>>        Integer iDbType
85049>>>>>>>        Boolean bExists
85049>>>>>>>
85049>>>>>>>        Get psDriverID to sDriverID
85050>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85051>>>>>>>        If (bExists = True) Begin
85053>>>>>>>            Function_Return False
85054>>>>>>>        End
85054>>>>>>>>
85054>>>>>>>
85054>>>>>>>        Get psDataPathFirstPart to sPath
85055>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85056>>>>>>>        If (bExists = True) Begin
85058>>>>>>>            // ToDo: What should we do if an .int file already exists?
85058>>>>>>>        End
85058>>>>>>>>
85058>>>>>>>
85058>>>>>>>        Get piDbType to iDbType
85059>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85060>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85061>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85062>>>>>>>
85062>>>>>>>        Move False to Err
85063>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85064>>>>>>>
85064>>>>>>>        Function_Return (Err = False)
85065>>>>>>>    End_Function
85066>>>>>>>    
85066>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
85066>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
85066>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
85068>>>>>>>        Boolean bOK                                                            
85068>>>>>>>        String sStatement
85068>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
85069>>>>>>>        Function_Return bOK
85070>>>>>>>    End_Function
85071>>>>>>>    
85071>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
85071>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
85071>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
85071>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
85073>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
85073>>>>>>>        Integer iRetval iDbType
85073>>>>>>>        Boolean bExists bOK
85073>>>>>>>
85073>>>>>>>        Get psDriverID to sDriverID
85074>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85075>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85076>>>>>>>        If (bExists = False) Begin
85078>>>>>>>            Function_Return False
85079>>>>>>>        End
85079>>>>>>>>
85079>>>>>>>
85079>>>>>>>        Get psDataPathFirstPart to sPath
85080>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85081>>>>>>>
85081>>>>>>>        Get piDbType to iDbType
85082>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85083>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85084>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85085>>>>>>>
85085>>>>>>>        Move False to Err
85086>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85087>>>>>>>
85087>>>>>>>        // We also need to remove the cache-file since the table has been changed
85087>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85088>>>>>>>
85088>>>>>>>        Function_Return (Err = False)
85089>>>>>>>    End_Function
85090>>>>>>>
85090>>>>>>>    // First deletes the data cache file and then drops the passed data table.
85090>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
85092>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
85092>>>>>>>        Integer iRetval iDbType
85092>>>>>>>        Boolean bOK
85092>>>>>>>
85092>>>>>>>        Get psDriverID to sDriverID
85093>>>>>>>        Get psDataPathFirstPart to sPath
85094>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85095>>>>>>>
85095>>>>>>>        Get piDbType to iDbType
85096>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85097>>>>>>>        Get psSchema to sSchema
85098>>>>>>>        If (sSchema = "") Begin
85100>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85101>>>>>>>        End
85101>>>>>>>>
85101>>>>>>>        Move (Uppercase(sTableName)) to sVal
85102>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85104>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85105>>>>>>>        End
85105>>>>>>>>
85105>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85106>>>>>>>
85106>>>>>>>        Move False to Err
85107>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85108>>>>>>>
85108>>>>>>>        // We also need to remove the cache-file since the table has been changed
85108>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85109>>>>>>>
85109>>>>>>>        Function_Return (Err = False)
85110>>>>>>>    End_Function
85111>>>>>>>
85111>>>>>>>    // *** Sql View Messages ***
85111>>>>>>>
85111>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
85111>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
85113>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
85113>>>>>>>        Integer iRetval
85113>>>>>>>        Boolean bOK
85113>>>>>>>
85113>>>>>>>        Get psDriverID to sDriverID
85114>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
85115>>>>>>>
85115>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
85116>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
85117>>>>>>>        Set psSQLStatementString to sSQLString
85118>>>>>>>
85118>>>>>>>        // As we don't check if the view exist or not, it might happen
85118>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
85118>>>>>>>        Move False to Err
85119>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85120>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85121>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85122>>>>>>>        Move 0 to LastErr
85123>>>>>>>
85123>>>>>>>        // We also need to remove the cache-file since the table has been changed
85123>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
85124>>>>>>>
85124>>>>>>>        Function_Return (Err = False)
85125>>>>>>>    End_Function
85126>>>>>>>
85126>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
85128>>>>>>>        Boolean bOK
85128>>>>>>>        Integer iDbType
85128>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
85128>>>>>>>
85128>>>>>>>        Get psDriverID to sDriverID
85129>>>>>>>        Get piDbType   to iDbType
85130>>>>>>>
85130>>>>>>>        Case Begin
85130>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85132>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85133>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85134>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85135>>>>>>>            Break
85136>>>>>>>
85136>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85139>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85140>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85141>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
85142>>>>>>>            Break
85143>>>>>>>
85143>>>>>>>            Case (iDbType = EN_DbTypeOracle)
85146>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85147>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85148>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85149>>>>>>>            Break
85150>>>>>>>
85150>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85153>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85154>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85155>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85156>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
85157>>>>>>>            Break
85158>>>>>>>
85158>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85161>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85162>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85163>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
85164>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85165>>>>>>>            Break
85166>>>>>>>        Case End
85166>>>>>>>
85166>>>>>>>        Move False to Err
85167>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85168>>>>>>>        Move (Err = False) to bOK
85169>>>>>>>
85169>>>>>>>        Function_Return bOK
85170>>>>>>>    End_Function
85171>>>>>>>
85171>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85171>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
85173>>>>>>>        Function_Return False
85174>>>>>>>    End_Function
85175>>>>>>>
85175>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
85175>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85177>>>>>>>        Integer iLength iDecimals
85177>>>>>>>        String sColumnValue
85177>>>>>>>        String sTableName sDriverID
85177>>>>>>>        Boolean bOK bInitializeValue
85177>>>>>>>
85177>>>>>>>        Get psDriverID to sDriverID
85178>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85179>>>>>>>        If (bOK = False) Begin
85181>>>>>>>            Function_Return False
85182>>>>>>>        End
85182>>>>>>>>
85182>>>>>>>
85182>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85183>>>>>>>        If (sTableName = "") Begin
85185>>>>>>>            Function_Return False
85186>>>>>>>        End
85186>>>>>>>>
85186>>>>>>>
85186>>>>>>>        If (num_arguments > 3) Begin
85188>>>>>>>            Move iLen     to iLength
85189>>>>>>>            Move iDec     to iDecimals
85190>>>>>>>            Move bInitVal to bInitializeValue
85191>>>>>>>            Move sColVal  to sColumnValue
85192>>>>>>>        End
85192>>>>>>>>
85192>>>>>>>
85192>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
85193>>>>>>>
85193>>>>>>>        Function_Return (bOK = True)
85194>>>>>>>    End_Function
85195>>>>>>>
85195>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
85195>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85197>>>>>>>        Integer iDbType iLength iDecimals iDriver
85197>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
85197>>>>>>>        String sDriverID sNotNull
85197>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
85197>>>>>>>        Handle hTable
85197>>>>>>>
85197>>>>>>>        Get psDriverID to sDriverID
85198>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85199>>>>>>>        If (bOK = False) Begin
85201>>>>>>>            Function_Return True
85202>>>>>>>        End
85202>>>>>>>>
85202>>>>>>>
85202>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85203>>>>>>>        If (hTable = 0) Begin
85205>>>>>>>            Get NextFreeFilelistSlot to hTable
85206>>>>>>>        End
85206>>>>>>>>
85206>>>>>>>
85206>>>>>>>        Get piDbType to iDbType
85207>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
85207>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85208>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
85210>>>>>>>            Function_Return True
85211>>>>>>>        End
85211>>>>>>>>
85211>>>>>>>
85211>>>>>>>        Get DriverIndex sDriverID to iDriver
85212>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85215>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85218>>>>>>>
85218>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85219>>>>>>>        If (num_arguments > 3) Begin
85221>>>>>>>            Move iLen     to iLength
85222>>>>>>>            Move iDec     to iDecimals
85223>>>>>>>            Move bInitVal to bInitializeValue
85224>>>>>>>            Move sColVal  to sColumnValue
85225>>>>>>>        End
85225>>>>>>>>
85225>>>>>>>
85225>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
85226>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85227>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85228>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85229>>>>>>>
85229>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85230>>>>>>>        If (bFixed = False) Begin
85232>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85233>>>>>>>        End
85233>>>>>>>>
85233>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85234>>>>>>>
85234>>>>>>>        Move False to Err
85235>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85236>>>>>>>
85236>>>>>>>        If (bInitializeValue = True and Err = False) Begin
85238>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
85239>>>>>>>        End
85239>>>>>>>>
85239>>>>>>>
85239>>>>>>>        If (Err = False) Begin
85241>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
85242>>>>>>>        End
85242>>>>>>>>
85242>>>>>>>
85242>>>>>>>        Move (not(Err)) to bRetval
85243>>>>>>>
85243>>>>>>>        // We also need to remove the cache-file since the table has been changed
85243>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85244>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85247>>>>>>>
85247>>>>>>>        Function_Return bRetval
85248>>>>>>>    End_Function
85249>>>>>>>
85249>>>>>>>    // To update all current rows for a table column with a common value.
85249>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
85251>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
85251>>>>>>>        Boolean bRetval bSQLDriver
85251>>>>>>>        Integer iCurrErr iDbType
85251>>>>>>>
85251>>>>>>>        Move False to bRetval
85252>>>>>>>        Get piDbType to iDbType
85253>>>>>>>        Get psDriverID to sDriverID
85254>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85255>>>>>>>        If (bSQLDriver = False) Begin
85257>>>>>>>            Function_Return bRetval
85258>>>>>>>        End
85258>>>>>>>>
85258>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85259>>>>>>>
85259>>>>>>>        Move Err to iCurrErr
85260>>>>>>>        Move False to Err
85261>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
85262>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
85263>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
85264>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
85264>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85266>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
85267>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85268>>>>>>>        End
85268>>>>>>>>
85268>>>>>>>        Else Begin
85269>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85270>>>>>>>        End
85270>>>>>>>>
85270>>>>>>>
85270>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85271>>>>>>>        Move (Err = False) to bRetval
85272>>>>>>>        Move iCurrErr to Err
85273>>>>>>>
85273>>>>>>>        Function_Return bRetval
85274>>>>>>>    End_Function
85275>>>>>>>
85275>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85275>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85275>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85277>>>>>>>        String sDriverID sTableName
85277>>>>>>>        Boolean bOK
85277>>>>>>>
85277>>>>>>>        Get psDriverID to sDriverID
85278>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85279>>>>>>>        If (bOK = False) Begin
85281>>>>>>>            Function_Return False
85282>>>>>>>        End
85282>>>>>>>>
85282>>>>>>>
85282>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85283>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
85284>>>>>>>
85284>>>>>>>        Function_Return (Err = False)
85285>>>>>>>    End_Function
85286>>>>>>>
85286>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
85286>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85286>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85286>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85288>>>>>>>        Integer iDbType iLength iDecimals
85288>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
85288>>>>>>>        Boolean bExists bOK bFixed
85288>>>>>>>        Handle hTable
85288>>>>>>>
85288>>>>>>>        Get psDriverID to sDriverID
85289>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85290>>>>>>>        If (bOK = False) Begin
85292>>>>>>>            Function_Return False
85293>>>>>>>        End
85293>>>>>>>>
85293>>>>>>>
85293>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85294>>>>>>>        If (hTable = 0) Begin
85296>>>>>>>            Get NextFreeFilelistSlot to hTable
85297>>>>>>>        End
85297>>>>>>>>
85297>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
85298>>>>>>>        If (bExists = False) Begin
85300>>>>>>>            Function_Return False
85301>>>>>>>        End
85301>>>>>>>>
85301>>>>>>>
85301>>>>>>>        If (num_arguments > 3) Begin
85303>>>>>>>            Move iLen to iLength
85304>>>>>>>        End
85304>>>>>>>>
85304>>>>>>>        If (num_arguments > 4) Begin
85306>>>>>>>            Move iDec to iDecimals
85307>>>>>>>        End
85307>>>>>>>>
85307>>>>>>>
85307>>>>>>>        Get piDbType to iDbType
85308>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85309>>>>>>>
85309>>>>>>>        Move False to Err
85310>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85311>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85312>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85313>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85314>>>>>>>
85314>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85315>>>>>>>        If (bFixed = False) Begin
85317>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85318>>>>>>>        End
85318>>>>>>>>
85318>>>>>>>
85318>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85319>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85320>>>>>>>
85320>>>>>>>        // We also need to remove the cache-file since the table has been changed
85320>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85321>>>>>>>
85321>>>>>>>        Function_Return (Err = False)
85322>>>>>>>    End_Function
85323>>>>>>>
85323>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85325>>>>>>>        Boolean bOK bErr bIsSQLDriver
85325>>>>>>>        String sDriverID
85325>>>>>>>        Integer iDataType
85325>>>>>>>
85325>>>>>>>        Get psDriverID to sDriverID
85326>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85327>>>>>>>        If (bIsSQLDriver = False) Begin
85329>>>>>>>            Function_Return False
85330>>>>>>>        End
85330>>>>>>>>
85330>>>>>>>
85330>>>>>>>        Move Err to bErr
85331>>>>>>>        Move False to bErr
85332>>>>>>>
85332>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85332>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85332>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85333>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85336>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85338>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85339>>>>>>>        End
85339>>>>>>>>
85339>>>>>>>
85339>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85342>>>>>>>        Move (not(Err)) to bOK
85343>>>>>>>        Move bErr to Err
85344>>>>>>>
85344>>>>>>>        Function_Return bOK
85345>>>>>>>    End_Function
85346>>>>>>>
85346>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85348>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85348>>>>>>>        String sDriverID
85348>>>>>>>
85348>>>>>>>        Get psDriverID to sDriverID
85349>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85350>>>>>>>        If (bIsSQLDriver = False) Begin
85352>>>>>>>            Function_Return False
85353>>>>>>>        End
85353>>>>>>>>
85353>>>>>>>
85353>>>>>>>        Move Err to bErr
85354>>>>>>>        Move False to bErr
85355>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85358>>>>>>>        If (bNullable = bCurrentState) Begin
85360>>>>>>>            Function_Return True
85361>>>>>>>        End
85361>>>>>>>>
85361>>>>>>>
85361>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85364>>>>>>>        If (bOpen = False) Begin
85366>>>>>>>            Get AutoConnectionIDLogin to bOK
85367>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85368>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85369>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85370>>>>>>>            Open hTable
85372>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85373>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85374>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85375>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85378>>>>>>>        End
85378>>>>>>>>
85378>>>>>>>        If (bOpen = True) Begin
85380>>>>>>>            Structure_Start hTable sDriverID
85381>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85384>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85385>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85387>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85388>>>>>>>        End
85388>>>>>>>>
85388>>>>>>>
85388>>>>>>>        Move (not(Err)) to bOK
85389>>>>>>>        Move bErr to Err
85390>>>>>>>
85390>>>>>>>        Function_Return bOK
85391>>>>>>>    End_Function
85392>>>>>>>
85392>>>>>>>    // Drop column by its table handle
85392>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85394>>>>>>>        String sDriverID sTableName
85394>>>>>>>        Boolean bOK
85394>>>>>>>
85394>>>>>>>        Get psDriverID to sDriverID
85395>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85396>>>>>>>        If (bOK = False) Begin
85398>>>>>>>            Function_Return False
85399>>>>>>>        End
85399>>>>>>>>
85399>>>>>>>
85399>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85400>>>>>>>        If (sTableName = "") Begin
85402>>>>>>>            Function_Return False
85403>>>>>>>        End
85403>>>>>>>>
85403>>>>>>>
85403>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85404>>>>>>>
85404>>>>>>>        Function_Return (bOK = True)
85405>>>>>>>    End_Function
85406>>>>>>>
85406>>>>>>>    // Drop column by its table name as a string.
85406>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85408>>>>>>>        Integer iDbType iDriver
85408>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85408>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85408>>>>>>>        Handle hTable
85408>>>>>>>
85408>>>>>>>        Get psDriverID to sDriverID
85409>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85410>>>>>>>        If (bOK = False) Begin
85412>>>>>>>            Function_Return False
85413>>>>>>>        End
85413>>>>>>>>
85413>>>>>>>
85413>>>>>>>        Get DriverIndex sDriverID to iDriver
85414>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85417>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85420>>>>>>>
85420>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85421>>>>>>>        If (hTable <> 0) Begin
85423>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85424>>>>>>>            If (bExists = False) Begin
85426>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85429>>>>>>>                Function_Return False
85430>>>>>>>            End
85430>>>>>>>>
85430>>>>>>>        End
85430>>>>>>>>
85430>>>>>>>
85430>>>>>>>        Get piDbType to iDbType
85431>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85433>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85434>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85435>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85438>>>>>>>            Function_Return bOK
85439>>>>>>>        End
85439>>>>>>>>
85439>>>>>>>
85439>>>>>>>        Move False to Err
85440>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85441>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85442>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85443>>>>>>>
85443>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85444>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85445>>>>>>>        Move (not(Err)) to bRetval
85446>>>>>>>
85446>>>>>>>        // We also need to remove the cache-file since the table has been changed
85446>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85447>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85450>>>>>>>
85450>>>>>>>        Function_Return bRetval
85451>>>>>>>    End_Function
85452>>>>>>>
85452>>>>>>>    // Rename a field/column by table handle (filelist number)
85452>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85454>>>>>>>        String sDriverID sTableName
85454>>>>>>>        Boolean bOK
85454>>>>>>>
85454>>>>>>>        Get psDriverID to sDriverID
85455>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85456>>>>>>>        If (bOK = False) Begin
85458>>>>>>>            Function_Return False
85459>>>>>>>        End
85459>>>>>>>>
85459>>>>>>>
85459>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85460>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85461>>>>>>>
85461>>>>>>>        Function_Return (Err = False)
85462>>>>>>>    End_Function
85463>>>>>>>
85463>>>>>>>    // Rename a field/column by table name.
85463>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85465>>>>>>>        Integer iDbType iDataType
85465>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85465>>>>>>>        Boolean bOK bRetval
85465>>>>>>>        Handle hTable
85465>>>>>>>
85465>>>>>>>        Move sTableName to sOrgTableName
85466>>>>>>>        Get psDriverID to sDriverID
85467>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85468>>>>>>>        If (bOK = False) Begin
85470>>>>>>>            Function_Return False
85471>>>>>>>        End
85471>>>>>>>>
85471>>>>>>>
85471>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85472>>>>>>>        If (sVal = "") Begin
85474>>>>>>>            Function_Return False
85475>>>>>>>        End
85475>>>>>>>>
85475>>>>>>>
85475>>>>>>>        Get piDbType to iDbType
85476>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85477>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85478>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85479>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85480>>>>>>>
85480>>>>>>>        Case Begin
85480>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85482>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85483>>>>>>>                Case Break
85484>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85484>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85487>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85488>>>>>>>                Case Break
85489>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85489>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85492>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85493>>>>>>>                Case Break
85494>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85494>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85497>>>>>>>                Move sOrgTableName to sTableName
85498>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85499>>>>>>>                Case Break
85500>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85503>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85503>>>>>>>                Move sOrgTableName to sTableName
85504>>>>>>>                Get psDatabase to sDatabase
85505>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85506>>>>>>>                If (hTable = 0) Begin
85508>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85509>>>>>>>                    If (bOK = False) Begin
85511>>>>>>>                        Function_Return False
85512>>>>>>>                    End
85512>>>>>>>>
85512>>>>>>>                    Get NextFreeFilelistSlot to hTable
85513>>>>>>>                End
85513>>>>>>>>
85513>>>>>>>                Else Begin
85514>>>>>>>                    Open hTable
85516>>>>>>>                End
85516>>>>>>>>
85516>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85517>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85518>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85519>>>>>>>                Case Break
85520>>>>>>>            Case Else
85520>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85521>>>>>>>        Case End
85521>>>>>>>
85521>>>>>>>        Move False to Err
85522>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85523>>>>>>>        Move (Err = False) to bRetval
85524>>>>>>>        // We also need to remove the cache-file since the table has been changed
85524>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85525>>>>>>>
85525>>>>>>>        Function_Return bRetval
85526>>>>>>>    End_Function
85527>>>>>>>
85527>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85529>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85529>>>>>>>        Integer iNumCols iCount iDataType
85529>>>>>>>        String sValue
85529>>>>>>>
85529>>>>>>>        Get phoSQLManager to hoSQLHandler
85530>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85531>>>>>>>        If (hSQLConnect <> 0) Begin
85533>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85534>>>>>>>            If (hStmt <> 0) Begin
85536>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85537>>>>>>>
85537>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85538>>>>>>>                For iCount from 1 to iNumCols
85544>>>>>>>>
85544>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85545>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85547>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85548>>>>>>>                        Move iNumCols to iCount // We're out of here
85549>>>>>>>                    End
85549>>>>>>>>
85549>>>>>>>                Loop
85550>>>>>>>>
85550>>>>>>>
85550>>>>>>>                Send SQLClose of hStmt
85551>>>>>>>            End
85551>>>>>>>>
85551>>>>>>>            Send SQLDisconnect of hSQLConnect
85552>>>>>>>        End
85552>>>>>>>>
85552>>>>>>>
85552>>>>>>>        Function_Return iDataType
85553>>>>>>>    End_Function
85554>>>>>>>
85554>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85554>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85556>>>>>>>        Function_Return False
85557>>>>>>>    End_Function
85558>>>>>>>
85558>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85560>>>>>>>        String sMessage // sConnectionString
85560>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85560>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85560>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85563>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85563>>>>>>>        TimeSpan tsQuery tsFetch
85563>>>>>>>        tSqlErrorArray aSqlErrorArray
85563>>>>>>>        tSqlErrorArray aSqlErrorArray
85563>>>>>>>        Boolean bOK bShowProgress
85563>>>>>>>        tSQLConnection SQLConnection
85563>>>>>>>        tSQLConnection SQLConnection
85563>>>>>>>
85563>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85564>>>>>>>        If (bOK = False) Begin
85566>>>>>>>            Procedure_Return
85567>>>>>>>        End
85567>>>>>>>>
85567>>>>>>>
85567>>>>>>>        If (num_arguments > 2) Begin
85569>>>>>>>            Move bShowProgr to bShowProgress
85570>>>>>>>        End
85570>>>>>>>>
85570>>>>>>>
85570>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85571>>>>>>>        Get phoSQLManager to hoSqlHandler
85572>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85573>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85574>>>>>>>
85574>>>>>>>        If (hoSQLConnect <> 0) Begin
85576>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85577>>>>>>>            If (hoStmt <> 0) Begin
85579>>>>>>>                // record starting date/time stamp
85579>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85580>>>>>>>                // turn on error handling if enabled
85580>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85582>>>>>>>                    Set pbSqlError to False
85583>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85584>>>>>>>                    Move Error_Object_Id to hoError
85585>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85587>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85588>>>>>>>                    End
85588>>>>>>>>
85588>>>>>>>                    Else Begin
85589>>>>>>>                        Move Self to Error_Object_Id
85590>>>>>>>                    End
85590>>>>>>>>
85590>>>>>>>                End
85590>>>>>>>>
85590>>>>>>>
85590>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85590>>>>>>>                Set psSQLStatementString to sStmt
85591>>>>>>>                Send Cursor_Wait of Cursor_Control
85592>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85593>>>>>>>                Send Cursor_Ready of Cursor_Control
85594>>>>>>>
85594>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85596>>>>>>>                    Move hoError to Error_Object_Id
85597>>>>>>>                End
85597>>>>>>>>
85597>>>>>>>
85597>>>>>>>                Move 0 to iMsgs
85598>>>>>>>                Move Err to iErr
85599>>>>>>>                Move LastErr to iLastErr
85600>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85601>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85602>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85603>>>>>>>                Send _SqlColumnInfo hoStmt
85604>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85605>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85606>>>>>>>                Repeat
85606>>>>>>>>
85606>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85607>>>>>>>                    If (iFetchResult <> 0) Begin
85609>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85610>>>>>>>                    End
85610>>>>>>>>
85610>>>>>>>                Until (iFetchResult = 0)
85612>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85613>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85614>>>>>>>                Move iErr to Err
85615>>>>>>>                Move iLastErr to LastErr
85616>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85617>>>>>>>
85617>>>>>>>                Set piRows    to iRows
85618>>>>>>>                Set piRowType to iRowType
85619>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85620>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85621>>>>>>>
85621>>>>>>>                If (iMsgs <> 0) Begin
85623>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85625>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85626>>>>>>>                    End
85626>>>>>>>>
85626>>>>>>>                    For i from 1 to iMsgs
85632>>>>>>>>
85632>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85633>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85634>>>>>>>                        If (bShowProgress = True) Begin
85636>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85638>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85639>>>>>>>                            End
85639>>>>>>>>
85639>>>>>>>                            Else Begin
85640>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85642>>>>>>>                            End
85642>>>>>>>>
85642>>>>>>>                        End
85642>>>>>>>>
85642>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85643>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85644>>>>>>>                    Loop
85645>>>>>>>>
85645>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85647>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85648>>>>>>>                    End
85648>>>>>>>>
85648>>>>>>>                    Set paQueryMessages to sMsg
85649>>>>>>>                End
85649>>>>>>>>
85649>>>>>>>                Else Begin
85650>>>>>>>                    If (bShowProgress = True) Begin
85652>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85653>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85655>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85656>>>>>>>                            Decrement iMsgs
85657>>>>>>>                            For i from 0 to iMsgs
85663>>>>>>>>
85663>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85666>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85669>>>>>>>                            Loop
85670>>>>>>>>
85670>>>>>>>                        End
85670>>>>>>>>
85670>>>>>>>                    End
85670>>>>>>>>
85670>>>>>>>                End
85670>>>>>>>>
85670>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85671>>>>>>>            End
85671>>>>>>>>
85671>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85672>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85673>>>>>>>            Set ptsQueryExec to tsQuery
85674>>>>>>>            Set ptsFetchResults to tsFetch
85675>>>>>>>            Send SqlClose of hoStmt
85676>>>>>>>        End
85676>>>>>>>>
85676>>>>>>>
85676>>>>>>>        Send SqlDisconnect of hoSQLConnect
85677>>>>>>>    End_Procedure
85678>>>>>>>
85678>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85678>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85678>>>>>>>    // Returns False if no error occured.
85678>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85680>>>>>>>        Boolean bOK bShowProgress
85680>>>>>>>        tSQLScriptArray SQLScriptArray
85680>>>>>>>        tSQLScriptArray SQLScriptArray
85680>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85680>>>>>>>        TimeSpan tsTotalTime
85680>>>>>>>
85680>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85681>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85682>>>>>>>        If (SQLScriptArray.bError = True) Begin
85684>>>>>>>            Function_Return False
85685>>>>>>>        End
85685>>>>>>>>
85685>>>>>>>
85685>>>>>>>        If (num_arguments > 3) Begin
85687>>>>>>>            Move bShowProgr to bShowProgress
85688>>>>>>>        End
85688>>>>>>>>
85688>>>>>>>
85688>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85689>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85690>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85691>>>>>>>
85691>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85692>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85693>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85694>>>>>>>
85694>>>>>>>        Function_Return bOK
85695>>>>>>>    End_Function
85696>>>>>>>
85696>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85696>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85698>>>>>>>        Function_Return False
85699>>>>>>>    End_Function
85700>>>>>>>
85700>>>>>>>    // Does three things with auxilirary files;
85700>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85700>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85700>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85700>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85702>>>>>>>        String sDataPath sDDSrcPath sDriverID
85702>>>>>>>        Boolean bOK bExists
85702>>>>>>>        Integer iCount iCh iPos
85702>>>>>>>
85702>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85702>>>>>>>        If (sTableName contains ".") Begin
85704>>>>>>>            Move (Pos(".", sTableName)) to iPos
85705>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85706>>>>>>>        End
85706>>>>>>>>
85706>>>>>>>
85706>>>>>>>        Get psDriverID to sDriverID
85707>>>>>>>        Get psDataPathFirstPart to sDataPath
85708>>>>>>>        Get vFolderExists sDataPath to bOK
85709>>>>>>>        If (bOK = False) Begin
85711>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85712>>>>>>>>
85712>>>>>>>            Function_Return False
85713>>>>>>>        End
85713>>>>>>>>
85713>>>>>>>
85713>>>>>>>        // First delete the cache file:
85713>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85714>>>>>>>
85714>>>>>>>        Get Seq_New_Channel to iCh
85715>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85717>>>>>>>            Function_Return False
85718>>>>>>>        End
85718>>>>>>>>
85718>>>>>>>
85718>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85719>>>>>>>        If (bExists = False) Begin
85721>>>>>>>            Function_Return False
85722>>>>>>>        End
85722>>>>>>>>
85722>>>>>>>
85722>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85723>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85723>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85724>>>>>>>
85724>>>>>>>        // If in development environment; output new .fd file:
85724>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85725>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85726>>>>>>>        If (iCount > 1) Begin
85728>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85729>>>>>>>        End
85729>>>>>>>>
85729>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85730>>>>>>>        If (bExists = True) Begin
85732>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85733>>>>>>>            Move False to Err
85734>>>>>>>            Get AutoConnectionIDLogin to bOK
85735>>>>>>>            If (hTable <> 0) Begin
85737>>>>>>>                Open hTable
85739>>>>>>>            End
85739>>>>>>>>
85739>>>>>>>            Else Begin
85740>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85741>>>>>>>            End
85741>>>>>>>>
85741>>>>>>>
85741>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85744>>>>>>>            If (bOK = True) Begin
85746>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85748>>>>>>>            End
85748>>>>>>>>
85748>>>>>>>            If (Err = True) Begin
85750>>>>>>>                Move False to bOK
85751>>>>>>>            End
85751>>>>>>>>
85751>>>>>>>        End
85751>>>>>>>>
85751>>>>>>>
85751>>>>>>>        Function_Return (bOK = True)
85752>>>>>>>    End_Function
85753>>>>>>>
85753>>>>>>>    // Message for changing .int files to use connection ID's
85753>>>>>>>    //
85753>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85753>>>>>>>    // OR changes an existing connection id to a new id.
85753>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85753>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85753>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult Returns String[] 
85755>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85755>>>>>>>        String[] sFilesData asFileChanges
85757>>>>>>>        Boolean bOK bCancel bChange
85757>>>>>>>        Integer iSize iCount
85757>>>>>>>
85757>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85758>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85759>>>>>>>        If (iSize = 0) Begin
85761>>>>>>>            If (ghoStatusPanel <> 0) Begin
85763>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85765>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85766>>>>>>>                End
85766>>>>>>>>
85766>>>>>>>            End
85766>>>>>>>>
85766>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85767>>>>>>>            Function_Return 0
85768>>>>>>>        End
85768>>>>>>>>
85768>>>>>>>
85768>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85769>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85770>>>>>>>        Decrement iSize
85771>>>>>>>        For iCount from 0 to iSize
85777>>>>>>>>
85777>>>>>>>            Move sFilesData[iCount] to sFileName
85778>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85780>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85780>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) (CS_SERVER_NAME * CS_SERVER) (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bChange
85781>>>>>>>            If (bChange = True) Begin
85783>>>>>>>                Move sFileName to asFileChanges[SizeOfArray(asFileChanges)]
85784>>>>>>>            End
85784>>>>>>>>
85784>>>>>>>            If (ghoStatusPanel <> 0) Begin
85786>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85788>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85789>>>>>>>                    If (bCancel = True) Begin
85791>>>>>>>                        Send Deactivate of ghoStatusPanel
85792>>>>>>>                        Function_Return asFileChanges
85793>>>>>>>                        End
85793>>>>>>>>
85793>>>>>>>                    End
85793>>>>>>>>
85793>>>>>>>                End
85793>>>>>>>>
85793>>>>>>>            End
85793>>>>>>>>
85793>>>>>>>        Loop
85794>>>>>>>>
85794>>>>>>>
85794>>>>>>>         // ToDo: Not sure at all we want to do this automatically:
85794>>>>>>>//        Get psDriverID to sDriverID
85794>>>>>>>//         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85794>>>>>>>//        Move "" to sFileName
85794>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
85794>>>>>>>//            Move "MSSQLDrv.int" to sFileName
85794>>>>>>>//        End
85794>>>>>>>//        If (sDriverID = DB2_DRV_ID) Begin
85794>>>>>>>//            Move "DB2_Drv.int" to sFileName
85794>>>>>>>//        End
85794>>>>>>>//        If (sDriverID = ODBC_DRV_ID) Begin
85794>>>>>>>//            Move "ODBC_Drv.int" to sFileName
85794>>>>>>>//        End
85794>>>>>>>//        If (sFileName <> "") Begin
85794>>>>>>>//            Move "" to sDriverFile
85794>>>>>>>//            Get_File_Path sFileName to sDriverFile
85794>>>>>>>//            Get ParseFolderName sDriverFile to sPath
85794>>>>>>>//            If (sDataPath <> sPath) Begin
85794>>>>>>>//                Move "" to sDriverFile
85794>>>>>>>//            End
85794>>>>>>>//            If (sDriverFile <> "") Begin
85794>>>>>>>//                Get psConnectionString to sConnectionString
85794>>>>>>>//                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85794>>>>>>>//            End
85794>>>>>>>//        End     
85794>>>>>>>        
85794>>>>>>>        Function_Return asFileChanges
85795>>>>>>>    End_Function
85796>>>>>>>
85796>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85796>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85798>>>>>>>        String[] sDatabaseArray
85799>>>>>>>        String sVal sServer sDriverID
85799>>>>>>>        Integer iCount iSize iPos
85799>>>>>>>        Boolean bExists
85799>>>>>>>        tSQLConnection SQLConnection
85799>>>>>>>        tSQLConnection SQLConnection
85799>>>>>>>
85799>>>>>>>        Move False to bExists
85800>>>>>>>        Get psDriverID to sDriverID
85801>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85801>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85803>>>>>>>            Function_Return bExists
85804>>>>>>>        End
85804>>>>>>>>
85804>>>>>>>
85804>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85805>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85807>>>>>>>            Function_Return False
85808>>>>>>>        End
85808>>>>>>>>
85808>>>>>>>
85808>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85809>>>>>>>        Move SQLConnection.sServer to sServer
85810>>>>>>>
85810>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85810>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85812>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85813>>>>>>>        End
85813>>>>>>>>
85813>>>>>>>        Else If (sServer contains "/") Begin
85816>>>>>>>            Move (Pos("/", sServer)) to iPos
85817>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85818>>>>>>>        End
85818>>>>>>>>
85818>>>>>>>
85818>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85819>>>>>>>        Decrement iSize
85820>>>>>>>        For iCount from 0 to iSize
85826>>>>>>>>
85826>>>>>>>            Move sDatabaseArray[iCount] to sVal
85827>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85829>>>>>>>                Move True to bExists
85830>>>>>>>                If (bExists = True) Begin
85832>>>>>>>                    Move iSize to iCount // We're done.
85833>>>>>>>                End
85833>>>>>>>>
85833>>>>>>>            End
85833>>>>>>>>
85833>>>>>>>        Loop
85834>>>>>>>>
85834>>>>>>>
85834>>>>>>>        Function_Return bExists
85835>>>>>>>    End_Function
85836>>>>>>>
85836>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85836>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85838>>>>>>>        String sDatabase sSchema sTableName sVal
85838>>>>>>>        Boolean bExists
85838>>>>>>>        String[] sTablesArray
85839>>>>>>>        Integer iSize iCount
85839>>>>>>>
85839>>>>>>>        Move False to bExists
85840>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85841>>>>>>>        Get psDatabase to sDatabase
85842>>>>>>>        Get psSchema   to sSchema
85843>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85844>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85845>>>>>>>        Decrement iSize
85846>>>>>>>        For iCount from 0 to iSize
85852>>>>>>>>
85852>>>>>>>            Move sTablesArray[iCount] to sVal
85853>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85855>>>>>>>                Move True to bExists
85856>>>>>>>                Move iSize to iCount // We're done!
85857>>>>>>>            End
85857>>>>>>>>
85857>>>>>>>        Loop
85858>>>>>>>>
85858>>>>>>>
85858>>>>>>>        Function_Return bExists
85859>>>>>>>    End_Function
85860>>>>>>>
85860>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85862>>>>>>>        String sVal sTableSpelledCorrectly
85862>>>>>>>        Boolean bExists
85862>>>>>>>        String[] sTablesArray
85863>>>>>>>        Integer iSize iCount
85863>>>>>>>
85863>>>>>>>        Move False to bExists
85864>>>>>>>        Move sTableName to sTableSpelledCorrectly
85865>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85866>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85867>>>>>>>        Decrement iSize
85868>>>>>>>        For iCount from 0 to iSize
85874>>>>>>>>
85874>>>>>>>            Move sTablesArray[iCount] to sVal
85875>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85877>>>>>>>                Move sVal to sTableSpelledCorrectly
85878>>>>>>>                Move iSize to iCount // We're done!
85879>>>>>>>            End
85879>>>>>>>>
85879>>>>>>>        Loop
85880>>>>>>>>
85880>>>>>>>
85880>>>>>>>        Function_Return sTableSpelledCorrectly
85881>>>>>>>    End_Function
85882>>>>>>>
85882>>>>>>>    // ToDo: This index name function needs to be finished...
85882>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85884>>>>>>>        String sSchema sTableName sDriverID
85884>>>>>>>        Boolean bExists
85884>>>>>>>
85884>>>>>>>        Get psDriverID to sDriverID
85885>>>>>>>        Get psSchema to sSchema
85886>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85887>>>>>>>
85887>>>>>>>        Function_Return bExists
85888>>>>>>>    End_Function
85889>>>>>>>
85889>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85889>>>>>>>    // Returns True if it does
85889>>>>>>>    // Sample:
85889>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85889>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85891>>>>>>>        Integer iNumColumns iColumn
85891>>>>>>>        String sColumn sDriverID
85891>>>>>>>        String[] sColumnsArray
85892>>>>>>>        Boolean bExists bOK
85892>>>>>>>
85892>>>>>>>        Move False to bExists
85893>>>>>>>        Get AutoConnectionIDLogin to bOK
85894>>>>>>>        Get psDriverID to sDriverID
85895>>>>>>>
85895>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85896>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85897>>>>>>>        Decrement iNumColumns
85898>>>>>>>        For iColumn from 0 to iNumColumns
85904>>>>>>>>
85904>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85905>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85907>>>>>>>                Move True to bExists
85908>>>>>>>                Move iNumColumns to iColumn // We're out of here
85909>>>>>>>            End
85909>>>>>>>>
85909>>>>>>>        Loop
85910>>>>>>>>
85910>>>>>>>
85910>>>>>>>        Function_Return bExists
85911>>>>>>>    End_Function
85912>>>>>>>
85912>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85914>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85914>>>>>>>        Boolean bOpened bOK
85914>>>>>>>        String sColumnName sNativeTypeName
85914>>>>>>>
85914>>>>>>>        Get AutoConnectionIDLogin to bOK
85915>>>>>>>        Get OpenTableExclusive hTable to bOK
85916>>>>>>>        If (bOK = False) Begin
85918>>>>>>>            Function_Return False
85919>>>>>>>        End
85919>>>>>>>>
85919>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85922>>>>>>>        If (bOpened = False) Begin
85924>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85925>>>>>>>>
85925>>>>>>>            Function_Return False
85926>>>>>>>        End
85926>>>>>>>>
85926>>>>>>>
85926>>>>>>>        Move False to Err
85927>>>>>>>
85927>>>>>>>        Structure_Start hTable
85928>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85931>>>>>>>
85931>>>>>>>            For iColumn from 1 to iNumColumns
85937>>>>>>>>
85937>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85940>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85943>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85946>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85949>>>>>>>
85949>>>>>>>                Case Begin
85949>>>>>>>                    Case (iDFType = DF_DATE)
85951>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85953>>>>>>>                            // Convert datetime to date
85953>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85956>>>>>>>                        End
85956>>>>>>>>
85956>>>>>>>                        Case Break
85957>>>>>>>                    Case (iDFType = DF_DATETIME)
85960>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85962>>>>>>>                            // Convert datetime to datetime2
85962>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85965>>>>>>>                        End
85965>>>>>>>>
85965>>>>>>>                        Case Break
85966>>>>>>>                    Case (iDFType = DF_ASCII)
85969>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85971>>>>>>>                            // Convert char to varchar
85971>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85974>>>>>>>                        End
85974>>>>>>>>
85974>>>>>>>                        Case Break
85975>>>>>>>                    Case (iDFType = DF_TEXT)
85978>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85980>>>>>>>                            // Convert text to varchar(max)
85980>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85983>>>>>>>                        End
85983>>>>>>>>
85983>>>>>>>                        Case Break
85984>>>>>>>                    Case (iDFType = DF_BINARY)
85987>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85989>>>>>>>                            // Convert image to varbinary(max)
85989>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85992>>>>>>>                        End
85992>>>>>>>>
85992>>>>>>>                        Case Break
85993>>>>>>>                Case End
85993>>>>>>>            Loop
85994>>>>>>>>
85994>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85995>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85997>>>>>>>
85997>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85998>>>>>>>        Function_Return (Err = False)
85999>>>>>>>    End_Function
86000>>>>>>>
86000>>>>>>>
86000>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
86000>>>>>>>    // the DbUpdateVersion database revision in.
86000>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
86000>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
86000>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
86002>>>>>>>        Boolean bOK bOpened
86002>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
86002>>>>>>>
86002>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86005>>>>>>>        Get _TableNameOnly sTableName to sTableName
86006>>>>>>>        If (sTableName = "") Begin
86008>>>>>>>            Function_Return False
86009>>>>>>>        End
86009>>>>>>>>
86009>>>>>>>
86009>>>>>>>        // This just creates the table and a "dummy" column.
86009>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
86010>>>>>>>        If (bOK = False) Begin
86012>>>>>>>            Function_Return False
86013>>>>>>>        End
86013>>>>>>>>
86013>>>>>>>
86013>>>>>>>        Close hTable
86014>>>>>>>        Move False to Err
86015>>>>>>>
86015>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
86016>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
86017>>>>>>>        Move "Decimal" to sDataType
86018>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
86019>>>>>>>
86019>>>>>>>        // Adds the "sColumnName" passed to the function
86019>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
86020>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
86021>>>>>>>
86021>>>>>>>        // Now we can delete the dummy column:
86021>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
86022>>>>>>>
86022>>>>>>>        // Finally, we attach to the newly created table.
86022>>>>>>>        If (Err = False) Begin
86024>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
86025>>>>>>>        End
86025>>>>>>>>
86025>>>>>>>        Open hTable
86027>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86030>>>>>>>
86030>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
86031>>>>>>>    End_Function
86032>>>>>>>
86032>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
86032>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
86032>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
86032>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
86032>>>>>>>    // column types.
86032>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
86034>>>>>>>        Handle hDatabase
86034>>>>>>>        Integer iDriver iServers iCount
86034>>>>>>>        String sValue
86034>>>>>>>
86034>>>>>>>        If (sServer = "") Begin
86036>>>>>>>            Function_Return 0
86037>>>>>>>        End
86037>>>>>>>>
86037>>>>>>>
86037>>>>>>>        Get DriverIndex sDriverID to iDriver
86038>>>>>>>        If (iDriver = 0) Begin
86040>>>>>>>            Function_Return 0
86041>>>>>>>        End
86041>>>>>>>>
86041>>>>>>>
86041>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
86044>>>>>>>        For iCount from 1 to iServers
86050>>>>>>>>
86050>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
86053>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
86055>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
86058>>>>>>>            End
86058>>>>>>>>
86058>>>>>>>        Loop
86059>>>>>>>>
86059>>>>>>>
86059>>>>>>>        Function_Return hDatabase
86060>>>>>>>    End_Function
86061>>>>>>>
86061>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
86061>>>>>>>//        String sRootName
86061>>>>>>>//        Boolean bOK
86061>>>>>>>//
86061>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86061>>>>>>>//        Move (sRootName contains sDriverID) to bOK
86061>>>>>>>//
86061>>>>>>>//        Function_Return bOK
86061>>>>>>>//    End_Function
86061>>>>>>>
86061>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
86061>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
86061>>>>>>>//        Integer iDbType
86061>>>>>>>//        Boolean bOK
86061>>>>>>>//
86061>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
86061>>>>>>>//        If (bOK = True) Begin
86061>>>>>>>//            Function_Return False
86061>>>>>>>//        End
86061>>>>>>>//
86061>>>>>>>//        Get psDriverID to sDriverID
86061>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86061>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
86061>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86061>>>>>>>//
86061>>>>>>>//        Get psDriverID to sDriverID
86061>>>>>>>//        Get piDbType   to iDbType
86061>>>>>>>//        Get psSchema   to sSchema
86061>>>>>>>//        If (sSchema = "") Begin
86061>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86061>>>>>>>//        End
86061>>>>>>>//
86061>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
86061>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
86061>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
86061>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86061>>>>>>>//            End
86061>>>>>>>//            Else Begin
86061>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86061>>>>>>>//            End
86061>>>>>>>//        End
86061>>>>>>>//
86061>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86061>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86061>>>>>>>//
86061>>>>>>>//        Function_Return True
86061>>>>>>>//    End_Function
86061>>>>>>>
86061>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
86061>>>>>>>    // from the passed filelist.
86061>>>>>>>    // Returns the number of tables affected.
86061>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
86063>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
86063>>>>>>>        Integer iRetval
86063>>>>>>>        Handle hTable
86063>>>>>>>
86063>>>>>>>        // We first save the current filelist as the passed filelist name
86063>>>>>>>        // may come from another workspace, to restore it when we're ready.
86063>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
86066>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
86069>>>>>>>        Move 0 to hTable
86070>>>>>>>        Move 0 to iRetval
86071>>>>>>>
86071>>>>>>>        Repeat
86071>>>>>>>>
86071>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86074>>>>>>>            If (hTable <> 0) Begin
86076>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86079>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86082>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86085>>>>>>>                Move (Uppercase(sRootName)) to sVal
86086>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
86088>>>>>>>                    // Prefixes:
86088>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
86089>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
86090>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
86091>>>>>>>                    // Suffixes:
86091>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
86092>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
86093>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
86094>>>>>>>
86094>>>>>>>                    // Change Filelist entry:
86094>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
86097>>>>>>>
86097>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
86098>>>>>>>                    If (sVal contains "dbo.") Begin
86100>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
86101>>>>>>>
86101>>>>>>>                        // Change Filelist entry:
86101>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
86104>>>>>>>                    End
86104>>>>>>>>
86104>>>>>>>                    Increment iRetval
86105>>>>>>>                End
86105>>>>>>>>
86105>>>>>>>            End
86105>>>>>>>>
86105>>>>>>>        Until (hTable = 0)
86107>>>>>>>
86107>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
86110>>>>>>>
86110>>>>>>>        Function_Return iRetval
86111>>>>>>>    End_Function
86112>>>>>>>
86112>>>>>>>    // To open all Sql based tables in Filelist.cfg
86112>>>>>>>    Procedure SqlUtilOpenAllTables
86114>>>>>>>        Handle hTable
86114>>>>>>>        String sRoot sDriverID
86114>>>>>>>        Boolean bOK
86114>>>>>>>
86114>>>>>>>        Move 0 to hTable
86115>>>>>>>        Move "" to sDriverID
86116>>>>>>>        Get AutoConnectionIDLogin to bOK
86117>>>>>>>
86117>>>>>>>        Repeat
86117>>>>>>>>
86117>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86120>>>>>>>            If (hTable > 0) Begin
86122>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86125>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86127>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86130>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86132>>>>>>>                        Open hTable
86134>>>>>>>                    End
86134>>>>>>>>
86134>>>>>>>                End
86134>>>>>>>>
86134>>>>>>>            End
86134>>>>>>>>
86134>>>>>>>
86134>>>>>>>        Until (hTable = 0)
86136>>>>>>>    End_Procedure
86137>>>>>>>
86137>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86137>>>>>>>//        String sRetval sDriverID
86137>>>>>>>//        String sTableName
86137>>>>>>>//        Integer iDbType iIndex
86137>>>>>>>//        Boolean bOK
86137>>>>>>>//
86137>>>>>>>//        Get psDriverID to sDriverID
86137>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86137>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86137>>>>>>>//            Function_Return ""
86137>>>>>>>//        End
86137>>>>>>>//
86137>>>>>>>//        Move False to Err
86137>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86137>>>>>>>//        Get piDbType to iDbType
86137>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86137>>>>>>>//        If (iIndex = -1) Begin
86137>>>>>>>//            Function_Return ""
86137>>>>>>>//        End
86137>>>>>>>//
86137>>>>>>>//        Function_Return sRetval
86137>>>>>>>//    End_Function
86137>>>>>>>
86137>>>>>>>    // Checks if the passed Table;
86137>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86137>>>>>>>    // 2) It has an .int file.
86137>>>>>>>    // If both is True it should already be connected to SQL
86137>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86139>>>>>>>        Boolean bExists bRootName
86139>>>>>>>        String sRootName sDataPath
86139>>>>>>>
86139>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86142>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86143>>>>>>>
86143>>>>>>>        Get psDataPathFirstPart to sDataPath
86144>>>>>>>        Get vFolderExists sDataPath to bExists
86145>>>>>>>        If (bExists = False) Begin
86147>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86147>>>>>>>            Function_Return False
86148>>>>>>>        End
86148>>>>>>>>
86148>>>>>>>
86148>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86149>>>>>>>        Get _TableNameOnly sRootName to sRootName
86150>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86151>>>>>>>
86151>>>>>>>        Function_Return (bRootName = True and bExists = True)
86152>>>>>>>    End_Function
86153>>>>>>>
86153>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86155>>>>>>>        Boolean bViewTableType bOpen bOK
86155>>>>>>>        Integer iTableCount iNumTables
86155>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86155>>>>>>>        Handle hoCliHandler
86155>>>>>>>        tSQLConnection SQLConnection
86155>>>>>>>        tSQLConnection SQLConnection
86155>>>>>>>
86155>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86158>>>>>>>        If (bOpen = False) Begin
86160>>>>>>>            Get AutoConnectionIDLogin to bOK
86161>>>>>>>            Open hTable
86163>>>>>>>        End
86163>>>>>>>>
86163>>>>>>>
86163>>>>>>>        Get pSQLConnection to SQLConnection
86164>>>>>>>        Get phoCLIHandler to hoCliHandler
86165>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86166>>>>>>>
86166>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86169>>>>>>>        Get _TableNameOnly sTableName to sTableName
86170>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86173>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86174>>>>>>>
86174>>>>>>>        For iTableCount from 1 to iNumTables
86180>>>>>>>>
86180>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86181>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86182>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86184>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86185>>>>>>>                Move iNumTables to iTableCount // We're done.
86186>>>>>>>            End
86186>>>>>>>>
86186>>>>>>>        Loop
86187>>>>>>>>
86187>>>>>>>
86187>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86188>>>>>>>        If (bOpen = False) Begin
86190>>>>>>>            Close hTable
86191>>>>>>>        End
86191>>>>>>>>
86191>>>>>>>
86191>>>>>>>        Function_Return bViewTableType
86192>>>>>>>    End_Function
86193>>>>>>>
86193>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86193>>>>>>>    //
86193>>>>>>>    // SQL utility function that returns a database type (string) constant
86193>>>>>>>    // corresponding to the passed iDbType.
86193>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86195>>>>>>>        String sRetval
86195>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86196>>>>>>>        Function_Return sRetval
86197>>>>>>>    End_Function
86198>>>>>>>
86198>>>>>>>    // SQL utility function that returns a database type constant (integer)
86198>>>>>>>    // corresponding to the passed sDbType string constant.
86198>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86200>>>>>>>        Integer iRetval
86200>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86201>>>>>>>        Function_Return iRetval
86202>>>>>>>    End_Function
86203>>>>>>>
86203>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86203>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86203>>>>>>>    // the SQL Connection program's grid.
86203>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86205>>>>>>>        String sRetval
86205>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86206>>>>>>>        Function_Return sRetval
86207>>>>>>>    End_Function
86208>>>>>>>
86208>>>>>>>    // Pass a driver name as a string and the function will return
86208>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86208>>>>>>>    // quite work and always returns "MS SQL Server"
86208>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86210>>>>>>>        Integer iRetval
86210>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86211>>>>>>>        Function_Return iRetval
86212>>>>>>>    End_Function
86213>>>>>>>
86213>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86213>>>>>>>    // that "fits" in the max allowed length for table names.
86213>>>>>>>    // Max number of characters allowed for table names;
86213>>>>>>>    // IBM DB2      = 128
86213>>>>>>>    // MS-SQL       = 128
86213>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86213>>>>>>>    // MySQL        = 64
86213>>>>>>>    // PostgreSQL   = 64
86213>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86215>>>>>>>        String sGUIDName
86215>>>>>>>        Integer iDbType iLength
86215>>>>>>>
86215>>>>>>>        Get piDbType to iDbType
86216>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86217>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86218>>>>>>>        Move (Length(sGUIDName)) to iLength
86219>>>>>>>
86219>>>>>>>        Case Begin
86219>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86221>>>>>>>            If (iLength > 128) Begin
86223>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86224>>>>>>>            End
86224>>>>>>>>
86224>>>>>>>            Case Break
86225>>>>>>>
86225>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86228>>>>>>>            If (iLength > 128) Begin
86230>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86231>>>>>>>            End
86231>>>>>>>>
86231>>>>>>>            Case Break
86232>>>>>>>
86232>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86235>>>>>>>            If (iLength > 128) Begin
86237>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86238>>>>>>>            End
86238>>>>>>>>
86238>>>>>>>            Case Break
86239>>>>>>>
86239>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86242>>>>>>>            If (iLength > 64) Begin
86244>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86245>>>>>>>            End
86245>>>>>>>>
86245>>>>>>>            Case Break
86246>>>>>>>
86246>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86249>>>>>>>            If (iLength > 64) Begin
86251>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86252>>>>>>>            End
86252>>>>>>>>
86252>>>>>>>        Case End
86252>>>>>>>
86252>>>>>>>        Function_Return sGUIDName
86253>>>>>>>    End_Function
86254>>>>>>>
86254>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86254>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86254>>>>>>>    // including full path.
86254>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86256>>>>>>>        String sText
86256>>>>>>>        Integer iCh iSize iArgSize
86256>>>>>>>
86256>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86257>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86258>>>>>>>        Get_Channel_Size iCh to iSize
86259>>>>>>>        Read_Block channel iCh sText iSize
86261>>>>>>>        Send Seq_Close_Channel iCh
86262>>>>>>>
86262>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86263>>>>>>>            Write channel iCh sText
86265>>>>>>>        Send Seq_Close_Channel iCh
86266>>>>>>>
86266>>>>>>>        // Wait for file to be written to disk.
86266>>>>>>>        Sleep 2
86267>>>>>>>    End_Procedure
86268>>>>>>>
86268>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86270>>>>>>>        String sNotNull sRetval sDefaultValue
86270>>>>>>>        Boolean bOK
86270>>>>>>>
86270>>>>>>>        Get IsSQLDriver sDriverID to bOK
86271>>>>>>>        If (bOK = False) Begin
86273>>>>>>>            Function_Return ""
86274>>>>>>>        End
86274>>>>>>>>
86274>>>>>>>
86274>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86275>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86276>>>>>>>
86276>>>>>>>        Case Begin
86276>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86278>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86279>>>>>>>                Case Break
86280>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86283>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86284>>>>>>>                Case Break
86285>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86288>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86289>>>>>>>                Case Break
86290>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86293>>>>>>>                Move (String(sNotNull))                                     to sRetval
86294>>>>>>>                Case Break
86295>>>>>>>
86295>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86295>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86295>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86298>>>>>>>                Move  ""                                                    to sRetval
86299>>>>>>>                Case Break
86300>>>>>>>
86300>>>>>>>            Case Else
86300>>>>>>>                Move  ""                                                    to sRetval
86301>>>>>>>        Case End
86301>>>>>>>
86301>>>>>>>        Function_Return sRetval
86302>>>>>>>    End_Function
86303>>>>>>>
86303>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86303>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86305>>>>>>>        Function_Return False
86306>>>>>>>    End_Function
86307>>>>>>>
86307>>>>>>>    // Enumerate SQL Servers.
86307>>>>>>>    // Pass a driver id. Returns a string array.
86307>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86307>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86307>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86309>>>>>>>        String[] sReturnArray
86310>>>>>>>        Handle hoSQLHandler
86310>>>>>>>        String sServer
86310>>>>>>>        Integer iCount iNumItems iDataSourceType
86310>>>>>>>
86310>>>>>>>        If (num_arguments > 1) Begin
86312>>>>>>>            Move iDatSrcType to iDataSourceType
86313>>>>>>>        End
86313>>>>>>>>
86313>>>>>>>
86313>>>>>>>        Case Begin
86313>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86315>>>>>>>                Get phoMSSQLHandler to hoSQLHandler 
86316>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
86317>>>>>>>                If (iNumItems = 0) Begin
86319>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
86320>>>>>>>                End
86320>>>>>>>>
86320>>>>>>>                For iCount from 0 to (iNumItems - 1)
86326>>>>>>>>
86326>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86327>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86328>>>>>>>                Loop
86329>>>>>>>>
86329>>>>>>>                Case Break
86330>>>>>>>
86330>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86333>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86334>>>>>>>                Send SeedDataSources of hoSQLHandler
86335>>>>>>>                Move 0 to iCount
86336>>>>>>>                Repeat
86336>>>>>>>>
86336>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86337>>>>>>>                    If (sServer <> "") Begin
86339>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86340>>>>>>>                        Move sServer to sReturnArray[iCount]
86341>>>>>>>                    End
86341>>>>>>>>
86341>>>>>>>                    Increment iCount
86342>>>>>>>                Until (sServer = "")
86344>>>>>>>                Case Break
86345>>>>>>>
86345>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86348>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86349>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86350>>>>>>>                Move 0 to iCount
86351>>>>>>>                Repeat
86351>>>>>>>>
86351>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86352>>>>>>>                    If (sServer <> "") Begin
86354>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86355>>>>>>>                        Move sServer to sReturnArray[iCount]
86356>>>>>>>                    End
86356>>>>>>>>
86356>>>>>>>                    Increment iCount
86357>>>>>>>                Until (sServer = "")
86359>>>>>>>                Case Break
86360>>>>>>>
86360>>>>>>>            Case Else
86360>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86361>>>>>>>>
86361>>>>>>>        Case End
86361>>>>>>>
86361>>>>>>>        Function_Return sReturnArray
86362>>>>>>>    End_Function
86363>>>>>>>
86363>>>>>>>    // Returns all databases as a string array for the passed driver id.
86363>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86365>>>>>>>        String[] sReturnArray
86366>>>>>>>        String sServer sVal
86366>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86366>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86367>>>>>>>        tSQLConnection SQLConnection
86367>>>>>>>        tSQLConnection SQLConnection
86367>>>>>>>        Boolean bOK
86367>>>>>>>        Integer iCount iSize
86367>>>>>>>
86367>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86368>>>>>>>        If (bOK = False) Begin
86370>>>>>>>            Function_Return sReturnArray
86371>>>>>>>        End
86371>>>>>>>>
86371>>>>>>>
86371>>>>>>>        Case Begin
86371>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86373>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86374>>>>>>>                Case Break
86375>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86378>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86379>>>>>>>                Case Break
86380>>>>>>>
86380>>>>>>>            // This is needed to be able to check if a database exists or not.
86380>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86383>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86384>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86386>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86388>>>>>>>                        // If a FILEDSN: (can only be one database name)
86388>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86389>>>>>>>                    End
86389>>>>>>>>
86389>>>>>>>                    Else Begin
86390>>>>>>>                        // Else the DSN's were read from the registry.
86390>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86391>>>>>>>                        Move SQLConnection.sServer to sServer
86392>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86393>>>>>>>                        Decrement iSize
86394>>>>>>>                        for iCount from 0 to iSize
86400>>>>>>>>
86400>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86401>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86403>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86404>>>>>>>                                Move iSize to iCount // We're done.
86405>>>>>>>                            End
86405>>>>>>>>
86405>>>>>>>                        Loop
86406>>>>>>>>
86406>>>>>>>                    End
86406>>>>>>>>
86406>>>>>>>                End
86406>>>>>>>>
86406>>>>>>>                Case Break
86407>>>>>>>
86407>>>>>>>            Case Else
86407>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86407>>>>>>>        Case End
86407>>>>>>>
86407>>>>>>>        Function_Return sReturnArray
86408>>>>>>>    End_Function
86409>>>>>>>
86409>>>>>>>    
86409>>>>>>>    // *** Database API Functions: ***
86409>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86409>>>>>>>    // make changes/updates to the database.
86409>>>>>>>
86409>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86409>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86411>>>>>>>        Function_Return False
86412>>>>>>>    End_Function
86413>>>>>>>
86413>>>>>>>    // This might not do what you think - Here's what it does:
86413>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86413>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86413>>>>>>>    // to the SQL table.
86413>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86413>>>>>>>    // already exists in SQL.
86413>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86413>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86413>>>>>>>    // restructuring an existing table.
86413>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86415>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86415>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86415>>>>>>>        Handle hToTable
86415>>>>>>>
86415>>>>>>>        Move True to bUseConnectionID
86416>>>>>>>        If (num_arguments > 1) Begin
86418>>>>>>>            Move bUseConnID to bUseConnectionID
86419>>>>>>>        End
86419>>>>>>>>
86419>>>>>>>
86419>>>>>>>        Get psDriverID to sDriverID
86420>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86420>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86421>>>>>>>        If (bExists = False) Begin
86423>>>>>>>            Function_Return False
86424>>>>>>>        End
86424>>>>>>>>
86424>>>>>>>
86424>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86425>>>>>>>
86425>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86426>>>>>>>        If (bOK = False) Begin
86428>>>>>>>            Function_Return False
86429>>>>>>>        End
86429>>>>>>>>
86429>>>>>>>
86429>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86429>>>>>>>        // we do nothing
86429>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86430>>>>>>>        If (bExists = True) Begin
86432>>>>>>>            Function_Return False
86433>>>>>>>        End
86433>>>>>>>>
86433>>>>>>>
86433>>>>>>>        Get psConnectionID     to sConnectionID
86434>>>>>>>        Get psConnectionString to sConnectionString
86435>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86437>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86438>>>>>>>>
86438>>>>>>>            Function_Return False
86439>>>>>>>        End
86439>>>>>>>>
86439>>>>>>>
86439>>>>>>>        Set Private.phCurrentTable to hTable
86440>>>>>>>        Get psSchema to sSchema
86441>>>>>>>        If (sSchema = "") Begin
86443>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86444>>>>>>>        End
86444>>>>>>>>
86444>>>>>>>
86444>>>>>>>        // If we should use a connection id we need to check it exists;
86444>>>>>>>        // else we create it before attempting creating the table
86444>>>>>>>        If (bUseConnectionID = True) Begin
86446>>>>>>>            Get AutoConnectionIDLogin to bOK
86447>>>>>>>            If (bOk = False) Begin
86449>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86450>>>>>>>>
86450>>>>>>>                Function_Return False
86451>>>>>>>            End
86451>>>>>>>>
86451>>>>>>>        End
86451>>>>>>>>
86451>>>>>>>
86451>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86454>>>>>>>        Get _TableNameOnly sRootName to sRootName
86455>>>>>>>        If (sRootName = "") Begin
86457>>>>>>>            Function_Return False
86458>>>>>>>        End
86458>>>>>>>>
86458>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86459>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86462>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86465>>>>>>>
86465>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86465>>>>>>>        //
86465>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86465>>>>>>>        // because then the table should not be visible to users.
86465>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86465>>>>>>>//        If (iPos <> 1) Begin
86465>>>>>>>//            If (sDisplayName contains ".") Begin
86465>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86465>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86465>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86465>>>>>>>//            End
86465>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86465>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86465>>>>>>>//            End
86465>>>>>>>//        End
86465>>>>>>>
86465>>>>>>>        If (bIsAlias = False) Begin
86467>>>>>>>            Get OpenTableExclusive hTable to bOpened
86468>>>>>>>            If (bOpened = False) Begin
86470>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86471>>>>>>>>
86471>>>>>>>                Function_Return False
86472>>>>>>>            End
86472>>>>>>>>
86472>>>>>>>        End
86472>>>>>>>>
86472>>>>>>>
86472>>>>>>>        If (ghoProgressBar <> 0) Begin
86474>>>>>>>            Send DoAdvance of ghoProgressBar
86475>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86476>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86477>>>>>>>        End
86477>>>>>>>>
86477>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86477>>>>>>>        Move hTable to hToTable
86478>>>>>>>        Move False to Err
86479>>>>>>>
86479>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86479>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86479>>>>>>>        // a proper and updated .int file.
86479>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86482>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86483>>>>>>>
86483>>>>>>>        If (bIsAlias = False) Begin
86485>>>>>>>            Structure_Start hToTable sDriverID
86486>>>>>>>                Set Private.phCurrentTable to hTable
86487>>>>>>>                If (bUseConnectionID = True) Begin
86489>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86492>>>>>>>                End
86492>>>>>>>>
86492>>>>>>>                Else Begin
86493>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86496>>>>>>>                End
86496>>>>>>>>
86496>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86499>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86499>>>>>>>                Move False to Err
86500>>>>>>>                Move 0 to LastErr
86501>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86502>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86504>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86505>>>>>>>        End
86505>>>>>>>>
86505>>>>>>>
86505>>>>>>>        Move (not(Err)) to bOK
86506>>>>>>>        If (bOK = True) Begin
86508>>>>>>>            // The attributes set above will always trigger an error
86508>>>>>>>            // We also adjust the Filelist entries
86508>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86511>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86514>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86517>>>>>>>
86517>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86517>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86518>>>>>>>        End
86518>>>>>>>>
86518>>>>>>>
86518>>>>>>>        Function_Return (bOK = True)
86519>>>>>>>    End_Function
86520>>>>>>>
86520>>>>>>>    // Sample usage:
86520>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86520>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86520>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86522>>>>>>>        Boolean bOK bIsSQLTable
86522>>>>>>>
86522>>>>>>>        Get AutoConnectionIDLogin to bOK
86523>>>>>>>        Move False to Err
86524>>>>>>>        Get OpenTableExclusive hTable to bOK
86525>>>>>>>        If (bOK = False) Begin
86527>>>>>>>            Function_Return False
86528>>>>>>>        End
86528>>>>>>>>
86528>>>>>>>
86528>>>>>>>        // ToDo: Add to all table change functions!
86528>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86529>>>>>>>            If (bIsSQLTable = True) Begin
86531>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86534>>>>>>>            End
86534>>>>>>>>
86534>>>>>>>
86534>>>>>>>        Set Private.phCurrentTable to hTable
86535>>>>>>>        Structure_Start hTable
86536>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86539>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86540>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86542>>>>>>>
86542>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86543>>>>>>>        Function_Return (Err = False)
86544>>>>>>>    End_Function
86545>>>>>>>
86545>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86547>>>>>>>        Boolean bOK
86547>>>>>>>        
86547>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86548>>>>>>>        If (bOK = True) Begin
86550>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86551>>>>>>>        End
86551>>>>>>>>
86551>>>>>>>        
86551>>>>>>>        Function_Return (bOK = True)
86552>>>>>>>    End_Function
86553>>>>>>>    
86553>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86553>>>>>>>    // or to change the filelist slot names.
86553>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86555>>>>>>>        String sFileListName
86555>>>>>>>        
86555>>>>>>>        Move False to Err
86556>>>>>>>
86556>>>>>>>        If (ghoProgressBar <> 0) Begin
86558>>>>>>>            Send DoAdvance of ghoProgressBar
86559>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86560>>>>>>>        End
86560>>>>>>>>
86560>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86560>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86562>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86565>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86568>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86571>>>>>>>            Function_Return (Err = False) // And we're done.
86572>>>>>>>        End
86572>>>>>>>>
86572>>>>>>>
86572>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86574>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86574>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86575>>>>>>>        End
86575>>>>>>>>
86575>>>>>>>//        Else Begin
86575>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86575>>>>>>>//        End
86575>>>>>>>//
86575>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86575>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86575>>>>>>>
86575>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86578>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86581>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86584>>>>>>>        
86584>>>>>>>        Function_Return (Err = False)
86585>>>>>>>    End_Function
86586>>>>>>>
86586>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86588>>>>>>>        Boolean bOK
86588>>>>>>>
86588>>>>>>>        Get AutoConnectionIDLogin to bOK
86589>>>>>>>        Move False to Err
86590>>>>>>>        Get OpenTableExclusive hTable to bOK
86591>>>>>>>        If (bOK = False) Begin
86593>>>>>>>            Function_Return False
86594>>>>>>>        End
86594>>>>>>>>
86594>>>>>>>
86594>>>>>>>        Set Private.phCurrentTable to hTable
86595>>>>>>>        Structure_Start hTable
86596>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86599>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86600>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86602>>>>>>>
86602>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86603>>>>>>>        Function_Return (Err = False)
86604>>>>>>>    End_Function
86605>>>>>>>
86605>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86607>>>>>>>        Boolean bOK bIsSQLTable
86607>>>>>>>
86607>>>>>>>        Move False to Err
86608>>>>>>>        Get AutoConnectionIDLogin to bOK
86609>>>>>>>        Open hToTable
86611>>>>>>>        Get OpenTableExclusive hTable to bOK
86612>>>>>>>        If (bOK = False) Begin
86614>>>>>>>            Function_Return False
86615>>>>>>>        End
86615>>>>>>>>
86615>>>>>>>
86615>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86616>>>>>>>            If (bIsSQLTable = True) Begin
86618>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86621>>>>>>>            End
86621>>>>>>>>
86621>>>>>>>
86621>>>>>>>        Set Private.phCurrentTable to hTable
86622>>>>>>>        Structure_Start hTable
86623>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86626>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86629>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86630>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86632>>>>>>>
86632>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86633>>>>>>>        Function_Return (Err = False)
86634>>>>>>>    End_Function
86635>>>>>>>
86635>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86637>>>>>>>        Integer[] aTableConvertExceptions
86638>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86639>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86640>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86641>>>>>>>    End_Procedure
86642>>>>>>>
86642>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86644>>>>>>>        Integer[] aTableDateCorrectionExceptions
86645>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86646>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86647>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86648>>>>>>>    End_Procedure
86649>>>>>>>
86649>>>>>>>    Procedure ApiTableConvertALLToSql
86651>>>>>>>        Integer[] iTablesArray
86652>>>>>>>        Integer iSize iCount
86652>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86652>>>>>>>        String sDriverID
86652>>>>>>>
86652>>>>>>>        Get psDriverID to sDriverID
86653>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86654>>>>>>>        Get pbToANSI          to bToANSI
86655>>>>>>>        Get pbRecnum          to bRecnum
86656>>>>>>>        Get pbCopyData        to bCopyData
86657>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86659>>>>>>>            Get pbContinueOnError to bContinueOnError
86660>>>>>>>        End
86660>>>>>>>>
86660>>>>>>>
86660>>>>>>>        Get _AllTablesToConvert to iTablesArray
86661>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86662>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86663>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86664>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86665>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86666>>>>>>>
86666>>>>>>>        Decrement iSize
86667>>>>>>>        For iCount from 0 to iSize
86673>>>>>>>>
86673>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86674>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86675>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86675>>>>>>>            // if there was an error converting one table...
86675>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86675>>>>>>>        Loop
86676>>>>>>>>
86676>>>>>>>
86676>>>>>>>    End_Procedure
86677>>>>>>>
86677>>>>>>>    Procedure ApiTableAttachALLToSql
86679>>>>>>>        Integer[] iTablesArray
86680>>>>>>>        Integer iSize iCount
86680>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86680>>>>>>>        String sDriverID
86680>>>>>>>
86680>>>>>>>        Get psDriverID to sDriverID
86681>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86682>>>>>>>        Get pbToANSI          to bToANSI
86683>>>>>>>        Get pbRecnum          to bRecnum
86684>>>>>>>        Get pbCopyData        to bCopyData
86685>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86687>>>>>>>            Get pbContinueOnError to bContinueOnError
86688>>>>>>>        End
86688>>>>>>>>
86688>>>>>>>
86688>>>>>>>        Get _AllTablesToConvert to iTablesArray
86689>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86690>>>>>>>        Decrement iSize
86691>>>>>>>        For iCount from 0 to iSize
86697>>>>>>>>
86697>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86698>>>>>>>        Loop
86699>>>>>>>>
86699>>>>>>>
86699>>>>>>>    End_Procedure
86700>>>>>>>
86700>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86702>>>>>>>        Handle hToTable hoLogFile
86702>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86702>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86702>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86702>>>>>>>        tSQLConnection SQLConnection
86702>>>>>>>        tSQLConnection SQLConnection
86702>>>>>>>        // ToDo: Redo logic. Instead create the new table!
86702>>>>>>>        Get _UtilTableExists hTable to bExists
86703>>>>>>>        If (bExists = False) Begin
86705>>>>>>>            Set Private.phCurrentTable to hTable
86706>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86707>>>>>>>>
86707>>>>>>>            Function_Return False
86708>>>>>>>        End
86708>>>>>>>>
86708>>>>>>>
86708>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86709>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86709>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86709>>>>>>>        If (bIsAlias = True) Begin
86711>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86714>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86716>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86719>>>>>>>                Get psConnectionID to sConnectionID
86720>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86721>>>>>>>            End
86721>>>>>>>>
86721>>>>>>>            Function_Return True
86722>>>>>>>        End
86722>>>>>>>>
86722>>>>>>>
86722>>>>>>>        Set Private.phCurrentTable to hTable
86723>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86726>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86729>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86732>>>>>>>
86732>>>>>>>        If (ghoProgressBar <> 0) Begin
86734>>>>>>>            Send DoAdvance of ghoProgressBar
86735>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86736>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86737>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86738>>>>>>>        End
86738>>>>>>>>
86738>>>>>>>
86738>>>>>>>        // Marco Kuipers suggestion;
86738>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86738>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86738>>>>>>>        // SQL table.
86738>>>>>>>        Get _UtilTableIsSql hTable to bOK
86739>>>>>>>        If (bOK = False) Begin
86741>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86742>>>>>>>            If (bExists = True) Begin
86744>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86744>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86744>>>>>>>                Get phoLogFile to hoLogFile
86745>>>>>>>                If (hoLogFile <> 0) Begin          
86747>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86748>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86748>>>>>>>                    Send LogError sWarning False
86749>>>>>>>                End
86749>>>>>>>>
86749>>>>>>>                Else Begin
86750>>>>>>>                    Error DFERR_PROGRAM sWarning
86751>>>>>>>>
86751>>>>>>>                End                                                       
86751>>>>>>>>
86751>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86752>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86753>>>>>>>            End
86753>>>>>>>>
86753>>>>>>>        End
86753>>>>>>>>
86753>>>>>>>
86753>>>>>>>        // Does the rootname contain a driver?
86753>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86755>>>>>>>            // Does the table already exist as an SQL table?
86755>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86756>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86756>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86756>>>>>>>            If (bExists = False) Begin
86758>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86759>>>>>>>            End
86759>>>>>>>>
86759>>>>>>>            If (bExists = True) Begin
86761>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86762>>>>>>>                Function_Return False
86763>>>>>>>            End
86763>>>>>>>>
86763>>>>>>>        End
86763>>>>>>>>
86763>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86764>>>>>>>
86764>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86765>>>>>>>        If (bUseConnectionID = True) Begin
86767>>>>>>>            Move False to bUseConnectionID
86768>>>>>>>        End
86768>>>>>>>>
86768>>>>>>>
86768>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86769>>>>>>>        Move SQLConnection.sSchema           to sSchema
86770>>>>>>>        If (sSchema = "") Begin
86772>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86773>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86774>>>>>>>        End
86774>>>>>>>>
86774>>>>>>>
86774>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86775>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86776>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86777>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86779>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86780>>>>>>>>
86780>>>>>>>            Function_Return False
86781>>>>>>>        End
86781>>>>>>>>
86781>>>>>>>
86781>>>>>>>        Get AutoConnectionIDLogin to bOK
86782>>>>>>>        Open hTable
86784>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86787>>>>>>>        If (bOpened = False) Begin
86789>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86790>>>>>>>>
86790>>>>>>>            Function_Return False
86791>>>>>>>        End
86791>>>>>>>>
86791>>>>>>>
86791>>>>>>>        If (ghoProgressBar <> 0) Begin
86793>>>>>>>            Send DoAdvance of ghoProgressBar
86794>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86795>>>>>>>        End
86795>>>>>>>>
86795>>>>>>>
86795>>>>>>>        Move 0 to hToTable
86796>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86797>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86798>>>>>>>
86798>>>>>>>        Case Begin
86798>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86800>>>>>>>                Case Break
86801>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86804>>>>>>>                Case Break
86805>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86808>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86809>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86810>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86811>>>>>>>                Case Break
86812>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86815>>>>>>>                Case Break
86816>>>>>>>            Case Else
86816>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86817>>>>>>>>
86817>>>>>>>                Case Break
86818>>>>>>>        Case End
86818>>>>>>>
86818>>>>>>>        Move False to Err
86819>>>>>>>
86819>>>>>>>        Structure_Start hToTable sDriverID
86820>>>>>>>            Structure_Copy hTable to hToTable
86821>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86824>>>>>>>
86824>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86826>>>>>>>                If (bUseConnectionID = True) Begin
86828>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86831>>>>>>>                End
86831>>>>>>>>
86831>>>>>>>                Else Begin
86832>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86835>>>>>>>                End
86835>>>>>>>>
86835>>>>>>>
86835>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86838>>>>>>>
86838>>>>>>>                If (sSchema <> "") Begin
86840>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86843>>>>>>>                End
86843>>>>>>>>
86843>>>>>>>
86843>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86845>>>>>>>                    If (sLongTableSpace <> "") Begin
86847>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86850>>>>>>>                    End
86850>>>>>>>>
86850>>>>>>>                    If (sBaseTableSpace <> "") Begin
86852>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86855>>>>>>>                    End
86855>>>>>>>>
86855>>>>>>>                    If (sIndexTableSpace <> "") Begin
86857>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86860>>>>>>>                    End
86860>>>>>>>>
86860>>>>>>>                End
86860>>>>>>>>
86860>>>>>>>            End
86860>>>>>>>>
86860>>>>>>>
86860>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86861>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86863>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86864>>>>>>>
86864>>>>>>>        Move (not(Err)) to bOK
86865>>>>>>>
86865>>>>>>>        If (bOK = True and bCopyData = True) Begin
86867>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86868>>>>>>>
86868>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86870>>>>>>>                Get pbContinueOnError to bContinueOnError
86871>>>>>>>            End
86871>>>>>>>>
86871>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86871>>>>>>>            // rename it by adding a GUID to the end of the table name
86871>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86871>>>>>>>            // different rules how long a table name can be.
86871>>>>>>>            // The new table will probably contain data but something went
86871>>>>>>>            // wrong while converting the data from embedded to SQL.
86871>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86873>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86874>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86875>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86876>>>>>>>>
86876>>>>>>>            End
86876>>>>>>>>
86876>>>>>>>        End
86876>>>>>>>>
86876>>>>>>>
86876>>>>>>>        // This must be after copying data...
86876>>>>>>>        If (Err = False) Begin
86878>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86881>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86881>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86881>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86881>>>>>>>            //                // The max length for the display_name is 31 characters...
86881>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86881>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86881>>>>>>>            //                End
86881>>>>>>>            //            End
86881>>>>>>>        End
86881>>>>>>>>
86881>>>>>>>
86881>>>>>>>        Close hTable
86882>>>>>>>        Move (not(Err)) to bOK
86883>>>>>>>        Function_Return bOK
86884>>>>>>>    End_Function
86885>>>>>>>
86885>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86885>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86885>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86885>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86887>>>>>>>        Boolean bOpened bOK
86887>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86887>>>>>>>        String sErrorFile sEmpty sPath
86887>>>>>>>
86887>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86890>>>>>>>        Get AutoConnectionIDLogin to bOK
86891>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86893>>>>>>>            Send IncreaseSortBufferSize
86894>>>>>>>//            Send SetAllIndexesToBatch hToTable
86894>>>>>>>        End
86894>>>>>>>>
86894>>>>>>>
86894>>>>>>>        Move False to Err
86895>>>>>>>        Open sPhysicalName as hToTable
86897>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86900>>>>>>>        If (bOpened = False) Begin
86902>>>>>>>            Function_Return False
86903>>>>>>>        End
86903>>>>>>>>
86903>>>>>>>
86903>>>>>>>        If (ghoStatusPanel <> 0) Begin
86905>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86906>>>>>>>            Set piMinimum of ghoProgressBar to 0
86907>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86908>>>>>>>        End
86908>>>>>>>>
86908>>>>>>>
86908>>>>>>>        Move "" to sEmpty
86909>>>>>>>        Move False to Err
86910>>>>>>>        Move True to bOK
86911>>>>>>>        Set Private.phCurrentTable to hToTable
86912>>>>>>>
86912>>>>>>>        // No need to get the record identifier
86912>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86915>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86918>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86920>>>>>>>            // Remove all indices to speed up copying of data:
86920>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86925>>>>>>>            If (iRetval <> 0) Begin       
86927>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86928>>>>>>>>
86928>>>>>>>                Close hToTable
86929>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86932>>>>>>>                Function_Return False
86933>>>>>>>            End
86933>>>>>>>>
86933>>>>>>>        End
86933>>>>>>>>
86933>>>>>>>
86933>>>>>>>        Move (sRootName + ".err") to sErrorFile
86934>>>>>>>        Move 0 to iIndex
86935>>>>>>>        Move False to Err
86936>>>>>>>
86936>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86938>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86941>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86946>>>>>>>            If (iRetval <> 0) Begin
86948>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86949>>>>>>>>
86949>>>>>>>                Close hToTable
86950>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86953>>>>>>>                Function_Return False
86954>>>>>>>            End
86954>>>>>>>>
86954>>>>>>>        End
86954>>>>>>>>
86954>>>>>>>        Else Begin
86955>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86958>>>>>>>        End
86958>>>>>>>>
86958>>>>>>>
86958>>>>>>>        If (Err = False) Begin
86960>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86961>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86962>>>>>>>        End
86962>>>>>>>>
86962>>>>>>>
86962>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86964>>>>>>>            // Recreate indices:
86964>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86969>>>>>>>            If (iRetval <> 0) Begin
86971>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86972>>>>>>>>
86972>>>>>>>                Close hToTable
86973>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86976>>>>>>>                Function_Return False
86977>>>>>>>            End
86977>>>>>>>>
86977>>>>>>>        End
86977>>>>>>>>
86977>>>>>>>
86977>>>>>>>        Close hToTable
86978>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86981>>>>>>>
86981>>>>>>>        If (bOK = True) Begin
86983>>>>>>>            Move (not(Err)) to bOK
86984>>>>>>>        End
86984>>>>>>>>
86984>>>>>>>
86984>>>>>>>        If (ghoStatusPanel <> 0) Begin
86986>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86987>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86988>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86989>>>>>>>        End
86989>>>>>>>>
86989>>>>>>>
86989>>>>>>>        Function_Return (bOK = True)
86990>>>>>>>    End_Function
86991>>>>>>>
86991>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86991>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86991>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86993>>>>>>>        Handle hFile
86993>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86993>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86993>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86993>>>>>>>        tSQLConnection SQLConnection
86993>>>>>>>        tSQLConnection SQLConnection
86993>>>>>>>        tAPIColumn[] aColumns
86993>>>>>>>        tAPIColumn[] aColumns
86994>>>>>>>        tColumnType ColumnType
86994>>>>>>>        tColumnType ColumnType
86994>>>>>>>
86994>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86994>>>>>>>        Get _UtilTableExists hTable to bOk
86995>>>>>>>        If (bOk = True) Begin
86997>>>>>>>            Function_Return False
86998>>>>>>>        End
86998>>>>>>>>
86998>>>>>>>
86998>>>>>>>        Set Private.phCurrentTable to hTable
86999>>>>>>>        Move sLogicalName to sTableName
87000>>>>>>>        If (ghoProgressBar <> 0) Begin
87002>>>>>>>            Send DoAdvance of ghoProgressBar
87003>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87004>>>>>>>        End
87004>>>>>>>>
87004>>>>>>>
87004>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87005>>>>>>>        Get psDriverID to sDriverID
87006>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87007>>>>>>>        Get piDbType to iDbType
87008>>>>>>>
87008>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87008>>>>>>>        Move False to bDeleteDummy
87009>>>>>>>        If (Num_Arguments = 8) Begin
87011>>>>>>>            Move aColumnIn to aColumns
87012>>>>>>>        End
87012>>>>>>>>
87012>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87014>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87015>>>>>>>            Move ColumnType.iSQLType to iDataType
87016>>>>>>>            If (bRecnum = False) Begin
87018>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87019>>>>>>>            End
87019>>>>>>>>
87019>>>>>>>            Else Begin
87020>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87021>>>>>>>            End
87021>>>>>>>>
87021>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87022>>>>>>>            Move True to bDeleteDummy
87023>>>>>>>        End
87023>>>>>>>>
87023>>>>>>>
87023>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87023>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87023>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87023>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87023>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87025>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87026>>>>>>>            Decrement iSize
87027>>>>>>>            for iCount from 0 to iSize
87033>>>>>>>>
87033>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87035>>>>>>>                    Move False to bRecnum
87036>>>>>>>                    Move iSize to iCount
87037>>>>>>>                End
87037>>>>>>>>
87037>>>>>>>            Loop
87038>>>>>>>>
87038>>>>>>>        End
87038>>>>>>>>
87038>>>>>>>
87038>>>>>>>        // If this is a SQL based driver we also check if the table exists
87038>>>>>>>        // in the SQL back end; in case we do nothing.
87038>>>>>>>        If (bSqlDriver = True) Begin
87040>>>>>>>            // Get all connection properties
87040>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87041>>>>>>>            Move SQLConnection.sSchema to sSchema
87042>>>>>>>            If (sSchema = "") Begin
87044>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87045>>>>>>>            End
87045>>>>>>>>
87045>>>>>>>
87045>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87046>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87046>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87046>>>>>>>            If (bExists = False) Begin
87048>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87049>>>>>>>            End
87049>>>>>>>>
87049>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87049>>>>>>>            // we will just add it to Filelist.cfg
87049>>>>>>>            If (bExists = True) Begin
87051>>>>>>>                If (bExistsInFilelist = False) Begin
87053>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87055>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87056>>>>>>>                    End
87056>>>>>>>>
87056>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87059>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87062>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87065>>>>>>>                    Move False to bSysFile
87066>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87067>>>>>>>                End
87067>>>>>>>>
87067>>>>>>>                Function_Return False
87068>>>>>>>            End
87068>>>>>>>>
87068>>>>>>>        End
87068>>>>>>>>
87068>>>>>>>
87068>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87069>>>>>>>        If (num_arguments > 6) Begin
87071>>>>>>>            If (bANSI = False) Begin
87073>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87074>>>>>>>            End
87074>>>>>>>>
87074>>>>>>>        End
87074>>>>>>>>
87074>>>>>>>
87074>>>>>>>        Move False to Err
87075>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87077>>>>>>>            Move sRootName to sPhysicalFile
87078>>>>>>>        End
87078>>>>>>>>
87078>>>>>>>
87078>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87080>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87081>>>>>>>
87081>>>>>>>            // If DAW driver and we should use a connection id we need to
87081>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87081>>>>>>>            If (bUseConnectionID = True) Begin
87083>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87084>>>>>>>                If (bExists = False) Begin
87086>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
87087>>>>>>>                    If (bOk = False) Begin
87089>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87090>>>>>>>>
87090>>>>>>>                        Function_Return False
87091>>>>>>>                    End
87091>>>>>>>>
87091>>>>>>>                End
87091>>>>>>>>
87091>>>>>>>            End
87091>>>>>>>>
87091>>>>>>>
87091>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87093>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87094>>>>>>>            End
87094>>>>>>>>
87094>>>>>>>            Else Begin
87095>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87096>>>>>>>            End
87096>>>>>>>>
87096>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87097>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
87097>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87097>>>>>>>//            End
87097>>>>>>>        End
87097>>>>>>>>
87097>>>>>>>        Move False to Err
87098>>>>>>>        Move 0 to hFile
87099>>>>>>>
87099>>>>>>>        Structure_Start hFile sDriverID
87100>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87102>>>>>>>                If (bUseConnectionID = True) Begin
87104>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87107>>>>>>>                End
87107>>>>>>>>
87107>>>>>>>                Else Begin
87108>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87111>>>>>>>                End
87111>>>>>>>>
87111>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87114>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87117>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87120>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87123>>>>>>>
87123>>>>>>>                If (sSchema <> "") Begin
87125>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87128>>>>>>>                End
87128>>>>>>>>
87128>>>>>>>
87128>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87130>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87132>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87135>>>>>>>                    End
87135>>>>>>>>
87135>>>>>>>                End
87135>>>>>>>>
87135>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87137>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87139>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87142>>>>>>>                    End
87142>>>>>>>>
87142>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87144>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87147>>>>>>>                    End
87147>>>>>>>>
87147>>>>>>>                End
87147>>>>>>>>
87147>>>>>>>            End
87147>>>>>>>>
87147>>>>>>>
87147>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87150>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87151>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87152>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87154>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87155>>>>>>>
87155>>>>>>>        Move (not(Err)) to bOK
87156>>>>>>>        If (bOk = True) Begin
87158>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87160>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87161>>>>>>>            End
87161>>>>>>>>
87161>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87164>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87167>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87170>>>>>>>
87170>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87170>>>>>>>            If (bDeleteDummy) Begin
87172>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87173>>>>>>>            End
87173>>>>>>>>
87173>>>>>>>        End
87173>>>>>>>>
87173>>>>>>>
87173>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87174>>>>>>>        Close hTable
87175>>>>>>>        Function_Return bOK
87176>>>>>>>    End_Function
87177>>>>>>>
87177>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87179>>>>>>>        Move False to Err
87180>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87183>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87186>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87189>>>>>>>
87189>>>>>>>        Function_Return (Err = False)
87190>>>>>>>    End_Function
87191>>>>>>>
87191>>>>>>>    // ToDo: Needs to be revised
87191>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87193>>>>>>>        Handle hTable
87193>>>>>>>        String sDEFName sDataPath
87193>>>>>>>        Boolean bExists
87193>>>>>>>
87193>>>>>>>        // Do nothing if MSSQL Driver.
87193>>>>>>>//        Get IsMSSQLDriver to bExists
87193>>>>>>>//        If (bExists = True) Begin
87193>>>>>>>//            Procedure_Return
87193>>>>>>>//        End
87193>>>>>>>
87193>>>>>>>        Get psDataPathFirstPart to sDataPath
87194>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87195>>>>>>>        If (bExists = True) Begin
87197>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87197>>>>>>>            // still be missing from the filelist and needs to be added.
87197>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
87198>>>>>>>            If (bExists = True) Begin
87200>>>>>>>                Procedure_Return
87201>>>>>>>            End
87201>>>>>>>>
87201>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87201>>>>>>>            Else Begin
87202>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87205>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87208>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87211>>>>>>>                Procedure_Return
87212>>>>>>>            End
87212>>>>>>>>
87212>>>>>>>        End
87212>>>>>>>>
87212>>>>>>>
87212>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87213>>>>>>>        Move 0 to hTable
87214>>>>>>>        Move False to Err
87215>>>>>>>
87215>>>>>>>        Structure_Start hTable DATAFLEX_ID
87216>>>>>>>            Load_Def sDEFName Onto hTable
87217>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87220>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87221>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87223>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87224>>>>>>>
87224>>>>>>>        Move iFilelistSlot to hTable
87225>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87228>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87231>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87234>>>>>>>
87234>>>>>>>    End_Procedure
87235>>>>>>>
87235>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87237>>>>>>>        Boolean bTmp bErr bOK
87237>>>>>>>        String sTableName sDisplayName sFileName
87237>>>>>>>
87237>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87237>>>>>>>        Move Err to bTmp
87238>>>>>>>        Move False to Err
87239>>>>>>>
87239>>>>>>>        Get AutoConnectionIDLogin to bOK
87240>>>>>>>        // First get the info for the current filelist slot:
87240>>>>>>>        Open iFromFileSlot
87242>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87245>>>>>>>        If (bOK = True) Begin
87247>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87250>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87253>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87256>>>>>>>
87256>>>>>>>            //...then move it.
87256>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87259>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87262>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87265>>>>>>>
87265>>>>>>>            //...and finally remove the old filelist values.
87265>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87268>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87271>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87274>>>>>>>        End
87274>>>>>>>>
87274>>>>>>>        Close iFromFileSlot
87275>>>>>>>
87275>>>>>>>        Move Err to bErr
87276>>>>>>>        Move bTmp to Err
87277>>>>>>>        Function_Return (bErr = False)
87278>>>>>>>    End_Function
87279>>>>>>>
87279>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87281>>>>>>>        Handle hTable
87281>>>>>>>        Boolean bOK
87281>>>>>>>        String sDriverID
87281>>>>>>>
87281>>>>>>>        Get _UtilTableExists hTableFrom to bOK
87282>>>>>>>        If (bOK = False) Begin
87284>>>>>>>            Set Private.phCurrentTable to hTableFrom
87285>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. From Table:" * String(hTableFrom) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87286>>>>>>>>
87286>>>>>>>            Function_Return False
87287>>>>>>>        End
87287>>>>>>>>
87287>>>>>>>
87287>>>>>>>        Get _UtilTableExists hTableTo to bOK
87288>>>>>>>        If (bOK = False) Begin
87290>>>>>>>            Set Private.phCurrentTable to hTableTo
87291>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. To Table:" * String(hTableTo) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87292>>>>>>>>
87292>>>>>>>            Function_Return False
87293>>>>>>>        End
87293>>>>>>>>
87293>>>>>>>
87293>>>>>>>        Get AutoConnectionIDLogin to bOK
87294>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87295>>>>>>>        If (bOK = False) Begin
87297>>>>>>>            Function_Return False
87298>>>>>>>        End
87298>>>>>>>>
87298>>>>>>>
87298>>>>>>>        Move False to Err
87299>>>>>>>        Open hTableTo
87301>>>>>>>
87301>>>>>>>        Move hTableFrom to hTable
87302>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87305>>>>>>>        Set Private.phCurrentTable to hTable
87306>>>>>>>
87306>>>>>>>        Structure_Start hTable sDriverID
87307>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87310>>>>>>>            If (iColumnTo <> 0) Begin
87312>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87315>>>>>>>            End
87315>>>>>>>>
87315>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87316>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87318>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87319>>>>>>>
87319>>>>>>>        If (hTableTo > 0) Begin
87321>>>>>>>            Close hTableTo
87322>>>>>>>        End
87322>>>>>>>>
87322>>>>>>>
87322>>>>>>>        Function_Return (Err = False)
87323>>>>>>>    End_Function
87324>>>>>>>
87324>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87324>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87326>>>>>>>        String sTableName sDriverID
87326>>>>>>>        Boolean bOk
87326>>>>>>>        String sDataPath
87326>>>>>>>
87326>>>>>>>        Get AutoConnectionIDLogin to bOK
87327>>>>>>>        Move False to Err
87328>>>>>>>        Get psDriverID to sDriverID
87329>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87330>>>>>>>        If (sTableName = "") Begin
87332>>>>>>>            Function_Return False
87333>>>>>>>        End
87333>>>>>>>>
87333>>>>>>>
87333>>>>>>>        Set Private.phCurrentTable to hTable
87334>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87335>>>>>>>        Delete_db sTableName
87336>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87337>>>>>>>
87337>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87339>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87339>>>>>>>            Get psDataPathFirstPart to sDataPath
87340>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87341>>>>>>>        End
87341>>>>>>>>
87341>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87341>>>>>>>        If (hTable <> 0) Begin
87343>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87346>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87349>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87352>>>>>>>        End
87352>>>>>>>>
87352>>>>>>>
87352>>>>>>>        Close hTable
87353>>>>>>>        Function_Return (hTable <> 0)
87354>>>>>>>    End_Function
87355>>>>>>>
87355>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87357>>>>>>>        Handle hTable
87357>>>>>>>        Boolean bOK
87357>>>>>>>
87357>>>>>>>        Get AutoConnectionIDLogin to bOK
87358>>>>>>>        Move False to Err
87359>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87361>>>>>>>        Move hTableFrom to hTable
87362>>>>>>>
87362>>>>>>>        Structure_Start hTable
87363>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87366>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87367>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87369>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87370>>>>>>>
87370>>>>>>>        Close hTableFrom
87371>>>>>>>        Function_Return (Err = False)
87372>>>>>>>    End_Function
87373>>>>>>>
87373>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87375>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87375>>>>>>>        Boolean bOK bExists bOpened
87375>>>>>>>        tAPITableNameInfo APITableNameInfo
87375>>>>>>>        tAPITableNameInfo APITableNameInfo
87375>>>>>>>
87375>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87378>>>>>>>        If (bOpened = False) Begin
87380>>>>>>>            Get OpenTableExclusive hTable to bOpened
87381>>>>>>>            If (bOpened = False) Begin
87383>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87384>>>>>>>                Function_Return False
87385>>>>>>>            End
87385>>>>>>>>
87385>>>>>>>        End
87385>>>>>>>>
87385>>>>>>>
87385>>>>>>>        Set Private.phCurrentTable to hTable
87386>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87387>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87388>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87389>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87390>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87391>>>>>>>        If (bExists = True) Begin
87393>>>>>>>            Function_Return True
87394>>>>>>>        End
87394>>>>>>>>
87394>>>>>>>
87394>>>>>>>        Set Private.phCurrentTable to hTable
87395>>>>>>>        Move False to Err
87396>>>>>>>        Get psDataPathFirstPart to sDataPath
87397>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87400>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87403>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87406>>>>>>>
87406>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87409>>>>>>>        Close hTable
87410>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87412>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87413>>>>>>>            If (bExists = True) Begin
87415>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87417>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87420>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87420>>>>>>>                    // might report "File in use..." and the deletion will fail.
87420>>>>>>>                    Sleep 2
87421>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87422>>>>>>>                End
87422>>>>>>>>
87422>>>>>>>            End
87422>>>>>>>>
87422>>>>>>>        End
87422>>>>>>>>
87422>>>>>>>
87422>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87424>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87426>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87427>>>>>>>            End
87427>>>>>>>>
87427>>>>>>>
87427>>>>>>>            // Change the table name in the .int file to the new table new:
87427>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87428>>>>>>>            If (bOK = False) Begin
87430>>>>>>>                Function_Return False
87431>>>>>>>            End
87431>>>>>>>>
87431>>>>>>>
87431>>>>>>>            // Change table name at the SQL side:
87431>>>>>>>            Get psSchema to sSchema
87432>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87433>>>>>>>
87433>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87434>>>>>>>            // Remove cache file and Rename the physical file names:
87434>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87435>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87436>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87437>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87438>>>>>>>
87438>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87438>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87438>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87438>>>>>>>//            End
87438>>>>>>>        End
87438>>>>>>>>
87438>>>>>>>
87438>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87441>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87444>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87447>>>>>>>
87447>>>>>>>        Function_Return (Err = False)
87448>>>>>>>    End_Function
87449>>>>>>>
87449>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87451>>>>>>>        Move False to Err
87452>>>>>>>        Set Private.phCurrentTable to hTable
87453>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87456>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87459>>>>>>>
87459>>>>>>>        Function_Return (Err = False)
87460>>>>>>>    End_Function
87461>>>>>>>
87461>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87463>>>>>>>        Handle hTable
87463>>>>>>>        String sTableName
87463>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87463>>>>>>>        Integer iDbType
87463>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK
87463>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87463>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87463>>>>>>>        tSQLConnection SQLConnection
87463>>>>>>>        tSQLConnection SQLConnection
87463>>>>>>>        tAPITable      APITableFrom APITableTo
87463>>>>>>>        tAPITable      APITableFrom APITableTo
87463>>>>>>>        tColumnType    ColumnType
87463>>>>>>>        tColumnType    ColumnType
87463>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87463>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87464>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87464>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87465>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87465>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87466>>>>>>>
87466>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87466>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87468>>>>>>>            Function_Return False
87469>>>>>>>        End
87469>>>>>>>>
87469>>>>>>>        
87469>>>>>>>        Move True to bOk
87470>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87471>>>>>>>        Get piDbType                            to iDbType
87472>>>>>>>        Get pbRecnum                            to bRecnum
87473>>>>>>>        Get pbToANSI                            to bToANSI
87474>>>>>>>        Get pbCopyData                          to bCopyData
87475>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87476>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87477>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87478>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87479>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87480>>>>>>>
87480>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87481>>>>>>>        Set Private.phCurrentTable              to hTable
87482>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87483>>>>>>>
87483>>>>>>>        If (ghoProgressBar <> 0) Begin
87485>>>>>>>            Send DoAdvance of ghoProgressBar
87486>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87487>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87488>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87489>>>>>>>        End
87489>>>>>>>>
87489>>>>>>>
87489>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87490>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87491>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87492>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87493>>>>>>>        Move True                               to APITableFrom.bFromTable
87494>>>>>>>        Move hTable                             to APITableFrom.hTable
87495>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87496>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87497>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87498>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87499>>>>>>>
87499>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87499>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87501>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87502>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87503>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87505>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87508>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87509>>>>>>>>
87509>>>>>>>                Function_Return False
87510>>>>>>>            End
87510>>>>>>>>
87510>>>>>>>        End
87510>>>>>>>>
87510>>>>>>>
87510>>>>>>>        If (bTableExists = True) Begin
87512>>>>>>>            If (bIsSQLTableTo = True) Begin
87514>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87515>>>>>>>            End
87515>>>>>>>>
87515>>>>>>>            Get OpenTableExclusive hTable to bOpened
87516>>>>>>>            If (bOpened = False) Begin
87518>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87519>>>>>>>                Function_Return False
87520>>>>>>>            End
87520>>>>>>>>
87520>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87521>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87522>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87523>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87524>>>>>>>        End
87524>>>>>>>>
87524>>>>>>>
87524>>>>>>>        Move True to bOk
87525>>>>>>>        Move False to Err
87526>>>>>>>        Case Begin
87526>>>>>>>            // Alias table:
87526>>>>>>>            Case (bIsAliasFrom = True)
87528>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87528>>>>>>>                Case Break
87529>>>>>>>
87529>>>>>>>            Case (bIsSQLTableFrom = True and bIsSQLTableTo = False and bTableExists = True)
87532>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOk
87533>>>>>>>                    If (bOk = True) Begin
87535>>>>>>>                        Send LogError ("DataFlex table:" * String(APITableNameInfoFrom.sLogicalName) * "successfully converted to use driver:" * String(sDriverIDFrom)) False
87536>>>>>>>                    End
87536>>>>>>>>
87536>>>>>>>                Case Break
87537>>>>>>>            // New Table:
87537>>>>>>>            Case (bTableExists = False)
87540>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87541>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87541>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87543>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87544>>>>>>>                End                                                                 
87544>>>>>>>>
87544>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87545>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87546>>>>>>>                Case Break
87547>>>>>>>
87547>>>>>>>            // Update table:
87547>>>>>>>            Case (bTableExists = True)
87550>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87551>>>>>>>                If (bIsSame = True) Begin
87553>>>>>>>                    Case Break
87554>>>>>>>                End
87554>>>>>>>>
87554>>>>>>>                If (bFilelistError = True) Begin
87556>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87557>>>>>>>                    If (bOk = False) Begin
87559>>>>>>>                        Case Break
87560>>>>>>>                    End
87560>>>>>>>>
87560>>>>>>>                End
87560>>>>>>>>
87560>>>>>>>
87560>>>>>>>                If (ghoProgressBar <> 0) Begin
87562>>>>>>>                    Send DoAdvance of ghoProgressBar
87563>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87564>>>>>>>                End
87564>>>>>>>>
87564>>>>>>>
87564>>>>>>>                // Columns:
87564>>>>>>>                Move True to bOk
87565>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87566>>>>>>>                If (bIsSame = False) Begin
87568>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87569>>>>>>>                End
87569>>>>>>>>
87569>>>>>>>                If (bOk = False) Begin
87571>>>>>>>                    Case Break
87572>>>>>>>                End
87572>>>>>>>>
87572>>>>>>>
87572>>>>>>>                // Indexes:
87572>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87573>>>>>>>                If (bIsSame = False) Begin
87575>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87576>>>>>>>                End
87576>>>>>>>>
87576>>>>>>>
87576>>>>>>>                // Relations:
87576>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87577>>>>>>>                If (bIsSame = False) Begin
87579>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87580>>>>>>>                    If (bOk = False) Begin
87582>>>>>>>                        Case Break
87583>>>>>>>                    End
87583>>>>>>>>
87583>>>>>>>                End
87583>>>>>>>>
87583>>>>>>>
87583>>>>>>>                Case Break
87584>>>>>>>
87584>>>>>>>            Case Else
87584>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87585>>>>>>>>
87585>>>>>>>                Move False to bOk
87586>>>>>>>        Case End
87586>>>>>>>        
87586>>>>>>>        If (bOk = True) Begin
87588>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87588>>>>>>>            // or convert an embedded table to SQL
87588>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87590>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87591>>>>>>>                If (bOk = False) Begin
87593>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87594>>>>>>>                End
87594>>>>>>>>
87594>>>>>>>            End
87594>>>>>>>>
87594>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87597>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87598>>>>>>>            End
87598>>>>>>>>
87598>>>>>>>            
87598>>>>>>>            // Filelist Names:
87598>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87599>>>>>>>        End
87599>>>>>>>>
87599>>>>>>>        
87599>>>>>>>        Close hTable
87600>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87601>>>>>>>
87601>>>>>>>        Function_Return bOK
87602>>>>>>>    End_Function
87603>>>>>>>
87603>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87603>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87605>>>>>>>        Function_Return False
87606>>>>>>>    End_Function
87607>>>>>>>
87607>>>>>>>    // Adds a column name to the passed table number.
87607>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87609>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87609>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87609>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87609>>>>>>>
87609>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87610>>>>>>>        If (bExists = True) Begin
87612>>>>>>>            Function_Return False
87613>>>>>>>        End
87613>>>>>>>>
87613>>>>>>>
87613>>>>>>>        Move False to Err
87614>>>>>>>        If (num_arguments > 4) Begin
87616>>>>>>>            Move iPrec to iPrecision
87617>>>>>>>        End
87617>>>>>>>>
87617>>>>>>>        If (num_arguments > 6) Begin
87619>>>>>>>            Move bInitVal to bInitializeValue
87620>>>>>>>            Move sColVal  to sColumnValue
87621>>>>>>>        End
87621>>>>>>>>
87621>>>>>>>        If (iType < -1490) Begin
87623>>>>>>>            Move (iType + 1500) to iType
87624>>>>>>>        End
87624>>>>>>>>
87624>>>>>>>
87624>>>>>>>        Move hTable to iFile
87625>>>>>>>        Get psDriverID to sDriverID
87626>>>>>>>        Get AutoConnectionIDLogin to bOK
87627>>>>>>>        Move False to Err
87628>>>>>>>        Move LastErr to iLastErr
87629>>>>>>>        Get OpenTableExclusive iFile to bOK
87630>>>>>>>        Set Private.phCurrentTable to hTable
87631>>>>>>>
87631>>>>>>>        Structure_Start iFile sDriverID
87632>>>>>>>            Move 0 to iColumn
87633>>>>>>>            Set Private.piCurrentField to iColumn
87634>>>>>>>            Create_Field hTable At iColumn
87635>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87638>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87641>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87644>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87647>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87648>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87650>>>>>>>
87650>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87651>>>>>>>
87651>>>>>>>        // If in development environment; create .fd file:
87651>>>>>>>        Open hTable
87653>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87654>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87655>>>>>>>        If (iCount > 1) Begin
87657>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87658>>>>>>>        End
87658>>>>>>>>
87658>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87659>>>>>>>        If (bExists = True) Begin
87661>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87662>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87665>>>>>>>            Get _TableNameOnly sTableName to sTableName
87666>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87668>>>>>>>        End
87668>>>>>>>>
87668>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87670>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87671>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87672>>>>>>>            If (iCount > 1) Begin
87674>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87675>>>>>>>            End
87675>>>>>>>>
87675>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87676>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87676>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87676>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87676>>>>>>>        End
87676>>>>>>>>
87676>>>>>>>        // Check for a default value
87676>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87678>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87679>>>>>>>        End
87679>>>>>>>>
87679>>>>>>>        Close hTable
87680>>>>>>>
87680>>>>>>>        Function_Return (Err = False)
87681>>>>>>>    End_Function
87682>>>>>>>
87682>>>>>>>    // Adds a column name to the passed table number.
87682>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87684>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87684>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87684>>>>>>>        String sDdSrcPath sTableName
87684>>>>>>>
87684>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87685>>>>>>>        Move False to Err
87686>>>>>>>        If (bExists = True) Begin
87688>>>>>>>            Function_Return False
87689>>>>>>>        End
87689>>>>>>>>
87689>>>>>>>        If (num_arguments > 4) Begin
87691>>>>>>>            Move iPrec to iPrecision
87692>>>>>>>        End
87692>>>>>>>>
87692>>>>>>>        If (iType < -1490) Begin
87694>>>>>>>            Move (iType + 1500) to iType
87695>>>>>>>        End
87695>>>>>>>>
87695>>>>>>>
87695>>>>>>>        Get AutoConnectionIDLogin to bOK
87696>>>>>>>        Move False to Err
87697>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87698>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87698>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87698>>>>>>>        Get piDbType to iDbType
87699>>>>>>>        If (bIsSQLTypeTo = False) Begin
87701>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87702>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87704>>>>>>>                Move DF_DATE to iType
87705>>>>>>>            End
87705>>>>>>>>
87705>>>>>>>        End
87705>>>>>>>>
87705>>>>>>>
87705>>>>>>>        // Structure_start will change the value of hTable...
87705>>>>>>>        Move hTable to iFile
87706>>>>>>>        Get OpenTableExclusive iFile to bOK
87707>>>>>>>        If (bOK = False) Begin
87709>>>>>>>            Function_Return False
87710>>>>>>>        End
87710>>>>>>>>
87710>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87713>>>>>>>
87713>>>>>>>        // If the passed column number is higher than the current number of fields
87713>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87713>>>>>>>        // a new field to the end:
87713>>>>>>>        If (iColumn > iNumberOfFields) Begin
87715>>>>>>>            Move 0 to iColumn
87716>>>>>>>        End
87716>>>>>>>>
87716>>>>>>>
87716>>>>>>>        Set Private.phCurrentTable to hTable
87717>>>>>>>        Set Private.piCurrentField to iColumn
87718>>>>>>>
87718>>>>>>>        Structure_Start iFile
87719>>>>>>>            Create_Field iFile At iColumn
87720>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87723>>>>>>>            If (bIsSQLTypeTo = False) Begin
87725>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87728>>>>>>>            End
87728>>>>>>>>
87728>>>>>>>            Else Begin
87729>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87732>>>>>>>            End
87732>>>>>>>>
87732>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87733>>>>>>>            If (bIsDateType = False) Begin
87735>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87738>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87741>>>>>>>            End
87741>>>>>>>>
87741>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87742>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87744>>>>>>>
87744>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87745>>>>>>>        // If in development environment; create .fd file:
87745>>>>>>>        Open hTable
87747>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87748>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87749>>>>>>>        If (iCount > 1) Begin
87751>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87752>>>>>>>        End
87752>>>>>>>>
87752>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87753>>>>>>>        If (bExists = True) Begin
87755>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87756>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87759>>>>>>>            Get _TableNameOnly sTableName to sTableName
87760>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87762>>>>>>>        End
87762>>>>>>>>
87762>>>>>>>
87762>>>>>>>        // Check for a default value
87762>>>>>>>        Close hTable
87763>>>>>>>
87763>>>>>>>        Function_Return (Err = False)
87764>>>>>>>    End_Function
87765>>>>>>>
87765>>>>>>>    // To update all records for a table column with a fixed value.
87765>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87767>>>>>>>        Integer iRecs iCurrErr iField iRecord
87767>>>>>>>        Boolean bRetval bOpen
87767>>>>>>>
87767>>>>>>>        Move 0 to iRecs
87768>>>>>>>        Move False to bRetval
87769>>>>>>>        Move Err to iCurrErr
87770>>>>>>>        Move False to Err
87771>>>>>>>
87771>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87774>>>>>>>        If (bOpen = False) Begin
87776>>>>>>>            Open hTable
87778>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87781>>>>>>>            If (bOpen = False) Begin
87783>>>>>>>                Function_Return bRetval
87784>>>>>>>            End
87784>>>>>>>>
87784>>>>>>>        End
87784>>>>>>>>
87784>>>>>>>
87784>>>>>>>        Field_Map hTable sFieldName to iField
87786>>>>>>>        If (iField <> 0) Begin
87788>>>>>>>            Set Private.phCurrentTable to hTable
87789>>>>>>>            Set Private.piCurrentField to iField
87790>>>>>>>            Clear hTable
87791>>>>>>>            Repeat
87791>>>>>>>>
87791>>>>>>>                Vfind hTable 0 GT
87793>>>>>>>                If (Found) Begin
87795>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87797>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87800>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87801>>>>>>>                    End
87801>>>>>>>>
87801>>>>>>>                    Reread hTable
87805>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87808>>>>>>>                        SaveRecord hTable
87809>>>>>>>                    Unlock
87810>>>>>>>>
87810>>>>>>>                End
87810>>>>>>>>
87810>>>>>>>           Until (not(Found))
87812>>>>>>>        End
87812>>>>>>>>
87812>>>>>>>
87812>>>>>>>        Move (Err = False) to bRetval
87813>>>>>>>        Move iCurrErr to Err
87814>>>>>>>
87814>>>>>>>        Function_Return bRetval
87815>>>>>>>    End_Function
87816>>>>>>>
87816>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87816>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87818>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87818>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87818>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87818>>>>>>>
87818>>>>>>>        Get psDriverID to sDriverID
87819>>>>>>>        Get piDbType to iDbType
87820>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87821>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87822>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87823>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87824>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87826>>>>>>>            Move True to bIsSqlTable
87827>>>>>>>        End
87827>>>>>>>>
87827>>>>>>>        Move False to bIsOpen
87828>>>>>>>        If (hTable > 0) Begin
87830>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87833>>>>>>>        End
87833>>>>>>>>
87833>>>>>>>        If (bIsOpen = True) Begin
87835>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87838>>>>>>>        End
87838>>>>>>>>
87838>>>>>>>        Else Begin
87839>>>>>>>            Get pbRecnum to bRecnumTable
87840>>>>>>>        End
87840>>>>>>>>
87840>>>>>>>
87840>>>>>>>        Move False to Err
87841>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87842>>>>>>>        Decrement iSize
87843>>>>>>>        for iCount from 0 to iSize
87849>>>>>>>>
87849>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87850>>>>>>>            If (hTable > 0) Begin
87852>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87853>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87854>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87857>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87858>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87859>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87860>>>>>>>            End
87860>>>>>>>>
87860>>>>>>>            Else Begin
87861>>>>>>>                Move False to bFieldExists
87862>>>>>>>            End
87862>>>>>>>>
87862>>>>>>>
87862>>>>>>>            If (bFieldExists = False) Begin
87864>>>>>>>                Move 0 to iColumn
87865>>>>>>>                Create_Field hTable At iColumn
87866>>>>>>>            End
87866>>>>>>>>
87866>>>>>>>            Else Begin
87867>>>>>>>                Move iCount to iColumn
87868>>>>>>>            End
87868>>>>>>>>
87868>>>>>>>
87868>>>>>>>            Set Private.piCurrentField to iColumn
87869>>>>>>>
87869>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87870>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87873>>>>>>>
87873>>>>>>>            Move aColumns[iCount].iType to iType
87874>>>>>>>            Move (not(iType < -1490)) to bNativeType
87875>>>>>>>            If (iType < -1490) Begin
87877>>>>>>>                Move (iType + 1500) to iType
87878>>>>>>>            End
87878>>>>>>>>
87878>>>>>>>
87878>>>>>>>            If (bIsSqlTable = True) Begin
87880>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87882>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87883>>>>>>>//                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87883>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87886>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87889>>>>>>>
87889>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87890>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87892>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87893>>>>>>>                    End
87893>>>>>>>>
87893>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87896>>>>>>>
87896>>>>>>>                End
87896>>>>>>>>
87896>>>>>>>                Else Begin
87897>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87900>>>>>>>                End
87900>>>>>>>>
87900>>>>>>>            End
87900>>>>>>>>
87900>>>>>>>            Else Begin
87901>>>>>>>                If (bCreating = False) Begin
87903>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87904>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87906>>>>>>>                        Move DF_DATE to iType
87907>>>>>>>                    End
87907>>>>>>>>
87907>>>>>>>                End
87907>>>>>>>>
87907>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87910>>>>>>>            End
87910>>>>>>>>
87910>>>>>>>
87910>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87911>>>>>>>            If (bIsDateType = False) Begin
87913>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87916>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87919>>>>>>>            End
87919>>>>>>>>
87919>>>>>>>
87919>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87921>>>>>>>                Move 0 to iIndex
87922>>>>>>>                Create_Index hTable at iIndex
87923>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87926>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87929>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87932>>>>>>>
87932>>>>>>>                // If we have an identity table - we must create a primary_key table.
87932>>>>>>>                If (bIsSqlTable = True) Begin
87934>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87937>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87940>>>>>>>                End
87940>>>>>>>>
87940>>>>>>>            End
87940>>>>>>>>
87940>>>>>>>        Loop
87941>>>>>>>>
87941>>>>>>>
87941>>>>>>>        Function_Return (Err = False)
87942>>>>>>>    End_Function
87943>>>>>>>
87943>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87943>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87945>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87945>>>>>>>        Boolean bOK bIsSqlTable
87945>>>>>>>        String sFieldNameTo
87945>>>>>>>
87945>>>>>>>        If (num_arguments > 4) Begin
87947>>>>>>>            Move iPrec to iPrecFrom
87948>>>>>>>        End
87948>>>>>>>>
87948>>>>>>>        If (iTypeFrom < -1490) Begin
87950>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87951>>>>>>>        End
87951>>>>>>>>
87951>>>>>>>
87951>>>>>>>        Get AutoConnectionIDLogin to bOK
87952>>>>>>>        Move False to Err
87953>>>>>>>        Get OpenTableExclusive hTable to bOK
87954>>>>>>>        If (bOK = False) Begin
87956>>>>>>>            Function_Return False
87957>>>>>>>        End
87957>>>>>>>>
87957>>>>>>>
87957>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87958>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87959>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87961>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87962>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87963>>>>>>>        If (Err = True) Begin
87965>>>>>>>            Function_Return False
87966>>>>>>>        End
87966>>>>>>>>
87966>>>>>>>
87966>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87969>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87970>>>>>>>        If (bIsSqlTable = False) Begin
87972>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87975>>>>>>>        End
87975>>>>>>>>
87975>>>>>>>        Else Begin
87976>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87979>>>>>>>        End
87979>>>>>>>>
87979>>>>>>>        // Let the driver decide the other values;
87979>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87982>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87985>>>>>>>
87985>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87987>>>>>>>            Function_Return False
87988>>>>>>>        End
87988>>>>>>>>
87988>>>>>>>
87988>>>>>>>        Set Private.phCurrentTable to hTable
87989>>>>>>>        Set Private.piCurrentField to iColumn
87990>>>>>>>
87990>>>>>>>        Structure_Start hTable
87991>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87994>>>>>>>            If (bIsSqlTable = False) Begin
87996>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87999>>>>>>>            End
87999>>>>>>>>
87999>>>>>>>            Else Begin
88000>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88003>>>>>>>            End
88003>>>>>>>>
88003>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
88006>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88009>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88010>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88012>>>>>>>
88012>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88013>>>>>>>        Function_Return (Err = False)
88014>>>>>>>    End_Function
88015>>>>>>>
88015>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88015>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88017>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88017>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88017>>>>>>>        String sFieldNameTo sDriverIDTo
88017>>>>>>>        tColumnType ColumnType
88017>>>>>>>        tColumnType ColumnType
88017>>>>>>>
88017>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88018>>>>>>>        Get piDbType to iDbType
88019>>>>>>>        If (num_arguments > 4) Begin
88021>>>>>>>            Move iPrec to iPrecFrom
88022>>>>>>>            Move iOpt  to iOptionFrom
88023>>>>>>>        End
88023>>>>>>>>
88023>>>>>>>        If (iTypeFrom < -1490) Begin
88025>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88026>>>>>>>        End
88026>>>>>>>>
88026>>>>>>>
88026>>>>>>>        Get AutoConnectionIDLogin to bOK
88027>>>>>>>        Move False to Err
88028>>>>>>>        Close hTable
88029>>>>>>>        Get OpenTableExclusive hTable to bOK
88030>>>>>>>        If (bOK = False) Begin
88032>>>>>>>            Function_Return False
88033>>>>>>>        End
88033>>>>>>>>
88033>>>>>>>
88033>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88036>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88039>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88040>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88042>>>>>>>            Move DF_DATE to iDataFlexType
88043>>>>>>>        End
88043>>>>>>>>
88043>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88046>>>>>>>
88046>>>>>>>        If (bIsSQLTableTo = True) Begin
88048>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
88051>>>>>>>        End
88051>>>>>>>>
88051>>>>>>>        Else Begin
88052>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88055>>>>>>>        End
88055>>>>>>>>
88055>>>>>>>
88055>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88058>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88061>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
88064>>>>>>>
88064>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88064>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
88064>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88066>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
88067>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88069>>>>>>>                Move DF_DATE to iTypeTo  
88070>>>>>>>            End
88070>>>>>>>>
88070>>>>>>>        End
88070>>>>>>>>
88070>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88073>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
88074>>>>>>>        End
88074>>>>>>>>
88074>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88075>>>>>>>
88075>>>>>>>        If (bCompareDate_DateTime = False) Begin
88077>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88078>>>>>>>            If (bSkip = True) Begin
88080>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88082>>>>>>>                    Function_Return True
88083>>>>>>>                End
88083>>>>>>>>
88083>>>>>>>            End
88083>>>>>>>>
88083>>>>>>>        End
88083>>>>>>>>
88083>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88086>>>>>>>            Function_Return True
88087>>>>>>>        End
88087>>>>>>>>
88087>>>>>>>
88087>>>>>>>        Set Private.phCurrentTable to hTable
88088>>>>>>>        Set Private.piCurrentField to iColumn
88089>>>>>>>
88089>>>>>>>        Structure_Start hTable
88090>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88092>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88095>>>>>>>            End
88095>>>>>>>>
88095>>>>>>>
88095>>>>>>>            If (bIsSameDataType = False) Begin
88097>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88100>>>>>>>                If (bIsSQLTableTo = True) Begin
88102>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
88105>>>>>>>                End
88105>>>>>>>>
88105>>>>>>>            End
88105>>>>>>>>
88105>>>>>>>
88105>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
88107>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88110>>>>>>>            End
88110>>>>>>>>
88110>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
88112>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88115>>>>>>>            End
88115>>>>>>>>
88115>>>>>>>
88115>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88117>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88117>>>>>>>                If (bRecnumTable = True) Begin
88119>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88122>>>>>>>                End
88122>>>>>>>>
88122>>>>>>>
88122>>>>>>>                // We might need to create an index here.
88122>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88122>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88122>>>>>>>                // index update checking logic.
88122>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88125>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88127>>>>>>>                    Create_Index hTable At iIndex
88128>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88131>>>>>>>                End
88131>>>>>>>>
88131>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88134>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88137>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88140>>>>>>>                If (bIsSQLTableTo = True) Begin
88142>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88145>>>>>>>                End
88145>>>>>>>>
88145>>>>>>>            End
88145>>>>>>>>
88145>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88146>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88148>>>>>>>
88148>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88149>>>>>>>        Function_Return (Err = False)
88150>>>>>>>    End_Function
88151>>>>>>>
88151>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88153>>>>>>>        Boolean bOK
88153>>>>>>>
88153>>>>>>>        Get AutoConnectionIDLogin to bOK
88154>>>>>>>        Move False to Err
88155>>>>>>>        Get OpenTableExclusive hTable to bOK
88156>>>>>>>        If (bOK = False) Begin
88158>>>>>>>            Function_Return False
88159>>>>>>>        End
88159>>>>>>>>
88159>>>>>>>
88159>>>>>>>        Structure_Start hTable
88160>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88163>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88164>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88166>>>>>>>
88166>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88167>>>>>>>        Function_Return (Err = False)
88168>>>>>>>    End_Function
88169>>>>>>>
88169>>>>>>>    // To move an existing field to another position in a table.
88169>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
88171>>>>>>>        String sColumn sDriverID
88171>>>>>>>        Integer iType iSQLType
88171>>>>>>>        Boolean bOK bIsDate
88171>>>>>>>
88171>>>>>>>        Close hTable
88172>>>>>>>        Get AutoConnectionIDLogin to bOK
88173>>>>>>>        Get OpenTableExclusive hTable to bOK
88174>>>>>>>        If (bOK = False) Begin
88176>>>>>>>            Function_Return False
88177>>>>>>>        End
88177>>>>>>>>
88177>>>>>>>
88177>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88180>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88182>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88183>>>>>>>>
88183>>>>>>>            Function_Return False
88184>>>>>>>        End
88184>>>>>>>>
88184>>>>>>>
88184>>>>>>>        Set Action_Text of ghoStatusPanel to "Restructures table..."
88185>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88188>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88191>>>>>>>        If (bIsSQLType = True) Begin
88193>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iOld to iSQLType
88196>>>>>>>            Get UtilColumnIsDateType iSQLType bIsSQLType  to bIsDate
88197>>>>>>>        End
88197>>>>>>>>
88197>>>>>>>        Else Begin
88198>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
88199>>>>>>>        End
88199>>>>>>>>
88199>>>>>>>
88199>>>>>>>        Set Private.phCurrentTable to hTable
88200>>>>>>>        Set Private.piCurrentField to iOld
88201>>>>>>>
88201>>>>>>>        Move False to Err
88202>>>>>>>
88202>>>>>>>        Structure_Start hTable
88203>>>>>>>            Delete_Field hTable iOld
88204>>>>>>>            Create_Field hTable At iNew
88205>>>>>>>            
88205>>>>>>>            // This one is the crucial line:
88205>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88208>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88211>>>>>>>            
88211>>>>>>>            // If SQL table it is important that we don't try to change the field type, as MS-SQL then will generate an error.
88211>>>>>>>            If (bIsSQLType = True and bIsDate = False) Begin
88213>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
88216>>>>>>>            End
88216>>>>>>>>
88216>>>>>>>            If (bIsDate = False) Begin
88218>>>>>>>                Set_Attribute DF_FIELD_TYPE   of hTable iNew to iType
88221>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88224>>>>>>>            End
88224>>>>>>>>
88224>>>>>>>            If (iType = DF_BCD) Begin
88226>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88229>>>>>>>            End
88229>>>>>>>>
88229>>>>>>>
88229>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88231>>>>>>>
88231>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88232>>>>>>>        Move (not(Err)) to bOK
88233>>>>>>>        Move False to Err
88234>>>>>>>        Move 0 to LastErr
88235>>>>>>>        Function_Return bOK
88236>>>>>>>    End_Function 
88237>>>>>>>    
88237>>>>>>>    // Deletes a column name for the passed table number (and column number).
88237>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88239>>>>>>>        Integer iColumn
88239>>>>>>>        Boolean bOK
88239>>>>>>>
88239>>>>>>>        Get AutoConnectionIDLogin to bOK
88240>>>>>>>        Move False to Err
88241>>>>>>>        Close hTable
88242>>>>>>>        Get OpenTableExclusive hTable to bOK
88243>>>>>>>        If (bOK = False) Begin
88245>>>>>>>            Function_Return False
88246>>>>>>>        End
88246>>>>>>>>
88246>>>>>>>
88246>>>>>>>        If (not(Err)) Begin
88248>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88249>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88250>>>>>>>            Field_Map hTable sFieldName to iColumn
88252>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88253>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88254>>>>>>>            If (iColumn = 0) Begin
88256>>>>>>>                Move 0 to LastErr
88257>>>>>>>                Function_Return False
88258>>>>>>>            End
88258>>>>>>>>
88258>>>>>>>            Move False to Err
88259>>>>>>>
88259>>>>>>>            Set Private.phCurrentTable to hTable
88260>>>>>>>            Set Private.piCurrentField to iColumn
88261>>>>>>>
88261>>>>>>>            Structure_Start hTable
88262>>>>>>>                Delete_Field hTable iColumn
88263>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88264>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88266>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88267>>>>>>>        End
88267>>>>>>>>
88267>>>>>>>        Else Begin
88268>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88269>>>>>>>>
88269>>>>>>>        End
88269>>>>>>>>
88269>>>>>>>
88269>>>>>>>        Function_Return (Err = False)
88270>>>>>>>    End_Function
88271>>>>>>>
88271>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88271>>>>>>>    // Returns True if no errors occured.
88271>>>>>>>    // Sample usage:
88271>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88271>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88273>>>>>>>        Integer iField
88273>>>>>>>        Boolean bOK bExists bIsOpen
88273>>>>>>>
88273>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88274>>>>>>>        If (bExists = True) Begin
88276>>>>>>>            Function_Return False
88277>>>>>>>        End
88277>>>>>>>>
88277>>>>>>>
88277>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
88277>>>>>>>        //       opened exclusively, so we first open it in normal mode.
88277>>>>>>>        Close hTable
88278>>>>>>>        Open hTable
88280>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88283>>>>>>>        If (bIsOpen = False) Begin
88285>>>>>>>            Function_Return False
88286>>>>>>>        End
88286>>>>>>>>
88286>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88287>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88288>>>>>>>        Field_Map hTable sOldFieldName to iField
88290>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88291>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88292>>>>>>>
88292>>>>>>>        Get AutoConnectionIDLogin to bOK
88293>>>>>>>        Get OpenTableExclusive hTable to bOK
88294>>>>>>>        If (bOK = False) Begin
88296>>>>>>>            Function_Return False
88297>>>>>>>        End
88297>>>>>>>>
88297>>>>>>>
88297>>>>>>>        Move False to Err
88298>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88299>>>>>>>        Set Private.phCurrentTable to hTable
88300>>>>>>>        Set Private.piCurrentField to iField
88301>>>>>>>
88301>>>>>>>        If (iField > 0) Begin
88303>>>>>>>            Structure_Start hTable
88304>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88307>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88308>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88310>>>>>>>        End
88310>>>>>>>>
88310>>>>>>>        Else Begin
88311>>>>>>>            Move 0 to LastErr
88312>>>>>>>            Move False to Err
88313>>>>>>>        End
88313>>>>>>>>
88313>>>>>>>
88313>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88314>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88315>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88316>>>>>>>
88316>>>>>>>        Function_Return (Err = False)
88317>>>>>>>    End_Function
88318>>>>>>>
88318>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88320>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88320>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88321>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88321>>>>>>>        Boolean bRenameField
88321>>>>>>>
88321>>>>>>>        Open hTable
88323>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88324>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88325>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88326>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88329>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88330>>>>>>>        Decrement iSize
88331>>>>>>>        for iCount from 0 to iSize
88337>>>>>>>>
88337>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88339>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88340>>>>>>>
88340>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88342>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88344>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88345>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88346>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88348>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88349>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88350>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88351>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88352>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88353>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88354>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88355>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88356>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88357>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88358>>>>>>>                        Increment iItem
88359>>>>>>>                    End
88359>>>>>>>>
88359>>>>>>>                End
88359>>>>>>>>
88359>>>>>>>            End
88359>>>>>>>>
88359>>>>>>>        Loop
88360>>>>>>>>
88360>>>>>>>
88360>>>>>>>        Move False to Err
88361>>>>>>>        Move 0 to LastErr
88362>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88363>>>>>>>        Function_Return aAPIColumnsToInsert
88364>>>>>>>    End_Function
88365>>>>>>>
88365>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88367>>>>>>>        Integer iSize iCount
88367>>>>>>>        Boolean bOK
88367>>>>>>>        tAPIColumn[] aColumnsTo
88367>>>>>>>        tAPIColumn[] aColumnsTo
88368>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88368>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88369>>>>>>>
88369>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88370>>>>>>>        If (iSize = 0) Begin
88372>>>>>>>            Function_Return True
88373>>>>>>>        End
88373>>>>>>>>
88373>>>>>>>
88373>>>>>>>        Move False to Err
88374>>>>>>>        Decrement iSize
88375>>>>>>>        for iCount from 0 to iSize
88381>>>>>>>>
88381>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88382>>>>>>>        Loop
88383>>>>>>>>
88383>>>>>>>
88383>>>>>>>        Function_Return bOK
88384>>>>>>>    End_Function
88385>>>>>>>
88385>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88385>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88387>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88387>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88388>>>>>>>        Integer iSize iCount iItem iShouldMove
88388>>>>>>>
88388>>>>>>>        Move 0 to iItem
88389>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88390>>>>>>>        Decrement iSize
88391>>>>>>>        for iCount from 0 to iSize
88397>>>>>>>>
88397>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88399>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88400>>>>>>>                If (iShouldMove <> -1) Begin
88402>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88403>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88404>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88405>>>>>>>                    Increment iItem
88406>>>>>>>                End
88406>>>>>>>>
88406>>>>>>>            End
88406>>>>>>>>
88406>>>>>>>        Loop
88407>>>>>>>>
88407>>>>>>>
88407>>>>>>>        Move False to Err
88408>>>>>>>        Move 0 to LastErr
88409>>>>>>>        Function_Return aAPIColumnsToMove
88410>>>>>>>    End_Function
88411>>>>>>>
88411>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88413>>>>>>>        Integer iSize iCount
88413>>>>>>>        Boolean bOK
88413>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88413>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88414>>>>>>>
88414>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88415>>>>>>>        If (iSize = 0) Begin
88417>>>>>>>            Function_Return True
88418>>>>>>>        End
88418>>>>>>>>
88418>>>>>>>
88418>>>>>>>        Move False to Err
88419>>>>>>>        Decrement iSize
88420>>>>>>>        for iCount from 0 to iSize
88426>>>>>>>>
88426>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88427>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88429>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88430>>>>>>>                If (bOK = True) Begin
88432>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88433>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88434>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88435>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88437>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88438>>>>>>>                        Decrement iSize
88439>>>>>>>                        Move 0 to iCount
88440>>>>>>>                    End
88440>>>>>>>>
88440>>>>>>>                End
88440>>>>>>>>
88440>>>>>>>                Else Begin
88441>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88442>>>>>>>                End
88442>>>>>>>>
88442>>>>>>>            End
88442>>>>>>>>
88442>>>>>>>        Loop
88443>>>>>>>>
88443>>>>>>>
88443>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88444>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88446>>>>>>>            Move 0 to LastErr
88447>>>>>>>        End
88447>>>>>>>>
88447>>>>>>>        Function_Return bOK
88448>>>>>>>    End_Function
88449>>>>>>>
88449>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88449>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88449>>>>>>>    // - The "FROM" field name is <> "TO" field name
88449>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88449>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88449>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88451>>>>>>>        Boolean bShouldRename
88451>>>>>>>        String sFieldNameFrom sFieldNameTo
88451>>>>>>>
88451>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88452>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88453>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88455>>>>>>>            Function_Return False
88456>>>>>>>        End
88456>>>>>>>>
88456>>>>>>>
88456>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88457>>>>>>>//        If (bShouldRename = False) Begin
88457>>>>>>>//            Function_Return False
88457>>>>>>>//        End
88457>>>>>>>//
88457>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88457>>>>>>>//            Function_Return True
88457>>>>>>>//        End
88457>>>>>>>
88457>>>>>>>        Function_Return bShouldRename
88458>>>>>>>    End_Function
88459>>>>>>>
88459>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88459>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88459>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88461>>>>>>>        Integer iCount iSize iRetval
88461>>>>>>>        String sFieldNameFrom
88461>>>>>>>
88461>>>>>>>        Move -1 to iRetval
88462>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88464>>>>>>>            Function_Return iRetval
88465>>>>>>>        End
88465>>>>>>>>
88465>>>>>>>
88465>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88466>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88467>>>>>>>        Decrement iSize
88468>>>>>>>        for iCount from 0 to iSize
88474>>>>>>>>
88474>>>>>>>            // We're only interested in fields other than the passed field/column number:
88474>>>>>>>            If (iCount <> iColumn) Begin
88476>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88478>>>>>>>                    Move (iCount + 1) to iRetval
88479>>>>>>>                End
88479>>>>>>>>
88479>>>>>>>            End
88479>>>>>>>>
88479>>>>>>>        Loop
88480>>>>>>>>
88480>>>>>>>
88480>>>>>>>        Move 0 to LastErr
88481>>>>>>>        Function_Return iRetval
88482>>>>>>>    End_Function
88483>>>>>>>
88483>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88485>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88485>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88486>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88486>>>>>>>        Boolean bRenameField
88486>>>>>>>
88486>>>>>>>        Open hTable
88488>>>>>>>        Move 0 to iItem
88489>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88490>>>>>>>        Decrement iSize
88491>>>>>>>        for iCount from 0 to iSize
88497>>>>>>>>
88497>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88499>>>>>>>                // Check if the field exists in another position (other field number)
88499>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88500>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88501>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88503>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88504>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88505>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88506>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88507>>>>>>>                    Increment iItem
88508>>>>>>>                End
88508>>>>>>>>
88508>>>>>>>            End
88508>>>>>>>>
88508>>>>>>>        Loop
88509>>>>>>>>
88509>>>>>>>
88509>>>>>>>        Move False to Err
88510>>>>>>>        Move 0 to LastErr
88511>>>>>>>        Function_Return aAPIColumnsToRename
88512>>>>>>>    End_Function
88513>>>>>>>
88513>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88515>>>>>>>        Integer iSize iCount
88515>>>>>>>        Boolean bOK
88515>>>>>>>        tAPIColumn[] aColumnsTo
88515>>>>>>>        tAPIColumn[] aColumnsTo
88516>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88516>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88517>>>>>>>
88517>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88518>>>>>>>        If (iSize = 0) Begin
88520>>>>>>>            Function_Return True
88521>>>>>>>        End
88521>>>>>>>>
88521>>>>>>>
88521>>>>>>>        Move False to Err
88522>>>>>>>        Decrement iSize
88523>>>>>>>        For iCount from 0 to iSize
88529>>>>>>>>
88529>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88530>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88531>>>>>>>        Loop
88532>>>>>>>>
88532>>>>>>>
88532>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88533>>>>>>>        Function_Return bOK
88534>>>>>>>    End_Function
88535>>>>>>>
88535>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88537>>>>>>>        Boolean bDateType
88537>>>>>>>
88537>>>>>>>        If (bIsSQLTableTo = True) Begin
88539>>>>>>>            Move (iType = SQL_DATE or iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88540>>>>>>>        End
88540>>>>>>>>
88540>>>>>>>        Else Begin
88541>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88542>>>>>>>        End
88542>>>>>>>>
88542>>>>>>>
88542>>>>>>>        Function_Return bDateType
88543>>>>>>>    End_Function
88544>>>>>>>
88544>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88546>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88546>>>>>>>        Integer iCount2 iColumn2
88546>>>>>>>        Handle hFile
88546>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88546>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88546>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88546>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88546>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88551>>>>>>>        tColumnType ColumnType
88551>>>>>>>        tColumnType ColumnType
88551>>>>>>>
88551>>>>>>>        Move False to Err
88552>>>>>>>        Close hTable
88553>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88554>>>>>>>        If (bIsOpen = False) Begin
88556>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88557>>>>>>>>
88557>>>>>>>            Function_Return False
88558>>>>>>>        End 
88558>>>>>>>>
88558>>>>>>>        
88558>>>>>>>        Get piDbType to iDbType
88559>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88562>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88563>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88564>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88567>>>>>>>
88567>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88568>>>>>>>
88568>>>>>>>        // Before we start to change the table we need to do three things;
88568>>>>>>>        // 1) Insert any new fields
88568>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88569>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88571>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88572>>>>>>>            If (bOK = False) Begin
88574>>>>>>>                Function_Return False
88575>>>>>>>            End
88575>>>>>>>>
88575>>>>>>>            // Update info with changes made.
88575>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88576>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88577>>>>>>>        End
88577>>>>>>>>
88577>>>>>>>
88577>>>>>>>        // 2) Move fields with same names
88577>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88578>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88580>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88581>>>>>>>            If (bOK = False) Begin
88583>>>>>>>                Function_Return False
88584>>>>>>>            End
88584>>>>>>>>
88584>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88585>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88586>>>>>>>        End
88586>>>>>>>>
88586>>>>>>>        
88586>>>>>>>        // 3) Rename fields
88586>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88587>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88589>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88590>>>>>>>            If (bOK = False) Begin
88592>>>>>>>                Function_Return False
88593>>>>>>>            End
88593>>>>>>>>
88593>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88594>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88595>>>>>>>        End
88595>>>>>>>>
88595>>>>>>>
88595>>>>>>>        // Note: Fields will be removed if needed in the Structure_Start/End below.
88595>>>>>>>        // Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88595>>>>>>>
88595>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88595>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88597>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88598>>>>>>>            If (bIsSame = True) Begin
88600>>>>>>>                Function_Return True
88601>>>>>>>            End
88601>>>>>>>>
88601>>>>>>>        End
88601>>>>>>>>
88601>>>>>>>
88601>>>>>>>        Move False to Err
88602>>>>>>>        // We can now continue to make standard field changes:
88602>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88603>>>>>>>        Set Private.phCurrentTable to hTable
88604>>>>>>>        Move hTable to hFile
88605>>>>>>>        Structure_Start hFile sDriverIDTo
88606>>>>>>>
88606>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88607>>>>>>>            Decrement iColumns
88608>>>>>>>            for iCount from 0 to iColumns
88614>>>>>>>>
88614>>>>>>>                Send DoAdvance of ghoProgressBar
88615>>>>>>>
88615>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88616>>>>>>>                Set Private.piCurrentField                  to iColumn
88617>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88618>>>>>>>                If (bIsSame = False) Begin
88620>>>>>>>
88620>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88621>>>>>>>                    If (bFieldExistsFrom = True) Begin
88623>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88624>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88625>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88626>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88627>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88628>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88629>>>>>>>
88629>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88630>>>>>>>                        If (iTypeFrom < -1490) Begin
88632>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88633>>>>>>>                        End
88633>>>>>>>>
88633>>>>>>>
88633>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88633>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88633>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88635>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88636>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88638>>>>>>>                                Move DF_DATE to iTypeFrom
88639>>>>>>>                            End
88639>>>>>>>>
88639>>>>>>>                        End
88639>>>>>>>>
88639>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88642>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88643>>>>>>>                        End
88643>>>>>>>>
88643>>>>>>>
88643>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88644>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88645>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88646>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88647>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88648>>>>>>>
88648>>>>>>>                        Move False to bSkipTypeChange
88649>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88651>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88652>>>>>>>                        End
88652>>>>>>>>
88652>>>>>>>
88652>>>>>>>                        If (bFieldExistsTo = False) Begin
88654>>>>>>>                            Move 0 to iColumn
88655>>>>>>>                            Create_Field hFile At iColumn
88656>>>>>>>                            Set Private.piCurrentField to iColumn
88657>>>>>>>                        End
88657>>>>>>>>
88657>>>>>>>
88657>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88659>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88662>>>>>>>                        End
88662>>>>>>>>
88662>>>>>>>
88662>>>>>>>                        // Note: In MS-SQL it is vital that *nothing* gets changed for e.g. a "datetime" column, else error: 22018 is generated by the SQL backend:
88662>>>>>>>                        //       "Explicit conversion from data type int to datetime2 is not allowed", which will make the update to fail, and all changes for the table is rollbacked. 
88662>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity and bSkipTypeChange = False) Begin
88664>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88667>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88668>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88670>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88671>>>>>>>                            End
88671>>>>>>>>
88671>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88674>>>>>>>                        End
88674>>>>>>>>
88674>>>>>>>
88674>>>>>>>                        If (bSkipTypeChange = False) Begin
88676>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88678>>>>>>>                                If (bIsSQLTableTo = True) Begin
88680>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88683>>>>>>>                                End
88683>>>>>>>>
88683>>>>>>>                                Else Begin                                                   
88684>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88686>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88687>>>>>>>                                    End
88687>>>>>>>>
88687>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88690>>>>>>>                                End
88690>>>>>>>>
88690>>>>>>>                            End
88690>>>>>>>>
88690>>>>>>>                        End
88690>>>>>>>>
88690>>>>>>>
88690>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88691>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88691>>>>>>>                        If (bIsDateType = False and iLengthFrom <> iLengthTo) Begin
88693>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88696>>>>>>>                        End
88696>>>>>>>>
88696>>>>>>>                        // We do want to set the precision for e.g. DateTime2 (can be 3 or 7, but DataFlex can just handle "3").
88696>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
88698>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88701>>>>>>>                        End
88701>>>>>>>>
88701>>>>>>>
88701>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88703>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88703>>>>>>>                            If (bRecnumTable = True) Begin
88705>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88708>>>>>>>                            End
88708>>>>>>>>
88708>>>>>>>
88708>>>>>>>                            // We might need to create an index here.
88708>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88708>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88708>>>>>>>                            // index update checking logic.
88708>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88711>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88713>>>>>>>                                Create_Index hFile at iIndex
88714>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88717>>>>>>>                            End
88717>>>>>>>>
88717>>>>>>>
88717>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88720>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88723>>>>>>>                                // Note: The order here is crucial!
88723>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88726>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88729>>>>>>>                        End
88729>>>>>>>>
88729>>>>>>>                    End
88729>>>>>>>>
88729>>>>>>>                    Else Begin
88730>>>>>>>                        Delete_Field hFile iColumn
88731>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88732>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88733>>>>>>>                        Decrement iCount2
88734>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88734>>>>>>>                        // starting with the array number we just deleted the field for.
88734>>>>>>>                        for iColumn2 from iCount to iCount2
88740>>>>>>>>
88740>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88741>>>>>>>                        Loop
88742>>>>>>>>
88742>>>>>>>                        Decrement iCount
88743>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88744>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88745>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88747>>>>>>>                            Move iColumns to iCount 
88748>>>>>>>                        End
88748>>>>>>>>
88748>>>>>>>                    End
88748>>>>>>>>
88748>>>>>>>                End 
88748>>>>>>>>
88748>>>>>>>                If (Err = True) Begin 
88750>>>>>>>                    Move False to bOK
88751>>>>>>>                    Move iColumns to iCount
88752>>>>>>>                End
88752>>>>>>>>
88752>>>>>>>            Loop
88753>>>>>>>>
88753>>>>>>>
88753>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructuring table..."
88754>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88756>>>>>>>
88756>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88757>>>>>>>        Function_Return (Not(Err))
88758>>>>>>>    End_Function
88759>>>>>>>
88759>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88759>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88761>>>>>>>        Function_Return False
88762>>>>>>>    End_Function
88763>>>>>>>
88763>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88763>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88763>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88763>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88765>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88765>>>>>>>        String sDriverID
88765>>>>>>>        Boolean bOK bExists bIsSQLTable
88765>>>>>>>
88765>>>>>>>        Get AutoConnectionIDLogin to bOK
88766>>>>>>>        Get OpenTableExclusive hTable to bOK
88767>>>>>>>        If (bOK = False) Begin
88769>>>>>>>            Function_Return False
88770>>>>>>>        End
88770>>>>>>>>
88770>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88773>>>>>>>
88773>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88774>>>>>>>            If (bIsSQLTable = True) Begin
88776>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88779>>>>>>>            End
88779>>>>>>>>
88779>>>>>>>
88779>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88782>>>>>>>        Move (iIndexSegments > 0) to bExists
88783>>>>>>>        If (bExists = True) Begin
88785>>>>>>>            Function_Return True
88786>>>>>>>        End
88786>>>>>>>>
88786>>>>>>>
88786>>>>>>>        Move -1 to iSegment1
88787>>>>>>>        Move -1 to iSegment2
88788>>>>>>>        Move -1 to iSegment3
88789>>>>>>>        Move -1 to iSegment4
88790>>>>>>>        Move -1 to iSegment5
88791>>>>>>>        Move -1 to iSegment6
88792>>>>>>>        Move -1 to iSegment7
88793>>>>>>>        Move -1 to iSegment8
88794>>>>>>>        Move -1 to iSegment9
88795>>>>>>>        Move -1 to iSegment10
88796>>>>>>>
88796>>>>>>>        If (num_arguments > 3) Begin
88798>>>>>>>            Move iSgmnt1 to iSegment1
88799>>>>>>>        End
88799>>>>>>>>
88799>>>>>>>        If (num_arguments > 4) Begin
88801>>>>>>>            Move iSgmnt2 to iSegment2
88802>>>>>>>        End
88802>>>>>>>>
88802>>>>>>>        If (num_arguments > 5) Begin
88804>>>>>>>            Move iSgmnt3 to iSegment3
88805>>>>>>>        End
88805>>>>>>>>
88805>>>>>>>        If (num_arguments > 6) Begin
88807>>>>>>>            Move iSgmnt4 to iSegment4
88808>>>>>>>        End
88808>>>>>>>>
88808>>>>>>>        If (num_arguments > 7) Begin
88810>>>>>>>            Move iSgmnt5 to iSegment5
88811>>>>>>>        End
88811>>>>>>>>
88811>>>>>>>        If (num_arguments > 8) Begin
88813>>>>>>>            Move iSgmnt6 to iSegment6
88814>>>>>>>        End
88814>>>>>>>>
88814>>>>>>>        If (num_arguments > 9) Begin
88816>>>>>>>            Move iSgmnt7 to iSegment7
88817>>>>>>>        End
88817>>>>>>>>
88817>>>>>>>        If (num_arguments > 10) Begin
88819>>>>>>>            Move iSgmnt8 to iSegment8
88820>>>>>>>        End
88820>>>>>>>>
88820>>>>>>>        If (num_arguments > 11) Begin
88822>>>>>>>            Move iSgmnt9 to iSegment9
88823>>>>>>>        End
88823>>>>>>>>
88823>>>>>>>        If (num_arguments > 12) Begin
88825>>>>>>>            Move iSgmnt10 to iSegment10
88826>>>>>>>        End
88826>>>>>>>>
88826>>>>>>>
88826>>>>>>>        Move False to Err
88827>>>>>>>        Move hTable to iTableNo
88828>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88829>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88830>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88831>>>>>>>
88831>>>>>>>        // We start by deleting the index, if it exists.
88831>>>>>>>        If (bExists = True) Begin
88833>>>>>>>            Structure_Start hTable sDriverID
88834>>>>>>>                Delete_Index iTableNo iIndex
88835>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88836>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88838>>>>>>>        End
88838>>>>>>>>
88838>>>>>>>
88838>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88839>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88840>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88841>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88842>>>>>>>        Move False to Err
88843>>>>>>>        Move 0 to LastErr
88844>>>>>>>
88844>>>>>>>        // Need to re-open if index deleted.
88844>>>>>>>        Move iTableNo to hTable
88845>>>>>>>        Get OpenTableExclusive hTable to bOK
88846>>>>>>>        If (bOK = False) Begin
88848>>>>>>>            Function_Return False
88849>>>>>>>        End
88849>>>>>>>>
88849>>>>>>>
88849>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88850>>>>>>>        Structure_Start hTable sDriverID
88851>>>>>>>            Create_Index hTable At iIndex
88852>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88855>>>>>>>
88855>>>>>>>            If (iSgmnt1 <> -1) Begin
88857>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88860>>>>>>>            End
88860>>>>>>>>
88860>>>>>>>            If (iSegment2 <> -1) Begin
88862>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88865>>>>>>>            End
88865>>>>>>>>
88865>>>>>>>            If (iSegment3 <> -1) Begin
88867>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88870>>>>>>>            End
88870>>>>>>>>
88870>>>>>>>            If (iSegment4 <> -1) Begin
88872>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88875>>>>>>>            End
88875>>>>>>>>
88875>>>>>>>            If (iSegment5 <> -1) Begin
88877>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88880>>>>>>>            End
88880>>>>>>>>
88880>>>>>>>            If (iSegment6 <> -1) Begin
88882>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88885>>>>>>>            End
88885>>>>>>>>
88885>>>>>>>            If (iSegment7 <> -1) Begin
88887>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88890>>>>>>>            End
88890>>>>>>>>
88890>>>>>>>            If (iSegment8 <> -1) Begin
88892>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88895>>>>>>>            End
88895>>>>>>>>
88895>>>>>>>            If (iSegment9 <> -1) Begin
88897>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88900>>>>>>>            End
88900>>>>>>>>
88900>>>>>>>            If (iSegment10 <> -1) Begin
88902>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88905>>>>>>>            End
88905>>>>>>>>
88905>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88906>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88908>>>>>>>
88908>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88909>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88910>>>>>>>
88910>>>>>>>        Function_Return (Err = False)
88911>>>>>>>    End_Function
88912>>>>>>>
88912>>>>>>>    // Example:
88912>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88912>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88912>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88914>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88914>>>>>>>        String sDriverID
88914>>>>>>>        Boolean bOK bIsSQLTable
88914>>>>>>>
88914>>>>>>>        Get AutoConnectionIDLogin to bOK
88915>>>>>>>
88915>>>>>>>        Move False to Err
88916>>>>>>>        Move hTable to iTableNo
88917>>>>>>>        Get OpenTableExclusive hTable to bOK
88918>>>>>>>        If (bOK = False) Begin
88920>>>>>>>            Function_Return False
88921>>>>>>>        End
88921>>>>>>>>
88921>>>>>>>
88921>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88924>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88925>>>>>>>            If (bIsSQLTable = True) Begin
88927>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88930>>>>>>>            End
88930>>>>>>>>
88930>>>>>>>
88930>>>>>>>        // We start by deleting the index
88930>>>>>>>        Structure_Start hTable sDriverID
88931>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88932>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88933>>>>>>>            Delete_Index iTableNo iIndex
88934>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88935>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88936>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88938>>>>>>>
88938>>>>>>>        Move False to Err
88939>>>>>>>        Move iTableNo to hTable
88940>>>>>>>        Get OpenTableExclusive hTable to bOK
88941>>>>>>>        If (bOK = False) Begin
88943>>>>>>>            Function_Return False
88944>>>>>>>        End
88944>>>>>>>>
88944>>>>>>>
88944>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88945>>>>>>>        Structure_Start hTable sDriverID
88946>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88947>>>>>>>
88947>>>>>>>            Create_Index hTable at iIndex
88948>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88951>>>>>>>
88951>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88957>>>>>>>>
88957>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88960>>>>>>>            Loop
88961>>>>>>>>
88961>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88963>>>>>>>
88963>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88964>>>>>>>
88964>>>>>>>        Function_Return (Err = False)
88965>>>>>>>    End_Function
88966>>>>>>>
88966>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88968>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88968>>>>>>>        String sDriverID sSQLIndexName
88968>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88968>>>>>>>
88968>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88969>>>>>>>        If (iSegmentsFrom = 0) Begin
88971>>>>>>>            Function_Return False
88972>>>>>>>        End
88972>>>>>>>>
88972>>>>>>>
88972>>>>>>>        Get AutoConnectionIDLogin to bOK
88973>>>>>>>        Move False to Err
88974>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88975>>>>>>>        If (bIsOpen = False) Begin
88977>>>>>>>            Function_Return False
88978>>>>>>>        End
88978>>>>>>>>
88978>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88981>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88982>>>>>>>            If (bIsSQLTable = True) Begin
88984>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88987>>>>>>>            End
88987>>>>>>>>
88987>>>>>>>
88987>>>>>>>        Move 0     to iSegmentsTo
88988>>>>>>>        Move 0     to iSQLIndexType
88989>>>>>>>        Move ""    to sSQLIndexName
88990>>>>>>>        Move False to bIsSQLTemporaryIndex
88991>>>>>>>        Move False to bIsSQLPrimaryKey
88992>>>>>>>        Move False to bIsSQLClustered
88993>>>>>>>
88993>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88994>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88997>>>>>>>        Move (iSegmentsTo > 0) to bExists
88998>>>>>>>        If (bExists = True) Begin
89000>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
89002>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
89005>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89008>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89009>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89012>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89015>>>>>>>            End
89015>>>>>>>>
89015>>>>>>>        End
89015>>>>>>>>
89015>>>>>>>
89015>>>>>>>        Move hTable to iTableNo
89016>>>>>>>        Move False to Err
89017>>>>>>>        Move 0 to LastErr
89018>>>>>>>
89018>>>>>>>        Structure_Start hTable sDriverID
89019>>>>>>>            If (bExists = True) Begin
89021>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
89022>>>>>>>            End
89022>>>>>>>>
89022>>>>>>>
89022>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
89023>>>>>>>
89023>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89025>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
89028>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89031>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89034>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89037>>>>>>>                End
89037>>>>>>>>
89037>>>>>>>
89037>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89040>>>>>>>
89040>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
89046>>>>>>>>
89046>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
89047>>>>>>>                If (iFieldFrom <> -1 ) Begin
89049>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89052>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
89055>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
89058>>>>>>>                End
89058>>>>>>>>
89058>>>>>>>            Loop
89059>>>>>>>>
89059>>>>>>>
89059>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89060>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89062>>>>>>>
89062>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89063>>>>>>>
89063>>>>>>>        Function_Return (Err = False)
89064>>>>>>>    End_Function
89065>>>>>>>
89065>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
89065>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
89065>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
89067>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
89067>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
89067>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
89067>>>>>>>
89067>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
89068>>>>>>>        
89068>>>>>>>        If (bIsSQLDriver = False) Begin
89070>>>>>>>            Function_Return False
89071>>>>>>>        End
89071>>>>>>>>
89071>>>>>>>
89071>>>>>>>        Move False to Err
89072>>>>>>>        Move hTable to iTableNo
89073>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89076>>>>>>>        for iCount from 0 to iLastIndex
89082>>>>>>>>
89082>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
89085>>>>>>>            Move (iSegments > 0) to bExists
89086>>>>>>>            If (bExists = True) Begin
89088>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
89091>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
89093>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
89094>>>>>>>                    Structure_Start iTableNo sDriverID
89095>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
89098>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89100>>>>>>>                    Open hTable
89102>>>>>>>                End
89102>>>>>>>>
89102>>>>>>>            End
89102>>>>>>>>
89102>>>>>>>        Loop
89103>>>>>>>>
89103>>>>>>>
89103>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89106>>>>>>>        If (bIsOpen = False) Begin
89108>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89109>>>>>>>        End
89109>>>>>>>>
89109>>>>>>>        If (bIsOpen = False) Begin
89111>>>>>>>            Function_Return False
89112>>>>>>>        End
89112>>>>>>>>
89112>>>>>>>
89112>>>>>>>        Function_Return (Err = False)
89113>>>>>>>    End_Function
89114>>>>>>>
89114>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89114>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89114>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89116>>>>>>>        Integer iSize iCount
89116>>>>>>>        Integer iRetVal
89116>>>>>>>
89116>>>>>>>        Move 0 to iRetVal
89117>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89120>>>>>>>        If (iRetVal = 0) Begin
89122>>>>>>>            Function_Return 0
89123>>>>>>>        End
89123>>>>>>>>
89123>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89124>>>>>>>        Decrement iSize
89125>>>>>>>        for iCount from 0 to iSize
89131>>>>>>>>
89131>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89133>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89135>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89136>>>>>>>                End
89136>>>>>>>>
89136>>>>>>>            End
89136>>>>>>>>
89136>>>>>>>        Loop
89137>>>>>>>>
89137>>>>>>>
89137>>>>>>>        Function_Return iRetVal
89138>>>>>>>    End_Function
89139>>>>>>>
89139>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89141>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89141>>>>>>>        Boolean bIsSQLTable
89141>>>>>>>        
89141>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89142>>>>>>>            If (bIsSQLTable = True) Begin
89144>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89147>>>>>>>            End
89147>>>>>>>>
89147>>>>>>>
89147>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89150>>>>>>>        If (iSegment = iNumSegments) Begin
89152>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89152>>>>>>>        End
89152>>>>>>>>
89152>>>>>>>
89152>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89155>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89161>>>>>>>>
89161>>>>>>>                //*** Move index segment attributes
89161>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89164>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89167>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89170>>>>>>>
89170>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89173>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89176>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89179>>>>>>>            Loop
89180>>>>>>>>
89180>>>>>>>
89180>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89183>>>>>>>        End
89183>>>>>>>>
89183>>>>>>>
89183>>>>>>>        Function_Return (Err = False)
89184>>>>>>>    End_Function
89185>>>>>>>
89185>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89187>>>>>>>        Integer iCount iSize iIndex
89187>>>>>>>        String sDriverID
89187>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
89187>>>>>>>
89187>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
89188>>>>>>>        If (iSize = 0) Begin
89190>>>>>>>            Function_Return True
89191>>>>>>>        End
89191>>>>>>>>
89191>>>>>>>
89191>>>>>>>        Get AutoConnectionIDLogin to bOK
89192>>>>>>>        Move False to Err
89193>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89196>>>>>>>        If (bIsOpen = False) Begin
89198>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89199>>>>>>>            If (bIsOpen = False) Begin
89201>>>>>>>                Function_Return False
89202>>>>>>>            End
89202>>>>>>>>
89202>>>>>>>        End
89202>>>>>>>>
89202>>>>>>>
89202>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89205>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89206>>>>>>>            If (bIsSQLTable = True) Begin
89208>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89211>>>>>>>            End
89211>>>>>>>>
89211>>>>>>>
89211>>>>>>>        Move False to Err
89212>>>>>>>        Move 0 to LastErr
89213>>>>>>>        Decrement iSize
89214>>>>>>>
89214>>>>>>>        Structure_Start hTable sDriverID
89215>>>>>>>            for iCount from 0 to iSize
89221>>>>>>>>
89221>>>>>>>//                Move False to bIsSQLPrimaryKey
89221>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
89221>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89221>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89221>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89221>>>>>>>//                #ENDIF
89221>>>>>>>                // We can't delete if this is a primary key index:
89221>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
89221>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89222>>>>>>>                    Delete_Index hTable iIndex
89223>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89223>>>>>>>//                End
89223>>>>>>>            Loop
89224>>>>>>>>
89224>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89225>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89227>>>>>>>//        Move False to Err
89227>>>>>>>        Move 0 to LastErr
89228>>>>>>>
89228>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89229>>>>>>>        Function_Return (Err = False)
89230>>>>>>>    End_Function
89231>>>>>>>
89231>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89233>>>>>>>        Boolean bOK
89233>>>>>>>
89233>>>>>>>        Get AutoConnectionIDLogin to bOK
89234>>>>>>>        Move False to Err
89235>>>>>>>        Get OpenTableExclusive hTable to bOK
89236>>>>>>>        If (bOK = False) Begin
89238>>>>>>>            Function_Return False
89239>>>>>>>        End
89239>>>>>>>>
89239>>>>>>>        Structure_Start hTable
89240>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89243>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89244>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89246>>>>>>>
89246>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89247>>>>>>>        Function_Return (Err = False)
89248>>>>>>>    End_Function
89249>>>>>>>
89249>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89251>>>>>>>        Integer iCase
89251>>>>>>>        Boolean bOK
89251>>>>>>>
89251>>>>>>>        If (bUppercase = True) Begin
89253>>>>>>>            Move DF_CASE_IGNORED to iCase
89254>>>>>>>        End
89254>>>>>>>>
89254>>>>>>>        Else Begin
89255>>>>>>>            Move DF_CASE_USED to iCase
89256>>>>>>>        End
89256>>>>>>>>
89256>>>>>>>
89256>>>>>>>        Get AutoConnectionIDLogin to bOK
89257>>>>>>>        Move False to Err
89258>>>>>>>        Get OpenTableExclusive hTable to bOK
89259>>>>>>>        If (bOK = False) Begin
89261>>>>>>>            Function_Return False
89262>>>>>>>        End
89262>>>>>>>>
89262>>>>>>>        Structure_Start hTable
89263>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89266>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89267>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89269>>>>>>>
89269>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89270>>>>>>>        Function_Return (Err = False)
89271>>>>>>>    End_Function
89272>>>>>>>
89272>>>>>>>    // To delete an index
89272>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89274>>>>>>>        Integer iTableNo iNumSegments
89274>>>>>>>        String sDriverID
89274>>>>>>>        Boolean bOK bIsSQLTable
89274>>>>>>>
89274>>>>>>>        Get AutoConnectionIDLogin to bOK
89275>>>>>>>        Move False to Err
89276>>>>>>>        Move hTable to iTableNo
89277>>>>>>>        Get OpenTableExclusive hTable to bOK
89278>>>>>>>        If (bOK = False) Begin
89280>>>>>>>            Function_Return False
89281>>>>>>>        End
89281>>>>>>>>
89281>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89284>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89285>>>>>>>            If (bIsSQLTable = True) Begin
89287>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89290>>>>>>>            End
89290>>>>>>>>
89290>>>>>>>
89290>>>>>>>        // Check to see if the index exists or not...
89290>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89293>>>>>>>        If (iNumSegments = 0) Begin
89295>>>>>>>            Function_Return True // Then nothing to do.
89296>>>>>>>        End
89296>>>>>>>>
89296>>>>>>>
89296>>>>>>>        Structure_Start hTable sDriverID
89297>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89298>>>>>>>            Delete_Index iTableNo iIndex
89299>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89300>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89301>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89303>>>>>>>
89303>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89304>>>>>>>        Function_Return (Err = False)
89305>>>>>>>    End_Function
89306>>>>>>>
89306>>>>>>>    // Delete an Index Segment
89306>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89308>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89308>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89308>>>>>>>        Integer iIndexType
89308>>>>>>>        String sDriverID
89308>>>>>>>
89308>>>>>>>        Get AutoConnectionIDLogin to bOK
89309>>>>>>>        Move False to Err
89310>>>>>>>
89310>>>>>>>        Get OpenTableExclusive hTable to bOK
89311>>>>>>>        If (bOK = False) Begin
89313>>>>>>>            Function_Return False
89314>>>>>>>        End
89314>>>>>>>>
89314>>>>>>>
89314>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89315>>>>>>>            If (bIsSQLTable = True) Begin
89317>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89320>>>>>>>            End
89320>>>>>>>>
89320>>>>>>>
89320>>>>>>>        // Check to see if the index exists or not...
89320>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89323>>>>>>>        If (iNumSegments = 0) Begin
89325>>>>>>>            Function_Return False
89326>>>>>>>        End
89326>>>>>>>>
89326>>>>>>>
89326>>>>>>>        Move False to bIndexTemporary
89327>>>>>>>        Get psDriverID to sDriverID
89328>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89329>>>>>>>        If (bSQLDriver) Begin
89331>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89334>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89337>>>>>>>                Move True to bIndexTemporary
89338>>>>>>>        End
89338>>>>>>>>
89338>>>>>>>
89338>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89338>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89340>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89343>>>>>>>            If (iSegment = iNumSegments) Begin
89345>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89348>>>>>>>            End
89348>>>>>>>>
89348>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89351>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89357>>>>>>>>
89357>>>>>>>                    //*** Move index segment attributes
89357>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89360>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89363>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89366>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89369>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89372>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89375>>>>>>>                Loop
89376>>>>>>>>
89376>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89379>>>>>>>            End
89379>>>>>>>>
89379>>>>>>>        End
89379>>>>>>>>
89379>>>>>>>
89379>>>>>>>        Else Begin
89380>>>>>>>           Structure_Start hTable
89381>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89384>>>>>>>               If (iSegment = iNumSegments) Begin
89386>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89389>>>>>>>               End
89389>>>>>>>>
89389>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89392>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89398>>>>>>>>
89398>>>>>>>                       //*** Move index segment attributes
89398>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89401>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89404>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89407>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89410>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89413>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89416>>>>>>>                   Loop
89417>>>>>>>>
89417>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89420>>>>>>>               End
89420>>>>>>>>
89420>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89421>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89423>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89424>>>>>>>        End
89424>>>>>>>>
89424>>>>>>>
89424>>>>>>>        Function_Return (Err = False)
89425>>>>>>>    End_Function
89426>>>>>>>
89426>>>>>>>    // Add/Insert an Index Segment
89426>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89428>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89428>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89428>>>>>>>        Integer iIndexType
89428>>>>>>>        String sDriverId
89428>>>>>>>
89428>>>>>>>        Get AutoConnectionIDLogin to bOK
89429>>>>>>>        Move False to Err
89430>>>>>>>
89430>>>>>>>        Get OpenTableExclusive hTable to bOK
89431>>>>>>>        If (bOK = False) Begin
89433>>>>>>>            Function_Return False
89434>>>>>>>        End
89434>>>>>>>>
89434>>>>>>>
89434>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89435>>>>>>>            If (bIsSQLTable = True) Begin
89437>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89440>>>>>>>            End
89440>>>>>>>>
89440>>>>>>>
89440>>>>>>>        Move False to bIndexTemporary
89441>>>>>>>        // Check to see if the index exists or not...
89441>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89444>>>>>>>        If (iNumSegments = 0) Begin
89446>>>>>>>            Function_Return False
89447>>>>>>>        End
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        Get psDriverID to sDriverID
89448>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89449>>>>>>>        If (bSQLDriver) Begin
89451>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89454>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89457>>>>>>>                Move True to bIndexTemporary
89458>>>>>>>        End
89458>>>>>>>>
89458>>>>>>>
89458>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89458>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89460>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89463>>>>>>>
89463>>>>>>>           If (iSegment > iNumSegments) Begin
89465>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89468>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89469>>>>>>>           End
89469>>>>>>>>
89469>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89472>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89475>>>>>>>               Move iNumSegments to iCurSegment
89476>>>>>>>
89476>>>>>>>               While (iCurSegment > iSegment)
89480>>>>>>>                   //*** Move index segment attributes
89480>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89483>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89486>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89489>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89492>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89495>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89498>>>>>>>                   Decrement iCurSegment
89499>>>>>>>               Loop
89500>>>>>>>>
89500>>>>>>>
89500>>>>>>>               //*** Now set new segment attributes
89500>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89503>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89506>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89509>>>>>>>           End
89509>>>>>>>>
89509>>>>>>>        End
89509>>>>>>>>
89509>>>>>>>
89509>>>>>>>        Else Begin
89510>>>>>>>        Structure_Start hTable
89511>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89514>>>>>>>
89514>>>>>>>            If (iSegment > iNumSegments) Begin
89516>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89519>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89520>>>>>>>            End
89520>>>>>>>>
89520>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89523>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89526>>>>>>>                Move iNumSegments to iCurSegment
89527>>>>>>>
89527>>>>>>>                While (iCurSegment > iSegment)
89531>>>>>>>                    //*** Move index segment attributes
89531>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89534>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89537>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89540>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89543>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89546>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89549>>>>>>>                    Decrement iCurSegment
89550>>>>>>>                Loop
89551>>>>>>>>
89551>>>>>>>
89551>>>>>>>                //*** Now set new segment attributes
89551>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89554>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89557>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89560>>>>>>>            End
89560>>>>>>>>
89560>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89561>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89563>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89564>>>>>>>        End
89564>>>>>>>>
89564>>>>>>>
89564>>>>>>>        Function_Return (Err = False)
89565>>>>>>>    End_Function
89566>>>>>>>
89566>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89566>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89568>>>>>>>        Function_Return False
89569>>>>>>>    End_Function  
89570>>>>>>>    
89570>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89570>>>>>>>    // for an SQL conversion.
89570>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89572>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89572>>>>>>>        
89572>>>>>>>        Move True to bConvertTo30FormatbOK
89573>>>>>>>        Move True to bRepairAndReindexOK
89574>>>>>>>        Move True to bFixBogusDatesOK
89575>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89576>>>>>>>        
89576>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89578>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89579>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89580>>>>>>>        End                                                                                
89580>>>>>>>>
89580>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89582>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89583>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89584>>>>>>>        End
89584>>>>>>>>
89584>>>>>>>        If (bConvertTo30Format = True) Begin
89586>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89587>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89588>>>>>>>        End                                                 
89588>>>>>>>>
89588>>>>>>>        If (bRepairAndReindex = True) Begin
89590>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89591>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89592>>>>>>>        End  
89592>>>>>>>>
89592>>>>>>>        If (bFixBogusDates = True) Begin
89594>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89595>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89596>>>>>>>        End                                    
89596>>>>>>>>
89596>>>>>>>        
89596>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89597>>>>>>>    End_Function
89598>>>>>>>
89598>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89600>>>>>>>        Boolean bOK bFlexErrs bTemp
89600>>>>>>>        Handle hTable
89600>>>>>>>        String sTableName
89600>>>>>>>        Integer iCount iSize
89600>>>>>>>        
89600>>>>>>>        Move True to bOK
89601>>>>>>>        Move 0 to hTable    
89602>>>>>>>
89602>>>>>>>        Get UtilFilelistNoOfTables to iSize
89603>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89604>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89605>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89606>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89607>>>>>>>
89607>>>>>>>        Repeat
89607>>>>>>>>
89607>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89608>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89609>>>>>>>            Increment iCount
89610>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89613>>>>>>>            If (hTable > 0) Begin
89615>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89618>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89619>>>>>>>                If (bFlexErrs = False) Begin
89621>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89622>>>>>>>                    If (bTemp = False) Begin
89624>>>>>>>                        Move False to bOK
89625>>>>>>>                    End
89625>>>>>>>>
89625>>>>>>>                End
89625>>>>>>>>
89625>>>>>>>            End
89625>>>>>>>>
89625>>>>>>>        Until (hTable = 0)
89627>>>>>>>        
89627>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89628>>>>>>>        Function_Return bOK
89629>>>>>>>    End_Function
89630>>>>>>>    
89630>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89630>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89630>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89630>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89632>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89632>>>>>>>        String sRevision
89632>>>>>>>        
89632>>>>>>>        Get AutoConnectionIDLogin to bOK
89633>>>>>>>        If (bOK = False) Begin
89635>>>>>>>            Function_Return True
89636>>>>>>>        End
89636>>>>>>>>
89636>>>>>>>        Get OpenTableExclusive hTable to bOK
89637>>>>>>>        If (bOK = False) Begin
89639>>>>>>>            Function_Return True
89640>>>>>>>        End
89640>>>>>>>>
89640>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89641>>>>>>>        If (bIsEmbedded = False) Begin
89643>>>>>>>            Function_Return True
89644>>>>>>>        End                             
89644>>>>>>>>
89644>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89645>>>>>>>        If (bIsAlias = True) Begin
89647>>>>>>>            Function_Return True
89648>>>>>>>        End                     
89648>>>>>>>>
89648>>>>>>>        
89648>>>>>>>        Move False to Err
89649>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89652>>>>>>>        If (sRevision contains "2.3") Begin
89654>>>>>>>            Move False to Err
89655>>>>>>>            Set Private.phCurrentTable to hTable
89656>>>>>>>            Structure_Start hTable    
89657>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89660>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89661>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89663>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89664>>>>>>>        End
89664>>>>>>>>
89664>>>>>>>        
89664>>>>>>>        Function_Return (Err = False)
89665>>>>>>>    End_Function
89666>>>>>>>
89666>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89668>>>>>>>        Boolean bIgnore bExists bOK bResponse
89668>>>>>>>        Handle hTable   
89668>>>>>>>        String sTableName
89668>>>>>>>        
89668>>>>>>>        Move False to Err 
89669>>>>>>>        Move True to bOK
89670>>>>>>>        Move 0 to hTable
89671>>>>>>>        Repeat
89671>>>>>>>>
89671>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89674>>>>>>>            If (hTable > 0) Begin
89676>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89679>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89680>>>>>>>                If (bIgnore = False) Begin
89682>>>>>>>                    Get _UtilTableExists hTable to bExists
89683>>>>>>>                    If (bExists = False) Begin
89685>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89686>>>>>>>                        If (bResponse = False) Begin
89688>>>>>>>                            Move False to bOK
89689>>>>>>>                        End
89689>>>>>>>>
89689>>>>>>>                        
89689>>>>>>>                    End
89689>>>>>>>>
89689>>>>>>>                End
89689>>>>>>>>
89689>>>>>>>            End
89689>>>>>>>>
89689>>>>>>>        Until (hTable = 0)                     
89691>>>>>>>        
89691>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89692>>>>>>>        Function_Return bOK
89693>>>>>>>    End_Function
89694>>>>>>>    
89694>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89694>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89694>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89694>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89694>>>>>>>    //
89694>>>>>>>    // The root of the problem is the following:
89694>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89694>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89694>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89694>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89694>>>>>>>    // an SQL error will be thrown;
89694>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89694>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89696>>>>>>>        Boolean bOK bIsAlias bIsSQL
89696>>>>>>>        Integer iCount iSize iDateSize
89696>>>>>>>        Handle hTable
89696>>>>>>>        String sLogicalName
89696>>>>>>>        Integer[] aTablesToCheck aDateFields
89698>>>>>>>
89698>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89699>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89700>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89701>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89702>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89703>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89704>>>>>>>
89704>>>>>>>        Move True to bOK
89705>>>>>>>        Decrement iSize
89706>>>>>>>        for iCount from 0 to iSize
89712>>>>>>>>
89712>>>>>>>            Move aTablesToCheck[iCount] to hTable
89713>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89714>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89715>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89716>>>>>>>
89716>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89719>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89720>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89721>>>>>>>
89721>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89723>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89724>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89725>>>>>>>                If (iDateSize > 0) Begin
89727>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89728>>>>>>>                    Close hTable
89729>>>>>>>                End
89729>>>>>>>>
89729>>>>>>>            End
89729>>>>>>>>
89729>>>>>>>        Loop
89730>>>>>>>>
89730>>>>>>>
89730>>>>>>>        Close DF_ALL
89731>>>>>>>        Function_Return bOK
89732>>>>>>>    End_Function
89733>>>>>>>
89733>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89733>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89735>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89737>>>>>>>        Integer iSize iCount iType
89737>>>>>>>        Boolean bOpen bOK
89737>>>>>>>        
89737>>>>>>>        Get _UtilTableExists hTable to bOK
89738>>>>>>>        If (bOK = False) Begin
89740>>>>>>>            Set Private.phCurrentTable to hTable
89741>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89742>>>>>>>>
89742>>>>>>>            Function_Return aDateFieldsEmpty
89743>>>>>>>        End
89743>>>>>>>>
89743>>>>>>>        Set Private.phCurrentTable to hTable
89744>>>>>>>        Set Private.piCurrentField to 0
89745>>>>>>>
89745>>>>>>>        Open hTable
89747>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89750>>>>>>>        If (bOpen = False) Begin
89752>>>>>>>            Function_Return aDateFieldsEmpty
89753>>>>>>>        End
89753>>>>>>>>
89753>>>>>>>
89753>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89756>>>>>>>        For iCount from 1 to iSize
89762>>>>>>>>
89762>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89765>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89767>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89768>>>>>>>            End
89768>>>>>>>>
89768>>>>>>>        Loop
89769>>>>>>>>
89769>>>>>>>
89769>>>>>>>        Function_Return aDateFields
89770>>>>>>>    End_Function
89771>>>>>>>
89771>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89771>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89771>>>>>>>    // and the record is saved
89771>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89771>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89771>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89773>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89773>>>>>>>        String sDriverID sDateMin
89773>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89773>>>>>>>        Date dDate dDateMin
89773>>>>>>>        Integer[] iaChangeField
89774>>>>>>>
89774>>>>>>>        Get _UtilTableExists hTable to bOK
89775>>>>>>>        // I believe we should just skip files not found and not report an error.
89775>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89775>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89775>>>>>>>        // Especially considering that this call is probably done at the very
89775>>>>>>>        // beginning of a DUF update.
89775>>>>>>>        If (bOK = False) Begin
89777>>>>>>>//            Set Private.phCurrentTable to hTable
89777>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89777>>>>>>>//            Function_Return False
89777>>>>>>>            Function_Return True
89778>>>>>>>        End
89778>>>>>>>>
89778>>>>>>>
89778>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89778>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89778>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89781>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89784>>>>>>>
89784>>>>>>>//        Send SetAllIndexesToBatch hTable True
89784>>>>>>>        Open hTable
89786>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89789>>>>>>>        If (bOpened = False) Begin
89791>>>>>>>            Function_Return False
89792>>>>>>>        End
89792>>>>>>>>
89792>>>>>>>        
89792>>>>>>>        Set Private.phCurrentTable to hTable
89793>>>>>>>        Move 0 to iRecord
89794>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89795>>>>>>>        Decrement iSize
89796>>>>>>>
89796>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89799>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89800>>>>>>>        If (iDriverIndex <> 0) Begin
89802>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89805>>>>>>>            If (sDateMin = "") Begin
89807>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89808>>>>>>>            End
89808>>>>>>>>
89808>>>>>>>            Else Begin
89809>>>>>>>                If (IsDate(sDateMin)) Begin
89811>>>>>>>                    Move sDateMin to dDateMin
89812>>>>>>>                End
89812>>>>>>>>
89812>>>>>>>                Else Begin
89813>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89814>>>>>>>                End
89814>>>>>>>>
89814>>>>>>>            End
89814>>>>>>>>
89814>>>>>>>        End
89814>>>>>>>>
89814>>>>>>>        Else Begin
89815>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89816>>>>>>>        End
89816>>>>>>>>
89816>>>>>>>
89816>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89819>>>>>>>        Set piPosition   of ghoProgressBar to 0
89820>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89821>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89822>>>>>>>        Move False to Err
89823>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89824>>>>>>>
89824>>>>>>>        Clear hTable
89825>>>>>>>        Repeat
89825>>>>>>>>
89825>>>>>>>            Vfind hTable 0 GT
89827>>>>>>>            Move Found to bFound
89828>>>>>>>            If (bFound = True) Begin
89830>>>>>>>                Move False to bSaveChanges
89831>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89832>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89833>>>>>>>                Decrement iSize
89834>>>>>>>                For iCount from 0 to iSize
89840>>>>>>>>
89840>>>>>>>                    Move aDateFields[iCount] to iField
89841>>>>>>>                    Get_Field_Value hTable iField to dDate
89844>>>>>>>                    If (bFixZeroDates = True) Begin
89846>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89847>>>>>>>                    End
89847>>>>>>>>
89847>>>>>>>                    Else Begin
89848>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89849>>>>>>>                    End
89849>>>>>>>>
89849>>>>>>>                    If (bChange = True) Begin
89851>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89852>>>>>>>                    End
89852>>>>>>>>
89852>>>>>>>                Loop
89853>>>>>>>>
89853>>>>>>>
89853>>>>>>>                // Only change Date fields that needs to be changed.
89853>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89855>>>>>>>                    Reread hTable
89859>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89860>>>>>>>                        Decrement iSize
89861>>>>>>>                        For iCount from 0 to iSize
89867>>>>>>>>
89867>>>>>>>                            Move iaChangeField[iCount] to iField
89868>>>>>>>                            Set Private.piCurrentField to iField
89869>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89872>>>>>>>                        Loop
89873>>>>>>>>
89873>>>>>>>                        Move False to Err
89874>>>>>>>                        SaveRecord hTable
89875>>>>>>>                    Unlock
89876>>>>>>>>
89876>>>>>>>                End
89876>>>>>>>>
89876>>>>>>>
89876>>>>>>>                Increment iRecord
89877>>>>>>>                // Increment the StatusPanel counter and check the
89877>>>>>>>                // cancel status every 100 records rather than every
89877>>>>>>>                // record, it's way faster.
89877>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89879>>>>>>>                    Send DoAdvance of ghoProgressBar
89880>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89881>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89882>>>>>>>                End
89882>>>>>>>>
89882>>>>>>>            End
89882>>>>>>>>
89882>>>>>>>        Until (bFound = False)
89884>>>>>>>
89884>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89887>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89889>>>>>>>            Send SetAllIndexesToBatch hTable False
89890>>>>>>>        End
89890>>>>>>>>
89890>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89891>>>>>>>
89891>>>>>>>        Function_Return (Err = False)
89892>>>>>>>    End_Function
89893>>>>>>>
89893>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89893>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89893>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89895>>>>>>>        Boolean bIsSame
89895>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89895>>>>>>>
89895>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89896>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89897>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89898>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89899>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89900>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89901>>>>>>>
89901>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89903>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89904>>>>>>>        End
89904>>>>>>>>
89904>>>>>>>        Else Begin
89905>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89906>>>>>>>        End
89906>>>>>>>>
89906>>>>>>>        If (bIsSame = False) Begin
89908>>>>>>>            Function_Return False
89909>>>>>>>        End
89909>>>>>>>>
89909>>>>>>>
89909>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89910>>>>>>>        If (bIsSame = False) Begin
89912>>>>>>>            Function_Return False
89913>>>>>>>        End
89913>>>>>>>>
89913>>>>>>>
89913>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89914>>>>>>>        If (bIsSame = False) Begin
89916>>>>>>>            Function_Return False
89917>>>>>>>        End
89917>>>>>>>>
89917>>>>>>>
89917>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89918>>>>>>>        If (bIsSame = False) Begin
89920>>>>>>>            Function_Return False
89921>>>>>>>        End
89921>>>>>>>>
89921>>>>>>>
89921>>>>>>>        Function_Return bIsSame
89922>>>>>>>    End_Function
89923>>>>>>>
89923>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89925>>>>>>>        Handle hTableFrom hTableTo
89925>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89925>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89925>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89925>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89925>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89926>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89926>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89927>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89927>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89928>>>>>>>
89928>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89929>>>>>>>        If (bIsSame = True) Begin
89931>>>>>>>            Function_Return True
89932>>>>>>>        End
89932>>>>>>>>
89932>>>>>>>
89932>>>>>>>        Move False to bFilelistError
89933>>>>>>>        Move True to bIsSame
89934>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89935>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89936>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89937>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89938>>>>>>>        Set Private.phCurrentTable to hTableFrom
89939>>>>>>>        
89939>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89940>>>>>>>
89940>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89941>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89942>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89943>>>>>>>
89943>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89943>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89943>>>>>>>        If (bCodeGenerateMode = True) Begin
89945>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89945>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89947>>>>>>>                Function_Return False
89948>>>>>>>            End
89948>>>>>>>>
89948>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89949>>>>>>>            If (bIsSame = False) Begin
89951>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89952>>>>>>>                Move True to bFilelistError
89953>>>>>>>                Function_Return False
89954>>>>>>>            End
89954>>>>>>>>
89954>>>>>>>        End
89954>>>>>>>>
89954>>>>>>>
89954>>>>>>>        If (bCodeGenerateMode = False) Begin
89956>>>>>>>            // Then we want to create this table
89956>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89958>>>>>>>                Function_Return False
89959>>>>>>>            End
89959>>>>>>>>
89959>>>>>>>
89959>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89960>>>>>>>            If (bIsSame = False) Begin
89962>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89963>>>>>>>>
89963>>>>>>>                Move True to bFilelistError
89964>>>>>>>                Function_Return False
89965>>>>>>>            End
89965>>>>>>>>
89965>>>>>>>        End
89965>>>>>>>>
89965>>>>>>>
89965>>>>>>>        // Check columns:
89965>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89966>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89967>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89968>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89969>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89970>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89971>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89972>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89973>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89974>>>>>>>        If (bIsSame = False) Begin
89976>>>>>>>            Function_Return False
89977>>>>>>>        End
89977>>>>>>>>
89977>>>>>>>
89977>>>>>>>        // ...then check indexes:
89977>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89978>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89979>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89980>>>>>>>        If (bIsSame = False) Begin
89982>>>>>>>            Function_Return False
89983>>>>>>>        End
89983>>>>>>>>
89983>>>>>>>
89983>>>>>>>        // ...and finally relationships:
89983>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89984>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89985>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89986>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89987>>>>>>>
89987>>>>>>>        Function_Return (bIsSame = True)
89988>>>>>>>    End_Function
89989>>>>>>>
89989>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89989>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89991>>>>>>>        Handle hTable
89991>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89991>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89991>>>>>>>
89991>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89993>>>>>>>            Move True to bFilelistError
89994>>>>>>>            Function_Return False
89995>>>>>>>        End
89995>>>>>>>>
89995>>>>>>>
89995>>>>>>>        Move APITableCompare.hTable to hTable
89996>>>>>>>        Move True  to bIsSame
89997>>>>>>>        Move False to bFilelistError
89998>>>>>>>
89998>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90000>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90001>>>>>>>        End
90001>>>>>>>>
90001>>>>>>>        Else Begin
90002>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90003>>>>>>>        End
90003>>>>>>>>
90003>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90004>>>>>>>
90004>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90005>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90006>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90007>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90008>>>>>>>
90008>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90008>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90008>>>>>>>        If (bCodeGenerateMode = True) Begin
90010>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90010>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90012>>>>>>>                Function_Return False
90013>>>>>>>            End
90013>>>>>>>>
90013>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90014>>>>>>>            If (bIsSame = False) Begin
90016>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90017>>>>>>>                Move True to bFilelistError
90018>>>>>>>                Function_Return False
90019>>>>>>>            End
90019>>>>>>>>
90019>>>>>>>        End
90019>>>>>>>>
90019>>>>>>>
90019>>>>>>>        If (bCodeGenerateMode = False) Begin
90021>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90023>>>>>>>                // Then we might want to create this table
90023>>>>>>>                Function_Return False
90024>>>>>>>            End
90024>>>>>>>>
90024>>>>>>>
90024>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90025>>>>>>>            If (bIsSame = False) Begin
90027>>>>>>>                Function_Return False
90028>>>>>>>            End
90028>>>>>>>>
90028>>>>>>>
90028>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90029>>>>>>>            If (bIsSame = False) Begin
90031>>>>>>>                Function_Return False
90032>>>>>>>            End
90032>>>>>>>>
90032>>>>>>>
90032>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90033>>>>>>>            If (bIsSame = False) Begin
90035>>>>>>>                Function_Return False
90036>>>>>>>            End
90036>>>>>>>>
90036>>>>>>>
90036>>>>>>>            // Check table names et al.
90036>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90037>>>>>>>            If (bIsSame = False) Begin
90039>>>>>>>                Function_Return False
90040>>>>>>>            End
90040>>>>>>>>
90040>>>>>>>        End
90040>>>>>>>>
90040>>>>>>>
90040>>>>>>>        // Check Columns:
90040>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90041>>>>>>>        If (bIsSame = False) Begin
90043>>>>>>>            Function_Return False
90044>>>>>>>        End
90044>>>>>>>>
90044>>>>>>>
90044>>>>>>>        // ...then check Indexes:
90044>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90045>>>>>>>        If (bIsSame = False) Begin
90047>>>>>>>            Function_Return False
90048>>>>>>>        End
90048>>>>>>>>
90048>>>>>>>
90048>>>>>>>        // ...and finally Relationships:
90048>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90049>>>>>>>
90049>>>>>>>        Function_Return (bIsSame = True)
90050>>>>>>>    End_Function
90051>>>>>>>
90051>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90051>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90051>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90051>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90051>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90053>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90053>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90053>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90053>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90055>>>>>>>        tAPIColumn[]    aApiColumns
90055>>>>>>>        tAPIColumn[]    aApiColumns
90056>>>>>>>        tAPIIndex[]     aApiIndexes
90056>>>>>>>        tAPIIndex[]     aApiIndexes
90057>>>>>>>        tAPIRelation[]  aApiRelations
90057>>>>>>>        tAPIRelation[]  aApiRelations
90058>>>>>>>        Handle hTable
90058>>>>>>>        Integer iCount
90058>>>>>>>        Boolean bUserCancel bOK
90058>>>>>>>        String sLogicalName sMessageText
90058>>>>>>>
90058>>>>>>>        Get AutoConnectionIDLogin to bOK
90059>>>>>>>        Move 0 to hTable
90060>>>>>>>        If (bFromTables = True) Begin
90062>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90063>>>>>>>            If (bCompareUtil = True) Begin
90065>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90066>>>>>>>            End
90066>>>>>>>>
90066>>>>>>>        End
90066>>>>>>>>
90066>>>>>>>        Else Begin
90067>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90068>>>>>>>            If (bCompareUtil = True) Begin
90070>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90071>>>>>>>            End
90071>>>>>>>>
90071>>>>>>>        End
90071>>>>>>>>
90071>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90072>>>>>>>
90072>>>>>>>        Get UtilFilelistNoOfTables to iCount
90073>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90074>>>>>>>        Move 0 to iCount
90075>>>>>>>
90075>>>>>>>        Repeat
90075>>>>>>>>
90075>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90078>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90080>>>>>>>
90080>>>>>>>                Open hTable
90082>>>>>>>                // ToDo: Needs to be revised
90082>>>>>>>                // For some reason tables may be reported as "unopened", while in
90082>>>>>>>                // fact the open was successful (!)
90082>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90082>>>>>>>//                If (bIsOpen = False) Begin
90082>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90082>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90082>>>>>>>//                    Function_Return aApiTablesEmpty
90082>>>>>>>//                End
90082>>>>>>>
90082>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90085>>>>>>>                Set piPosition of ghoProgressBar to iCount
90086>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90087>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90088>>>>>>>
90088>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90089>>>>>>>//                Close hTable DF_PERMANENT
90089>>>>>>>                Increment iCount
90090>>>>>>>            End
90090>>>>>>>>
90090>>>>>>>
90090>>>>>>>            If (bStatusPanel = True) Begin
90092>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90093>>>>>>>                If (bUserCancel = True) Begin
90095>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90096>>>>>>>                    Function_Return aApiTablesEmpty
90097>>>>>>>                End
90097>>>>>>>>
90097>>>>>>>            End
90097>>>>>>>>
90097>>>>>>>
90097>>>>>>>        Until (hTable = 0)
90099>>>>>>>
90099>>>>>>>        Function_Return aApiTables
90100>>>>>>>    End_Function
90101>>>>>>>
90101>>>>>>>    // Returns a 'single' table APITable struct.
90101>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90103>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90103>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90103>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90103>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90103>>>>>>>        tAPIColumn[]     aApiColumns
90103>>>>>>>        tAPIColumn[]     aApiColumns
90104>>>>>>>        tAPIIndex[]      aApiIndexes
90104>>>>>>>        tAPIIndex[]      aApiIndexes
90105>>>>>>>        tAPIRelation[]   aApiRelations
90105>>>>>>>        tAPIRelation[]   aApiRelations
90106>>>>>>>        Boolean bIsOpen
90106>>>>>>>
90106>>>>>>>        Open hTable
90108>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90111>>>>>>>        If (bIsOpen = False) Begin
90113>>>>>>>            Move True to ApiTableEmpty.bError
90114>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90115>>>>>>>            Function_Return ApiTableEmpty
90116>>>>>>>        End
90116>>>>>>>>
90116>>>>>>>
90116>>>>>>>        // Fill Table Name Info
90116>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90117>>>>>>>
90117>>>>>>>        // Fill columns
90117>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90118>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90120>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90122>>>>>>>                Move True to ApiTableEmpty.bError
90123>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90124>>>>>>>                Function_Return ApiTableEmpty
90125>>>>>>>            End
90125>>>>>>>>
90125>>>>>>>        End
90125>>>>>>>>
90125>>>>>>>
90125>>>>>>>        // Fill indexes
90125>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90126>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90128>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90130>>>>>>>                Move True to ApiTableEmpty.bError
90131>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90132>>>>>>>                Function_Return ApiTableEmpty
90133>>>>>>>            End
90133>>>>>>>>
90133>>>>>>>        End
90133>>>>>>>>
90133>>>>>>>
90133>>>>>>>        // Fill relationships
90133>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90134>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90136>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90138>>>>>>>                Move True to ApiTableEmpty.bError
90139>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90140>>>>>>>                Function_Return ApiTableEmpty
90141>>>>>>>            End
90141>>>>>>>>
90141>>>>>>>        End
90141>>>>>>>>
90141>>>>>>>
90141>>>>>>>        Move hTable             to ApiTable.hTable
90142>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90143>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
90144>>>>>>>
90144>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90145>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90146>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90147>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90148>>>>>>>
90148>>>>>>>        Function_Return ApiTable
90149>>>>>>>    End_Function
90150>>>>>>>
90150>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90152>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90152>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90152>>>>>>>        Boolean bIsOpen
90152>>>>>>>
90152>>>>>>>        Open hTable
90154>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90157>>>>>>>        If (bIsOpen = False) Begin
90159>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90160>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90161>>>>>>>            Function_Return APITableNameInfoEmpty
90162>>>>>>>        End
90162>>>>>>>>
90162>>>>>>>
90162>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90163>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90166>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90169>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90172>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90175>>>>>>>
90175>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90176>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
90177>>>>>>>
90177>>>>>>>        Function_Return APITableNameInfo
90178>>>>>>>    End_Function
90179>>>>>>>
90179>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90181>>>>>>>        Integer iSize iCount iItem
90181>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90181>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90181>>>>>>>
90181>>>>>>>        Move -1 to iItem
90182>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90183>>>>>>>        Decrement iSize
90184>>>>>>>        for iCount from 0 to iSize
90190>>>>>>>>
90190>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90191>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90193>>>>>>>                Move iCount to iItem
90194>>>>>>>                Move iSize  to iCount // We're done.
90195>>>>>>>            End
90195>>>>>>>>
90195>>>>>>>        Loop
90196>>>>>>>>
90196>>>>>>>
90196>>>>>>>        Function_Return iItem
90197>>>>>>>    End_Function
90198>>>>>>>
90198>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90200>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90203>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90206>>>>>>>
90206>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90209>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90212>>>>>>>
90212>>>>>>>        Function_Return (EQ)
90213>>>>>>>    End_Function
90214>>>>>>>
90214>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90216>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90216>>>>>>>        Handle hTable
90216>>>>>>>        tAPITable[] aAPITableFromAndTo
90216>>>>>>>        tAPITable[] aAPITableFromAndTo
90217>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90217>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90217>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90217>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90217>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90217>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90218>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90218>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90219>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90219>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90220>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90220>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90221>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90221>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90221>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90221>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90224>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90224>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90227>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90227>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90230>>>>>>>
90230>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90231>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90232>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90234>>>>>>>            Function_Return aAPITableCompare
90235>>>>>>>        End
90235>>>>>>>>
90235>>>>>>>
90235>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90236>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90237>>>>>>>
90237>>>>>>>        Move 0 to iItem
90238>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90239>>>>>>>        Decrement iSize
90240>>>>>>>        for iCount from 0 to iSize
90246>>>>>>>>
90246>>>>>>>
90246>>>>>>>            Move iCount to iItemFrom
90247>>>>>>>            Move iCount to iItemTo
90248>>>>>>>            Move APITableEmpty to APITableFrom
90249>>>>>>>            Move APITableEmpty to APITableTo
90250>>>>>>>
90250>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90252>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90253>>>>>>>            End
90253>>>>>>>>
90253>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90255>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90256>>>>>>>            End
90256>>>>>>>>
90256>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90258>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90259>>>>>>>                Move (iCount + 1) to iItemTo
90260>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90261>>>>>>>            End
90261>>>>>>>>
90261>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
90263>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
90264>>>>>>>                If (iItemTo <> -1) Begin
90266>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
90267>>>>>>>                End
90267>>>>>>>>
90267>>>>>>>                Else Begin
90268>>>>>>>                    Move APITableEmpty to APITableTo
90269>>>>>>>                End
90269>>>>>>>>
90269>>>>>>>            End
90269>>>>>>>>
90269>>>>>>>
90269>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90270>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90271>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90272>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90273>>>>>>>
90273>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90274>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90275>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90276>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90277>>>>>>>
90277>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90278>>>>>>>
90278>>>>>>>            If (hTable > 0) Begin
90280>>>>>>>
90280>>>>>>>                // Table info:
90280>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90281>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90282>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90283>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90284>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90285>>>>>>>
90285>>>>>>>                // Column info:
90285>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90286>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90287>>>>>>>
90287>>>>>>>                // Index info:
90287>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90288>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90289>>>>>>>
90289>>>>>>>                // Relation info:
90289>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90290>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90291>>>>>>>
90291>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90292>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90293>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90294>>>>>>>                If (iItemTo > iItemFrom) Begin
90296>>>>>>>                    Increment iCount
90297>>>>>>>                End
90297>>>>>>>>
90297>>>>>>>                Increment iItem
90298>>>>>>>            End
90298>>>>>>>>
90298>>>>>>>
90298>>>>>>>        Loop
90299>>>>>>>>
90299>>>>>>>
90299>>>>>>>        Function_Return aAPITableCompare
90300>>>>>>>    End_Function
90301>>>>>>>
90301>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
90303>>>>>>>        Integer iSize iCount iItem
90303>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90303>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90303>>>>>>>
90303>>>>>>>        Move -1 to iItem
90304>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90305>>>>>>>        Decrement iSize
90306>>>>>>>        For iCount from 0 to iSize
90312>>>>>>>>
90312>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90313>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
90315>>>>>>>                Move iCount to iItem
90316>>>>>>>                Move iSize  to iCount // We're done.
90317>>>>>>>            End
90317>>>>>>>>
90317>>>>>>>        Loop
90318>>>>>>>>
90318>>>>>>>
90318>>>>>>>        Function_Return iItem
90319>>>>>>>    End_Function
90320>>>>>>>
90320>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90322>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90322>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90322>>>>>>>
90322>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90324>>>>>>>            Function_Return APITableNameInfoCompare
90325>>>>>>>        End
90325>>>>>>>>
90325>>>>>>>
90325>>>>>>>        // FROM database info:
90325>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90327>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90328>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90329>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90330>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90331>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90332>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90333>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90334>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90335>>>>>>>        End
90335>>>>>>>>
90335>>>>>>>
90335>>>>>>>        // TO database info:
90335>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90337>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90338>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90339>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90340>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90341>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90342>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90343>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90344>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90345>>>>>>>        End
90345>>>>>>>>
90345>>>>>>>
90345>>>>>>>        Function_Return APITableNameInfoCompare
90346>>>>>>>    End_Function
90347>>>>>>>
90347>>>>>>>    // Note:
90347>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90347>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90347>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90347>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90347>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90347>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90349>>>>>>>        String sTableName
90349>>>>>>>        Boolean bOpen bExists bOK
90349>>>>>>>
90349>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90350>>>>>>>        If (bExists = False) Begin
90352>>>>>>>            Function_Return ""
90353>>>>>>>        End
90353>>>>>>>>
90353>>>>>>>
90353>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90354>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90357>>>>>>>        If (bOpen = False) Begin
90359>>>>>>>            Get AutoConnectionIDLogin to bOK
90360>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90361>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90362>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90363>>>>>>>            Open hTable
90365>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90366>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90367>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90368>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90371>>>>>>>        End
90371>>>>>>>>
90371>>>>>>>        If (bOpen = True) Begin
90373>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90374>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90377>>>>>>>            // If blank it is an embedded table:
90377>>>>>>>            If (sTableName = "") Begin
90379>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90382>>>>>>>                Move 0 to LastErr
90383>>>>>>>                Move False to Err
90384>>>>>>>            End
90384>>>>>>>>
90384>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90385>>>>>>>        End
90385>>>>>>>>
90385>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90386>>>>>>>        Move 0 to LastErr
90387>>>>>>>
90387>>>>>>>        Function_Return sTableName
90388>>>>>>>    End_Function
90389>>>>>>>
90389>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90389>>>>>>>    // Returns 0 if unsuccessful.
90389>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90389>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90391>>>>>>>        String sValue sPrefixTableName sDriverID
90391>>>>>>>        Handle hTable hRetval
90391>>>>>>>
90391>>>>>>>        Get psDriverID to sDriverID
90392>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90394>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90395>>>>>>>        End
90395>>>>>>>>
90395>>>>>>>        Move 0 to hTable
90396>>>>>>>        Move 0 to hRetval
90397>>>>>>>        Repeat
90397>>>>>>>>
90397>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90400>>>>>>>            If (hTable <> 0) Begin
90402>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90405>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90407>>>>>>>                    Move hTable to hRetval
90408>>>>>>>                    Move 0 to hTable
90409>>>>>>>                End
90409>>>>>>>>
90409>>>>>>>            End
90409>>>>>>>>
90409>>>>>>>        Until (hTable = 0)
90411>>>>>>>
90411>>>>>>>        Function_Return hRetval
90412>>>>>>>    End_Function
90413>>>>>>>
90413>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90413>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90413>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90415>>>>>>>        Boolean bOK bExists
90415>>>>>>>        String sDataPath sBackupFolder
90415>>>>>>>
90415>>>>>>>        Close DF_ALL DF_PERMANENT
90416>>>>>>>        Send DoAdvance of ghoProgressBar
90417>>>>>>>
90417>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90418>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90419>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90420>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90421>>>>>>>
90421>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90422>>>>>>>        If (bExists = False) Begin
90424>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90425>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90426>>>>>>>            If (bExists = False) Begin
90428>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90429>>>>>>>>
90429>>>>>>>                Function_Return False
90430>>>>>>>            End
90430>>>>>>>>
90430>>>>>>>        End
90430>>>>>>>>
90430>>>>>>>
90430>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90431>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90432>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90433>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90434>>>>>>>        // We need to wait for Windows before we can copy files back
90434>>>>>>>        Sleep 2  
90435>>>>>>>        
90435>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90435>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90436>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90437>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90438>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90439>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90440>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90441>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90441>>>>>>>        
90441>>>>>>>
90441>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90442>>>>>>>        Function_Return True
90443>>>>>>>    End_Function
90444>>>>>>>    
90444>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90446>>>>>>>        Boolean bOK bRetval
90446>>>>>>>        Handle hTable
90446>>>>>>>        Integer iSize iCount
90446>>>>>>>        
90446>>>>>>>        Move True to bOK
90447>>>>>>>        Get UtilFilelistNoOfTables to iSize
90448>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90449>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90450>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90451>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90452>>>>>>>
90452>>>>>>>        Repeat
90452>>>>>>>>
90452>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90453>>>>>>>            Increment iCount
90454>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90457>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90459>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90460>>>>>>>                If (bRetval = False) Begin
90462>>>>>>>                    Move False to bOK
90463>>>>>>>                End
90463>>>>>>>>
90463>>>>>>>            End
90463>>>>>>>>
90463>>>>>>>        Until (hTable = 0)
90465>>>>>>>                
90465>>>>>>>        Function_Return bOK
90466>>>>>>>    End_Function           
90467>>>>>>>    
90467>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90467>>>>>>>    // After the header has been repaired - also makes a re-index.  
90467>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90467>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90469>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90469>>>>>>>        Integer iRetval
90469>>>>>>>        String sRootName sFileName sDataPath
90469>>>>>>>        
90469>>>>>>>        Move False to Err
90470>>>>>>>        Move 0 to LastErr 
90471>>>>>>>        Move True to bOK
90472>>>>>>>        
90472>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90473>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90475>>>>>>>            Function_Return True
90476>>>>>>>        End
90476>>>>>>>>
90476>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90477>>>>>>>        If (bIsAlias = True) Begin
90479>>>>>>>            Function_Return True
90480>>>>>>>        End
90480>>>>>>>>
90480>>>>>>>        
90480>>>>>>>        // Check for bad file and remove if exists
90480>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90483>>>>>>>        Set private.phCurrentTable to hTable  
90484>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90485>>>>>>>        
90485>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90485>>>>>>>        // with a "4077 - File in use" error.
90485>>>>>>>        Close DF_ALL DF_PERMANENT    
90486>>>>>>>        Open hTable
90488>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90491>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90492>>>>>>>        If (bIsOpen = False) Begin
90494>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90495>>>>>>>>
90495>>>>>>>            Function_Return False        
90496>>>>>>>        End
90496>>>>>>>>
90496>>>>>>>
90496>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90497>>>>>>>        If (bBadExists = True) Begin
90499>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90500>>>>>>>            Get vDeleteFile sFileName to iRetval
90501>>>>>>>        End
90501>>>>>>>>
90501>>>>>>>        
90501>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90502>>>>>>>        
90502>>>>>>>        Move False to Err
90503>>>>>>>        // **** Repair and reindex the table. ****
90503>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90504>>>>>>>
90504>>>>>>>        // Check for bad file: if it exists, something went wrong
90504>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90505>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90506>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90507>>>>>>>        If (bBadExists = True) Begin
90509>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90510>>>>>>>>
90510>>>>>>>            Move False to bOK
90511>>>>>>>        End
90511>>>>>>>>
90511>>>>>>>        Close hTable
90512>>>>>>>
90512>>>>>>>        Function_Return bOK
90513>>>>>>>    End_Function
90514>>>>>>>
90514>>>>>>>    // Repair and reindex the named DataFlex data-table.
90514>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90514>>>>>>>    // so use with care (make sure you only pass embedded table names).
90514>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90516>>>>>>>        String sMode
90516>>>>>>>        Integer iVoid
90516>>>>>>>
90516>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90517>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90518>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90519>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90524>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90525>>>>>>>        Function_Return (iVoid = 0)
90526>>>>>>>    End_Function
90527>>>>>>>
90527>>>>>>>    // Returns _two_ arrays.
90527>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90527>>>>>>>    // Also returns all files that are Alias files in a second array.
90527>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90527>>>>>>>    //            the DoSetAllMasterAndAlias message.
90527>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90529>>>>>>>        Integer[] iaFileIsAlias
90530>>>>>>>        Integer hTable iFileAlias iSize
90530>>>>>>>        Boolean bOpen
90530>>>>>>>
90530>>>>>>>        Move 0 to hTable
90531>>>>>>>        Repeat
90531>>>>>>>>
90531>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90534>>>>>>>            If (hTable <> 0) Begin
90536>>>>>>>                Open hTable
90538>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90541>>>>>>>                If (bOpen = True) Begin
90543>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90546>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90548>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90549>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90550>>>>>>>                    End
90550>>>>>>>>
90550>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90553>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90554>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90555>>>>>>>                    End
90555>>>>>>>>
90555>>>>>>>                End
90555>>>>>>>>
90555>>>>>>>            End
90555>>>>>>>>
90555>>>>>>>        Until (hTable = 0)
90557>>>>>>>
90557>>>>>>>        Function_Return iaFileIsAlias
90558>>>>>>>    End_Function  
90559>>>>>>>    
90559>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90559>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90561>>>>>>>        String sMode
90561>>>>>>>        Integer iRepairNeeded bIsOpen
90561>>>>>>>
90561>>>>>>>        Move "0" to sMode
90562>>>>>>>        Set private.phCurrentTable to hTable 
90563>>>>>>>        Close hTable
90564>>>>>>>        Open hTable
90566>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90569>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90574>>>>>>>
90574>>>>>>>        Function_Return iRepairNeeded
90575>>>>>>>    End_Function
90576>>>>>>>
90576>>>>>>>    // Helper function
90576>>>>>>>    // Takes two params:
90576>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90576>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90576>>>>>>>    // Returns:
90576>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90576>>>>>>>    //  DF_FILE_IS_MASTER if master
90576>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90576>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90578>>>>>>>        Integer i iSize
90578>>>>>>>
90578>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90579>>>>>>>        Decrement iSize
90580>>>>>>>        for i from 0 to iSize
90586>>>>>>>>
90586>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90588>>>>>>>                Function_Return DF_FILE_IS_MASTER
90589>>>>>>>            End
90589>>>>>>>>
90589>>>>>>>        Loop
90590>>>>>>>>
90590>>>>>>>
90590>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90591>>>>>>>        Decrement iSize
90592>>>>>>>        for i from 0 to iSize
90598>>>>>>>>
90598>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90600>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90601>>>>>>>            End
90601>>>>>>>>
90601>>>>>>>        Loop
90602>>>>>>>>
90602>>>>>>>
90602>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90603>>>>>>>    End_Function
90604>>>>>>>
90604>>>>>>>    // Determine the available indexes of a table.
90604>>>>>>>    //
90604>>>>>>>    // Arguments:
90604>>>>>>>    //   Handle hTable - The number of the table
90604>>>>>>>    //
90604>>>>>>>    // Returns:
90604>>>>>>>    //   String - A string to be used with the sort command
90604>>>>>>>    //   to re-index all indexes of a table.
90604>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90606>>>>>>>        String  sSortString
90606>>>>>>>        Integer iLastIndex iNumSegments iCount
90606>>>>>>>
90606>>>>>>>        Move "" to sSortString
90607>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90610>>>>>>>
90610>>>>>>>        for iCount from 1 to iLastIndex
90616>>>>>>>>
90616>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90619>>>>>>>            If iNumSegments Begin
90621>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90624>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90625>>>>>>>            End
90625>>>>>>>>
90625>>>>>>>        Loop
90626>>>>>>>>
90626>>>>>>>
90626>>>>>>>        Function_Return sSortString
90627>>>>>>>    End_Function
90628>>>>>>>
90628>>>>>>>    
90628>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90628>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90630>>>>>>>        Function_Return False
90631>>>>>>>    End_Function
90632>>>>>>>
90632>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90632>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90634>>>>>>>        Boolean bIsSame
90634>>>>>>>        Integer iCount iColumns iColumn
90634>>>>>>>
90634>>>>>>>        Move True to bIsSame
90635>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90636>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90637>>>>>>>        Decrement iColumns
90638>>>>>>>
90638>>>>>>>        for iCount from 0 to iColumns
90644>>>>>>>>
90644>>>>>>>            Set piPosition of ghoProgressBar to iCount
90645>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90646>>>>>>>            If (bIsSame = False) Begin
90648>>>>>>>                Function_Return False
90649>>>>>>>            End
90649>>>>>>>>
90649>>>>>>>        Loop
90650>>>>>>>>
90650>>>>>>>
90650>>>>>>>        Function_Return (bIsSame = True)
90651>>>>>>>    End_Function
90652>>>>>>>
90652>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90652>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90654>>>>>>>        Integer iFromType iToType iDbType
90654>>>>>>>        tColumnType ColumnType
90654>>>>>>>        tColumnType ColumnType
90654>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90654>>>>>>>
90654>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90656>>>>>>>            Function_Return False
90657>>>>>>>        End
90657>>>>>>>>
90657>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90659>>>>>>>            Function_Return False
90660>>>>>>>        End
90660>>>>>>>>
90660>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90662>>>>>>>            Function_Return False
90663>>>>>>>        End                                                                
90663>>>>>>>>
90663>>>>>>>
90663>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90665>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90667>>>>>>>                Function_Return False
90668>>>>>>>            End
90668>>>>>>>>
90668>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90670>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90672>>>>>>>                    End
90672>>>>>>>>
90672>>>>>>>                Else Begin
90673>>>>>>>                    Function_Return False
90674>>>>>>>                End
90674>>>>>>>>
90674>>>>>>>            End
90674>>>>>>>>
90674>>>>>>>        End
90674>>>>>>>>
90674>>>>>>>
90674>>>>>>>        Get piDbType                       to iDbType
90675>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90676>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90677>>>>>>>
90677>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90677>>>>>>>        // data types between Embedded and SQL.
90677>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90679>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90680>>>>>>>        End
90680>>>>>>>>
90680>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90682>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90683>>>>>>>        End
90683>>>>>>>>
90683>>>>>>>
90683>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90684>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90685>>>>>>>
90685>>>>>>>        // Make Date and DateTime comparison?
90685>>>>>>>        If (bCompareDate_DataTime = True) Begin
90687>>>>>>>            If (iFromType <> iToType) Begin
90689>>>>>>>                Function_Return False
90690>>>>>>>            End
90690>>>>>>>>
90690>>>>>>>        End
90690>>>>>>>>
90690>>>>>>>
90690>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90690>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90692>>>>>>>            If (iFromType <> iToType) Begin
90694>>>>>>>                Function_Return False
90695>>>>>>>            End
90695>>>>>>>>
90695>>>>>>>        End
90695>>>>>>>>
90695>>>>>>>
90695>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90695>>>>>>>        If (bIsDateTypeFrom = False) Begin
90697>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90699>>>>>>>                Function_Return False
90700>>>>>>>            End
90700>>>>>>>>
90700>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90702>>>>>>>                Function_Return False
90703>>>>>>>            End
90703>>>>>>>>
90703>>>>>>>        End
90703>>>>>>>>
90703>>>>>>>
90703>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90705>>>>>>>            Function_Return False
90706>>>>>>>        End
90706>>>>>>>>
90706>>>>>>>
90706>>>>>>>        Function_Return True
90707>>>>>>>    End_Function
90708>>>>>>>
90708>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90710>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber iDriverID
90710>>>>>>>        Boolean bIdentityKey bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90710>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90710>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90712>>>>>>>        String sDriverID sRootName sLogicalName sDataType
90712>>>>>>>
90712>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90713>>>>>>>        Get piDbType to iDbType
90714>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90717>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90720>>>>>>>
90720>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90723>>>>>>>        If (bIsOpen = False) Begin
90725>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90726>>>>>>>            Open hTable
90728>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90729>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90732>>>>>>>            If (bIsOpen = False) Begin
90734>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90735>>>>>>>                Move True to APIColumnsEmpty[0].bError
90736>>>>>>>                Function_Return APIColumnsEmpty
90737>>>>>>>            End
90737>>>>>>>>
90737>>>>>>>        End
90737>>>>>>>>
90737>>>>>>>
90737>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90740>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90741>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90742>>>>>>>        If (bIsSqlTable = True) Begin
90744>>>>>>>            Get _UtilTableExists hTable to bExists
90745>>>>>>>            If (bExists = False) Begin
90747>>>>>>>                Move True to APIColumnsEmpty[0].bError
90748>>>>>>>                Function_Return APIColumnsEmpty
90749>>>>>>>            End
90749>>>>>>>>
90749>>>>>>>        End
90749>>>>>>>>
90749>>>>>>>//        Get DriverIndex sDriverID to iDriverID
90749>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
90749>>>>>>>//            Set_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE of iDriverId to 'datetime2'
90749>>>>>>>//        End
90749>>>>>>>
90749>>>>>>>        Move 0 to iCount
90750>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90753>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90754>>>>>>>
90754>>>>>>>        for iColumn from 1 to iNumColumns
90760>>>>>>>>
90760>>>>>>>            Move 0 to iOptions
90761>>>>>>>            Move False to bIdentityKey
90762>>>>>>>            Move False to Err
90763>>>>>>>            Move 0     to LastErr
90764>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90765>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90766>>>>>>>
90766>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90767>>>>>>>            If (bIsSqlTable = True) Begin 
90769>>>>>>>//                If (iType = DF_DATE) Begin
90769>>>>>>>//                    // Note: This is actually the same as SQL_DATETIME
90769>>>>>>>//                    Move SQL_DATE to iType
90769>>>>>>>//                    Move 3 to APIColumns[iCouknt].iPrecision
90769>>>>>>>//                End
90769>>>>>>>//                Else If (iType = DF_DATET Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeIME) Begin
90769>>>>>>>//                    // In modern MS-SQL databases SQL_DATETIME will be = to "datetime2".
90769>>>>>>>//                    // By default MS-SQL will create such a field with 7 (!) decimal places.
90769>>>>>>>//                    // This is just a waste because DataFlex will truncate that to 3 decimal
90769>>>>>>>//                    // places. Therefore, we hard-code the precision to be only thee decimals.
90769>>>>>>>//                    Move SQL_DATETIME to iType
90769>>>>>>>//                    Move 3 to APIColumns[iCount].iPrecision
90769>>>>>>>//                End
90769>>>>>>>//                Move iType                                                to APIColumns[iCount].iType
90769>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
90772>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90775>>>>>>>                Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90778>>>>>>>                Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90781>>>>>>>            End
90781>>>>>>>>
90781>>>>>>>            Else Begin
90782>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90785>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90786>>>>>>>            End
90786>>>>>>>>
90786>>>>>>>
90786>>>>>>>            // If the array value is out of bounce it means that this column doesn't exist on the backend.
90786>>>>>>>            Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90789>>>>>>>            Move (iCheckFieldNumber >= 0) to bExists
90790>>>>>>>            If (bExists = False) Begin
90792>>>>>>>                Move 0 to APIColumns[iCount].iType
90793>>>>>>>            End
90793>>>>>>>>
90793>>>>>>>            If (bExists = True) Begin
90795>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90798>>>>>>>            End
90798>>>>>>>>
90798>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90799>>>>>>>            If (bIdentityKey = True) Begin
90801>>>>>>>                Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90802>>>>>>>            End
90802>>>>>>>>
90802>>>>>>>
90802>>>>>>>//            Else Begin
90802>>>>>>>//                Move False to Err
90802>>>>>>>//                Move 0     to LastErr
90802>>>>>>>//                If (bIsSqlTable = True) Begin
90802>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90802>>>>>>>//                End
90802>>>>>>>//                Else Begin
90802>>>>>>>//                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90802>>>>>>>//                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90802>>>>>>>//                End
90802>>>>>>>//                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90802>>>>>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90802>>>>>>>//                If (bExists = False) Begin
90802>>>>>>>//                    Move 0 to APIColumns[iCount].iType
90802>>>>>>>//                End
90802>>>>>>>//            End
90802>>>>>>>
90802>>>>>>>            If (bExists = True) Begin
90804>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90805>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90808>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90808>>>>>>>//                If (bIsSqlTable = True) Begin
90808>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90808>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90808>>>>>>>//                End
90808>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength 
90811>>>>>>>                If (APIColumns[iCount].iPrecision = 0) Begin
90813>>>>>>>                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90816>>>>>>>                End
90816>>>>>>>>
90816>>>>>>>
90816>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90816>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90816>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90818>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90821>>>>>>>                    If (iType = DF_OVERLAP) Begin
90823>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90824>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90825>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90826>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90827>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90828>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90829>>>>>>>                        Decrement iCount
90830>>>>>>>                    End
90830>>>>>>>>
90830>>>>>>>                End
90830>>>>>>>>
90830>>>>>>>            End
90830>>>>>>>>
90830>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90831>>>>>>>            If (bUserCancel = True) Begin
90833>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90834>>>>>>>                Function_Return APIColumnsEmpty
90835>>>>>>>            End
90835>>>>>>>>
90835>>>>>>>            Increment iCount
90836>>>>>>>        Loop
90837>>>>>>>>
90837>>>>>>>
90837>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90838>>>>>>>        Function_Return APIColumns
90839>>>>>>>    End_Function
90840>>>>>>>     
90840>>>>>>>    // ToDo: Shouldn't this be the other way round? The From bit last? That is what should be of interest??
90840>>>>>>>    // *** 
90840>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO column arrays.
90840>>>>>>>    // The combined data will be sorted on the first struct member: iFieldNumber
90840>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90842>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90842>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90843>>>>>>>        tAPIColumnCompare   APIColumnCompare
90843>>>>>>>        tAPIColumnCompare   APIColumnCompare
90843>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90843>>>>>>>
90843>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90844>>>>>>>        Decrement iSizeFrom
90845>>>>>>>        for iCount from 0 to iSizeFrom
90851>>>>>>>>
90851>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90852>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90853>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90854>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90855>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90856>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90857>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90858>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90859>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90860>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90861>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90862>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90863>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90864>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90865>>>>>>>        Loop
90866>>>>>>>>
90866>>>>>>>
90866>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90867>>>>>>>        Decrement iSizeTo
90868>>>>>>>        for iCount from 0 to iSizeTo
90874>>>>>>>>
90874>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90875>>>>>>>            // Search if the field number already exists in the "to" array; else add it. <
90875>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90876>>>>>>>            If (iItem = -1) Begin
90878>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90879>>>>>>>            End
90879>>>>>>>>
90879>>>>>>>
90879>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90880>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90881>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90882>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90883>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90884>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90885>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90886>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90887>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90888>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90889>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90890>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90891>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90892>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90893>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90894>>>>>>>        Loop
90895>>>>>>>>
90895>>>>>>>
90895>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90896>>>>>>>
90896>>>>>>>        Function_Return aAPIColumnCompare
90897>>>>>>>    End_Function
90898>>>>>>>
90898>>>>>>>    // Checks if a field name exists in a table definition
90898>>>>>>>    // Returns True if it does
90898>>>>>>>    // Sample:
90898>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90898>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90900>>>>>>>        Integer iNumColumns iColumn
90900>>>>>>>        String sColumn
90900>>>>>>>        Boolean bExists bOK bOpen
90900>>>>>>>
90900>>>>>>>        Get AutoConnectionIDLogin to bOK
90901>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90902>>>>>>>        Open hTable
90904>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90905>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90908>>>>>>>        If (bOpen = False) Begin
90910>>>>>>>            Function_Return False
90911>>>>>>>        End
90911>>>>>>>>
90911>>>>>>>
90911>>>>>>>        Move False to bExists
90912>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90915>>>>>>>        for iColumn from 1 to iNumColumns
90921>>>>>>>>
90921>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90924>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90926>>>>>>>                Move iNumColumns to iColumn
90927>>>>>>>                Move True to bExists
90928>>>>>>>            End
90928>>>>>>>>
90928>>>>>>>        Loop
90929>>>>>>>>
90929>>>>>>>        Close hTable
90930>>>>>>>
90930>>>>>>>        Function_Return bExists
90931>>>>>>>    End_Function
90932>>>>>>>
90932>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90932>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90934>>>>>>>        Integer iNumColumns iColumn iRetval
90934>>>>>>>        String sColumn
90934>>>>>>>        Boolean bOK bOpen
90934>>>>>>>
90934>>>>>>>        Get AutoConnectionIDLogin to bOK
90935>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90936>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90937>>>>>>>        Open hTable
90939>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90940>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90943>>>>>>>        If (bOpen = False) Begin
90945>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90946>>>>>>>            Function_Return False
90947>>>>>>>        End
90947>>>>>>>>
90947>>>>>>>
90947>>>>>>>        Move 0 to iColumn
90948>>>>>>>        Move 0 to iRetval
90949>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90952>>>>>>>        for iColumn from 1 to iNumColumns
90958>>>>>>>>
90958>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90961>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90963>>>>>>>                Move iColumn to iRetval
90964>>>>>>>                Move iNumColumns to iColumn
90965>>>>>>>            End
90965>>>>>>>>
90965>>>>>>>        Loop
90966>>>>>>>>
90966>>>>>>>        Close hTable
90967>>>>>>>
90967>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90968>>>>>>>        Function_Return iRetval
90969>>>>>>>    End_Function
90970>>>>>>>
90970>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90970>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90970>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90972>>>>>>>        tColumnType RetvalType
90972>>>>>>>        tColumnType RetvalType
90972>>>>>>>
90972>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90973>>>>>>>        Function_Return RetvalType.iSQLType
90974>>>>>>>    End_Function
90975>>>>>>>
90975>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90975>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90975>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90977>>>>>>>        tColumnType RetvalType
90977>>>>>>>        tColumnType RetvalType
90977>>>>>>>
90977>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90978>>>>>>>        Function_Return RetvalType.sSQLType
90979>>>>>>>    End_Function
90980>>>>>>>
90980>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90982>>>>>>>        tColumnType RetvalType
90982>>>>>>>        tColumnType RetvalType
90982>>>>>>>
90982>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90983>>>>>>>        Function_Return RetvalType.sPrecision
90984>>>>>>>    End_Function
90985>>>>>>>
90985>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90987>>>>>>>        tColumnType RetvalType
90987>>>>>>>        tColumnType RetvalType
90987>>>>>>>
90987>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90988>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90988>>>>>>>        // if the column type length is _not_ fixed.
90988>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90989>>>>>>>    End_Function
90990>>>>>>>
90990>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90992>>>>>>>        tColumnType RetvalType
90992>>>>>>>        tColumnType RetvalType
90992>>>>>>>        String sValue
90992>>>>>>>        Integer iRetval iPos
90992>>>>>>>
90992>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90993>>>>>>>        Move RetvalType.sPrecision to sValue
90994>>>>>>>        Move (Pos(".", sValue)) to iPos
90995>>>>>>>        If (iPos <> 0) Begin
90997>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90998>>>>>>>        End
90998>>>>>>>>
90998>>>>>>>        Else Begin
90999>>>>>>>            Move sValue to iRetval
91000>>>>>>>        End
91000>>>>>>>>
91000>>>>>>>        Function_Return iRetval
91001>>>>>>>    End_Function
91002>>>>>>>
91002>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91004>>>>>>>        tColumnType RetvalType
91004>>>>>>>        tColumnType RetvalType
91004>>>>>>>        String sValue
91004>>>>>>>        Integer iRetval iPos
91004>>>>>>>
91004>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91005>>>>>>>        Move RetvalType.sPrecision to sValue
91006>>>>>>>        Move (Pos(".", sValue)) to iPos
91007>>>>>>>        If (iPos = 0) Begin
91009>>>>>>>            Function_Return 0
91010>>>>>>>        End
91010>>>>>>>>
91010>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91011>>>>>>>
91011>>>>>>>        Function_Return iRetval
91012>>>>>>>    End_Function
91013>>>>>>>
91013>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91013>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91015>>>>>>>        Function_Return False
91016>>>>>>>    End_Function
91017>>>>>>>
91017>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91017>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91019>>>>>>>        Boolean bIsSame
91019>>>>>>>        Integer iCount iSize
91019>>>>>>>
91019>>>>>>>        Move True to bIsSame
91020>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91021>>>>>>>        Decrement iSize
91022>>>>>>>        For iCount from 0 to iSize
91028>>>>>>>>
91028>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91029>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91030>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91031>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91032>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91033>>>>>>>            If (bIsSame = False) Begin
91035>>>>>>>                Function_Return False
91036>>>>>>>            End
91036>>>>>>>>
91036>>>>>>>        Loop
91037>>>>>>>>
91037>>>>>>>
91037>>>>>>>        Function_Return bIsSame
91038>>>>>>>    End_Function
91039>>>>>>>
91039>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91039>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91041>>>>>>>        Boolean bIsSame
91041>>>>>>>        Integer iSegment
91041>>>>>>>
91041>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91042>>>>>>>        If (bIsSame = False) Begin
91044>>>>>>>            Function_Return False
91045>>>>>>>        End
91045>>>>>>>>
91045>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91046>>>>>>>        If (bIsSame = False) Begin
91048>>>>>>>            Function_Return False
91049>>>>>>>        End
91049>>>>>>>>
91049>>>>>>>
91049>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91051>>>>>>>            // * We should probably not compare SQL index names?
91051>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91051>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91051>>>>>>>            //     Function_Return False
91051>>>>>>>            // End
91051>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91052>>>>>>>            If (bIsSame = False) Begin
91054>>>>>>>                Function_Return False
91055>>>>>>>            End
91055>>>>>>>>
91055>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91056>>>>>>>            If (bIsSame = False) Begin
91058>>>>>>>                Function_Return False
91059>>>>>>>            End
91059>>>>>>>>
91059>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91060>>>>>>>            If (bIsSame = False) Begin
91062>>>>>>>                Function_Return False
91063>>>>>>>            End
91063>>>>>>>>
91063>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
91064>>>>>>>            If (bIsSame = False) Begin
91066>>>>>>>                Function_Return False
91067>>>>>>>            End
91067>>>>>>>>
91067>>>>>>>        End
91067>>>>>>>>
91067>>>>>>>
91067>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91068>>>>>>>        Move (iSegment = -1) to bIsSame
91069>>>>>>>
91069>>>>>>>        Function_Return (bIsSame = True)
91070>>>>>>>    End_Function
91071>>>>>>>
91071>>>>>>>    // Compares each segment for the passed index.
91071>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91071>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91073>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91073>>>>>>>        Boolean bIsSame
91073>>>>>>>
91073>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91074>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91075>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91076>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
91077>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91078>>>>>>>
91078>>>>>>>        Decrement iNumSegments
91079>>>>>>>        for iSegment from 0 to iNumSegments
91085>>>>>>>>
91085>>>>>>>            Move False to bIsSame
91086>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
91088>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91089>>>>>>>            End
91089>>>>>>>>
91089>>>>>>>            If (bIsSame = False) Begin
91091>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91092>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91093>>>>>>>                Function_Return iSegment
91094>>>>>>>            End
91094>>>>>>>>
91094>>>>>>>        Loop
91095>>>>>>>>
91095>>>>>>>
91095>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91096>>>>>>>        Function_Return -1 // This means bIsSame = True
91097>>>>>>>    End_Function
91098>>>>>>>
91098>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91100>>>>>>>        Boolean bIsSame
91100>>>>>>>
91100>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91101>>>>>>>        If (bIsSame = False) Begin
91103>>>>>>>            Function_Return False
91104>>>>>>>        End
91104>>>>>>>>
91104>>>>>>>        If (bCompareIndexUppercase = True) Begin
91106>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91107>>>>>>>            If (bIsSame = False) Begin
91109>>>>>>>                Function_Return False
91110>>>>>>>            End
91110>>>>>>>>
91110>>>>>>>        End
91110>>>>>>>>
91110>>>>>>>        If (bCompareIndexAscending = True) Begin
91112>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91113>>>>>>>            If (bIsSame = False) Begin
91115>>>>>>>                Function_Return False
91116>>>>>>>            End
91116>>>>>>>>
91116>>>>>>>        End
91116>>>>>>>>
91116>>>>>>>
91116>>>>>>>        Function_Return True
91117>>>>>>>    End_Function
91118>>>>>>>
91118>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91120>>>>>>>        Boolean bIsSame bOK
91120>>>>>>>        Integer iSize iSizeTo iCount
91120>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91120>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91121>>>>>>>
91121>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91122>>>>>>>        If (iSize = 0) Begin
91124>>>>>>>            Function_Return True
91125>>>>>>>        End
91125>>>>>>>>
91125>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
91126>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
91127>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91128>>>>>>>
91128>>>>>>>        for iCount from 0 to (iSize - 1)
91134>>>>>>>>
91134>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91135>>>>>>>            If (bIsSame = False) Begin
91137>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91138>>>>>>>            End
91138>>>>>>>>
91138>>>>>>>        Loop
91139>>>>>>>>
91139>>>>>>>
91139>>>>>>>        // We probably should delete other indexes if they exists.
91139>>>>>>>        for iCount from (iSize +1) to iSizeTo
91145>>>>>>>>
91145>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91146>>>>>>>        Loop
91147>>>>>>>>
91147>>>>>>>
91147>>>>>>>        Function_Return bOK
91148>>>>>>>    End_Function
91149>>>>>>>
91149>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91151>>>>>>>        tAPIIndex[] APIIndexes
91151>>>>>>>        tAPIIndex[] APIIndexes
91152>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91152>>>>>>>        String sDriverID
91152>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
91152>>>>>>>
91152>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91153>>>>>>>        Get psDriverID to sDriverID
91154>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91155>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
91156>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91159>>>>>>>        If (bIsOpen = False) Begin
91161>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91162>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91163>>>>>>>            Open hTable
91165>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91166>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91167>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91170>>>>>>>            If (bIsOpen = False) Begin
91172>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91173>>>>>>>                Move True to APIIndexes[0].bError
91174>>>>>>>                Function_Return APIIndexes
91175>>>>>>>            End
91175>>>>>>>>
91175>>>>>>>        End
91175>>>>>>>>
91175>>>>>>>
91175>>>>>>>        Move 0 to iCount
91176>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91179>>>>>>>        for iIndex from 1 to iIndexes
91185>>>>>>>>
91185>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91185>>>>>>>            // numbers doesn't not need to be consequitive:
91185>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91188>>>>>>>            If (iNumSegments > 0) Begin
91190>>>>>>>
91190>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91191>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91194>>>>>>>                If (bIsSQLTable = True) Begin
91196>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91199>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91202>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91205>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91208>>>>>>>                End
91208>>>>>>>>
91208>>>>>>>
91208>>>>>>>                Move 0 to iSegmentCount
91209>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91212>>>>>>>                For iSegment from 1 to iNumSegments
91218>>>>>>>>
91218>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91221>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91222>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91225>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91228>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91231>>>>>>>                    Increment iSegmentCount
91232>>>>>>>                Loop
91233>>>>>>>>
91233>>>>>>>                Increment iCount
91234>>>>>>>            End
91234>>>>>>>>
91234>>>>>>>        Loop
91235>>>>>>>>
91235>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91236>>>>>>>
91236>>>>>>>        Function_Return APIIndexes
91237>>>>>>>    End_Function
91238>>>>>>>
91238>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91238>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91238>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91238>>>>>>>    // have "holes" in the series of index numbers.
91238>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91240>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91240>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91241>>>>>>>        tAPIIndexCompare   APIIndexCompare
91241>>>>>>>        tAPIIndexCompare   APIIndexCompare
91241>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91241>>>>>>>
91241>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91242>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91243>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91245>>>>>>>            Function_Return aAPIIndexCompare
91246>>>>>>>        End
91246>>>>>>>>
91246>>>>>>>
91246>>>>>>>        Decrement iSizeFrom
91247>>>>>>>        for iCount from 0 to iSizeFrom
91253>>>>>>>>
91253>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91254>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91255>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91256>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91257>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91258>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91259>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91260>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91261>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91262>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91263>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91264>>>>>>>        Loop
91265>>>>>>>>
91265>>>>>>>
91265>>>>>>>        Decrement iSizeTo
91266>>>>>>>        for iCount from 0 to iSizeTo
91272>>>>>>>>
91272>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91273>>>>>>>            // Search if the Index number already exists in the array; else add it.
91273>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91274>>>>>>>            If (iItem = -1) Begin
91276>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91277>>>>>>>            End
91277>>>>>>>>
91277>>>>>>>
91277>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91278>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91279>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91280>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91281>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91282>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91283>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91284>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91285>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91286>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91287>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91288>>>>>>>        Loop
91289>>>>>>>>
91289>>>>>>>
91289>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91290>>>>>>>
91290>>>>>>>        Function_Return aAPIIndexCompare
91291>>>>>>>    End_Function
91292>>>>>>>
91292>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91292>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91294>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91294>>>>>>>        String sDriverID
91294>>>>>>>
91294>>>>>>>        Get psDriverID to sDriverID
91295>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91296>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91297>>>>>>>        If (bIsSqlTable = True) Begin
91299>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
91300>>>>>>>        End
91300>>>>>>>>
91300>>>>>>>
91300>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91301>>>>>>>        If (bIsSame = False) Begin
91303>>>>>>>            Function_Return False
91304>>>>>>>        End
91304>>>>>>>>
91304>>>>>>>
91304>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91306>>>>>>>            // Don't think we should do this. Or should we?
91306>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91306>>>>>>>
91306>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91307>>>>>>>            If (bIsSame = False) Begin
91309>>>>>>>                Function_Return False
91310>>>>>>>            End
91310>>>>>>>>
91310>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91311>>>>>>>            If (bIsSame = False) Begin
91313>>>>>>>                Function_Return False
91314>>>>>>>            End
91314>>>>>>>>
91314>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91315>>>>>>>            If (bIsSame = False) Begin
91317>>>>>>>                Function_Return False
91318>>>>>>>            End
91318>>>>>>>>
91318>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91319>>>>>>>            If (bIsSame = False) Begin
91321>>>>>>>                Function_Return False
91322>>>>>>>            End
91322>>>>>>>>
91322>>>>>>>        End
91322>>>>>>>>
91322>>>>>>>
91322>>>>>>>        Function_Return bIsSame
91323>>>>>>>    End_Function
91324>>>>>>>
91324>>>>>>>    // DF_INDEX_SQL_TYPE values
91324>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91324>>>>>>>    // returns a string with the name.
91324>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91326>>>>>>>        String sRetval
91326>>>>>>>            Case Begin
91326>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91328>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91329>>>>>>>                    Case Break
91330>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91333>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91334>>>>>>>                    Case Break
91335>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91338>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91339>>>>>>>                    Case Break
91340>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91343>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91344>>>>>>>                    Case Break
91345>>>>>>>                Case Else
91345>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91346>>>>>>>            Case End
91346>>>>>>>        Function_Return sRetval
91347>>>>>>>    End_Function
91348>>>>>>>
91348>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91348>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91350>>>>>>>        Function_Return False
91351>>>>>>>    End_Function
91352>>>>>>>
91352>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91352>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91354>>>>>>>        Boolean bIsSame
91354>>>>>>>        Integer iSize iCount
91354>>>>>>>
91354>>>>>>>        Move True to bIsSame
91355>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91356>>>>>>>        Decrement iSize
91357>>>>>>>        For iCount from 0 to iSize
91363>>>>>>>>
91363>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91364>>>>>>>            If (bIsSame = False) Begin
91366>>>>>>>                Function_Return False
91367>>>>>>>            End
91367>>>>>>>>
91367>>>>>>>        Loop
91368>>>>>>>>
91368>>>>>>>
91368>>>>>>>        Function_Return bIsSame
91369>>>>>>>    End_Function
91370>>>>>>>
91370>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91370>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91372>>>>>>>        Boolean bIsSame
91372>>>>>>>
91372>>>>>>>        Move True to bIsSame
91373>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91375>>>>>>>            Function_Return False
91376>>>>>>>        End
91376>>>>>>>>
91376>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91378>>>>>>>            Function_Return False
91379>>>>>>>        End
91379>>>>>>>>
91379>>>>>>>
91379>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91379>>>>>>>
91379>>>>>>>        Function_Return bIsSame
91380>>>>>>>    End_Function
91381>>>>>>>
91381>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91381>>>>>>>    // already exists.
91381>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91383>>>>>>>        Boolean bOK
91383>>>>>>>        Integer iSizeTo iSize iCount iColumn
91383>>>>>>>        String sDriverID
91383>>>>>>>
91383>>>>>>>        Move True to bOK
91384>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91385>>>>>>>        If (iSizeTo > 0) Begin
91387>>>>>>>            Get AutoConnectionIDLogin to bOK
91388>>>>>>>            Move False to Err
91389>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91391>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91394>>>>>>>            Decrement iSizeTo
91395>>>>>>>
91395>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91395>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91395>>>>>>>            Structure_Start hTable sDriverID
91396>>>>>>>                for iCount from 0 to iSizeTo
91402>>>>>>>>
91402>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91403>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91406>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91409>>>>>>>                Loop
91410>>>>>>>>
91410>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91411>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91413>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91414>>>>>>>        End
91414>>>>>>>>
91414>>>>>>>
91414>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91415>>>>>>>        Decrement iSize
91416>>>>>>>        for iCount from 0 to iSize
91422>>>>>>>>
91422>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91423>>>>>>>        Loop
91424>>>>>>>>
91424>>>>>>>
91424>>>>>>>        Function_Return bOK
91425>>>>>>>    End_Function
91426>>>>>>>
91426>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91428>>>>>>>        tAPIRelation[] APIRelations
91428>>>>>>>        tAPIRelation[] APIRelations
91429>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91429>>>>>>>        Handle hParent
91429>>>>>>>        Boolean bIsOpen
91429>>>>>>>
91429>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91430>>>>>>>        Move 0 to iCount
91431>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91434>>>>>>>        If (bIsOpen = False) Begin
91436>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91437>>>>>>>            Open hTable
91439>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91440>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91443>>>>>>>            If (bIsOpen = False) Begin
91445>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91446>>>>>>>                Move True to APIRelations[0].bError
91447>>>>>>>                Function_Return APIRelations
91448>>>>>>>            End
91448>>>>>>>>
91448>>>>>>>        End
91448>>>>>>>>
91448>>>>>>>
91448>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91451>>>>>>>        For iColumn from 1 to iNumColumns
91457>>>>>>>>
91457>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91460>>>>>>>            If (hParent <> 0) Begin
91462>>>>>>>                Open hParent
91464>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91465>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91468>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91469>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91472>>>>>>>
91472>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91473>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91476>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91479>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91480>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91483>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91484>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91485>>>>>>>                Move False                                              to APIRelations[iCount].bError
91486>>>>>>>                Close hParent
91487>>>>>>>                Increment iCount
91488>>>>>>>            End
91488>>>>>>>>
91488>>>>>>>        Loop
91489>>>>>>>>
91489>>>>>>>
91489>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91490>>>>>>>        Function_Return APIRelations
91491>>>>>>>    End_Function
91492>>>>>>>
91492>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO relation arrays.
91492>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91492>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91494>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91494>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91495>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91495>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91496>>>>>>>        tAPIRelationCompare   APIRelationCompare
91496>>>>>>>        tAPIRelationCompare   APIRelationCompare
91496>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91496>>>>>>>
91496>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91497>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91498>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91500>>>>>>>            Function_Return aAPIRelationCompare
91501>>>>>>>        End
91501>>>>>>>>
91501>>>>>>>
91501>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91502>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91503>>>>>>>
91503>>>>>>>        Decrement iSizeFrom
91504>>>>>>>        for iCount from 0 to iSizeFrom
91510>>>>>>>>
91510>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91511>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91512>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91513>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91514>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91515>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91516>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91517>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91518>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91519>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91520>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91521>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91522>>>>>>>        Loop
91523>>>>>>>>
91523>>>>>>>
91523>>>>>>>        Decrement iSizeTo
91524>>>>>>>        for iCount from 0 to iSizeTo
91530>>>>>>>>
91530>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91531>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91532>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91533>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91534>>>>>>>
91534>>>>>>>            // Search if the relation already exists in the array; else add it.
91534>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91535>>>>>>>            If (iItem = -1) Begin
91537>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91538>>>>>>>            End
91538>>>>>>>>
91538>>>>>>>
91538>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91539>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91540>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91541>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91542>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91543>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91544>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91545>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91546>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91547>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91548>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91549>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91550>>>>>>>        Loop
91551>>>>>>>>
91551>>>>>>>
91551>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91552>>>>>>>
91552>>>>>>>        Function_Return aAPIRelationCompare
91553>>>>>>>    End_Function
91554>>>>>>>
91554>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91554>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91556>>>>>>>        Function_Return False
91557>>>>>>>    End_Function
91558>>>>>>>
91558>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91558>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91558>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91558>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91560>>>>>>>        Boolean bFound
91560>>>>>>>
91560>>>>>>>        Move False to Err
91561>>>>>>>        Open CodeMast
91563>>>>>>>        Open CodeType
91565>>>>>>>
91565>>>>>>>        If (bCodeType = True) Begin
91567>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91568>>>>>>>            Clear CodeType
91569>>>>>>>            Move sTypeValue to CODETYPE.Type
91570>>>>>>>            Find eq CODETYPE by 1
91571>>>>>>>>
91571>>>>>>>            Move Found to bFound
91572>>>>>>>            If (bFound = True) Begin
91574>>>>>>>                Reread CodeType
91578>>>>>>>            End
91578>>>>>>>>
91578>>>>>>>            Else Begin
91579>>>>>>>                Clear CodeType
91580>>>>>>>            End
91580>>>>>>>>
91580>>>>>>>
91580>>>>>>>            Move sTypeValue to CODETYPE.Type
91581>>>>>>>            Move sValue2    to CODETYPE.Description
91582>>>>>>>            Move sValue3    to CODETYPE.Comment
91583>>>>>>>            SaveRecord CODETYPE
91584>>>>>>>
91584>>>>>>>            If (bFound = True) Begin
91586>>>>>>>                Unlock
91587>>>>>>>>
91587>>>>>>>            End
91587>>>>>>>>
91587>>>>>>>        End
91587>>>>>>>>
91587>>>>>>>
91587>>>>>>>        If (bCodeType = False) Begin
91589>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91590>>>>>>>            Clear CODEMAST
91591>>>>>>>            Move sTypeValue to CODEMAST.Type
91592>>>>>>>            Move sValue2    to CODEMAST.Code
91593>>>>>>>            Find eq CODEMAST by 1
91594>>>>>>>>
91594>>>>>>>            Move Found to bFound
91595>>>>>>>            If (bFound = True) Begin
91597>>>>>>>                Reread CODEMAST
91601>>>>>>>            End
91601>>>>>>>>
91601>>>>>>>            Else Begin
91602>>>>>>>                Clear CODEMAST
91603>>>>>>>            End
91603>>>>>>>>
91603>>>>>>>
91603>>>>>>>            Move sTypeValue to CODEMAST.Type
91604>>>>>>>            Move sValue2    to CODEMAST.Code
91605>>>>>>>            Move sValue3    to CODEMAST.Description
91606>>>>>>>            SaveRecord CODEMAST
91607>>>>>>>
91607>>>>>>>            If (bFound = True) Begin
91609>>>>>>>                Unlock
91610>>>>>>>>
91610>>>>>>>            End
91610>>>>>>>>
91610>>>>>>>        End
91610>>>>>>>>
91610>>>>>>>
91610>>>>>>>        Close CodeMast
91611>>>>>>>        Close CodeType
91612>>>>>>>
91612>>>>>>>        Function_Return (Err = False)
91613>>>>>>>    End_Function
91614>>>>>>>
91614>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91614>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91614>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91616>>>>>>>        Boolean bFound
91616>>>>>>>
91616>>>>>>>        Move False to Err
91617>>>>>>>        Open CodeMast
91619>>>>>>>        Open CodeType
91621>>>>>>>
91621>>>>>>>        Clear CodeType
91622>>>>>>>        Move sFromValue to CODETYPE.Type
91623>>>>>>>        Find eq CODETYPE.Type
91624>>>>>>>>
91624>>>>>>>        If (Found = True) Begin
91626>>>>>>>            Reread CODETYPE
91630>>>>>>>                Move sToValue to CODETYPE.Type
91631>>>>>>>                SaveRecord CODETYPE
91632>>>>>>>            Unlock
91633>>>>>>>>
91633>>>>>>>        End
91633>>>>>>>>
91633>>>>>>>
91633>>>>>>>        Clear CODEMAST
91634>>>>>>>        Find gt CODEMAST by Recnum
91635>>>>>>>>
91635>>>>>>>        While (Found = True)
91639>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91640>>>>>>>            If (bFound = True) Begin
91642>>>>>>>                Reread CODEMAST
91646>>>>>>>                    Move sToValue to CODEMAST.Type
91647>>>>>>>                    SaveRecord CODEMAST
91648>>>>>>>                Unlock
91649>>>>>>>>
91649>>>>>>>            End
91649>>>>>>>>
91649>>>>>>>            Find gt CODEMAST by Recnum
91650>>>>>>>>
91650>>>>>>>        Loop
91651>>>>>>>>
91651>>>>>>>
91651>>>>>>>        Close CodeMast
91652>>>>>>>        Close CodeType
91653>>>>>>>
91653>>>>>>>        Function_Return (Err = False)
91654>>>>>>>    End_Function
91655>>>>>>>
91655>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91655>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91657>>>>>>>        Boolean bFound
91657>>>>>>>
91657>>>>>>>        Move False to Err
91658>>>>>>>        Open CodeMast
91660>>>>>>>
91660>>>>>>>        Clear CODEMAST
91661>>>>>>>        Move sTypeValue to CODEMAST.Type
91662>>>>>>>        Move sValue2    to CODEMAST.Code
91663>>>>>>>        Find eq CODEMAST.Code
91664>>>>>>>>
91664>>>>>>>        Move Found to bFound
91665>>>>>>>        If (bFound = True) Begin
91667>>>>>>>            Delete CODEMAST
91668>>>>>>>        End
91668>>>>>>>>
91668>>>>>>>
91668>>>>>>>        Close CodeMast
91669>>>>>>>
91669>>>>>>>        Function_Return (Err = False)
91670>>>>>>>    End_Function
91671>>>>>>>
91671>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91673>>>>>>>        Boolean bRecnum bToAnsi
91673>>>>>>>        Integer iCh
91673>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91673>>>>>>>
91673>>>>>>>        If (Trim(sDataPath) = "") Begin
91675>>>>>>>            Function_Return False
91676>>>>>>>        End
91676>>>>>>>>
91676>>>>>>>
91676>>>>>>>        Move False to Err
91677>>>>>>>        Get psDriverID     to sDriverID
91678>>>>>>>        Get psConnectionID to sConnectionID
91679>>>>>>>        Get psSchema       to sSchemaName
91680>>>>>>>        Get True           to bRecnum
91681>>>>>>>        Get pbToANSI       to bToAnsi
91682>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91683>>>>>>>        If (bToAnsi = False) Begin
91685>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91686>>>>>>>        End
91686>>>>>>>>
91686>>>>>>>
91686>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91687>>>>>>>        Move "CodeMast.int"         to sFileName
91688>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91689>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91692>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91695>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91698>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91701>>>>>>>            Writeln channel iCh ("")
91704>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91707>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91710>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91713>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91716>>>>>>>            Writeln channel iCh ("")
91719>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91722>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91725>>>>>>>            Writeln channel iCh ("")
91728>>>>>>>        Send Seq_Close_Channel iCh
91729>>>>>>>
91729>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91730>>>>>>>        Move "CodeType.int"         to sFileName
91731>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91732>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91735>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91738>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91741>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91744>>>>>>>            Writeln channel iCh ("")
91747>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91750>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91753>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91756>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91759>>>>>>>            Writeln channel iCh ("")
91762>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91765>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91768>>>>>>>            Writeln channel iCh ("")
91771>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91774>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91777>>>>>>>            Writeln channel iCh ("")
91780>>>>>>>        Send Seq_Close_Channel iCh
91781>>>>>>>
91781>>>>>>>        Function_Return (Err = False)
91782>>>>>>>    End_Function
91783>>>>>>>
91783>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91783>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91785>>>>>>>        Function_Return False
91786>>>>>>>    End_Function
91787>>>>>>>
91787>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91787>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91787>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91789>>>>>>>        Boolean bOK bExists
91789>>>>>>>        String sDataPath sBackupFolder
91789>>>>>>>
91789>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91790>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91791>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91792>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91793>>>>>>>
91793>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91794>>>>>>>        If (bExists = False) Begin
91796>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91797>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91798>>>>>>>            If (bExists = False) Begin
91800>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91801>>>>>>>>
91801>>>>>>>                Function_Return False
91802>>>>>>>            End
91802>>>>>>>>
91802>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91803>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91804>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91805>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91806>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91807>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91808>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91809>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91810>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91811>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91812>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91813>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91814>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91815>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91816>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91817>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91818>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91819>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91820>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91821>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91822>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91823>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91824>>>>>>>        End
91824>>>>>>>>
91824>>>>>>>
91824>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91825>>>>>>>        Function_Return True
91826>>>>>>>    End_Function
91827>>>>>>>    
91827>>>>>>>    // Check if the file exists in the Data folder,
91827>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91827>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91829>>>>>>>        String sPath
91829>>>>>>>        Boolean bExists
91829>>>>>>>
91829>>>>>>>        Get psDataPathFirstPart to sPath
91830>>>>>>>        Move (sPath + sFileName) to sFileName
91831>>>>>>>        Get vFilePathExists sFileName to bExists
91832>>>>>>>
91832>>>>>>>        If (bExists = False) Begin
91834>>>>>>>            // Read from memory & create file on disk.
91834>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91835>>>>>>>            Get vFilePathExists sFileName to bExists
91836>>>>>>>        End
91836>>>>>>>>
91836>>>>>>>        Function_Return bExists
91837>>>>>>>    End_Function
91838>>>>>>>
91838>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91840>>>>>>>        tColumnType RetvalType
91840>>>>>>>        tColumnType RetvalType
91840>>>>>>>        Integer iRetval
91840>>>>>>>
91840>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91841>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91842>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91844>>>>>>>            If (iLength <= 255) Begin
91846>>>>>>>                Move DF_ASCII to iRetval
91847>>>>>>>            End
91847>>>>>>>>
91847>>>>>>>        End
91847>>>>>>>>
91847>>>>>>>        Function_Return iRetval
91848>>>>>>>    End_Function
91849>>>>>>>
91849>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91851>>>>>>>        String sRetval
91851>>>>>>>
91851>>>>>>>        Case Begin
91851>>>>>>>            Case (iDataType = DF_ASCII)
91853>>>>>>>                Move "DF_ASCII" to sRetval
91854>>>>>>>                Case Break
91855>>>>>>>            Case (iDataType = DF_BCD)
91858>>>>>>>                Move "DF_BCD" to sRetval
91859>>>>>>>                Case Break
91860>>>>>>>            Case (iDataType = DF_BINARY)
91863>>>>>>>                Move "DF_BINARY" to sRetval
91864>>>>>>>                Case Break
91865>>>>>>>            Case (iDataType = DF_DATE)
91868>>>>>>>                Move "DF_DATE" to sRetval
91869>>>>>>>                Case Break
91870>>>>>>>            Case (iDataType = DF_DATETIME)
91873>>>>>>>                Move "DF_DATETIME" to sRetval
91874>>>>>>>                Case Break
91875>>>>>>>            Case (iDataType = DF_TEXT)
91878>>>>>>>                Move "DF_TEXT" to sRetval
91879>>>>>>>                Case Break
91880>>>>>>>            Case Else
91880>>>>>>>                Move "" to sRetval
91881>>>>>>>        Case End
91881>>>>>>>
91881>>>>>>>        Function_Return sRetval
91882>>>>>>>    End_Function
91883>>>>>>>
91883>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91883>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91885>>>>>>>        String sRetval sServer
91885>>>>>>>        tColumnType RetvalType
91885>>>>>>>        tColumnType RetvalType
91885>>>>>>>        Integer iDriver iDataFlexType
91885>>>>>>>        Handle hDatabase
91885>>>>>>>
91885>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91886>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91887>>>>>>>        Get DriverIndex sDriverID to iDriver
91888>>>>>>>        Get psServer to sServer
91889>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91890>>>>>>>        If (hDatabase = 0) Begin
91892>>>>>>>            Function_Return ""
91893>>>>>>>        End
91893>>>>>>>>
91893>>>>>>>
91893>>>>>>>        Case Begin
91893>>>>>>>            Case (iDataFlexType = DF_ASCII)
91895>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91898>>>>>>>                Case Break
91899>>>>>>>            Case (iDataFlexType = DF_BCD)
91902>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91905>>>>>>>                Case Break
91906>>>>>>>            Case (iDataFlexType = DF_BINARY)
91909>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91912>>>>>>>                Case Break
91913>>>>>>>            Case (iDataFlexType = DF_DATE)
91916>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91919>>>>>>>                Case Break
91920>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91923>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91926>>>>>>>                Case Break
91927>>>>>>>            Case (iDataFlexType = DF_TEXT)
91930>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91933>>>>>>>                Case Break
91934>>>>>>>            Case Else
91934>>>>>>>                Move "" to sRetval
91935>>>>>>>        Case End
91935>>>>>>>
91935>>>>>>>        Function_Return sRetval
91936>>>>>>>    End_Function
91937>>>>>>>
91937>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91939>>>>>>>        String sDriverID sServer
91939>>>>>>>        tColumnType RetvalType
91939>>>>>>>        tColumnType RetvalType
91939>>>>>>>        Integer iDbType iDriver
91939>>>>>>>        Handle hDatabase
91939>>>>>>>
91939>>>>>>>        Get psDriverID to sDriverID
91940>>>>>>>        Get piDbType   to iDbType
91941>>>>>>>        Get DriverIndex sDriverID to iDriver
91942>>>>>>>        Get psServer to sServer
91943>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91944>>>>>>>        If (hDatabase = 0) Begin
91946>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91947>>>>>>>>
91947>>>>>>>            Procedure_Return
91948>>>>>>>        End
91948>>>>>>>>
91948>>>>>>>
91948>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91951>>>>>>>
91951>>>>>>>    End_Procedure
91952>>>>>>>
91952>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91954>>>>>>>        String sDriverID sServer
91954>>>>>>>        tColumnType RetvalType
91954>>>>>>>        tColumnType RetvalType
91954>>>>>>>        Integer iDbType iDriver
91954>>>>>>>        Handle hDatabase
91954>>>>>>>
91954>>>>>>>        Get psDriverID to sDriverID
91955>>>>>>>        Get piDbType   to iDbType
91956>>>>>>>        Get DriverIndex sDriverID to iDriver
91957>>>>>>>        Get psServer to sServer
91958>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91959>>>>>>>        If (hDatabase = 0) Begin
91961>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91962>>>>>>>>
91962>>>>>>>            Procedure_Return
91963>>>>>>>        End
91963>>>>>>>>
91963>>>>>>>
91963>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91966>>>>>>>
91966>>>>>>>    End_Procedure
91967>>>>>>>
91967>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91967>>>>>>>    // are mapped to the standard DataFlex data types.
91967>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91967>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91969>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91969>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91971>>>>>>>        String sDataType
91971>>>>>>>        Integer iDataType iDriverID iCount
91971>>>>>>>        Boolean bSQLDriver
91971>>>>>>>
91971>>>>>>>        Move 0 to iCount
91972>>>>>>>        Get DriverIndex sDriverID to iDriverID
91973>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91974>>>>>>>        If (bSQLDriver = False) Begin
91976>>>>>>>            Function_Return EmptyArray
91977>>>>>>>        End
91977>>>>>>>>
91977>>>>>>>
91977>>>>>>>        // DF_ASCII
91977>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91979>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91982>>>>>>>        End
91982>>>>>>>>
91982>>>>>>>        Else Begin
91983>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91986>>>>>>>        End
91986>>>>>>>>
91986>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91987>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91988>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91989>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91990>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91991>>>>>>>        Increment iCount
91992>>>>>>>
91992>>>>>>>        // DF_BINARY
91992>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91994>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91997>>>>>>>        End
91997>>>>>>>>
91997>>>>>>>        Else Begin
91998>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92001>>>>>>>        End
92001>>>>>>>>
92001>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92002>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92003>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92004>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92005>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92006>>>>>>>        Increment iCount
92007>>>>>>>
92007>>>>>>>        // DF_DATE
92007>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92009>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92012>>>>>>>        End
92012>>>>>>>>
92012>>>>>>>        Else Begin
92013>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92016>>>>>>>        End
92016>>>>>>>>
92016>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92017>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92018>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92019>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92020>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92021>>>>>>>        Increment iCount
92022>>>>>>>
92022>>>>>>>        // DF_DATETIME
92022>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92024>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92027>>>>>>>        End
92027>>>>>>>>
92027>>>>>>>        Else Begin
92028>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92031>>>>>>>        End
92031>>>>>>>>
92031>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92032>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92033>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92034>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92035>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92036>>>>>>>        Increment iCount
92037>>>>>>>
92037>>>>>>>        // DF_NUMERIC
92037>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92037>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92037>>>>>>>        // we make them here all "Numeric"...
92037>>>>>>>        Case Begin
92037>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92039>>>>>>>                Move SQL_NUMERIC to iDataType
92040>>>>>>>                Move "numeric"   to sDataType
92041>>>>>>>                Case Break
92042>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92045>>>>>>>                Move SQL_NUMERIC to iDataType
92046>>>>>>>                Move "NUMERIC"   to sDataType
92047>>>>>>>                Case Break
92048>>>>>>>            Case Else
92048>>>>>>>                Move DF_BCD      to iDataType
92049>>>>>>>                Move "Numeric"   to sDataType
92050>>>>>>>        Case End
92050>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92051>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92052>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92053>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92054>>>>>>>        Increment iCount
92055>>>>>>>
92055>>>>>>>        // DF_TEXT
92055>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92057>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92060>>>>>>>        End
92060>>>>>>>>
92060>>>>>>>        Else Begin
92061>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92064>>>>>>>        End
92064>>>>>>>>
92064>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92065>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92066>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92067>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92068>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92069>>>>>>>
92069>>>>>>>        Function_Return ColumnTypeArray
92070>>>>>>>    End_Function
92071>>>>>>>
92071>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92073>>>>>>>        tColumnType[] ColumnTypeArray
92073>>>>>>>        tColumnType[] ColumnTypeArray
92074>>>>>>>        tColumnType   ColumnType
92074>>>>>>>        tColumnType   ColumnType
92074>>>>>>>        Integer iCount iSize
92074>>>>>>>
92074>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92075>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92076>>>>>>>        Decrement iSize
92077>>>>>>>
92077>>>>>>>        for iCount from 0 to iSize
92083>>>>>>>>
92083>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92085>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92086>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92087>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92088>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92089>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92090>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92091>>>>>>>                Move iSize to iCount
92092>>>>>>>            End
92092>>>>>>>>
92092>>>>>>>        Loop
92093>>>>>>>>
92093>>>>>>>
92093>>>>>>>        Function_Return ColumnType
92094>>>>>>>    End_Function
92095>>>>>>>
92095>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92095>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92095>>>>>>>    // but the Logical name is different.
92095>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92095>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92097>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
92097>>>>>>>        Handle hInTable hMasterTable 
92097>>>>>>>        Boolean bIsAlias
92097>>>>>>>        
92097>>>>>>>        Move hTable to hInTable
92098>>>>>>>        Move False to bIsAlias
92099>>>>>>>        Move 0 to hMasterTable
92100>>>>>>>        
92100>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92103>>>>>>>        // Remove any prefix with a driver name.
92103>>>>>>>        Get _TableNameOnly sRootName to sRootName     
92104>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92107>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
92108>>>>>>>        
92108>>>>>>>        // If the table has the same root and logical name it can't be an alias,
92108>>>>>>>        // so we can safely return a "False".
92108>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
92110>>>>>>>            Function_Return True
92111>>>>>>>        End
92111>>>>>>>>
92111>>>>>>>        
92111>>>>>>>        Function_Return False
92112>>>>>>>        
92112>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
92112>>>>>>>        // as the passed hTable root name.
92112>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
92112>>>>>>>//        Move 0 to hTable
92112>>>>>>>//        Repeat
92112>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92112>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92112>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
92112>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
92112>>>>>>>//                // If we found another table with the same root and logical name
92112>>>>>>>//                // we have found a master table.
92112>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
92112>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
92112>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
92112>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
92112>>>>>>>//                        Move hTable to hMasterTable   
92112>>>>>>>//                        Move 0 to hTable // To end the loop.
92112>>>>>>>//                    End
92112>>>>>>>//                End
92112>>>>>>>//            End
92112>>>>>>>//        Until (hTable = 0)
92112>>>>>>>//        
92112>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
92112>>>>>>>//            Move True to bIsAlias
92112>>>>>>>//        End
92112>>>>>>>//        
92112>>>>>>>//        Function_Return bIsAlias
92112>>>>>>>    End_Function
92113>>>>>>>
92113>>>>>>>    // To Open a table with any driver.
92113>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92113>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92113>>>>>>>    //
92113>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92113>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92113>>>>>>>    // returns a True if successful (table could be opened).
92113>>>>>>>    //
92113>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92113>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92113>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92113>>>>>>>    // set properly we can open the table.
92113>>>>>>>    //
92113>>>>>>>    // DAW Driver Syntax:
92113>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92113>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92113>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92113>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92113>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92113>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92113>>>>>>>    //
92113>>>>>>>    // DAW Driver Sample:
92113>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92113>>>>>>>    //
92113>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92115>>>>>>>        String sTableNameOrg
92115>>>>>>>        Boolean bOpen bOK
92115>>>>>>>        tSQLConnection SQLConnection
92115>>>>>>>        tSQLConnection SQLConnection
92115>>>>>>>        
92115>>>>>>>        Move False to bOpen
92116>>>>>>>        Move sTableName to sTableNameOrg
92117>>>>>>>        If (hTable > 0) Begin
92119>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92120>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92121>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92122>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92123>>>>>>>            Open hTable Mode iMode
92125>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92126>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92127>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92128>>>>>>>            Send Trap_Error of Error_Object_Id 10
92129>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92132>>>>>>>            If (bOpen = True) Begin
92134>>>>>>>                Function_Return True
92135>>>>>>>            End
92135>>>>>>>>
92135>>>>>>>        End
92135>>>>>>>>
92135>>>>>>>
92135>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92136>>>>>>>        If (hTable > 0) Begin
92138>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92141>>>>>>>        End
92141>>>>>>>>
92141>>>>>>>
92141>>>>>>>        Function_Return bOpen
92142>>>>>>>    End_Function
92143>>>>>>>
92143>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92145>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92145>>>>>>>        Boolean bOpen bOK
92145>>>>>>>        tSQLConnection SQLConnection
92145>>>>>>>        tSQLConnection SQLConnection
92145>>>>>>>
92145>>>>>>>        If (hTable < 1) Begin
92147>>>>>>>            Function_Return False
92148>>>>>>>        End
92148>>>>>>>>
92148>>>>>>>
92148>>>>>>>        Move sTableName to sTableNameOrg
92149>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92150>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92151>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92152>>>>>>>        Move SQLConnection.sSchema to sSchema
92153>>>>>>>        If (sSchema = "") Begin
92155>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92156>>>>>>>        End
92156>>>>>>>>
92156>>>>>>>
92156>>>>>>>        // We need to remove the ".int" part of the table name because
92156>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92156>>>>>>>        // "bare" table name without any extension.
92156>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92158>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92160>>>>>>>                Get ParseFileExtension sTableName to sExt
92161>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92162>>>>>>>            End
92162>>>>>>>>
92162>>>>>>>            Else Begin
92163>>>>>>>                Move sTableName to sTableNameShort
92164>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92165>>>>>>>            End
92165>>>>>>>>
92165>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92166>>>>>>>            Move sConnection to sTableName
92167>>>>>>>        End
92167>>>>>>>>
92167>>>>>>>
92167>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92168>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92169>>>>>>>        If (hTable = 0) Begin
92171>>>>>>>            Get NextFreeFilelistSlot to hTable
92172>>>>>>>        End
92172>>>>>>>>
92172>>>>>>>
92172>>>>>>>        Case Begin
92172>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92174>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92174>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92176>>>>>>>                    Close hTable
92177>>>>>>>                    Open sTableName as hTable
92179>>>>>>>                End
92179>>>>>>>>
92179>>>>>>>                Else Begin
92180>>>>>>>                    Get OpenTableExclusive hTable to bOK
92181>>>>>>>                    If (bOK = False) Begin
92183>>>>>>>                        Function_Return False
92184>>>>>>>                    End
92184>>>>>>>>
92184>>>>>>>                End
92184>>>>>>>>
92184>>>>>>>                Case Break
92185>>>>>>>
92185>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92188>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92188>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92190>>>>>>>                    Close hTable
92191>>>>>>>                    Open sTableName as hTable
92193>>>>>>>                End
92193>>>>>>>>
92193>>>>>>>                Else Begin
92194>>>>>>>                    Get OpenTableExclusive hTable to bOK
92195>>>>>>>                    If (bOK = False) Begin
92197>>>>>>>                        Function_Return False
92198>>>>>>>                    End
92198>>>>>>>>
92198>>>>>>>                End
92198>>>>>>>>
92198>>>>>>>                Case Break
92199>>>>>>>
92199>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92202>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92202>>>>>>>                If (iMode = DF_SHARE) Begin
92204>>>>>>>                    Close hTable
92205>>>>>>>                    Open sTableName as hTable
92207>>>>>>>                End
92207>>>>>>>>
92207>>>>>>>                Else Begin
92208>>>>>>>                    Get OpenTableExclusive hTable to bOK
92209>>>>>>>                    If (bOK = False) Begin
92211>>>>>>>                        Function_Return False
92212>>>>>>>                    End
92212>>>>>>>>
92212>>>>>>>                End
92212>>>>>>>>
92212>>>>>>>                Case Break
92213>>>>>>>
92213>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92216>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92218>>>>>>>                    Close hTable
92219>>>>>>>                    Open sTableName as hTable
92221>>>>>>>                End
92221>>>>>>>>
92221>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92224>>>>>>>                    Get OpenTableExclusive hTable to bOK
92225>>>>>>>                    If (bOK = False) Begin
92227>>>>>>>                        Function_Return False
92228>>>>>>>                    End
92228>>>>>>>>
92228>>>>>>>                End
92228>>>>>>>>
92228>>>>>>>                Else Begin
92229>>>>>>>                    Open hTable
92231>>>>>>>                End
92231>>>>>>>>
92231>>>>>>>                Case Break
92232>>>>>>>
92232>>>>>>>            Case Else
92232>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92233>>>>>>>>
92233>>>>>>>        Case End
92233>>>>>>>
92233>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92234>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92235>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92237>>>>>>>            Move False to Found
92238>>>>>>>        End
92238>>>>>>>>
92238>>>>>>>        // If open failed, the Err is set to true,
92238>>>>>>>        // but we don't want that because it could end our loop.
92238>>>>>>>        Move False to Err
92239>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92242>>>>>>>
92242>>>>>>>        Function_Return bOpen
92243>>>>>>>    End_Function
92244>>>>>>>
92244>>>>>>>    // Pass a table's logical name
92244>>>>>>>    // Returns True if the table exists in filelist.cfg.
92244>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92246>>>>>>>        Handle hTable
92246>>>>>>>        Boolean bFound
92246>>>>>>>        String sCompareTable
92246>>>>>>>
92246>>>>>>>        Move False to bFound
92247>>>>>>>        Move 0 to hTable
92248>>>>>>>        Repeat
92248>>>>>>>>
92248>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92251>>>>>>>            If (hTable > 0) Begin
92253>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92256>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92258>>>>>>>                    Move True to bFound
92259>>>>>>>                End
92259>>>>>>>>
92259>>>>>>>            End
92259>>>>>>>>
92259>>>>>>>            If (bFound = True) ;                Break
92262>>>>>>>        Until (hTable = 0)
92264>>>>>>>
92264>>>>>>>        Function_Return (bFound = True)
92265>>>>>>>    End_Function
92266>>>>>>>
92266>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92266>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92268>>>>>>>        Boolean bOK bExists
92268>>>>>>>        String sDriverID
92268>>>>>>>
92268>>>>>>>        Get _UtilTableExists hTable to bExists
92269>>>>>>>        If (bExists = False) Begin
92271>>>>>>>            Function_Return DATAFLEX_ID
92272>>>>>>>        End
92272>>>>>>>>
92272>>>>>>>        Get OpenTableExclusive hTable to bOK
92273>>>>>>>        If (bOK = False) Begin
92275>>>>>>>            Function_Return DATAFLEX_ID
92276>>>>>>>        End
92276>>>>>>>>
92276>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92279>>>>>>>        Function_Return sDriverID
92280>>>>>>>    End_Function
92281>>>>>>>
92281>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92281>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92283>>>>>>>        Handle hTable
92283>>>>>>>        Integer iRetval
92283>>>>>>>
92283>>>>>>>        Move 0 to hTable
92284>>>>>>>        Move 0 to iRetval
92285>>>>>>>
92285>>>>>>>        Repeat
92285>>>>>>>>
92285>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92288>>>>>>>            If (hTable > 0) Begin
92290>>>>>>>                Increment iRetval
92291>>>>>>>            End
92291>>>>>>>>
92291>>>>>>>        Until (hTable = 0)
92293>>>>>>>
92293>>>>>>>        Function_Return iRetval
92294>>>>>>>    End_Function
92295>>>>>>>
92295>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92295>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92297>>>>>>>        Handle hTable
92297>>>>>>>        String sRoot sDriverID
92297>>>>>>>        Boolean bIsSQLTable
92297>>>>>>>        Integer iPos
92297>>>>>>>
92297>>>>>>>        Move 0 to hTable
92298>>>>>>>        Move "" to sDriverID
92299>>>>>>>        Move False to bIsSQLTable
92300>>>>>>>
92300>>>>>>>        Repeat
92300>>>>>>>>
92300>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92303>>>>>>>            If (hTable > 0) Begin
92305>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92308>>>>>>>                If (sRoot contains ":") Begin
92310>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92311>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92312>>>>>>>                End
92312>>>>>>>>
92312>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92313>>>>>>>            End
92313>>>>>>>>
92313>>>>>>>
92313>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92315>>>>>>>
92315>>>>>>>        Function_Return sDriverID
92316>>>>>>>    End_Function
92317>>>>>>>
92317>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92319>>>>>>>        String sRootName
92319>>>>>>>        Boolean bIsSQL
92319>>>>>>>        Handle hTable
92319>>>>>>>
92319>>>>>>>        Move False to bIsSQL
92320>>>>>>>        Move 0 to hTable
92321>>>>>>>        Repeat
92321>>>>>>>>
92321>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92324>>>>>>>            If (hTable > 0) Begin
92326>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92329>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92330>>>>>>>                If (bIsSQL = True) Begin
92332>>>>>>>                    Move 0 to hTable
92333>>>>>>>                End
92333>>>>>>>>
92333>>>>>>>            End
92333>>>>>>>>
92333>>>>>>>        Until (hTable = 0)
92335>>>>>>>
92335>>>>>>>        Function_Return (bIsSQL = False)
92336>>>>>>>    End_Function
92337>>>>>>>
92337>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92337>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92339>>>>>>>        Function_Return False
92340>>>>>>>    End_Function
92341>>>>>>>
92341>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92343>>>>>>>        String  sRetval
92343>>>>>>>        String[] sOverlapFieldsArray
92344>>>>>>>        Integer iType iColumn iColumns
92344>>>>>>>        Boolean bOpen bOverlap
92344>>>>>>>
92344>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92347>>>>>>>        If (bOpen = False) Begin
92349>>>>>>>            Open hTable
92351>>>>>>>        End
92351>>>>>>>>
92351>>>>>>>
92351>>>>>>>        Move "" to sRetval
92352>>>>>>>
92352>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92355>>>>>>>
92355>>>>>>>        for iColumn from 0 to iColumns
92361>>>>>>>>
92361>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92364>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92366>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92369>>>>>>>                If (bOverlap) Begin
92371>>>>>>>                    If (sRetval <> "") Begin
92373>>>>>>>                        Append sRetval ","
92374>>>>>>>                    End
92374>>>>>>>>
92374>>>>>>>                    Append sRetval iColumn
92375>>>>>>>                End
92375>>>>>>>>
92375>>>>>>>            End
92375>>>>>>>>
92375>>>>>>>        Loop
92376>>>>>>>>
92376>>>>>>>
92376>>>>>>>        If (bOpen = False) Begin
92378>>>>>>>            Close hTable
92379>>>>>>>        End
92379>>>>>>>>
92379>>>>>>>
92379>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92380>>>>>>>
92380>>>>>>>        Function_Return sOverlapFieldsArray
92381>>>>>>>    End_Function
92382>>>>>>>
92382>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92384>>>>>>>        Handle hoRegistry hoODBCDriverNames
92384>>>>>>>        Boolean bExists bKeyOpened
92384>>>>>>>        String sKey
92384>>>>>>>        String[] sDrivers
92385>>>>>>>        Integer iDriverNames iDriverName
92385>>>>>>>
92385>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92386>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92387>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92388>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92389>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92390>>>>>>>        If (bExists) Begin
92392>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92393>>>>>>>            If (bKeyOpened) Begin
92395>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92396>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92397>>>>>>>                If (iDriverNames > 0) Begin
92399>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92400>>>>>>>                    Decrement iDriverNames
92401>>>>>>>                    for iDriverName from 0 to iDriverNames
92407>>>>>>>>
92407>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92408>>>>>>>                    Loop
92409>>>>>>>>
92409>>>>>>>                End
92409>>>>>>>>
92409>>>>>>>                Send CloseKey of hoRegistry
92410>>>>>>>            End
92410>>>>>>>>
92410>>>>>>>        End
92410>>>>>>>>
92410>>>>>>>        Send Destroy of hoRegistry
92411>>>>>>>
92411>>>>>>>        Function_Return sDrivers
92412>>>>>>>    End_Function
92413>>>>>>>
92413>>>>>>>    Procedure IncreaseSortBufferSize
92415>>>>>>>        String sNull
92415>>>>>>>        Integer iSortBufferSize
92415>>>>>>>        Boolean bBufferSet
92415>>>>>>>
92415>>>>>>>        Move "" to sNull
92416>>>>>>>        Move (1024 * 128) to iSortBufferSize
92417>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92422>>>>>>>
92422>>>>>>>    End_Procedure
92423>>>>>>>
92423>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92425>>>>>>>        Integer iLastIndex iIndex iNumSegments
92425>>>>>>>        Boolean bOK
92425>>>>>>>        String sDriverID
92425>>>>>>>
92425>>>>>>>        If (hTable > 0) Begin
92427>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92428>>>>>>>            Close hTable
92429>>>>>>>            Get OpenTableExclusive hTable to bOK
92430>>>>>>>            If (bOK = False) Begin
92432>>>>>>>                Procedure_Return
92433>>>>>>>            End
92433>>>>>>>>
92433>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92436>>>>>>>            Structure_Start hTable sDriverID
92437>>>>>>>                for iIndex from 1 to iLastIndex
92443>>>>>>>>
92443>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92446>>>>>>>                    If (iNumSegments > 0) Begin
92448>>>>>>>                        If (bSetToBatch = True) Begin
92450>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92453>>>>>>>                        End
92453>>>>>>>>
92453>>>>>>>                        Else Begin
92454>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92457>>>>>>>                        End
92457>>>>>>>>
92457>>>>>>>                    End
92457>>>>>>>>
92457>>>>>>>                Loop
92458>>>>>>>>
92458>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92460>>>>>>>        End
92460>>>>>>>>
92460>>>>>>>    End_Procedure
92461>>>>>>>
92461>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92463>>>>>>>        Handle hTable
92463>>>>>>>
92463>>>>>>>        Move 0 to hTable
92464>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92467>>>>>>>
92467>>>>>>>        Function_Return hTable
92468>>>>>>>    End_Function
92469>>>>>>>
92469>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92469>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92471>>>>>>>        Integer iCh
92471>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92472>>>>>>>            Write channel iCh sStmt
92474>>>>>>>        Send Seq_Close_Channel iCh
92475>>>>>>>    End_Procedure
92476>>>>>>>
92476>>>>>>>    // Returns the integer number for the passed Driver ID that is
92476>>>>>>>    // needed by some database API calls.
92476>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92478>>>>>>>        String  sCurrentDriver
92478>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92478>>>>>>>
92478>>>>>>>        Move 0 to iDriver
92479>>>>>>>
92479>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92482>>>>>>>        for iCount from 1 to iNumberOfDrivers
92488>>>>>>>>
92488>>>>>>>
92488>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92491>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92493>>>>>>>                Move iCount to iDriver
92494>>>>>>>            End
92494>>>>>>>>
92494>>>>>>>        Loop
92495>>>>>>>>
92495>>>>>>>
92495>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92495>>>>>>>        If (iDriver = 0) Begin
92497>>>>>>>            Move False to Err
92498>>>>>>>            Load_Driver sDriverID
92499>>>>>>>            If (Err = False) Begin
92501>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92504>>>>>>>            End
92504>>>>>>>>
92504>>>>>>>        End
92504>>>>>>>>
92504>>>>>>>
92504>>>>>>>        Function_Return iDriver
92505>>>>>>>    End_Function
92506>>>>>>>
92506>>>>>>>
92506>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92508>>>>>>>        String  sSqlServerClientVersionName
92508>>>>>>>        
92508>>>>>>>        Case Begin
92508>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92510>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92511>>>>>>>                Case Break
92512>>>>>>>
92512>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92515>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92516>>>>>>>                Case Break
92517>>>>>>>                
92517>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92520>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92521>>>>>>>                Case Break
92522>>>>>>>            
92522>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92525>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92526>>>>>>>                Case Break
92527>>>>>>>            
92527>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92530>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92531>>>>>>>                Case Break
92532>>>>>>>            
92532>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92535>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92536>>>>>>>                Case Break
92537>>>>>>>            
92537>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92540>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92541>>>>>>>                Case Break
92542>>>>>>>            
92542>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92545>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92546>>>>>>>                Case Break
92547>>>>>>>            
92547>>>>>>>            Case Else
92547>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92548>>>>>>>        Case End
92548>>>>>>>        
92548>>>>>>>        Function_Return sSqlServerClientVersionName
92549>>>>>>>    End_Function
92550>>>>>>>
92550>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92552>>>>>>>        String  sSqlServerClientDriverName
92552>>>>>>>        
92552>>>>>>>        Case Begin
92552>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92554>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92555>>>>>>>                Case Break
92556>>>>>>>
92556>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92559>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92560>>>>>>>                Case Break
92561>>>>>>>                
92561>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92564>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92565>>>>>>>                Case Break
92566>>>>>>>            
92566>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92569>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92570>>>>>>>                Case Break
92571>>>>>>>            
92571>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92574>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92575>>>>>>>                Case Break
92576>>>>>>>            
92576>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92579>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92580>>>>>>>                Case Break
92581>>>>>>>            
92581>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92584>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92585>>>>>>>                Case Break
92586>>>>>>>            
92586>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92589>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92590>>>>>>>                Case Break
92591>>>>>>>            
92591>>>>>>>            Case Else
92591>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92592>>>>>>>        Case End
92592>>>>>>>        
92592>>>>>>>        Function_Return sSqlServerClientDriverName
92593>>>>>>>    End_Function
92594>>>>>>>    
92594>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92596>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92596>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92596>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92596>>>>>>>        Boolean bOK
92596>>>>>>>        
92596>>>>>>>        Move "" to sRetval
92597>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92598>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92599>>>>>>>        Load_Driver MSSQLDRV_ID
92600>>>>>>>
92600>>>>>>>        // Loop through all loaded drivers.
92600>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92603>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92609>>>>>>>>
92609>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92612>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92614>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92615>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92618>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92619>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92620>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92621>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92622>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92624>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92625>>>>>>>                End                                
92625>>>>>>>>
92625>>>>>>>                Else Begin
92626>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92627>>>>>>>                End
92627>>>>>>>>
92627>>>>>>>            End
92627>>>>>>>>
92627>>>>>>>        Loop
92628>>>>>>>>
92628>>>>>>>        Send Destroy of hoCLIHandler  
92629>>>>>>>        Send Destroy of hoMSSQLHandler  
92630>>>>>>>        If (bShowErrorDialog = True) Begin
92632>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92633>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92635>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92636>>>>>>>                If (bExitProgram = True) Begin
92638>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92639>>>>>>>                End
92639>>>>>>>>
92639>>>>>>>                Send Stop_Box sRetval  
92640>>>>>>>                If (bExitProgram = True) Begin
92642>>>>>>>                    Send Exit_Application
92643>>>>>>>                End
92643>>>>>>>>
92643>>>>>>>            End
92643>>>>>>>>
92643>>>>>>>        End
92643>>>>>>>>
92643>>>>>>>        
92643>>>>>>>        Function_Return sRetval
92644>>>>>>>    End_Function  
92645>>>>>>>    
92645>>>>>>>    // Returns True if first "." separated string is greater than the second.
92645>>>>>>>    // It checks from left to right, one part of the string at a time.
92645>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92645>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92647>>>>>>>        String[] asVersion asSQLVersion          
92649>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92649>>>>>>>        
92649>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92650>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92651>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92652>>>>>>>        // Make sure the two arrays are of the same size:
92652>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92654>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92655>>>>>>>        End
92655>>>>>>>>
92655>>>>>>>        Decrement iSize
92656>>>>>>>        for iCount from 0 to iSize
92662>>>>>>>>
92662>>>>>>>            Move asVersion[iCount]    to iVersion
92663>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92664>>>>>>>            CompilerWarnings Off
92664>>>>>>>            If (iVersion > iSQLVersion) Break
92667>>>>>>>            CompilerWarnings On
92667>>>>>>>        Loop
92668>>>>>>>>
92668>>>>>>>        
92668>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92669>>>>>>>    End_Function
92670>>>>>>>
92670>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92670>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92670>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92670>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92672>>>>>>>        Integer iMode iErrorObject
92672>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92672>>>>>>>        String sTableName 
92672>>>>>>>        Handle hoCurrentErrorHandler
92672>>>>>>>        
92672>>>>>>>        Move False to bExitIfDebuggerActive
92673>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92675>>>>>>>            Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92676>>>>>>>        End
92676>>>>>>>>
92676>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92677>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92677>>>>>>>        // so we generate an error here:
92677>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92679>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92680>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92681>>>>>>>            If (iErrorObject <> 0) Begin
92683>>>>>>>                Move iErrorObject to Error_Object_Id
92684>>>>>>>            End
92684>>>>>>>>
92684>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92685>>>>>>>>
92685>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92686>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92687>>>>>>>            Function_Return False
92688>>>>>>>        End
92688>>>>>>>>
92688>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92691>>>>>>>        If (bOpened) Begin
92693>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92696>>>>>>>            If (iMode = DF_EXCLUSIVE) Begin
92698>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92699>>>>>>>                Function_Return True
92700>>>>>>>            End
92700>>>>>>>>
92700>>>>>>>            Close hTable
92701>>>>>>>        End
92701>>>>>>>>
92701>>>>>>>        Else Begin
92702>>>>>>>            Open hTable
92704>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92707>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92709>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92712>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92714>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92715>>>>>>>                    Function_Return True
92716>>>>>>>                End
92716>>>>>>>>
92716>>>>>>>            End
92716>>>>>>>>
92716>>>>>>>
92716>>>>>>>        End
92716>>>>>>>>
92716>>>>>>>
92716>>>>>>>        Close hTable
92717>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92719>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92722>>>>>>>
92722>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92723>>>>>>>        Function_Return bOpened
92724>>>>>>>    End_Function
92725>>>>>>>
92725>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92727>>>>>>>        String sConnectionID sConnectionString sDriverID
92727>>>>>>>        Boolean bExists bOK bSQLDriver
92727>>>>>>>        Handle hoCLI hoDriver
92727>>>>>>>        Integer iRetval
92727>>>>>>>        tSQLConnection SQLConnection
92727>>>>>>>        tSQLConnection SQLConnection
92727>>>>>>>
92727>>>>>>>        Get psDriverID to sDriverID
92728>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92729>>>>>>>        If (bSQLDriver = False) Begin
92731>>>>>>>            Function_Return True
92732>>>>>>>        End
92732>>>>>>>>
92732>>>>>>>
92732>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92733>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92734>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92735>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92736>>>>>>>
92736>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92737>>>>>>>        If (bExists = False) Begin
92739>>>>>>>            // We always start by deleting the current connection - if any - because the
92739>>>>>>>            // login details my have changed.
92739>>>>>>>            Get phoCLIHandler to hoCLI
92740>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92741>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92742>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92743>>>>>>>            If (bOk = False) Begin
92745>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92746>>>>>>>>
92746>>>>>>>                Function_Return False
92747>>>>>>>            End
92747>>>>>>>>
92747>>>>>>>            Move bOK to bExists
92748>>>>>>>        End
92748>>>>>>>>
92748>>>>>>>
92748>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92749>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92750>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92751>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92752>>>>>>>        Send Destroy of hoDriver
92753>>>>>>>
92753>>>>>>>        Function_Return (bExists = True)
92754>>>>>>>    End_Function
92755>>>>>>>
92755>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92755>>>>>>>    // Returns: False if nobody else is running
92755>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92755>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92755>>>>>>>    //      tables are not locked as DataFlex tables are.
92755>>>>>>>    Function IsDatabaseInUse Returns Boolean
92757>>>>>>>        Handle  hTable
92757>>>>>>>        String  sRootName sDatabase sSchema sDriverID
92757>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92757>>>>>>>        Integer iCount iTables
92757>>>>>>>        String[] asTablesArray asTablesArrayEmpty
92759>>>>>>>        
92759>>>>>>>        Move 0 to iTables
92760>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92761>>>>>>>        Get AutoConnectionIDLogin to bOK
92762>>>>>>>        Get UtilFilelistNoOfTables to iTables
92763>>>>>>>        Set piPosition   of ghoProgressBar to 0
92764>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92765>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92766>>>>>>>        Close DF_ALL
92767>>>>>>>        Move 0 to hTable
92768>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92771>>>>>>>        Move False to bErr
92772>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92773>>>>>>>
92773>>>>>>>        Get psDriverID to sDriverID
92774>>>>>>>        Get psDatabase to sDatabase
92775>>>>>>>        Get psSchema   to sSchema
92776>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
92777>>>>>>>        Set pasSQLDataTables to asTablesArray
92778>>>>>>>        Repeat
92778>>>>>>>>
92778>>>>>>>            Set piPosition of ghoProgressBar to iCount
92779>>>>>>>            Increment iCount
92780>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92783>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92784>>>>>>>
92784>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92784>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92785>>>>>>>            Move False to bOpen
92786>>>>>>>            // _UtilTableExists_Ex is a variant of "_UtilTableExists", but it needs that the pasSQLDataTables
92786>>>>>>>            // property has been set/updated before usage! This makes the loop much faster.
92786>>>>>>>            Get _UtilTableExists_Ex hTable to bExists
92787>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92787>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92789>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92790>>>>>>>                Open hTable
92792>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92795>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92796>>>>>>>                If (bOpen = True) Begin
92798>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92798>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92799>>>>>>>                    If (bAlias = False) Begin
92801>>>>>>>                        Close hTable
92802>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92803>>>>>>>                        If (bOpen = False) Begin
92805>>>>>>>                            Move True to bErr
92806>>>>>>>                        End
92806>>>>>>>>
92806>>>>>>>                    End
92806>>>>>>>>
92806>>>>>>>                End
92806>>>>>>>>
92806>>>>>>>            End
92806>>>>>>>>
92806>>>>>>>            Close hTable
92807>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92810>>>>>>>            If (bErr = True ) ;                Break
92813>>>>>>>        Until (not(hTable))
92815>>>>>>>
92815>>>>>>>        // Reset the temporary used data tables property to blank:
92815>>>>>>>        Set pasSQLDataTables to asTablesArrayEmpty
92816>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92817>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92818>>>>>>>        Move False to Err
92819>>>>>>>
92819>>>>>>>        Function_Return bErr
92820>>>>>>>    End_Function
92821>>>>>>>
92821>>>>>>>End_Class
92822>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92822>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92822>>>>>>>//
92822>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92822>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92822>>>>>>>// conjunction with constraint-clauses.
92822>>>>>>>//
92822>>>>>>>// SYNTAX:
92822>>>>>>>//
92822>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92822>>>>>>>//    <Constraints...>
92822>>>>>>>//    {DO}
92822>>>>>>>//      <loop body>
92822>>>>>>>//  End_For_All
92822>>>>>>>//
92822>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92822>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92822>>>>>>>//
92822>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92822>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92822>>>>>>>//   End_For_All
92822>>>>>>>//
92822>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92822>>>>>>>//
92822>>>>>>>//   For_All Customer BY Index.1
92822>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92822>>>>>>>//     DO
92822>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92822>>>>>>>//   End_For_All
92822>>>>>>>//
92822>>>>>>>// Constraint clauses are:
92822>>>>>>>//
92822>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92822>>>>>>>//   CONSTRAIN <File> AS <Expression>
92822>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92822>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92822>>>>>>>//
92822>>>>>>>// For example, to list all customers with a bad status whose names start
92822>>>>>>>// with "A" and which have not made a payment in thirty days:
92822>>>>>>>//
92822>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92822>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92822>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92822>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92822>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92822>>>>>>>//      DO
92822>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92822>>>>>>>//    End_For_All
92822>>>>>>>//
92822>>>>>>>
92822>>>>>>>
92822>>>>>>>//This command starts the loop process body when constraints are used;
92822>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92822>>>>>>>//command line, and not on a line by itself
92822>>>>>>>//
92822>>>>>>>
92822>>>>>>>//Ends a For_All loop
92822>>>>>>>//
92822>>>>>>>
92822>>>>>>>
92822>>>>>
92822>>>>>
92822>>>>>Class cDbUpdateVersion is a cObject
92823>>>>>
92823>>>>>    Procedure Construct_Object    
92825>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92825>>>>>        String[] aSQLQueryMessages
92826>>>>>        
92826>>>>>        Forward Send Construct_Object
92828>>>>>
92828>>>>>        // cDbUpdateHandler object event.
92828>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92830>>>>>        If (bOnCreateExecuted = False) Begin    
92832>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92834>>>>>            If (bUseCustomDbVersion = False) Begin
92836>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92838>>>>>            End
92838>>>>>>
92838>>>>>            Delegate Send OnCreate
92840>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92842>>>>>        End
92842>>>>>>
92842>>>>>
92842>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92842>>>>>        // event was triggered, thus an actual change of the database was made.
92842>>>>>        Property Boolean pbVersionUpdate False
92843>>>>>
92843>>>>>        // This property must be manually set within each cDbUpdateVersion object
92843>>>>>        // by the programmer, to a consecutive number.
92843>>>>>        Property Number pnVersionNumber
92844>>>>>
92844>>>>>        Property Boolean pbUseConnectionID True
92845>>>>>        Property Boolean private.pbToANSI   True
92846>>>>>        Property Boolean private.pbRecnum   True
92847>>>>>        Property Boolean private.pbCopyData True
92848>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92849>>>>>        Property Boolean private.pbCompareDate_DateTime False
92850>>>>>        Property Boolean private.pbCompareIndexAscending False
92851>>>>>        Property Boolean private.pbCompareIndexUppercase False
92852>>>>>        Property String private.psSchema
92853>>>>>        Property String private.psBaseTableSpace
92854>>>>>        Property String private.psLongTableSpace
92855>>>>>        Property String private.psIndexTableSpace
92856>>>>>
92856>>>>>        // Driver default value settings:
92856>>>>>        Property String private.psDriverDefaultValueASCII    ""
92857>>>>>        Property String private.psDriverDefaultValueBinary   ""
92858>>>>>        Property String private.psDriverDefaultValueDate     ""
92859>>>>>        Property String private.psDriverDefaultValueDateTime ""
92860>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92861>>>>>        Property String private.psDriverDefaultValueText     ""
92862>>>>>
92862>>>>>        // Driver "nullability" settings:
92862>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92863>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92864>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92865>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92866>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92867>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92868>>>>>
92868>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92868>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92868>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92868>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92868>>>>>        // We reset it here for each cDbUpdateVersion object
92868>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92870>>>>>    End_Procedure
92871>>>>>
92871>>>>>    // *** Main hook event message ***
92871>>>>>    // Place your database update logic here!
92871>>>>>    Procedure OnUpdate
92873>>>>>    End_Procedure
92874>>>>>
92874>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92874>>>>>    // imported to the cDbUpdateHandler container class which should be a
92874>>>>>    // parent object to this object. To have the Studio's Property Panel
92874>>>>>    // "behave" aka show these properties we need to duplicate them in this
92874>>>>>    // class and "relay" them to the parent object.
92874>>>>>    Procedure Set pbToANSI Boolean bState
92876>>>>>        Set private.pbToANSI  to bState
92877>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92878>>>>>        Delegate Set pbToANSI to bState
92880>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92881>>>>>    End_Procedure
92882>>>>>
92882>>>>>    Function pbToANSI Returns Boolean
92884>>>>>        Function_Return (private.pbToAnsi(Self))
92885>>>>>    End_Function
92886>>>>>
92886>>>>>    Procedure Set pbRecnum Boolean bState
92888>>>>>        Set private.pbRecnum  to bState
92889>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92890>>>>>        Delegate Set pbRecnum to bState
92892>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92893>>>>>    End_Procedure
92894>>>>>
92894>>>>>    Function pbRecnum Returns Boolean
92896>>>>>        Function_Return (private.pbRecnum(Self))
92897>>>>>    End_Function
92898>>>>>
92898>>>>>    Procedure Set pbCopyData Boolean bState
92900>>>>>        Set private.pbCopyData  to bState
92901>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92902>>>>>        Delegate Set pbCopyData to bState
92904>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92905>>>>>    End_Procedure
92906>>>>>
92906>>>>>    Function pbCopyData Returns Boolean
92908>>>>>        Function_Return (private.pbCopyData(Self))
92909>>>>>    End_Function
92910>>>>>
92910>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92910>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92912>>>>>        Set private.pbApiTableUpdateAuto  to bState
92913>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92914>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92915>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92916>>>>>    End_Procedure
92917>>>>>
92917>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92919>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92920>>>>>    End_Function
92921>>>>>
92921>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92923>>>>>        Set private.pbCompareDate_DateTime  to bState
92924>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92925>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92926>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92927>>>>>    End_Procedure
92928>>>>>
92928>>>>>    Function pbCompareDate_DateTime Returns Boolean
92930>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92931>>>>>    End_Function
92932>>>>>
92932>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92934>>>>>        Set private.pbCompareIndexAscending  to bState
92935>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92936>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92937>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92938>>>>>    End_Procedure
92939>>>>>
92939>>>>>    Function pbCompareIndexAscending Returns Boolean
92941>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92942>>>>>    End_Function
92943>>>>>
92943>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92945>>>>>        Set private.pbCompareIndexUppercase  to bState
92946>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92947>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92948>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92949>>>>>    End_Procedure
92950>>>>>
92950>>>>>    Function pbCompareIndexUppercase Returns Boolean
92952>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92953>>>>>    End_Function
92954>>>>>
92954>>>>>    Procedure Set psSchema String sValue
92956>>>>>        Set private.psSchema  to sValue
92957>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92958>>>>>        Delegate Set psSchema to sValue
92960>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92961>>>>>    End_Procedure
92962>>>>>
92962>>>>>    // First retrieve the private value that might have been set in the object.
92962>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92962>>>>>    // it might have been specified in the SQLConnections.ini file.
92962>>>>>    Function psSchema Returns String
92964>>>>>        String sValue
92964>>>>>        Get private.psSchema to sValue
92965>>>>>        If (sValue = "") Begin
92967>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92968>>>>>        End
92968>>>>>>
92968>>>>>        Function_Return sValue
92969>>>>>    End_Function
92970>>>>>
92970>>>>>    Procedure Set psBaseTableSpace String sValue
92972>>>>>        Set private.psBaseTableSpace  to sValue
92973>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92974>>>>>        Delegate Set psBaseTableSpace to sValue
92976>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92977>>>>>    End_Procedure
92978>>>>>
92978>>>>>    // First retrieve the private value that might have been set in the object.
92978>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92978>>>>>    // it might have been specified in the SQLConnections.ini file.
92978>>>>>    Function psBaseTableSpace Returns String
92980>>>>>        String sValue
92980>>>>>        Get private.psBaseTableSpace to sValue
92981>>>>>        If (sValue = "") Begin
92983>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92984>>>>>        End
92984>>>>>>
92984>>>>>        Function_Return sValue
92985>>>>>    End_Function
92986>>>>>
92986>>>>>    Procedure Set psLongTableSpace String sValue
92988>>>>>        Set private.psLongTableSpace  to sValue
92989>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92990>>>>>        Delegate Set psLongTableSpace to sValue
92992>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92993>>>>>    End_Procedure
92994>>>>>
92994>>>>>    // First retrieve the private value that might have been set in the object.
92994>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92994>>>>>    // it might have been specified in the SQLConnections.ini file.
92994>>>>>    Function psLongTableSpace Returns String
92996>>>>>        String sValue
92996>>>>>        Get private.psLongTableSpace to sValue
92997>>>>>        If (sValue = "") Begin
92999>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93000>>>>>        End
93000>>>>>>
93000>>>>>        Function_Return sValue
93001>>>>>    End_Function
93002>>>>>
93002>>>>>    Procedure Set psIndexTableSpace String sValue
93004>>>>>        Set private.psIndexTableSpace  to sValue
93005>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93006>>>>>        Delegate Set psIndexTableSpace to sValue
93008>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93009>>>>>    End_Procedure
93010>>>>>
93010>>>>>    // First retrieve the private value that might have been set in the object.
93010>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93010>>>>>    // it might have been specified in the SQLConnections.ini file.
93010>>>>>    Function psIndexTableSpace Returns String
93012>>>>>        String sValue
93012>>>>>        Get private.psIndexTableSpace to sValue
93013>>>>>        If (sValue = "") Begin
93015>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93016>>>>>        End
93016>>>>>>
93016>>>>>        Function_Return sValue
93017>>>>>    End_Function
93018>>>>>
93018>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93020>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93021>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93022>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93024>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93025>>>>>    End_Procedure
93026>>>>>
93026>>>>>    // First retrieve the private value that might have been set in the object.
93026>>>>>    // If blank; get it from the parent object
93026>>>>>    Function psDriverDefaultValueASCII Returns String
93028>>>>>        String sValue
93028>>>>>        Get private.psDriverDefaultValueASCII to sValue
93029>>>>>        If (sValue = "") Begin
93031>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93033>>>>>        End
93033>>>>>>
93033>>>>>        Function_Return sValue
93034>>>>>    End_Function
93035>>>>>
93035>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93037>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93038>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93039>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93041>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93042>>>>>    End_Procedure
93043>>>>>
93043>>>>>    // First retrieve the private value that might have been set in the object.
93043>>>>>    // If blank; get it from the parent object
93043>>>>>    Function psDriverDefaultValueBinary Returns String
93045>>>>>        String sValue
93045>>>>>        Get private.psDriverDefaultValueBinary to sValue
93046>>>>>        If (sValue = "") Begin
93048>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93050>>>>>        End
93050>>>>>>
93050>>>>>        Function_Return sValue
93051>>>>>    End_Function
93052>>>>>
93052>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93054>>>>>        Set private.psDriverDefaultValueDate  to sValue
93055>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93056>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93058>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93059>>>>>    End_Procedure
93060>>>>>
93060>>>>>    // First retrieve the private value that might have been set in the object.
93060>>>>>    // If blank; get it from the parent object
93060>>>>>    Function psDriverDefaultValueDate Returns String
93062>>>>>        String sValue
93062>>>>>        Get private.psDriverDefaultValueDate to sValue
93063>>>>>        If (sValue = "") Begin
93065>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93067>>>>>        End
93067>>>>>>
93067>>>>>        Function_Return sValue
93068>>>>>    End_Function
93069>>>>>
93069>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93071>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93072>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93073>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93075>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93076>>>>>    End_Procedure
93077>>>>>
93077>>>>>    // First retrieve the private value that might have been set in the object.
93077>>>>>    // If blank; get it from the parent object
93077>>>>>    Function psDriverDefaultValueDateTime Returns String
93079>>>>>        String sValue
93079>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93080>>>>>        If (sValue = "") Begin
93082>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93084>>>>>        End
93084>>>>>>
93084>>>>>        Function_Return sValue
93085>>>>>    End_Function
93086>>>>>
93086>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93088>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93089>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93090>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93092>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93093>>>>>    End_Procedure
93094>>>>>
93094>>>>>    // First retrieve the private value that might have been set in the object.
93094>>>>>    // If blank; get it from the parent object
93094>>>>>    Function psDriverDefaultValueNumeric Returns String
93096>>>>>        String sValue
93096>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93097>>>>>        If (sValue = "") Begin
93099>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93101>>>>>        End
93101>>>>>>
93101>>>>>        Function_Return sValue
93102>>>>>    End_Function
93103>>>>>
93103>>>>>    Procedure Set psDriverDefaultValueText String sValue
93105>>>>>        Set private.psDriverDefaultValueText  to sValue
93106>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93107>>>>>        Delegate Set psDriverDefaultValueText to sValue
93109>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93110>>>>>    End_Procedure
93111>>>>>
93111>>>>>    // First retrieve the private value that might have been set in the object.
93111>>>>>    // If blank; get it from the parent object
93111>>>>>    Function psDriverDefaultValueText Returns String
93113>>>>>        String sValue
93113>>>>>        Get private.psDriverDefaultValueText to sValue
93114>>>>>        If (sValue = "") Begin
93116>>>>>            Delegate Get psDriverDefaultValueText to sValue
93118>>>>>        End
93118>>>>>>
93118>>>>>        Function_Return sValue
93119>>>>>    End_Function
93120>>>>>
93120>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93122>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93123>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93124>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93126>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93127>>>>>    End_Procedure
93128>>>>>
93128>>>>>    // First retrieve the private value that might have been set in the object.
93128>>>>>    // If blank; get it from the parent object
93128>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93130>>>>>        Boolean bState
93130>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93131>>>>>        If (bState = False) Begin
93133>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93135>>>>>        End
93135>>>>>>
93135>>>>>        Function_Return bState
93136>>>>>    End_Function
93137>>>>>
93137>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93139>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93140>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93141>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93143>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93144>>>>>    End_Procedure
93145>>>>>
93145>>>>>    // First retrieve the private value that might have been set in the object.
93145>>>>>    // If blank; get it from the parent object
93145>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93147>>>>>        Boolean bState
93147>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93148>>>>>        If (bState = False) Begin
93150>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93152>>>>>        End
93152>>>>>>
93152>>>>>        Function_Return bState
93153>>>>>    End_Function
93154>>>>>
93154>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93156>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93157>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93158>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93160>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93161>>>>>    End_Procedure
93162>>>>>
93162>>>>>    // First retrieve the private value that might have been set in the object.
93162>>>>>    // If blank; get it from the parent object
93162>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93164>>>>>        Boolean bState
93164>>>>>        Get private.pbDriverDefaultNullableDate to bState
93165>>>>>        If (bState = False) Begin
93167>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93169>>>>>        End
93169>>>>>>
93169>>>>>        Function_Return bState
93170>>>>>    End_Function
93171>>>>>
93171>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93173>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93174>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93175>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93177>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93178>>>>>    End_Procedure
93179>>>>>
93179>>>>>    // First retrieve the private value that might have been set in the object.
93179>>>>>    // If blank; get it from the parent object
93179>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93181>>>>>        Boolean bState
93181>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93182>>>>>        If (bState = False) Begin
93184>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93186>>>>>        End
93186>>>>>>
93186>>>>>        Function_Return bState
93187>>>>>    End_Function
93188>>>>>
93188>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93190>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93191>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93192>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93194>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93195>>>>>    End_Procedure
93196>>>>>
93196>>>>>    // First retrieve the private value that might have been set in the object.
93196>>>>>    // If blank; get it from the parent object
93196>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93198>>>>>        Boolean bState
93198>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93199>>>>>        If (bState = False) Begin
93201>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93203>>>>>        End
93203>>>>>>
93203>>>>>        Function_Return bState
93204>>>>>    End_Function
93205>>>>>
93205>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93207>>>>>        Set private.pbDriverDefaultNullableText  to bState
93208>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93209>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93211>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93212>>>>>    End_Procedure
93213>>>>>
93213>>>>>    // First retrieve the private value that might have been set in the object.
93213>>>>>    // If blank; get it from the parent object
93213>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93215>>>>>        Boolean bState
93215>>>>>        Get private.pbDriverDefaultNullableText to bState
93216>>>>>        If (bState = False) Begin
93218>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93220>>>>>        End
93220>>>>>>
93220>>>>>        Function_Return bState
93221>>>>>    End_Function
93222>>>>>
93222>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93224>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93224>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93224>>>>>
93224>>>>>        Get psDriverID to sDriverID
93225>>>>>        Get psSchema to sSchema
93226>>>>>
93226>>>>>        Get psBaseTableSpace to sBaseTableSpace
93227>>>>>        If (sBaseTableSpace <> "") Begin
93229>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93230>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93232>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93233>>>>>        End
93233>>>>>>
93233>>>>>
93233>>>>>        Get psLongTableSpace to sLongTableSpace
93234>>>>>        If (sLongTableSpace <> "") Begin
93236>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93237>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93239>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93240>>>>>        End
93240>>>>>>
93240>>>>>
93240>>>>>        Get psIndexTableSpace to sIndexTableSpace
93241>>>>>        If (sIndexTableSpace <> "") Begin
93243>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93244>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93246>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93247>>>>>        End
93247>>>>>>
93247>>>>>
93247>>>>>        Get pbUseConnectionID to bUseConnectionID
93248>>>>>        Get pbToANSI          to bToANSI
93249>>>>>        Get pbRecnum          to bRecnum
93250>>>>>        Get pbCopyData        to bCopyData
93251>>>>>
93251>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93252>>>>>
93252>>>>>        Function_Return bOK
93253>>>>>    End_Function
93254>>>>>
93254>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93254>>>>>//        Boolean bOK bExists
93254>>>>>//        String sDataPath sBackupFolder
93254>>>>>//        
93254>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93254>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93254>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93254>>>>>//        Get vFolderFormat sDataPath to sDataPath
93254>>>>>//        
93254>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93254>>>>>//        If (bExists = False) Begin
93254>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93254>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93254>>>>>//            If (bExists = False) Begin
93254>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93254>>>>>//                Function_Return False
93254>>>>>//            End                                                                                                                                            
93254>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93254>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93254>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93254>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93254>>>>>//        End
93254>>>>>//        
93254>>>>>//        Set Message_Text of ghoStatusPanel to ""
93254>>>>>//        Function_Return bOK
93254>>>>>//    End_Function
93254>>>>>//
93254>>>>>    // This is automatically called after the OnUpdate
93254>>>>>    // event has been executed. It will automatically update the
93254>>>>>    // version database field/column with the "pnVersionNumber"
93254>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93254>>>>>    Procedure UpdateVersionColumnValue
93256>>>>>        Number nVersion nCurrentValue
93256>>>>>        Integer hTable iColumn
93256>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93256>>>>>
93256>>>>>        Move False to Err
93257>>>>>        Move 0 to LastErr
93258>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93258>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93258>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93260>>>>>        Get pbVersionUpdate to bVersionUpdate
93261>>>>>
93261>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93263>>>>>            Get pnVersionNumber to nVersion
93264>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93266>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93268>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93268>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93268>>>>>            Close DF_ALL DF_PERMANENT
93269>>>>>
93269>>>>>            Open hTable
93271>>>>>
93271>>>>>            // It is then the developer responsibility to take care of finding
93271>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93271>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93273>>>>>            If (bUseCustomDbVersion = True) Begin
93275>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93277>>>>>            End
93277>>>>>>
93277>>>>>
93277>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93280>>>>>            If (nCurrentValue < nVersion) Begin
93282>>>>>                Lock
93283>>>>>>
93283>>>>>                    If (bUseCustomDbVersion = False) Begin
93285>>>>>                        Vfind hTable Recnum GE                            
93287>>>>>                    End
93287>>>>>>
93287>>>>>                    Set_Field_Value hTable iColumn to nVersion
93290>>>>>                    SaveRecord hTable
93291>>>>>                Unlock
93292>>>>>>
93292>>>>>            End
93292>>>>>>
93292>>>>>            Close hTable
93293>>>>>        End
93293>>>>>>
93293>>>>>    End_Procedure
93294>>>>>
93294>>>>>// Property of the container object (cDbUpdateHandler)
93294>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93294>>>>>
93294>>>>>    Procedure End_Construct_Object
93296>>>>>        Forward Send End_Construct_Object
93298>>>>>        Send ProcessUpdate True
93299>>>>>    End_Procedure
93300>>>>>    
93300>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93302>>>>>        Number nVersion nCurrentValue
93302>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
93302>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
93302>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
93302>>>>>        String sObjectName
93302>>>>>        tDbVersionInfo[] dbVersionInfoArray
93302>>>>>        tDbVersionInfo[] dbVersionInfoArray
93303>>>>>
93303>>>>>        Move 0 to nCurrentValue
93304>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93306>>>>>
93306>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
93308>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
93310>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
93312>>>>>            If (iErrorObject <> 0) Begin
93314>>>>>                Move iErrorObject to Error_Object_Id
93315>>>>>            End
93315>>>>>>
93315>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
93316>>>>>>
93316>>>>>            Send Exit_Application
93317>>>>>        End
93317>>>>>>
93317>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93317>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93317>>>>>        // one database update is depended on an earlier update and that earlier version
93317>>>>>        // update was never executed it could lead to disastrous results.
93317>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93317>>>>>        Get pnVersionNumber to nVersion
93318>>>>>        If (nVersion < 0) Begin
93320>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93321>>>>>            Move (Name(Self)) to sObjectName
93322>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93323>>>>>>
93323>>>>>            Send Exit_Application
93324>>>>>        End
93324>>>>>>
93324>>>>>
93324>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93324>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93324>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93326>>>>>        If (bOnPreUpdateExecuted = False) Begin
93328>>>>>            Delegate Send OnPreUpdate
93330>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93332>>>>>        End
93332>>>>>>
93332>>>>>        
93332>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93334>>>>>        
93334>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93336>>>>>        If (bUseCustomDbVersion = False) Begin
93338>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93338>>>>>        End
93338>>>>>>
93338>>>>>        Else Begin
93339>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93340>>>>>            If (bTableExists = False) Begin
93342>>>>>                Delegate Send OnCreateCustomDbVersionTable
93344>>>>>            End
93344>>>>>>
93344>>>>>        End
93344>>>>>>
93344>>>>>        
93344>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93344>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93344>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93346>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93348>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93349>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93350>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93351>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93353>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93355>>>>>        End
93355>>>>>>
93355>>>>>
93355>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93357>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93359>>>>>
93359>>>>>        Open hTable
93361>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93364>>>>>        If (bOpened = False) Begin
93366>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93367>>>>>            Send Exit_Application
93368>>>>>        End
93368>>>>>>
93368>>>>>        
93368>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93368>>>>>        // in case we take care of it here.
93368>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93371>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93373>>>>>            Vfind hTable 0 GT
93375>>>>>        End
93375>>>>>>
93375>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93378>>>>>        If (bSystemTable = True) Begin
93380>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93383>>>>>        End
93383>>>>>>
93383>>>>>        Else Begin
93384>>>>>            If (bUseCustomDbVersion = True) Begin
93386>>>>>                Send OnFindVersionRecord
93387>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93390>>>>>            End
93390>>>>>>
93390>>>>>        End
93390>>>>>>
93390>>>>>
93390>>>>>        Close hTable
93391>>>>>
93391>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93391>>>>>        // If not set we do nothing.
93391>>>>>        If (nCurrentValue < nVersion) Begin
93393>>>>>
93393>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93393>>>>>            // execution of database update code. So if true _and_ one error
93393>>>>>            // has already occured; we're out of here.
93393>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93395>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93397>>>>>            If (bStopOnFirstError = True) Begin
93399>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93401>>>>>                    Procedure_Return
93402>>>>>                End
93402>>>>>>
93402>>>>>            End
93402>>>>>>
93402>>>>>
93402>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93402>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93404>>>>>
93404>>>>>            // If the parent property pbContinueOnError = False, an update
93404>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93404>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93406>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93408>>>>>                Procedure_Return
93409>>>>>            End
93409>>>>>>
93409>>>>>
93409>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93411>>>>>
93411>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93412>>>>>
93412>>>>>            // *** Programmer's main hook event for database update functions:
93412>>>>>            Send OnUpdate
93413>>>>>
93413>>>>>            Set pbVersionUpdate to True
93414>>>>>            Send UpdateVersionColumnValue
93415>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93417>>>>>        End
93417>>>>>>
93417>>>>>
93417>>>>>    End_Procedure
93418>>>>>
93418>>>>>End_Class
93419>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93419>>>>>//****************************************************************************
93419>>>>>// $Module type: Class
93419>>>>>// $Module name: cDbUpdateUserCount.pkg
93419>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93419>>>>>//
93419>>>>>//               Collected from DAW's newsgroups.
93419>>>>>//
93419>>>>>// Description : It uses the windows API to lock bytes in a file.
93419>>>>>//               If the application or PC craches it will release the lock
93419>>>>>//               automatically.
93419>>>>>//
93419>>>>>// Note 1      : It will count the number of running app's, so if a
93419>>>>>//               user starts the app twice on one machine it will count as two users.
93419>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93419>>>>>//               However, to not conflict with any other usage of this class it was
93419>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93419>>>>>//               and cDbUpdateVersion classes)
93419>>>>>//
93419>>>>>// $Rev History:
93419>>>>>//    2008-10-17  Module header created (Militaty data format)
93419>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93419>>>>>//                for easy translation to other languages.
93419>>>>>//                Added the tUserCount struct for easier passing of parameters.
93419>>>>>//                Added the ApplicationPath message.
93419>>>>>//****************************************************************************
93419>>>>>Use LanguageText.pkg
93419>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93419>>>>>>>Use GlobalFunctionsProcedures.pkg
93419>>>>>>>// Sample:
93419>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93419>>>>>>>
93419>>>>>>>
93419>>>>>>>// Symbols used by UserCounting
93419>>>>>>>    Define GENERIC_READ         for |CI$80000000
93419>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93419>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93419>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93419>>>>>>>    Define CREATE_NEW           for 1
93419>>>>>>>    Define CREATE_ALWAYS        for 2
93419>>>>>>>    Define OPEN_EXISTING        for 3
93419>>>>>>>    Define OPEN_ALWAYS          for 4
93419>>>>>>>    Define TRUNCATE_EXISTING    for 5
93419>>>>>>>    Define FILE_BEGIN           for 0
93419>>>>>>>    Define FILE_CURRENT         for 1
93419>>>>>>>    Define FILE_END             for 2
93419>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93419>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93419>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93419>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93419>>>>>>>    Define _MAX_PATH  for 260
93419>>>>>>>    Define _MAX_DRIVE for 3
93419>>>>>>>    Define _MAX_DIR   for 256
93419>>>>>>>    Define _MAX_FNAME for 256
93419>>>>>>>    Define _MAX_EXT   for 256
93419>>>>>>>
93419>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93420>>>>>>>
93420>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93421>>>>>>>
93421>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93422>>>>>>>
93422>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93423>>>>>>>
93423>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93424>>>>>>>
93424>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93425>>>>>>>
93425>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93426>>>>>>>
93426>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93427>>>>>>>// Sample:
93427>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93427>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93429>>>>>>>    Boolean bReturn
93429>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93430>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93431>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93432>>>>>>>    Function_Return bReturn
93433>>>>>>>End_Function
93434>>>>>Use vWin32fh.pkg
93434>>>>>Use seq_chnl.pkg
93434>>>>>
93434>>>>>// User interface constant strings:
93434>>>>>    Define CS_UserCountError            for "User count error:"
93434>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93434>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93434>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93434>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>
93434>>>>>    Struct tUserCount
93434>>>>>        Integer iUserCount
93434>>>>>        Integer iError
93434>>>>>        String  sErrorTxt
93434>>>>>    End_Struct
93434>>>>>
93434>>>>>    Define CI_UserCountMaxUsers for 9999
93434>>>>>
93434>>>>>Class cDbUpdateUserCount is a cObject
93435>>>>>    Procedure Construct_Object
93437>>>>>        Forward Send Construct_Object
93439>>>>>
93439>>>>>        Property String  psLockFileName
93440>>>>>        Property Integer piMaxUsers
93441>>>>>        Property Boolean pbCheckDataFlexUserCount True
93442>>>>>
93442>>>>>        Property Handle  phUserCountFile
93443>>>>>        Property Integer pdwLockPosition
93444>>>>>    End_Procedure
93445>>>>>
93445>>>>>    Function IsProgramRunning Returns Boolean
93447>>>>>        tUserCount UserCount
93447>>>>>        tUserCount UserCount
93447>>>>>
93447>>>>>        Get CheckUserCount to UserCount
93448>>>>>
93448>>>>>        Function_Return (UserCount.iUserCount > 1)
93449>>>>>    End_Function
93450>>>>>
93450>>>>>    // Returns the full path of the Application (no trailing "\")
93450>>>>>    Function ApplicationPath Returns String
93452>>>>>        String sApplicationFileName sPath
93452>>>>>        Integer iNumChars iRetval
93452>>>>>
93452>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93453>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93454>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93455>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93456>>>>>        Move (CString(sApplicationFileName)) to sPath
93457>>>>>
93457>>>>>        Function_Return sPath
93458>>>>>    End_Function
93459>>>>>
93459>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93461>>>>>        Handle  hFile
93461>>>>>        Pointer pFileName
93461>>>>>        String sPath sFile
93461>>>>>        Integer iCh
93461>>>>>
93461>>>>>        Move (Addressof(sFileName)) to pFileName
93462>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93463>>>>>
93463>>>>>        // If lock file doesn't exist, create it.
93463>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93465>>>>>            Get ApplicationPath to sPath
93466>>>>>            Get vFolderFormat sPath to sPath
93467>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93468>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93469>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93471>>>>>                Function_Return 0
93472>>>>>            End
93472>>>>>>
93472>>>>>            Direct_Output channel iCh sFile
93474>>>>>                Write channel iCh ""
93476>>>>>            Send Seq_Close_Channel iCh
93477>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93478>>>>>        End
93478>>>>>>
93478>>>>>
93478>>>>>        Function_Return hFile
93479>>>>>    End_Function
93480>>>>>
93480>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93482>>>>>        Integer iReturnValue 
93482>>>>>        Boolean bOK
93482>>>>>
93482>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93483>>>>>        If (iReturnValue = 0) Begin
93485>>>>>            Move False to bOK
93486>>>>>        End
93486>>>>>>
93486>>>>>        Else Begin
93487>>>>>            Move True to bOK
93488>>>>>        End
93488>>>>>>
93488>>>>>        Function_Return bOK
93489>>>>>    End_Function
93490>>>>>
93490>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93492>>>>>        Integer iReturnValue
93492>>>>>        Boolean bOK
93492>>>>>
93492>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93493>>>>>        If (iReturnValue = 0) Begin
93495>>>>>            Move False to bOK
93496>>>>>        End
93496>>>>>>
93496>>>>>        Else Begin
93497>>>>>            Move True to bOK
93498>>>>>        End           
93498>>>>>>
93498>>>>>        Function_Return bOK
93499>>>>>    End_Function
93500>>>>>
93500>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93502>>>>>        dWord dwCurrPos
93502>>>>>
93502>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93503>>>>>        Function_Return dwCurrPos
93504>>>>>    End_Function
93505>>>>>
93505>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93507>>>>>        DWord dwCurrPos
93507>>>>>
93507>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93508>>>>>        Function_Return dwCurrPos
93509>>>>>    End_Function
93510>>>>>
93510>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93512>>>>>        Integer iReturnValue                               
93512>>>>>        Boolean bOK
93512>>>>>        String  sBuffer
93512>>>>>        Pointer pBuffer
93512>>>>>        String  sSize
93512>>>>>        Pointer pSize
93512>>>>>
93512>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93513>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93514>>>>>
93514>>>>>        Move (Repeat((Character(0)),4)) to sSize
93515>>>>>        Move (AddressOf(sSize)) to pSize
93516>>>>>
93516>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93517>>>>>        If (iReturnValue = 0) Begin
93519>>>>>            Move False to bOK
93520>>>>>        End
93520>>>>>>
93520>>>>>        Else Begin
93521>>>>>            Move True to bOK
93522>>>>>        End                 
93522>>>>>>
93522>>>>>        Function_Return bOK
93523>>>>>    End_Function
93524>>>>>
93524>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93526>>>>>        Integer iReturnValue
93526>>>>>
93526>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93527>>>>>        Function_Return iReturnValue
93528>>>>>    End_Function
93529>>>>>
93529>>>>>    Procedure DoCheckUserCount
93531>>>>>        tUserCount UserCount
93531>>>>>        tUserCount UserCount
93531>>>>>
93531>>>>>        Get CheckUserCount to UserCount
93532>>>>>        // If all is fine, we're done.
93532>>>>>        If (UserCount.iError = 0) Begin
93534>>>>>            Procedure_Return
93535>>>>>        End
93535>>>>>>
93535>>>>>
93535>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93536>>>>>
93536>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93538>>>>>            Abort
93539>>>>>>
93539>>>>>        End
93539>>>>>>
93539>>>>>    End_Procedure
93540>>>>>
93540>>>>>    Function CheckUserCount Returns tUserCount
93542>>>>>        Handle  hFile
93542>>>>>        String  sPath sFile
93542>>>>>        Integer iResult
93542>>>>>        DWord   dwFilePos
93542>>>>>        Integer bLocked
93542>>>>>        Integer iMaxUsers
93542>>>>>        Integer iCurUser
93542>>>>>        tUserCount UserCount
93542>>>>>        tUserCount UserCount
93542>>>>>
93542>>>>>        Move 0 to UserCount.iError
93543>>>>>
93543>>>>>        Get phUserCountFile to hFile
93544>>>>>        If (not(hFile)) Begin
93546>>>>>            Get ApplicationPath to sPath
93547>>>>>            Get vFolderFormat sPath to sPath
93548>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93549>>>>>            Get OpenUserCountFile sFile to hFile
93550>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93552>>>>>                Move 1 to UserCount.iUserCount
93553>>>>>                Move 1 to UserCount.iError
93554>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93555>>>>>                Function_Return UserCount
93556>>>>>            End
93556>>>>>>
93556>>>>>            Else Begin
93557>>>>>                Move False to bLocked
93558>>>>>                Set phUserCountFile to hFile
93559>>>>>                Get piMaxUsers to iMaxUsers
93560>>>>>
93560>>>>>                // Set Filepointer to beginning of the file
93560>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93561>>>>>                If (dwFilePos = -1) Begin
93563>>>>>                    Move 1 to UserCount.iUserCount
93564>>>>>                    Move 2 to UserCount.iError
93565>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93566>>>>>                    Function_Return UserCount
93567>>>>>                End
93567>>>>>>
93567>>>>>                For iCurUser from 1 to iMaxUsers
93573>>>>>>
93573>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93574>>>>>                    If (not(iResult)) Begin  // byte is locked
93576>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93577>>>>>                        If (dwFilePos = -1) Begin
93579>>>>>                            Move 1 to UserCount.iUserCount
93580>>>>>                            Move 3 to UserCount.iError
93581>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93582>>>>>                            Function_Return UserCount
93583>>>>>                        End
93583>>>>>>
93583>>>>>                    End
93583>>>>>>
93583>>>>>                    Else Begin  // byte is not locked
93584>>>>>                        Set pdwLockPosition to dwFilePos
93585>>>>>                        Move True to bLocked
93586>>>>>                        Move iMaxUsers to iCurUser
93587>>>>>                    End
93587>>>>>>
93587>>>>>                Loop
93588>>>>>>
93588>>>>>                If (not(bLocked)) Begin
93590>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93591>>>>>                    Move 4 to UserCount.iError
93592>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93593>>>>>                    Function_Return UserCount
93594>>>>>                End
93594>>>>>>
93594>>>>>            End
93594>>>>>>
93594>>>>>        End
93594>>>>>>
93594>>>>>
93594>>>>>        Function_Return UserCount
93595>>>>>    End_Function
93596>>>>>
93596>>>>>
93596>>>>>    Procedure DoReleaseUserCount
93598>>>>>        Integer iResult
93598>>>>>        Handle  hFile
93598>>>>>        DWord   dwLockPos
93598>>>>>
93598>>>>>        Get phUserCountFile to hFile
93599>>>>>        Get pdwLockPosition to dwLockPos
93600>>>>>        If (hFile) Begin
93602>>>>>            If (dwLockPos) Begin
93604>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93605>>>>>            End
93605>>>>>>
93605>>>>>            Get CloseUserCountFile hFile to iResult
93606>>>>>        End
93606>>>>>>
93606>>>>>    End_Procedure
93607>>>>>
93607>>>>>    Function CurrentNumberOfUsers Returns Integer
93609>>>>>        Handle  hFile
93609>>>>>        Integer iMaxUsers
93609>>>>>        DWord   dwFilePos
93609>>>>>        Integer iCurUser
93609>>>>>        Integer iResult
93609>>>>>        Integer iNumberOfLocks
93609>>>>>        String  sPath sFile
93609>>>>>
93609>>>>>        Move 0 to iNumberOfLocks
93610>>>>>
93610>>>>>        Get ApplicationPath to sPath
93611>>>>>        Get vFolderFormat sPath to sPath
93612>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93613>>>>>        Get OpenUserCountFile sFile to hFile
93614>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93616>>>>>            Send UserError CS_UnableToInitUserCountSys
93617>>>>>            Abort
93618>>>>>>
93618>>>>>        End
93618>>>>>>
93618>>>>>
93618>>>>>        If (hFile > 0) Begin
93620>>>>>            Get piMaxUsers To iMaxUsers
93621>>>>>
93621>>>>>            // Set Filepointer to beginning of the file
93621>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93622>>>>>            If (dwFilePos = -1) Begin
93624>>>>>                Send UserError CS_UnableResetUserCountSys
93625>>>>>                Abort
93626>>>>>>
93626>>>>>            End
93626>>>>>>
93626>>>>>            For iCurUser from 1 to iMaxUsers
93632>>>>>>
93632>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93633>>>>>                If (Not(iResult)) Begin  // byte is locked
93635>>>>>                    Increment iNumberOfLocks
93636>>>>>                End
93636>>>>>>
93636>>>>>                Else Begin  // byte is not locked
93637>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93638>>>>>                End
93638>>>>>>
93638>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93639>>>>>                If (dwFilePos = -1) Begin
93641>>>>>                    Send UserError CS_ErrorAdvancingPointer
93642>>>>>                    Abort
93643>>>>>>
93643>>>>>                End
93643>>>>>>
93643>>>>>            Loop
93644>>>>>>
93644>>>>>        End
93644>>>>>>
93644>>>>>        Get CloseUserCountFile hFile to iResult
93645>>>>>        Function_Return iNumberOfLocks
93646>>>>>    End_Function
93647>>>>>
93647>>>>>End_Class
93648>>>Use cDbUpdateFunctionLibrary.pkg
93648>>>
93648>>>//{ DataBindable=True }
93648>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93649>>>
93649>>>    Procedure Construct_Object
93651>>>        tUserCount UserCount
93651>>>        tUserCount UserCount
93651>>>        Integer iUserCount
93651>>>        Handle ho                     
93651>>>
93651>>>        Forward Send Construct_Object
93653>>>        Move Self to ghoDbUpdateHandler  
93654>>>        
93654>>>        // Latin1_General_CI_AS = General Insensitive collation
93654>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93654>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93654>>>        // Good read about which collation to select:
93654>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93654>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93655>>>
93655>>>        // Struct array that will contain pnVersionNumbers & object id's of
93655>>>        // all child cDbVersion objects.
93655>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93656>>>
93656>>>        Property Integer Error_Processing_State False  // internal usage
93657>>>        
93657>>>        Property Boolean Private.pbDbVersionCheckDone False
93658>>>
93658>>>        Property Boolean pbUseCustomDbVersion False  
93659>>>        
93659>>>        // If this property = True _and_ no DbVersion table exists 
93659>>>        // when the framework is started, a DbVersion table will be created automatically.
93659>>>        Property Boolean pbAutoCreateDbVersionTable True
93660>>>
93660>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93660>>>        // the Filelist.cfg slot number indicated by this property will be used
93660>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93660>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93660>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93660>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93660>>>        Property Integer Private.piDbVersionFileNumber -1
93661>>>        Property Integer Private.piDbVersionFieldNumber 1
93662>>>
93662>>>        Property Handle  piIntFilesFileNumber -1
93663>>>        Property Boolean pbRestoreIntFilesNow False   
93664>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93664>>>        // also needs to be created in the ghoApplication object.
93664>>>        Property Boolean pbSaveIntFilesNow False
93665>>>        Property Boolean pbUseIntFilesBackup False   
93666>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93667>>>        
93667>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93667>>>        // that creates all library properties
93667>>>        Send CreateDbUpdateLibraryProperties
93668>>>
93668>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93669>>>
93669>>>        // Error handling:
93669>>>        Property Boolean Private.pbOnCreateExecuted False
93670>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93671>>>        Property Boolean Private.pbProcessingError False
93672>>>        Property Boolean pbDbUpdateErrorHasOccured False
93673>>>        // Don't touch. It is being used by the cDbUpdateVersion
93673>>>        // subclass to tell if that particular update was a success or not.
93673>>>        Property Boolean Private.pbUpdateVersionObjectError False
93674>>>        Property String[] paSQLQueryMessages
93675>>>        
93675>>>        Property Boolean pbExitIfDebuggerActive True
93676>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93677>>>        Move Self to Error_Object_Id
93678>>>        // Error handling:
93678>>>        // Temporarily redirect all errors to this object so we can silently
93678>>>        // log all errors that might appear while updating the database.
93678>>>        // We temporarily redirect all errors to this object so we can
93678>>>        // log and write errors to the log file. It will be reset after
93678>>>        // the database updates have been finished.
93678>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93679>>>
93679>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93680>>>
93680>>>        // Error Reporting Related
93680>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93680>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93681>>>
93681>>>        // If the pbContinueOnError = False, an update
93681>>>        // of another cDbUpdateVersion object will _not_ be
93681>>>        // performed if an error occured in a previous
93681>>>        // cDbUpdateVersion object.
93681>>>        Property Boolean pbContinueOnError False
93682>>>        // Stops execution in other cDbUpdateVersion objecs,
93682>>>        // if errors occurred in one cDbUpdateVersion object.
93682>>>        Property Boolean pbStopOnFirstError False
93683>>>        // If True errors that occured while updating the database
93683>>>        // will be shown in the default app for .txt files when done.
93683>>>        // Note: The log file will _always_ be created in the Data folder.
93683>>>        Property Boolean pbShowErrorLogPostRun True
93684>>>
93684>>>        // Be _very_ careful to set this property to true!
93684>>>        // If = True, no question will be asked if the update
93684>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93684>>>        // the error log won't be shown. The logfile itself will still be created though.
93684>>>        // You have to know what you're doing!
93684>>>        Property Boolean pbSilentMode False
93685>>>        
93685>>>        Property Boolean pbEnableCancelButton False
93686>>>
93686>>>        // Don't touch! Very private. The value is used by the error log to write for which
93686>>>        // cDbUpdateVersion object an error occured.
93686>>>        Property Number pnCurrentVersionUpdate 0
93687>>>
93687>>>        // The user counting logic is used to safe-guard agains anybody else is
93687>>>        // using the application when a database update is to be performed.
93687>>>        // (Garters & suspenders!)
93687>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93688>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93689>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93690>>>
93690>>>        // This lock file is used to guard against somebody else tries to start the
93690>>>        // application while updates are in progress.
93690>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93691>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93692>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93693>>>                                                                                      // Only the current user allowed.
93693>>>        // Properties for the table & column of a system file field/column where
93693>>>        // the database version update number gets saved.
93693>>>        Property Integer Private.Data_File  0
93694>>>        Property Integer Private.Data_Field 0
93695>>>
93695>>>        // Property that is used to indicate that we have already
93695>>>        // started the database update.
93695>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93696>>>
93696>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93696>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93696>>>        // change of the database has been made.
93696>>>        Property Boolean Private.pbDatabaseWasUpdated False
93697>>>
93697>>>        // We need to trigger the user counting system so that a bit in the
93697>>>        // user counting file is locked. This is to guard that not more than one user
93697>>>        // is currently runnning the program.
93697>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93698>>>
93698>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93699>>>        If (iUserCount > 0) Begin
93701>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93702>>>            Send Exit_Application
93703>>>        End
93703>>>>
93703>>>
93703>>>        Set pbHandleQueryErrors to False
93704>>>            
93704>>>        Property Handle phoSQLConnectionHandler 0
93705>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93705>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93705>>>        // etc information.
93705>>>        If (ghoSQLConnectionHandler = 0) Begin
93707>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93708>>>            Set phoSQLConnectionHandler to ho
93709>>>        End             
93709>>>>
93709>>>        
93709>>>        Set Icon to "Default.ico"
93710>>>    End_Procedure
93711>>>
93711>>>    Procedure End_Construct_Object
93713>>>        Forward Send End_Construct_Object
93715>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93717>>>            Send OnCreate
93718>>>            Set Private.pbOnCreateExecuted to True
93719>>>        End
93719>>>>
93719>>>        Send Cleanup
93720>>>    End_Procedure
93721>>>    
93721>>>    // Programmers hook event!
93721>>>    Procedure OnCreate
93723>>>    End_Procedure        
93724>>>                                 
93724>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93724>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93724>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93724>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93724>>>    //                                                
93724>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93724>>>    // cDbUpdateHandler object.
93724>>>    //
93724>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93724>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93724>>>    //
93724>>>    // If not done previously the piIntFilesFileNumber will be created and filled with data
93724>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93724>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93724>>>    // of Filelist.cfg is made for backup purposes.
93724>>>    //
93724>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93724>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93724>>>
93724>>>    // Note: Include_Resource is a compiler directive!
93724>>>    // It will embedd the Filelist.cfg from the developers machine
93724>>>    // into the executable.        
93724>>>    //
93724>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93724>>>    // when we get here and then the compiler can't embedd it!        
93724>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93724>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93724>>>    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
93726>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93726>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93726>>>        String sFileListZipFile sParam sProgram sFile 
93726>>>        Integer iDataPaths iCount iSize
93726>>>        Handle hTable hIntFilesTable                    
93726>>>        UChar[] asFileListArray 
93727>>>        String[] asSavedIntFile
93728>>>        tDUFIntFile[] DUFIntFiles
93728>>>        tDUFIntFile[] DUFIntFiles
93729>>>
93729>>>        // This will automatically create the piIntFilesFileNumber if not exists.
93729>>>        // It is used to save data from the current set of .int files.
93729>>>        // We do this on both developer & client machines.
93729>>>        Get IsIntFileTable to bIsIntFileTable
93730>>>        If (bIsIntFileTable = False) Begin
93732>>>            Send AutoCreateIntFilesTable
93733>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93734>>>            If (bOK = False) Begin
93736>>>                Function_Return False
93737>>>            End
93737>>>>
93737>>>        End                                                       
93737>>>>
93737>>>        
93737>>>        Get _CountFilelistSystemTables to iSize
93738>>>        Send StartStatusPanel "" "" iSize
93739>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
93740>>>
93740>>>        // Check Filelist.cfg & backup file
93740>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93741>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93742>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93743>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93744>>>
93744>>>        Move (IsDebuggerPresent()) to bDevelop
93745>>>        // Is this a client machine?
93745>>>        If (bDevelop = False) Begin
93747>>>            If (bNewer = True) Begin
93749>>>                // Create filelist.cfg from resource backup file.
93749>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93750>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93751>>>            End
93751>>>>
93751>>>        End
93751>>>>
93751>>>
93751>>>        Else If (bDevelop = True) Begin
93754>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93755>>>            If (bNewer = True) Begin
93757>>>                Get vDeleteFile sFileListNameBackup to bOK
93758>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93759>>>                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program.\n\nThe program will now exit." to sErrorText
93760>>>            End
93760>>>>
93760>>>        End
93760>>>>
93760>>>        
93760>>>        Move True to bResult 
93761>>>
93761>>>        Get piIntFilesFileNumber to hIntFilesTable
93762>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93763>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93764>>>
93764>>>        For iCount from 1 to iDataPaths
93770>>>>
93770>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93771>>>            Get vFolderFormat sDataPath to sDataPath 
93772>>>            Get vFolderExists sDataPath to bExists
93773>>>            If (bExists = True) Begin                  
93775>>>                Move 0 to hTable
93776>>>                Repeat
93776>>>>
93776>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93779>>>                    If (hTable <> 0 and hTable <> 50) Begin
93781>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93784>>>                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
93785>>>                        Send DoAdvance of ghoProgressBar
93786>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93787>>>                        Get UtilTableIsAlias hTable to bIsAlias 
93788>>>                        If (bIsSQL = True and bIsAlias = False) Begin
93790>>>                            If (bIsSQL = True) Begin     
93792>>>                                Get _TableNameOnly sIntFileName to sIntFileName
93793>>>                                Move (sIntFileName + ".int")    to sIntFileName
93794>>>                                Get IsIntFileSaved sIntFileName to bSaved  
93795>>>                                Move True to bOK            
93796>>>                                
93796>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
93796>>>                                If (bSaved = False) Begin
93798>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93799>>>                                    If (bOK = False) Begin
93801>>>                                        Error DFERR_PROGRAM ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.")
93802>>>>
93802>>>                                        Move False to bResult    
93803>>>                                    End
93803>>>>
93803>>>                                End         
93803>>>>
93803>>>                                Else Begin
93804>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93805>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
93807>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93808>>>                                        If (bOK = False) Begin
93810>>>                                            Move False to bResult
93811>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93812>>>>
93812>>>                                        End
93812>>>>
93812>>>                                    End
93812>>>>
93812>>>                                End
93812>>>>
93812>>>                            End
93812>>>>
93812>>>                        End
93812>>>>
93812>>>                    End
93812>>>>
93812>>>                Until (hTable = 0)
93814>>>            End
93814>>>>
93814>>>        Loop       
93815>>>>
93815>>>        
93815>>>        Send StopStatusPanel
93816>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
93816>>>        If (bResult = False) Begin  
93818>>>            Function_Return False
93819>>>        End 
93819>>>>
93819>>>        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
93820>>>        Function_Return True
93821>>>    End_Function
93822>>>
93822>>>    // It checks that *.int files on disk corresponds with the content in the
93822>>>    // .int file backup table piIntFilesFileNumber.
93822>>>    Procedure RestoreIntFiles
93824>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
93824>>>        String sPaths sDataPath sIntFileName 
93824>>>        String[] asSavedIntFile
93825>>>        Integer iDataPaths iCount iRetval iSize
93825>>>        Handle hTable hIntFilesTable
93825>>>
93825>>>        Get IsIntFileTable to bIsIntFileTable
93826>>>        If (bIsIntFileTable = False) Begin
93828>>>            Send Info_Box "The 'IntFilesTable' was not created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
93829>>>            Procedure_Return
93830>>>        End
93830>>>>
93830>>>        
93830>>>        Get YesNo_Box "This will restore the content of .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed.\n\n Continue?" to iRetval
93831>>>        If (iRetval <> MBR_Yes) Begin
93833>>>            Procedure_Return
93834>>>        End
93834>>>>
93834>>>        
93834>>>        Get _CountFilelistSystemTables to iSize
93835>>>        Send StartStatusPanel "" "" iSize
93836>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
93837>>>
93837>>>        Move False to bRestored
93838>>>        Get piIntFilesFileNumber to hIntFilesTable
93839>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93840>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93841>>>
93841>>>        For iCount from 1 to iDataPaths
93847>>>>
93847>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93848>>>            Get vFolderFormat sDataPath to sDataPath 
93849>>>            Get vFolderExists sDataPath to bExists
93850>>>            If (bExists = True) Begin                  
93852>>>                Move 0 to hTable
93853>>>                Repeat
93853>>>>
93853>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93856>>>                    If (hTable <> 0) Begin
93858>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93861>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
93862>>>                        Send DoAdvance of ghoProgressBar
93863>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93864>>>                        If (bIsSQL = True) Begin     
93866>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93867>>>                            Move (sIntFileName + ".int")    to sIntFileName
93868>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93869>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
93871>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
93872>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
93873>>>                                If (bRestored = False and bOK = True) Begin
93875>>>                                    Move True to bRestored
93876>>>                                End
93876>>>>
93876>>>                                If (bOK = False) Begin
93878>>>                                    Error DFERR_PROGRAM ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName))
93879>>>>
93879>>>                                End
93879>>>>
93879>>>                            End
93879>>>>
93879>>>                        End
93879>>>>
93879>>>                    End
93879>>>>
93879>>>                Until (hTable = 0)
93881>>>            End
93881>>>>
93881>>>        Loop       
93882>>>>
93882>>>        
93882>>>        Send StopStatusPanel
93883>>>        If (bRestored = True) Begin
93885>>>            Send Info_Box "Ready! All .int files checked and updated if different. The program will now exit."
93886>>>            Send Exit_Application
93887>>>        End
93887>>>>
93887>>>    End_Procedure
93888>>>
93888>>>    Function IsIntFileTable Returns Boolean
93890>>>        Boolean bExists
93890>>>        Handle hTable
93890>>>        String sLogicalName
93890>>>        Move False to bExists
93891>>>        Get piIntFilesFileNumber to hTable
93892>>>        If (hTable > 0) Begin
93894>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93897>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
93898>>>        End
93898>>>>
93898>>>        Function_Return bExists    
93899>>>    End_Function
93900>>>    
93900>>>    // To update currently saved IntFile data to the database.
93900>>>    // Because it is much easier, we first delete all current records and
93900>>>    // then saves the changed .int file to the database.
93900>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93902>>>        Boolean bOK
93902>>>        Move False to bOK
93903>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93904>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93905>>>        If (bOK = True) Begin
93907>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93908>>>        End
93908>>>>
93908>>>        Function_Return bOK
93909>>>    End_Function
93910>>>    
93910>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
93910>>>    //       and thus we cannot compile.
93910>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93912>>>        Handle hTable
93912>>>        Boolean bOK
93912>>>        Integer iColumn iIndex   
93912>>>        String sFileName
93912>>>        
93912>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93913>>>        Move False to bOK  
93914>>>        Get piIntFilesFileNumber to hTable
93915>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93916>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93917>>>
93917>>>        Open hTable
93919>>>        Set_Field_Value hTable iColumn to sIntFileName
93922>>>        Vfind hTable iIndex GE
93924>>>        Get_Field_Value hTable iColumn to sFileName
93927>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93929>>>            Move True to bOK    
93930>>>        End
93930>>>>
93930>>>        Close hTable
93931>>>        
93931>>>        Function_Return bOK       
93932>>>    End_Function   
93933>>>    
93933>>>    // Checks that the passed .int file is the same as what is saved in the database.
93933>>>    // If not same, the return string array will contain the read .int file,
93933>>>    // else the returned array will be empty.
93933>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93935>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93939>>>        Boolean bIsSame
93939>>>        
93939>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93940>>>        Get ReadIntFileData  sDataPath sIntFileName to asIntFileOrg   
93941>>>        Get SavedIntFileData sDataPath sIntFileName to asSavedIntFile
93942>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93943>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93944>>>        
93944>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93945>>>        If (bIsSame = False) Begin
93947>>>            Move asIntFileOrg to asReturnIntFile    
93948>>>        End
93948>>>>
93948>>>        
93948>>>        Function_Return asReturnIntFile    
93949>>>    End_Function                                   
93950>>>    
93950>>>    // Takes a string array as parameter and returns a new
93950>>>    // string array without any empty rows and all rows trimmed.
93950>>>    // This is e.g. used by the HasIntFileChanged message to compare
93950>>>    // two .int file arrays. 
93950>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93952>>>        Integer iSize iCount iRow
93952>>>        String sVal        
93952>>>        String[] asRetValArray
93953>>>        
93953>>>        Move (SizeOfArray(asIntFile)) to iSize
93954>>>        If (iSize = 0) Begin
93956>>>            Function_Return asRetValArray
93957>>>        End                          
93957>>>>
93957>>>        Decrement iSize         
93958>>>        Move 0 to iRow
93959>>>        
93959>>>        For iCount from 0  to iSize
93965>>>>
93965>>>            Move asIntFile[iCount] to sVal
93966>>>            Move (Trim(sVal)) to sVal
93967>>>            If (sVal <> "") Begin
93969>>>                Move sVal to asRetValArray[iRow]
93970>>>                Increment iRow        
93971>>>            End
93971>>>>
93971>>>        Loop
93972>>>>
93972>>>        
93972>>>        Function_Return asRetValArray
93973>>>    End_Function
93974>>>    
93974>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93976>>>        Handle hTable
93976>>>        Boolean bOK bErr
93976>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93976>>>        Number iID
93976>>>        String sFileName
93976>>>        String[] asIntFile
93977>>>        
93977>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
93977>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93978>>>        
93978>>>        Move Err to bErr
93979>>>        Move False to Err
93980>>>        Move False to bOK
93981>>>        Get piIntFilesFileNumber to hTable  
93982>>>        Move 1              to iIDCol
93983>>>        Move 2              to iFileCol
93984>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93985>>>        Move 1              to iIDIdx   // Main ID index.
93986>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93987>>>
93987>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93988>>>        Move (SizeOfArray(asIntFile)) to iSize
93989>>>        If (iSize = 0) Begin
93991>>>            Function_Return False
93992>>>        End
93992>>>>
93992>>>        Decrement iSize
93993>>>        Open hTable  
93995>>>                  
93995>>>        // Find the last used ID no:
93995>>>        Fill_Field hTable iIDCol with DF_HIGH
93997>>>        Vfind hTable iIDIdx LE
93999>>>        Get_Field_Value hTable iIDCol to iID 
94002>>>        // This only happens the very first time we save a record.
94002>>>        If (iID = 999999999999) Begin
94004>>>            Move 0 to iID
94005>>>        End
94005>>>>
94005>>>        Increment iID
94006>>>        
94006>>>        Lock
94007>>>>
94007>>>            For iCount from 0 to iSize
94013>>>>
94013>>>                Clear hTable
94014>>>                Set_Field_Value hTable iIDCol   to iID     
94017>>>                Set_Field_Value hTable iFileCol to sIntFileName
94020>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94023>>>                SaveRecord hTable
94024>>>                Increment iID
94025>>>            Loop
94026>>>>
94026>>>        Unlock
94027>>>>
94027>>>        Close hTable
94028>>>        
94028>>>        Move (not(Err)) to bOK
94029>>>        Move bErr to Err
94030>>>        
94030>>>        Function_Return bOK
94031>>>    End_Function
94032>>>    
94032>>>    // Deletes all records for the passed sIntFileName value,
94032>>>    // from the piIntFilesFileNumber.
94032>>>    // Returns True if no errors occured.
94032>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94034>>>        Handle hTable
94034>>>        Boolean bOK bErr bFound
94034>>>        Integer iFileCol iIndex
94034>>>        String sVal
94034>>>        String[] asIntFile
94035>>>        
94035>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94036>>>        Move Err to bErr
94037>>>        Move False to Err
94038>>>        Move False to bOK
94039>>>        Move 2              to iFileCol
94040>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94041>>>        Get piIntFilesFileNumber to hTable  
94042>>>        Open hTable  
94044>>>                  
94044>>>        // Find the first record
94044>>>        Set_Field_Value hTable iFileCol to sIntFileName
94047>>>        Vfind hTable iIndex GE
94049>>>        Get_Field_Value hTable iFileCol to sVal
94052>>>        Move (Trim(Lowercase(sVal))) to sVal
94053>>>        Move (Found and sVal = sIntFileName) to bFound
94054>>>        While (bFound = True)
94058>>>            Delete hTable
94059>>>            Vfind hTable iIndex GT
94061>>>            Get_Field_Value hTable iFileCol to sVal
94064>>>            Move (Trim(Lowercase(sVal))) to sVal
94065>>>            Move (Found and sVal = sIntFileName) to bFound
94066>>>        Loop
94067>>>>
94067>>>        Unlock
94068>>>>
94068>>>        Close hTable
94069>>>        
94069>>>        Move (not(Err)) to bOK
94070>>>        Move bErr to Err
94071>>>        
94071>>>        Function_Return bOK
94072>>>    End_Function
94073>>>
94073>>>    // Returns all saved piIntFilesFileNumber records for the passed 
94073>>>    // sIntFileName value as a string array.
94073>>>    Function SavedIntFileData String sPath String sIntFileName Returns String[]
94075>>>        Handle hTable
94075>>>        Boolean bOK bErr bFound
94075>>>        Integer iFileCol iTextCol iIndex
94075>>>        String sVal sFileName
94075>>>        String[] asIntFile asEmptyArray
94077>>>        
94077>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94078>>>        Move Err to bErr
94079>>>        Move False to Err
94080>>>        Move False to bOK
94081>>>        Move 2              to iFileCol
94082>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94083>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94084>>>        Get piIntFilesFileNumber to hTable  
94085>>>        Open hTable  
94087>>>        
94087>>>        // Find the first record
94087>>>        Set_Field_Value hTable iFileCol to sIntFileName
94090>>>        Vfind hTable iIndex GE
94092>>>        Get_Field_Value hTable iFileCol to sFileName
94095>>>        Move (Trim(Lowercase(sFileName))) to sFileName
94096>>>        Move (Found and sFileName = sIntFileName) to bFound
94097>>>        While (bFound = True)
94101>>>            Get_Field_Value hTable iFileCol   to sFileName
94104>>>            Move (Trim(Lowercase(sFileName))) to sFileName
94105>>>            Move (Found and sFileName = sIntFileName) to bFound
94106>>>            If (bFound = True) Begin
94108>>>                Get_Field_Value hTable iTextCol to sVal
94111>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94112>>>            End
94112>>>>
94112>>>            Vfind hTable iIndex GT
94114>>>        Loop
94115>>>>
94115>>>        
94115>>>        Close hTable
94116>>>        Move (not(Err)) to bOK
94117>>>        If (bOK = False) Begin
94119>>>            Move asEmptyArray to asIntFile
94120>>>        End
94120>>>>
94120>>>        Move bErr to Err               
94121>>>        
94121>>>        Function_Return asIntFile
94122>>>    End_Function
94123>>>
94123>>>    // Reads the passed sIntFileName from disk and returns its value
94123>>>    // as a string array.
94123>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
94125>>>        String[] asIntFile       
94126>>>        String sFileName sLine
94126>>>        Integer iCh iSize iCount
94126>>>        
94126>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94127>>>        Get vFolderFormat sPath to sPath
94128>>>        If (not(sIntFileName contains ".")) Begin
94130>>>            Move (sIntFileName + ".int") to sIntFileName
94131>>>        End
94131>>>>
94131>>>        Move (sPath + sIntFileName) to sFileName
94132>>>        Get Seq_Open_input_Channel sFileName to iCh
94133>>>        If (iCh < 0) Begin
94135>>>            Function_Return asIntFile
94136>>>        End                                 
94136>>>>
94136>>>        
94136>>>        Repeat
94136>>>>
94136>>>            Readln channel iCh sLine
94138>>>            If (SeqEof = False) Begin
94140>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
94141>>>            End
94141>>>>
94141>>>        Until (SeqEof = True)
94143>>>        Send Seq_Close_Channel iCh    
94144>>>        
94144>>>        Function_Return asIntFile
94145>>>    End_Function
94146>>>    
94146>>>    // Reads the Filelist.cfg from memeory as a resource.
94146>>>    // The Filelist.cfg has been compiled into the program.
94146>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94148>>>        Integer iCh iCount
94148>>>        Number nByteCount
94148>>>        String[] asFileListArray sEmptyArray
94150>>>        String sLine
94150>>>        UChar[] uCharData
94151>>>        
94151>>>        Move False to Err
94152>>>        Get Seq_New_Channel to iCh
94153>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94155>>>            Error DFERR_PROGRAM 'No channel available...'
94156>>>>
94156>>>            Function_Return sEmptyArray
94157>>>        End
94157>>>>
94157>>>
94157>>>        // First decide the size of the script
94157>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94159>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94161>>>        Close_Input channel iCh
94163>>>        Send Seq_Release_Channel iCh
94164>>>
94164>>>        Function_Return uCharData
94165>>>    End_Function    
94166>>>    
94166>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94166>>>    // It does so by reading from a memory resource, as the file has
94166>>>    // been compiled into the program.
94166>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94168>>>        Boolean bOK bErr
94168>>>        Integer iSize iCh
94168>>>        
94168>>>        Move Err to bErr
94169>>>        Move False to Err
94170>>>        Move False to bOK
94171>>>        Move (SizeOfArray(asFileListArray)) to iSize
94172>>>        If (iSize = 0) Begin
94174>>>            Function_Return False
94175>>>        End
94175>>>>
94175>>>
94175>>>        Get Seq_New_Channel to iCh
94176>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94178>>>            Error DFERR_PROGRAM 'No channel available...'
94179>>>>
94179>>>            Function_Return False
94180>>>        End                      
94180>>>>
94180>>>        
94180>>>        Direct_Output channel iCh sFileListName
94182>>>        Writeln channel iCh asFileListArray
94185>>>                
94185>>>        Close_Input channel iCh
94187>>>        Send Seq_Release_Channel iCh
94188>>>        Move (not(Err)) to bOK
94189>>>        Move bErr to Err
94190>>>        
94190>>>        Function_Return bOK
94191>>>    End_Function
94192>>>
94192>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the piIntFilesFileNumber data table.
94192>>>    // It first deletes the .cch file (if any).
94192>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
94194>>>        Boolean bOK bFound bExists bErr
94194>>>        Integer iCh iSize iCount
94194>>>        String sFileName sCCHFileName sVal
94194>>>        String[] asIntFile
94195>>>        
94195>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94196>>>        Move Err to bErr   
94197>>>        Move False to Err
94198>>>        Move False to bOK
94199>>>
94199>>>        Get SavedIntFileData sDataPath sIntFileName to asIntFile
94200>>>        Move (SizeOfArray(asIntFile)) to iSize
94201>>>        If (iSize = 0) Begin
94203>>>            Function_Return False        
94204>>>        End                      
94204>>>>
94204>>>        Decrement iSize
94205>>>        
94205>>>        Get Seq_New_Channel to iCh
94206>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94208>>>            Function_Return False
94209>>>        End   
94209>>>>
94209>>>        
94209>>>        // Before we start to actually create the new .int file, make sure we delete
94209>>>        // the .cch file.                                     
94209>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94210>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94211>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94212>>>        If (bExists = True) Begin
94214>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94215>>>            If (bOK = False) Begin
94217>>>                Function_Return False
94218>>>            End
94218>>>>
94218>>>        End
94218>>>>
94218>>>        
94218>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94220>>>        For iCount from 0 to iSize
94226>>>>
94226>>>            Writeln channel iCh asIntFile[iCount]
94229>>>        Loop
94230>>>>
94230>>>        
94230>>>        Close_Input channel iCh
94232>>>        Send Seq_Release_Channel iCh
94233>>>        Move (not(Err)) to bOK
94234>>>        Move bErr to Err
94235>>>        
94235>>>        Function_Return bOK
94236>>>    End_Function   
94237>>>              
94237>>>    // Automatically writes .int files to disk that is missing.
94237>>>    // We only need to make this test this once, but because the message is called
94237>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94237>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94237>>>    Procedure AutoCreateIntFilesTable
94239>>>        Integer hTable 
94239>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
94239>>>        String sInfoTxt 
94239>>>        
94239>>>        Get piIntFilesFileNumber to hTable  
94240>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94241>>>        If (bIntFilesTablesCheckDone = True) Begin
94243>>>            Procedure_Return
94244>>>        End
94244>>>>
94244>>>
94244>>>        If (hTable < 1) Begin
94246>>>            Set Private.pbIntFilesTablesCheckDone to False
94247>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94248>>>            Error DFERR_PROGRAM "The piIntFilesFileNumber has been set! The property MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94249>>>>
94249>>>            Send Exit_Application
94250>>>        End
94250>>>>
94250>>>        
94250>>>        Get IsIntFileTable hTable to bTableExists
94251>>>        If (bTableExists = True) Begin
94253>>>            Set Private.pbIntFilesTablesCheckDone to True
94254>>>            Procedure_Return
94255>>>        End
94255>>>>
94255>>>
94255>>>        Send SubCreateIntFilesTable hTable
94256>>>    End_Procedure
94257>>>                
94257>>>    Procedure SubCreateIntFilesTable Handle hTable
94259>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94259>>>        Boolean bTableExists bOK bUseConnectionID bExists
94259>>>        tAPIColumn[] APIColumn
94259>>>        tAPIColumn[] APIColumn
94260>>>
94260>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94261>>>        If (bTableExists = True) Begin
94263>>>            Procedure_Return
94264>>>        End
94264>>>>
94264>>>
94264>>>        Move False to Err
94265>>>        Get psDriverID to sDriverID
94266>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94267>>>
94267>>>        Move CS_IntFilesTableLogicalName to sTableName
94268>>>
94268>>>        Move 1                  to APIColumn[0].iFieldNumber
94269>>>        Move "ID"               to APIColumn[0].sFieldName
94270>>>        Move DF_BCD             to APIColumn[0].iType
94271>>>        Move False              to APIColumn[0].bIsSQLType
94272>>>        Move 12                 to APIColumn[0].iLength
94273>>>        Move 0                  to APIColumn[0].iPrecision
94274>>>
94274>>>        Move 2                  to APIColumn[1].iFieldNumber
94275>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94276>>>        Move DF_ASCII           to APIColumn[1].iType
94277>>>        Move False              to APIColumn[1].bIsSQLType
94278>>>        Move 50                 to APIColumn[1].iLength
94279>>>        Move 0                  to APIColumn[1].iPrecision
94280>>>
94280>>>        Move 3                  to APIColumn[2].iFieldNumber
94281>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94282>>>        Move DF_ASCII           to APIColumn[2].iType
94283>>>        Move False              to APIColumn[2].bIsSQLType
94284>>>        Move 100                to APIColumn[2].iLength
94285>>>        Move 0                  to APIColumn[2].iPrecision
94286>>>
94286>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94287>>>        
94287>>>        If (bOK = True and Err = False) Begin
94289>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94290>>>        End
94290>>>>
94290>>>        Else Begin
94291>>>            Set Private.pbIntFilesTablesCheckDone to False
94292>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94293>>>            Error DFERR_PROGRAM sInfoTxt
94294>>>>
94294>>>            Procedure_Return
94295>>>        End
94295>>>>
94295>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94296>>>        
94296>>>        Open hTable
94298>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94299>>>        If (bOK = True) Begin
94301>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94302>>>        End
94302>>>>
94302>>>        If (bOK = False) Begin
94304>>>            Set Private.pbIntFilesTablesCheckDone to False
94305>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94306>>>            Error DFERR_PROGRAM sInfoTxt
94307>>>>
94307>>>            Procedure_Return
94308>>>        End
94308>>>>
94308>>>        
94308>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94308>>>        If (sDriverID <> DATAFLEX_ID) Begin
94310>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94311>>>            Get vFolderFormat sDataPath to sDataPath
94312>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
94313>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
94314>>>            If (bExists = True) Begin
94316>>>                Move CS_IntFilesTableLogicalName to sTableName
94317>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94318>>>                If (bExists = True) Begin
94320>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94321>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94322>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94323>>>                End
94323>>>>
94323>>>            End
94323>>>>
94323>>>        End
94323>>>>
94323>>>        
94323>>>        Set Private.pbIntFilesTablesCheckDone to True
94324>>>    End_Procedure
94325>>>
94325>>>    Procedure CheckAutoCreateDbVersionTable
94327>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94327>>>        Integer iDbVersionFileNumber
94327>>>
94327>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94328>>>        If (bDbVersionCheckDone = True) Begin
94330>>>            Procedure_Return
94331>>>        End
94331>>>>
94331>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94332>>>        If (bUseCustomDbVersion = True) Begin
94334>>>            Procedure_Return
94335>>>        End
94335>>>>
94335>>>
94335>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94336>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94337>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
94339>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94340>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94341>>>>
94341>>>            Send Exit_Application
94342>>>        End
94342>>>>
94342>>>
94342>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94343>>>        If (bTableExists = True) Begin
94345>>>            Set Private.pbDbVersionCheckDone to True
94346>>>            Procedure_Return
94347>>>        End
94347>>>>
94347>>>
94347>>>        Send CreateDbVersionTable iDbVersionFileNumber
94348>>>
94348>>>        // We only need to these DbVersion checks once, but because this message is called
94348>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94348>>>        // we use a property to only run these tests once.
94348>>>        Set Private.pbDbVersionCheckDone to True
94349>>>    End_Procedure
94350>>>
94350>>>    Procedure CreateDbVersionTable Handle hTable
94352>>>        String sTableName sColumnName sInfoTxt sDriverID 
94352>>>        Boolean bTableExists bOK bUseConnectionID
94352>>>        tAPIColumn[] APIColumn
94352>>>        tAPIColumn[] APIColumn
94353>>>
94353>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94354>>>        If (bTableExists = True) Begin
94356>>>            Procedure_Return
94357>>>        End
94357>>>>
94357>>>
94357>>>        Get psDriverID to sDriverID
94358>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94359>>>
94359>>>        Move "DbVersion"        to sTableName
94360>>>        Move 1                  to APIColumn[0].iFieldNumber
94361>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94362>>>        Move DF_BCD             to APIColumn[0].iType
94363>>>        Move False              to APIColumn[0].bIsSQLType
94364>>>        Move 4                  to APIColumn[0].iLength
94365>>>        Move 2                  to APIColumn[0].iPrecision
94366>>>
94366>>>        Move False to Err                                
94367>>>        
94367>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94367>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94367>>>        Set psDriverID to DATAFLEX_ID
94368>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94369>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94370>>>        Set psDriverID to sDriverID
94371>>>        
94371>>>        If (bOK = True and Err = False) Begin
94373>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94373>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94374>>>        End
94374>>>>
94374>>>        Else Begin
94375>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94376>>>        End
94376>>>>
94376>>>
94376>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94377>>>    End_Procedure
94378>>>
94378>>>    Procedure Set pbVerboseState Boolean bVerboseState
94380>>>        Handle ho
94380>>>        Get phoLogFile to ho
94381>>>        Set pbVerboseState of ho to bVerboseState
94382>>>    End_Procedure
94383>>>
94383>>>    Function pbVerboseState Returns Boolean
94385>>>        Boolean bVerboseState
94385>>>        Handle ho
94385>>>        Get phoLogFile to ho
94386>>>        Get pbVerboseState of ho to bVerboseState
94387>>>        Function_Return bVerboseState
94388>>>    End_Function
94389>>>
94389>>>    // Callback functionality used when e.g. calling driver functions directly.
94389>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94389>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94391>>>        Integer iPerc
94391>>>        Number nReady nTotal nVersion
94391>>>        Boolean bVerboseState
94391>>>        Handle hoLogFile
94391>>>
94391>>>        Get pbVerboseState to bVerboseState
94392>>>        Get pnCurrentVersionUpdate to nVersion
94393>>>        Get phoLogFile     to hoLogFile
94394>>>        Send DoAdvance of ghoProgressBar
94395>>>
94395>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94397>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94398>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94399>>>        End
94399>>>>
94399>>>        If (sCallback_Text contains "Creating index") Begin
94401>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94402>>>        End
94402>>>>
94402>>>        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
94404>>>            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94405>>>        End
94405>>>>
94405>>>        If (iCallback_Type <> DF_Message_Progress_Value) Begin
94407>>>            Set Message_Text of ghoStatusPanel to sCallback_Text
94408>>>            Set Action_Text  of ghoStatusPanel to ""
94409>>>        End
94409>>>>
94409>>>
94409>>>        Case Begin
94409>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94411>>>                Set Action_Text  of ghoStatusPanel to ""
94412>>>                Case Break
94413>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94416>>>                //*** Interpret numbers
94416>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94417>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94418>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94419>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94420>>>                Set piPosition of ghoProgressBar to iPerc
94421>>>                Case Break
94422>>>//            Case Else
94422>>>//                Set Message_Text of ghoStatusPanel to ""
94422>>>//                Set Action_Text  of ghoStatusPanel to ""
94422>>>        Case End
94422>>>
94422>>>        Send ProcessEvents of ghoStatusPanel
94423>>>        Function_Return False
94424>>>    End_Function
94425>>>
94425>>>    // This was made to be a procedure/function pair so we
94425>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94425>>>
94425>>>    Procedure Set piDbType Integer iDbType
94427>>>        If (ghoSQLConnectionHandler = 0) Begin
94429>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94430>>>>
94430>>>            Procedure_Return
94431>>>        End
94431>>>>
94431>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94432>>>    End_Procedure
94433>>>
94433>>>    Function piDbType Returns Integer
94435>>>        Integer iDbType
94435>>>        If (ghoSQLConnectionHandler = 0) Begin
94437>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94438>>>>
94438>>>            Function_Return ""
94439>>>        End
94439>>>>
94439>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94440>>>        Function_Return iDbType
94441>>>    End_Function
94442>>>
94442>>>    Procedure Set psDriverID String sDriverID
94444>>>        If (ghoSQLConnectionHandler = 0) Begin
94446>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94447>>>>
94447>>>            Procedure_Return
94448>>>        End
94448>>>>
94448>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94449>>>    End_Procedure
94450>>>
94450>>>    Function psDriverID Returns String
94452>>>        String sValue
94452>>>        If (ghoSQLConnectionHandler = 0) Begin
94454>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94455>>>>
94455>>>            Function_Return ""
94456>>>        End
94456>>>>
94456>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94457>>>        Function_Return sValue
94458>>>    End_Function
94459>>>
94459>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94461>>>        If (ghoSQLConnectionHandler = 0) Begin
94463>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94464>>>>
94464>>>            Procedure_Return
94465>>>        End
94465>>>>
94465>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94466>>>    End_Procedure
94467>>>
94467>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94469>>>        Integer iRetval
94469>>>        If (ghoSQLConnectionHandler = 0) Begin
94471>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94472>>>>
94472>>>            Function_Return 2
94473>>>        End
94473>>>>
94473>>>
94473>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94474>>>        Function_Return iRetval
94475>>>    End_Function
94476>>>
94476>>>    Procedure Set psConnectionID String sValue
94478>>>        If (ghoSQLConnectionHandler = 0) Begin
94480>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94481>>>>
94481>>>            Procedure_Return
94482>>>        End
94482>>>>
94482>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94483>>>    End_Procedure
94484>>>
94484>>>    Function psConnectionID Returns String
94486>>>        String sValue
94486>>>        If (ghoSQLConnectionHandler = 0) Begin
94488>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94489>>>>
94489>>>            Function_Return ""
94490>>>        End
94490>>>>
94490>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94491>>>
94491>>>        Function_Return sValue
94492>>>    End_Function
94493>>>
94493>>>    // These "properties" are settings of the cCLIHandler class, but are being
94493>>>    // relayed to the ghoSQLConnectionHandler object
94493>>>    // simply by changing one of its parameters.
94493>>>    Procedure Set psServer String sValue
94495>>>        If (ghoSQLConnectionHandler = 0) Begin
94497>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94498>>>>
94498>>>            Procedure_Return
94499>>>        End
94499>>>>
94499>>>        Set psServer of ghoSQLConnectionHandler to sValue
94500>>>    End_Procedure
94501>>>
94501>>>    Function psServer Returns String
94503>>>        String sValue
94503>>>        If (ghoSQLConnectionHandler = 0) Begin
94505>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94506>>>>
94506>>>            Function_Return ""
94507>>>        End
94507>>>>
94507>>>        Get psServer of ghoSQLConnectionHandler to sValue
94508>>>
94508>>>        Function_Return sValue
94509>>>    End_Function
94510>>>
94510>>>    Procedure Set psDatabase String sValue
94512>>>        If (ghoSQLConnectionHandler = 0) Begin
94514>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94515>>>>
94515>>>            Procedure_Return
94516>>>        End
94516>>>>
94516>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94517>>>    End_Procedure
94518>>>
94518>>>    Function psDatabase Returns String
94520>>>        String sValue
94520>>>        If (ghoSQLConnectionHandler = 0) Begin
94522>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94523>>>>
94523>>>            Function_Return ""
94524>>>        End
94524>>>>
94524>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94525>>>
94525>>>        Function_Return sValue
94526>>>    End_Function
94527>>>
94527>>>    Procedure Set psUserID String sValue
94529>>>        If (ghoSQLConnectionHandler = 0) Begin
94531>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94532>>>>
94532>>>            Procedure_Return
94533>>>        End
94533>>>>
94533>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94534>>>    End_Procedure
94535>>>
94535>>>    Function psUserID Returns String
94537>>>        String sValue
94537>>>        If (ghoSQLConnectionHandler = 0) Begin
94539>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94540>>>>
94540>>>            Function_Return ""
94541>>>        End
94541>>>>
94541>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94542>>>
94542>>>        Function_Return sValue
94543>>>    End_Function
94544>>>
94544>>>    Procedure Set psPassword String sValue
94546>>>        If (ghoSQLConnectionHandler = 0) Begin
94548>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94549>>>>
94549>>>            Procedure_Return
94550>>>        End
94550>>>>
94550>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94551>>>    End_Procedure
94552>>>
94552>>>    Function psPassword Returns String
94554>>>        String sValue
94554>>>        If (ghoSQLConnectionHandler = 0) Begin
94556>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94557>>>>
94557>>>            Function_Return ""
94558>>>        End
94558>>>>
94558>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94559>>>
94559>>>        Function_Return sValue
94560>>>    End_Function
94561>>>
94561>>>    Procedure Set pbTrusted Boolean bValue
94563>>>        If (ghoSQLConnectionHandler = 0) Begin
94565>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94566>>>>
94566>>>            Procedure_Return
94567>>>        End
94567>>>>
94567>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94568>>>    End_Procedure
94569>>>
94569>>>    Function pbTrusted Returns Boolean
94571>>>        Boolean bValue
94571>>>        If (ghoSQLConnectionHandler = 0) Begin
94573>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94574>>>>
94574>>>            Function_Return False
94575>>>        End
94575>>>>
94575>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94576>>>
94576>>>        Function_Return bValue
94577>>>    End_Function
94578>>>
94578>>>    Procedure Set psConnectionString String sValue
94580>>>        If (ghoSQLConnectionHandler = 0) Begin
94582>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94583>>>>
94583>>>            Procedure_Return
94584>>>        End
94584>>>>
94584>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94585>>>    End_Procedure
94586>>>
94586>>>    Function psConnectionString Returns String
94588>>>        String sValue
94588>>>        If (ghoSQLConnectionHandler = 0) Begin
94590>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94591>>>>
94591>>>            Function_Return ""
94592>>>        End
94592>>>>
94592>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94593>>>
94593>>>        Function_Return sValue
94594>>>    End_Function
94595>>>
94595>>>    Function piConnectionOptions Returns Integer
94597>>>        Integer iValue
94597>>>        If (ghoSQLConnectionHandler = 0) Begin
94599>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94600>>>>
94600>>>            Function_Return 0
94601>>>        End
94601>>>>
94601>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94602>>>
94602>>>        Function_Return iValue
94603>>>    End_Function
94604>>>
94604>>>
94604>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94606>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94607>>>    End_Procedure
94608>>>
94608>>>    Function pbCheckDataFlexUserCount Returns Boolean
94610>>>        Boolean bState
94610>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94611>>>        Function_Return bState
94612>>>    End_Function
94613>>>
94613>>>    Procedure Set psLogTextFile String sValue
94615>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94616>>>    End_Procedure
94617>>>
94617>>>    Function psLogTextFile Returns String
94619>>>        String sValue
94619>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94620>>>        Function_Return sValue
94621>>>    End_Function
94622>>>
94622>>>    Procedure Set psEditorProgram String sValue
94624>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94625>>>    End_Procedure
94626>>>
94626>>>    Function psEditorProgram Returns String
94628>>>        String sValue
94628>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94629>>>        Function_Return sValue
94630>>>    End_Function
94631>>>
94631>>>    Procedure Set pbUseDataTableLog Boolean bState
94633>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94634>>>    End_Procedure
94635>>>
94635>>>    Function pbUseDataTableLog Returns Boolean
94637>>>        Boolean bState
94637>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94638>>>        Function_Return bState
94639>>>    End_Function
94640>>>
94640>>>    Procedure Set pbQuickWrite Boolean bState
94642>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94643>>>    End_Procedure
94644>>>
94644>>>    Function pbQuickWrite Returns Boolean
94646>>>        Boolean bState
94646>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94647>>>        Function_Return bState
94648>>>    End_Function
94649>>>
94649>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94651>>>        Boolean bUpdateVersionObjectError bVerboseState
94651>>>        Integer iSize iCount
94651>>>        Number nVersion
94651>>>        String[] aSQLQueryMessages
94652>>>
94652>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94653>>>        Set Private.pbDatabaseWasUpdated to bState
94654>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94654>>>        // to the log that it was OK.
94654>>>        If (bUpdateVersionObjectError = False) Begin
94656>>>            Get pnCurrentVersionUpdate to nVersion
94657>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94658>>>        End
94658>>>>
94658>>>
94658>>>        Get pbVerboseState to bVerboseState
94659>>>        If (bVerboseState = True) Begin
94661>>>            Get paSQLQueryMessages to aSQLQueryMessages
94662>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94663>>>            Decrement iSize
94664>>>            For iCount from 0 to iSize
94670>>>>
94670>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94671>>>            Loop
94672>>>>
94672>>>        End
94672>>>>
94672>>>
94672>>>    End_Procedure 
94673>>>    
94673>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94675>>>        Set Private.piDbVersionFileNumber to iFileNumber
94676>>>    End_Procedure                                         
94677>>>    
94677>>>    Function piDbVersionFileNumber Returns Integer
94679>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94680>>>    End_Function
94681>>>
94681>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94683>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94684>>>    End_Procedure                                         
94685>>>    
94685>>>    Function piDbVersionFieldNumber Returns Integer
94687>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94688>>>    End_Function
94689>>>
94689>>>    Function pbDatabaseWasUpdated Returns Boolean
94691>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94692>>>    End_Function
94693>>>    
94693>>>    //
94693>>>    Procedure ReinitializeFramework  
94695>>>        tDbVersionInfo[] aDbVersionInfoArray
94695>>>        tDbVersionInfo[] aDbVersionInfoArray
94696>>>        Handle hoDbVersionObject
94696>>>        Integer iSize iCount
94696>>>        
94696>>>        Set Private.pbDatabaseUpdateStarted to False
94697>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94698>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94699>>>        Decrement iSize
94700>>>        
94700>>>        For iCount from 0 to iSize
94706>>>>
94706>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94707>>>            Send ProcessUpdate                  of hoDbVersionObject False
94708>>>        Loop
94709>>>>
94709>>>        Send Cleanup
94710>>>    End_Procedure
94711>>>    
94711>>>    Procedure StartStatusPanel String sMsg String sMsg2 Integer iSze
94713>>>        Integer iSize
94713>>>        String sMessage sMessage2
94713>>>        
94713>>>        // Make it optional to pass an argument
94713>>>        If (num_arguments > 0) Begin
94715>>>            Move sMsg to sMessage
94716>>>        End
94716>>>>
94716>>>
94716>>>        // Make it optional to pass a second argument
94716>>>        If (num_arguments > 1) Begin
94718>>>            Move sMsg2 to sMessage2
94719>>>        End
94719>>>>
94719>>>
94719>>>        Move 0 to iSize
94720>>>        // Make it optional to pass a third argument
94720>>>        If (num_arguments > 2) Begin
94722>>>            Move iSze to iSize
94723>>>        End                   
94723>>>>
94723>>>        If (iSize = -1) Begin
94725>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
94726>>>        End
94726>>>>
94726>>>        If (iSize <> 0) Begin
94728>>>            Set Progress_Bar_Visible_State of ghoStatusPanel to True
94729>>>            Set piMaximum                  of ghoStatusPanel to iSize 
94730>>>            Set piAdvanceBy                of ghoStatusPanel to 1
94731>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to True
94732>>>        End
94732>>>>
94732>>>//        Else Begin
94732>>>//            Set Progress_Bar_Visible_State of ghoStatusPanel to False
94732>>>//        End
94732>>>//
94732>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94733>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) sMessage sMessage2
94734>>>        Send Start_StatusPanel of ghoStatusPanel
94735>>>    End_Procedure
94736>>>    
94736>>>    Procedure StopStatusPanel
94738>>>        Send Stop_StatusPanel of ghoStatusPanel
94739>>>    End_Procedure
94740>>>    
94740>>>    // This event is triggered by the cDbUpdateVersion child class when
94740>>>    // a database change is to be started, and is considered private.
94740>>>    // It is only executed once for the first cDbUpateVersion object!
94740>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94742>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94742>>>        Integer iRetval iDataFlexUsers iUserCount
94742>>>        Handle hoUserCountSystem
94742>>>        tUserCount UserCount
94742>>>        tUserCount UserCount
94742>>>        DateTime dtUpdateStarted
94742>>>        tSQLConnection SQLConnection
94742>>>        tSQLConnection SQLConnection
94742>>>
94742>>>        // *Important:* If we already started the update; we do no further checking.
94742>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94743>>>        If (bDatabaseUpdateStarted = True) Begin
94745>>>            Procedure_Return
94746>>>        End
94746>>>>
94746>>>
94746>>>        // If not silent mode; Ask user if OK to start database update.
94746>>>        If (pbSilentMode(Self) = False) Begin
94748>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94749>>>            If (iRetval <> MBR_Yes) Begin
94751>>>                Send Exit_Application
94752>>>            End
94752>>>>
94752>>>        End
94752>>>>
94752>>>        
94752>>>        Send StartStatusPanel "" "" 1
94753>>>        // This will save the status of all open tables including Master/Alias settings,
94753>>>        // so we can restore them later;
94753>>>        Send SaveOpenTables
94754>>>
94754>>>        Move 0 to iDataFlexUsers
94755>>>        // Make various tests to check that the database is not in use.
94755>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94756>>>        // We also use our own user counting mechanism to guard against the
94756>>>        // database isn't opened already as we need exclusive access to the tables.:
94756>>>        Get phoUserCountSystem to hoUserCountSystem
94757>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94758>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94759>>>
94759>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94760>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94760>>>        If (bCheckDataFlexUserCount = True) Begin
94762>>>            Get_Current_User_Count to iDataFlexUsers
94763>>>            // For some reason DataFlex - in some cases - might think that 2 users
94763>>>            // are in use while debugging from the Studio.
94763>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94765>>>                Decrement iDataFlexUsers
94766>>>            End
94766>>>>
94766>>>        End 
94766>>>>
94766>>>        Else Begin
94767>>>            Move 1 to iDataFlexUsers 
94768>>>            Move 1 to iUserCount
94769>>>            Move False to bInUse
94770>>>        End
94770>>>>
94770>>>
94770>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94772>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94773>>>            If (iRetval <> MBR_Yes) Begin
94775>>>                Send Exit_Application
94776>>>            End
94776>>>>
94776>>>        End
94776>>>>
94776>>>
94776>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94778>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94779>>>            Send Exit_Application
94780>>>        End
94780>>>>
94780>>>
94780>>>        // This will put a look on the DbUpdateLock.ucf file.
94780>>>        // It is released when the update process is finished
94780>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94781>>>
94781>>>        Move (CurrentDateTime()) to dtUpdateStarted
94782>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94783>>>        Set Private.pbDatabaseUpdateStarted to True
94784>>>
94784>>>        // We need to close all tables before starting to make changes.
94784>>>        Close DF_ALL DF_PERMANENT
94785>>>
94785>>>        // If these properties has not exclicitly been set in the object, set them
94785>>>        // to settings from the SQLConnections.ini file;
94785>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94786>>>        If (psSchema(Self) = "") Begin
94788>>>            Set psSchema            to SQLConnection.sSchema
94789>>>        End
94789>>>>
94789>>>        If (psBaseTableSpace(Self) = "") Begin
94791>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94792>>>        End
94792>>>>
94792>>>        If (psLongTableSpace(Self) = "") Begin
94794>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94795>>>        End
94795>>>>
94795>>>        If (psIndexTableSpace(Self) = "") Begin
94797>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94798>>>        End
94798>>>>
94798>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94800>>>            Procedure_Return
94801>>>        End
94801>>>>
94801>>>
94801>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94802>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94804>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94805>>>            Send StopStatusPanel
94806>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94806>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94807>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94807>>>            Send Exit_Application
94808>>>        End
94808>>>>
94808>>>    End_Procedure
94809>>>
94809>>>    // *** Hook message for pre-processing ***
94809>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94809>>>    // Aka, when another table than the standard "DbVersion" is used.
94809>>>    Procedure OnCreateCustomDbVersionTable
94811>>>    End_Procedure
94812>>>    
94812>>>    // *** Hook message for pre-processing ***
94812>>>    // The programmer can use this event for putting code that
94812>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94812>>>    // child objects are executed.
94812>>>    Procedure OnPreUpdate
94814>>>    End_Procedure
94815>>>
94815>>>    // *** Hook message for post-processing ***
94815>>>    // The programmer should use this event for putting code that
94815>>>    // needs to be executed _after_ all database updates have finished.
94815>>>    Procedure OnPostUpdate
94817>>>    End_Procedure
94818>>>
94818>>>    // *** Hook message for custom DbVersion record find ***
94818>>>    // The programmer can use this event for putting code that
94818>>>    // needs to be executed to find a *custom* DbVersion table record.
94818>>>    // By default the DbVersion table is used but this can be
94818>>>    // customized by adding this line to the code;
94818>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94818>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94818>>>    //       to save the current database version to. Only if you use your own
94818>>>    //       table _and_ it is not a system table (contains only one record).
94818>>>    Procedure OnFindVersionRecord
94820>>>        // Open MyTable
94820>>>        // Move xx to MyTable.Field1
94820>>>        // Move yy to MyTable.Field2
94820>>>        // Find le MyTable by Index.x
94820>>>    End_Procedure
94821>>>
94821>>>    // Hook event for writing header error text (pre-update) to
94821>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94821>>>    // Don't forget to Open the table first (!) as all
94821>>>    // tables have been closed at this stage.
94821>>>    // The start date & time is passed.
94821>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94823>>>    End_Procedure
94824>>>
94824>>>    // Hook event to log errors to a database table.
94824>>>    // Only called if the pbUseDataTableLog = True.
94824>>>    // Don't forget to Open the table first (!) as all
94824>>>    // tables have been closed at this stage.
94824>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94824>>>    // will contain just one row, as it is called for each error
94824>>>    // that occurred. Else it is called once at the end after all updates
94824>>>    // have run and contains all errors.
94824>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94826>>>    End_Procedure
94827>>>
94827>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94827>>>    Procedure Cleanup
94829>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
94829>>>        String sErrorText
94829>>>        
94829>>>        Move "" to sErrorText
94830>>>        Send CheckAutoCreateDbVersionTable
94831>>>        Send RestoreOpenTables
94832>>>
94832>>>        // The function library have two purposes; one is to use it in the
94832>>>        // Database Update Framework, but it can also be used on its own.
94832>>>        // If that is the case it has its own error handling system, which
94832>>>        // we temporarily disbled when running updates because we have
94832>>>        // error handling/logging here too... We now restore its setting.
94832>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94834>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94835>>>        End
94835>>>>
94835>>>        Set pbHandleQueryErrors to True
94836>>>
94836>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94837>>>        Get pbDbUpdateErrorHasOccured to bError
94838>>>        // Note: We make backup of .int files even if an error occured.
94838>>>        If (bDatabaseWasUpdated = True) Begin
94840>>>            // Check/create/update *.int files backup table:
94840>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
94841>>>            If (bUseIntFilesBackup = True) Begin
94843>>>                Get SaveUpdateIntFiles (&sErrorText) to bOK
94844>>>                If (bOK = False) Begin
94846>>>                    Send LogError sErrorText True
94847>>>                End
94847>>>>
94847>>>                Else If (sErrorText <> "") Begin
94850>>>                    Send LogError sErrorText False
94851>>>                End
94851>>>>
94851>>>            End
94851>>>>
94851>>>        End            
94851>>>>
94851>>>            
94851>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94853>>>
94853>>>            // We should always create the log as it also contains info about
94853>>>            // the update being successful.
94853>>>            Send WriteErrorLog of (phoLogFile(Self))
94854>>>
94854>>>            // This is a programmer's hook message:
94854>>>            Send OnPostUpdate
94855>>>
94855>>>            Send StopStatusPanel
94856>>>            If (pbSilentMode(Self) = False) Begin
94858>>>                If (bError = True) Begin
94860>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94862>>>                        Send ShowErrorLog of (phoLogFile(Self))
94863>>>                    End
94863>>>>
94863>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94864>>>                    Send Exit_Application
94865>>>                End
94865>>>>
94865>>>                Else Begin
94866>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94868>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94869>>>                    End
94869>>>>
94869>>>                    Else Begin
94870>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94871>>>                    End
94871>>>>
94871>>>                End
94871>>>>
94871>>>            End
94871>>>>
94871>>>        End
94871>>>>
94871>>>
94871>>>        // Restore the standard error handler:
94871>>>        Get piOrgErrorHandlerID to Error_Object_Id
94872>>>    End_Procedure
94873>>>
94873>>>    // We do this _before_ we close the database to make changes, and save
94873>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94873>>>    // we reopen the database.
94873>>>    Procedure SaveOpenTables
94875>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94875>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94876>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94877>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94878>>>    End_Procedure
94879>>>
94879>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94879>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94879>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94881>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94881>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94882>>>        Integer hTable iMasterAliasType iSize
94882>>>        Boolean bOpen
94882>>>
94882>>>        Move 0 to hTable
94883>>>        Repeat
94883>>>>
94883>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94886>>>            If (hTable <> 0) Begin
94888>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94891>>>                If (bOpen = True) Begin
94893>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94896>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94897>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94898>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94899>>>                End
94899>>>>
94899>>>            End
94899>>>>
94899>>>        Until (hTable = 0)
94901>>>
94901>>>        Function_Return aDbUpdateHandlerMasterAlias
94902>>>    End_Function
94903>>>
94903>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94903>>>    // Takes one parameter:
94903>>>    //   A struct array with all master & alias
94903>>>    Procedure RestoreOpenTables
94905>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94905>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94906>>>        Integer hTable iFileAlias iSize iCount
94906>>>        Boolean bOpen
94906>>>        String sRootName
94906>>>
94906>>>        Move 0 to hTable
94907>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94908>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94909>>>        Decrement iSize
94910>>>        For iCount from 0 to iSize
94916>>>>
94916>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94917>>>            // We also need to check that the table hasn't been removed...
94917>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94920>>>            If (hTable <> 0 and sRootName <> "") Begin
94922>>>                Open hTable
94924>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94927>>>                If (bOpen = True) Begin
94929>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94930>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94932>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94935>>>                    End
94935>>>>
94935>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94938>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94941>>>                    End
94941>>>>
94941>>>                End
94941>>>>
94941>>>            End
94941>>>>
94941>>>        Loop
94942>>>>
94942>>>    End_Procedure
94943>>>
94943>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94943>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94943>>>    Procedure CheckForDuplicates Number nVersion
94945>>>        tDbVersionInfo[] DbVersionInfoArray
94945>>>        tDbVersionInfo[] DbVersionInfoArray
94946>>>        Integer iCount iSize iHits iDuplicateIndex
94946>>>        Number nCompare
94946>>>        Handle hObject1 hObject2
94946>>>        String sObjectName1 sObjectName2
94946>>>        Boolean bObjectOrderError
94946>>>
94946>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94947>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94948>>>        Decrement iSize
94949>>>        Move 0 to iHits
94950>>>        Move 0 to nCompare
94951>>>        Move False to bObjectOrderError
94952>>>        For iCount from 0 to iSize
94958>>>>
94958>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94960>>>                Increment iHits
94961>>>                If (iHits > 1) Begin
94963>>>                    Move iCount to iDuplicateIndex
94964>>>                    If (nCompare <> 0) Begin
94966>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94967>>>                    End
94967>>>>
94967>>>                End
94967>>>>
94967>>>            End
94967>>>>
94967>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94968>>>        Loop
94969>>>>
94969>>>        If (iHits > 1) Begin
94971>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94972>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94973>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94974>>>            Move (Name(hObject1)) to sObjectName1
94975>>>            Move (Name(hObject2)) to sObjectName2
94976>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94977>>>>
94977>>>            Send Exit_Application
94978>>>        End
94978>>>>
94978>>>        Else If (bObjectOrderError = True) Begin
94981>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94982>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94983>>>>
94983>>>            Send Exit_Application
94984>>>        End
94984>>>>
94984>>>    End_Procedure
94985>>>
94985>>>    // We take care of all errors in the Error_Report below and
94985>>>    // collect them all to an array property. So just ignore any
94985>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94985>>>    // in some other package.
94985>>>    Procedure Ignore_Error Integer iError
94987>>>    End_Procedure
94988>>>
94988>>>    Procedure Trap_Error Integer iError
94990>>>    End_Procedure
94991>>>
94991>>>    // Build complete error description from Flexerrs and user error message.
94991>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94993>>>        String Full_Error_Text
94993>>>        
94993>>>        Move (Trim(ErrMsg)) to ErrMsg
94994>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94995>>>        
94995>>>        If (ErrMsg <> "") Begin
94997>>>            
94997>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94999>>>                // Make sure last character of error text is a separating symbol.
94999>>>                // if not, add a "." So we have format of "error-text. error-detail"
94999>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95002>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95003>>>            End
95003>>>>
95003>>>            Else ;                Move ErrMsg to Full_Error_Text
95005>>>            
95005>>>        End
95005>>>>
95005>>>        
95005>>>        Function_Return Full_Error_Text
95006>>>    End_Function
95007>>>
95007>>>    // While we update the database we collect all errors in
95007>>>    // the struct array paDbUpdateErrorArray.
95007>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95009>>>        Number nVersion
95009>>>        Handle hoLogFile 
95009>>>        
95009>>>        If (Private.pbProcessingError(Self)) Begin
95011>>>            Procedure_Return
95012>>>        End
95012>>>>
95012>>>
95012>>>        // The UtilTableNameFromHandleToString function does a:
95012>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95012>>>        // and it generates an error if the table is of the embedded type.
95012>>>        // As we don't want to trigger an error in that very specific case,
95012>>>        // we just ignore it here.
95012>>>        //
95012>>>        // If no report mode, just set the err indicator to false.
95012>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95014>>>            Set Private.pbProcessingError to False
95015>>>            Procedure_Return
95016>>>        End
95016>>>>
95016>>>
95016>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95018>>>            Set Private.pbProcessingError to False
95019>>>            Procedure_Return
95020>>>        End
95020>>>>
95020>>>
95020>>>        Set Private.pbProcessingError to True
95021>>>        Set Private.pbUpdateVersionObjectError to True
95022>>>
95022>>>        Set pbDbUpdateErrorHasOccured to True
95023>>>        Get pnCurrentVersionUpdate to nVersion
95024>>>        Get phoLogFile to hoLogFile
95025>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95026>>>
95026>>>        Set Private.pbProcessingError to False
95027>>>    End_Procedure
95028>>>
95028>>>End_Class
95029>
95029>Object oHtmlHelp is a cHtmlHelp
95031>    Set pbAlwaysOnTop to False
95032>
95032>    // Overriden class message to also handle internet HTML Help links;
95032>    // which in which case we should not try to find the path to the help file.
95032>    Function GetHelpFile Returns String
95035>        String sHelpFile
95035>
95035>        Get psHelpFile of ghoApplication to sHelpFile
95036>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95038>            Get_File_Path sHelpFile to sHelpFile
95039>        End
95039>        Function_Return sHelpFile
95040>    End_Function
95041>
95041>End_Object
95042>
95042>Object oApplication is a cApplication
95044>    Set peHelpType to htHtmlHelp
95045>
95045>    // Note: These help file settings gets changed by the Help toolbar button(s).
95045>    Set psHelpFile to "Developer5.chm"
95046>
95046>    Set pbPreserveEnvironment to True
95047>    Set psProduct to "Database Update Framework Lab"
95048>    Set psCompany to "RDC Tools International" 
95049>
95049>    Object oConnection is a cConnection
95051>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
95051>>>Use cLoginEncryption.pkg
95051>>>
95051>>>Object oLoginEncryption is a cLoginEncryption
95053>>>
95053>>>    // this must be created in your appsrc directory and must contain an encryption
95053>>>    // key that is set to psEncryptPassword. It will look something like this
95053>>>    //
95053>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95053>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95053>>>>// Studio generated login encryption key
95053>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95054>>>>
95054>>>    
95054>>>    // use this to register this object to your cConnection Object. This object
95054>>>    // must be created after the cConnection object
95054>>>    Move Self to ghoLoginEncryption
95055>>>End_Object
95056>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
95056>>>
95056>>>Use Windows.pkg
95056>>>Use cConnection.pkg
95056>>>Use dfLine.pkg
95056>>>
95056>>>Object oDatabaseLoginDialog is a ModalPanel
95058>>>    Set Label to "Database Login"
95059>>>    Set Location to 2 2
95060>>>    Set Size to 110 211
95061>>>    
95061>>>    Property String psId
95063>>>    Property Boolean pbOk False
95065>>>    Property Boolean pbChanged False
95067>>>    Property Boolean pbAllowRemember True
95069>>>    
95069>>>    // this registers this object with the cConnection object.
95069>>>    Move Self to ghoLoginConnectDialog
95070>>>    
95070>>>    Object oUserIDForm is a Form
95072>>>        Set Label to "User Name"
95073>>>        Set Size to 12 85
95074>>>        Set Location to 34 79
95075>>>        Set Label_Col_Offset to 64
95076>>>        Set peAnchors to anTopLeftRight
95077>>>    End_Object
95078>>>    
95078>>>    Object oPwdForm is a Form
95080>>>        Set Size to 12 85
95081>>>        Set Location to 49 79
95082>>>        Set Label_Col_Offset to 64
95083>>>        Set Password_State to True
95084>>>        Set peAnchors to anTopLeftRight
95085>>>        Set Label to "Password"
95086>>>    End_Object
95087>>>    
95087>>>    Object oTrustedConnection is a CheckBox
95089>>>        Set Size to 10 50
95090>>>        Set Location to 65 79
95091>>>        Set Label to "Trusted Connection"
95092>>>    End_Object
95093>>>    
95093>>>    Object oRemember is a CheckBox
95095>>>        Set Size to 10 50
95096>>>        Set Location to 79 14
95097>>>        Set Label to "Remember and don't ask again"
95098>>>        Set Checked_State to True
95099>>>    End_Object
95100>>>    
95100>>>    Object oLogin_btn is a Button
95102>>>        Set Label to "&Login"
95103>>>        Set Location to 92 102
95104>>>        Set peAnchors to anBottomRight
95105>>>        Set Default_State to True
95106>>>        
95106>>>        Procedure OnClick
95109>>>            Boolean bTrust
95109>>>            String sUser sPwd sConn sErr sId
95109>>>            Integer iError
95109>>>            Get psId to sId
95110>>>            Get Value of oUserIDForm to sUser
95111>>>            Get Value of oPwdForm to sPwd
95112>>>            Get Checked_State of oTrustedConnection to bTrust
95113>>>            
95113>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95114>>>            If (iError=0) Begin
95116>>>                Set pbOk to True
95117>>>                Set pbChanged to True
95118>>>                Send Close_Panel
95119>>>            End
95119>>>>
95119>>>            Else Begin
95120>>>                Get psErrorText of ghoConnection to sErr
95121>>>                Send UserError sErr "Login Error"
95122>>>            End
95122>>>>
95122>>>        End_Procedure
95123>>>    End_Object
95124>>>    
95124>>>    Object oCancel_btn is a Button
95126>>>        Set Label to "&Cancel"
95127>>>        Set Location to 92 157
95128>>>        Set peAnchors to anBottomRight
95129>>>        
95129>>>        Procedure OnClick
95132>>>            Send Close_Panel
95133>>>        End_Procedure
95134>>>    End_Object
95135>>>    
95135>>>    Object oConnectionIdInfo is a TextBox
95137>>>        Set Size to 10 50
95138>>>        Set Location to 4 14
95139>>>        Set Label to 'Connection Id='
95140>>>    End_Object
95141>>>    
95141>>>    Object oConnectionServerInfo is a TextBox
95143>>>        Set Size to 10 50
95144>>>        Set Location to 16 14
95145>>>        Set Label to 'Server'
95146>>>    End_Object
95147>>>    
95147>>>    Object oLineControl1 is a LineControl
95149>>>        Set Size to 2 202
95150>>>        Set Location to 29 5
95151>>>    End_Object
95152>>>    
95152>>>    Function LoginConnectIdDialog String sId Returns Boolean
95155>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95155>>>        String sUser sPwd sDescription
95155>>>        tConnection Connect
95155>>>        tConnection Connect
95155>>>        
95155>>>        Get pbAllowRemember to bAllowRemember
95156>>>        
95156>>>        
95156>>>        If not bAllowRemember Begin
95158>>>            Set Enabled_State of oRemember to bRemember
95159>>>            Set Visible_State of oRemember to bRemember
95160>>>        End
95160>>>>
95160>>>        
95160>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95161>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95162>>>        Set Value of oConnectionServerInfo to Connect.sString
95163>>>        
95163>>>        Set psId to sId
95164>>>        Set pbOk to False
95165>>>        Set pbChanged to False
95166>>>        Set Value of oUserIDForm to Connect.sUID
95167>>>        Set Value of oPwdForm to ""
95168>>>        
95168>>>        Send Popup
95169>>>        
95169>>>        Get pbOk to bOk
95170>>>        Get pbChanged to bChanged
95171>>>        If (bChanged and bOk) Begin
95173>>>            If bAllowRemember Begin
95175>>>                Get Checked_State of oRemember to bRemember
95176>>>                If bRemember Begin
95178>>>                    Get Checked_State of oTrustedConnection to bTrusted
95179>>>                    If not (bTrusted) Begin
95181>>>                        Get Value of oUserIDForm to sUser
95182>>>                        Get Value of oPwdForm to sPwd
95183>>>                    End
95183>>>>
95183>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95184>>>                End
95184>>>>
95184>>>            End
95184>>>>
95184>>>        End
95184>>>>
95184>>>        Function_Return bOk
95185>>>    End_Function
95186>>>    
95186>>>    
95186>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95187>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95188>>>End_Object
95189>>>
95189>    End_Object
95190>
95190>End_Object   
95191>
95191>Object oDbUpdateHandler is a cDbUpdateHandler 
95193>    Set piDbVersionFileNumber to 255
95194>    Set piDbVersionFieldNumber to 1
95195>    
95195>End_Object
95196>
95196>Object oCJSkinFramework is a cCJSkinFramework
95198>    Set pbLoadPreference to True
95199>End_Object
95200>
95200>Object oToolTipController is a cToolTipController
95202>    Set piDurationPopup to 10000
95203>    Set piMaxWidth to 500
95204>    Move Self to ghoToolTipController
95205>End_Object
95206>
95206>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95206>>>Use cCJStandardMenuItemClasses.pkg
95206>>>
95206>>>Object oEditContextMenu is a cCJContextMenu
95208>>>    
95208>>>    Move Self to Default_Form_Floating_Menu_ID
95209>>>    
95209>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95211>>>    End_Object
95212>>>    
95212>>>    Object oCutMenuItem is a cCJCutMenuItem
95214>>>        Set pbControlBeginGroup to True
95215>>>    End_Object
95216>>>    
95216>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95218>>>    End_Object
95219>>>
95219>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95221>>>    End_Object
95222>>>
95222>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95224>>>    End_Object
95225>>>
95225>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95227>>>        Set pbControlBeginGroup to True
95228>>>    End_Object
95229>>>
95229>>>End_Object
95230>>>
95230>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95230>>>Use Windows.pkg
95230>>>Use cCJStandardMenuItemClasses.pkg
95230>>>Use cCJDeoMenuItemClasses.pkg
95230>>>
95230>>>
95230>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95232>>>    
95232>>>    Move Self to Default_dbFloating_Menu_ID
95233>>>    
95233>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95235>>>    End_Object
95236>>>    
95236>>>    Object oCutMenuItem is a cCJCutMenuItem
95238>>>        Set pbControlBeginGroup to True
95239>>>    End_Object
95240>>>    
95240>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95242>>>    End_Object
95243>>>
95243>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95245>>>    End_Object
95246>>>
95246>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95248>>>    End_Object
95249>>>
95249>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95251>>>        Set pbControlBeginGroup to True
95252>>>    End_Object
95253>>>
95253>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95255>>>        Set pbControlBeginGroup to True
95256>>>    End_Object
95257>>>
95257>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95259>>>        Set pbControlBeginGroup to True
95260>>>    End_Object
95261>>>
95261>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95263>>>    End_Object
95264>>>
95264>>>    Object oClearMenuItem is a cCJClearMenuItem
95266>>>        Set pbControlBeginGroup to True
95267>>>    End_Object
95268>>>
95268>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95270>>>    End_Object
95271>>>
95271>>>    Object oSaveMenu is a cCJSaveMenuItem
95273>>>    End_Object
95274>>>    
95274>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95276>>>    End_Object
95277>>>
95277>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95279>>>        Set pbControlBeginGroup to True
95280>>>    End_Object
95281>>>
95281>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95283>>>    End_Object
95284>>>
95284>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95286>>>    End_Object
95287>>>
95287>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95289>>>    End_Object
95290>>>
95290>>>End_Object
95291>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95291>>>Use cCJCommandBarSystem.pkg
95291>>>Use Wingdi.pkg
95291>>>Use LanguageText.pkg
95291>>>
95291>>>// User interface constant strings:
95291>>>Define CS_NoSkinShort For "-None"
95291>>>Define CS_NoSkinLong  For "Do not use a skin"
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>
95291>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95292>>>
95292>>>    Procedure Construct_Object
95294>>>        Forward Send Construct_Object
95296>>>
95296>>>        Set peControlType to xtpControlComboBox
95297>>>
95297>>>        Property tSkinInformation[] pSkins
95298>>>
95298>>>    End_Procedure
95299>>>
95299>>>    Procedure End_Construct_Object
95301>>>        Forward Send End_Construct_Object
95303>>>    End_Procedure
95304>>>
95304>>>    // Custom array sort for the tSkinInformation struct array.
95304>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95304>>>    // Why?
95304>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95304>>>    // create a custom sort algorithm.
95304>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95304>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95304>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95304>>>    // randomly ordered. This custom sort method will take care of that.
95304>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95306>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95308>>>            Function_Return (GT)
95309>>>        End
95309>>>>
95309>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95311>>>            Function_Return (LT)
95312>>>        End
95312>>>>
95312>>>        Function_Return (EQ)
95313>>>    End_Function
95314>>>
95314>>>    Procedure OnCreateControl Handle hoObj
95316>>>        Forward Send OnCreateControl hoObj
95318>>>
95318>>>        Send LoadSkins
95319>>>        Send FillComboList hoObj
95320>>>    End_Procedure
95321>>>
95321>>>    // Load all skins. We will only look for skins in expected
95321>>>    // directory which is the Programs folder.
95321>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95321>>>    // This is not the case with the 'standard' VDF behaviour.
95321>>>    Procedure LoadSkins
95323>>>        Integer iCount iItems iSize
95323>>>        Boolean bFound
95323>>>        String sFile sIni sSkin
95323>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95323>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95325>>>        tSkinInformation NoneRow
95325>>>        tSkinInformation NoneRow
95325>>>
95325>>>        If (ghoSkinFramework > 0) Begin
95327>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95328>>>
95328>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95329>>>            Move CS_NoSkinShort to NoneRow.sName
95330>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95331>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95332>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95333>>>
95333>>>            // Get the currently loaded skin.
95333>>>            Get psSkinFile of ghoSkinFramework to sFile
95334>>>            Get psSkinIni  of ghoSkinFramework to sIni
95335>>>
95335>>>            // Remove all Extra Large and Large skins from the array.
95335>>>            Move (SizeOfArray(SkinsArray)) to iItems
95336>>>            Decrement iItems
95337>>>            For iCount From 0 to iItems
95343>>>>
95343>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95344>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95345>>>                If (bFound = False) Begin
95347>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95348>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95349>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95350>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95351>>>                End
95351>>>>
95351>>>            Loop
95352>>>>
95352>>>            Set pSkins to SkinsArrayNoLarge
95353>>>        End
95353>>>>
95353>>>    End_Procedure
95354>>>
95354>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95354>>>    Procedure FillComboList Handle hoCombo
95356>>>        Integer iCount iItems iCurrent iTxtEntentSize
95356>>>        String  sFile sIni sCurrSkin
95356>>>        String  sSkin sSkinText
95356>>>        tSkinInformation[] SkinsArray
95356>>>        tSkinInformation[] SkinsArray
95357>>>        Integer iSize
95357>>>
95357>>>        If (ghoSkinFramework < 1) Begin
95359>>>            Procedure_Return
95360>>>        End
95360>>>>
95360>>>
95360>>>        // Get the currently loaded skin.
95360>>>        Get psSkinFile of ghoSkinFramework to sFile
95361>>>        Get psSkinIni  of ghoSkinFramework to sIni
95362>>>        Get pSkins to SkinsArray
95363>>>        Move (SizeOfArray(SkinsArray)) to iItems
95364>>>        Decrement iItems
95365>>>        Send ComClear of hoCombo
95366>>>
95366>>>        For iCount From 0 to iItems
95372>>>>
95372>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95373>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95374>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95375>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95376>>>            Get Text_Extent sSkinText to iSize
95377>>>            If (iSize > iTxtEntentSize) Begin
95379>>>                Move iSize to iTxtEntentSize
95380>>>            End
95380>>>>
95380>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95381>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95383>>>                Move iCount to iCurrent
95384>>>            End
95384>>>>
95384>>>        Loop
95385>>>>
95385>>>
95385>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95386>>>        Set ComDropDownWidth of hoCombo  to iSize
95387>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95388>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95389>>>    End_Procedure
95390>>>
95390>>>    // Event for when an item is selected from the comboform
95390>>>    Procedure OnExecute Variant vCommandBarControl
95392>>>        Handle  hoCombo
95392>>>        Integer iSelection
95392>>>        String  sSkinFile sSkinIni
95392>>>        tSkinInformation[] SkinsArray
95392>>>        tSkinInformation[] SkinsArray
95393>>>
95393>>>        // Create and bind proxy control
95393>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95394>>>        // Get the current selection
95394>>>        Get ComListIndex of hoCombo to iSelection
95395>>>        Decrement iSelection
95396>>>        Get pSkins to SkinsArray
95397>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95398>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95399>>>
95399>>>        Send DoChangeSkin sSkinFile sSkinIni
95400>>>
95400>>>        // Dispose of the proxy control
95400>>>        Send Destroy of hoCombo
95401>>>    End_Procedure
95402>>>
95402>>>    // Send this message to change the current skin.
95402>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95404>>>        Handle hoClient
95404>>>
95404>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95405>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95406>>>        Send ApplySkin of ghoSkinFramework
95407>>>
95407>>>        // Note: The following line is essential for the resizing logic
95407>>>        // to function properly when changing a skin and a view is maximized.
95407>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95408>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95409>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95410>>>    End_Procedure
95411>>>
95411>>>    // Returns: DPI setting as an integer.
95411>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95411>>>    //                      iDPI=120 is "Medium setting" 125%
95411>>>    //                      iDPI= 144 is "Large setting" 150%
95411>>>    Function GetCurrentDPI Returns Integer
95413>>>        Handle hDC
95413>>>        Integer iPixelsX
95413>>>        Move (GetDC(0)) to hDC
95414>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95415>>>        Move (ReleaseDC(0, hDC)) to hDC
95416>>>        Function_Return iPixelsX
95417>>>    End_Function
95418>>>
95418>>>End_Class
95419>
95419>Object oMain is a Panel
95421>    Set Label to "Test Program - The Database Update Framework"
95422>    Set Location to 2 2
95423>    Set Size to 309 493
95424>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95425>    Set Icon to "TestTools.ico"
95426>
95426>    Property Handle phoViewMenu 0
95428>    Property Handle phoReportMenu 0
95430>
95430>    Object oCommandBarSystem is a cCJCommandBarSystem
95432>        Set pbTimerUpdate to True
95433>            Set pbAutoResizeIcons to True
95434>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95435>            Set peVisualTheme to xtpThemeOffice2013Publisher
95436>            Set pbLargeIcons to True
95437>
95437>        Procedure OnCreateCommandBars
95440>            Handle hoOptions
95440>            Forward Send OnCreateCommandBars
95442>                Get OptionsObject to hoOptions
95443>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95444>        End_Procedure
95445>
95445>
95445>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95448>        Set ComShowIcons of hoTabPaintManager to True
95449>
95449>        // This will truncate the middle part of long items
95449>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95450>    End_Procedure
95451>
95451>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95451>        // the previous tab workspace view.
95451>        Object oPreviousTabAction is a cCJAction
95453>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95454>            Procedure OnExecute Variant vCommandBarControl
95457>                Handle hoCommandBars hoClientArea
95457>                Forward Send OnExecute vCommandBarControl
95459>                Get CommandBarSystemObject to hoCommandBars
95460>                Get ClientAreaObject of hoCommandBars to hoClientArea
95461>                If hoClientArea Begin
95463>                    Send Switch_Next_View of hoClientArea
95464>                End
95464>            End_Procedure
95465>        End_Object
95466>
95466>        Object oToolBar is a cCJToolbar
95468>            Set psTitle to "Edit Toolbar"
95469>            Set pbGripper to False
95470>            Set peStretched to stStretch
95471>
95471>            Object oCutToolbarItem is a cCJCutMenuItem  
95473>                Set psImage to "ActionCut1.ico"
95474>            End_Object
95475>
95475>            Object oCopyToolbarItem is a cCJCopyMenuItem
95477>                Set psImage to "ActionCopy1.ico"
95478>            End_Object
95479>
95479>            Object oPasteToolbarItem is a cCJPasteMenuItem
95481>                Set psImage to "ActionPaste1.ico"
95482>            End_Object
95483>
95483>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95485>                Set psImage to "ActionDelete1.ico"
95486>                Set pbControlBeginGroup to True
95487>            End_Object
95488>
95488>            Object oTheme_tb is a cCJMenuItem
95490>                Set peControlType to xtpControlLabel
95491>                Set psCaption to "Theme:"
95492>                Set pbControlBeginGroup to True
95493>            End_Object
95494>
95494>            Object oThemeItem is a cCJMenuItem
95496>                Set peControlType to xtpControlComboBox
95497>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95498>
95498>                Procedure OnCreateControl Handle hoObj
95501>                    Integer iItem eTheme
95501>                    Set ComWidth of hoObj to 250
95502>                    Send FillComboList hoObj
95503>                    Get peVisualTheme to eTheme
95504>                    Get FindDataItem hoObj eTheme to iItem
95505>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95506>                End_Procedure
95507>
95507>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95510>                    Integer iCount i eTheme
95510>                    Get ComListCount of hoCombo to iCount
95511>                    For i from 1 to iCount
95517>                        Get ComItemData of hoCombo i to eTheme
95518>                        If (eTheme=eVal) Begin
95520>                            Send SetTheTheme eTheme
95521>                            Function_Return i
95522>                        End
95522>                    Loop
95523>                    Function_Return 0
95524>                End_Function
95525>
95525>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95528>                    Integer iCount
95528>                    Get ComListCount of hoCombo to iCount
95529>                    Increment iCount
95530>                    Send ComAddItem  of hoCombo sText iCount
95531>                    Set ComItemData  of hoCombo iCount to  eTheme
95532>                End_Procedure
95533>
95533>                Procedure FillComboList Handle hoCombo
95536>                    Send ComClear     of hoCombo
95537>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95538>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95539>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95540>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95541>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95542>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95543>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95544>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95545>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95546>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95547>    
95547>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95548>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95549>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95550>    
95550>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95551>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95552>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95553>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95554>    
95554>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95555>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95556>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95557>    
95557>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95558>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95559>    
95559>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95560>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95561>    
95561>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95562>    
95562>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95563>    
95563>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95564>                End_Procedure
95565>
95565>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95568>                    Handle hMessage hoCombo
95568>                    Integer iIndex
95568>                    // create and bind  proxy control
95568>                    Get CreateProxyControl vCommandBarControl to hoCombo
95569>                    // get the current selection
95569>                    Get ComListIndex of hoCombo to iIndex
95570>                    // note the index selections are 1 based
95570>                    If (iIndex > 0) Begin
95572>                        // get the ItemData for the selected item and send that message
95572>                        Get ComItemData of hoCombo iIndex to hMessage
95573>                        Function_Return hMessage
95574>                    End
95574>                    // dispose of the proxy control
95574>                    Send Destroy of hoCombo
95575>                    Function_Return 0
95576>                End_Function
95577>
95577>                Procedure OnExecute Variant vCommandBarControl
95580>                    Integer eTheme
95580>                    Integer iColor
95580>                    Get CurrentTheme vCommandBarControl to eTheme
95581>                    Set peVisualTheme of ghoCommandBars to eTheme
95582>                    Send ComRecalcLayout of ghoCommandBars
95583>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95584>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95586>                End_Procedure
95587>
95587>                Procedure SetTheTheme Integer eTheme
95590>                    Integer iColor
95590>                    Set peVisualTheme of ghoCommandBars to eTheme
95591>                    Send ComRecalcLayout of ghoCommandBars
95592>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95593>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95595>                End_Procedure
95596>
95596>                Function ConvertSystemColor Integer iColor Returns Integer
95599>                    Integer iSysColor
95599>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95601>                        Move clNone to iColor
95602>                    End
95602>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95605>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95606>                        Move (GetSysColor(iSysColor)) to iColor
95607>                    End
95607>                    Function_Return iColor
95608>                End_Function
95609>
95609>            End_Object
95610>
95610>            Object oAbout_MenuItem is a cCJMenuItem
95612>                Set psCaption to "About"
95613>                Set psToolTip to "About Info"
95614>                Set psDescription to "About the program"
95615>                Set psImage to "ActionAbout1.ico"
95616>                Set pbControlBeginGroup to True
95617>                Procedure OnExecute Variant vCommandBarControl
95620>                    Forward Send OnExecute vCommandBarControl
95622>                    Send Activate_About of (Client_Id(ghoCommandBars))
95623>                End_Procedure
95624>            End_Object
95625>
95625>            Object oHelpMenuItem is a cCJHelpMenuItem
95627>                Set peControlType to xtpControlSplitButtonPopup
95628>                Set psImage to "ActionHelp1.ico"
95629>
95629>                Procedure OnExecute Variant vCommandBarControl
95632>                    Forward Send OnExecute vCommandBarControl
95634>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95635>                    Send ShowProgramHelp
95636>                End_Procedure
95637>
95637>                Object oHelpMenuItemLocal is a cCJMenuItem
95639>                    Set psCaption to "Local HTML Help"
95640>                    Set psImage to "ActionHelp1.ico"
95641>                    Procedure OnExecute Variant vCommandBarControl
95644>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95645>                        Send ShowProgramHelp
95646>                    End_Procedure
95647>                End_Object
95648>
95648>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95650>                    Set psCaption to "Internet Online HTML Help"
95651>                    Set psImage to "ActionHelp1.ico"
95652>                    Procedure OnExecute Variant vCommandBarControl
95655>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95656>                    End_Procedure
95657>
95657>                End_Object
95658>            End_Object
95659>
95659>            Object oExitMenuItem is a cCJExitMenuItem
95661>                Set psImage to "ActionExit1.ico"
95662>                Set psToolTip to "Exit application"
95663>                Set psDescription to "Exit the program (Alt+F4)"
95664>                Set pbControlBeginGroup to True
95665>            End_Object
95666>        End_Object
95667>
95667>//        Object oSpacerBar is a cCJToolbar
95667>//            Set pbDockNextTo to False
95667>//            Set pbShowExpandButton to False
95667>//            Set pbGripper to False
95667>//            Set peStretched to stStretch
95667>//            Set pbCustomizable to False
95667>//            Set pbCloseable to False
95667>//            Set pbEnableDocking to False
95667>//            Set pbHideWrap to True
95667>//
95667>//            Object oFiller is a cCJMenuItem
95667>//            End_Object
95667>//
95667>//        End_Object
95667>
95667>        Object oStatusBar is a cCJStatusBar
95669>
95669>            Object oStatusPane1 is a cCJStatusBarPane
95671>                Set piID to sbpIDIdlePane
95672>                Set pbStyleStretch to True
95673>            End_Object
95674>            Object oStatusPane2 is a cCJStatusBarPane
95676>                Set phoViewPane to Self
95677>                Set pbStyleStretch to True
95678>            End_Object
95679>
95679>        End_Object
95680>
95680>    End_Object
95681>
95681>    Object oClientArea is a ClientArea
95683>
95683>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95683>
95683>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95683>>>//************************************************************************
95683>>>// Confidential Trade Secret.
95683>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95683>>>// as an unpublished work.  All rights reserved.
95683>>>// DataFlex is a registered trademark of Data Access Corporation.
95683>>>//
95683>>>//************************************************************************
95683>>>//************************************************************************
95683>>>//
95683>>>// $File name  : StdAbout.pkg
95683>>>// $File title : Standard about object package for VDF
95683>>>// Notice      :
95683>>>// $Author(s)  : John Tuohy
95683>>>//
95683>>>// $Rev History
95683>>>//
95683>>>// JT 06/27/97   File created
95683>>>//************************************************************************
95683>>>
95683>>>// This provides a quick and simple way to create an about package for a program.
95683>>>// You need to create a message inside you client area called Activate_About.
95683>>>// Within this message you should send the message DoAbout passing needed
95683>>>// string information.
95683>>>//
95683>>>//       Procedure Activate_About
95683>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95683>>>//       End_Procedure
95683>>>//    where: sTitle =     Name of application. If none provided, uses caption
95683>>>//                        bar title
95683>>>//           sVersion   = Version Line. If none provided, will be blank
95683>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95683>>>//           sAuthor    = Author name, blank if none provided
95683>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95683>>>//                        is used.
95683>>>// It is expected that you will place this in your own object package. For
95683>>>// example an order about package may look like this:
95683>>>//
95683>>>//   // OrderAbout.pkg
95683>>>//   Use StdAbout.pkg
95683>>>//   Procedure Activate_About
95683>>>//      String sTitle sCopyright sVersion sAuthor
95683>>>//      Move "My Order Entry System" to sTitle
95683>>>//      Move "Version 2.1" to sVersion
95683>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95683>>>//      Move "John Smith"  to sAuthor
95683>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95683>>>//   end_procedure
95683>>>//   // end of file.
95683>>>
95683>>>Use DfAbout.pkg
95683>>>
95683>>>// *************************************************************************
95683>>>//  Public message. This is the default message. It is expected that you will
95683>>>//   create your own message to override this
95683>>>// *************************************************************************
95683>>>
95683>>>Procedure Activate_About
95686>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95687>>>End_Procedure
95688>>>
95688>>>// *************************************************************************
95688>>>//  Public message. It is expected that you will send this message (most
95688>>>//  likely from Activate_About. This creates an about object, activates it
95688>>>//  and destroys it when done. It is not exepected that you will augment this.
95688>>>// *************************************************************************
95688>>>// Sample usage:
95688>>>//   The first two params will automatically be filled from the application settings if not provided.
95688>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95688>>>
95688>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95691>>>    Integer hoObj hoMain iArgs
95691>>>    String sValue
95691>>>
95691>>>    // Create object
95691>>>    Object About is an AboutDialog
95693>>>    // Uncomment these two lines if you would like to have a resizable About object.
95693>>>    //            Set Border_Style to Border_Thick
95693>>>    //            Set peAnchors to anAll
95693>>>
95693>>>    // Add checking for the number of arguments passed to avoid runtime errors
95693>>>    // if one of them is not passed. This makes the interface
95693>>>    // more flexible.
95693>>>        Move num_arguments to iArgs
95694>>>
95694>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95694>>>        If (iArgs > 0 and sTitle = "") Begin
95696>>>            Get Main_Window of Desktop to hoMain
95697>>>            If hoMain Begin
95699>>>                Get Label of hoMain to sValue
95700>>>            End
95700>>>>
95700>>>        End
95700>>>>
95700>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95703>>>            Move sTitle to sValue
95704>>>        End
95704>>>>
95704>>>        Else If (iArgs = 0) Begin
95707>>>            Get Main_Window of Desktop to hoMain
95708>>>            If hoMain Begin
95710>>>                Get Label of hoMain to sValue
95711>>>            End
95711>>>>
95711>>>        End
95711>>>>
95711>>>
95711>>>        If (sValue <> "") Begin
95713>>>            Send Add_LineLn sValue
95714>>>        End
95714>>>>
95714>>>        Move "" to sValue
95715>>>
95715>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95715>>>        // For this to work the Project Properties Version must have been set in the Studio.
95715>>>        If (iArgs < 2) Begin
95717>>>            Move "" to sValue
95718>>>        End
95718>>>>
95718>>>        Else Begin
95719>>>            Move sVersion to sValue
95720>>>        End
95720>>>>
95720>>>        Set Version to sValue
95721>>>
95721>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95723>>>            Send Add_LineLn sCopyRight
95724>>>        End
95724>>>>
95724>>>
95724>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95724>>>        // else we do.
95724>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95726>>>            Send Add_Line sAuthor
95727>>>        End
95727>>>>
95727>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95730>>>            Send Add_LineLn sAuthor
95731>>>        End
95731>>>>
95731>>>
95731>>>        // Square bitmaps of 80x80 works best
95731>>>        If (iArgs > 4 and sBitmap <> "") Begin
95733>>>            Set Logo to sBitMap
95734>>>        End
95734>>>>
95734>>>
95734>>>        // Here starts handling of the five optional params:
95734>>>        If (iArgs = 6 and sParam6  <> "") Begin
95736>>>            Send Add_Line sParam6
95737>>>        End
95737>>>>
95737>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95740>>>            Send Add_LineLn sParam6
95741>>>        End
95741>>>>
95741>>>
95741>>>        If (iArgs = 7 and sParam7  <> "") Begin
95743>>>            Send Add_Line sParam7
95744>>>        End
95744>>>>
95744>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95747>>>            Send Add_LineLn sParam7
95748>>>        End
95748>>>>
95748>>>
95748>>>        If (iArgs = 8 and sParam8  <> "") Begin
95750>>>            Send Add_Line sParam8
95751>>>        End
95751>>>>
95751>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95754>>>            Send Add_LineLn sParam8
95755>>>        End
95755>>>>
95755>>>
95755>>>        If (iArgs = 9 and sParam9  <> "") Begin
95757>>>            Send Add_Line sParam9
95758>>>        End
95758>>>>
95758>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95761>>>            Send Add_LineLn sParam9
95762>>>        End
95762>>>>
95762>>>
95762>>>        If (iArgs = 10 and sParam10 <> "") Begin
95764>>>            Send Add_Line sParam10
95765>>>        End
95765>>>>
95765>>>
95765>>>        Move Self to hoObj
95766>>>    End_Object
95767>>>
95767>>>    Send Popup   of hoObj // Popup the about object
95768>>>    Send Destroy of hoObj // When done, it will be destroyed
95769>>>End_Procedure
95770>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95770>>>Use Windows.pkg
95770>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95770>>>>>Use Windows.pkg
95770>>>>>Use cCJGrid.pkg
95770>>>>>Use umPromptRelational.pkg
95770>>>>>
95770>>>>>Class cCJGridPromptList is a cCJGrid
95771>>>>>    
95771>>>>>    Procedure Construct_Object
95773>>>>>        Forward Send Construct_Object
95775>>>>>        
95775>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95776>>>>>        Property Boolean Private_pbAutoOrdering True
95777>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95778>>>>>        Property Integer peUpdateMode umPromptValue
95779>>>>>        Property Integer piUpdateColumn 0
95780>>>>>        Property Integer piInitialColumn -1
95781>>>>>        Property String  psSeedValue ''
95782>>>>>        Property Handle phmPromptUpdateCallback 0
95783>>>>>        Property Integer phoInvokingObject
95784>>>>>        
95784>>>>>        Property Boolean pbStoredAutoSeed
95785>>>>>        Property Boolean pbStoredAutoOrdering
95786>>>>>        Property Boolean pbStoredAutoSearch
95787>>>>>        Property Integer peStoredUpdateMode
95788>>>>>        Property Integer piStoredUpdateColumn
95789>>>>>        Property Integer piStoredInitialColumn
95790>>>>>        Property Handle  phmStoredPromptUpdateCallback
95791>>>>>        Property Boolean pbStoredSelectionEnable
95792>>>>>        Property Boolean pbStoredMultipleSelection
95793>>>>>        
95793>>>>>        // internally set by list
95793>>>>>        // these must be set upon closing the list and can be used for manual list updates
95793>>>>>        Property Boolean pbCanceled
95794>>>>>        Property Integer[] pSelectedRows
95795>>>>>        
95795>>>>>        Property Boolean pbNeedsNewOrdering
95796>>>>>        Property Boolean pbRequestSearch
95797>>>>>        Property tGridKeyPair[] pSearchKeys
95798>>>>>        
95798>>>>>        // these properties makes a prompt list a prompt list
95798>>>>>        // and should not be changed.
95798>>>>>        Set pbEditOnKeyNavigation to False
95799>>>>>        Set pbEditOnClick to False
95800>>>>>        Set pbReadOnly to True
95801>>>>>        Set pbFocusSubItems to True
95802>>>>>        
95802>>>>>        // these could maybe be changed
95802>>>>>        Set pbShadeSortColumn to True
95803>>>>>        Set pbHeaderReorders to True
95804>>>>>        Set pbHeaderTogglesDirection to True
95805>>>>>        Set pbHeaderSelectsColumn to True
95806>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95807>>>>>        Set piFocusCellBackColor to clNone
95808>>>>>        Set piFocusCellForeColor to clNone
95809>>>>>        Set piFocusCellRectangleColor to clBlack
95810>>>>>        Set pbUseFocusCellRectangle to False
95811>>>>>        Set pbSelectionEnable to True
95812>>>>>        
95812>>>>>        On_Key kEnter Send Ok
95813>>>>>        On_Key kCancel Send Cancel
95814>>>>>        
95814>>>>>    End_Procedure
95815>>>>>    
95815>>>>>    // reorder list automatically on column change
95815>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95815>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95817>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95818>>>>>        Set pbFocusSubItems to bAutoOrder
95819>>>>>    End_Procedure
95820>>>>>    
95820>>>>>    Function pbAutoOrdering Returns Boolean
95822>>>>>        Boolean bAutoOrder
95822>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95823>>>>>        Function_Return bAutoOrder
95824>>>>>    End_Function
95825>>>>>    
95825>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95825>>>>>    Procedure OnIdle
95827>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95827>>>>>        Handle hoCol
95827>>>>>        Integer iKy1 iKy2 iCol
95827>>>>>        
95827>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95828>>>>>        If bNeedsReorder Begin
95830>>>>>            Get SelectedColumn to iCol
95831>>>>>            If (iCol<>-1) Begin
95833>>>>>                
95833>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95834>>>>>                Set pbHeaderTogglesDirection to False
95835>>>>>                Send HeaderReorder iCol
95836>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95837>>>>>                
95837>>>>>                Set pbNeedsNewOrdering to False
95838>>>>>            End
95838>>>>>>
95838>>>>>        End
95838>>>>>>
95838>>>>>        
95838>>>>>        Get pbRequestSearch to bSearch
95839>>>>>        If bSearch Begin
95841>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95842>>>>>        End
95842>>>>>>
95842>>>>>        
95842>>>>>        Forward Send OnIdle
95844>>>>>    End_Procedure
95845>>>>>    
95845>>>>>    Procedure OnStoreDefaults
95847>>>>>        Integer iVal
95847>>>>>        Boolean bVal
95847>>>>>        
95847>>>>>        Get pbAutoSeed to bVal
95848>>>>>        Set pbStoredAutoSeed to bVal
95849>>>>>        
95849>>>>>        Get pbAutoOrdering to bVal
95850>>>>>        Set pbStoredAutoOrdering to bVal
95851>>>>>        
95851>>>>>        Get pbAutoSearch to bVal
95852>>>>>        Set pbStoredAutoSearch to bVal
95853>>>>>        
95853>>>>>        Get peUpdateMode to iVal
95854>>>>>        Set peStoredUpdateMode to iVal
95855>>>>>        
95855>>>>>        Get piUpdateColumn to iVal
95856>>>>>        Set piStoredUpdateColumn to iVal
95857>>>>>        
95857>>>>>        Get piInitialColumn to iVal
95858>>>>>        Set piStoredInitialColumn to iVal
95859>>>>>        
95859>>>>>        Get phmPromptUpdateCallback to iVal
95860>>>>>        Set phmStoredPromptUpdateCallback to iVal
95861>>>>>        
95861>>>>>        Get pbSelectionEnable to bVal
95862>>>>>        Set pbStoredSelectionEnable to bVal
95863>>>>>        
95863>>>>>        Get pbMultipleSelection to bVal
95864>>>>>        Set pbStoredMultipleSelection to bVal
95865>>>>>        
95865>>>>>    End_Procedure
95866>>>>>    
95866>>>>>    Procedure OnRestoreDefaults
95868>>>>>        Integer iVal
95868>>>>>        Boolean bVal
95868>>>>>        
95868>>>>>        Get pbStoredAutoSeed to bVal
95869>>>>>        Set pbAutoSeed to bVal
95870>>>>>        
95870>>>>>        Get pbStoredAutoOrdering to bVal
95871>>>>>        Set pbAutoOrdering to bVal
95872>>>>>        
95872>>>>>        Get pbStoredAutoSearch to bVal
95873>>>>>        Set pbAutoSearch to bVal
95874>>>>>        
95874>>>>>        Get peStoredUpdateMode to iVal
95875>>>>>        Set peUpdateMode to iVal
95876>>>>>        
95876>>>>>        Get piStoredUpdateColumn to iVal
95877>>>>>        Set piUpdateColumn to iVal
95878>>>>>        
95878>>>>>        Get piStoredInitialColumn to iVal
95879>>>>>        Set piInitialColumn to iVal
95880>>>>>        
95880>>>>>        Get phmStoredPromptUpdateCallback to iVal
95881>>>>>        Set phmPromptUpdateCallback to iVal
95882>>>>>        
95882>>>>>        Get pbStoredSelectionEnable to bVal
95883>>>>>        Set pbSelectionEnable to bVal
95884>>>>>        
95884>>>>>        Get pbStoredMultipleSelection to bVal
95885>>>>>        Set pbMultipleSelection to bVal
95886>>>>>        
95886>>>>>    End_Procedure
95887>>>>>    
95887>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95887>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95887>>>>>    // Suitable for augmentation
95887>>>>>    Procedure OnSeedData
95889>>>>>        Integer iUpdateColumn iSortColumn
95889>>>>>        Boolean bSeed bAuto
95889>>>>>        String sValue
95889>>>>>        Handle hoCol
95889>>>>>        
95889>>>>>        Get piUpdateColumn to iUpdateColumn
95890>>>>>        Get psSeedValue to sValue
95891>>>>>        Get pbAutoSeed to bSeed
95892>>>>>        Get piSortColumn to iSortColumn
95893>>>>>        Get pbAutoOrdering to bAuto
95894>>>>>        // if not yet sorted and this is auto ordering we will
95894>>>>>        // sort the data for the search column. We do this to make the
95894>>>>>        // column search GE logic work properly.
95894>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95896>>>>>            Get ColumnObject iUpdateColumn to hoCol
95897>>>>>            Send SortGridByColumn hoCol False
95898>>>>>        End
95898>>>>>>
95898>>>>>        
95898>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95900>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95901>>>>>        End
95901>>>>>>
95901>>>>>        Else Begin
95902>>>>>            Send MovetoFirstRow
95903>>>>>        End
95903>>>>>>
95903>>>>>        
95903>>>>>    End_Procedure
95904>>>>>    
95904>>>>>    Procedure OnMoveValueOutByValue
95906>>>>>        String sValue
95906>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95906>>>>>        Integer iRow iCol
95906>>>>>        Integer[] SelRowsIndexes
95907>>>>>        
95907>>>>>        Get phoInvokingObject to hoInvokingObject
95908>>>>>        Get pSelectedRows to SelRowsIndexes
95909>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95911>>>>>            Get piUpdateColumn to iCol
95912>>>>>            Get ColumnObject iCol to hoCol
95913>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95914>>>>>            Set Value of hoInvokingObject to sValue
95915>>>>>            Set Item_Changed_State of hoInvokingObject to True
95916>>>>>        End
95916>>>>>>
95916>>>>>    End_Procedure
95917>>>>>    
95917>>>>>    Procedure OnMoveValueOutByCustom
95919>>>>>    End_Procedure
95920>>>>>    
95920>>>>>    // augment to popup a search window when allowed
95920>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95922>>>>>        Boolean bSubFocus bAutoSearch bChar
95922>>>>>        Integer iVal
95922>>>>>        
95922>>>>>        Get pbFocusSubItems to bSubFocus
95923>>>>>        Get pbAutoSearch to bAutoSearch
95924>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95926>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95928>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95930>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95931>>>>>                Move (iVal<>0) to bChar
95932>>>>>            End
95932>>>>>>
95932>>>>>            If bChar Begin
95934>>>>>                // this can get called multiple times before a search dialog pops up
95934>>>>>                Send AddToSearchKeys llKeyCode llShift
95935>>>>>            End
95935>>>>>>
95935>>>>>        End
95935>>>>>>
95935>>>>>    End_Procedure
95936>>>>>    
95936>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95938>>>>>        Boolean bAutoSearch
95938>>>>>        Integer iKeyCode iShiftCode
95938>>>>>        Get pbAutoSearch to bAutoSearch
95939>>>>>        If bAutoSearch Begin
95941>>>>>            // this can get called multiple times before a search dialog pops up
95941>>>>>            Get piLastKey to iKeyCode
95942>>>>>            Get piLastKey2 to iShiftCode
95943>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95944>>>>>        End
95944>>>>>>
95944>>>>>        Move True to llCancel
95945>>>>>    End_Procedure
95946>>>>>    
95946>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95948>>>>>        Send ClearSearchRequest // kill any deferred search popup
95949>>>>>        Forward Send OnComRowDblClick llRow llItem
95951>>>>>    End_Procedure
95952>>>>>    
95952>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95954>>>>>        Send Ok
95955>>>>>    End_Procedure
95956>>>>>    
95956>>>>>    
95956>>>>>    // we don't want a menu for prompt lists
95956>>>>>    Function CreateContextMenu Returns Handle
95958>>>>>        Function_Return 0
95959>>>>>    End_Function
95960>>>>>    
95960>>>>>    // if we use auto-ordering, change the order when the column changes
95960>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95962>>>>>        Boolean bAutoOrder
95962>>>>>        Forward Send ColumnChanged iOld iNew
95964>>>>>        Get pbAutoOrdering to bAutoOrder
95965>>>>>        If bAutoOrder Begin
95967>>>>>            // will be reordered in idle event
95967>>>>>            Set pbNeedsNewOrdering to True
95968>>>>>        End
95968>>>>>>
95968>>>>>    End_Procedure
95969>>>>>    
95969>>>>>    
95969>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95971>>>>>        Integer eMode
95971>>>>>        Integer[] SelRowsIndexes
95972>>>>>        Set pbCanceled to True // assume cancel unless changed
95973>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95974>>>>>        Get peUpdateMode to eMode
95975>>>>>        If (eMode<>umPromptNonInvoking) Begin
95977>>>>>            Send OnStoreDefaults
95978>>>>>        End
95978>>>>>>
95978>>>>>        Send InitializePromptList
95979>>>>>        Forward Send Add_Focus hoParent
95981>>>>>        Send LoadData
95982>>>>>        Set psSeedValue to ""
95983>>>>>    End_Procedure
95984>>>>>    
95984>>>>>    // called before the list is activated.
95984>>>>>    Procedure InitializePromptList
95986>>>>>        Integer hoInvokingObject
95986>>>>>        Boolean bAutoColumn bAutoSeed
95986>>>>>        Integer i iOldMode eUpdateMode
95986>>>>>        String sValue
95986>>>>>        
95986>>>>>        Get peUpdateMode to eUpdateMode
95987>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95989>>>>>            Get Focus of Desktop to hoInvokingObject
95990>>>>>            If (hoInvokingObject<=Desktop) Begin
95992>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95993>>>>>>
95993>>>>>                Procedure_Return
95994>>>>>            End
95994>>>>>>
95994>>>>>            
95994>>>>>            Set phoInvokingObject to hoInvokingObject
95995>>>>>            
95995>>>>>            Send Prompt_Callback to hoInvokingObject Self
95996>>>>>            Get peUpdateMode to eUpdateMode
95997>>>>>        End
95997>>>>>>
95997>>>>>        
95997>>>>>        Send ClearSearchRequest // clear the search keys
95998>>>>>        Set pbNeedsNewOrdering to False
95999>>>>>        
95999>>>>>        Get pbAutoSeed to bAutoSeed
96000>>>>>        
96000>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96002>>>>>            Get Value of hoInvokingObject to sValue
96003>>>>>            Set psSeedValue to sValue
96004>>>>>        End
96004>>>>>>
96004>>>>>        
96004>>>>>    End_Procedure
96005>>>>>    
96005>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96005>>>>>    Procedure LoadData
96007>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96007>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96007>>>>>        Integer eUpdateMode
96007>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96007>>>>>        
96007>>>>>        Get phoDataSource to hoDataSource
96008>>>>>        Get peUpdateMode to eUpdateMode
96009>>>>>        Get phoInvokingObject to hoInvokingObject
96010>>>>>        Get pbAutoSeed to bAutoSeed
96011>>>>>        Get piInitialColumn to iInitialColumn
96012>>>>>        Get piUpdateColumn to iUpdateColumn
96013>>>>>        Get RowCount of hoDataSource to iRows
96014>>>>>        
96014>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96014>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96014>>>>>        If (iInitialColumn=-1) Begin
96016>>>>>            Move iUpdateColumn to iInitialColumn
96017>>>>>        End
96017>>>>>>
96017>>>>>        If (iInitialColumn>=0) Begin
96019>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96020>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96021>>>>>        End
96021>>>>>>
96021>>>>>        Send OnSeedData // find a good starting place for the row
96022>>>>>        Get pbFocusSubItems to bSubFocus
96023>>>>>        If bSubFocus Begin
96025>>>>>            // if column focus, which is normal, go to initialcolumn
96025>>>>>            If hoInitialColumn Begin
96027>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96028>>>>>            End
96028>>>>>>
96028>>>>>            Else Begin
96029>>>>>                Send MoveToFirstEnterableColumn
96030>>>>>            End
96030>>>>>>
96030>>>>>        End
96030>>>>>>
96030>>>>>        
96030>>>>>    End_Procedure
96031>>>>>    
96031>>>>>    // This is only called in a successful close
96031>>>>>    Procedure ClosePromptList
96033>>>>>        Handle hoDataSource hoInvokingObject
96033>>>>>        Handle hmCallBack
96033>>>>>        Integer iRow eUpdateMode
96033>>>>>        Integer[] SelRowsIndexes
96034>>>>>        
96034>>>>>        Get phoDataSource to hoDataSource
96035>>>>>        Get phoInvokingObject to hoInvokingObject
96036>>>>>        
96036>>>>>        If (pbMultipleSelection(Self)) Begin
96038>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96039>>>>>        End
96039>>>>>>
96039>>>>>        Else Begin
96040>>>>>            Get SelectedRow of hoDataSource to iRow
96041>>>>>            If (iRow<>-1) Begin
96043>>>>>                Move iRow to SelRowsIndexes[0]
96044>>>>>            End
96044>>>>>>
96044>>>>>        End
96044>>>>>>
96044>>>>>        
96044>>>>>        Set pbCanceled to False
96045>>>>>        Set pSelectedRows to SelRowsIndexes
96046>>>>>        
96046>>>>>        Get peUpdateMode to eUpdateMode
96047>>>>>        // if non-invoking there is by definition, no move value out
96047>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96049>>>>>            
96049>>>>>            If (eUpdateMode=umPromptValue) Begin
96051>>>>>                Send OnMoveValueOutByValue
96052>>>>>            End
96052>>>>>>
96052>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96055>>>>>                Send OnMoveValueOutByCustom
96056>>>>>            End
96056>>>>>>
96056>>>>>            Get phmPromptUpdateCallback to hmCallBack
96057>>>>>            If hmCallBack Begin
96059>>>>>                Send hmCallBack of hoInvokingObject Self
96060>>>>>            End
96060>>>>>>
96060>>>>>        End
96060>>>>>>
96060>>>>>        
96060>>>>>        Send Close_Panel
96061>>>>>    End_Procedure
96062>>>>>    
96062>>>>>    // augment to send OnRestoreDefaults.
96062>>>>>    Procedure Release_Focus
96064>>>>>        Integer eUpdateMode
96064>>>>>        Get peUpdateMode to eUpdateMode
96065>>>>>        Forward Send Release_Focus
96067>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96069>>>>>            Send OnRestoreDefaults
96070>>>>>        End
96070>>>>>>
96070>>>>>    End_Procedure
96071>>>>>    
96071>>>>>    Function SelectedRowIds Returns RowID[]
96073>>>>>        RowID[] SelectedRowids
96074>>>>>        Integer[] SelectedRows
96075>>>>>        Integer i iRows
96075>>>>>        Handle hoDataSource
96075>>>>>        Get phoDataSource to hoDataSource
96076>>>>>        Get pSelectedRows to SelectedRows
96077>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96078>>>>>        For i from 0 to (iRows-1)
96084>>>>>>
96084>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96085>>>>>        Loop
96086>>>>>>
96086>>>>>        Function_Return SelectedRowids
96087>>>>>    End_Function
96088>>>>>    
96088>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96090>>>>>        String[] SelectedValues
96091>>>>>        Integer[] SelectedRows
96092>>>>>        Integer i iRows
96092>>>>>        Handle hoCol
96092>>>>>        Get ColumnObject iCol to hoCol
96093>>>>>        Get pSelectedRows to SelectedRows
96094>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96095>>>>>        For i from 0 to (iRows-1)
96101>>>>>>
96101>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96102>>>>>        Loop
96103>>>>>>
96103>>>>>        Function_Return SelectedValues
96104>>>>>    End_Function
96105>>>>>    
96105>>>>>    Procedure Ok Returns Integer
96107>>>>>        Send ClosePromptList
96108>>>>>    End_Procedure
96109>>>>>    
96109>>>>>    Procedure Cancel Returns Integer
96111>>>>>        Send Close_Panel
96112>>>>>    End_Procedure
96113>>>>>    
96113>>>>>    Procedure Search
96115>>>>>        Send Activate // give focus back to list so focus things are correct
96116>>>>>        Send Request_Search 0 0
96117>>>>>    End_Procedure
96118>>>>>    
96118>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96118>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96118>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96118>>>>>    Procedure Request_SearchEx
96120>>>>>        tGridKeyPair[] Keys
96120>>>>>        tGridKeyPair[] Keys
96121>>>>>        Integer iCol
96121>>>>>        Handle hoCol hoSearchDialog
96121>>>>>        Boolean bOk
96121>>>>>        String sValue
96121>>>>>        
96121>>>>>        Get piSortColumn to iCol
96122>>>>>        If (iCol<>-1) Begin
96124>>>>>            Get ColumnObject iCol to hoCol
96125>>>>>            Get pSearchKeys to Keys
96126>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96127>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96128>>>>>            If bOk Begin
96130>>>>>                Send RequestFindColumnValue iCol sValue True 0
96131>>>>>            End
96131>>>>>>
96131>>>>>            Send Destroy of hoSearchDialog
96132>>>>>        End
96132>>>>>>
96132>>>>>        Send ClearSearchRequest // clear the search keys
96133>>>>>    End_Procedure
96134>>>>>    
96134>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96134>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96136>>>>>        tGridKeyPair[] Keys
96136>>>>>        tGridKeyPair[] Keys
96137>>>>>        tGridKeyPair KeyPair
96137>>>>>        tGridKeyPair KeyPair
96137>>>>>        Set pbRequestSearch to True
96138>>>>>        Move iKeyCode to KeyPair.KeyCode
96139>>>>>        Move iShiftCode to KeyPair.ShiftCode
96140>>>>>        Get pSearchKeys to Keys
96141>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96142>>>>>        Set pSearchKeys to Keys
96143>>>>>    End_Procedure
96144>>>>>    
96144>>>>>    Procedure ClearSearchRequest
96146>>>>>        tGridKeyPair[] SearchKeys
96146>>>>>        tGridKeyPair[] SearchKeys
96147>>>>>        Set pSearchKeys to SearchKeys
96148>>>>>        Set pbRequestSearch to False
96149>>>>>    End_Procedure
96150>>>>>    
96150>>>>>End_Class
96151>>>>>
96151>>>Use cDbUpdateFunctionLibrary.pkg
96151>>>Use MSSqldrv.pkg
96151>>>Use db2_drv.pkg
96151>>>Use odbc_drv.pkg
96151>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96151>>>>>//****************************************************************************
96151>>>>>// $Module type: Class
96151>>>>>// $Module name: cRDCModalPanel
96151>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96151>>>>>// Created     : 2014-03-17 @ 12:33
96151>>>>>//
96151>>>>>// Description :
96151>>>>>//
96151>>>>>// $Rev History:
96151>>>>>//    2014-03-17  Module header created
96151>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96151>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96151>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96151>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96151>>>>>// in the help folder for more details.
96151>>>>>//
96151>>>>>//****************************************************************************
96151>>>>>Use Windows.pkg
96151>>>>>Use cCJCommandBarSystem.pkg   
96151>>>>>Use cCJSkinFramework.pkg
96151>>>>>
96151>>>>>Class cRDCModalPanel is a ModalPanel
96152>>>>>
96152>>>>>    Procedure Construct_Object
96154>>>>>        Forward Send Construct_Object
96156>>>>>
96156>>>>>        Set Maximize_Icon to True
96157>>>>>        Set Minimize_Icon to False
96158>>>>>        Set Border_Style to Border_Thick
96159>>>>>        Set Locate_Mode to Center_On_Parent
96160>>>>>
96160>>>>>        Property String Private_Icon
96161>>>>>        Property Handle phoDialogCommandbar
96162>>>>>    End_Procedure
96163>>>>>
96163>>>>>    Procedure Set Icon String sIcon
96165>>>>>        Forward Set Icon to sIcon
96167>>>>>        Set Private_Icon to sIcon
96168>>>>>    End_Procedure
96169>>>>>
96169>>>>>    Function Icon Returns String
96171>>>>>        String sIcon
96171>>>>>        Get Private_Icon to sIcon
96172>>>>>        Function_Return sIcon
96173>>>>>    End_Function
96174>>>>>
96174>>>>>    Procedure Page Integer iPageObject
96176>>>>>        String sIcon
96176>>>>>        Integer hWnd
96176>>>>>        
96176>>>>>        Forward Send Page iPageObject
96178>>>>>        Get Private_Icon to sIcon
96179>>>>>        If (sIcon <> "") Begin
96181>>>>>            Set Icon to sIcon
96182>>>>>        End
96182>>>>>>
96182>>>>>
96182>>>>>        Get Window_Handle to hWnd
96183>>>>>
96183>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96185>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96186>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96187>>>>>        End
96187>>>>>>
96187>>>>>    End_Procedure
96188>>>>>
96188>>>>>    // Put a status bar at the bottom of the panel, which makes
96188>>>>>    // status_help work and puts a gripper in the lower right corner.
96188>>>>>    Procedure End_Construct_Object
96190>>>>>        Integer iStyle iSize iOffset
96190>>>>>
96190>>>>>        Forward Send End_Construct_Object
96192>>>>>
96192>>>>>        Get Border_Style to iStyle
96193>>>>>        Move 8 to iOffset
96194>>>>>        If (iStyle = Border_Thick) Begin
96196>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96198>>>>>                Object oStatusBar is a cCJStatusBar
96200>>>>>                    Set phoDialogCommandbar to Self
96201>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96203>>>>>                        Set piId to sbpIDIdlePane
96204>>>>>                        Set pbStyleStretch to True
96205>>>>>                    End_Object
96206>>>>>                End_Object
96207>>>>>            End_Object
96208>>>>>            Get Size to iSize
96209>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96210>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96211>>>>>        End
96211>>>>>>
96211>>>>>
96211>>>>>    End_Procedure
96212>>>>>
96212>>>>>    Procedure Popup
96214>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96215>>>>>        Forward Send Popup
96217>>>>>    End_Procedure
96218>>>>>
96218>>>>>End_Class
96219>>>
96219>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96221>>>    Set Label to "SQL Database Selection"
96222>>>    Set Size to 119 183
96223>>>    Set piMinSize to 89 170
96224>>>    Set Location to 2 2
96225>>>    Set Border_Style to Border_Thick
96226>>>    Set Icon to "DatabaseLookup1.ico"
96227>>>
96227>>>    Property String[] psTheData
96229>>>
96229>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96231>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96233>>>        End_Object
96234>>>    End
96234>>>>
96234>>>
96234>>>    Object oSelList is a cCJGridPromptList
96236>>>        Set Size to 89 167
96237>>>        Set Location to 6 6
96238>>>        Set peAnchors to anAll
96239>>>        Set pbAllowColumnRemove to False
96240>>>        Set pbUseAlternateRowBackgroundColor to True
96241>>>        Set pbGrayIfDisable to False
96242>>>        Set pbHeaderReorders to False
96243>>>        Set pbHeaderSelectsColumn to False
96244>>>        Set pbHeaderTogglesDirection to False
96245>>>        Set pbShadeSortColumn to False
96246>>>        Set piFocusCellBackColor to clDkGray
96247>>>
96247>>>        Object oName is a cCJGridColumn
96249>>>            Set piWidth to 334
96250>>>            Set psCaption to "Database Name"
96251>>>        End_Object
96252>>>
96252>>>        Procedure Activating
96255>>>            tDataSourceRow[] MyData
96255>>>            tDataSourceRow[] MyData
96256>>>            Handle hoDataSource
96256>>>            String[] sTheData
96257>>>            Integer iCount iSize
96257>>>
96257>>>            Send Cursor_Wait of Cursor_Control
96258>>>            Forward Send Activating
96260>>>
96260>>>            Get psTheData to sTheData
96261>>>            Move (SizeOfArray(sTheData)) to iSize
96262>>>            Decrement iSize
96263>>>            For iCount from 0 to iSize
96269>>>>
96269>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96270>>>            Loop
96271>>>>
96271>>>
96271>>>            Get phoDataSource to hoDataSource
96272>>>            Send InitializeData of hoDataSource MyData
96273>>>            Send Cursor_Ready of Cursor_Control
96274>>>        End_Procedure
96275>>>
96275>>>    End_Object
96276>>>
96276>>>    Object oOK_Btn is a Button
96278>>>        Set Size to 14 50
96279>>>        Set Label    to "&OK"
96280>>>        Set Location to 98 68
96281>>>        Set peAnchors To anBottomRight
96282>>>
96282>>>        Procedure OnClick
96285>>>            Send Ok of oSelList
96286>>>        End_Procedure
96287>>>
96287>>>    End_Object
96288>>>
96288>>>    Object oCancel_Btn is a Button
96290>>>        Set Size to 14 50
96291>>>        Set Label    to "&Cancel"
96292>>>        Set Location to 98 123
96293>>>        Set peAnchors to anBottomRight
96294>>>
96294>>>        Procedure OnClick
96297>>>            Send Close_Panel
96298>>>        End_Procedure
96299>>>
96299>>>    End_Object
96300>>>
96300>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96301>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96302>>>End_Object
96303>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96303>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96303>>>Use Windows.pkg
96303>>>Use vWin32fh.pkg
96303>>>
96303>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96305>>>    Set Size to 104 298
96306>>>    Set Label to "SQL Database Backup"
96307>>>    Set piMinSize to 89 211
96308>>>    Set Location to 2 4
96309>>>    Set Border_Style To Border_Thick
96310>>>
96310>>>    Property Boolean pbOK False
96312>>>    Property String  psDatabase
96314>>>    Property String  psPath
96316>>>    Property String  psBackupName
96318>>>
96318>>>    Object oDatabase_fm is a Form
96320>>>        Set Size to 13 204
96321>>>        Set Location to 14 71
96322>>>        Set Label_Justification_Mode to JMode_Right
96323>>>        Set Label_Col_Offset to 2
96324>>>        Set Label to "Database Name"
96325>>>        Set Enabled_State to False
96326>>>        Set peAnchors to anTopLeftRight
96327>>>
96327>>>        Procedure Page Integer iPageObject
96330>>>            String sValue
96330>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96331>>>            Set Value to sValue
96332>>>            Set psDatabase to sValue
96333>>>            Forward Send Page iPageObject
96335>>>        End_Procedure
96336>>>
96336>>>    End_Object
96337>>>
96337>>>    Object oBackupName_fm is a Form
96339>>>        Set Size to 13 204
96340>>>        Set Location to 29 71
96341>>>        Set Label_Justification_Mode to JMode_Right
96342>>>        Set Label_Col_Offset to 2
96343>>>        Set Label to "Backup Name"
96344>>>        Set peAnchors to anTopLeftRight
96345>>>
96345>>>        Procedure Page Integer iPageObject
96348>>>            String sValue
96348>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96349>>>            Set Value to sValue
96350>>>            Forward Send Page iPageObject
96352>>>        End_Procedure
96353>>>
96353>>>        Procedure OnChange
96356>>>            String sValue
96356>>>            Get Value to sValue
96357>>>            Set psBackupName to sValue
96358>>>        End_Procedure
96359>>>
96359>>>    End_Object
96360>>>
96360>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96362>>>        Set Size to 10 50
96363>>>        Set Location to 50 71
96364>>>        Set Label to "Use Default SQL Backup Folder"
96365>>>        Set Checked_State to True
96366>>>
96366>>>        Procedure OnChange
96369>>>            Boolean bChecked
96369>>>            Get Checked_State to bChecked
96370>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96371>>>        End_Procedure
96372>>>
96372>>>    End_Object
96373>>>
96373>>>    Object oPath_fm is a Form
96375>>>        Set Size to 13 204
96376>>>        Set Location to 62 71
96377>>>        Set Label_Justification_Mode to JMode_Right
96378>>>        Set Label_Col_Offset to 2
96379>>>        Set Label to "Path"
96380>>>        Set Prompt_Button_Mode to PB_PromptOn
96381>>>        Set peAnchors to anTopLeftRight
96382>>>        Set Enabled_State to False
96383>>>
96383>>>        Procedure Page Integer iPageObject
96386>>>            String sValue
96386>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96387>>>            Get vFolderFormat sValue to sValue
96388>>>            Move (sValue + "Backup") to sValue
96389>>>            Set Value to sValue
96390>>>            Forward Send Page iPageObject
96392>>>        End_Procedure
96393>>>
96393>>>        Procedure Prompt
96396>>>            String sPath sFileMask sRetval
96396>>>
96396>>>            Get Value to sPath
96397>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96398>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96399>>>            If (sRetval <> "") Begin
96401>>>                Get ParseFolderName sRetval to sPath
96402>>>                If (Right(sPath, 1) ="\") Begin
96404>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96405>>>                End
96405>>>>
96405>>>                Set Value to sPath
96406>>>            End
96406>>>>
96406>>>        End_Procedure
96407>>>
96407>>>        Procedure OnChange
96410>>>            String sValue
96410>>>            Get Value to sValue
96411>>>            Set psPath to sValue
96412>>>        End_Procedure
96413>>>
96413>>>    End_Object
96414>>>
96414>>>    Object oOK_Btn is a Button
96416>>>        Set Label    to "&OK"
96417>>>        Set Location to 81 169
96418>>>        Set peAnchors to anBottomRight
96419>>>
96419>>>        Procedure OnClick
96422>>>            Set pbOK to True
96423>>>            Send Close_Panel
96424>>>        End_Procedure
96425>>>
96425>>>    End_Object
96426>>>
96426>>>    Object oCancel_Btn is a Button
96428>>>        Set Label    to "&Cancel"
96429>>>        Set Location to 81 224
96430>>>        Set peAnchors to anBottomRight
96431>>>
96431>>>        Procedure OnClick
96434>>>            Set pbOK to False
96435>>>            Send Close_Panel
96436>>>        End_Procedure
96437>>>
96437>>>    End_Object
96438>>>
96438>>>    Object oButton1 is a Button
96440>>>        Set Size to 14 96
96441>>>        Set Location to 80 32
96442>>>        Set Label to "Enum table types"
96443>>>
96443>>>        Procedure OnClick
96446>>>            String sDriverID
96446>>>            tSQLConnection SQLConnection
96446>>>            tSQLConnection SQLConnection
96446>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96447>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96448>>>        End_Procedure
96449>>>
96449>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96452>>>            Handle hoCLIHandler
96452>>>            Integer iNumTables iTableCount
96452>>>
96452>>>            Get Create U_cCLIHandler to hoCLIhandler
96453>>>            If (hoCLIHandler > 0) Begin
96455>>>                Set psDriverID of hoCLIHandler to sDriver
96456>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96457>>>                For iTableCount from 1 to iNumTables
96463>>>>
96463>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96465>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96467>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96469>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96471>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96471>>>//                    For iColumnCount from 1 to iNumColumns
96471>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96471>>>//                    Loop
96471>>>                    Showln
96472>>>                Loop
96473>>>>
96473>>>                Send Destroy of hoCLIHandler
96474>>>            End
96474>>>>
96474>>>        End_Procedure
96475>>>
96475>>>    End_Object
96476>>>
96476>>>    Procedure Page Integer iPageObject
96479>>>        Set Icon to "DbBackup1.ico"
96480>>>        Forward Send Page iPageObject
96482>>>    End_Procedure
96483>>>
96483>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96484>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96485>>>
96485>>>End_Object
96486>>>
96486>>>// *** General purpose access method for this dialog ***
96486>>>Function MakeSQLDatabaseBackup Returns Boolean
96489>>>    Handle ho
96489>>>    Boolean bOK bDefault
96489>>>    String sDatabase sPath sBackupName
96489>>>
96489>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96490>>>    Set pbOK of ho to False
96491>>>    Send Popup of ho
96492>>>
96492>>>    Get pbOk of ho to bOK
96493>>>    If (bOK = True) Begin
96495>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96496>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96497>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96498>>>        If (bDefault = False) Begin
96500>>>            Get Value of (oPath_fm(ho)) to sPath
96501>>>        End
96501>>>>
96501>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96502>>>    End
96502>>>>
96502>>>
96502>>>    Function_Return bOK
96503>>>End_Function
96504>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96504>>>Use Windows.pkg
96504>>>Use DFClient.pkg
96504>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96504>>>>>// Provides support for db aware scrolling containers.
96504>>>>>// Scrolling containers is provided by creating two objects,
96504>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96504>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96504>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96504>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96504>>>>>
96504>>>>>Use DFClient.pkg
96504>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96504>>>>>>>// Mixin classes for scrolling container support:
96504>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96504>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96504>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96504>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96504>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96504>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96504>>>>>>>
96504>>>>>>>Use Windows.pkg
96504>>>>>>>Use Winuser.pkg
96504>>>>>>>Use tWinStructs.pkg
96504>>>>>>>
96504>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96504>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96504>>>>>>>// support for the scrolling client area mixin object.
96504>>>>>>>
96504>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96505>>>>>>>    
96505>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96507>>>>>>>        
96507>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96508>>>>>>>        Set Border_Style to Border_None
96509>>>>>>>        
96509>>>>>>>        Property Boolean pbAutoScroll True
96510>>>>>>>        Property Boolean pbAutoScrollFocus True
96511>>>>>>>        Property Integer piAutoScrollMarginX 5
96512>>>>>>>        Property Integer piAutoScrollMarginY 5
96513>>>>>>>        Property Integer piAutoScrollMinX 0
96514>>>>>>>        Property Integer piAutoScrollMinY 0
96515>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96516>>>>>>>        
96516>>>>>>>        
96516>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96517>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96518>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96519>>>>>>>        // keeps track of scrolling
96519>>>>>>>        Property Integer piCurrentVertScrolled 0
96520>>>>>>>        Property Integer piCurrentHorzScrolled 0
96521>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96522>>>>>>>        Delegate Set phoScrollingClientArea to Self
96524>>>>>>>        
96524>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96524>>>>>>>        Property Boolean pbTabWorkspaceView False
96525>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96525>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96526>>>>>>>    End_Procedure
96527>>>>>>>    
96527>>>>>>>    // low level event sent from windows.
96527>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96529>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96529>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96530>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96531>>>>>>>        If (wParam<0) Begin
96533>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96534>>>>>>>        End
96534>>>>>>>>
96534>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96535>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96536>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96536>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96537>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96538>>>>>>>        // If we have enough Clicks send OnMouseWheel
96538>>>>>>>        If (iClicks<>0) Begin
96540>>>>>>>            Send OnMouseWheel iClicks iKeys
96541>>>>>>>        End
96541>>>>>>>>
96541>>>>>>>        // tell windows that we've handled the event.
96541>>>>>>>        Set Windows_Override_State to True
96542>>>>>>>    End_Procedure
96543>>>>>>>    
96543>>>>>>>    
96543>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96543>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96545>>>>>>>        Integer iLineScrollUnit
96545>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96546>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96547>>>>>>>    End_Procedure
96548>>>>>>>    
96548>>>>>>>    // should be sent by WM_VSCROLL
96548>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96550>>>>>>>        Boolean bOk
96550>>>>>>>        tWinScrollInfo ScrollInfo
96550>>>>>>>        tWinScrollInfo ScrollInfo
96550>>>>>>>        Integer iLineScrollUnit
96550>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96551>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96552>>>>>>>        If bOk Begin
96554>>>>>>>            
96554>>>>>>>            Case Begin
96554>>>>>>>                Case (iType=SB_PAGEDOWN)
96556>>>>>>>                    Send VScroll ScrollInfo.nPage
96557>>>>>>>                    Case Break
96558>>>>>>>                
96558>>>>>>>                Case (iType=SB_PAGEUP)
96561>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96562>>>>>>>                    Case Break
96563>>>>>>>                
96563>>>>>>>                Case (iType=SB_LINEDOWN)
96566>>>>>>>                    Send VScroll iLineScrollUnit
96567>>>>>>>                    Case Break
96568>>>>>>>                
96568>>>>>>>                Case (iType=SB_LINEUP)
96571>>>>>>>                    Send VScroll (-iLineScrollUnit)
96572>>>>>>>                    Case Break
96573>>>>>>>                
96573>>>>>>>                Case (iType=SB_BOTTOM)
96576>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96577>>>>>>>                    Case Break
96578>>>>>>>                
96578>>>>>>>                Case (iType=SB_Top)
96581>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96582>>>>>>>                    Case Break
96583>>>>>>>                
96583>>>>>>>                Case (iType=SB_THUMBPOSITION)
96586>>>>>>>                    Case Break
96587>>>>>>>                
96587>>>>>>>                Case (iType=SB_THUMBTRACK)
96590>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96591>>>>>>>                    Case Break
96592>>>>>>>            Case End
96592>>>>>>>        End
96592>>>>>>>>
96592>>>>>>>    End_Procedure
96593>>>>>>>    
96593>>>>>>>    // should be sent by WM_HSCROLL
96593>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96595>>>>>>>        Boolean bOk
96595>>>>>>>        tWinScrollInfo ScrollInfo
96595>>>>>>>        tWinScrollInfo ScrollInfo
96595>>>>>>>        Integer iLineScrollUnit
96595>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96596>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96597>>>>>>>        If bOk Begin
96599>>>>>>>            
96599>>>>>>>            Case Begin
96599>>>>>>>                Case (iType=SB_PAGEDOWN)
96601>>>>>>>                    Send hScroll ScrollInfo.nPage
96602>>>>>>>                    Case Break
96603>>>>>>>                
96603>>>>>>>                Case (iType=SB_PAGEUP)
96606>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96607>>>>>>>                    Case Break
96608>>>>>>>                
96608>>>>>>>                Case (iType=SB_LINEDOWN)
96611>>>>>>>                    Send hScroll iLineScrollUnit
96612>>>>>>>                    Case Break
96613>>>>>>>                
96613>>>>>>>                Case (iType=SB_LINEUP)
96616>>>>>>>                    Send hScroll (-iLineScrollUnit)
96617>>>>>>>                    Case Break
96618>>>>>>>                
96618>>>>>>>                Case (iType=SB_BOTTOM)
96621>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96622>>>>>>>                    Case Break
96623>>>>>>>                
96623>>>>>>>                Case (iType=SB_Top)
96626>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96627>>>>>>>                    Case Break
96628>>>>>>>                
96628>>>>>>>                Case (iType=SB_THUMBPOSITION)
96631>>>>>>>                    Case Break
96632>>>>>>>                
96632>>>>>>>                Case (iType=SB_THUMBTRACK)
96635>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96636>>>>>>>                    Case Break
96637>>>>>>>            Case End
96637>>>>>>>        End
96637>>>>>>>>
96637>>>>>>>    End_Procedure
96638>>>>>>>    
96638>>>>>>>    
96638>>>>>>>    // this calls SetScrollInfo with proper info
96638>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96640>>>>>>>        tWinScrollInfo ScrollInfo
96640>>>>>>>        tWinScrollInfo ScrollInfo
96640>>>>>>>        Integer iVoid
96640>>>>>>>        Handle hWnd
96640>>>>>>>        Boolean bShow
96640>>>>>>>        
96640>>>>>>>        Delegate Get Window_Handle to hWnd
96642>>>>>>>        If (hWnd <> 0) Begin
96644>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96645>>>>>>>            
96645>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96646>>>>>>>            Get pbShowDisabledScrollBar to bShow
96647>>>>>>>            If bShow Begin
96649>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96650>>>>>>>            End
96650>>>>>>>>
96650>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96651>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96652>>>>>>>            Move iPageSize to ScrollInfo.nPage
96653>>>>>>>            Move 0 to ScrollInfo.nPos
96654>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96655>>>>>>>            
96655>>>>>>>        End
96655>>>>>>>>
96655>>>>>>>    End_Procedure
96656>>>>>>>    
96656>>>>>>>    // this wraps GetScrollInfo
96656>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96658>>>>>>>        Boolean bOk
96658>>>>>>>        Handle hWnd
96658>>>>>>>        
96658>>>>>>>        Delegate Get Window_Handle to hWnd
96660>>>>>>>        If (hWnd <> 0) Begin
96662>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96663>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96664>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96665>>>>>>>        End
96665>>>>>>>>
96665>>>>>>>        Function_Return bOk
96666>>>>>>>    End_Function
96667>>>>>>>    
96667>>>>>>>    // this wraps SetScrollPos
96667>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96669>>>>>>>        Integer iVoid
96669>>>>>>>        Handle hWnd
96669>>>>>>>        
96669>>>>>>>        Delegate Get Window_Handle to hWnd
96671>>>>>>>        If (hWnd <> 0) Begin
96673>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96674>>>>>>>        End
96674>>>>>>>>
96674>>>>>>>    End_Procedure
96675>>>>>>>    
96675>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96675>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96675>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96677>>>>>>>        Send ScrollClientArea
96678>>>>>>>    End_Procedure
96679>>>>>>>    
96679>>>>>>>    // augment to handle the scrolling area initialization.
96679>>>>>>>    Procedure Add_Focus Handle hoParent
96681>>>>>>>        Forward Send Add_Focus hoParent
96683>>>>>>>        // at this the scrolling container and client area should both be paged.
96683>>>>>>>        // child objects ae also paged with initial anchors applied
96683>>>>>>>        Send CalculateAutoScrollMinimums
96684>>>>>>>    End_Procedure
96685>>>>>>>    
96685>>>>>>>    Procedure Page Integer iPage
96687>>>>>>>        Forward Send Page iPage
96689>>>>>>>        If iPage Begin
96691>>>>>>>            // at this the scrolling container and client area should both be paged
96691>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96691>>>>>>>            // the child items are paged (else they may get anchored oddly)
96691>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96691>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96691>>>>>>>            // before they were really needed. This should be more accurate
96691>>>>>>>            Send SetScrollBarInfo True 0 0 0
96692>>>>>>>            Send SetScrollBarInfo False 0 0 0
96693>>>>>>>        End
96693>>>>>>>>
96693>>>>>>>    End_Procedure
96694>>>>>>>    
96694>>>>>>>    // determine scrolling minimums and set the client area as required.
96694>>>>>>>    
96694>>>>>>>    Procedure CalculateAutoScrollMinimums
96696>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96696>>>>>>>        Integer iAutoMinX iAutoMinY
96696>>>>>>>        Boolean bAutoScroll
96696>>>>>>>        Handle hoNext hoFirst
96696>>>>>>>        
96696>>>>>>>        Get pbAutoScroll to bAutoScroll
96697>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96698>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96699>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96700>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96701>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96702>>>>>>>        Set piMinimumHeight to iAutoMinY
96703>>>>>>>        Set piMinimumWidth to iAutoMinX
96704>>>>>>>        
96704>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96706>>>>>>>            
96706>>>>>>>            Get Next_Level to hoFirst
96707>>>>>>>            Move hoFirst to hoNext
96708>>>>>>>            If (hoFirst) Begin
96710>>>>>>>                Repeat
96710>>>>>>>>
96710>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96711>>>>>>>                    Get GuiLocation of hoNext to iLoc
96712>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96713>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96714>>>>>>>                    Get Next_Focus of hoNext to hoNext
96715>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96717>>>>>>>                
96717>>>>>>>                If (iAutoMinY=0) Begin
96719>>>>>>>                    Get piAutoScrollMarginY to iMargin
96720>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96721>>>>>>>                End
96721>>>>>>>>
96721>>>>>>>                
96721>>>>>>>                If (iAutoMinX=0) Begin
96723>>>>>>>                    Get piAutoScrollMarginX to iMargin
96724>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96725>>>>>>>                    
96725>>>>>>>                End
96725>>>>>>>>
96725>>>>>>>            End
96725>>>>>>>>
96725>>>>>>>        End
96725>>>>>>>>
96725>>>>>>>        
96725>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96725>>>>>>>        Broadcast Set pbAnchorCreated to False
96727>>>>>>>        Send ScrollClientArea
96728>>>>>>>        // after the scroll set up, reinitialize all anchors.
96728>>>>>>>        Broadcast Send DoCreateAnchors
96730>>>>>>>    End_Procedure
96731>>>>>>>    
96731>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96731>>>>>>>    // work of scrolling.
96731>>>>>>>    
96731>>>>>>>    Procedure ScrollClientArea
96733>>>>>>>        Integer iSiz
96733>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96733>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96733>>>>>>>        Integer iSzY iSzX iLocX iLocY
96733>>>>>>>        
96733>>>>>>>        Delegate Get GuiClientSize to iSiz
96735>>>>>>>        Move (Hi(iSiz)) to iHeight
96736>>>>>>>        Move (Low(iSiz)) to iWidth
96737>>>>>>>        
96737>>>>>>>        // Vertical scrolling
96737>>>>>>>        
96737>>>>>>>        Get piMinimumHeight to iOrig
96738>>>>>>>        Get piMinimumWidth to iWOrig
96739>>>>>>>        
96739>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96741>>>>>>>            
96741>>>>>>>            If (iOrig<>0) Begin
96743>>>>>>>                Get piCurrentVertScrolled to iHCur
96744>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96744>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96746>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96747>>>>>>>                    Set piCurrentVertScrolled to iHCur
96748>>>>>>>                End
96748>>>>>>>>
96748>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96750>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96751>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96752>>>>>>>                End
96752>>>>>>>>
96752>>>>>>>                Else Begin
96753>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96754>>>>>>>                End
96754>>>>>>>>
96754>>>>>>>            End
96754>>>>>>>>
96754>>>>>>>            
96754>>>>>>>            // Horiz scrolling
96754>>>>>>>            
96754>>>>>>>            Get piCurrentHorzScrolled to iWCur
96755>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96755>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96757>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96758>>>>>>>                Set piCurrentHorzScrolled to iWCur
96759>>>>>>>            End
96759>>>>>>>>
96759>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96761>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96762>>>>>>>                Send SetScrollBarPosInfo False iWCur
96763>>>>>>>            End
96763>>>>>>>>
96763>>>>>>>            Else Begin
96764>>>>>>>                Send SetScrollBarInfo False 0 0 0
96765>>>>>>>            End
96765>>>>>>>>
96765>>>>>>>        End
96765>>>>>>>>
96765>>>>>>>        
96765>>>>>>>        // this could change depending on scrollbars appearing or not
96765>>>>>>>        Delegate Get GuiClientSize to iSiz
96767>>>>>>>        
96767>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96767>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96767>>>>>>>        // This is required to make anchors work sensibly
96767>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96768>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96769>>>>>>>        Move (-iHCur) to iLocY
96770>>>>>>>        Move (-iWCur) to iLocX
96771>>>>>>>        
96771>>>>>>>        // Allow chance to make modifications
96771>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96772>>>>>>>        
96772>>>>>>>        Set GuiSize to iSzY iSzX
96773>>>>>>>        // if we've scrolled, we need to reposition the container
96773>>>>>>>        Set GuiLocation to iLocY iLocX
96774>>>>>>>    End_Procedure
96775>>>>>>>    
96775>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96775>>>>>>>    // this way, it does not interfere with anchors.
96775>>>>>>>    
96775>>>>>>>    Procedure VScroll Integer iDelta
96777>>>>>>>        Integer iHeight iCur iOrig iSiz
96777>>>>>>>        Delegate Get GuiClientSize to iSiz
96779>>>>>>>        Move (hi(iSiz)) to iHeight
96780>>>>>>>        Get piCurrentVertScrolled to iCur
96781>>>>>>>        Get piMinimumHeight to iOrig
96782>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96784>>>>>>>            Procedure_Return
96785>>>>>>>        End
96785>>>>>>>>
96785>>>>>>>        // make sure delta is within range
96785>>>>>>>        If (iDelta+iCur<0) Begin
96787>>>>>>>            Move (-iCur) to iDelta
96788>>>>>>>        End
96788>>>>>>>>
96788>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96791>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96792>>>>>>>        End
96792>>>>>>>>
96792>>>>>>>        If (iDelta=0) ;            Procedure_Return
96795>>>>>>>        
96795>>>>>>>        Move (iCur + iDelta) to iCur
96796>>>>>>>        Set piCurrentVertScrolled to iCur
96797>>>>>>>        Send SetScrollBarPosInfo True iCur
96798>>>>>>>        Get GuiLocation to iSiz
96799>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96800>>>>>>>        Send ScrollClientArea
96801>>>>>>>    End_Procedure
96802>>>>>>>    
96802>>>>>>>    
96802>>>>>>>    Procedure HScroll Integer iDelta
96804>>>>>>>        Integer iHeight iCur iOrig iSiz
96804>>>>>>>        Delegate Get GuiClientSize to iSiz
96806>>>>>>>        Move (low(iSiz)) to iHeight
96807>>>>>>>        Get piCurrentHorzScrolled to iCur
96808>>>>>>>        Get piMinimumWidth to iOrig
96809>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96811>>>>>>>            Procedure_Return
96812>>>>>>>        End
96812>>>>>>>>
96812>>>>>>>        If (iDelta+iCur<0) Begin
96814>>>>>>>            Move (-iCur) to iDelta
96815>>>>>>>        End
96815>>>>>>>>
96815>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96818>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96819>>>>>>>        End
96819>>>>>>>>
96819>>>>>>>        If (iDelta=0) ;            Procedure_Return
96822>>>>>>>        
96822>>>>>>>        Move (iCur + iDelta) to iCur
96823>>>>>>>        Set piCurrentHorzScrolled to iCur
96824>>>>>>>        Send SetScrollBarPosInfo False iCur
96825>>>>>>>        Get GuiLocation to iSiz
96826>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96827>>>>>>>        Send ScrollClientArea
96828>>>>>>>    End_Procedure
96829>>>>>>>    
96829>>>>>>>    // make sure client is a 0,0
96829>>>>>>>    Procedure ScrollHome
96831>>>>>>>        Send SetVScrollbox SB_TOP 0
96832>>>>>>>        Send SetHScrollbox SB_TOP 0
96833>>>>>>>    End_Procedure
96834>>>>>>>    
96834>>>>>>>    // get relative GUI location of this object to the parent one passed.
96834>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96836>>>>>>>        Integer ivoid
96836>>>>>>>        tWinRect Rect0 Rect1
96836>>>>>>>        tWinRect Rect0 Rect1
96836>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96837>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96838>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96839>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96840>>>>>>>    End_Procedure
96841>>>>>>>    
96841>>>>>>>    // This scrolls this object into visual range.
96841>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96843>>>>>>>        Handle hoScrollingContainer
96843>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96843>>>>>>>        Integer iViewHeight iViewWidth
96843>>>>>>>        Integer iRelLocHeight iRelLocWidth
96843>>>>>>>        Integer iSize iControlHeight iControlWidth
96843>>>>>>>        Integer iScroll
96843>>>>>>>        Integer iMarginX iMarginY
96843>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96843>>>>>>>        
96843>>>>>>>        Get piAutoScrollMarginX to iMarginX
96844>>>>>>>        Get piAutoScrollMarginY to iMarginY
96845>>>>>>>        
96845>>>>>>>        // the scrolling container
96845>>>>>>>        Move Self to hoScrollingContainer
96846>>>>>>>        // the amount the SC is currently scrolled
96846>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96847>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96848>>>>>>>        
96848>>>>>>>        // size of view's client area (this is the viewport area)
96848>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96849>>>>>>>        Move (hi(iSize)) to iViewHeight
96850>>>>>>>        Move (low(iSize)) to iViewWidth
96851>>>>>>>        
96851>>>>>>>        // get this object's location relative to the scrolling container
96851>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96852>>>>>>>        
96852>>>>>>>        // we expect that the client size is the window size but just in case
96852>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96853>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96854>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96855>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96856>>>>>>>        
96856>>>>>>>        // the outer size of the control object
96856>>>>>>>        Get GUIWindowSize of hoControl to iSize
96857>>>>>>>        Move (hi(iSize)) to iControlHeight
96858>>>>>>>        Move (low(iSize)) to iControlWidth
96859>>>>>>>        
96859>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96859>>>>>>>        
96859>>>>>>>        // Vertical Scroll
96859>>>>>>>        
96859>>>>>>>        // Vertical Scroll down
96859>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96859>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96861>>>>>>>            
96861>>>>>>>            // set scroll amount so that the bottom of the control is visible
96861>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96862>>>>>>>            
96862>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96862>>>>>>>            // top of the object appears at the bottom
96862>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96864>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96865>>>>>>>            End
96865>>>>>>>>
96865>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96865>>>>>>>            If (iScroll>0) Begin
96867>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96868>>>>>>>            End
96868>>>>>>>>
96868>>>>>>>        End
96868>>>>>>>>
96868>>>>>>>        // else vertical scroll up
96868>>>>>>>        // We scroll if the top of the object is not visible.
96868>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96871>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96871>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96872>>>>>>>            If (iScroll<0) Begin
96874>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96875>>>>>>>            End
96875>>>>>>>>
96875>>>>>>>        End
96875>>>>>>>>
96875>>>>>>>        
96875>>>>>>>        // Horizonal Scroll
96875>>>>>>>        
96875>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96875>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96877>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96878>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96880>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96881>>>>>>>            End
96881>>>>>>>>
96881>>>>>>>            If (iScroll>0) Begin
96883>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96884>>>>>>>            End
96884>>>>>>>>
96884>>>>>>>        End
96884>>>>>>>>
96884>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96886>>>>>>>            // if this can fit by moving all the way to left, do so.
96886>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96888>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96889>>>>>>>            End
96889>>>>>>>>
96889>>>>>>>            Else Begin
96890>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96891>>>>>>>            End
96891>>>>>>>>
96891>>>>>>>            If (iScroll<0) Begin
96893>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96894>>>>>>>            End
96894>>>>>>>>
96894>>>>>>>        End
96894>>>>>>>>
96894>>>>>>>        
96894>>>>>>>        
96894>>>>>>>    End_Procedure
96895>>>>>>>    
96895>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96895>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96897>>>>>>>        Boolean bScrollOnFocus
96897>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96898>>>>>>>        If bScrollOnFocus Begin
96900>>>>>>>            Send ScrollObjectInRange hoControl
96901>>>>>>>        End
96901>>>>>>>>
96901>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96903>>>>>>>    End_Procedure
96904>>>>>>>    
96904>>>>>>>    
96904>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96906>>>>>>>        Boolean bCenter
96906>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96907>>>>>>>        Function_Return bCenter
96908>>>>>>>    End_Function
96909>>>>>>>    
96909>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96911>>>>>>>        Boolean bTabWorkspaceView
96911>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96912>>>>>>>        If bTabWorkspaceView Begin
96914>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96915>>>>>>>        End
96915>>>>>>>>
96915>>>>>>>    End_Procedure
96916>>>>>>>    
96916>>>>>>>    Function ParentView Returns Handle
96918>>>>>>>        Function_Return (Parent(Parent(Self)))
96919>>>>>>>    End_Function
96920>>>>>>>    
96920>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96922>>>>>>>        Integer iSize iMax iDiff
96922>>>>>>>        Handle hoView
96922>>>>>>>        Boolean bCenter bModal
96922>>>>>>>        Get ParentView to hoView
96923>>>>>>>        Get Block_Mouse_State of hoView to bModal
96924>>>>>>>        If not bModal Begin
96926>>>>>>>            Get CenterTabWorkspaceView to bCenter
96927>>>>>>>            Get GuiSize of hoView to iSize
96928>>>>>>>            Get piMaxSize of hoView to iMax
96929>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
96930>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
96932>>>>>>>                If bCenter Begin
96934>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
96935>>>>>>>                End
96935>>>>>>>>
96935>>>>>>>                Move (Low(iMax)) to iWidth
96936>>>>>>>            End
96936>>>>>>>>
96936>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
96938>>>>>>>                If bCenter Begin
96940>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
96941>>>>>>>                    Move (iLocy min 25) to  iLocY
96942>>>>>>>                End
96942>>>>>>>>
96942>>>>>>>                Move (Hi(imax)) to iHeight
96943>>>>>>>            End
96943>>>>>>>>
96943>>>>>>>        End
96943>>>>>>>>
96943>>>>>>>    End_Procedure
96944>>>>>>>    
96944>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
96944>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
96944>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
96944>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
96944>>>>>>>    // This should almost always yield the right answer.
96944>>>>>>>    // This is called by the scrolling container's end_constructor
96944>>>>>>>    Procedure AutoSetTabWorkspaceView
96946>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
96946>>>>>>>        Handle hoParent
96946>>>>>>>        Integer iSize
96946>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
96947>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
96949>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
96950>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
96950>>>>>>>            // change this after the commandbar is paged.
96950>>>>>>>            If (bTabView) Begin
96952>>>>>>>                Get ParentView to hoParent
96953>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
96954>>>>>>>                If (bIsView) Begin
96956>>>>>>>                    // set this as a tab workspace view
96956>>>>>>>                    Set pbTabWorkspaceView to True
96957>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
96957>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
96957>>>>>>>                    Set pbAutoScroll to True
96958>>>>>>>                    
96958>>>>>>>                End
96958>>>>>>>>
96958>>>>>>>            End
96958>>>>>>>>
96958>>>>>>>        End
96958>>>>>>>>
96958>>>>>>>    End_Procedure
96959>>>>>>>    
96959>>>>>>>End_Class
96960>>>>>>>
96960>>>>>>>// Container scrolling class support. Nothing in here is public
96960>>>>>>>Class cScrollingContainerMixin is a Mixin
96961>>>>>>>    
96961>>>>>>>    Procedure Define_cScrollingContainerMixin
96963>>>>>>>        Forward Set Border_Style to Border_None
96965>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
96966>>>>>>>        Forward Set peAnchors to anAll
96968>>>>>>>        
96968>>>>>>>        // forcing scrollbars right away seems to make painting better
96968>>>>>>>        Set Window_Style WS_HSCROLL to True
96969>>>>>>>        Set Window_Style WS_VSCROLL to True
96970>>>>>>>        
96970>>>>>>>        Property Handle phoScrollingClientArea 0
96971>>>>>>>    End_Procedure
96972>>>>>>>    
96972>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
96972>>>>>>>    Procedure Set peAnchors Integer eAnchors
96974>>>>>>>    End_Procedure
96975>>>>>>>    
96975>>>>>>>    // if a border style is set, it will not work. We won't let that happen
96975>>>>>>>    Procedure Set Border_Style Integer eStyle
96977>>>>>>>    End_Procedure
96978>>>>>>>    
96978>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
96978>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96980>>>>>>>        Handle hoClient
96980>>>>>>>        Get phoScrollingClientArea to hoClient
96981>>>>>>>        If hoClient Begin
96983>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
96984>>>>>>>        End
96984>>>>>>>>
96984>>>>>>>    End_Procedure
96985>>>>>>>    
96985>>>>>>>    // should be sent by WM_VSCROLL
96985>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96987>>>>>>>        Handle hoClient
96987>>>>>>>        Get phoScrollingClientArea to hoClient
96988>>>>>>>        If hoClient Begin
96990>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
96991>>>>>>>        End
96991>>>>>>>>
96991>>>>>>>    End_Procedure
96992>>>>>>>    
96992>>>>>>>    // should be sent by WM_HSCROLL
96992>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96994>>>>>>>        Handle hoClient
96994>>>>>>>        Get phoScrollingClientArea to hoClient
96995>>>>>>>        If hoClient Begin
96997>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
96998>>>>>>>        End
96998>>>>>>>>
96998>>>>>>>    End_Procedure
96999>>>>>>>    
96999>>>>>>>    // augmented to adjust its size to the size of the parent client area.
96999>>>>>>>    // After this is set, anchors will handle any further resizing.
96999>>>>>>>    Procedure Page Integer iState
97001>>>>>>>        Integer iSiz iHeight iWidth
97001>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97001>>>>>>>        Boolean bGroup
97001>>>>>>>        Handle hoClient
97001>>>>>>>        If (iState =1) Begin
97003>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97005>>>>>>>            // We have special code to support groups because they
97005>>>>>>>            // draw a border inside of the client rectangle
97005>>>>>>>            If bGroup Begin
97007>>>>>>>                Get Physical_FontSize to iFontSize
97008>>>>>>>                Move (Hi(iFontSize)) to iTop
97009>>>>>>>                Move 2 to iLeft
97010>>>>>>>                Move 2 to iRight
97011>>>>>>>                Move 2 to iBottom
97012>>>>>>>            End
97012>>>>>>>>
97012>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97012>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97012>>>>>>>            // makes anchors work properly with unpaged tab-pages
97012>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97014>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97015>>>>>>>            Set GuiLocation to iTop iLeft
97016>>>>>>>            Send Adjust_Logicals
97017>>>>>>>        End
97017>>>>>>>>
97017>>>>>>>        Forward Send Page iState
97019>>>>>>>    End_Procedure
97020>>>>>>>    
97020>>>>>>>    Procedure End_Construct_Object
97022>>>>>>>        Handle hoClient
97022>>>>>>>        Forward Send End_Construct_Object
97024>>>>>>>        Get phoScrollingClientArea to hoClient
97025>>>>>>>        If (hoClient) Begin
97027>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97028>>>>>>>        End
97028>>>>>>>>
97028>>>>>>>    End_Procedure
97029>>>>>>>    
97029>>>>>>>End_Class
97030>>>>>
97030>>>>>Class cDbScrollingClientArea is a dbContainer3d
97031>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97032>>>>>    Procedure Construct_Object
97034>>>>>        Forward Send Construct_Object
97036>>>>>        Send Define_cScrollingClientAreaMixin
97037>>>>>    End_Procedure
97038>>>>>End_Class
97039>>>>>
97039>>>>>
97039>>>>>
97039>>>>>Class cDbScrollingContainer is a dbContainer3d
97040>>>>>    Import_Class_Protocol cScrollingContainerMixin
97041>>>>>    Procedure Construct_Object
97043>>>>>        Forward Send Construct_Object
97045>>>>>        Send Define_cScrollingContainerMixin
97046>>>>>    End_Procedure
97047>>>>>End_Class
97048>>>Use cDbUpdateFunctionLibrary.pkg
97048>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97048>>>>>//****************************************************************************
97048>>>>>// $Module type: Package
97048>>>>>// $Module name: cRDCButtonDPI.pkg
97048>>>>>//
97048>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97048>>>>>// Copyright (c) 2013 RDC Tools International
97048>>>>>// E-mail      : support@rdctools.com
97048>>>>>// Web-site    : http://www.rdctools.com
97048>>>>>//
97048>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97048>>>>>//
97048>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97048>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97048>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97048>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97048>>>>>// in the help folder for more details.
97048>>>>>//
97048>>>>>//****************************************************************************
97048>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
97048>>>>>>>//****************************************************************************
97048>>>>>>>// $Module type: Package
97048>>>>>>>// $Module name: cRDCButton.pkg
97048>>>>>>>//
97048>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97048>>>>>>>// Copyright (c) 2013 RDC Tools International
97048>>>>>>>// E-mail      : support@rdctools.com
97048>>>>>>>// Web-site    : http://www.rdctools.com
97048>>>>>>>//
97048>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97048>>>>>>>//
97048>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97048>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97048>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97048>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97048>>>>>>>// in the help folder for more details.
97048>>>>>>>//
97048>>>>>>>//****************************************************************************
97048>>>>>>>Use Windows.pkg
97048>>>>>>>Use Enclient.pkg
97048>>>>>>>Use errornum.inc
97048>>>>>>>
97048>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97049>>>>>>>    Procedure Construct_Object
97051>>>>>>>        Forward Send Construct_Object
97053>>>>>>>
97053>>>>>>>    End_Procedure
97054>>>>>>>
97054>>>>>>>    Procedure OnIdle
97056>>>>>>>        Delegate Send DoUpdate
97058>>>>>>>    End_Procedure
97059>>>>>>>
97059>>>>>>>End_Class
97060>>>>>>>
97060>>>>>>>Class cRDCButton is a Button
97061>>>>>>>
97061>>>>>>>    Procedure Construct_Object
97063>>>>>>>        Forward Send Construct_Object
97065>>>>>>>
97065>>>>>>>        Property Boolean pbAutoEnable True
97066>>>>>>>
97066>>>>>>>        Property Boolean pbEnabled True
97067>>>>>>>
97067>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97068>>>>>>>
97068>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97069>>>>>>>    End_Procedure
97070>>>>>>>
97070>>>>>>>    Procedure CancelIfPopupObject
97072>>>>>>>        Boolean bIsInPopupObject
97072>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97074>>>>>>>        If (bIsInPopupObject = True) Begin
97076>>>>>>>            Send Close_Panel
97077>>>>>>>        End
97077>>>>>>>>
97077>>>>>>>    End_Procedure
97078>>>>>>>
97078>>>>>>>    Procedure End_Construct_Object
97080>>>>>>>        String sTooltip sStatus_Help
97080>>>>>>>
97080>>>>>>>        Forward Send End_Construct_Object
97082>>>>>>>
97082>>>>>>>        Get psToolTip   to sTooltip
97083>>>>>>>        Get Status_Help to sStatus_Help
97084>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97086>>>>>>>            Set psToolTip to sStatus_Help
97087>>>>>>>        End
97087>>>>>>>>
97087>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97089>>>>>>>            Set Status_Help to sToolTip
97090>>>>>>>        End
97090>>>>>>>>
97090>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97091>>>>>>>    End_Procedure
97092>>>>>>>
97092>>>>>>>    Procedure DoUpdate
97094>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97096>>>>>>>            Procedure_Return
97097>>>>>>>        End
97097>>>>>>>>
97097>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97098>>>>>>>    End_Procedure
97099>>>>>>>
97099>>>>>>>    Function IsEnabled Returns Boolean
97101>>>>>>>        Boolean bEnabled
97101>>>>>>>        Get pbEnabled to bEnabled
97102>>>>>>>        Function_Return bEnabled
97103>>>>>>>    End_Function
97104>>>>>>>
97104>>>>>>>    // Enable the idle handler timer when the button is activated
97104>>>>>>>    Procedure Activating
97106>>>>>>>        Forward Send Activating
97108>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97109>>>>>>>    End_Procedure
97110>>>>>>>
97110>>>>>>>    // Disable the idle handler when the button is deactivated
97110>>>>>>>    Procedure Deactivating
97112>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97113>>>>>>>        Forward Send Deactivating
97115>>>>>>>    End_Procedure
97116>>>>>>>
97116>>>>>>>End_Class
97117>>>>>
97117>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97117>>>>>Class cRDCButtonDPI is a cRDCButton
97118>>>>>    Procedure Construct_Object
97120>>>>>        Integer iIconSize
97120>>>>>        Forward Send Construct_Object
97122>>>>>        Set piImageMarginLeft to 10
97123>>>>>    End_Procedure
97124>>>>>
97124>>>>>    // Returns: DPI setting as an integer.
97124>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97124>>>>>    //                      iDPI=120 is "Medium setting" 125%
97124>>>>>    //                      iDPI= 144 is "Large setting" 150%
97124>>>>>    Function GetCurrentDPI Returns Integer
97126>>>>>        Handle hDC
97126>>>>>        Integer iPixelsX
97126>>>>>        Move (GetDC(0)) to hDC
97127>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97128>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97129>>>>>        Function_Return iPixelsX
97130>>>>>    End_Function
97131>>>>>
97131>>>>>    Function GetCorrectIconSize Returns Integer
97133>>>>>        Integer iPixelsX iIndex iSize
97133>>>>>        Integer[] iaSizes
97134>>>>>
97134>>>>>        Move 16 to iaSizes[0]
97135>>>>>        Move 24 to iaSizes[1]
97136>>>>>        Move 32 to iaSizes[2]
97137>>>>>        Move 48 to iaSizes[3]
97138>>>>>        Move 64 to iaSizes[4]
97139>>>>>
97139>>>>>        Get piImageSize to iSize  // the "100%" size
97140>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97141>>>>>        Move (0 max iIndex) to iIndex
97142>>>>>        Get GetCurrentDPI to iPixelsX
97143>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97143>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97143>>>>>        // will increment iIndex as many times as we need here.
97143>>>>>        Case Begin
97143>>>>>            Case (iPixelsX > 144)
97145>>>>>                Increment iIndex
97146>>>>>            Case (iPixelsX = 144)
97149>>>>>                Increment iIndex
97150>>>>>            Case (iPixelsX = 120)
97153>>>>>                Increment iIndex
97154>>>>>        Case End
97154>>>>>        Move (iIndex min 4) to iIndex
97155>>>>>        Function_Return iaSizes[iIndex]
97156>>>>>    End_Function
97157>>>>>
97157>>>>>    Procedure Set psToolTip String sToolTip
97159>>>>>        String sStatusHelp
97159>>>>>
97159>>>>>        Get Status_Help to sStatusHelp
97160>>>>>        If (sStatusHelp = "") Begin
97162>>>>>            Set Status_Help to sToolTip
97163>>>>>        End
97163>>>>>>
97163>>>>>
97163>>>>>        Forward Set psToolTip to sToolTip
97165>>>>>    End_Procedure
97166>>>>>
97166>>>>>End_Class
97167>>>Use DatabaseSelection.dg
97167>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97167>>>>>Use Windows.pkg
97167>>>>>Use cCJGridPromptList.pkg
97167>>>>>Use MSSqldrv.pkg
97167>>>>>Use db2_drv.pkg
97167>>>>>Use odbc_drv.pkg    
97167>>>>>Use cRDCModalPanel.pkg
97167>>>>>Use cDbUpdateFunctionLibrary.pkg
97167>>>>>
97167>>>>>Object oServerSelection_sl is a cRDCModalPanel
97169>>>>>    Set Size to 105 225
97170>>>>>    Set Label to "Database Server/DSN Selection"
97171>>>>>    Set piMinSize to 89 211
97172>>>>>    Set Location to 2 2
97173>>>>>    Set Icon to "ServerLookup1.ico"
97174>>>>>
97174>>>>>    Property String[] psTheData
97176>>>>>
97176>>>>>    Object oSelList is a cCJGridPromptList
97178>>>>>        Set Size to 72 215
97179>>>>>        Set Location to 6 6
97180>>>>>        Set peAnchors to anAll
97181>>>>>        Set pbAllowColumnRemove to False
97182>>>>>        Set pbUseAlternateRowBackgroundColor to True
97183>>>>>        Set pbGrayIfDisable to False
97184>>>>>        Set pbHeaderReorders to False
97185>>>>>        Set pbHeaderSelectsColumn to False
97186>>>>>        Set pbHeaderTogglesDirection to False
97187>>>>>        Set pbShadeSortColumn to False
97188>>>>>        Set piFocusCellBackColor to clDkGray
97189>>>>>
97189>>>>>        Object oName is a cCJGridColumn
97191>>>>>            Set piWidth to 358
97192>>>>>            Set psCaption to "Name"
97193>>>>>        End_Object
97194>>>>>
97194>>>>>        Procedure Activating
97197>>>>>            tDataSourceRow[] MyData
97197>>>>>            tDataSourceRow[] MyData
97198>>>>>            Handle hoDataSource
97198>>>>>            String[] sTheData
97199>>>>>            Integer iCount iSize
97199>>>>>
97199>>>>>            Send Cursor_Wait of Cursor_Control
97200>>>>>            Get psTheData to sTheData
97201>>>>>            Move (SizeOfArray(sTheData)) to iSize
97202>>>>>            Decrement iSize
97203>>>>>            For iCount from 0 to iSize
97209>>>>>>
97209>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97210>>>>>            Loop
97211>>>>>>
97211>>>>>
97211>>>>>            Forward Send Activating
97213>>>>>
97213>>>>>            Get phoDataSource to hoDataSource
97214>>>>>            Send InitializeData of hoDataSource MyData
97215>>>>>            Send Cursor_Ready of Cursor_Control
97216>>>>>        End_Procedure
97217>>>>>
97217>>>>>    End_Object
97218>>>>>
97218>>>>>    Object oOK_Btn is a Button
97220>>>>>        Set Size to 14 50
97221>>>>>        Set Label    to "&OK"
97222>>>>>        Set Location to 85 116
97223>>>>>        Set peAnchors To anBottomRight
97224>>>>>
97224>>>>>        Procedure OnClick
97227>>>>>            Send Ok of oSelList
97228>>>>>        End_Procedure
97229>>>>>
97229>>>>>    End_Object
97230>>>>>
97230>>>>>    Object oCancel_Btn is a Button
97232>>>>>        Set Size to 14 50
97233>>>>>        Set Label    to "&Cancel"
97234>>>>>        Set Location to 85 171
97235>>>>>        Set peAnchors to anBottomRight
97236>>>>>
97236>>>>>        Procedure OnClick
97239>>>>>            Send Close_Panel
97240>>>>>        End_Procedure
97241>>>>>
97241>>>>>    End_Object
97242>>>>>
97242>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97243>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97244>>>>>End_Object
97245>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97245>>>>>Use Windows.pkg
97245>>>>>Use cCJGridPromptList.pkg
97245>>>>>Use cDbUpdateFunctionLibrary.pkg
97245>>>>>Use MSSqldrv.pkg
97245>>>>>Use db2_drv.pkg
97245>>>>>Use odbc_drv.pkg
97245>>>>>Use cCJGridColumn.pkg
97245>>>>>
97245>>>>>Object oSQLConnections is a ModalPanel
97247>>>>>    Set Label to "SQL Connections"
97248>>>>>    Set Size to 121 397
97249>>>>>    Set piMinSize to 89 185
97250>>>>>    Set Location to 2 2
97251>>>>>    Set Border_Style to Border_Thick
97252>>>>>
97252>>>>>    Property tSQLConnection[] psTheData
97254>>>>>
97254>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
97254>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97254>>>>>//        End_Object
97254>>>>>//    End
97254>>>>>
97254>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97256>>>>>        Set Size to 90 377
97257>>>>>        Set Location to 6 6
97258>>>>>        Set peAnchors to anAll
97259>>>>>        Set pbAllowColumnRemove to False
97260>>>>>        Set pbUseAlternateRowBackgroundColor to True
97261>>>>>        Set pbGrayIfDisable to False
97262>>>>>        Set pbHeaderReorders to False
97263>>>>>        Set pbHeaderSelectsColumn to False
97264>>>>>        Set pbHeaderTogglesDirection to False
97265>>>>>        Set pbShadeSortColumn to False
97266>>>>>        Set piFocusCellBackColor to clDkGray  
97267>>>>>        Set pbRestoreLayout to True
97268>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97269>>>>>
97269>>>>>        Object oID_Col is a cCJGridColumn
97271>>>>>            Set piWidth to 132
97272>>>>>            Set psCaption to "ID"
97273>>>>>        End_Object
97274>>>>>
97274>>>>>        Object oDbType_Col is a cCJGridColumn
97276>>>>>            Set piWidth to 182
97277>>>>>            Set psCaption to "Database Type"
97278>>>>>        End_Object
97279>>>>>
97279>>>>>        Object oServer_Col is a cCJGridColumn
97281>>>>>            Set piWidth to 296
97282>>>>>            Set psCaption to "Server/DSN"
97283>>>>>        End_Object
97284>>>>>
97284>>>>>        Object oDatabase_Col is a cCJGridColumn
97286>>>>>            Set piWidth to 211
97287>>>>>            Set psCaption to "Database"
97288>>>>>        End_Object
97289>>>>>
97289>>>>>        Object oDriverID_Col is a cCJGridColumn
97291>>>>>            Set piWidth to 121
97292>>>>>            Set psCaption to "Driver ID"
97293>>>>>        End_Object
97294>>>>>
97294>>>>>        Procedure Activating
97297>>>>>            tDataSourceRow[] MyData
97297>>>>>            tDataSourceRow[] MyData
97298>>>>>            Handle hoDataSource
97298>>>>>            Integer iCount iSize iPos
97298>>>>>            String sDriverID sConnectionID sValue
97298>>>>>            tSQLConnection[] sTheData
97298>>>>>            tSQLConnection[] sTheData
97299>>>>>
97299>>>>>            Send Cursor_Wait of Cursor_Control
97300>>>>>            Forward Send Activating
97302>>>>>
97302>>>>>            Get psTheData to sTheData
97303>>>>>            Move (SizeOfArray(sTheData)) to iSize
97304>>>>>            Decrement iSize
97305>>>>>            For iCount from 0 to iSize
97311>>>>>>
97311>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97312>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97313>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97314>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97315>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97316>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97317>>>>>            Loop
97318>>>>>>
97318>>>>>
97318>>>>>            Get phoDataSource to hoDataSource
97319>>>>>            Send InitializeData of hoDataSource MyData
97320>>>>>            Send Cursor_Ready of Cursor_Control
97321>>>>>        End_Procedure
97322>>>>>
97322>>>>>    End_Object
97323>>>>>
97323>>>>>    Object oOK_Btn is a Button
97325>>>>>        Set Label    to "&OK"
97326>>>>>        Set Location to 101 280
97327>>>>>        Set peAnchors to anBottomRight
97328>>>>>
97328>>>>>        Procedure OnClick
97331>>>>>            Send Ok of oSelListSQLConnections
97332>>>>>        End_Procedure
97333>>>>>
97333>>>>>    End_Object
97334>>>>>
97334>>>>>    Object oCancel_Btn is a Button
97336>>>>>        Set Label    to "&Cancel"
97337>>>>>        Set Location to 101 335
97338>>>>>        Set peAnchors to anBottomRight
97339>>>>>
97339>>>>>        Procedure OnClick
97342>>>>>            Send Close_Panel
97343>>>>>        End_Procedure
97344>>>>>
97344>>>>>    End_Object
97345>>>>>
97345>>>>>    Procedure Page Integer iPageObject
97348>>>>>        Set Icon to "SQLConnections1.ico"
97349>>>>>        Forward Send Page iPageObject
97351>>>>>    End_Procedure
97352>>>>>
97352>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97353>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97354>>>>>End_Object
97355>>>
97355>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97365>>>>
97365>>>Object oSQLConnections_vw is a dbView
97367>>>    Set Border_Style to Border_Thick
97368>>>    Set Size to 251 427
97369>>>    Set Location to 2 2
97370>>>    Set Label to "SQL Connections"
97371>>>    Set pbAutoActivate to True
97372>>>    Set Icon to "SQLConnections1.ico"
97373>>>
97373>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97375>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97377>>>
97377>>>            Object oCurrentSettings_grp is a Group
97379>>>                Set Size to 232 402
97380>>>                Set Location to 6 12
97381>>>                Set Label to "Current Connection Settings"
97382>>>                Set peAnchors to anAll
97383>>>
97383>>>                Object oConnectionID_fm is a Form
97385>>>                    Set Size to 12 100
97386>>>                    Set Location to 12 68
97387>>>                    Set Label to "Connection ID"
97388>>>                    Set Label_Col_Offset to 2
97389>>>                    Set Label_Justification_Mode to JMode_Right
97390>>>                    Set Prompt_Button_Mode to PB_PromptOn
97391>>>                    Set Prompt_Object to (oSQLConnections(Self))
97392>>>
97392>>>                    Procedure Prompt
97395>>>                        String[] sTheData
97396>>>                        String sCurrentVal sNewVal
97396>>>                        Handle hoIniFile ho
97396>>>                        Integer iSize iCount
97396>>>                        tSQLConnection[] SQLConnectionArray
97396>>>                        tSQLConnection[] SQLConnectionArray
97397>>>
97397>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97398>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97399>>>                        Get Value to sCurrentVal
97400>>>                        Get Prompt_Object to ho
97401>>>                        Set psTheData of ho to SQLConnectionArray
97402>>>
97402>>>                        Forward Send Prompt
97404>>>                        Get Value to sNewVal
97405>>>                        If (sCurrentVal <> sNewVal) Begin
97407>>>                            Send Cursor_Wait of Cursor_Control
97408>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97409>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97411>>>                            Send Cursor_Ready of Cursor_Control
97412>>>                            Send KeyAction of oTestLogin_btn
97413>>>                        End
97413>>>>
97413>>>                    End_Procedure   
97414>>>                    
97414>>>                    Procedure PromptUpdate Handle hoPrompt
97417>>>                        String[] sSelectedNames                    
97418>>>                
97418>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97419>>>                        If (SizeOfArray(sSelectedNames)) Begin
97421>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97422>>>                            Delegate Send Page True // Broadcast sends refresh
97424>>>                        End
97424>>>>
97424>>>                    End_Procedure   
97425>>>
97425>>>                    Procedure Prompt_Callback Handle hoPrompt
97428>>>                        String sServer
97428>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97429>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97430>>>                        Get Value of oServer_fm to sServer
97431>>>                        Set psSeedValue of hoPrompt to sServer
97432>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97433>>>                    End_Procedure
97434>>>
97434>>>                    Procedure Refresh
97437>>>                        String sValue
97437>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97438>>>                        Set Value to sValue
97439>>>                    End_Procedure
97440>>>
97440>>>                End_Object
97441>>>
97441>>>                Object oDriverID_cf is a ComboForm
97443>>>                    Set Size to 12 91
97444>>>                    Set Location to 12 222
97445>>>                    Set Label_Col_Offset to 2
97446>>>                    Set Label_Justification_Mode to JMode_Right
97447>>>                    Set Label to "Driver ID"
97448>>>                    Set Entry_State to False
97449>>>                    Set Enabled_State to False
97450>>>
97450>>>                    Procedure Combo_Fill_List
97453>>>                        Send Combo_Add_Item MSSQLDRV_ID
97454>>>                        Send Combo_Add_Item DB2_DRV_ID
97455>>>                        Send Combo_Add_Item ODBC_DRV_ID
97456>>>                    End_Procedure
97457>>>
97457>>>                    Procedure OnChange
97460>>>                        String sValue sOrgValue
97460>>>                        Boolean bEnabled bChecked
97460>>>
97460>>>                        Get Value to sValue
97461>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97462>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97464>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97465>>>                        End
97465>>>>
97465>>>                        Move (sValue <> "None") to bEnabled
97466>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97468>>>                        Set Enabled_State to False
97469>>>                        Set Enabled_State of oConnectionString_fm to False
97470>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97471>>>
97471>>>                        Get Checked_State of oTrusted_cb  to bChecked
97472>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97473>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97474>>>                    End_Procedure
97475>>>
97475>>>                    Procedure Refresh
97478>>>                        String sValue
97478>>>
97478>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97479>>>                        Set Value to sValue
97480>>>                    End_Procedure
97481>>>
97481>>>                End_Object
97482>>>
97482>>>                Object oServer_fm is a Form
97484>>>                    Set Size to 12 100
97485>>>                    Set Location to 26 68
97486>>>                    Set Label to "Server"
97487>>>                    Set Label_Col_Offset to 2
97488>>>                    Set Label_Justification_Mode to JMode_Right
97489>>>                    Set Prompt_Button_Mode to PB_PromptOn
97490>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97491>>>
97491>>>                    Procedure Refresh
97494>>>                        String sValue
97494>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97495>>>                        Set Value to sValue
97496>>>                    End_Procedure
97497>>>
97497>>>                    Procedure Prompt
97500>>>                        String[] sTheData
97501>>>                        String sDriverID
97501>>>                        Handle ho
97501>>>
97501>>>                        Send Cursor_Wait of Cursor_Control
97502>>>                        Get Prompt_Object to ho
97503>>>                        Get Value of oDriverID_cf to sDriverID
97504>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97505>>>                        Set psTheData of ho to sTheData
97506>>>                        Send Cursor_Ready of Cursor_Control
97507>>>
97507>>>                        Forward Send Prompt
97509>>>                    End_Procedure
97510>>>
97510>>>                End_Object
97511>>>
97511>>>                Object oDatabase_fm is a Form
97513>>>                    Set Size to 12 91
97514>>>                    Set Location to 26 222
97515>>>                    Set Label to "Database"
97516>>>                    Set Label_Col_Offset to 2
97517>>>                    Set Label_Justification_Mode to JMode_Right
97518>>>                    Set Prompt_Button_Mode to PB_PromptOn
97519>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97520>>>                    Set peAnchors to anNone
97521>>>                    Set Entry_State to False
97522>>>
97522>>>                    Procedure Refresh
97525>>>                        String sDatabase
97525>>>
97525>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97526>>>                        Set Value to sDatabase
97527>>>                    End_Procedure
97528>>>
97528>>>                    Procedure Prompt
97531>>>                        String[] sTheData
97532>>>                        Handle ho
97532>>>                        String sDriverID
97532>>>
97532>>>                        Get Value of oDriverID_cf to sDriverID
97533>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97534>>>
97534>>>                        Get Prompt_Object to ho
97535>>>                        Set psTheData of ho to sTheData
97536>>>
97536>>>                        Forward Send Prompt
97538>>>                    End_Procedure
97539>>>
97539>>>                    Procedure OnChange
97542>>>                        String sValue sOrgValue
97542>>>                        Get Value to sValue
97543>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97544>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97546>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97547>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97548>>>                            Set Value of oConnectionString_fm to sValue
97549>>>                        End
97549>>>>
97549>>>                    End_Procedure
97550>>>
97550>>>                End_Object
97551>>>
97551>>>                Object oTrusted_cb is a CheckBox
97553>>>                    Set Size to 10 50
97554>>>                    Set Location to 45 68
97555>>>                    Set Label to "Use Trusted Connection"
97556>>>
97556>>>                    Procedure Refresh
97559>>>                        Boolean bValue
97559>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97560>>>                        Set Checked_State to bValue
97561>>>                    End_Procedure
97562>>>
97562>>>                    Procedure OnChange
97565>>>                        Boolean bChecked
97565>>>
97565>>>                        Get Checked_State to bChecked
97566>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97567>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97568>>>                    End_Procedure
97569>>>
97569>>>                End_Object
97570>>>
97570>>>                Object oUserID_fm is a Form
97572>>>                    Set Size to 12 100
97573>>>                    Set Location to 57 68
97574>>>                    Set Label to "UserID"
97575>>>                    Set Label_Col_Offset to 2
97576>>>                    Set Label_Justification_Mode to JMode_Right
97577>>>
97577>>>                    Procedure Refresh
97580>>>                        String sValue
97580>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97581>>>                        Set Value to sValue
97582>>>                    End_Procedure
97583>>>
97583>>>                End_Object
97584>>>
97584>>>                Object oPassword_fm is a Form
97586>>>                    Set Size to 12 91
97587>>>                    Set Location to 57 222
97588>>>                    Set Label to "Password"
97589>>>                    Set Label_Col_Offset to 2
97590>>>                    Set Label_Justification_Mode to JMode_Right
97591>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97591>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97592>>>                    Set Password_State to True
97593>>>
97593>>>                    Procedure Refresh
97596>>>                        String sValue
97596>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97597>>>                        Set Value to sValue
97598>>>                    End_Procedure
97599>>>
97599>>>                End_Object
97600>>>
97600>>>                Object oViewPassword_btn is a cRDCButtonDPI
97602>>>                    Set Size to 12 19
97603>>>                    Set Location to 57 317
97604>>>                    Set psToolTip to "Toggle password"
97605>>>                    Set psImage to "ViewPassword1.ico"
97606>>>                    Set piImageMarginLeft to 0
97607>>>
97607>>>                    Procedure OnClick
97610>>>                        Boolean bState
97610>>>                        Get Password_State of oPassword_fm to bState
97611>>>                        Send Page_Object   of oPassword_fm False
97612>>>                        Set Password_State of oPassword_fm to (not(bState))
97613>>>                        Send Page_Object   of oPassword_fm True
97614>>>                    End_Procedure
97615>>>
97615>>>                End_Object
97616>>>
97616>>>                Object oTestLogin_btn is a cRDCButtonDPI
97618>>>                    Set Size to 12 56
97619>>>                    Set Location to 57 340
97620>>>                    Set Label to "Test Login"
97621>>>                    Set peAnchors to anNone
97622>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97623>>>                    Set FontWeight to fw_Bold
97624>>>                    Set psImage to "ActionLogin1.ico"
97625>>>                    Set piImageMarginLeft to 0
97626>>>
97626>>>                    Procedure OnClick
97629>>>                        tSQLConnection SQLConnection
97629>>>                        tSQLConnection SQLConnection
97629>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97629>>>                        Boolean bTrusted bLoginSuccessful
97629>>>                        Integer iDriverID
97629>>>                        Handle hoDriver
97629>>>
97629>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97630>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97631>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97632>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97633>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97634>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97635>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97636>>>
97636>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97637>>>
97637>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97638>>>                        If (iDriverID = 0) Begin
97640>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97641>>>                            Procedure_Return
97642>>>                        End
97642>>>>
97642>>>
97642>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97645>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97646>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97647>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97648>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97649>>>                        Send Destroy   of hoDriver
97650>>>
97650>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97651>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97653>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97654>>>                            Set Value of oConnectionString_fm to sConnectionString
97655>>>                            Send Info_Box "Login Successful!"
97656>>>                        End
97656>>>>
97656>>>                        Else Begin
97657>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97658>>>                        End
97658>>>>
97658>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97660>>>                        Move 0 to LastErr
97661>>>                    End_Procedure
97662>>>
97662>>>                End_Object
97663>>>
97663>>>                Object oConnectionString_fm is a Form
97665>>>                    Set Size to 12 328
97666>>>                    Set Location to 82 68
97667>>>                    Set Label to "Connection String"    
97668>>>                    Set Label_Col_Offset to 2
97669>>>                    Set Label_Justification_Mode to JMode_Right
97670>>>                    Set peAnchors to anTopLeftRight
97671>>>                    Set Enabled_State to False
97672>>>
97672>>>                    Procedure Refresh
97675>>>                        String sValue
97675>>>                        tSQLConnection SQLConnection
97675>>>                        tSQLConnection SQLConnection
97675>>>
97675>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97676>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97677>>>                        Set Value to sValue
97678>>>                    End_Procedure
97679>>>
97679>>>                End_Object
97680>>>
97680>>>                Object oInfo_tb is a TextBox
97682>>>                    Set Auto_Size_State to False
97683>>>                    Set Size to 18 303
97684>>>                    Set Location to 106 8
97685>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97686>>>                    Set Justification_Mode to JMode_Left
97687>>>                    Set FontItalics to True
97688>>>                End_Object
97689>>>
97689>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97691>>>                    Set Size to 21 83
97692>>>                    Set Location to 106 315
97693>>>                    Set Label to "SQL Connections"
97694>>>                    Set peAnchors to anNone
97695>>>                    Set psImage to "SQLConnections1.ico"
97696>>>
97696>>>                    Procedure OnClick 
97699>>>                        Runprogram Background "DUFSQLConnections.exe"
97700>>>                    End_Procedure
97701>>>
97701>>>                End_Object
97702>>>
97702>>>                Object oGetCollation_btn is a Button
97704>>>                    Set Size to 27 91
97705>>>                    Set Location to 154 38
97706>>>                    Set Label to 'Get Database Collation'
97707>>>                
97707>>>                    Procedure OnClick
97710>>>                        String sCollation sDatabase
97710>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97711>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97712>>>                        Set Value of oGetCollation_fm to sCollation
97713>>>                    End_Procedure
97714>>>                
97714>>>                End_Object
97715>>>
97715>>>                Object oGetCollation_fm is a Form
97717>>>                    Set Size to 12 148
97718>>>                    Set Location to 162 143
97719>>>                    Set Label to "Current SQL Collation Name"
97720>>>                    Set Label_Col_Offset to 0
97721>>>                    Set Label_Row_Offset to 1
97722>>>                    Set Label_Justification_Mode to JMode_Top
97723>>>                End_Object
97724>>>        
97724>>>                Object oSetCollation_btn is a Button
97726>>>                    Set Size to 27 91
97727>>>                    Set Location to 188 38
97728>>>                    Set Label to "Set Database Collation"
97729>>>                
97729>>>                    Procedure OnClick
97732>>>                        String sCollation sDatabase sErrorText
97732>>>                        Boolean bOK
97732>>>                        Integer iRetval  
97732>>>                        tSqlErrorArray aSqlErrorArray
97732>>>                        tSqlErrorArray aSqlErrorArray
97732>>>                        
97732>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97733>>>                        Get Value of oSetCollation_fm to sCollation
97734>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97735>>>                        If (iRetval <> MBR_Yes) Begin
97737>>>                            Procedure_Return
97738>>>                        End
97738>>>>
97738>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97739>>>                        If (bOK = True) Begin
97741>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97742>>>                        End
97742>>>>
97742>>>                        Else Begin                   
97743>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97744>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97745>>>                            Move (sErrorText + "\n")                  to sErrorText
97746>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97747>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97748>>>                        End
97748>>>>
97748>>>
97748>>>                    End_Procedure
97749>>>                
97749>>>                End_Object
97750>>>
97750>>>                Object oSetCollation_fm is a Form
97752>>>                    Set Size to 12 148
97753>>>                    Set Location to 197 143
97754>>>                    Set Label to "New SQL Collation Name"
97755>>>                    Set Label_Col_Offset to 0
97756>>>                    Set Label_Row_Offset to 1
97757>>>                    Set Label_Justification_Mode to JMode_Top
97758>>>                End_Object
97759>>>
97759>>>                Procedure Page Integer iPageObject
97762>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97764>>>                    Forward Send Page iPageObject
97766>>>                End_Procedure
97767>>>
97767>>>            End_Object
97768>>>
97768>>>        End_Object
97769>>>        
97769>>>    End_Object
97770>>>
97770>>>End_Object
97771>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97771>>>Use Windows.pkg
97771>>>Use DFClient.pkg
97771>>>Use Dfspnfrm.pkg
97771>>>Use cDbScrollingContainer.pkg
97771>>>Use cRDCButtonDPI.pkg
97771>>>Use cDbUpdateFunctionLibrary.pkg
97771>>>Use SQLDatabaseBackup.dg
97771>>>
97771>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97781>>>>
97781>>>Object oSQLFunctions_vw is a dbView
97783>>>    Set Border_Style to Border_Thick
97784>>>    Set Size to 260 426
97785>>>    Set Location to -4 2
97786>>>    Set Label to "Functions"
97787>>>    Set pbAutoActivate to True
97788>>>    Set Icon to "Sql1.ico"
97789>>>
97789>>>    Procedure OnSetFocus
97792>>>        String sValue
97792>>>        tSQLConnection SQLConnection
97792>>>        tSQLConnection SQLConnection
97792>>>
97792>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97793>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97794>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97795>>>        Set Value of oSQLConnectionString_fm to sValue
97796>>>    End_Procedure
97797>>>
97797>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97799>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97801>>>
97801>>>            Object oSQLFunctionTests_grp is a Group
97803>>>                Set Size to 243 402
97804>>>                Set Location to 7 12
97805>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97806>>>                Set peAnchors to anAll
97807>>>
97807>>>                Object oSQLConnectionString_fm is a Form
97809>>>                    Set Size to 12 375
97810>>>                    Set Location to 23 14
97811>>>                    Set Label to "Current Connection String Settings:"
97812>>>                    Set Label_Col_Offset to 0
97813>>>                    Set Label_Justification_Mode to JMode_Top
97814>>>                    Set peAnchors to anTopLeftRight
97815>>>                    Set Enabled_State to False
97816>>>                    Set Label_Row_Offset to 1
97817>>>                End_Object
97818>>>
97818>>>                Object oSQLDatabase_fm is a Form
97820>>>                    Set Size to 12 86
97821>>>                    Set Location to 50 14
97822>>>                    Set Label to "Database:"
97823>>>                    Set Label_Col_Offset to 0
97824>>>                    Set Label_Justification_Mode to JMode_Top
97825>>>                    Set Label_Row_Offset to 1
97826>>>                    Set FontWeight to fw_Bold
97827>>>                    Set Enabled_State to False
97828>>>                End_Object
97829>>>
97829>>>                Object oDriverID2_cf is a ComboForm
97831>>>                    Set Size to 12 91
97832>>>                    Set Location to 50 121
97833>>>                    Set Label_Col_Offset to 0
97834>>>                    Set Label_Justification_Mode to JMode_Top
97835>>>                    Set Label to "Driver ID:"
97836>>>                    Set Entry_State to False
97837>>>                    Set Enabled_State to False
97838>>>                    Set Label_Row_Offset to 1
97839>>>
97839>>>                    Procedure Combo_Fill_List
97842>>>                        Send Combo_Add_Item MSSQLDRV_ID
97843>>>                        Send Combo_Add_Item DB2_DRV_ID
97844>>>                        Send Combo_Add_Item ODBC_DRV_ID
97845>>>                    End_Procedure
97846>>>
97846>>>                    Procedure Refresh
97849>>>                        String sValue
97849>>>
97849>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97850>>>                        Set Value to sValue
97851>>>                    End_Procedure
97852>>>
97852>>>                End_Object
97853>>>
97853>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97855>>>                    Set Size to 12 109
97856>>>                    Set Location to 50 220
97857>>>                    Set Label to "Backup MS-SQL Database"
97858>>>                    Set psImage to "DbBackup1.ico"
97859>>>
97859>>>                    Procedure OnClick
97862>>>                        Boolean bOK
97862>>>
97862>>>                        // SQLDatabaseBackup dialog:
97862>>>                        Get MakeSQLDatabaseBackup to bOK
97863>>>
97863>>>                        If (bOK = True) Begin
97865>>>                            Send Info_Box "The backup of the database was successful!"
97866>>>                        End
97866>>>>
97866>>>                        Else Begin
97867>>>                            Send Info_Box "The database was not backup up"
97868>>>                        End
97868>>>>
97868>>>                    End_Procedure
97869>>>
97869>>>                End_Object
97870>>>
97870>>>                Object oDatabaseInfo_tb is a TextBox
97872>>>                    Set Auto_Size_State to False
97873>>>                    Set Size to 25 96
97874>>>                    Set Location to 64 14
97875>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97876>>>                    Set Justification_Mode to JMode_Left
97877>>>                End_Object
97878>>>
97878>>>                Object oSQLInfo_tb is a TextBox
97880>>>                    Set Auto_Size_State to False
97881>>>                    Set Size to 37 270
97882>>>                    Set Location to 76 118
97883>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97884>>>                    Set Justification_Mode to JMode_Left
97885>>>                End_Object
97886>>>
97886>>>                Object oSQLTableName_cf is a ComboForm
97888>>>                    Set Size to 12 96
97889>>>                    Set Location to 106 14
97890>>>                    Set Label_Col_Offset to 0
97891>>>                    Set Label_Justification_Mode to JMode_Top
97892>>>                    Set Label to "Select Table:"
97893>>>                    Set Label_Row_Offset to 1
97894>>>                    Set Entry_State to False
97895>>>
97895>>>                    Procedure OnDropDown
97898>>>                        Send DoCombo_Fill_List
97899>>>                    End_Procedure
97900>>>
97900>>>                    Procedure OnCloseUp
97903>>>                        Send Delete_Data of oSQLColumnName_cf
97904>>>                    End_Procedure
97905>>>
97905>>>                    Procedure DoCombo_Fill_List
97908>>>                        String[] sTablesArray
97909>>>                        String sDriverID
97909>>>                        Integer iCount iSize
97909>>>
97909>>>                        Send Delete_Data
97910>>>                        Get Value of oDriverID2_cf to sDriverID
97911>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97912>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97913>>>                        Decrement iSize
97914>>>                        For iCount from 0 to iSize
97920>>>>
97920>>>                            Send Combo_Add_Item sTablesArray[iCount]
97921>>>                        Loop
97922>>>>
97922>>>                    End_Procedure
97923>>>
97923>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97923>>>                    // Augmented Value function.
97923>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97923>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97923>>>                    Function Value Integer iItem Returns String
97926>>>                        String sValue
97926>>>                        Get WinCombo_Current_Item to iItem
97927>>>                        Get WinCombo_Value iItem  to sValue
97928>>>                        Function_Return sValue
97929>>>                    End_Function
97930>>>
97930>>>                End_Object
97931>>>
97931>>>                Object oSQLColumnName_cf is a ComboForm
97933>>>                    Set Size to 12 96
97934>>>                    Set Location to 134 14
97935>>>                    Set Label_Col_Offset to 0
97936>>>                    Set Label_Justification_Mode to JMode_Top
97937>>>                    Set Label to "Select Column:"
97938>>>                    Set Label_Row_Offset to 1
97939>>>                    Set Entry_State to False
97940>>>
97940>>>                    Procedure DoCombo_Fill_List
97943>>>                        String[] sColumnsArray
97944>>>                        String sTableName sDriverID
97944>>>                        Integer iCount iSize
97944>>>
97944>>>                        Send Delete_Data
97945>>>                        Get Value of oDriverID2_cf    to sDriverID
97946>>>                        Get Value of oSQLTableName_cf to sTableName
97947>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
97948>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
97949>>>                        Decrement iSize
97950>>>                        For iCount from 0 to iSize
97956>>>>
97956>>>                            Send Combo_Add_Item sColumnsArray[iCount]
97957>>>                        Loop
97958>>>>
97958>>>                        If (iSize > 1) Begin
97960>>>                            Set Current_Item to 1
97961>>>                        End
97961>>>>
97961>>>                    End_Procedure
97962>>>
97962>>>                    Procedure OnDropDown
97965>>>                        Send DoCombo_Fill_List
97966>>>                    End_Procedure
97967>>>                End_Object
97968>>>
97968>>>                Object oSQLRenameColumnTo_fm is a Form
97970>>>                    Set Size to 12 96
97971>>>                    Set Location to 134 116
97972>>>                    Set Label_Col_Offset to 0
97973>>>                    Set Label_Justification_Mode to JMode_Top
97974>>>                    Set Label to "Rename Column To:"
97975>>>                    Set Label_Row_Offset to 1
97976>>>                    Set Value to "NewColumnName"
97977>>>                End_Object
97978>>>
97978>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
97980>>>                    Set Size to 12 69
97981>>>                    Set Location to 134 220
97982>>>                    Set Label to "Rename Column"
97983>>>                    Set psToolTip to "Test of SQLColumnRename function"
97984>>>                    Set MultiLineState to True
97985>>>
97985>>>                    Procedure OnClick
97988>>>                        Boolean bOk
97988>>>                        Handle hTable
97988>>>                        String sTableName sColumnName sNewColumnName sDriverID
97988>>>
97988>>>                        Get Value of oSQLTableName_cf to sTableName
97989>>>                        If (sTableName = "") Begin
97991>>>                            Send Info_Box "You need to select a table first..."
97992>>>                            Procedure_Return
97993>>>                        End
97993>>>>
97993>>>                        Get Value of oSQLColumnName_cf to sColumnName
97994>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
97996>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
97997>>>                            Procedure_Return
97998>>>                        End
97998>>>>
97998>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
97999>>>                        If (Trim(sNewColumnName) = "") Begin
98001>>>                            Send Info_Box "You need to enter a column name to rename to..."
98002>>>                            Procedure_Return
98003>>>                        End
98003>>>>
98003>>>
98003>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98004>>>                        If (hTable = 0) Begin
98006>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98007>>>                            Procedure_Return
98008>>>                        End
98008>>>>
98008>>>
98008>>>                        Get Value of oDriverID2_cf to sDriverID
98009>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98010>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98011>>>                        If (bOk = True) Begin
98013>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98013>>>                            Send Delete_Data of oSQLColumnName_cf
98014>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98015>>>                        End
98015>>>>
98015>>>                        Else Begin
98016>>>                            Send Info_Box "Nope, that didn't work..."
98017>>>                        End
98017>>>>
98017>>>
98017>>>                    End_Procedure
98018>>>
98018>>>                End_Object
98019>>>
98019>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98021>>>                    Set Size to 12 91
98022>>>                    Set Location to 134 297
98023>>>                    Set Label to "Drop Column"
98024>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98025>>>                    Set psImage to "DeleteColumn1.ico"
98026>>>
98026>>>                    Procedure OnClick
98029>>>                        Boolean bOk
98029>>>                        String sTableName sColumnName sDriverID
98029>>>                        Integer iRetval
98029>>>
98029>>>                        Get Value of oDriverID2_cf              to sDriverID
98030>>>                        Get Value of oSQLTableName_cf           to sTableName
98031>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98032>>>
98032>>>                        If (sTableName = "" or sColumnName = "") Begin
98034>>>                            Send Info_Box "You first need to select a table and a column."
98035>>>                            Procedure_Return
98036>>>                        End
98036>>>>
98036>>>
98036>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98037>>>                        If (iRetval <> MBR_Yes) Begin
98039>>>                            Procedure_Return
98040>>>                        End
98040>>>>
98040>>>
98040>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98041>>>
98041>>>                        If (bOk = True) Begin
98043>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98043>>>                            Send Delete_Data of oSQLColumnName_cf
98044>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98045>>>                        End
98045>>>>
98045>>>                        Else Begin
98046>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98047>>>                            Procedure_Return
98048>>>                        End
98048>>>>
98048>>>
98048>>>                    End_Procedure
98049>>>
98049>>>                End_Object
98050>>>
98050>>>                Object oSQLAddColumnName_fm is a Form
98052>>>                    Set Size to 12 96
98053>>>                    Set Location to 177 14
98054>>>                    Set Label_Col_Offset to 0
98055>>>                    Set Label_Justification_Mode to JMode_Top
98056>>>                    Set Label to "Column Name:"
98057>>>                    Set Label_Row_Offset to 1
98058>>>                    Set Value to "NewColumn"
98059>>>                End_Object
98060>>>
98060>>>                Object oSQLColumnType_cf is a ComboForm
98062>>>                    Set Size to 12 96
98063>>>                    Set Location to 177 116
98064>>>                    Set Label_Col_Offset to 0
98065>>>                    Set Label_Justification_Mode to JMode_Top
98066>>>                    Set Label_Row_Offset to 1
98067>>>                    Set Label to "Type:"
98068>>>                    Set Entry_State to False
98069>>>
98069>>>                    Procedure Combo_Fill_List
98072>>>                        tColumnType[] ColumnTypeArray
98072>>>                        tColumnType[] ColumnTypeArray
98073>>>                        Integer iSize iCount iDbType
98073>>>                        String sDriverID
98073>>>
98073>>>                        Send Delete_Data
98074>>>                        Get Value of oDriverID2_cf to sDriverID
98075>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98076>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98077>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98078>>>                        Decrement iSize
98079>>>                        For iCount from 0 to iSize
98085>>>>
98085>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98086>>>                        Loop
98087>>>>
98087>>>                        If (iSize > 0) Begin
98089>>>                            Set Value to ColumnTypeArray[0].sSQLType
98090>>>                        End
98090>>>>
98090>>>                    End_Procedure
98091>>>
98091>>>                    Procedure OnChange
98094>>>                        Integer iType iSize iDec
98094>>>                        tSQLConnection SQLConnection
98094>>>                        tSQLConnection SQLConnection
98094>>>                        Boolean bFixed
98094>>>
98094>>>                        Get SelectedType to iType
98095>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98096>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98097>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98098>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98099>>>
98099>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98100>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98101>>>                        Set Value         of oSQLLength_sf   to iSize
98102>>>                        If (iDec = 0) Begin
98104>>>                            Set Value     of oSQLDecimals_sf to ""
98105>>>                        End
98105>>>>
98105>>>                        Else Begin
98106>>>                            Set Value     of oSQLDecimals_sf to iDec
98107>>>                        End
98107>>>>
98107>>>                        If (bFixed = False) Begin
98109>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98110>>>                        End
98110>>>>
98110>>>                    End_Procedure
98111>>>
98111>>>                    Function SelectedType Returns Integer
98114>>>                        String sValue sDriverID
98114>>>                        Integer iType iDbType
98114>>>
98114>>>                        Get Value to sValue
98115>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98116>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98117>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98118>>>
98118>>>                        Function_Return iType
98119>>>                    End_Function
98120>>>
98120>>>                End_Object
98121>>>
98121>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98123>>>                    Set Size to 12 69
98124>>>                    Set Location to 177 220
98125>>>                    Set Label to "Add Column"
98126>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98127>>>                    Set psImage to "AddColumn1.ico"
98128>>>
98128>>>                    Procedure OnClick
98131>>>                        Boolean bOk bInitialize
98131>>>                        Handle hTable
98131>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98131>>>                        Integer iType iLength iDecimals
98131>>>
98131>>>                        Get Value of oDriverID2_cf              to sDriverID
98132>>>                        Get Value of oSQLTableName_cf           to sTableName
98133>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98134>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98135>>>                        Get Value         of oSQLColumnType_cf  to sType
98136>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98137>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98138>>>                        Get Value         of oSQLLength_sf      to iLength
98139>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98140>>>
98140>>>                        If (sTableName <> "") Begin
98142>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98143>>>                            If (hTable = 0) Begin
98145>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98146>>>                            End
98146>>>>
98146>>>                        End
98146>>>>
98146>>>                        If (hTable = 0) Begin
98148>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98149>>>                            Procedure_Return
98150>>>                        End
98150>>>>
98150>>>                        If (sColumnName = "") Begin
98152>>>                            Send Info_Box "You need to enter a column name"
98153>>>                            Procedure_Return
98154>>>                        End
98154>>>>
98154>>>
98154>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98155>>>
98155>>>                        If (bOk = True) Begin
98157>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98158>>>                        End
98158>>>>
98158>>>                        Else Begin
98159>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98160>>>                            Procedure_Return
98161>>>                        End
98161>>>>
98161>>>
98161>>>                    End_Procedure
98162>>>
98162>>>                End_Object
98163>>>
98163>>>//                Object oTest_btn is a cRDCButtonDPI
98163>>>//                    Set Size to 13 92
98163>>>//                    Set Location to 177 298
98163>>>//                    Set Label to "Test SQL script button"
98163>>>//
98163>>>//                    Procedure OnClick
98163>>>//                        Boolean bOK
98163>>>//                        String sTableName sColumnName
98163>>>//
98163>>>//                        Get Value of oSQLTableName_cf      to sTableName
98163>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98163>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98163>>>//
98163>>>//                    End_Procedure
98163>>>//
98163>>>//                End_Object
98163>>>
98163>>>                Object oSQLLength_sf is a SpinForm
98165>>>                    Set Label to "Length:"
98166>>>                    Set Size to 12 40
98167>>>                    Set Location to 202 16
98168>>>                    Set Label_Col_Offset to 0
98169>>>                    Set Label_Justification_Mode to JMode_Top
98170>>>                    Set Label_Row_Offset to 1
98171>>>                    Set Value to "10"
98172>>>                    Set Maximum_Position to 500
98173>>>                    Set Minimum_Position to 1
98174>>>                End_Object
98175>>>
98175>>>                Object oSQLDecimals_sf is a SpinForm
98177>>>                    Set Label to "Decimals:"
98178>>>                    Set Size to 12 33
98179>>>                    Set Location to 202 60
98180>>>                    Set Label_Col_Offset to 0
98181>>>                    Set Label_Justification_Mode to JMode_Top
98182>>>                    Set Label_Row_Offset to 1
98183>>>                    Set Value to "0"
98184>>>                    Set Maximum_Position to 16
98185>>>                    Set Minimum_Position to 1
98186>>>                End_Object
98187>>>
98187>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98189>>>                    Set Size to 12 85
98190>>>                    Set Location to 202 116
98191>>>                    Set Label to "Initialize Column Value"
98192>>>
98192>>>                    Procedure OnChange
98195>>>                        Boolean bChecked
98195>>>
98195>>>                        Get Checked_State to bChecked
98196>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98197>>>                    End_Procedure
98198>>>
98198>>>                End_Object
98199>>>
98199>>>                Object oSQLColumnValue_fm is a Form
98201>>>                    Set Size to 12 96
98202>>>                    Set Location to 218 116
98203>>>                    Set Label_Col_Offset to 2
98204>>>                    Set Label_Justification_Mode to JMode_Right
98205>>>                    Set Label to "Column Value"
98206>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98207>>>                    Set Enabled_State to False
98208>>>                End_Object
98209>>>
98209>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98211>>>                    Set Size to 12 91
98212>>>                    Set Location to 116 297
98213>>>                    Set Label to "Test Enum SQL Relations"
98214>>>
98214>>>                    Procedure OnClick
98217>>>                        tSQLRelation[] SQLRelationArray
98217>>>                        tSQLRelation[] SQLRelationArray
98218>>>                        String sTableName sDriverID
98218>>>                        Integer iSize iCount
98218>>>
98218>>>                        Get Value of oDriverID2_cf to sDriverID
98219>>>                        Get Value of oSQLTableName_cf to sTableName
98220>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98221>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98222>>>                        Decrement iSize
98223>>>                        For iCount from 0 to iSize
98229>>>>
98229>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98238>>>                        Loop
98239>>>>
98239>>>                        If (iSize < 1) Begin
98241>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98242>>>                        End
98242>>>>
98242>>>
98242>>>                    End_Procedure
98243>>>
98243>>>                End_Object
98244>>>
98244>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98246>>>                    Set Size to 12 101
98247>>>                    Set Location to 177 297
98248>>>                    Set Label to "Enumerate Logged In Users"
98249>>>
98249>>>                    Procedure OnClick
98252>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98252>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98253>>>                        String sDriverID sDatabase
98253>>>                        Integer iSize iCount
98253>>>
98253>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98254>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98255>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98256>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98257>>>                        Decrement iSize
98258>>>
98258>>>                        Showln "SQL User Name" " and Program:"
98261>>>                        For iCount from 0 to iSize
98267>>>>
98267>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98271>>>                        Loop
98272>>>>
98272>>>                    End_Procedure
98273>>>
98273>>>                End_Object
98274>>>
98274>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98276>>>                    Set Size to 12 101
98277>>>                    Set Location to 193 297
98278>>>                    Set Label to "Is Table or View?"
98279>>>
98279>>>                    Procedure OnClick
98282>>>                        String sDriverID sTableName
98282>>>                        Handle hTable
98282>>>                        Boolean bViewTableType
98282>>>
98282>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98283>>>                        Get Value of oSQLTableName_cf to sTableName
98284>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98285>>>                        If (hTable = 0) Begin
98287>>>                            Procedure_Return
98288>>>                        End
98288>>>>
98288>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98289>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98290>>>                    End_Procedure
98291>>>
98291>>>                End_Object
98292>>>
98292>>>            End_Object
98293>>>
98293>>>        End_Object
98294>>>
98294>>>    End_Object
98295>>>
98295>>>End_Object
98296>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98296>>>Use Windows.pkg
98296>>>Use DFClient.pkg
98296>>>Use Dfspnfrm.pkg
98296>>>Use Dfline.pkg
98296>>>Use cDbScrollingContainer.pkg
98296>>>Use cRDCButtonDPI.pkg
98296>>>Use cDbUpdateFunctionLibrary.pkg
98296>>>
98296>>>Define CI_Table1_FileNo for 401
98296>>>Define CI_View1_FileNo  for 402
98296>>>
98296>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98306>>>>
98306>>>Object oAPIFunctions_vw is a dbView
98308>>>    Set Border_Style to Border_Thick
98309>>>    Set Size to 237 424
98310>>>    Set Location to 17 2
98311>>>    Set Label to "API Functions"
98312>>>    Set pbAutoActivate to True
98313>>>    Set Icon to "APIFunctions1.ico"
98314>>>
98314>>>    Property String psTableName ""
98316>>>
98316>>>    Procedure OnSetFocus
98319>>>        String sValue
98319>>>        tSQLConnection SQLConnection
98319>>>        tSQLConnection SQLConnection
98319>>>
98319>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98320>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98321>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98322>>>        Set Value of oApiConnectionString_fm to sValue
98323>>>    End_Procedure
98324>>>
98324>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98326>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98328>>>
98328>>>            Object oApiFunctions_grp is a Group
98330>>>                Set Size to 222 402
98331>>>                Set Location to 6 12
98332>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98333>>>                Set peAnchors to anAll
98334>>>
98334>>>                Object oApiConnectionString_fm is a Form
98336>>>                    Set Size to 12 368
98337>>>                    Set Location to 23 14
98338>>>                    Set Label to "Current Connection String Settings:"
98339>>>                    Set Label_Col_Offset to 0
98340>>>                    Set Label_Justification_Mode to JMode_Top
98341>>>                    Set peAnchors to anTopLeftRight
98342>>>                    Set Enabled_State to False
98343>>>                    Set Label_Row_Offset to 1
98344>>>                End_Object
98345>>>
98345>>>                Object oApiDatabase_fm is a Form
98347>>>                    Set Size to 12 86
98348>>>                    Set Location to 50 14
98349>>>                    Set Label to "Database:"
98350>>>                    Set Label_Col_Offset to 0
98351>>>                    Set Label_Justification_Mode to JMode_Top
98352>>>                    Set Label_Row_Offset to 1
98353>>>                    Set Enabled_State to False
98354>>>                    Set FontWeight to fw_Bold
98355>>>//                    Set Label_FontWeight to fw_Bold
98355>>>
98355>>>                    Procedure Page Integer iPageObject
98358>>>                        String sValue
98358>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98359>>>                        Set Value to sValue
98360>>>
98360>>>                        Forward Send Page iPageObject
98362>>>                    End_Procedure
98363>>>
98363>>>                End_Object
98364>>>
98364>>>                Object oDriverID3_cf is a ComboForm
98366>>>                    Set Size to 12 91
98367>>>                    Set Location to 51 121
98368>>>                    Set Label_Col_Offset to 0
98369>>>                    Set Label_Justification_Mode to JMode_Top
98370>>>                    Set Label to "Driver ID:"
98371>>>                    Set Entry_State to False
98372>>>                    Set Enabled_State to False
98373>>>                    Set Label_Row_Offset to 1
98374>>>                    Set Enabled_State to False
98375>>>
98375>>>                    Procedure Combo_Fill_List
98378>>>                        Send Combo_Add_Item MSSQLDRV_ID
98379>>>                        Send Combo_Add_Item DB2_DRV_ID
98380>>>                        Send Combo_Add_Item ODBC_DRV_ID
98381>>>                    End_Procedure
98382>>>
98382>>>                    Procedure Refresh
98385>>>                        String sValue
98385>>>
98385>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98386>>>                        Set Value to sValue
98387>>>                    End_Procedure
98388>>>
98388>>>                End_Object
98389>>>
98389>>>                Object oDatabaseInfo_tb is a TextBox
98391>>>                    Set Auto_Size_State to False
98392>>>                    Set Size to 25 96
98393>>>                    Set Location to 64 14
98394>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98395>>>                    Set Justification_Mode to JMode_Left
98396>>>                End_Object
98397>>>
98397>>>                Object oApiTableName_fm is a Form
98399>>>                    Set Size to 12 77
98400>>>                    Set Location to 114 14
98401>>>                    Set Label_Col_Offset to 0
98402>>>                    Set Label_Justification_Mode to JMode_Top
98403>>>                    Set Label to "Table Name:"
98404>>>                    Set Label_Row_Offset to 1
98405>>>                    Set Value to "NewTable"
98406>>>                    Procedure OnChange
98409>>>                        String sValue
98409>>>                        Get Value to sValue
98410>>>                        Set psTableName to sValue
98411>>>                    End_Procedure
98412>>>                    Send OnChange
98413>>>                End_Object
98414>>>
98414>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98416>>>                    Set Size to 12 69
98417>>>                    Set Location to 114 271
98418>>>                    Set Label to "Add Table"
98419>>>                    Set psImage to "ActionAddTable1.ico"
98420>>>
98420>>>                    Procedure OnClick
98423>>>                        Boolean bOk
98423>>>                        Handle hTable
98423>>>                        String sTableName sDriverID
98423>>>
98423>>>                        Get Value of oDriverID3_cf to sDriverID
98424>>>                        Get Value of oApiTableName_fm to sTableName
98425>>>                        Move (Trim(sTableName)) to sTableName
98426>>>                        If (sTableName = "") Begin
98428>>>                            Send Info_Box "You first need to enter a table name."
98429>>>                            Procedure_Return
98430>>>                        End
98430>>>>
98430>>>
98430>>>                        Send Cursor_Wait of Cursor_Control
98431>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98432>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98433>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98434>>>                        If (bOk = True) Begin
98436>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98437>>>                        End
98437>>>>
98437>>>                        Else Begin
98438>>>                            Send Cursor_Ready of Cursor_Control
98439>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98440>>>                            Procedure_Return
98441>>>                        End
98441>>>>
98441>>>
98441>>>                    End_Procedure
98442>>>
98442>>>                End_Object
98443>>>
98443>>>                Object oApiAddColumn_fm is a Form
98445>>>                    Set Size to 12 77
98446>>>                    Set Location to 141 14
98447>>>                    Set Label_Col_Offset to 0
98448>>>                    Set Label_Justification_Mode to JMode_Top
98449>>>                    Set Label to "Column Name:"
98450>>>                    Set Label_Row_Offset to 1
98451>>>                    Set Value to "NewColumn"
98452>>>                End_Object
98453>>>
98453>>>                Object oApiColumnType_cf is a ComboForm
98455>>>                    Set Size to 12 85
98456>>>                    Set Location to 141 96
98457>>>                    Set Label_Col_Offset to 0
98458>>>                    Set Label_Justification_Mode to JMode_Top
98459>>>                    Set Label_Row_Offset to 1
98460>>>                    Set Label to "Type:"
98461>>>                    Set Entry_State to False
98462>>>
98462>>>                    Procedure Combo_Fill_List
98465>>>                        tColumnType[] ColumnTypeArray
98465>>>                        tColumnType[] ColumnTypeArray
98466>>>                        Integer iSize iCount
98466>>>
98466>>>                        Send Delete_Data
98467>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98468>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98469>>>                        Decrement iSize
98470>>>                        For iCount from 0 to iSize
98476>>>>
98476>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98477>>>                        Loop
98478>>>>
98478>>>                        Set Value to ColumnTypeArray[0].sSQLType
98479>>>                    End_Procedure
98480>>>
98480>>>                    Procedure OnChange
98483>>>                        Integer iType iSize iDec
98483>>>                        tSQLConnection SQLConnection
98483>>>                        tSQLConnection SQLConnection
98483>>>                        Boolean bFixed
98483>>>
98483>>>                        Get SelectedType to iType
98484>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98485>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98486>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98487>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98488>>>
98488>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98489>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98490>>>                        Set Value         of oApiLength_sf   to iSize
98491>>>                        If (iDec = 0) Begin
98493>>>                            Set Value     of oApiDecimals_sf to ""
98494>>>                        End
98494>>>>
98494>>>                        Else Begin
98495>>>                            Set Value     of oApiDecimals_sf to iDec
98496>>>                        End
98496>>>>
98496>>>                        If (bFixed = False) Begin
98498>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98499>>>                        End
98499>>>>
98499>>>                    End_Procedure
98500>>>
98500>>>                    Function SelectedType Returns Integer
98503>>>                        String sValue
98503>>>                        Integer iType
98503>>>
98503>>>                        Get Value to sValue
98504>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98505>>>
98505>>>                        Function_Return iType
98506>>>                    End_Function
98507>>>
98507>>>                End_Object
98508>>>
98508>>>                Object oApiLength_sf is a SpinForm
98510>>>                    Set Label to "Length:"
98511>>>                    Set Size to 12 35
98512>>>                    Set Location to 141 186
98513>>>                    Set Label_Col_Offset to 0
98514>>>                    Set Label_Justification_Mode to JMode_Top
98515>>>                    Set Label_Row_Offset to 1
98516>>>                    Set Value to "10"
98517>>>                    Set Maximum_Position to 500
98518>>>                    Set Minimum_Position to 1
98519>>>                End_Object
98520>>>
98520>>>                Object oApiDecimals_sf is a SpinForm
98522>>>                    Set Label to "Decimals:"
98523>>>                    Set Size to 12 33
98524>>>                    Set Location to 141 225
98525>>>                    Set Label_Col_Offset to 0
98526>>>                    Set Label_Justification_Mode to JMode_Top
98527>>>                    Set Label_Row_Offset to 1
98528>>>                    Set Value to "0"
98529>>>                    Set Maximum_Position to 16
98530>>>                    Set Minimum_Position to 1
98531>>>                End_Object
98532>>>
98532>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98534>>>                    Set Size to 12 69
98535>>>                    Set Location to 141 271
98536>>>                    Set Label to "Add Column"
98537>>>                    Set psToolTip to "ApiColumnAdd function"
98538>>>                    Set psImage to "ActionAddColumn1.ico"
98539>>>
98539>>>                    Procedure OnClick
98542>>>                        Boolean bOk
98542>>>                        Handle hTable
98542>>>                        String sTableName sColumnName sType sDriverID
98542>>>                        Integer iType iLength iDecimals
98542>>>
98542>>>                        Get Value of oDriverID3_cf            to sDriverID
98543>>>                        Get Value of oApiTableName_fm         to sTableName
98544>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98545>>>                        Get SelectedType of oApiColumnType_cf to iType
98546>>>                        Get Value        of oApiLength_sf     to iLength
98547>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98548>>>
98548>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98549>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98550>>>                        If (hTable = 0) Begin
98552>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98553>>>                            Procedure_Return
98554>>>                        End
98554>>>>
98554>>>                        If (sColumnName = "") Begin
98556>>>                            Send Info_Box "You need to enter a column name"
98557>>>                            Procedure_Return
98558>>>                        End
98558>>>>
98558>>>
98558>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98559>>>                        If (bOk = True) Begin
98561>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98562>>>                        End
98562>>>>
98562>>>                        Else Begin
98563>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98564>>>                            Procedure_Return
98565>>>                        End
98565>>>>
98565>>>
98565>>>                    End_Procedure
98566>>>
98566>>>                End_Object
98567>>>
98567>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98569>>>                    Set Size to 26 77
98570>>>                    Set Location to 184 14
98571>>>                    Set Label to "Create 'New' Table with Three Columns"
98572>>>                    Set MultiLineState to True
98573>>>                    Set psImage to "ActionAddTable1.ico"
98574>>>
98574>>>                    Procedure OnClick
98577>>>                        Boolean bOk
98577>>>                        Handle hTable
98577>>>                        String sTableName sDriverID
98577>>>
98577>>>                        Get Value of oDriverID3_cf to sDriverID
98578>>>                        Get Value of oApiTableName_fm to sTableName
98579>>>                        Move (Trim(sTableName)) to sTableName
98580>>>                        If (sTableName = "") Begin
98582>>>                            Send Info_Box "You first need to enter a table name."
98583>>>                            Procedure_Return
98584>>>                        End
98584>>>>
98584>>>
98584>>>                        Send Cursor_Wait of Cursor_Control
98585>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98586>>>
98586>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98587>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98588>>>                        If (bOk = True) Begin
98590>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98591>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98592>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98593>>>                        End
98593>>>>
98593>>>                        Send Cursor_Ready of Cursor_Control
98594>>>
98594>>>                        If (bOk = True) Begin
98596>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98597>>>                        End
98597>>>>
98597>>>                        Else Begin
98598>>>                            Send Cursor_Ready of Cursor_Control
98599>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98600>>>                            Procedure_Return
98601>>>                        End
98601>>>>
98601>>>
98601>>>                    End_Procedure
98602>>>
98602>>>                End_Object
98603>>>
98603>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98605>>>                    Set Size to 26 77
98606>>>                    Set Location to 184 96
98607>>>                    Set Label to "Remove 'New' Table"
98608>>>                    Set psImage to "ActionDeleteTable1.ico"
98609>>>                    Set MultiLineState to True
98610>>>
98610>>>                    Procedure OnClick
98613>>>                        Boolean bOk
98613>>>                        Integer iRetval
98613>>>                        Handle hTable
98613>>>                        String sTableName sDriverID
98613>>>
98613>>>                        Get Value of oDriverID3_cf to sDriverID
98614>>>                        Get Value of oApiTableName_fm to sTableName
98615>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98616>>>                        If (iRetval = MBR_Yes) Begin
98618>>>                            Send Cursor_Wait of Cursor_Control
98619>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98620>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98621>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98622>>>                            Send Cursor_Ready of Cursor_Control
98623>>>                            If (bOk = True) Begin
98625>>>                                Send Info_Box "Table removed"
98626>>>                            End
98626>>>>
98626>>>                            Else Begin
98627>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98628>>>                            End
98628>>>>
98628>>>                        End
98628>>>>
98628>>>                    End_Procedure
98629>>>
98629>>>                End_Object
98630>>>
98630>>>                Object oLineControl1 is a LineControl
98632>>>                    Set Size to 2 387
98633>>>                    Set Location to 96 6
98634>>>                    Set peAnchors to anTopLeftRight
98635>>>                End_Object
98636>>>
98636>>>                Object oLineControl2 is a LineControl
98638>>>                    Set Size to 3 248
98639>>>                    Set Location to 171 9
98640>>>                End_Object
98641>>>
98641>>>                Object oTestError_fm is a Form
98643>>>                    Set Size to 13 64
98644>>>                    Set Location to 186 180
98645>>>                    Set Form_Datatype to 0 
98646>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98647>>>                End_Object
98648>>>
98648>>>Register_Function FetchErrorDescription Integer iError Returns String
98648>>>                Object oFindErrorText_Btn is a Button
98650>>>                    Set Size to 13 70
98651>>>                    Set Location to 186 248
98652>>>                    Set Label to "Find Error Text"
98653>>>                
98653>>>                    Procedure OnClick
98656>>>                        String sRetval
98656>>>                        Integer iError 
98656>>>                        Handle hoLogFile
98656>>>                        
98656>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98657>>>                        Get Value of oTestError_fm to iError
98658>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98659>>>                        Set Value of oErrorText_fm to sRetval    
98660>>>                    End_Procedure
98661>>>                
98661>>>                End_Object
98662>>>
98662>>>                Object oErrorText_fm is a Form
98664>>>                    Set Size to 13 213
98665>>>                    Set Location to 202 180
98666>>>                End_Object
98667>>>
98667>>>            End_Object
98668>>>
98668>>>        End_Object
98669>>>
98669>>>    End_Object
98670>>>
98670>>>End_Object
98671>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98671>>>
98671>>>Use Windows.pkg
98671>>>Use DFClient.pkg
98671>>>Use Dfline.pkg
98671>>>Use cDbScrollingContainer.pkg
98671>>>Use cRDCButtonDPI.pkg
98671>>>Use cDbUpdateFunctionLibrary.pkg
98671>>>Use Dftreevw.pkg
98671>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98671>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98671>>>>>//
98671>>>>>// This program is free software; you can redistribute it and/or
98671>>>>>// modify it under the terms of the GNU General Public License
98671>>>>>// as published by the Free Software Foundation; version 2
98671>>>>>// of the License.
98671>>>>>
98671>>>>>// This program is distributed in the hope that it will be useful,
98671>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98671>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98671>>>>>// GNU General Public License for more details.
98671>>>>>
98671>>>>>// You should have received a copy of the GNU General Public License
98671>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98671>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98671>>>>>Use Windows.pkg
98671>>>>>
98671>>>>>Object oWorkingMessagePanel is a ToolPanel
98673>>>>>    Set Label    to "Working"
98674>>>>>    Set Size to 48 150
98675>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98676>>>>>    Set Popup_State to True
98677>>>>>
98677>>>>>    Object oWorkingMessage is a Textbox
98679>>>>>        Set Label to "Working message..."
98680>>>>>        Set Location to 15 5
98681>>>>>        Set Size to 27 123
98682>>>>>        Set Auto_Size_State to False
98683>>>>>        Set Justification_Mode to JMode_Center
98684>>>>>        Set FontWeight to fw_Bold
98685>>>>>    End_Object
98686>>>>>
98686>>>>>End_Object
98687>>>>>
98687>>>>>Procedure StartWorkingMessage Global String sText
98689>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98690>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98691>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98692>>>>>End_Procedure
98693>>>>>
98693>>>>>Procedure StopWorkingMessage Global
98695>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98696>>>>>End_Procedure
98697>>>Use DUFStatusPanel.pkg
98697>>>Use cCharTranslate.pkg
98697>>>
98697>>>Struct tFilelistDUF
98697>>>    Integer iFileNumber
98697>>>    String sLogicalName
98697>>>    String sRootName
98697>>>    String sDisplayName
98697>>>End_Struct
98697>>>
98697>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98707>>>>
98707>>>Object oUtilFunctions_vw is a dbView
98709>>>    Set Border_Style to Border_Thick
98710>>>    Set Size to 291 428
98711>>>    Set Location to 2 1
98712>>>    Set Label to "Utility Functions"
98713>>>    Set pbAutoActivate to True
98714>>>    Set Icon to "TestTools1.ico"
98715>>>    Set pbAcceptDropFiles to True
98716>>>
98716>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98718>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98720>>>
98720>>>            Object oSQL_grp is a Group
98722>>>                Set Size to 88 402
98723>>>                Set Location to 7 12
98724>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98725>>>                Set peAnchors to anTopLeftRight
98726>>>
98726>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98728>>>                    Set Size to 14 219
98729>>>                    Set Location to 13 13
98730>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98731>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98732>>>                    Set psImage to "ActionCreateDatabase1.ico"
98733>>>
98733>>>                    Procedure OnClick
98736>>>                        String sInfoText sDriverID
98736>>>                        Boolean bOK
98736>>>                        TimeSpan tsTotalQueryTime
98736>>>                        Integer iRetval
98736>>>
98736>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98736>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98736>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98736>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98737>>>                        If (iRetval <> MBR_Yes) Begin
98739>>>                            Procedure_Return
98740>>>                        End
98740>>>>
98740>>>
98740>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98741>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98743>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98744>>>                            Procedure_Return
98745>>>                        End
98745>>>>
98745>>>
98745>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98746>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98747>>>                        Send StopWorkingMessage
98748>>>
98748>>>                        If (bOK = True) Begin
98750>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98751>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98752>>>                        End
98752>>>>
98752>>>
98752>>>                        Else Begin
98753>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98754>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98755>>>                        End
98755>>>>
98755>>>
98755>>>                        Send Info_Box sInfoText
98756>>>                    End_Procedure
98757>>>
98757>>>                End_Object
98758>>>
98758>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98760>>>                    Set Size to 14 219
98761>>>                    Set Location to 33 13
98762>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98763>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98764>>>                    Set psImage to "ActionCreateDatabase1.ico"
98765>>>
98765>>>                    Procedure OnClick
98768>>>                        String sInfoText sDriverID
98768>>>                        Boolean bOK
98768>>>                        TimeSpan tsTotalQueryTime
98768>>>                        Integer iRetval
98768>>>
98768>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98768>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98768>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98768>>>
98768>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98769>>>                        If (iRetval <> MBR_Yes) Begin
98771>>>                            Procedure_Return
98772>>>                        End
98772>>>>
98772>>>
98772>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98773>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98775>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98776>>>                            Procedure_Return
98777>>>                        End
98777>>>>
98777>>>
98777>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98778>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98779>>>                        Send StopWorkingMessage
98780>>>
98780>>>                        If (bOK = True) Begin
98782>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98783>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98784>>>                        End
98784>>>>
98784>>>
98784>>>                        Else Begin
98785>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98786>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98787>>>                        End
98787>>>>
98787>>>
98787>>>                        Send Info_Box sInfoText
98788>>>                    End_Procedure
98789>>>
98789>>>                End_Object
98790>>>
98790>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98792>>>                    Set Size to 14 219
98793>>>                    Set Location to 53 13
98794>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98795>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98796>>>                    Set psImage to "ActionCreateDatabase1.ico"
98797>>>
98797>>>                    Procedure OnClick
98800>>>                        String sInfoText sDriverID
98800>>>                        Boolean bOK
98800>>>                        TimeSpan tsTotalQueryTime
98800>>>                        Integer iRetval
98800>>>
98800>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98800>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98800>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98800>>>
98800>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98801>>>                        If (iRetval <> MBR_Yes) Begin
98803>>>                            Procedure_Return
98804>>>                        End
98804>>>>
98804>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98805>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98807>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98808>>>                            Procedure_Return
98809>>>                        End
98809>>>>
98809>>>
98809>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98810>>>
98810>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98811>>>
98811>>>                        Send StopWorkingMessage
98812>>>                        If (bOK = True) Begin
98814>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98815>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98816>>>                        End
98816>>>>
98816>>>
98816>>>                        Else Begin
98817>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98818>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98819>>>                        End
98819>>>>
98819>>>
98819>>>                        Send Info_Box sInfoText
98820>>>                    End_Procedure
98821>>>
98821>>>                End_Object
98822>>>
98822>>>                Object oInfo_tb is a TextBox
98824>>>                    Set Auto_Size_State to False
98825>>>                    Set Size to 25 158
98826>>>                    Set Location to 53 238
98827>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98828>>>                    Set Justification_Mode to JMode_Left
98829>>>                    Set peAnchors to anTopLeftRight
98830>>>                End_Object
98831>>>
98831>>>        //  This will choke the computer so don't try it!
98831>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98831>>>        //            Set Size to 14 312
98831>>>        //            Set Location to 97 45
98831>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98831>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98831>>>        //
98831>>>        //            Procedure OnClick
98831>>>        //                String sInfoText
98831>>>        //                Boolean bOK
98831>>>        //                TimeSpan tsTotalQueryTime
98831>>>        //                Integer iRetval
98831>>>        //
98831>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98831>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98831>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98831>>>        //Procedure_Return
98831>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98831>>>        //                If (iRetval <> MBR_Yes) Begin
98831>>>        //                    Procedure_Return
98831>>>        //                End
98831>>>        //
98831>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98831>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98831>>>        //                Send StopWorkingMessage
98831>>>        //
98831>>>        //                If (bOK = True) Begin
98831>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98831>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98831>>>        //                End
98831>>>        //
98831>>>        //                Else Begin
98831>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98831>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98831>>>        //                End
98831>>>        //
98831>>>        //                Send Info_Box sInfoText
98831>>>        //            End_Procedure
98831>>>        //
98831>>>        //        End_Object
98831>>>
98831>>>            End_Object
98832>>>
98832>>>            Object oChangeIntFiles_grp is a Group
98834>>>                Set Size to 65 402
98835>>>                Set Location to 102 12
98836>>>                Set Label to "Change Old .int files to use Connection ID's"
98837>>>                Set peAnchors to anTopLeftRight
98838>>>
98838>>>                Object oSelectDataPath_fm is a Form
98840>>>                    Set Size to 12 300
98841>>>                    Set Location to 22 13
98842>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98843>>>                    Set Label_Col_Offset to 0
98844>>>                    Set Label_Row_Offset to 1
98845>>>                    Set Label_Justification_Mode to JMode_Top
98846>>>
98846>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98846>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98846>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98847>>>                    Set peAnchors to anTopLeftRight
98848>>>
98848>>>                    Procedure Prompt
98851>>>                        String sPath sFileMask sRetval
98851>>>
98851>>>                        Get psDataPathFirstPart to sPath
98852>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98853>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98854>>>                        If (sRetval <> "") Begin
98856>>>                            Get ParseFolderName sRetval to sPath
98857>>>                            If (Right(sPath, 1) ="\") Begin
98859>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98860>>>                            End
98860>>>>
98860>>>                            Set Value to sPath
98861>>>                        End
98861>>>>
98861>>>                    End_Procedure
98862>>>
98862>>>                    // Returns the first datapath found in the psDataPath property.
98862>>>                    // The returned path always ends with a "\"
98862>>>                    Function psDataPathFirstPart Returns String
98865>>>                        String sDataPath
98865>>>                        Integer iCount
98865>>>
98865>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98866>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98867>>>                        If (iCount > 1) Begin
98869>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98870>>>                        End
98870>>>>
98870>>>                        If (sDataPath <> "") Begin
98872>>>                            Get vFolderFormat sDataPath to sDataPath
98873>>>                        End
98873>>>>
98873>>>
98873>>>                        Function_Return sDataPath
98874>>>                    End_Function
98875>>>
98875>>>                End_Object
98876>>>
98876>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98878>>>                    Set Size to 13 73
98879>>>                    Set Location to 22 320
98880>>>                    Set Label to "Select Folder"
98881>>>                    Set psToolTip to "Please select an .int file from the data folder"
98882>>>                    Set peAnchors to anTopRight
98883>>>                    Set psImage to "ActionOpen1.ico"
98884>>>
98884>>>                    Procedure OnClick
98887>>>                        Send Prompt to oSelectDataPath_fm
98888>>>                    End_Procedure
98889>>>
98889>>>                End_Object
98890>>>
98890>>>                Object oConnectionID_fm is a Form
98892>>>                    Set Size to 13 111
98893>>>                    Set Location to 38 202
98894>>>                    Set Label_Col_Offset to 2
98895>>>                    Set Label_Justification_Mode to JMode_Right
98896>>>                    Set Label to "Change to DFConnID:"
98897>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98898>>>                    Set peAnchors to anTopRight
98899>>>                End_Object
98900>>>
98900>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98902>>>                    Set Size to 13 68
98903>>>                    Set Location to 38 320
98904>>>                    Set Label to "GO !"
98905>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98906>>>                    Set FontWeight to fw_Bold
98907>>>                    Set peAnchors to anTopRight
98908>>>
98908>>>                    Procedure OnClick
98911>>>                        String sDataPath sConnectionID
98911>>>                        Boolean bExists bActive
98911>>>                        Integer iRetval iChangedFiles
98911>>>
98911>>>                        Get Value of oSelectDataPath_fm to sDataPath
98912>>>                        Get vFolderExists sDataPath to bExists
98913>>>                        If (bExists = False) Begin
98915>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98916>>>                            Procedure_Return
98917>>>                        End
98917>>>>
98917>>>                        Get Value of oConnectionID_fm to sConnectionID
98918>>>                        Move (Trim(sConnectionID)) to sConnectionID
98919>>>                        If (sConnectionID = "") Begin
98921>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98922>>>                            Procedure_Return
98923>>>                        End
98923>>>>
98923>>>
98923>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98924>>>                        If (iRetval <> MBR_Yes) Begin
98926>>>                            Procedure_Return
98927>>>                        End
98927>>>>
98927>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98928>>>                        If (iRetval <> MBR_Yes) Begin
98930>>>                            Procedure_Return
98931>>>                        End
98931>>>>
98931>>>
98931>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
98932>>>                        If (iRetval <> 0) Begin
98934>>>                            Send Info_Box "Could not delete .cch files!"
98935>>>                            Procedure_Return
98936>>>                        End
98936>>>>
98936>>>
98936>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
98937>>>                        Send Start_StatusPanel of ghoStatusPanel
98938>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
98939>>>
98939>>>                        Get Active_State of ghoStatusPanel to bActive
98940>>>                        If (bActive = False) Begin
98942>>>                            Send Info_Box "Process interupted..."
98943>>>                        End
98943>>>>
98943>>>                        Else Begin
98944>>>                            Send Stop_StatusPanel of ghoStatusPanel
98945>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
98946>>>                        End
98946>>>>
98946>>>                    End_Procedure
98947>>>
98947>>>                End_Object
98948>>>
98948>>>            End_Object
98949>>>
98949>>>            Object oRemoveFilelistDriverIDs_grp is a Group
98951>>>                Set Size to 59 402
98952>>>                Set Location to 171 12
98953>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
98954>>>                Set peAnchors to anTopLeftRight
98955>>>//                Set TextColor to clGreen
98955>>>//
98955>>>//                Procedure Page Integer iPage
98955>>>//                    Integer ia iz
98955>>>//                    Forward Send Page iPage
98955>>>//                    Move 0 to iz
98955>>>//                    Move (AddressOf(iz)) to ia
98955>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
98955>>>//                End_Procedure
98955>>>
98955>>>                Object oFilelistPath_fm is a Form
98957>>>                    Set Size to 13 299
98958>>>                    Set Location to 22 13
98959>>>                    Set Label to "Path and Filelist.cfg Name:"
98960>>>                    Set Label_Col_Offset to 0
98961>>>                    Set Label_Row_Offset to 1
98962>>>                    Set Label_Justification_Mode to JMode_Top
98963>>>
98963>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98963>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98963>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
98964>>>                    Set peAnchors to anTopLeftRight
98965>>>
98965>>>                    Procedure Prompt
98968>>>                        String sFileName sPath sFileMask sRetval
98968>>>
98968>>>                        Get Value to sFileName
98969>>>                        Get ParseFolderName sFileName to sPath
98970>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
98971>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
98972>>>                        If (sRetval <> "") Begin
98974>>>                            Set Value to sRetval
98975>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
98978>>>                        End
98978>>>>
98978>>>                    End_Procedure
98979>>>
98979>>>                    Procedure OnCreate
98982>>>                        String sFilelist
98982>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
98985>>>                        Set Value to sFilelist
98986>>>                    End_Procedure
98987>>>                    Send OnCreate
98988>>>
98988>>>                End_Object
98989>>>
98989>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
98991>>>                    Set Size to 13 73
98992>>>                    Set Location to 22 319
98993>>>                    Set Label to "Select Filelist.cfg"
98994>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
98995>>>                    Set peAnchors to anTopRight
98996>>>
98996>>>                    Procedure OnClick
98999>>>                        Send Prompt to oFilelistPath_fm
99000>>>                    End_Procedure
99001>>>
99001>>>                End_Object
99002>>>
99002>>>                Object oInfo_tb is a TextBox
99004>>>                    Set Size to 9 207
99005>>>                    Set Location to 40 138
99006>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99007>>>                    Set peAnchors to anTopRight
99008>>>                End_Object
99009>>>
99009>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99011>>>                    Set Size to 13 68
99012>>>                    Set Location to 38 319
99013>>>                    Set Label to "GO !"
99014>>>                    Set FontWeight to fw_Bold
99015>>>                    Set peAnchors to anTopRight
99016>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99017>>>
99017>>>                    Procedure OnClick
99020>>>                        String sFileList
99020>>>                        Integer iRetval iCount
99020>>>                        Boolean bExits
99020>>>
99020>>>                        Get Value of oFilelistPath_fm to sFileList
99021>>>                        Get vFilePathExists sFileList to bExits
99022>>>                        If (bExits = False) Begin
99024>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99025>>>                            Procedure_Return
99026>>>                        End
99026>>>>
99026>>>
99026>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99027>>>                        If (iRetval <> MBR_Yes) Begin
99029>>>                            Procedure_Return
99030>>>                        End
99030>>>>
99030>>>                        Send Cursor_Wait of Cursor_Control
99031>>>
99031>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99032>>>
99032>>>                        Send Cursor_Ready of Cursor_Control
99033>>>                        If (iCount <> 0) Begin
99035>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99036>>>                        End
99036>>>>
99036>>>                        Else Begin
99037>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99038>>>                        End
99038>>>>
99038>>>
99038>>>                    End_Procedure
99039>>>
99039>>>                End_Object
99040>>>
99040>>>            End_Object
99041>>>
99041>>>            Object oOutput_grp is a Group
99043>>>                Set Size to 47 402
99044>>>                Set Location to 234 12
99045>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99046>>>                Set peAnchors to anTopLeftRight
99047>>>
99047>>>                Object oOutput_rg is a RadioGroup
99049>>>                    Set Location to 18 13
99050>>>                    Set Size to 25 288
99051>>>                    Set Label to "Filelist Output Order"
99052>>>
99052>>>                    Object oRadio1 is a Radio
99054>>>                        Set Label to "Filelist Number"
99055>>>                        Set Size to 10 61
99056>>>                        Set Location to 10 7
99057>>>                    End_Object
99058>>>
99058>>>                    Object oRadio2 is a Radio
99060>>>                        Set Label to "Logical Name"
99061>>>                        Set Size to 10 61
99062>>>                        Set Location to 10 77
99063>>>                    End_Object
99064>>>
99064>>>                    Object oRadio3 is a Radio
99066>>>                        Set Label to "Root Name"
99067>>>                        Set Size to 10 61
99068>>>                        Set Location to 10 147
99069>>>                    End_Object
99070>>>
99070>>>                    Object oRadio4 is a Radio
99072>>>                        Set Label to "Display Name"
99073>>>                        Set Size to 10 62
99074>>>                        Set Location to 10 213
99075>>>                    End_Object
99076>>>
99076>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99079>>>                        Forward Send Notify_Select_State iToItem iFromItem
99081>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99082>>>                    End_Procedure
99083>>>
99083>>>                End_Object
99084>>>                
99084>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99086>>>                    Set Size to 13 78
99087>>>                    Set Location to 26 315
99088>>>                    Set Label to "Print to Filelist.txt"
99089>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99090>>>                    Set psImage to "ActionDocument1.ico"
99091>>>
99091>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99093>>>
99093>>>                    // Custom array sort function.
99093>>>                    // iSortOrder = 0 -> Filelist number order
99093>>>                    // iSortOrder = 1 -> Logical name order
99093>>>                    // iSortOrder = 2 -> Root name order
99093>>>                    // iSortOrder = 3 -> Display name order
99093>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99096>>>                        Integer iSortOrder
99096>>>
99096>>>                        Get piSortOrder to iSortOrder
99097>>>
99097>>>                        Case Begin
99097>>>                            Case (iSortOrder = 0)
99099>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99101>>>                                    Function_Return (GT)
99102>>>                                End
99102>>>>
99102>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99104>>>                                    Function_Return (LT)
99105>>>                                End
99105>>>>
99105>>>                                Function_Return (EQ)
99106>>>                            Case (iSortOrder = 1)
99109>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99111>>>                                    Function_Return (GT)
99112>>>                                End
99112>>>>
99112>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99114>>>                                    Function_Return (LT)
99115>>>                                End
99115>>>>
99115>>>                                Function_Return (EQ)
99116>>>                            Case (iSortOrder = 2)
99119>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99121>>>                                    Function_Return (GT)
99122>>>                                End
99122>>>>
99122>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99124>>>                                    Function_Return (LT)
99125>>>                                End
99125>>>>
99125>>>                                Function_Return (EQ)
99126>>>                            Case (iSortOrder = 3)
99129>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99131>>>                                    Function_Return (GT)
99132>>>                                End
99132>>>>
99132>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99134>>>                                    Function_Return (LT)
99135>>>                                End
99135>>>>
99135>>>                                Function_Return (EQ)
99136>>>                        Case End
99136>>>
99136>>>                    End_Function
99137>>>
99137>>>                    Procedure OnClick
99140>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99140>>>                        Integer iCh iCount iSize
99140>>>                        Handle hTable
99140>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99140>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99142>>>
99142>>>                        Get Value of oFilelistPath_fm to sFileList
99143>>>                        Move (Trim(sFileList)) to sFileList
99144>>>                        If (sFileList = "") Begin
99146>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99147>>>                            Procedure_Return
99148>>>                        End
99148>>>>
99148>>>
99148>>>                        Get ParseFolderName sFileList to sPath
99149>>>                        Get vFolderFormat sPath to sPath
99150>>>                        Get ParseFileName sFileList to sOutputName
99151>>>                        Get ParseFileExtension sFileList to sExt
99152>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99153>>>                        Move (sOutputName + "txt")           to sOutputName
99154>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99155>>>                        If (iCh < 0) Begin
99157>>>                            Procedure_Return
99158>>>                        End
99158>>>>
99158>>>
99158>>>                        Move 0 to hTable
99159>>>                        Writeln channel iCh sFileList
99162>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99165>>>                        Writeln channel iCh "==================================================================================================="
99168>>>                        Writeln channel iCh
99170>>>
99170>>>                        Move 0 to iCount
99171>>>                        Repeat
99171>>>>
99171>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99174>>>                            If (hTable > 0) Begin
99176>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99177>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99180>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99183>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99186>>>                                Increment iCount
99187>>>                            End
99187>>>>
99187>>>                        Until (hTable = 0)
99189>>>
99189>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99190>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99191>>>                        Decrement iSize
99192>>>
99192>>>                        For iCount from 0 to iSize
99198>>>>
99198>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99199>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99200>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99201>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99202>>>
99202>>>                            Get PadLeft (String(hTable))        09 to sTable
99203>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99204>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99205>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99206>>>
99206>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99212>>>                        Loop
99213>>>>
99213>>>
99213>>>                        Writeln channel iCh "==================================================================================================="
99216>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99220>>>                        Close_Output
99221>>>
99221>>>                        Send vShellExecute "open" sOutputName "" sPath
99222>>>                    End_Procedure
99223>>>
99223>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99226>>>                        String sChar
99226>>>
99226>>>                        If (Num_Arguments >= 3) Begin
99228>>>                            Move sOptChar to sChar
99229>>>                        End
99229>>>>
99229>>>                        Else Begin
99230>>>                            Move " " to sChar
99231>>>                        End
99231>>>>
99231>>>
99231>>>                        While (Length(sString) < iLength)
99235>>>                            Move (sChar + sString) to sString
99236>>>                        Loop
99237>>>>
99237>>>
99237>>>                        Function_Return sString
99238>>>                    End_Function
99239>>>
99239>>>                End_Object
99240>>>            End_Object
99241>>>
99241>>>        End_Object
99242>>>
99242>>>    End_Object
99243>>>
99243>>>    Procedure OnFileDropped String sFilename Boolean bLast
99246>>>        String sTest
99246>>>        Forward Send OnFileDropped sFilename bLast
99248>>>        If (bLast = True) Begin
99250>>>            Get ParseFileName sFilename to sTest
99251>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99253>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99254>>>                Procedure_Return
99255>>>            End
99255>>>>
99255>>>            Set Value of oFilelistPath_fm to sFilename
99256>>>        End
99256>>>>
99256>>>    End_Procedure
99257>>>
99257>>>End_Object
99258>
99258>        Procedure Activate_About
99261>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99262>        End_Procedure
99263>
99263>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99264>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99265>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99266>    End_Object
99267>
99267>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99267>    // in the oHtmlHelp object, so we need to explitetly send the message
99267>    // to that object.
99267>    Procedure ShowProgramHelp
99270>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99271>    End_Procedure
99272>
99272>    On_Key Key_F1 Send ShowProgramHelp
99273>End_Object
99274>
99274>// *** Note: If you get a compile error: "Can't include the resource COMPILEHEADER.H",
99274>//     you will need to compile the "WriteDateTimeHeaderFile" program first. ***
99274>Start_UI
99275>
Including Resources...
Summary
Memory Available: 61729603584
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52832
Total Resources: 10
Total Commands : 99274
Total Windows  : 0
Total Pages    : 0
Static Data    : 845959
Message area   : 639142
Total Blocks   : 80724
