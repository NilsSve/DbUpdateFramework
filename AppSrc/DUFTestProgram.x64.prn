Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 47481430016
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set phIntFilesTable to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Send RestoreIntFiles
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Send SaveUpdateIntFiles    
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74835>>>>>    End_Procedure
74836>>>>>
74836>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74839>>>>>        Boolean bVisible
74839>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74840>>>>>        Function_Return (bVisible)
74841>>>>>    End_Function
74842>>>>>
74842>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74842>>>>>    // objects defined within this instance of the status panel.
74842>>>>>
74842>>>>>    // note: all of the messages that change text should be forwarded
74842>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74842>>>>>
74842>>>>>    Procedure Set Message_Text String sText
74845>>>>>        Set Label of oMessageTxt to sText
74846>>>>>        Forward Set Message_Text to sText
74848>>>>>    End_Procedure
74849>>>>>
74849>>>>>    Function Message_Text Returns String
74852>>>>>        Function_Return (Label(oMessageTxt))
74853>>>>>    End_Function
74854>>>>>
74854>>>>>    Procedure Set Action_Text String sText
74857>>>>>        Set Label of oActionTxt to sText
74858>>>>>        Forward Set Action_Text to sText
74860>>>>>    End_Procedure
74861>>>>>
74861>>>>>    Function Action_Text Returns String
74864>>>>>        Function_Return (Label(oActionTxt))
74865>>>>>    End_Function
74866>>>>>
74866>>>>>    Procedure Set Button_Text String sText
74869>>>>>        Set Label of oStopButton to sText
74870>>>>>        Forward Set Button_Text to sText
74872>>>>>    End_Procedure
74873>>>>>
74873>>>>>    Function Button_Text Returns String
74876>>>>>        Function_Return (Label(oStopButton))
74877>>>>>    End_Function
74878>>>>>
74878>>>>>    Procedure Set Title_Text String sText
74881>>>>>        Set Label of oTitleTxt to sText
74882>>>>>        Forward Set Title_Text to sText
74884>>>>>    End_Procedure
74885>>>>>
74885>>>>>    Function Title_Text Returns String
74888>>>>>        Function_Return (Label(oTitleTxt))
74889>>>>>    End_Function
74890>>>>>
74890>>>>>    Procedure Set TableName_Text String sText
74893>>>>>        Set Label of oTableNameTxt to sText
74894>>>>>    End_Procedure
74895>>>>>
74895>>>>>    Function TableName_Text Returns String
74898>>>>>        Function_Return (Label(oTableNameTxt))
74899>>>>>    End_Function
74900>>>>>
74900>>>>>    Procedure Set License_Text String sText
74903>>>>>//        Set Label of oLicense_txt to sText
74903>>>>>    End_Procedure
74904>>>>>
74904>>>>>    // gets called when status panel is activated passing whether a button
74904>>>>>    // should appear
74904>>>>>    Procedure EnableCancelButton Boolean bEnable
74907>>>>>        Boolean bVisible
74907>>>>>        Get Cancel_Button_Visible_State to bVisible
74908>>>>>        If (bEnable = False) Begin
74910>>>>>            Set Visible_State of oStopButton to bVisible
74911>>>>>        End
74911>>>>>>
74911>>>>>        Set Enabled_State of oStopButton to bEnable
74912>>>>>    End_Procedure
74913>>>>>
74913>>>>>    Procedure Reset_StatusPanel
74916>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74917>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74918>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74919>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74920>>>>>    End_Procedure
74921>>>>>
74921>>>>>//    Object oProgressBar is a cProgressBar
74921>>>>>//        Move Self to ghoProgressBar
74921>>>>>//        Set Location to 1 25
74921>>>>>//        Set Size to 9 173
74921>>>>>//        Set piMinimum        to 0
74921>>>>>//        Set piMaximum        to 2000
74921>>>>>//        Set piAdvanceBy      to 100
74921>>>>>//        Set pbSmooth to True
74921>>>>>//
74921>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74921>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74921>>>>>//        // color will show correctly.
74921>>>>>//        Procedure Page Integer iPageObject
74921>>>>>//            Handle hWin
74921>>>>>//            Forward Send Page iPageObject
74921>>>>>//            If (ghoSkinFramework <> 0) Begin
74921>>>>>//                Get Window_Handle to hWin
74921>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74921>>>>>//            End
74921>>>>>//        End_Procedure
74921>>>>>//    End_Object
74921>>>>>
74921>>>>>End_Object
74922>>>>>
74922>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74922>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74922>>>>>//
74922>>>>>Use VdfBase.pkg
74922>>>>>Use cApplication.pkg
74922>>>>>Use seq_chnl.pkg
74922>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74922>>>>>>>// This code is part of VDF GUIdance
74922>>>>>>>// Visit us @ http://www.vdf-guidance.com
74922>>>>>>>// e-Mail us @ info@vdf-guidance.com
74922>>>>>>>// VDF GUIdance is a mutual project of
74922>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74922>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74922>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74922>>>>>>>//
74922>>>>>>>//
74922>>>>>>>// *** Windows 32bit file handling wrapper class ***
74922>>>>>>>//
74922>>>>>>>
74922>>>>>>>
74922>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74922>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>//*
74922>>>>>>>>>//* Class:        cvSaveAsDialog
74922>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74922>>>>>>>>>//*
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>
74922>>>>>>>>>Use File_dlg.pkg
74922>>>>>>>>>
74922>>>>>>>>>// *WvA: 13-01-1999 Created
74922>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74922>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74922>>>>>>>>>// file_name.
74922>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74923>>>>>>>>>
74923>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74925>>>>>>>>>        Forward Send Construct_Object iImage_Id
74927>>>>>>>>>        Set HideReadOnly_State to True
74928>>>>>>>>>    End_Procedure
74929>>>>>>>>>
74929>>>>>>>>>    Function SelectedFileName Returns String
74931>>>>>>>>>        String sFileName
74931>>>>>>>>>        Move "" to sFileName
74932>>>>>>>>>        If (Show_Dialog(Self)) Begin
74934>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74935>>>>>>>>>        End
74935>>>>>>>>>>
74935>>>>>>>>>        Function_Return sFileName
74936>>>>>>>>>    End_Function
74937>>>>>>>>>End_Class
74938>>>>>>>>>
74938>>>>>>>>>// *WvA: 13-01-1999 Created
74938>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74938>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74938>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74938>>>>>>>>>//                   file-open dialog
74938>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74940>>>>>>>>>    String sSelectedFile
74940>>>>>>>>>    Integer hoOpenFileDialog
74940>>>>>>>>>
74940>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74942>>>>>>>>>
74942>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74943>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74944>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74945>>>>>>>>>
74945>>>>>>>>>        Move Self       to hoOpenFileDialog
74946>>>>>>>>>    End_Object
74947>>>>>>>>>
74947>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74948>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74949>>>>>>>>>    Function_Return sSelectedFile
74950>>>>>>>>>End_Function
74951>>>>>>>>>
74951>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74952>>>>>>>>>
74952>>>>>>>>>    Procedure Construct_Object
74954>>>>>>>>>        Forward Send Construct_Object
74956>>>>>>>>>        Set HideReadOnly_State to True
74957>>>>>>>>>    End_Procedure
74958>>>>>>>>>
74958>>>>>>>>>    Function SelectedFileName Returns String
74960>>>>>>>>>        String sFileName
74960>>>>>>>>>        Move "" to sFileName
74961>>>>>>>>>        If (Show_Dialog(Self)) Begin
74963>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74964>>>>>>>>>        End
74964>>>>>>>>>>
74964>>>>>>>>>        Function_Return sFileName
74965>>>>>>>>>    End_Function
74966>>>>>>>>>
74966>>>>>>>>>End_Class
74967>>>>>>>>>
74967>>>>>>>>>// Added optional default filename as suggested by Nils
74967>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74969>>>>>>>>>    String sSelectedFile
74969>>>>>>>>>    Integer hoDialog
74969>>>>>>>>>
74969>>>>>>>>>    Move "" to sSelectedFile
74970>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74971>>>>>>>>>    If (hoDialog) Begin
74973>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74973>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74974>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74975>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74976>>>>>>>>>        If (Num_Arguments = 4) Begin
74978>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74979>>>>>>>>>        End
74979>>>>>>>>>>
74979>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74980>>>>>>>>>        Send Destroy of hoDialog
74981>>>>>>>>>    End
74981>>>>>>>>>>
74981>>>>>>>>>    Function_Return sSelectedFile
74982>>>>>>>>>End_Function
74983>>>>>>>Use Seq_chnl.pkg
74983>>>>>>>
74983>>>>>>>Use windows.pkg
74983>>>>>>>Use Dll.pkg
74983>>>>>>>
74983>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
74983>>>>>>>>>// This code is part of VDF GUIdance
74983>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74983>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74983>>>>>>>>>// VDF GUIdance is a mutual project of
74983>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74983>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74983>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74983>>>>>>>>>//
74983>>>>>>>>>//
74983>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74983>>>>>>>>>// Unicode variant
74983>>>>>>>>>
74983>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
74983>>>>>>>>>>>//TH-Header
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74983>>>>>>>>>>>// All rights reserved.
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74983>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74983>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74983>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74983>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// Contents:
74983>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74983>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>//TH-RevisionStart
74983>>>>>>>>>>>//TH-RevisionEnd
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vMax_Path     For |CI260
74983>>>>>>>>>>>Define vMinChar      For |CI$80
74983>>>>>>>>>>>Define vMaxChar      For |CI$7F
74983>>>>>>>>>>>Define vMinShort     For |CI$8000
74983>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74983>>>>>>>>>>>Define vMinLong      For |CI$80000000
74983>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74983>>>>>>>>>>>Define vMaxByte      For |CI$FF
74983>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74983>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// For FindFirstFile
74983>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74983>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74983>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74983>>>>>>>>>>>
74983>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74983>>>>>>>>>>>// the API-call ShellExecute is used.
74983>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74983>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74983>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74983>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74983>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74983>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74983>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74983>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74983>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74983>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74983>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74983>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74983>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74983>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// C-Structure
74983>>>>>>>>>>>//typedef struct _browseinfo {
74983>>>>>>>>>>>//    HWND hwndOwner;
74983>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74983>>>>>>>>>>>//    LPSTR pszDisplayName;
74983>>>>>>>>>>>//    LPCSTR lpszTitle;
74983>>>>>>>>>>>//    UINT ulFlags;
74983>>>>>>>>>>>//    BFFCALLBACK lpfn;
74983>>>>>>>>>>>//    LPARAM lParam;
74983>>>>>>>>>>>//    int iImage;
74983>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74983>>>>>>>>>>>
74983>>>>>>>>>>>//declare C structure struct_browseinfo
74983>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74983>>>>>>>>>>>Struct tvBrowseInfo
74983>>>>>>>>>>>  Handle    hWndOwner
74983>>>>>>>>>>>  Pointer   pIDLRoot
74983>>>>>>>>>>>  Pointer   pszDisplayName
74983>>>>>>>>>>>  Pointer   lpszTitle
74983>>>>>>>>>>>  DWord     ulFlags
74983>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
74983>>>>>>>>>>>  Pointer   lpfnCallback
74983>>>>>>>>>>>  LongPtr   lParam
74983>>>>>>>>>>>  DWord     iImage
74983>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
74983>>>>>>>>>>>End_Struct // tvBrowseInfo
74983>>>>>>>>>>>
74983>>>>>>>>>>>// Browsing for directory.
74983>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74983>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74983>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74983>>>>>>>>>>>                                            // The callback function can set the status text by
74983>>>>>>>>>>>                                            // sending messages to the dialog box.
74983>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74983>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74983>>>>>>>>>>>
74983>>>>>>>>>>>// message from browser
74983>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74983>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74983>>>>>>>>>>>
74983>>>>>>>>>>>// messages to browser
74983>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74983>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74983>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74984>>>>>>>>>>>
74984>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74985>>>>>>>>>>>
74985>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>Struct tvSecurity_attributes
74986>>>>>>>>>>>  DWord   nLength
74986>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
74986>>>>>>>>>>>  Pointer lpDescriptor
74986>>>>>>>>>>>  Integer bInheritHandle
74986>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
74986>>>>>>>>>>>End_Struct // tvSecurity_attributes
74986>>>>>>>>>>>
74986>>>>>>>>>>>//nLength:
74986>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74986>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74986>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74986>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74986>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//lpSecurityDescriptor:
74986>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74986>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74986>>>>>>>>>>>// descriptor of the calling process.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//bInheritHandle:
74986>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74986>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>// BOOL CreateDirectory(
74986>>>>>>>>>>>//    LPCTSTR lpPathName,
74986>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74986>>>>>>>>>>>//   );
74986>>>>>>>>>>>//
74986>>>>>>>>>>>// lpPathName
74986>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74986>>>>>>>>>>>//  to be created.
74986>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74986>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74986>>>>>>>>>>>// lpSecurityAttributes
74986>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74986>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74986>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74986>>>>>>>>>>>// Returns:
74986>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74986>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74986>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
74987>>>>>>>>>>>
74987>>>>>>>>>>>
74987>>>>>>>>>>>// lpPathName
74987>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74987>>>>>>>>>>>//  to be removed.
74987>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74987>>>>>>>>>>>// Returns:
74987>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74987>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74987>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74988>>>>>>>>>>>// executable file or a document file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Operation can be one of the following:
74988>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74988>>>>>>>>>>>//            The file can be an executable file or a document file.
74988>>>>>>>>>>>//            The file can be a folder to open.
74988>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74988>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74988>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74988>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Return Values:
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74988>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74988>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// The following table lists these error values:
74988>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74988>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74988>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74988>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74988>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74988>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74988>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74988>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74988>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74988>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
74988>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74988>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
74988>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
74988>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// Code to open the program that is associated with the selected file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// External function call used in Procedure DoStartDocument
74988>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
74989>>>>>>>>>>>Define vFO_COPY                For |CI$0002
74989>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
74989>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74989>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74989>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74989>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74989>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74989>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74989>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74989>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74989>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74989>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74989>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74989>>>>>>>>>>>
74989>>>>>>>>>>>Struct tvShFileOpStruct
74989>>>>>>>>>>>  Handle   hWnd
74989>>>>>>>>>>>  UInteger wFunc
74989>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
74989>>>>>>>>>>>  Pointer  pFrom
74989>>>>>>>>>>>  Pointer  pTo
74989>>>>>>>>>>>  Short    fFlags
74989>>>>>>>>>>>  Integer  fAnyOperationsAborted
74989>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
74989>>>>>>>>>>>  Pointer  hNameMappings
74989>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74989>>>>>>>>>>>End_Struct // tvShFileOpStruct
74989>>>>>>>>>>>
74989>>>>>>>>>>>// hwnd
74989>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// wFunc
74989>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74989>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74989>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pFrom
74989>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74989>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pTo
74989>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74989>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74989>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74989>>>>>>>>>>>//   double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// fAnyOperationsAborted
74989>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74989>>>>>>>>>>>//   were completed or FALSE otherwise.
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74989>>>>>>>>>>>// This can be a file or a folder.
74989>>>>>>>>>>>// With thanks to Andrew S Kaplan
74989>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
74990>>>>>>>>>>>
74990>>>>>>>>>>>
74990>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74990>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74991>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74991>>>>>>>>>>>//   Pointer lpPathName ;
74991>>>>>>>>>>>//   Pointer lpPrefixString ;
74991>>>>>>>>>>>//   Integer uUnique ;
74991>>>>>>>>>>>//   Pointer lpTempFileName ;
74991>>>>>>>>>>>//   Returns Integer
74991>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74991>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
74992>>>>>>>>>>>
74992>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74993>>>>>>>>>>>
74993>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
74994>>>>>>>>>>>
74994>>>>>>>>>>>// from:
74994>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74994>>>>>>>>>>>//
74994>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74994>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74994>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74994>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74994>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74994>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74994>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74994>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74994>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74994>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74994>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74994>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74994>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74994>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74994>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74994>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74994>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74994>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74994>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74994>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74994>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74994>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74994>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74994>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74994>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74994>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74994>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74994>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74994>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74994>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74994>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74994>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74994>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74994>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74994>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74994>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74994>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74994>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74994>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74994>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74994>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74994>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74994>>>>>>>>>>>
74994>>>>>>>>>>>
74994>>>>>>>>>>>//HRESULT SHGetFolderPath(
74994>>>>>>>>>>>//    HWND hwndOwner,
74994>>>>>>>>>>>//    int nFolder,
74994>>>>>>>>>>>//    HANDLE hToken,
74994>>>>>>>>>>>//    DWORD dwFlags,
74994>>>>>>>>>>>//    LPTSTR pszPath
74994>>>>>>>>>>>//);
74994>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74994>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74994>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74994>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74994>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74994>>>>>>>>>>>//
74994>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>Struct tvWin32FindData
74995>>>>>>>>>>> Dword            dwFileAttributes
74995>>>>>>>>>>> Dword            ftCreationLowDateTime
74995>>>>>>>>>>> Dword            ftCreationHighDateTime
74995>>>>>>>>>>> dword            ftLastAccessLowDateTime
74995>>>>>>>>>>> Dword            ftLastAccessHighDateTime
74995>>>>>>>>>>> Dword            ftLastWriteLowDateTime
74995>>>>>>>>>>> Dword            ftLastWriteHighDateTime
74995>>>>>>>>>>> Dword            nFileSizeHigh
74995>>>>>>>>>>> Dword            nFileSizeLow
74995>>>>>>>>>>> Dword            dwReserved0
74995>>>>>>>>>>> Dword            dwReserved1
74995>>>>>>>>>>> Short[vMax_Path] cFileName
74995>>>>>>>>>>> Short[14]        cAlternateFileName
74995>>>>>>>>>>>End_Struct
74995>>>>>>>>>>>
74995>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74995>>>>>>>>>>>// lpFileName      : address of name of file to search for
74995>>>>>>>>>>>// lpFindFileData  : address of returned information
74995>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
74996>>>>>>>>>>>
74996>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74996>>>>>>>>>>>// hFindFile       : handle of search
74996>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74996>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74997>>>>>>>>>>>
74997>>>>>>>>>>>
74997>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74997>>>>>>>>>>>//  hFindFile      : file search handle
74997>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvFileTime
74998>>>>>>>>>>>  DWord dwLowDateTime
74998>>>>>>>>>>>  DWord dwHighDateTime
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvSystemTime
74998>>>>>>>>>>>  UShort wYear
74998>>>>>>>>>>>  UShort wMonth
74998>>>>>>>>>>>  UShort wDayOfWeek
74998>>>>>>>>>>>  UShort wDay
74998>>>>>>>>>>>  UShort wHour
74998>>>>>>>>>>>  UShort wMinute
74998>>>>>>>>>>>  UShort wSecond
74998>>>>>>>>>>>  UShort wMilliSeconds
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74998>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74998>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74998>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74999>>>>>>>>>>>
74999>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74999>>>>>>>>>>>// This function formats the time in a picture-string passed
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// Picture      Meaning
74999>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74999>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74999>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74999>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74999>>>>>>>>>>>//    t         One character time marker string, such as A or P
74999>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74999>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74999>>>>>>>>>>>
74999>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75000>>>>>>>>>>>
75000>>>>>>>>>>>
75000>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75000>>>>>>>>>>>// This function formats the date in a picture-string passed
75000>>>>>>>>>>>//
75000>>>>>>>>>>>// Picture      Meaning
75000>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75000>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75000>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75000>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75000>>>>>>>>>>>//              value associated with the specified locale.
75000>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75000>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75000>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75000>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75000>>>>>>>>>>>//              associated with the specified locale.
75000>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75000>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75000>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75000>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75000>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75000>>>>>>>>>>>//              does not have an associated era or period string.
75000>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75000>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75000>>>>>>>>>>>
75000>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75001>>>>>>>>>>>
75001>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75001>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75001>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75001>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75001>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75001>>>>>>>>>>>
75001>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75001>>>>>>>>>>>//
75001>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75001>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75001>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75001>>>>>>>>>>>
75001>>>>>>>>>>>
75001>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>// **WvA: 20-02-2004
75002>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75002>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75002>>>>>>>>>>>// incorrectly into an unsigned integer.
75002>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75002>>>>>>>>>>>// It does smell a bit fishy though
75002>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75002>>>>>>>>>>>
75002>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75002>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75002>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75002>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75002>>>>>>>>>>>
75002>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75002>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75002>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75002>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>> // Courtesy Of Steve Walter,
75002>>>>>>>>>>> // USA Software, Inc
75002>>>>>>>>>>> // Format a disk
75002>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75002>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75003>>>>>>>>>>>
75003>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75003>>>>>>>>>>>
75003>>>>>>>>>>>// SHCreateDirectoryEx
75003>>>>>>>>>>>
75003>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75003>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75003>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75003>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75003>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75003>>>>>>>>>>>//        ERROR_CANCELLED.
75003>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75003>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75003>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75003>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75003>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75003>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75003>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75003>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        int SHCreateDirectoryEx(
75003>>>>>>>>>>>//            HWND hwnd,
75003>>>>>>>>>>>//            LPCTSTR pszPath,
75003>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75003>>>>>>>>>>>//        );
75003>>>>>>>>>>>
75003>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75004>>>>>>>>>>>
75004>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75005>>>>>>>>>// This also works with UNC path encoding and wildcards
75005>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75007>>>>>>>>>    Boolean bFolderExists
75007>>>>>>>>>    Boolean bStop
75007>>>>>>>>>    String  sFolder sTmp
75007>>>>>>>>>    Integer iCh
75007>>>>>>>>>
75007>>>>>>>>>    If (sFolderName = "") Begin
75009>>>>>>>>>        Function_Return False
75010>>>>>>>>>    End
75010>>>>>>>>>>
75010>>>>>>>>>
75010>>>>>>>>>    Move True  to bFolderExists
75011>>>>>>>>>    Move False to bStop
75012>>>>>>>>>    Move "dir:" to sFolder
75013>>>>>>>>>    Append sFolder sFolderName
75014>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75015>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75017>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75018>>>>>>>>>>
75018>>>>>>>>>        Function_Return False
75019>>>>>>>>>    End
75019>>>>>>>>>>
75019>>>>>>>>>    Direct_Input channel iCh sFolder
75021>>>>>>>>>    Repeat
75021>>>>>>>>>>
75021>>>>>>>>>        Readln channel iCh sTmp
75023>>>>>>>>>        Move (SeqEof) to bStop
75024>>>>>>>>>        If (Trim(sTmp)="") Begin
75026>>>>>>>>>            Move False to bFolderExists
75027>>>>>>>>>        End
75027>>>>>>>>>>
75027>>>>>>>>>        Else Begin
75028>>>>>>>>>            Move True to bFolderExists
75029>>>>>>>>>            Move True to bStop
75030>>>>>>>>>        End
75030>>>>>>>>>>
75030>>>>>>>>>    Until (bStop)
75032>>>>>>>>>    Close_Input channel iCh
75034>>>>>>>>>    Send Seq_Release_Channel iCh
75035>>>>>>>>>    Function_Return bFolderExists
75036>>>>>>>>>End_Function
75037>>>>>>>>>
75037>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75037>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75039>>>>>>>>>    String  sPath
75039>>>>>>>>>    WString sFolder sTitle
75039>>>>>>>>>    Pointer lpItemIdList
75039>>>>>>>>>    Integer iFolderSelected iRetval
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>
75039>>>>>>>>>    Move "" to sPath
75040>>>>>>>>>    If (sDialogTitle<>"") Begin
75042>>>>>>>>>        Move sDialogTitle to sTitle
75043>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75043>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75043>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75043>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75043>>>>>>>>>        // selected it will always be valid.
75043>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75044>>>>>>>>>    End
75044>>>>>>>>>>
75044>>>>>>>>>
75044>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75045>>>>>>>>>
75045>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75045>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75045>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75046>>>>>>>>>
75046>>>>>>>>>    // null 128 chars into var (make space)
75046>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75047>>>>>>>>>
75047>>>>>>>>>    // select folder
75047>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75048>>>>>>>>>    // get selected folder name
75048>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75049>>>>>>>>>
75049>>>>>>>>>    // release memory resources that are used by the ItemIdList
75049>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75050>>>>>>>>>
75050>>>>>>>>>    If (iFolderSelected<>0) Begin
75052>>>>>>>>>        Move (CString(sFolder)) to sPath
75053>>>>>>>>>    End
75053>>>>>>>>>>
75053>>>>>>>>>    Function_Return  sPath
75054>>>>>>>>>End_Function
75055>>>>>>>>>
75055>>>>>>>>>// returns 0 if the folder is created.
75055>>>>>>>>>//         1 if the API-call returned an error.
75055>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75057>>>>>>>>>    Integer  iRetval bFolderCreated
75057>>>>>>>>>    WString  sFolder
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>
75057>>>>>>>>>    Move False to bFolderCreated
75058>>>>>>>>>    If (sNewFolder <> "") Begin
75060>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75061>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75062>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75063>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75064>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75065>>>>>>>>>    End
75065>>>>>>>>>>
75065>>>>>>>>>
75065>>>>>>>>>    If (bFolderCreated=false) Begin
75067>>>>>>>>>        Move 1 to iRetVal
75068>>>>>>>>>    End
75068>>>>>>>>>>
75068>>>>>>>>>    Function_Return iRetVal
75069>>>>>>>>>End_Function
75070>>>>>>>>>
75070>>>>>>>>>// **WvA: 03-02-2002 Function created.
75070>>>>>>>>>// With this function one can remove a directory.
75070>>>>>>>>>// returns 0 if the folder is removed.
75070>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75070>>>>>>>>>//         2 if the folder did not exist
75070>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75070>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75072>>>>>>>>>    Boolean bRemoved
75072>>>>>>>>>    WString sPath
75072>>>>>>>>>    Integer iRetval
75072>>>>>>>>>
75072>>>>>>>>>    Move 0     to iRetVal
75073>>>>>>>>>    Move False to bRemoved
75074>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75075>>>>>>>>>    If (sFolder="") Begin
75077>>>>>>>>>        Move 3 to iRetVal
75078>>>>>>>>>    End
75078>>>>>>>>>>
75078>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75080>>>>>>>>>        Move 2 to iRetVal
75081>>>>>>>>>    End
75081>>>>>>>>>>
75081>>>>>>>>>    If (iRetVal=0) Begin
75083>>>>>>>>>        // null MAX_PATH chars into var (make space)
75083>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75084>>>>>>>>>        //
75084>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75085>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75086>>>>>>>>>    End
75086>>>>>>>>>>
75086>>>>>>>>>
75086>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75088>>>>>>>>>        Move 1 to iRetVal
75089>>>>>>>>>    End
75089>>>>>>>>>>
75089>>>>>>>>>    Function_Return iRetVal
75090>>>>>>>>>End_Function
75091>>>>>>>>>
75091>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75091>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75091>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75091>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75093>>>>>>>>>    Handle  hInstance hWnd
75093>>>>>>>>>    // remove any leading/trailing spaces in the string
75093>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75094>>>>>>>>>    Move (Trim(sPath))     to sPath
75095>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75095>>>>>>>>>    Append sOperation   (Character(0))
75096>>>>>>>>>    Append sDocument    (Character(0))
75097>>>>>>>>>    Append sParameters  (Character(0))
75098>>>>>>>>>    Append sPath        (Character(0))
75099>>>>>>>>>
75099>>>>>>>>>    Get Window_Handle to hWnd
75100>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75101>>>>>>>>>    If (hInstance <= 32) Begin
75103>>>>>>>>>        Send vDDE_Error_Handler hInstance
75104>>>>>>>>>    End
75104>>>>>>>>>>
75104>>>>>>>>>End_Procedure
75105>>>>>>>>>
75105>>>>>>>>>Class cShellFileOperations is a Array
75106>>>>>>>>>
75106>>>>>>>>>    Procedure Construct_Object
75108>>>>>>>>>        Forward Send Construct_Object
75110>>>>>>>>>        Property Integer piDeleteFlags        0
75111>>>>>>>>>        Property Integer piCopyFlags          0
75112>>>>>>>>>        Property Integer piMoveFlags          0
75113>>>>>>>>>        Property Integer piRenameFlags        0
75114>>>>>>>>>
75114>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75115>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75116>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75117>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75118>>>>>>>>>    End_Procedure
75119>>>>>>>>>
75119>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75119>>>>>>>>>    // files supplied.
75119>>>>>>>>>    //
75119>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75121>>>>>>>>>        Integer  iRetVal
75121>>>>>>>>>        Integer  iUserAbort
75121>>>>>>>>>        WString  wsSource wsDestination
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>
75121>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75122>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75123>>>>>>>>>
75123>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75125>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75126>>>>>>>>>        End
75126>>>>>>>>>>
75126>>>>>>>>>
75126>>>>>>>>>        Move eOperation            to FOS.wFunc
75127>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75128>>>>>>>>>        Move iFlags                to FOS.fFlags
75129>>>>>>>>>
75129>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75130>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75131>>>>>>>>>        If (iUserAbort <> 0) Begin
75133>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75134>>>>>>>>>        End
75134>>>>>>>>>>
75134>>>>>>>>>        Function_Return (iRetVal)
75135>>>>>>>>>    End_Function
75136>>>>>>>>>
75136>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75138>>>>>>>>>        Integer  iRetVal
75138>>>>>>>>>        Integer  iFlags
75138>>>>>>>>>
75138>>>>>>>>>        Get piDeleteFlags to iFlags
75139>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75140>>>>>>>>>        Function_Return iRetVal
75141>>>>>>>>>    End_Function
75142>>>>>>>>>
75142>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75144>>>>>>>>>        Integer  iRetVal
75144>>>>>>>>>        Integer  iFlags
75144>>>>>>>>>
75144>>>>>>>>>        Get piCopyFlags to iFlags
75145>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75146>>>>>>>>>        Function_Return iRetVal
75147>>>>>>>>>    End_Function
75148>>>>>>>>>
75148>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75150>>>>>>>>>        Integer  iRetVal
75150>>>>>>>>>        Integer  iFlags
75150>>>>>>>>>
75150>>>>>>>>>        Get piMoveFlags to iFlags
75151>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75152>>>>>>>>>        Function_Return iRetVal
75153>>>>>>>>>    End_Function
75154>>>>>>>>>
75154>>>>>>>>>    // Rename a file or folder
75154>>>>>>>>>    // Returns a nonzero value if the operation failed.
75154>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75156>>>>>>>>>        Integer  iRetVal
75156>>>>>>>>>        Integer  iFlags
75156>>>>>>>>>
75156>>>>>>>>>        Get piRenameFlags to iFlags
75157>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75158>>>>>>>>>        Function_Return iRetVal
75159>>>>>>>>>    End_Function
75160>>>>>>>>>
75160>>>>>>>>>
75160>>>>>>>>>    //Example:
75160>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75160>>>>>>>>>    //                                          mode.
75160>>>>>>>>>
75160>>>>>>>>>End_Class
75161>>>>>>>>>
75161>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75163>>>>>>>>>End_Object
75164>>>>>>>>>
75164>>>>>>>>>// Restore to the old way of working with the shell file operations.
75164>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75164>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75164>>>>>>>>>Procedure vWin32fhCompatibilityMode
75166>>>>>>>>>    Integer hoSFO
75166>>>>>>>>>    Integer iFlags
75166>>>>>>>>>
75166>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75167>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75168>>>>>>>>>
75168>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75169>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75170>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75171>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75172>>>>>>>>>End_Procedure
75173>>>>>>>>>
75173>>>>>>>>>// Delete a file or folder
75173>>>>>>>>>// Returns a nonzero value if the operation failed.
75173>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75175>>>>>>>>>    Integer  iRetVal
75175>>>>>>>>>
75175>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75176>>>>>>>>>    Function_Return iRetVal
75177>>>>>>>>>End_Function
75178>>>>>>>>>
75178>>>>>>>>>// Copy a file or folder
75178>>>>>>>>>// Returns a nonzero value if the operation failed.
75178>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75180>>>>>>>>>    Integer  iRetVal
75180>>>>>>>>>
75180>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75181>>>>>>>>>    Function_Return iRetVal
75182>>>>>>>>>End_Function
75183>>>>>>>>>
75183>>>>>>>>>// Move a file or folder
75183>>>>>>>>>// Returns a nonzero value if the operation failed.
75183>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75185>>>>>>>>>    Integer  iRetVal
75185>>>>>>>>>
75185>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75186>>>>>>>>>    Function_Return iRetVal
75187>>>>>>>>>End_Function
75188>>>>>>>>>
75188>>>>>>>>>// Rename a file or folder
75188>>>>>>>>>// Returns a nonzero value if the operation failed.
75188>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75190>>>>>>>>>    Integer  iRetVal
75190>>>>>>>>>
75190>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75191>>>>>>>>>    Function_Return iRetVal
75192>>>>>>>>>End_Function
75193>>>>>>>>>
75193>>>>>>>>>Function vGetWindowsDirectory Returns String
75195>>>>>>>>>    WString wDirectory
75195>>>>>>>>>    Integer iRetVal
75195>>>>>>>>>
75195>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75196>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75197>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75199>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75200>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75201>>>>>>>>>    End
75201>>>>>>>>>>
75201>>>>>>>>>    Function_Return (CString(wDirectory))
75202>>>>>>>>>End_Function
75203>>>>>>>>>
75203>>>>>>>>>Function vGetTempPath Returns String
75205>>>>>>>>>    Integer iRetVal
75205>>>>>>>>>    WString wTempPath
75205>>>>>>>>>
75205>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75206>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75207>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75209>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75210>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75211>>>>>>>>>    End
75211>>>>>>>>>>
75211>>>>>>>>>    Function_Return (CString(wTempPath))
75212>>>>>>>>>End_Function
75213>>>>>>>>>
75213>>>>>>>>>// Courtesy of Marco Kuipers
75213>>>>>>>>>Function vMakeTempFile Returns String
75215>>>>>>>>>    Integer iRetval
75215>>>>>>>>>    String  sTempPath
75215>>>>>>>>>    String  sTempFileName
75215>>>>>>>>>    String  sPrefixString
75215>>>>>>>>>    WString wsTempFileName
75215>>>>>>>>>
75215>>>>>>>>>    Get vGetTempPath to sTempPath
75216>>>>>>>>>    If (sTempPath = "") Begin
75218>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75219>>>>>>>>>        If (sTempPath<>"") Begin
75221>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75222>>>>>>>>>        End
75222>>>>>>>>>>
75222>>>>>>>>>    End
75222>>>>>>>>>>
75222>>>>>>>>>
75222>>>>>>>>>    If (sTempPath = "") Begin
75224>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75224>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75224>>>>>>>>>        Get_Current_Directory to sTempPath
75225>>>>>>>>>    End
75225>>>>>>>>>>
75225>>>>>>>>>
75225>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75226>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75228>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75229>>>>>>>>>>
75229>>>>>>>>>    End
75229>>>>>>>>>>
75229>>>>>>>>>
75229>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75230>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75231>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75232>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75234>>>>>>>>>    //Get ShowLastError to iRetval
75234>>>>>>>>>        Move "" to sTempFileName
75235>>>>>>>>>    End
75235>>>>>>>>>>
75235>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75236>>>>>>>>>    Function_Return sTempFileName
75237>>>>>>>>>End_Function
75238>>>>>>>>>
75238>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75238>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75238>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75238>>>>>>>>>// does not take care of that.
75238>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75240>>>>>>>>>    Integer iRetVal
75240>>>>>>>>>    String  sTempFileName
75240>>>>>>>>>    WString wTempFileName
75240>>>>>>>>>
75240>>>>>>>>>    Move (sPath+Character(0))   to sPath
75241>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75242>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75243>>>>>>>>>
75243>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75244>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75245>>>>>>>>>    Function_Return sTempFileName
75246>>>>>>>>>End_Function
75247>>>>>>>>>
75247>>>>>>>>>//
75247>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75247>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75247>>>>>>>>>//
75247>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75249>>>>>>>>>    Integer iVoid
75249>>>>>>>>>    Handle  hWnd
75249>>>>>>>>>    String  sFolder
75249>>>>>>>>>    WString wFolder
75249>>>>>>>>>
75249>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75250>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75251>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75252>>>>>>>>>    Move (CString(wFolder)) to sFolder
75253>>>>>>>>>    Function_Return sFolder
75254>>>>>>>>>End_Function
75255>>>>>>>>>
75255>>>>>>>>>// Courtesy Of Vincent Oorsprong
75255>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75257>>>>>>>>>    String  sFileDateTime
75257>>>>>>>>>    WString wFormattedTime wFormattedDate
75257>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>
75257>>>>>>>>>    Move "" to sFileDateTime
75258>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75259>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75260>>>>>>>>>
75260>>>>>>>>>    Move 0 to SystemTime.wYear
75261>>>>>>>>>
75261>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75262>>>>>>>>>    If (iSuccess = 1) Begin
75264>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75265>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75266>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75267>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75268>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75269>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75270>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75271>>>>>>>>>    End
75271>>>>>>>>>>
75271>>>>>>>>>    Function_Return sFileDateTime
75272>>>>>>>>>End_Function
75273>>>>>>>>>
75273>>>>>>>>>// **WvA:
75273>>>>>>>>>// A windows replacement for the standard function FileExists.
75273>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75273>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75273>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75273>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75273>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75275>>>>>>>>>    String  sDirSep
75275>>>>>>>>>    Handle  hFindFile
75275>>>>>>>>>    Integer iVoid
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>
75275>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75276>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75277>>>>>>>>>
75277>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75279>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75279>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75280>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75284>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75285>>>>>>>>>        Loop
75286>>>>>>>>>>
75286>>>>>>>>>
75286>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75287>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75288>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75289>>>>>>>>>    End
75289>>>>>>>>>>
75289>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75290>>>>>>>>>End_Function
75291>>>>>>>>>
75291>>>>>>>>>
75291>>>>>>>>>//
75291>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75291>>>>>>>>>// Returns -1 if folder doesn't exist.
75291>>>>>>>>>// The files "." and ".." are not counted.
75291>>>>>>>>>//
75291>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75293>>>>>>>>>    Boolean bFound
75293>>>>>>>>>    Handle  hFindFile
75293>>>>>>>>>    Integer iCount  iVoid
75293>>>>>>>>>    Integer iSuccess
75293>>>>>>>>>    String  sFileName
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>
75293>>>>>>>>>    Move -1 to iCount
75294>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75295>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75296>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75297>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75298>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75299>>>>>>>>>    If (bFound) Begin
75301>>>>>>>>>        Move 0 to iCount
75302>>>>>>>>>    End
75302>>>>>>>>>>
75302>>>>>>>>>    While (bFound)
75306>>>>>>>>>        Increment iCount
75307>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75308>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75310>>>>>>>>>            Decrement iCount
75311>>>>>>>>>        End
75311>>>>>>>>>>
75311>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75312>>>>>>>>>        Move (iSuccess<>0) to bFound
75313>>>>>>>>>    Loop
75314>>>>>>>>>>
75314>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75315>>>>>>>>>    Function_Return iCount
75316>>>>>>>>>End_Function
75317>>>>>>>>>
75317>>>>>>>>>// Create the folder, including intermediate directories.
75317>>>>>>>>>// Don't panic if the folder already exists.
75317>>>>>>>>>// Michael Mullan June 2009.
75317>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75319>>>>>>>>>    String  sFolder
75319>>>>>>>>>    Integer iRetval iFolderCreated
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>
75319>>>>>>>>>    Move 0 to iFolderCreated
75320>>>>>>>>>
75320>>>>>>>>>    // null MAX_PATH chars into var (make space)
75320>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75321>>>>>>>>>    If (sNewFolder <> "") Begin
75323>>>>>>>>>
75323>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75324>>>>>>>>>        Move  0  to SA.lpDescriptor
75325>>>>>>>>>        Move  1  to SA.bInheritHandle
75326>>>>>>>>>
75326>>>>>>>>>        //
75326>>>>>>>>>        Move (sNewFolder+"") to sFolder
75327>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75328>>>>>>>>>    End
75328>>>>>>>>>>
75328>>>>>>>>>
75328>>>>>>>>>    If (iFolderCreated <> 0) Begin
75330>>>>>>>>>        Move 1 to iRetVal
75331>>>>>>>>>        Case Begin
75331>>>>>>>>>            Case (iFolderCreated = 161)
75333>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75334>>>>>>>>>>
75334>>>>>>>>>                Case Break
75335>>>>>>>>>            Case (iFolderCreated = 206)
75338>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75339>>>>>>>>>>
75339>>>>>>>>>                Case Break
75340>>>>>>>>>            Case (iFolderCreated = 3)
75343>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75344>>>>>>>>>>
75344>>>>>>>>>                Case Break
75345>>>>>>>>>            Case (iFolderCreated = 80)
75348>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75349>>>>>>>>>                Case Break
75350>>>>>>>>>            Case (iFolderCreated = 183)
75353>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75354>>>>>>>>>                Case Break
75355>>>>>>>>>            Case (iFolderCreated = 1223)
75358>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75359>>>>>>>>>>
75359>>>>>>>>>                Case Break
75360>>>>>>>>>            Case Else
75360>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75361>>>>>>>>>>
75361>>>>>>>>>        Case End
75361>>>>>>>>>    End
75361>>>>>>>>>>
75361>>>>>>>>>    Function_Return iRetVal
75362>>>>>>>>>End_Function
75363>>>>>>>>>
75363>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75365>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75365>>>>>>>>>    Integer iFileSize iVoid
75365>>>>>>>>>    Handle  hFindFile
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>
75365>>>>>>>>>    Move (sFileName+"") to sFileName
75366>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75367>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75368>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75370>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75371>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75372>>>>>>>>>    End
75372>>>>>>>>>>
75372>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75373>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75374>>>>>>>>>
75374>>>>>>>>>    Function_Return iFileSize
75375>>>>>>>>>End_Function
75376>>>>>>>>>
75376>>>>>>>>>//
75376>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75376>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75376>>>>>>>>>//
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>// Verifies that a path is a valid directory.
75376>>>>>>>>>//
75376>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75376>>>>>>>>>//
75376>>>>>>>>>// Parameters:
75376>>>>>>>>>//      sPath - Address of the path to verify.
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75378>>>>>>>>>    Integer iResult
75378>>>>>>>>>    Boolean bRetVal
75378>>>>>>>>>
75378>>>>>>>>>    Move false to bRetVal
75379>>>>>>>>>    Move (sPath - Character (0)) to sPath
75380>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75381>>>>>>>>>    If (iResult<>0) Begin
75383>>>>>>>>>        Move True to bRetVal
75384>>>>>>>>>    End
75384>>>>>>>>>>
75384>>>>>>>>>
75384>>>>>>>>>    Function_Return bRetVal
75385>>>>>>>>>End_Function
75386>>>>>>>>>
75386>>>>>>>
75386>>>>>>>//
75386>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75386>>>>>>>// If sStopChar has no occurences in the string an empty string is
75386>>>>>>>// returned.
75386>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75388>>>>>>>    String  sRetVal
75388>>>>>>>    String  sChar
75388>>>>>>>    Integer iLength
75388>>>>>>>    Integer iPos
75388>>>>>>>    Boolean bStopChar
75388>>>>>>>    Move "" to sRetval
75389>>>>>>>    Move (Length(sFrom)) to iLength
75390>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75392>>>>>>>        Move iLength   to iPos
75393>>>>>>>        Move (False)   to bStopChar
75394>>>>>>>        While Not bStopChar
75398>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75399>>>>>>>            Decrement iPos
75400>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75402>>>>>>>                Move (True) to bStopChar
75403>>>>>>>            End
75403>>>>>>>>
75403>>>>>>>            Else Begin
75404>>>>>>>                Move (sChar+sRetVal) to sRetVal
75405>>>>>>>            End
75405>>>>>>>>
75405>>>>>>>        Loop
75406>>>>>>>>
75406>>>>>>>    End
75406>>>>>>>>
75406>>>>>>>    Function_Return sRetVal
75407>>>>>>>End_Function
75408>>>>>>>
75408>>>>>>>// Pre:  sFileName contains the complete path of the file.
75408>>>>>>>// Post: returns the complete path of the file.
75408>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75408>>>>>>>Function ParseFolderName Global String sFileName Returns String
75410>>>>>>>    String sFile
75410>>>>>>>    String sFolderName
75410>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75410>>>>>>>
75410>>>>>>>    Move "" to sFolderName
75411>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75412>>>>>>>    If sDirSep In sFileName Begin
75414>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75415>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75416>>>>>>>    End
75416>>>>>>>>
75416>>>>>>>    Else If ":" In sFileName Begin
75419>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75420>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75421>>>>>>>    End
75421>>>>>>>>
75421>>>>>>>    Function_Return sFolderName
75422>>>>>>>End_Function
75423>>>>>>>
75423>>>>>>>// Pre:  sFileName contains the complete path of the file.
75423>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75423>>>>>>>Function ParseFileName Global String sFileName Returns String
75425>>>>>>>    String sFolderName
75425>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75425>>>>>>>
75425>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75426>>>>>>>    Get ParseFolderName sFileName to sFolderName
75427>>>>>>>    If (sFolderName <> "") Begin
75429>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75430>>>>>>>    End
75430>>>>>>>>
75430>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75431>>>>>>>    Function_Return sFilename
75432>>>>>>>End_Function
75433>>>>>>>
75433>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75433>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75433>>>>>>>//       return "bak" as the extension and not "gif"
75433>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75433>>>>>>>//       such as "html" or "java"
75433>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75435>>>>>>>    String  sFileExtension
75435>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75436>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75437>>>>>>>    Function_Return sFileExtension
75438>>>>>>>End_Function
75439>>>>>>>
75439>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75439>>>>>>>
75439>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75441>>>>>>>    String sMessage
75441>>>>>>>    Case Begin
75441>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75443>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75444>>>>>>>            Case Break
75445>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75448>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75449>>>>>>>            Case Break
75450>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75453>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75454>>>>>>>            Case Break
75455>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75458>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75459>>>>>>>            Case Break
75460>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75463>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75464>>>>>>>            Case Break
75465>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75468>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75469>>>>>>>            Case Break
75470>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75473>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75474>>>>>>>            Case Break
75475>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75478>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75479>>>>>>>            Case Break
75480>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75483>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75484>>>>>>>            Case Break
75485>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75488>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75489>>>>>>>            Case Break
75490>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75493>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75494>>>>>>>            Case Break
75495>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75498>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75499>>>>>>>            Case Break
75500>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75503>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75504>>>>>>>            Case Break
75505>>>>>>>        Case Else
75505>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75506>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75507>>>>>>>            Case Break
75508>>>>>>>    Case End
75508>>>>>>>    Function_Return sMessage
75509>>>>>>>End_Function
75510>>>>>>>
75510>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75512>>>>>>>    String sMessage
75512>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75513>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75514>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75515>>>>>>>End_Procedure
75516>>>>>>>
75516>>>>>>>
75516>>>>>>>// This function informs the user that he entered a yet unknown folder and
75516>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75516>>>>>>>// Choice: "Yes" - this creates the folder
75516>>>>>>>//                 if successful, the function returns false
75516>>>>>>>//                 else it will be true.
75516>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75516>>>>>>>//                 For example: to stop a save
75516>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75516>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75516>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75518>>>>>>>    Integer bIsNotValid
75518>>>>>>>    Integer iUsers_Choice
75518>>>>>>>    String  sMessage
75518>>>>>>>
75518>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75520>>>>>>>        Move "The folder '" to sMessage
75521>>>>>>>        Append sMessage sFolderName
75522>>>>>>>        Append sMessage "' does not yet exist,\n"
75523>>>>>>>        Append sMessage "Do you want to create it now?"
75524>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75525>>>>>>>        Case Begin
75525>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75527>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75528>>>>>>>                If bIsNotValid Begin
75530>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75531>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75533>>>>>>>                    Send Info_Box sMessage "Info"
75534>>>>>>>                End
75534>>>>>>>>
75534>>>>>>>                Case Break
75535>>>>>>>            Case (iUsers_Choice = MBR_No)
75538>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75539>>>>>>>                Case Break
75540>>>>>>>        Case End
75540>>>>>>>    End
75540>>>>>>>>
75540>>>>>>>    Function_Return bIsNotValid
75541>>>>>>>End_Function
75542>>>>>>>
75542>>>>>>>// **WvA
75542>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75542>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75542>>>>>>>// The folder may contain a drive letter or UNC encoding.
75542>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75544>>>>>>>    String sDirSep
75544>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75545>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75546>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75548>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75549>>>>>>>    End
75549>>>>>>>>
75549>>>>>>>    Function_Return sFolderName
75550>>>>>>>End_Function
75551>>>>>>>
75551>>>>>>>//
75551>>>>>>>// Gets the parent path of the currently supplied path
75551>>>>>>>// Returns "" when we are at the root folder.
75551>>>>>>>//
75551>>>>>>>Function vParentPath Global String sPath Returns String
75553>>>>>>>    String sStrip sDirSep
75553>>>>>>>
75553>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75554>>>>>>>    Move (Trim(sPath)) to sPath
75555>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75557>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75558>>>>>>>    End
75558>>>>>>>>
75558>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75560>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75561>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75562>>>>>>>    End
75562>>>>>>>>
75562>>>>>>>    Else Begin
75563>>>>>>>        Move "" to sPath
75564>>>>>>>    End
75564>>>>>>>>
75564>>>>>>>    Function_Return sPath
75565>>>>>>>End_Function
75566>>>>>Use DUFLanguageConstants.inc
75566>>>>>
75566>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75566>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75566>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75566>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75566>>>>>
75566>>>>>Struct tDUFIntFile
75566>>>>>    Integer iID
75566>>>>>    String sIntFileName
75566>>>>>    String sIntLineText
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbVersionInfo
75566>>>>>    Number nVersionNumber
75566>>>>>    Handle hObject
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbUpdateError
75566>>>>>    Number nUpdateVersion
75566>>>>>    Integer iError
75566>>>>>    String  sOrgErrorText
75566>>>>>    String  sErrorText
75566>>>>>    Integer iErrorLine
75566>>>>>    Boolean bError  
75566>>>>>    Handle  hTable 
75566>>>>>    String  sTableRootName
75566>>>>>    Integer iField
75566>>>>>    Boolean bShortFormat
75566>>>>>End_Struct
75566>>>>>
75566>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75566>>>>>//  DF_FILE_IS_MASTER if master
75566>>>>>//  DF_FILE_IS_ALIAS if alias
75566>>>>>Struct tDbUpdateHandlerMasterAlias
75566>>>>>    Handle hTable
75566>>>>>    Integer iMode
75566>>>>>End_Struct
75566>>>>>
75566>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75566>>>>>Enumeration_List
75566>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75566>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75566>>>>>End_Enumeration_List
75566>>>>>
75566>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75566>>>>>
75566>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75566>>>>>// communicate with the object from anywhere in a program.
75566>>>>>    Global_Variable Handle ghoDbUpdateHandler
75566>>>>>    Move 0 to ghoDbUpdateHandler
75567>>>>>
75567>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75567>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75567>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75567>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75567>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75567>>>>>//    Declare_Datafile DbVersion
75567>>>>>//#ENDIF
75567>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75567>>>>>//****************************************************************************
75567>>>>>// $Module type: Class
75567>>>>>// $Module name: cDbUpdateLogFile
75567>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75567>>>>>// Web-site    : http://www.rdctools.com
75567>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75567>>>>>//
75567>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75567>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75567>>>>>//               that this class is to change; each developer can decide if the errors instead
75567>>>>>//               should be saved to a database table, or something entirely different.
75567>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75567>>>>>//
75567>>>>>// $Rev History:
75567>>>>>//    2016-10-05  Module header created
75567>>>>>//****************************************************************************
75567>>>>>Use UI
75567>>>>>Use vWin32fh.pkg
75567>>>>>
75567>>>>>
75567>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75567>>>>>
75567>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75567>>>>>
75567>>>>>Class cDbUpdateLogFile is a cObject
75568>>>>>
75568>>>>>    Procedure Construct_Object
75570>>>>>        Forward Send Construct_Object
75572>>>>>
75572>>>>>        // Error handling:
75572>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75573>>>>>        Property Integer piChannel -1
75574>>>>>
75574>>>>>        // This property is set by the cDbUpdateHandler object,
75574>>>>>        // when the update process starts.
75574>>>>>        Property DateTime pdtUpdateStart
75575>>>>>
75575>>>>>        // Gets set to False if the log contains data
75575>>>>>        Property Boolean pbEmptyLogFile True
75576>>>>>
75576>>>>>        // Gets set to True after the error log header text
75576>>>>>        // has been written.
75576>>>>>        Property Boolean pbHeaderWritten False
75577>>>>>
75577>>>>>        // If all activities should be logged- not just errors.
75577>>>>>        Property Boolean pbVerboseState False
75578>>>>>
75578>>>>>        // File name for the error log where all errors
75578>>>>>        // after a run is written to (appended).
75578>>>>>        // It is saved in the Data folder.
75578>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75579>>>>>        // If this property is set to "" in object code, the
75579>>>>>        // "shell" command parameter will be used to let Windows decide
75579>>>>>        // with which program to open the logfile.
75579>>>>>        Property String psEditorProgram ""
75580>>>>>
75580>>>>>        Property Boolean pbUseDataTableLog False
75581>>>>>
75581>>>>>        // If true an error will be written to file immediately when
75581>>>>>        // it occurs. This can be handy if a large update generates a lots
75581>>>>>        // of errors and the application crasches before finished, thus
75581>>>>>        // the errors will not be written.
75581>>>>>        Property Boolean pbQuickWrite True
75582>>>>>    End_Procedure
75583>>>>>
75583>>>>>    Procedure End_Construct_Object
75585>>>>>        Forward Send End_Construct_Object
75587>>>>>
75587>>>>>    End_Procedure
75588>>>>>
75588>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75592>>>>>        Boolean bShortFormat
75592>>>>>        Integer iSize
75592>>>>>        Handle hCurrentTable
75592>>>>>        Integer iCurrentField           
75592>>>>>        String sOrgErrorText sTableRootName
75592>>>>>        
75592>>>>>        Move False to bShortFormat
75593>>>>>        If (num_arguments > 5) Begin
75595>>>>>            Move bShortFormatIn to bShortFormat
75596>>>>>        End
75596>>>>>>
75596>>>>>        // Only do once.
75596>>>>>        If (pbHeaderWritten(Self) = False) Begin
75598>>>>>            Send WriteHeaderData
75599>>>>>            Set pbHeaderWritten to True
75600>>>>>        End
75600>>>>>>
75600>>>>>
75600>>>>>        Get Private.phCurrentTable to hCurrentTable  
75601>>>>>        Get Private.piCurrentField to iCurrentField  
75602>>>>>        If (iError > 0) Begin
75604>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75607>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75608>>>>>        End
75608>>>>>>
75608>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75609>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75610>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75611>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75612>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75613>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75614>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75615>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75616>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75617>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75618>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75619>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75620>>>>>
75620>>>>>        If (bError = False) Begin
75622>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75623>>>>>        End
75623>>>>>>
75623>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75624>>>>>
75624>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75626>>>>>            If (pbQuickWrite(Self) = True) Begin
75628>>>>>                Send OnWriteRow_DataTable
75629>>>>>                // If we are writing error for error flush the
75629>>>>>                // error array when latest error has been written.
75629>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75630>>>>>            End
75630>>>>>>
75630>>>>>            Procedure_Return
75631>>>>>        End
75631>>>>>>
75631>>>>>        Else Begin
75632>>>>>            If (pbQuickWrite(Self) = True) Begin
75634>>>>>                Send WriteErrorLog
75635>>>>>                // Flush the error log array
75635>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75636>>>>>            End
75636>>>>>>
75636>>>>>        End
75636>>>>>>
75636>>>>>    End_Procedure   
75637>>>>>    
75637>>>>>    Function FetchErrorDescription Integer iError Returns String
75639>>>>>        String sErrorText         
75639>>>>>        Move "" to sErrorText
75640>>>>>        If (iError > 0) Begin
75642>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75643>>>>>        End
75643>>>>>>
75643>>>>>        Function_Return sErrorText
75644>>>>>    End_Function
75645>>>>>
75645>>>>>    // Hook procedure for writing header text prior starting the update work to
75645>>>>>    // a database table. This does nothing by default.
75645>>>>>    // Don't forget to Open your "error log table" first (!) as all
75645>>>>>    // tables have been closed at this stage. Put anything
75645>>>>>    // you want to indicate that the update process is just started.
75645>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75647>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75649>>>>>    End_Procedure
75650>>>>>
75650>>>>>    Procedure OnWriteRow_DataTable
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75653>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75654>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75656>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75658>>>>>        End
75658>>>>>>
75658>>>>>    End_Procedure
75659>>>>>
75659>>>>>    Function psLogTextFileWithPath Returns String
75661>>>>>        String sPath sFileName sFullFileName
75661>>>>>        
75661>>>>>        Get psDataPathFirstPart to sPath
75662>>>>>        Get psLogTextFile to sFileName
75663>>>>>        Move (sPath + sFileName) to sFullFileName
75664>>>>>        Function_Return sFullFileName
75665>>>>>    End_Function                     
75666>>>>>    
75666>>>>>    Procedure WriteHeaderData
75668>>>>>        String sFileName
75668>>>>>        Integer iCh iSize
75668>>>>>        Boolean bQuickWrite
75668>>>>>        DateTime dtUpdateStart
75668>>>>>
75668>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75669>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75671>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75672>>>>>            Procedure_Return
75673>>>>>        End
75673>>>>>>
75673>>>>>
75673>>>>>        Get piChannel to iCh
75674>>>>>        If (iCh < 0) Begin
75676>>>>>            Get Seq_New_Channel to iCh
75677>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75679>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75680>>>>>>
75680>>>>>                Procedure_Return
75681>>>>>            End
75681>>>>>>
75681>>>>>            Set piChannel to iCh
75682>>>>>        End
75682>>>>>>
75682>>>>>
75682>>>>>        Get psLogTextFileWithPath to sFileName
75683>>>>>        Get vWin32_APIFileSize sFileName to iSize
75684>>>>>        Get pbQuickWrite to bQuickWrite
75685>>>>>        
75685>>>>>        If (bQuickWrite = True) Begin
75687>>>>>            Append_Output channel iCh sFileName
75689>>>>>                If (bQuickWrite = True) Begin
75691>>>>>                    If (iSize = 0) Begin
75693>>>>>                        Write channel iCh C_BOM_UTF8
75695>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75698>>>>>                        Set pbEmptyLogFile to False
75699>>>>>                    End
75699>>>>>>
75699>>>>>                    Writeln channel iCh
75701>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75704>>>>>                End
75704>>>>>>
75704>>>>>            Close_Output channel iCh
75706>>>>>        End
75706>>>>>>
75706>>>>>    End_Procedure
75707>>>>>
75707>>>>>    // Returns the first datapath found in the psDataPath property.
75707>>>>>    // The returned path always ends with a "\"
75707>>>>>    Function psDataPathFirstPart Returns String
75709>>>>>        String sDataPath
75709>>>>>        Integer iCount
75709>>>>>
75709>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75710>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75711>>>>>        If (iCount > 1) Begin
75713>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75714>>>>>        End
75714>>>>>>
75714>>>>>        If (sDataPath <> "") Begin
75716>>>>>            Get vFolderFormat sDataPath to sDataPath
75717>>>>>        End
75717>>>>>>
75717>>>>>
75717>>>>>        Function_Return sDataPath
75718>>>>>    End_Function
75719>>>>>
75719>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75719>>>>>    Procedure WriteErrorLog
75721>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75721>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75722>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75722>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75722>>>>>        Boolean bUseDataTable bQuickWrite
75722>>>>>        DateTime dtUpdateStart dtUpdateEnd
75722>>>>>        TimeSpan tsElapsed
75722>>>>>        Number nVersion                                  
75722>>>>>        Handle hTable
75722>>>>>
75722>>>>>        If (pbHeaderWritten(Self) = False) Begin
75724>>>>>            Send WriteHeaderData
75725>>>>>            Set pbHeaderWritten to True
75726>>>>>        End
75726>>>>>>
75726>>>>>
75726>>>>>        Get pbUseDataTableLog to bUseDataTable
75727>>>>>        If (bUseDataTable = True) Begin
75729>>>>>            Send OnWriteRow_DataTable
75730>>>>>            Procedure_Return
75731>>>>>        End
75731>>>>>>
75731>>>>>
75731>>>>>        Get piChannel to iCh
75732>>>>>        If (iCh < 0) Begin
75734>>>>>            Get Seq_New_Channel to iCh
75735>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75737>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75738>>>>>>
75738>>>>>                Procedure_Return
75739>>>>>            End
75739>>>>>>
75739>>>>>            Set piChannel to iCh
75740>>>>>        End
75740>>>>>>
75740>>>>>
75740>>>>>        Get psLogTextFileWithPath to sFileName
75741>>>>>
75741>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75742>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75743>>>>>        Decrement iSize
75744>>>>>
75744>>>>>        Get pdtUpdateStart to dtUpdateStart
75745>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75747>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75748>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75749>>>>>        End
75749>>>>>>
75749>>>>>        Get pbQuickWrite to bQuickWrite
75750>>>>>
75750>>>>>        Append_Output channel iCh sFileName
75752>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75754>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75757>>>>>        End
75757>>>>>>
75757>>>>>        Else If (bQuickWrite = False) Begin
75760>>>>>            Writeln channel iCh
75762>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75765>>>>>        End   
75765>>>>>>
75765>>>>>        If (iSize >= 0) Begin
75767>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75769>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75772>>>>>            End
75772>>>>>>
75772>>>>>        End
75772>>>>>>
75772>>>>>
75772>>>>>        For iCount from 0 to iSize  
75778>>>>>>
75778>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75779>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75780>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75781>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75782>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75783>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75784>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75785>>>>>            
75785>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75786>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75788>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75789>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75790>>>>>            End
75790>>>>>>
75790>>>>>            Else Begin
75791>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75792>>>>>                Move (sVersion + "   " + sErrorText) to sText
75793>>>>>            End
75793>>>>>>
75793>>>>>            Writeln channel iCh sText
75796>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75798>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75799>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75800>>>>>                Writeln channel iCh sOrgErrorText
75803>>>>>            End
75803>>>>>>
75803>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75805>>>>>                Writeln channel iCh
75807>>>>>            End
75807>>>>>>
75807>>>>>        Loop
75808>>>>>>
75808>>>>>        Close_Output channel iCh
75810>>>>>
75810>>>>>        Send Seq_Release_Channel iCh
75811>>>>>        Set piChannel to -1
75812>>>>>
75812>>>>>    End_Procedure
75813>>>>>
75813>>>>>    // The character to pad is optional. If nothing, spaces are used.
75813>>>>>    // Example:
75813>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75813>>>>>    //  or:
75813>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75813>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75813>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75815>>>>>        String sChar
75815>>>>>
75815>>>>>        If (Num_Arguments >= 3) Begin
75817>>>>>            Move sOptChar to sChar
75818>>>>>        End
75818>>>>>>
75818>>>>>        Else Begin
75819>>>>>            Move " " to sChar
75820>>>>>        End
75820>>>>>>
75820>>>>>
75820>>>>>        While (Length(sString) < iLength)
75824>>>>>            Move (sChar + sString) to sString
75825>>>>>        Loop
75826>>>>>>
75826>>>>>
75826>>>>>        Function_Return sString
75827>>>>>    End_Function
75828>>>>>
75828>>>>>    Procedure ShowErrorLog
75830>>>>>        String sPath sFileName sEditorProgram
75830>>>>>        Boolean bExists
75830>>>>>
75830>>>>>        Get psLogTextFileWithPath to sFileName
75831>>>>>        Get vFilePathExists sFileName to bExists
75832>>>>>        If (bExists = True) Begin
75834>>>>>            Get psEditorProgram to sEditorProgram
75835>>>>>            If (sEditorProgram <> "") Begin
75837>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75838>>>>>            End
75838>>>>>>
75838>>>>>            Else Begin
75839>>>>>                Runprogram Shell Background sFileName
75840>>>>>            End
75840>>>>>>
75840>>>>>        End
75840>>>>>>
75840>>>>>        Else Begin
75841>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75842>>>>>        End
75842>>>>>>
75842>>>>>    End_Procedure
75843>>>>>
75843>>>>>End_Class
75844>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75844>>>>>//****************************************************************************
75844>>>>>// $Module type: Class
75844>>>>>// $Module name: cDbUpdateVersion
75844>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75844>>>>>// Web-site    : http://www.rdctools.com
75844>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75844>>>>>//
75844>>>>>// Description : Child class to cDbUpdateHandler.
75844>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75844>>>>>//               Set the pnVersionNumber to a version number.
75844>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75844>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75844>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75844>>>>>//
75844>>>>>// $Rev History:
75844>>>>>//    2016-09-27  Module header created
75844>>>>>//****************************************************************************
75844>>>>>Use UI
75844>>>>>Use DUFLanguageConstants.inc
75844>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75844>>>>>>>//****************************************************************************
75844>>>>>>>// $Module type: Class
75844>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75844>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75844>>>>>>>// Web-site    : http://www.rdctools.com
75844>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75844>>>>>>>//
75844>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75844>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75844>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75844>>>>>>>//               with the help of Sql-scripts.
75844>>>>>>>//
75844>>>>>>>// $Rev History:
75844>>>>>>>//    2014-09-05  Module header created
75844>>>>>>>//
75844>>>>>>>//****************************************************************************
75844>>>>>>>//
75844>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75844>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75844>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75844>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75844>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75844>>>>>>>//
75844>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75844>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75844>>>>>>>
75844>>>>>>>
75844>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75844>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
75844>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75844>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75844>>>>>>>//
75844>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75844>>>>>>>>>//****************************************************************************
75844>>>>>>>>>// $Module type: Class
75844>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75844>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75844>>>>>>>>>// Web-site    : http://www.rdctools.com
75844>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75844>>>>>>>>>//
75844>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75844>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75844>>>>>>>>>//
75844>>>>>>>>>// $Rev History:
75844>>>>>>>>>//    2023-11-06  Module header created
75844>>>>>>>>>//
75844>>>>>>>>>//****************************************************************************
75844>>>>>>>>>Use cApplication.pkg
75844>>>>>>>>>Use seq_chnl.pkg
75844>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75844>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75844>>>>>>>>>Use Dfcursor.pkg
75844>>>>>>>>>Use DUFStatusPanel.pkg
75844>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75844>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75844>>>>>>>>>>>//
75844>>>>>>>>>>>// We need to create a mixin class for the library.
75844>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75844>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75844>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75844>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75844>>>>>>>>>>>//
75844>>>>>>>>>>>Use VdfBase.pkg
75844>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75844>>>>>>>>>>>>>Use Unicode.Pkg
75844>>>>>>>>>>>>>
75844>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75845>>>>>>>>>>>>>
75845>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75846>>>>>>>>>>>>>
75846>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75847>>>>>>>>>>>>>
75847>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75848>>>>>>>>>>>>>
75848>>>>>>>>>>>>>
75848>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75848>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75850>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75850>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75850>>>>>>>>>>>>>    String sUUID
75850>>>>>>>>>>>>>    
75850>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75851>>>>>>>>>>>>>    
75851>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75852>>>>>>>>>>>>>    
75852>>>>>>>>>>>>>    If (iRetval = 0) Begin
75854>>>>>>>>>>>>>        Move 0 to pUUIDStr
75855>>>>>>>>>>>>>        
75855>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75856>>>>>>>>>>>>>        If (iRetval = 0) Begin
75858>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75859>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75860>>>>>>>>>>>>>            
75860>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75861>>>>>>>>>>>>>        End
75861>>>>>>>>>>>>>>
75861>>>>>>>>>>>>>    End
75861>>>>>>>>>>>>>>
75861>>>>>>>>>>>>>    
75861>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75862>>>>>>>>>>>>>    
75862>>>>>>>>>>>>>    Function_Return sUUID
75863>>>>>>>>>>>>>End_Function
75864>>>>>>>>>>>>>
75864>>>>>>>>>>>>>
75864>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75864>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75866>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75866>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75866>>>>>>>>>>>>>    String sUUID
75866>>>>>>>>>>>>>    
75866>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75867>>>>>>>>>>>>>    
75867>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75868>>>>>>>>>>>>>    
75868>>>>>>>>>>>>>    If (iRetval = 0) Begin
75870>>>>>>>>>>>>>        Move 0 to pUUIDStr
75871>>>>>>>>>>>>>        
75871>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75872>>>>>>>>>>>>>        If (iRetval = 0) Begin
75874>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75875>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75876>>>>>>>>>>>>>            
75876>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75877>>>>>>>>>>>>>        End
75877>>>>>>>>>>>>>>
75877>>>>>>>>>>>>>    End
75877>>>>>>>>>>>>>>
75877>>>>>>>>>>>>>    
75877>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75878>>>>>>>>>>>>>    
75878>>>>>>>>>>>>>    Function_Return sUUID
75879>>>>>>>>>>>>>End_Function
75880>>>>>>>>>>>Use cli.pkg
75880>>>>>>>>>>>Use sql.pkg
75880>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75880>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75880>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75880>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>Use Cli.pkg
75880>>>>>>>>>>>>>Use SQL.pkg
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>//   Driver Indentification
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>//   Error number constants
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>// SQL Server spcific types.
75880>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75880>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75880>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75880>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>// SQL Server spcific types.
75880>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75880>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75880>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75880>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75880>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75880>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75880>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75880>>>>>>>>>>>>>//
75880>>>>>>>>>>>>>//     Setup a constraint for a file.
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>
75880>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75881>>>>>>>>>>>>>    
75881>>>>>>>>>>>>>    Procedure Construct_Object
75883>>>>>>>>>>>>>        Forward Send Construct_Object
75885>>>>>>>>>>>>>        
75885>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75886>>>>>>>>>>>>>    End_Procedure
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75887>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75889>>>>>>>>>>>>>        String  sItem
75889>>>>>>>>>>>>>        Integer iStart
75889>>>>>>>>>>>>>        Integer iEnd
75889>>>>>>>>>>>>>        
75889>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75892>>>>>>>>>>>>>        
75892>>>>>>>>>>>>>        Send Delete_Data to hoStore
75893>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75894>>>>>>>>>>>>>        While (iStart > 0)
75898>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75899>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75902>>>>>>>>>>>>>            Else Begin
75903>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75904>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75905>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75908>>>>>>>>>>>>>                
75908>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75911>>>>>>>>>>>>>                
75911>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75914>>>>>>>>>>>>>            End
75914>>>>>>>>>>>>>>
75914>>>>>>>>>>>>>        Loop
75915>>>>>>>>>>>>>>
75915>>>>>>>>>>>>>        
75915>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75916>>>>>>>>>>>>>    End_Procedure
75917>>>>>>>>>>>>>    
75917>>>>>>>>>>>>>    
75917>>>>>>>>>>>>>    
75917>>>>>>>>>>>>>    //   Call the driver's browse connect function
75917>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75919>>>>>>>>>>>>>        String  sDriver
75919>>>>>>>>>>>>>        String  sOutConnStr
75919>>>>>>>>>>>>>        Integer iArg
75919>>>>>>>>>>>>>        Integer iRetval
75919>>>>>>>>>>>>>        
75919>>>>>>>>>>>>>        Get psDriverID to sDriver
75920>>>>>>>>>>>>>        If (sDriver <> "") Begin
75922>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75923>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75928>>>>>>>>>>>>>        End
75928>>>>>>>>>>>>>>
75928>>>>>>>>>>>>>        
75928>>>>>>>>>>>>>        Function_Return sOutConnStr
75929>>>>>>>>>>>>>    End_Function// BrowseConnect
75930>>>>>>>>>>>>>    
75930>>>>>>>>>>>>>    
75930>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75932>>>>>>>>>>>>>        String  sDriver
75932>>>>>>>>>>>>>        String  sOutConnStr
75932>>>>>>>>>>>>>        Integer iArg
75932>>>>>>>>>>>>>        Integer iRetval
75932>>>>>>>>>>>>>        
75932>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75933>>>>>>>>>>>>>        
75933>>>>>>>>>>>>>        Get psDriverID to sDriver
75934>>>>>>>>>>>>>        If (sDriver <> "") Begin
75936>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75937>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75942>>>>>>>>>>>>>        End
75942>>>>>>>>>>>>>>
75942>>>>>>>>>>>>>        
75942>>>>>>>>>>>>>        Function_Return sOutConnStr
75943>>>>>>>>>>>>>    End_Function// BrowseConnect
75944>>>>>>>>>>>>>    
75944>>>>>>>>>>>>>    
75944>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75946>>>>>>>>>>>>>        String  sServerList
75946>>>>>>>>>>>>>        Integer iNumServers
75946>>>>>>>>>>>>>        Integer iDriver
75946>>>>>>>>>>>>>        Integer iClientVersion
75946>>>>>>>>>>>>>        String  sDriver
75946>>>>>>>>>>>>>        
75946>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75947>>>>>>>>>>>>>        
75947>>>>>>>>>>>>>        If (iDriver) Begin
75949>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75952>>>>>>>>>>>>>            
75952>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75953>>>>>>>>>>>>>            
75953>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75954>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75956>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75957>>>>>>>>>>>>>            End
75957>>>>>>>>>>>>>>
75957>>>>>>>>>>>>>            Else Begin
75958>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75959>>>>>>>>>>>>>            End
75959>>>>>>>>>>>>>>
75959>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75960>>>>>>>>>>>>>        End
75960>>>>>>>>>>>>>>
75960>>>>>>>>>>>>>        
75960>>>>>>>>>>>>>        Function_Return iNumServers
75961>>>>>>>>>>>>>    End_Function
75962>>>>>>>>>>>>>    
75962>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75962>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75962>>>>>>>>>>>>>    //   This may take a long time.
75962>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75962>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75964>>>>>>>>>>>>>        Integer iNumServers
75964>>>>>>>>>>>>>        Integer iNetworkLocal
75964>>>>>>>>>>>>>        
75964>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75965>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75966>>>>>>>>>>>>>
75966>>>>>>>>>>>>>        Function_Return iNumServers
75967>>>>>>>>>>>>>    End_Function
75968>>>>>>>>>>>>>    
75968>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75968>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75968>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75968>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75970>>>>>>>>>>>>>        Integer iNumServers
75970>>>>>>>>>>>>>        Integer iNetworkLocal
75970>>>>>>>>>>>>>        
75970>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75971>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75972>>>>>>>>>>>>>        
75972>>>>>>>>>>>>>        Function_Return iNumServers
75973>>>>>>>>>>>>>    End_Function
75974>>>>>>>>>>>>>    
75974>>>>>>>>>>>>>    //   Enumerate database in a given server.
75974>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75976>>>>>>>>>>>>>        Integer hoSQL
75976>>>>>>>>>>>>>        String  sConnect
75976>>>>>>>>>>>>>        String  sDatabase
75976>>>>>>>>>>>>>        Integer hdbc
75976>>>>>>>>>>>>>        Integer hstmt
75976>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75976>>>>>>>>>>>>>        
75976>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75979>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75982>>>>>>>>>>>>>        
75982>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75985>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75987>>>>>>>>>>>>>
75987>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75988>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75991>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
75993>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
75994>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
75995>>>>>>>>>>>>>        End
75995>>>>>>>>>>>>>>
75995>>>>>>>>>>>>>        
75995>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75997>>>>>>>>>>>>>            Move Current_Object to hoSQL
75998>>>>>>>>>>>>>        End_Object
75999>>>>>>>>>>>>>        
75999>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76001>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76002>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76004>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76005>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76007>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76007>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76007>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76007>>>>>>>>>>>>>                    //   stay the same.
76007>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76008>>>>>>>>>>>>>                    Send SQLCall to hstmt
76009>>>>>>>>>>>>>                    Repeat
76009>>>>>>>>>>>>>>
76009>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76010>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76012>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76013>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76014>>>>>>>>>>>>>                        End
76014>>>>>>>>>>>>>>
76014>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76016>>>>>>>>>>>>>                    
76016>>>>>>>>>>>>>                    Send SQLClose to hstmt
76017>>>>>>>>>>>>>                End
76017>>>>>>>>>>>>>>
76017>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76018>>>>>>>>>>>>>            End
76018>>>>>>>>>>>>>>
76018>>>>>>>>>>>>>        End
76018>>>>>>>>>>>>>>
76018>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76019>>>>>>>>>>>>>        
76019>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76020>>>>>>>>>>>>>    End_Function
76021>>>>>>>>>>>>>    
76021>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76023>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76023>>>>>>>>>>>>>        
76023>>>>>>>>>>>>>        Case Begin
76023>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76025>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76026>>>>>>>>>>>>>                Case Break
76027>>>>>>>>>>>>>            
76027>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76030>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76031>>>>>>>>>>>>>                Case Break
76032>>>>>>>>>>>>>                
76032>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76035>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76036>>>>>>>>>>>>>                Case Break
76037>>>>>>>>>>>>>            
76037>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76040>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76041>>>>>>>>>>>>>                Case Break
76042>>>>>>>>>>>>>            
76042>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76045>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76046>>>>>>>>>>>>>                Case Break
76047>>>>>>>>>>>>>            
76047>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76050>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76051>>>>>>>>>>>>>                Case Break
76052>>>>>>>>>>>>>            
76052>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76055>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76056>>>>>>>>>>>>>                Case Break
76057>>>>>>>>>>>>>            
76057>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76060>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76061>>>>>>>>>>>>>                Case Break
76062>>>>>>>>>>>>>            
76062>>>>>>>>>>>>>            Case Else
76062>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76063>>>>>>>>>>>>>        Case End
76063>>>>>>>>>>>>>        
76063>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76064>>>>>>>>>>>>>    End_Function
76065>>>>>>>>>>>>>
76065>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76067>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76067>>>>>>>>>>>>>        
76067>>>>>>>>>>>>>        Case Begin
76067>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76069>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76070>>>>>>>>>>>>>                Case Break
76071>>>>>>>>>>>>>
76071>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76074>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76075>>>>>>>>>>>>>                Case Break
76076>>>>>>>>>>>>>                
76076>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76079>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76080>>>>>>>>>>>>>                Case Break
76081>>>>>>>>>>>>>            
76081>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76084>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76085>>>>>>>>>>>>>                Case Break
76086>>>>>>>>>>>>>            
76086>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76089>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76090>>>>>>>>>>>>>                Case Break
76091>>>>>>>>>>>>>            
76091>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76094>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76095>>>>>>>>>>>>>                Case Break
76096>>>>>>>>>>>>>            
76096>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76099>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76100>>>>>>>>>>>>>                Case Break
76101>>>>>>>>>>>>>            
76101>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76104>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76105>>>>>>>>>>>>>                Case Break
76106>>>>>>>>>>>>>            
76106>>>>>>>>>>>>>            Case Else
76106>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76107>>>>>>>>>>>>>        Case End
76107>>>>>>>>>>>>>        
76107>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76108>>>>>>>>>>>>>    End_Function
76109>>>>>>>>>>>>>    
76109>>>>>>>>>>>>>End_Class
76110>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76110>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76110>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76110>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76110>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>Use Cli.pkg
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// Driver attributes
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// Driver Indentification
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// Error number constants
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// Call driver function identifiers
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// DB2 specific data types
76110>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76110>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76110>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76110>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76110>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76110>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76110>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76110>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// Extra DB2 commands
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76110>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>
76110>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76111>>>>>>>>>>>>>    
76111>>>>>>>>>>>>>    Procedure Construct_Object
76113>>>>>>>>>>>>>        Forward Send Construct_Object
76115>>>>>>>>>>>>>        
76115>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76116>>>>>>>>>>>>>    End_Procedure
76117>>>>>>>>>>>>>    
76117>>>>>>>>>>>>>    
76117>>>>>>>>>>>>>    
76117>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76117>>>>>>>>>>>>>    Procedure SeedDataSources
76119>>>>>>>>>>>>>        String  sDriver
76119>>>>>>>>>>>>>        String  sVoid
76119>>>>>>>>>>>>>        Integer iRetval
76119>>>>>>>>>>>>>        
76119>>>>>>>>>>>>>        Get psDriverID to sDriver
76120>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76127>>>>>>>>>>>>>    End_Procedure
76128>>>>>>>>>>>>>    
76128>>>>>>>>>>>>>    
76128>>>>>>>>>>>>>    
76128>>>>>>>>>>>>>    // Call the driver's data sources function
76128>>>>>>>>>>>>>    Function DataSources Returns String
76130>>>>>>>>>>>>>        String  sDriver
76130>>>>>>>>>>>>>        String  sDataSource
76130>>>>>>>>>>>>>        String  sDescription
76130>>>>>>>>>>>>>        Integer iLength
76130>>>>>>>>>>>>>        Integer iRetval
76130>>>>>>>>>>>>>        
76130>>>>>>>>>>>>>        Get psDriverID to sDriver
76131>>>>>>>>>>>>>        If (sDriver <> "") Begin
76133>>>>>>>>>>>>>            Move 8192 to iLength
76134>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76135>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76136>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76141>>>>>>>>>>>>>        End
76141>>>>>>>>>>>>>>
76141>>>>>>>>>>>>>        
76141>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76144>>>>>>>>>>>>>        Else ;            Function_Return ""
76146>>>>>>>>>>>>>    End_Function
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>End_Class
76148>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76148>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76148>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76148>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76148>>>>>>>>>>>>>
76148>>>>>>>>>>>>>Use Cli.pkg
76148>>>>>>>>>>>>>
76148>>>>>>>>>>>>>// Driver Indentification
76148>>>>>>>>>>>>>
76148>>>>>>>>>>>>>// Error number constants
76148>>>>>>>>>>>>>
76148>>>>>>>>>>>>>// Call driver function identifiers
76148>>>>>>>>>>>>>
76148>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76149>>>>>>>>>>>>>    
76149>>>>>>>>>>>>>    Procedure Construct_Object
76151>>>>>>>>>>>>>        Forward Send Construct_Object
76153>>>>>>>>>>>>>        
76153>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76154>>>>>>>>>>>>>    End_Procedure
76155>>>>>>>>>>>>>    
76155>>>>>>>>>>>>>    
76155>>>>>>>>>>>>>    
76155>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76155>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76157>>>>>>>>>>>>>        String  sDriver
76157>>>>>>>>>>>>>        String  sVoid
76157>>>>>>>>>>>>>        Integer iRetval
76157>>>>>>>>>>>>>        
76157>>>>>>>>>>>>>        Get psDriverID to sDriver
76158>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76165>>>>>>>>>>>>>    End_Procedure
76166>>>>>>>>>>>>>    
76166>>>>>>>>>>>>>    
76166>>>>>>>>>>>>>    // Call the driver's data sources function
76166>>>>>>>>>>>>>    Function DataSources Returns String
76168>>>>>>>>>>>>>        String  sDriver
76168>>>>>>>>>>>>>        String  sDataSource
76168>>>>>>>>>>>>>        String  sDescription
76168>>>>>>>>>>>>>        Integer iLength
76168>>>>>>>>>>>>>        Integer iRetval
76168>>>>>>>>>>>>>        
76168>>>>>>>>>>>>>        Get psDriverID to sDriver
76169>>>>>>>>>>>>>        If (sDriver <> "") Begin
76171>>>>>>>>>>>>>            Move 8192 to iLength
76172>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76173>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76174>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76179>>>>>>>>>>>>>        End
76179>>>>>>>>>>>>>>
76179>>>>>>>>>>>>>        
76179>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76182>>>>>>>>>>>>>        Else ;            Function_Return ""
76184>>>>>>>>>>>>>    End_Function
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>End_Class
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76186>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76186>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76186>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76186>>>>>>>>>>>>>Use Ui
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Driver Indentification
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Driver attributes
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Call_Driver functions ID's
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to create all vars which may be needed
76186>>>>>>>>>>>>>// in other commands.
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76186>>>>>>>>>>>>>// File must have been opened.
76186>>>>>>>>>>>>>// Filenumber needs to be passed.
76186>>>>>>>>>>>>>// To clear set the owner to "".
76186>>>>>>>>>>>>>// Examples:
76186>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76186>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76186>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76186>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76186>>>>>>>>>>>>>// To clear:
76186>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76186>>>>>>>>>>>>>// options.
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to parse for Callback
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76186>>>>>>>>>>>>>// File must have been opened.
76186>>>>>>>>>>>>>// Filenumber needs to be passed.
76186>>>>>>>>>>>>>// Examples:
76186>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76186>>>>>>>>>>>>>// which will be tries when opening files.
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76186>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76186>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76186>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to change the transaction type.
76186>>>>>>>>>>>>>// Valid types are:
76186>>>>>>>>>>>>>//     DFBTRTT_NONE
76186>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76186>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to get the current transaction type.
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to set explicit_locking
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to get explicit locking
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76186>>>>>>>>>>>>>//
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76186>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76187>>>>>>>>>>>>>    
76187>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76189>>>>>>>>>>>>>        Forward Send Construct_object iImage
76191>>>>>>>>>>>>>        
76191>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76192>>>>>>>>>>>>>    End_Procedure
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76193>>>>>>>>>>>>>    //
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    Function CKRevision Returns String
76195>>>>>>>>>>>>>        String  sDriverID
76195>>>>>>>>>>>>>        String  sRevision
76195>>>>>>>>>>>>>        String  sVoid
76195>>>>>>>>>>>>>        Integer iRetval
76195>>>>>>>>>>>>>        
76195>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76195>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76195>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76195>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76196>>>>>>>>>>>>>        Get psDriverID to sDriverID
76197>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76198>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76203>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76204>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76206>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76206>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76207>>>>>>>>>>>>>        End
76207>>>>>>>>>>>>>>
76207>>>>>>>>>>>>>        Function_Return sRevision
76208>>>>>>>>>>>>>    End_Function
76209>>>>>>>>>>>>>    
76209>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76211>>>>>>>>>>>>>        String  sDriverID
76211>>>>>>>>>>>>>        String  sVoid1
76211>>>>>>>>>>>>>        String  sVoid2
76211>>>>>>>>>>>>>        Integer iRetval
76211>>>>>>>>>>>>>        
76211>>>>>>>>>>>>>        Get psDriverID to sDriverID
76212>>>>>>>>>>>>>        
76212>>>>>>>>>>>>>        Move 0 to iRetval
76213>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76213>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76213>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76213>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76214>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76219>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76220>>>>>>>>>>>>>        
76220>>>>>>>>>>>>>        Function_Return iRetval
76221>>>>>>>>>>>>>    End_Function
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76222>>>>>>>>>>>>>    //
76222>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76222>>>>>>>>>>>>>    //
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76224>>>>>>>>>>>>>        Integer iPartRev
76224>>>>>>>>>>>>>        Integer iCurrentPart
76224>>>>>>>>>>>>>        Integer iSeparatorPos
76224>>>>>>>>>>>>>        
76224>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76227>>>>>>>>>>>>>        
76227>>>>>>>>>>>>>        Move 0 to iCurrentPart
76228>>>>>>>>>>>>>        Repeat
76228>>>>>>>>>>>>>>
76228>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76229>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76231>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76232>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76233>>>>>>>>>>>>>                Increment iCurrentPart
76234>>>>>>>>>>>>>            End
76234>>>>>>>>>>>>>>
76234>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76237>>>>>>>>>>>>>                Move sRevision to iPartRev
76238>>>>>>>>>>>>>                Move "" to sRevision
76239>>>>>>>>>>>>>                Increment iCurrentPart
76240>>>>>>>>>>>>>            End
76240>>>>>>>>>>>>>>
76240>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76242>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76244>>>>>>>>>>>>>        
76244>>>>>>>>>>>>>        Function_Return iPartRev
76245>>>>>>>>>>>>>    End_Function
76246>>>>>>>>>>>>>    
76246>>>>>>>>>>>>>    
76246>>>>>>>>>>>>>    
76246>>>>>>>>>>>>>    //
76246>>>>>>>>>>>>>    //  Returns the major revision of the CK
76246>>>>>>>>>>>>>    //
76246>>>>>>>>>>>>>    
76246>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76248>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76249>>>>>>>>>>>>>    End_Function
76250>>>>>>>>>>>>>    
76250>>>>>>>>>>>>>    
76250>>>>>>>>>>>>>    
76250>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76250>>>>>>>>>>>>>    //
76250>>>>>>>>>>>>>    
76250>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76252>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76253>>>>>>>>>>>>>    End_Function
76254>>>>>>>>>>>>>    
76254>>>>>>>>>>>>>    
76254>>>>>>>>>>>>>    //  Returns the release revision of the CK
76254>>>>>>>>>>>>>    //
76254>>>>>>>>>>>>>    
76254>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76256>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76257>>>>>>>>>>>>>    End_Function
76258>>>>>>>>>>>>>    
76258>>>>>>>>>>>>>    
76258>>>>>>>>>>>>>    //  Returns the major revision of the CK
76258>>>>>>>>>>>>>    //
76258>>>>>>>>>>>>>    
76258>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76260>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76261>>>>>>>>>>>>>    End_Function
76262>>>>>>>>>>>>>    
76262>>>>>>>>>>>>>    
76262>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76262>>>>>>>>>>>>>    //
76262>>>>>>>>>>>>>    
76262>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76264>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76267>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76270>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76273>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76276>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76279>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76283>>>>>>>>>>>>>            End
76283>>>>>>>>>>>>>>
76283>>>>>>>>>>>>>        End
76283>>>>>>>>>>>>>>
76283>>>>>>>>>>>>>        
76283>>>>>>>>>>>>>        Function_Return (False)
76284>>>>>>>>>>>>>    End_Function
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76285>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76285>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76285>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76285>>>>>>>>>>>>>    //
76285>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76285>>>>>>>>>>>>>    //   in the following format:
76285>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76285>>>>>>>>>>>>>    //   possible values for <type>:
76285>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76285>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76285>>>>>>>>>>>>>    //       C for client cache engine
76285>>>>>>>>>>>>>    //       D for DOS workstation
76285>>>>>>>>>>>>>    //       N for client Requester
76285>>>>>>>>>>>>>    //       S for NetWare server
76285>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76285>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76285>>>>>>>>>>>>>    //
76285>>>>>>>>>>>>>    //   example:
76285>>>>>>>>>>>>>    //       8.50.T
76285>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76285>>>>>>>>>>>>>    //   32-bits Windows server.
76285>>>>>>>>>>>>>    //
76285>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76285>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76285>>>>>>>>>>>>>    //
76285>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76285>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    //  Returns the version information of the
76285>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76287>>>>>>>>>>>>>        
76287>>>>>>>>>>>>>        String  sDriverID
76287>>>>>>>>>>>>>        String  sVersion
76287>>>>>>>>>>>>>        String  sVoid
76287>>>>>>>>>>>>>        Integer iRetval
76287>>>>>>>>>>>>>        
76287>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76287>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76287>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76287>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76288>>>>>>>>>>>>>        Get psDriverID to sDriverID
76289>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76290>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76295>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76296>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76298>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76298>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76299>>>>>>>>>>>>>        End
76299>>>>>>>>>>>>>>
76299>>>>>>>>>>>>>        Function_Return sVersion
76300>>>>>>>>>>>>>    End_Function
76301>>>>>>>>>>>>>    
76301>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76301>>>>>>>>>>>>>    
76301>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76303>>>>>>>>>>>>>        
76303>>>>>>>>>>>>>        String  sDriverID
76303>>>>>>>>>>>>>        String  sVersion
76303>>>>>>>>>>>>>        String  sVoid
76303>>>>>>>>>>>>>        Integer iRetval
76303>>>>>>>>>>>>>        
76303>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76303>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76303>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76303>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76304>>>>>>>>>>>>>        Get psDriverID to sDriverID
76305>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76306>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76311>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76312>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76314>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76314>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76315>>>>>>>>>>>>>        End
76315>>>>>>>>>>>>>>
76315>>>>>>>>>>>>>        Function_Return sVersion
76316>>>>>>>>>>>>>    End_Function
76317>>>>>>>>>>>>>    
76317>>>>>>>>>>>>>    //  Returns the version information of the
76317>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76317>>>>>>>>>>>>>    
76317>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76319>>>>>>>>>>>>>        
76319>>>>>>>>>>>>>        String  sDriverID
76319>>>>>>>>>>>>>        String  sVersion
76319>>>>>>>>>>>>>        String  sVoid
76319>>>>>>>>>>>>>        Integer iRetval
76319>>>>>>>>>>>>>        
76319>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76319>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76319>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76319>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76320>>>>>>>>>>>>>        Get psDriverID to sDriverID
76321>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76322>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76327>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76328>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76330>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76330>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76331>>>>>>>>>>>>>        End
76331>>>>>>>>>>>>>>
76331>>>>>>>>>>>>>        Function_Return sVersion
76332>>>>>>>>>>>>>    End_Function
76333>>>>>>>>>>>>>    
76333>>>>>>>>>>>>>End_Class
76334>>>>>>>>>>>>>
76334>>>>>>>>>>>>>
76334>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76334>>>>>>>>>>>>>//****************************************************************************
76334>>>>>>>>>>>>>// $Module type: Include file
76334>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76334>>>>>>>>>>>>>//
76334>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76334>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76334>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76334>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76334>>>>>>>>>>>>>//
76334>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76334>>>>>>>>>>>>>//
76334>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76334>>>>>>>>>>>>>//
76334>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76334>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76334>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76334>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76334>>>>>>>>>>>>>// in the help folder for more details.
76334>>>>>>>>>>>>>//
76334>>>>>>>>>>>>>Use Winkern.pkg
76334>>>>>>>>>>>>>Use cIniFile.pkg
76334>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76334>>>>>>>>>>>>>>>Use VdfBase.pkg
76334>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76334>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76334>>>>>>>>>>>>>>>>>// Algorithm classes
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76334>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Algorithm types
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76334>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Generic sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// RSA sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// DSS sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// DES sub_ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76334>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76334>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76334>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76334>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76334>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76334>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76334>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76334>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76334>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// RC2 sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76334>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76334>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Hash sub ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76334>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76334>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76334>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76334>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76334>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76334>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// secure channel sub ids
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76334>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76334>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76334>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76334>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76334>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76334>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76334>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76334>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76334>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76334>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76334>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76334>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76334>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76334>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76334>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76334>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76334>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76334>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76334>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76334>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76334>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76334>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76334>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76334>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76334>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76334>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76334>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76334>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76334>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76334>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76334>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76334>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76334>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76334>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76334>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76334>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76334>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76334>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76334>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76334>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76334>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76334>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76334>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76334>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76334>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76334>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76334>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Providers
76334>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76334>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76334>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76334>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76334>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76334>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76334>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76334>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76334>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76334>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76334>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76334>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76334>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76334>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76334>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76334>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76334>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76334>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76334>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76334>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76334>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76334>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76334>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76334>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76334>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Provider types
76334>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76334>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76334>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76334>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76334>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76334>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76334>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76334>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76334>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76334>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76334>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76334>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76334>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76334>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76334>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76334>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76334>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76334>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// KP_MODE
76334>>>>>>>>>>>>>>>>>// KP_MODE
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76334>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76334>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76334>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76334>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76334>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76334>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76334>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76334>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76334>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76334>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76334>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76334>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76334>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76334>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76334>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76334>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76334>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76334>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76334>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76334>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76334>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76334>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76334>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76334>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76334>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76334>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76334>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76334>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76334>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76334>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76334>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76334>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76334>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76334>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76334>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76334>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76334>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76334>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76334>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76334>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76334>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76334>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76334>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76334>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76334>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76334>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76334>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// key BLOB types
76334>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76334>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76334>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76334>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76334>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76334>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76334>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76334>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// KP_PADDING
76334>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76334>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76334>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76334>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76334>>>>>>>>>>>>>>>>>    UChar    bType
76334>>>>>>>>>>>>>>>>>    UChar    bVersion
76334>>>>>>>>>>>>>>>>>    UShort   reserved
76334>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76334>>>>>>>>>>>>>>>>>End_Struct
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76334>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76334>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76334>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76334>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76334>>>>>>>>>>>>>>>>>End_Struct
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76334>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76334>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76334>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76334>>>>>>>>>>>>>>>>>    DWord cbInnerString
76334>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76334>>>>>>>>>>>>>>>>>    DWord cbOuterString
76334>>>>>>>>>>>>>>>>>End_Struct
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76334>>>>>>>>>>>>>>>>>    UChar   bType
76334>>>>>>>>>>>>>>>>>    UChar   bVersion
76334>>>>>>>>>>>>>>>>>    Short   reserved
76334>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76334>>>>>>>>>>>>>>>>>End_Struct
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>Struct CryptoBlob
76334>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76334>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76334>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76334>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76334>>>>>>>>>>>>>>>>>End_Struct
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76334>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76335>>>>>>>>>>>>>>>>>
76335>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76335>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76337>>>>>>>>>>>>>>>>>    
76337>>>>>>>>>>>>>>>>>    Boolean bResult
76337>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76337>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76338>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76339>>>>>>>>>>>>>>>>>    
76339>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76340>>>>>>>>>>>>>>>>>
76340>>>>>>>>>>>>>>>>>    Function_Return bResult
76341>>>>>>>>>>>>>>>>>End_Function
76342>>>>>>>>>>>>>>>>>
76342>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76343>>>>>>>>>>>>>>>>>
76343>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76344>>>>>>>>>>>>>>>>>
76344>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76345>>>>>>>>>>>>>>>>>
76345>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76346>>>>>>>>>>>>>>>>>
76346>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76347>>>>>>>>>>>>>>>>>
76347>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76348>>>>>>>>>>>>>>>>>
76348>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76349>>>>>>>>>>>>>>>>>
76349>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76350>>>>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76351>>>>>>>>>>>>>>>>>    
76351>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76352>>>>>>>>>>>>>>>>>
76352>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76354>>>>>>>>>>>>>>>>>
76354>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76355>>>>>>>>>>>>>>>>>    
76355>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76356>>>>>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76357>>>>>>>>>>>>>>>>>    
76357>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76358>>>>>>>>>>>>>>>
76358>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76359>>>>>>>>>>>>>>>    
76359>>>>>>>>>>>>>>>    Procedure Construct_Object
76361>>>>>>>>>>>>>>>        Forward Send Construct_Object
76363>>>>>>>>>>>>>>>        
76363>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76364>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76365>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76366>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76367>>>>>>>>>>>>>>>        
76367>>>>>>>>>>>>>>>        // Private properties
76367>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76368>>>>>>>>>>>>>>>        
76368>>>>>>>>>>>>>>>        // Block cipher properties
76368>>>>>>>>>>>>>>>        Property UChar[]    paKey
76369>>>>>>>>>>>>>>>        Property UChar[]    paIV
76370>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76371>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76372>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76373>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76374>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76375>>>>>>>>>>>>>>>    End_Procedure
76376>>>>>>>>>>>>>>>    
76376>>>>>>>>>>>>>>>    
76376>>>>>>>>>>>>>>>    // Acquire key container handle
76376>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76378>>>>>>>>>>>>>>>        Integer iProvider
76378>>>>>>>>>>>>>>>        WString wProvider
76378>>>>>>>>>>>>>>>        Handle hProv
76378>>>>>>>>>>>>>>>        Boolean bOk
76378>>>>>>>>>>>>>>>        Pointer pProv
76378>>>>>>>>>>>>>>>        
76378>>>>>>>>>>>>>>>        Move 0 to hProv
76379>>>>>>>>>>>>>>>        Get piProvider to iProvider
76380>>>>>>>>>>>>>>>        Get psProvider to wProvider
76381>>>>>>>>>>>>>>>        
76381>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76381>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76383>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76384>>>>>>>>>>>>>>>        End
76384>>>>>>>>>>>>>>>>
76384>>>>>>>>>>>>>>>        Else Begin
76385>>>>>>>>>>>>>>>            Move 0 to pProv
76386>>>>>>>>>>>>>>>        End
76386>>>>>>>>>>>>>>>>
76386>>>>>>>>>>>>>>>        
76386>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76386>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76387>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76389>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76390>>>>>>>>>>>>>>>        End
76390>>>>>>>>>>>>>>>>
76390>>>>>>>>>>>>>>>        
76390>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76392>>>>>>>>>>>>>>>            // Fallback to original
76392>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76393>>>>>>>>>>>>>>>            
76393>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76395>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76396>>>>>>>>>>>>>>>            End
76396>>>>>>>>>>>>>>>>
76396>>>>>>>>>>>>>>>        End
76396>>>>>>>>>>>>>>>>
76396>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76397>>>>>>>>>>>>>>>        
76397>>>>>>>>>>>>>>>        Function_Return hProv
76398>>>>>>>>>>>>>>>    End_Function
76399>>>>>>>>>>>>>>>    
76399>>>>>>>>>>>>>>>    // Releases key container handle
76399>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76401>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76402>>>>>>>>>>>>>>>    End_Function
76403>>>>>>>>>>>>>>>    
76403>>>>>>>>>>>>>>>    // Creates hash object
76403>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76405>>>>>>>>>>>>>>>        Integer iAlgorithm
76405>>>>>>>>>>>>>>>        Handle hHash
76405>>>>>>>>>>>>>>>        Boolean bOk
76405>>>>>>>>>>>>>>>        
76405>>>>>>>>>>>>>>>        Move 0 to hHash
76406>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76407>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76408>>>>>>>>>>>>>>>        
76408>>>>>>>>>>>>>>>        Function_Return hHash
76409>>>>>>>>>>>>>>>    End_Function
76410>>>>>>>>>>>>>>>    
76410>>>>>>>>>>>>>>>    // Destroys the hash object
76410>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76412>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76413>>>>>>>>>>>>>>>    End_Function
76414>>>>>>>>>>>>>>>    
76414>>>>>>>>>>>>>>>    // Adds data to hash object
76414>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76416>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76417>>>>>>>>>>>>>>>    End_Function
76418>>>>>>>>>>>>>>>    
76418>>>>>>>>>>>>>>>    // Generates session key
76418>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76420>>>>>>>>>>>>>>>        Integer iAlgorithm
76420>>>>>>>>>>>>>>>        Handle hKey
76420>>>>>>>>>>>>>>>        Boolean bOk
76420>>>>>>>>>>>>>>>        
76420>>>>>>>>>>>>>>>        Move 0 to hKey
76421>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76422>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76423>>>>>>>>>>>>>>>        
76423>>>>>>>>>>>>>>>        Function_Return hKey
76424>>>>>>>>>>>>>>>    End_Function
76425>>>>>>>>>>>>>>>    
76425>>>>>>>>>>>>>>>    // Imports a plain text key
76425>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76427>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76427>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76427>>>>>>>>>>>>>>>        Boolean   bSuccess
76427>>>>>>>>>>>>>>>        Handle    hKey
76427>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76427>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76428>>>>>>>>>>>>>>>        Integer iVoid
76428>>>>>>>>>>>>>>>        
76428>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76429>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76430>>>>>>>>>>>>>>>        
76430>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76431>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76432>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76433>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76434>>>>>>>>>>>>>>>        
76434>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76435>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76436>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76437>>>>>>>>>>>>>>>        
76437>>>>>>>>>>>>>>>        Move 0 to hKey
76438>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76439>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76441>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76442>>>>>>>>>>>>>>>        End
76442>>>>>>>>>>>>>>>>
76442>>>>>>>>>>>>>>>        
76442>>>>>>>>>>>>>>>        Function_Return hKey
76443>>>>>>>>>>>>>>>    End_Function
76444>>>>>>>>>>>>>>>    
76444>>>>>>>>>>>>>>>    // Destroys the key
76444>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76446>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76447>>>>>>>>>>>>>>>    End_Function
76448>>>>>>>>>>>>>>>    
76448>>>>>>>>>>>>>>>    // Retrieves key data
76448>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76450>>>>>>>>>>>>>>>        Integer iBuffer iLen
76450>>>>>>>>>>>>>>>        Boolean bOk
76450>>>>>>>>>>>>>>>        
76450>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76451>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76452>>>>>>>>>>>>>>>        Function_Return iBuffer
76453>>>>>>>>>>>>>>>    End_Function
76454>>>>>>>>>>>>>>>    
76454>>>>>>>>>>>>>>>    // Retrieves a hash value
76454>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76456>>>>>>>>>>>>>>>        UChar[] ucHash
76457>>>>>>>>>>>>>>>        Integer liResult
76457>>>>>>>>>>>>>>>        DWord   dwDataLen
76457>>>>>>>>>>>>>>>        
76457>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76458>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76459>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76462>>>>>>>>>>>>>>>        
76462>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76463>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76464>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76467>>>>>>>>>>>>>>>        
76467>>>>>>>>>>>>>>>        Function_Return ucHash
76468>>>>>>>>>>>>>>>    End_Function
76469>>>>>>>>>>>>>>>
76469>>>>>>>>>>>>>>>    // Encrypts data
76469>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76471>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76471>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76471>>>>>>>>>>>>>>>        Boolean bOk
76471>>>>>>>>>>>>>>>        
76471>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76472>>>>>>>>>>>>>>>        If (hProv) Begin
76474>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76475>>>>>>>>>>>>>>>            If (hHash) Begin
76477>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76478>>>>>>>>>>>>>>>                If (bOk) Begin
76480>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76481>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76482>>>>>>>>>>>>>>>                End
76482>>>>>>>>>>>>>>>>
76482>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76483>>>>>>>>>>>>>>>            End
76483>>>>>>>>>>>>>>>>
76483>>>>>>>>>>>>>>>            
76483>>>>>>>>>>>>>>>            If (hKey) Begin
76485>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76485>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76486>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76487>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76488>>>>>>>>>>>>>>>                
76488>>>>>>>>>>>>>>>                //  Reserve space in string
76488>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76490>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76491>>>>>>>>>>>>>>>                End
76491>>>>>>>>>>>>>>>>
76491>>>>>>>>>>>>>>>                
76491>>>>>>>>>>>>>>>                //  Call to really decrypt
76491>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76492>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76492>>>>>>>>>>>>>>>                //Move "" to sData
76492>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76492>>>>>>>>>>>>>>>                //End
76492>>>>>>>>>>>>>>>                
76492>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76493>>>>>>>>>>>>>>>            End 
76493>>>>>>>>>>>>>>>>
76493>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76494>>>>>>>>>>>>>>>        End 
76494>>>>>>>>>>>>>>>>
76494>>>>>>>>>>>>>>>        Function_Return ucData
76495>>>>>>>>>>>>>>>    End_Function
76496>>>>>>>>>>>>>>>    
76496>>>>>>>>>>>>>>>    // Decrypts data
76496>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76498>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76498>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76498>>>>>>>>>>>>>>>        Boolean bOk
76498>>>>>>>>>>>>>>>        
76498>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76499>>>>>>>>>>>>>>>        If (hProv) Begin
76501>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76502>>>>>>>>>>>>>>>            If (hHash) Begin
76504>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76505>>>>>>>>>>>>>>>                If (bOk) Begin
76507>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76508>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76509>>>>>>>>>>>>>>>                End
76509>>>>>>>>>>>>>>>>
76509>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76510>>>>>>>>>>>>>>>            End
76510>>>>>>>>>>>>>>>>
76510>>>>>>>>>>>>>>>            
76510>>>>>>>>>>>>>>>            If (hKey) Begin
76512>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76513>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76514>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76514>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76516>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76517>>>>>>>>>>>>>>>                End
76517>>>>>>>>>>>>>>>>
76517>>>>>>>>>>>>>>>                
76517>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76518>>>>>>>>>>>>>>>            End
76518>>>>>>>>>>>>>>>>
76518>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76519>>>>>>>>>>>>>>>        End
76519>>>>>>>>>>>>>>>>
76519>>>>>>>>>>>>>>>        Function_Return ucData
76520>>>>>>>>>>>>>>>    End_Function
76521>>>>>>>>>>>>>>>    
76521>>>>>>>>>>>>>>>    // Creates a key
76521>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76523>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76523>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76523>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76523>>>>>>>>>>>>>>>        Boolean bOk
76523>>>>>>>>>>>>>>>        Handle hKey
76523>>>>>>>>>>>>>>>        UChar[] aKey
76524>>>>>>>>>>>>>>>
76524>>>>>>>>>>>>>>>        Get paKey to aKey
76525>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76526>>>>>>>>>>>>>>>        Get piKeyType to iType
76527>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76528>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76529>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76530>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76531>>>>>>>>>>>>>>>        
76531>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76532>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76538>>>>>>>>>>>>>>>>
76538>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76539>>>>>>>>>>>>>>>        Loop
76540>>>>>>>>>>>>>>>>
76540>>>>>>>>>>>>>>>        
76540>>>>>>>>>>>>>>>        Move 0 to hKey
76541>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76542>>>>>>>>>>>>>>>        Function_Return hKey
76543>>>>>>>>>>>>>>>    End_Function
76544>>>>>>>>>>>>>>>    
76544>>>>>>>>>>>>>>>    // Sets the key parameters
76544>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76546>>>>>>>>>>>>>>>        Integer iPadding iMode
76546>>>>>>>>>>>>>>>        Boolean bOk
76546>>>>>>>>>>>>>>>        UChar[] aIV
76547>>>>>>>>>>>>>>>        
76547>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76547>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76547>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76547>>>>>>>>>>>>>>>        //Loop
76547>>>>>>>>>>>>>>>
76547>>>>>>>>>>>>>>>        // Set initialization vector
76547>>>>>>>>>>>>>>>        Get paIV to aIV
76548>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76549>>>>>>>>>>>>>>>        If (bOk) Begin
76551>>>>>>>>>>>>>>>            // Set padding
76551>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76552>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76553>>>>>>>>>>>>>>>            If (bOk) Begin
76555>>>>>>>>>>>>>>>                // Set move
76555>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76556>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76557>>>>>>>>>>>>>>>            End
76557>>>>>>>>>>>>>>>>
76557>>>>>>>>>>>>>>>        End
76557>>>>>>>>>>>>>>>>
76557>>>>>>>>>>>>>>>        Function_Return bOk        
76558>>>>>>>>>>>>>>>    End_Function
76559>>>>>>>>>>>>>>>    
76559>>>>>>>>>>>>>>>    // Encrypts using block cipher
76559>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76561>>>>>>>>>>>>>>>        Handle hProv hKey
76561>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76561>>>>>>>>>>>>>>>        Boolean bOk
76561>>>>>>>>>>>>>>>        
76561>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76562>>>>>>>>>>>>>>>        If (hProv) Begin
76564>>>>>>>>>>>>>>>            // Create key
76564>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76565>>>>>>>>>>>>>>>            If (hKey) Begin
76567>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76568>>>>>>>>>>>>>>>                If (bOk) Begin
76570>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76570>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76571>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76572>>>>>>>>>>>>>>>                    
76572>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76573>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76574>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76575>>>>>>>>>>>>>>>                End
76575>>>>>>>>>>>>>>>>
76575>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76576>>>>>>>>>>>>>>>            End
76576>>>>>>>>>>>>>>>>
76576>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76577>>>>>>>>>>>>>>>        End
76577>>>>>>>>>>>>>>>>
76577>>>>>>>>>>>>>>>        Function_Return ucData
76578>>>>>>>>>>>>>>>    End_Function
76579>>>>>>>>>>>>>>>    
76579>>>>>>>>>>>>>>>    // Decrypts using block cipher
76579>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76581>>>>>>>>>>>>>>>        Handle hProv hKey
76581>>>>>>>>>>>>>>>        Integer iLen
76581>>>>>>>>>>>>>>>        Boolean bOk
76581>>>>>>>>>>>>>>>        
76581>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76582>>>>>>>>>>>>>>>        If (hProv) Begin
76584>>>>>>>>>>>>>>>            // Create key
76584>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76585>>>>>>>>>>>>>>>            If (hKey) Begin
76587>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76588>>>>>>>>>>>>>>>                If (bOk) Begin
76590>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76591>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76592>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76593>>>>>>>>>>>>>>>                End
76593>>>>>>>>>>>>>>>>
76593>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76594>>>>>>>>>>>>>>>            End
76594>>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76595>>>>>>>>>>>>>>>        End
76595>>>>>>>>>>>>>>>>
76595>>>>>>>>>>>>>>>        Function_Return ucData
76596>>>>>>>>>>>>>>>    End_Function
76597>>>>>>>>>>>>>>>    
76597>>>>>>>>>>>>>>>    
76597>>>>>>>>>>>>>>>    //  Generates random data.
76597>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76599>>>>>>>>>>>>>>>        Handle hProv
76599>>>>>>>>>>>>>>>        UChar[] uaResult
76600>>>>>>>>>>>>>>>        Boolean bRes
76600>>>>>>>>>>>>>>>        
76600>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76601>>>>>>>>>>>>>>>        
76601>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76602>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76603>>>>>>>>>>>>>>>        
76603>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76604>>>>>>>>>>>>>>>        
76604>>>>>>>>>>>>>>>        Function_Return uaResult
76605>>>>>>>>>>>>>>>    End_Function
76606>>>>>>>>>>>>>>>    
76606>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76606>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76608>>>>>>>>>>>>>>>        String sResult
76608>>>>>>>>>>>>>>>        UChar[] ucData
76609>>>>>>>>>>>>>>>        Pointer pBase64
76609>>>>>>>>>>>>>>>        Integer iVoid
76609>>>>>>>>>>>>>>>        
76609>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76610>>>>>>>>>>>>>>>        
76610>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76611>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76612>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76613>>>>>>>>>>>>>>>        
76613>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76614>>>>>>>>>>>>>>>    End_Function
76615>>>>>>>>>>>>>>>    
76615>>>>>>>>>>>>>>>End_Class
76616>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76616>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76616>>>>>>>>>>>>>>>//>
76616>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76616>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76616>>>>>>>>>>>>>>>//>
76616>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76616>>>>>>>>>>>>>>>//> strings.
76616>>>>>>>>>>>>>>>//>
76616>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76616>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76616>>>>>>>>>>>>>>>//>
76616>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76616>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76616>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76616>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76616>>>>>>>>>>>>>>>
76616>>>>>>>>>>>>>>>Use VdfBase.pkg
76616>>>>>>>>>>>>>>>
76616>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76616>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76617>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76618>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76619>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>// Structure
76619>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76619>>>>>>>>>>>>>>>    Pointer pData
76619>>>>>>>>>>>>>>>    Integer iLength
76619>>>>>>>>>>>>>>>End_Struct 
76619>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76619>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76621>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76622>>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76625>>>>>>>>>>>>>>>        Address pBase64
76625>>>>>>>>>>>>>>>        String sResult
76625>>>>>>>>>>>>>>>        Integer iVoid
76625>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76626>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76627>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76628>>>>>>>>>>>>>>>        Function_Return sResult
76629>>>>>>>>>>>>>>>    End_Function
76630>>>>>>>>>>>>>>>
76630>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76633>>>>>>>>>>>>>>>        Address pBinary
76633>>>>>>>>>>>>>>>        String sBinary
76633>>>>>>>>>>>>>>>        Integer iVoid iLen
76633>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76634>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76635>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76636>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76637>>>>>>>>>>>>>>>        Function_Return sBinary
76638>>>>>>>>>>>>>>>    End_Function
76639>>>>>>>>>>>>>>>
76639>>>>>>>>>>>>>>>End_Object
76640>>>>>>>>>>>>>Use MSSqldrv.pkg
76640>>>>>>>>>>>>>Use db2_drv.pkg
76640>>>>>>>>>>>>>Use odbc_drv.pkg
76640>>>>>>>>>>>>>Use DFBtrDrv.pkg
76640>>>>>>>>>>>>>Use vWin32fh.pkg
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76640>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76640>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76640>>>>>>>>>>>>>// Note: If a new type is added to the list,
76640>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76640>>>>>>>>>>>>>//       so that it is filled with all SQL
76640>>>>>>>>>>>>>//       keywords for that new type.
76640>>>>>>>>>>>>>Enum_List  
76640>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76640>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76640>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76640>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76640>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76640>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76640>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76640>>>>>>>>>>>>>End_Enum_List
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76640>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76640>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76640>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76640>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76640>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76640>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76640>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76640>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76640>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// SQLConnection.ini constants:
76640>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76640>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76640>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76640>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// DF 19 ini-file settings:
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76640>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76640>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76640>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76640>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76640>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76640>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76640>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76640>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76640>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76640>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// Database Update Framework extended settings:
76640>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76640>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76640>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76640>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76640>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76640>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76640>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76640>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>Struct tSQLConnection
76640>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76640>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76640>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76640>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76640>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76640>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76640>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76640>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76640>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76640>>>>>>>>>>>>>    String sPassword                // 10. Password
76640>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76640>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76640>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76640>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76640>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76640>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76640>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76640>>>>>>>>>>>>>End_Struct
76640>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76640>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76640>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76640>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76640>>>>>>>>>>>>>
76640>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76640>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSQLScriptArray
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76641>>>>>>>>>>>>>    Integer iOrgArgumentSize
76641>>>>>>>>>>>>>    String[] sSQLScriptArray
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSqlErrorArray
76641>>>>>>>>>>>>>    String[]  sSqlErrorArray
76641>>>>>>>>>>>>>    String[]  sSqlStatementArray
76641>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSqlColumnNew
76641>>>>>>>>>>>>>    String  sBaseColumnName
76641>>>>>>>>>>>>>    String  sBaseTableName
76641>>>>>>>>>>>>>    String  sLabel
76641>>>>>>>>>>>>>    Integer iSqlType
76641>>>>>>>>>>>>>    Integer iSize
76641>>>>>>>>>>>>>    Integer iPrecision
76641>>>>>>>>>>>>>    Integer iDFType
76641>>>>>>>>>>>>>    Integer iDFNativeType
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tColumnType
76641>>>>>>>>>>>>>    String  sSQLType
76641>>>>>>>>>>>>>    Integer iSQLType
76641>>>>>>>>>>>>>    Boolean bCanEditSize
76641>>>>>>>>>>>>>    Integer iDefaultSize
76641>>>>>>>>>>>>>    Integer iMinSize
76641>>>>>>>>>>>>>    Number  nMaxSize
76641>>>>>>>>>>>>>    String  sDataFlexType
76641>>>>>>>>>>>>>    Integer iDataFlexType
76641>>>>>>>>>>>>>    Boolean bNativeDataType
76641>>>>>>>>>>>>>    String  sPrecision
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76641>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76641>>>>>>>>>>>>>// keywords.
76641>>>>>>>>>>>>>Struct tSQLKeyWords
76641>>>>>>>>>>>>>    Integer iSQLWord
76641>>>>>>>>>>>>>    Integer iSQLDbType
76641>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSQLRelation
76641>>>>>>>>>>>>>    Integer iFileNumber
76641>>>>>>>>>>>>>    Integer iFieldNumber
76641>>>>>>>>>>>>>    String  sFileName
76641>>>>>>>>>>>>>    String  sFieldName
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSQLLoggedInUser
76641>>>>>>>>>>>>>    String sUser
76641>>>>>>>>>>>>>    String sProgram
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76641>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76641>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76641>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76641>>>>>>>>>>>>>// Note: If a new type is added to the list,
76641>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76641>>>>>>>>>>>>>//       so that it is filled with all SQL
76641>>>>>>>>>>>>>//       keywords for that new type.
76641>>>>>>>>>>>>>Enum_List
76641>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76641>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76641>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76641>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76641>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76641>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76641>>>>>>>>>>>>>End_Enum_List
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76641>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76641>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76641>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76641>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76641>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76641>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76641>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76641>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76641>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76641>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76641>>>>>>>>>>>>>Enum_List
76641>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76641>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76641>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76641>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76641>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76641>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76641>>>>>>>>>>>>>End_Enum_List
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76641>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76641>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// These are not defined pre DF 18:
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSQLIntTableInfo
76641>>>>>>>>>>>>>    String sDriverName
76641>>>>>>>>>>>>>    String sServerName
76641>>>>>>>>>>>>>    String sDatabaseName
76641>>>>>>>>>>>>>    String sSchemaName
76641>>>>>>>>>>>>>    Boolean bRecnumTable
76641>>>>>>>>>>>>>    Integer iPrimaryIndex
76641>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76641>>>>>>>>>>>>>    String sTableCharacterFormat
76641>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76641>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76641>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76641>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76641>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76641>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76641>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76641>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76641>>>>>>>>>>>>>    String sFileIndexTablespace
76641>>>>>>>>>>>>>    String sFileLongTablespace
76641>>>>>>>>>>>>>    String sTableTablespace
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76641>>>>>>>>>>>>>    Integer iFieldNumber
76641>>>>>>>>>>>>>    Integer iFieldIndex
76641>>>>>>>>>>>>>    Integer iFieldRelatedFile
76641>>>>>>>>>>>>>    Integer iFieldRelatedField
76641>>>>>>>>>>>>>    Integer iIndexNumber
76641>>>>>>>>>>>>>    Integer iIndexNumberSegments
76641>>>>>>>>>>>>>    Integer iIndexSegmentField1
76641>>>>>>>>>>>>>    Integer iIndexSegmentField2
76641>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76641>>>>>>>>>>>>>    String  sIndexName
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIColumn
76641>>>>>>>>>>>>>    Integer iFieldNumber
76641>>>>>>>>>>>>>    String  sFieldName
76641>>>>>>>>>>>>>    Integer iType
76641>>>>>>>>>>>>>    String  sType
76641>>>>>>>>>>>>>    Integer iLength
76641>>>>>>>>>>>>>    Integer iPrecision
76641>>>>>>>>>>>>>    Integer iOptions
76641>>>>>>>>>>>>>    Boolean bIsSQLType
76641>>>>>>>>>>>>>    Boolean bAllowNULL
76641>>>>>>>>>>>>>    String  sDefaultValue
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIColumnCompare
76641>>>>>>>>>>>>>    Integer iFieldNumber
76641>>>>>>>>>>>>>    // FROM database:
76641>>>>>>>>>>>>>    Boolean bExistsFrom
76641>>>>>>>>>>>>>    String  sFieldNameFrom
76641>>>>>>>>>>>>>    Integer iTypeFrom
76641>>>>>>>>>>>>>    String  sTypeFrom
76641>>>>>>>>>>>>>    Integer iLengthFrom
76641>>>>>>>>>>>>>    Integer iPrecisionFrom
76641>>>>>>>>>>>>>    Integer iOptionsFrom
76641>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76641>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76641>>>>>>>>>>>>>    String  sDefaultValueFrom
76641>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76641>>>>>>>>>>>>>    Boolean bCancelFrom
76641>>>>>>>>>>>>>    Boolean bErrorFrom
76641>>>>>>>>>>>>>    // TO database:
76641>>>>>>>>>>>>>    Boolean bExistsTo
76641>>>>>>>>>>>>>    Integer iFieldNumberTo
76641>>>>>>>>>>>>>    String  sFieldNameTo
76641>>>>>>>>>>>>>    Integer iTypeTo
76641>>>>>>>>>>>>>    String  sTypeTo
76641>>>>>>>>>>>>>    Integer iLengthTo
76641>>>>>>>>>>>>>    Integer iPrecisionTo
76641>>>>>>>>>>>>>    Integer iOptionsTo
76641>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76641>>>>>>>>>>>>>    Boolean bAllowNULLTo
76641>>>>>>>>>>>>>    String  sDefaultValueTo
76641>>>>>>>>>>>>>    Boolean bShouldChangeTo
76641>>>>>>>>>>>>>    Boolean bCancelTo
76641>>>>>>>>>>>>>    Boolean bErrorTo
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIRelation
76641>>>>>>>>>>>>>    Handle  hTableFrom
76641>>>>>>>>>>>>>    Integer iColumnFrom
76641>>>>>>>>>>>>>    Handle  hTableTo
76641>>>>>>>>>>>>>    Integer iColumnTo
76641>>>>>>>>>>>>>    String  sLogicalNameFrom
76641>>>>>>>>>>>>>    String  sLogicalNameTo
76641>>>>>>>>>>>>>    String  sFieldNameFrom
76641>>>>>>>>>>>>>    String  sFieldNameTo
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIRelationCompare
76641>>>>>>>>>>>>>    // Common:
76641>>>>>>>>>>>>>    Handle  hTableFrom
76641>>>>>>>>>>>>>    Integer iColumnFrom
76641>>>>>>>>>>>>>    Handle  hTableTo
76641>>>>>>>>>>>>>    Integer iColumnTo
76641>>>>>>>>>>>>>    // FROM database:
76641>>>>>>>>>>>>>    Boolean bExistsFrom
76641>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76641>>>>>>>>>>>>>    String  sLogicalNameTo_From
76641>>>>>>>>>>>>>    String  sFieldNameFrom_From
76641>>>>>>>>>>>>>    String  sFieldNameTo_From
76641>>>>>>>>>>>>>    Boolean bShouldChange_From
76641>>>>>>>>>>>>>    Boolean bCancel_From
76641>>>>>>>>>>>>>    Boolean bError_From
76641>>>>>>>>>>>>>    // TO database:
76641>>>>>>>>>>>>>    Boolean bExistsTo
76641>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76641>>>>>>>>>>>>>    String  sLogicalNameTo_To
76641>>>>>>>>>>>>>    String  sFieldNameFrom_To
76641>>>>>>>>>>>>>    String  sFieldNameTo_To
76641>>>>>>>>>>>>>    Boolean bShouldChange_To
76641>>>>>>>>>>>>>    Boolean bCancel_To
76641>>>>>>>>>>>>>    Boolean bError_To
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIIndexSegment
76641>>>>>>>>>>>>>    Integer iFieldNumber
76641>>>>>>>>>>>>>    String  sFieldName
76641>>>>>>>>>>>>>    Boolean bUppercase
76641>>>>>>>>>>>>>    Boolean bAscending
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIIndex
76641>>>>>>>>>>>>>    Integer iIndexNumber
76641>>>>>>>>>>>>>    Integer iPrimaryIndex
76641>>>>>>>>>>>>>    String  sSQLIndexName
76641>>>>>>>>>>>>>    Integer iSQLIndexType
76641>>>>>>>>>>>>>    Boolean bIsSQLClustered
76641>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPIIndexCompare
76641>>>>>>>>>>>>>    // Common:
76641>>>>>>>>>>>>>    Integer iIndexNumber
76641>>>>>>>>>>>>>    // FROM database:
76641>>>>>>>>>>>>>    Boolean bExistsFrom
76641>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76641>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76641>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76641>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76641>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76641>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76641>>>>>>>>>>>>>    Boolean bCancelFrom
76641>>>>>>>>>>>>>    Boolean bErrorFrom
76641>>>>>>>>>>>>>    // TO database:
76641>>>>>>>>>>>>>    Boolean bExistsTo
76641>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76641>>>>>>>>>>>>>    String  sSQLIndexNameTo
76641>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76641>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76641>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76641>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76641>>>>>>>>>>>>>    Boolean bShouldChangeTo
76641>>>>>>>>>>>>>    Boolean bCancelTo
76641>>>>>>>>>>>>>    Boolean bErrorTo
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPITableNameInfo
76641>>>>>>>>>>>>>    Integer iTableNumber
76641>>>>>>>>>>>>>    String  sRootName
76641>>>>>>>>>>>>>    String  sLogicalName
76641>>>>>>>>>>>>>    String  sDisplayName
76641>>>>>>>>>>>>>    String  sDriverID
76641>>>>>>>>>>>>>    Boolean bIsAlias
76641>>>>>>>>>>>>>    Boolean bIsSQL
76641>>>>>>>>>>>>>    Boolean bIsSystemFile
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76641>>>>>>>>>>>>>    Integer iTableNumber
76641>>>>>>>>>>>>>    // FROM
76641>>>>>>>>>>>>>    Boolean bExistsFrom
76641>>>>>>>>>>>>>    String  sRootNameFrom
76641>>>>>>>>>>>>>    String  sLogicalNameFrom
76641>>>>>>>>>>>>>    String  sDisplayNameFrom
76641>>>>>>>>>>>>>    String  sDriverIDFrom
76641>>>>>>>>>>>>>    Boolean bIsAliasFrom
76641>>>>>>>>>>>>>    Boolean bIsSQLFrom
76641>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76641>>>>>>>>>>>>>    // TO database:
76641>>>>>>>>>>>>>    Boolean bExistsTo
76641>>>>>>>>>>>>>    String  sRootNameTo
76641>>>>>>>>>>>>>    String  sLogicalNameTo
76641>>>>>>>>>>>>>    String  sDisplayNameTo
76641>>>>>>>>>>>>>    String  sDriverIDTo
76641>>>>>>>>>>>>>    Boolean bIsAliasTo
76641>>>>>>>>>>>>>    Boolean bIsSQLTo
76641>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPITable
76641>>>>>>>>>>>>>    Handle hTable
76641>>>>>>>>>>>>>    Boolean bFromTable
76641>>>>>>>>>>>>>    Boolean bToTable
76641>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76641>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76641>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76641>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76641>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76641>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76641>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76641>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76641>>>>>>>>>>>>>    Boolean bShouldChange
76641>>>>>>>>>>>>>    Boolean bCancel
76641>>>>>>>>>>>>>    Boolean bError
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPITableCompare
76641>>>>>>>>>>>>>    Handle hTable
76641>>>>>>>>>>>>>    // FROM database:
76641>>>>>>>>>>>>>    Boolean bExistsFrom
76641>>>>>>>>>>>>>    // TO database:
76641>>>>>>>>>>>>>    Boolean bExistsTo
76641>>>>>>>>>>>>>    // Both:
76641>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76641>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76641>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76641>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76641>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76641>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76641>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76641>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76641>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76641>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76641>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Struct tAPITableBooleans
76641>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76641>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76641>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76641>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76641>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76641>>>>>>>>>>>>>End_Struct
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76641>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76641>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76641>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76641>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76641>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76641>>>>>>>>>>>>>Enum_List
76641>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76641>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76641>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76641>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76641>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76641>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76641>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76641>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76641>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76641>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76641>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76641>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76641>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76641>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76641>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76641>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76641>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76641>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76641>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76641>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76641>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76641>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76641>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76641>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76641>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76641>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76641>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76641>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76641>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76641>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76641>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76641>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76641>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76641>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76641>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76641>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76641>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76641>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76641>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76641>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76641>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76641>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76641>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76641>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76641>>>>>>>>>>>>>End_Enum_List
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>>>
76641>>>>>>>>>>>
76641>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76642>>>>>>>>>>>
76642>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76644>>>>>>>>>>>        Handle hoSQLManagerMT
76644>>>>>>>>>>>
76644>>>>>>>>>>>        Property String private.psUseDatabase ""
76645>>>>>>>>>>>
76645>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76645>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76646>>>>>>>>>>>        Property Integer private.piCurrentField 0
76647>>>>>>>>>>>
76647>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76648>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76649>>>>>>>>>>>
76649>>>>>>>>>>>        Property Handle phoSQLManagerMT
76650>>>>>>>>>>>
76650>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76651>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76652>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76653>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76654>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76655>>>>>>>>>>>
76655>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76656>>>>>>>>>>>
76656>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76657>>>>>>>>>>>        Property String[] paSQLFetchResults
76658>>>>>>>>>>>
76658>>>>>>>>>>>        // Error handling
76658>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76659>>>>>>>>>>>        Property Boolean pbSqlError False
76660>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76661>>>>>>>>>>>        Property Boolean pbProcessingError False
76662>>>>>>>>>>>
76662>>>>>>>>>>>        // Statistics on query
76662>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76663>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76664>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76665>>>>>>>>>>>        Property Integer piColumns 0
76666>>>>>>>>>>>        Property Integer piRows 0
76667>>>>>>>>>>>        Property Integer piRowType 0
76668>>>>>>>>>>>        Property String[] paQueryMessages
76669>>>>>>>>>>>        Property String psSQLStatementString
76670>>>>>>>>>>>
76670>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76671>>>>>>>>>>>
76671>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76672>>>>>>>>>>>
76672>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76672>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76672>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76672>>>>>>>>>>>        Property Integer piChunkMax 500
76673>>>>>>>>>>>
76673>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76673>>>>>>>>>>>        Send SetupSQLKeywordArray
76674>>>>>>>>>>>    End_Procedure
76675>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76675>>>>>>>>>>>>
76675>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76677>>>>>>>>>>>>    Integer iStart iEnd
76677>>>>>>>>>>>>    String sRetval
76677>>>>>>>>>>>>
76677>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76678>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76679>>>>>>>>>>>>    If (iStart = 0) Begin
76681>>>>>>>>>>>>        Function_Return ""
76682>>>>>>>>>>>>    End
76682>>>>>>>>>>>>>
76682>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76683>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76684>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76686>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76687>>>>>>>>>>>>    End
76687>>>>>>>>>>>>>
76687>>>>>>>>>>>>    Else Begin
76688>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76689>>>>>>>>>>>>    End
76689>>>>>>>>>>>>>
76689>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76691>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76692>>>>>>>>>>>>        Decrement iEnd
76693>>>>>>>>>>>>    End
76693>>>>>>>>>>>>>
76693>>>>>>>>>>>>    If (iEnd <> 0) Begin
76695>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76696>>>>>>>>>>>>    End
76696>>>>>>>>>>>>>
76696>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76697>>>>>>>>>>>>
76697>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76698>>>>>>>>>>>>End_Function
76699>>>>>>>>>>>>
76699>>>>>>>>>>>>
76699>>>>>>>>>>>
76699>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76699>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76701>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76703>>>>>>>>>>>            Function_Return (EQ)
76704>>>>>>>>>>>        End
76704>>>>>>>>>>>>
76704>>>>>>>>>>>        Function_Return (GT)
76705>>>>>>>>>>>    End_Function
76706>>>>>>>>>>>
76706>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76706>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76708>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76711>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76714>>>>>>>>>>>
76714>>>>>>>>>>>        Function_Return (EQ)
76715>>>>>>>>>>>    End_Function
76716>>>>>>>>>>>
76716>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76718>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76718>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76719>>>>>>>>>>>        Integer iSize
76719>>>>>>>>>>>
76719>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76720>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76721>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76722>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76723>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76724>>>>>>>>>>>
76724>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76725>>>>>>>>>>>    End_Procedure
76726>>>>>>>>>>>
76726>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76726>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76726>>>>>>>>>>>    // have slightly different wording.
76726>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76726>>>>>>>>>>>    // needs to be done for every keyword group below.
76726>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76728>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76728>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76730>>>>>>>>>>>
76730>>>>>>>>>>>        // This should only be called once; but in case it is
76730>>>>>>>>>>>        // we delete the array first.
76730>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76731>>>>>>>>>>>
76731>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76731>>>>>>>>>>>        //
76731>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76732>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76733>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76734>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76735>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76736>>>>>>>>>>>
76736>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76737>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76738>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76739>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76740>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76741>>>>>>>>>>>
76741>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76742>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76743>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76744>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76745>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76746>>>>>>>>>>>
76746>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76747>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76748>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76749>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76750>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76751>>>>>>>>>>>
76751>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76752>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76753>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76754>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76755>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76756>>>>>>>>>>>
76756>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76757>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76758>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76759>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76760>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76761>>>>>>>>>>>
76761>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76762>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76763>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76764>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76765>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76766>>>>>>>>>>>
76766>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76767>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76768>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76769>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76770>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76771>>>>>>>>>>>
76771>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76772>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76773>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76774>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76775>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76776>>>>>>>>>>>
76776>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76777>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76778>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76779>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76780>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76781>>>>>>>>>>>
76781>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76782>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76783>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76784>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76785>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76786>>>>>>>>>>>
76786>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76787>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76788>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76789>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76790>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76791>>>>>>>>>>>
76791>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76792>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76793>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76794>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76795>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76796>>>>>>>>>>>
76796>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76797>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76798>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76799>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76800>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76801>>>>>>>>>>>
76801>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76802>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76803>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76804>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76805>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76806>>>>>>>>>>>
76806>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76807>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76808>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76809>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76810>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76811>>>>>>>>>>>
76811>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76812>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76813>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76814>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76815>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76816>>>>>>>>>>>
76816>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76819>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76820>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76821>>>>>>>>>>>
76821>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76822>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76824>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76825>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76826>>>>>>>>>>>
76826>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76827>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76828>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76829>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76830>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76831>>>>>>>>>>>
76831>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76832>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76833>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76834>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76835>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76836>>>>>>>>>>>
76836>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76837>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76838>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76839>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76840>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76841>>>>>>>>>>>
76841>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76842>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76844>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76845>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76846>>>>>>>>>>>
76846>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76847>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76848>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76849>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76850>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76851>>>>>>>>>>>
76851>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76852>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76853>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76854>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76855>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76856>>>>>>>>>>>
76856>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76857>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76858>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76859>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76860>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76861>>>>>>>>>>>
76861>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76862>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76863>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76864>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76865>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76866>>>>>>>>>>>
76866>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76867>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76868>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76869>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76870>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76871>>>>>>>>>>>
76871>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76872>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76873>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76876>>>>>>>>>>>
76876>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76877>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76878>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76879>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76880>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76881>>>>>>>>>>>
76881>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76882>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76883>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76884>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76885>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76886>>>>>>>>>>>
76886>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76887>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76888>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76889>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76890>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76891>>>>>>>>>>>
76891>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76892>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76893>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76894>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76895>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76896>>>>>>>>>>>
76896>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76897>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76898>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76899>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76900>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76901>>>>>>>>>>>
76901>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76902>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76903>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76904>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76905>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76906>>>>>>>>>>>
76906>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76907>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76908>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76909>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76910>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76911>>>>>>>>>>>
76911>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76912>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76913>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76914>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76915>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76916>>>>>>>>>>>
76916>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76917>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76918>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76919>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76920>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76921>>>>>>>>>>>
76921>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76922>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76923>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76924>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76925>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76926>>>>>>>>>>>
76926>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76927>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76928>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76929>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76930>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76931>>>>>>>>>>>
76931>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76932>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76933>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76934>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76935>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76936>>>>>>>>>>>
76936>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76937>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76938>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76939>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76940>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76941>>>>>>>>>>>
76941>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76942>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76943>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76944>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76945>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76946>>>>>>>>>>>
76946>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76947>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76948>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76949>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76950>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76951>>>>>>>>>>>
76951>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76951>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76952>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76953>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76954>>>>>>>>>>>
76954>>>>>>>>>>>    End_Procedure
76955>>>>>>>>>>>
76955>>>>>>>>>>>End_Class
76956>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76956>>>>>>>>>>>//****************************************************************************
76956>>>>>>>>>>>// $Module type: Class
76956>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76956>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76956>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76956>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76956>>>>>>>>>>>//
76956>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76956>>>>>>>>>>>//
76956>>>>>>>>>>>// $Rev History:
76956>>>>>>>>>>>//    2015-08-11  Module header created
76956>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76956>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76956>>>>>>>>>>>//                Added better error handling.
76956>>>>>>>>>>>//                Added a decompose message for the connection string.
76956>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76956>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76956>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76956>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76956>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76956>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76956>>>>>>>>>>>//****************************************************************************
76956>>>>>>>>>>>Use cli.pkg
76956>>>>>>>>>>>Use MSSqldrv.pkg
76956>>>>>>>>>>>Use db2_drv.pkg
76956>>>>>>>>>>>Use odbc_drv.pkg
76956>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76956>>>>>>>>>>>>>//****************************************************************************
76956>>>>>>>>>>>>>// $Module type: Class
76956>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76956>>>>>>>>>>>>>//
76956>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76956>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76956>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76956>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76956>>>>>>>>>>>>>//
76956>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76956>>>>>>>>>>>>>//
76956>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76956>>>>>>>>>>>>>//               properties of that object.
76956>>>>>>>>>>>>>//
76956>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76956>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76956>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76956>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76956>>>>>>>>>>>>>// in the help folder for more details.
76956>>>>>>>>>>>>>//
76956>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76956>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76956>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76956>>>>>>>>>>>>>>>
76956>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76957>>>>>>>>>>>>>>>    Procedure Construct_Object
76959>>>>>>>>>>>>>>>        Forward Send Construct_Object
76961>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76962>>>>>>>>>>>>>>>    End_Procedure
76963>>>>>>>>>>>>>>>
76963>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76965>>>>>>>>>>>>>>>        String sRetval
76965>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76967>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76968>>>>>>>>>>>>>>>        End                                        
76968>>>>>>>>>>>>>>>>
76968>>>>>>>>>>>>>>>        Else Begin
76969>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76970>>>>>>>>>>>>>>>        End
76970>>>>>>>>>>>>>>>>
76970>>>>>>>>>>>>>>>            
76970>>>>>>>>>>>>>>>        Function_Return sRetval
76971>>>>>>>>>>>>>>>    End_Function
76972>>>>>>>>>>>>>>>
76972>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76974>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76974>>>>>>>>>>>>>>>        Integer iClientVersion
76974>>>>>>>>>>>>>>>        
76974>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76975>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76976>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76977>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76979>>>>>>>>>>>>>>>            Move "" to sDatabase
76980>>>>>>>>>>>>>>>        End
76980>>>>>>>>>>>>>>>>
76980>>>>>>>>>>>>>>>        
76980>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
76982>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76983>>>>>>>>>>>>>>>        End
76983>>>>>>>>>>>>>>>>
76983>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
76985>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76986>>>>>>>>>>>>>>>        End
76986>>>>>>>>>>>>>>>>
76986>>>>>>>>>>>>>>>        Else Begin
76987>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76988>>>>>>>>>>>>>>>        End
76988>>>>>>>>>>>>>>>>
76988>>>>>>>>>>>>>>>        
76988>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
76990>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
76991>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
76993>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76994>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
76995>>>>>>>>>>>>>>>            End
76995>>>>>>>>>>>>>>>>
76995>>>>>>>>>>>>>>>        End
76995>>>>>>>>>>>>>>>>
76995>>>>>>>>>>>>>>>        
76995>>>>>>>>>>>>>>>        Function_Return sConnect
76996>>>>>>>>>>>>>>>    End_Function
76997>>>>>>>>>>>>>>>
76997>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76999>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
76999>>>>>>>>>>>>>>>        String sDriverID
76999>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77000>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77002>>>>>>>>>>>>>>>            Function_Return True
77003>>>>>>>>>>>>>>>        End
77003>>>>>>>>>>>>>>>>
77003>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77004>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77006>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77007>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77009>>>>>>>>>>>>>>>        End
77009>>>>>>>>>>>>>>>>
77009>>>>>>>>>>>>>>>        Else Begin
77010>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77012>>>>>>>>>>>>>>>        End
77012>>>>>>>>>>>>>>>>
77012>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77013>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77014>>>>>>>>>>>>>>>    End_Function
77015>>>>>>>>>>>>>>>
77015>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77017>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77017>>>>>>>>>>>>>>>        String sDriver
77017>>>>>>>>>>>>>>>        
77017>>>>>>>>>>>>>>>        Move 0 to iDriver
77018>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77021>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77023>>>>>>>>>>>>>>>            Load_Driver sDriverID
77024>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77027>>>>>>>>>>>>>>>        End
77027>>>>>>>>>>>>>>>>
77027>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77033>>>>>>>>>>>>>>>>
77033>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77036>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77038>>>>>>>>>>>>>>>                Move iCount to iDriver
77039>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77040>>>>>>>>>>>>>>>            End
77040>>>>>>>>>>>>>>>>
77040>>>>>>>>>>>>>>>        Loop
77041>>>>>>>>>>>>>>>>
77041>>>>>>>>>>>>>>>    
77041>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77041>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77043>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77046>>>>>>>>>>>>>>>        End
77046>>>>>>>>>>>>>>>>
77046>>>>>>>>>>>>>>>        Function_Return iClientVersion
77047>>>>>>>>>>>>>>>    End_Function
77048>>>>>>>>>>>>>>>    
77048>>>>>>>>>>>>>>>End_Class
77049>>>>>>>>>>>>>>>
77049>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77050>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77052>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77053>>>>>>>>>>>>>>>    End_Function
77054>>>>>>>>>>>>>>>
77054>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77056>>>>>>>>>>>>>>>        Integer iClientVersion
77056>>>>>>>>>>>>>>>        String sConnect
77056>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77056>>>>>>>>>>>>>>>        
77056>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77057>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77059>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77060>>>>>>>>>>>>>>>        End
77060>>>>>>>>>>>>>>>>
77060>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77062>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77063>>>>>>>>>>>>>>>        End
77063>>>>>>>>>>>>>>>>
77063>>>>>>>>>>>>>>>        Else Begin
77064>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77065>>>>>>>>>>>>>>>        End
77065>>>>>>>>>>>>>>>>
77065>>>>>>>>>>>>>>>
77065>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77066>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77068>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77069>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77070>>>>>>>>>>>>>>>        End
77070>>>>>>>>>>>>>>>>
77070>>>>>>>>>>>>>>>        
77070>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77072>>>>>>>>>>>>>>>
77072>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77073>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77074>>>>>>>>>>>>>>>    End_Function
77075>>>>>>>>>>>>>>>
77075>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77077>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77077>>>>>>>>>>>>>>>        String sDriver
77077>>>>>>>>>>>>>>>        
77077>>>>>>>>>>>>>>>        Move 0 to iDriver
77078>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77081>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77083>>>>>>>>>>>>>>>            Load_Driver sDriverID
77084>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77087>>>>>>>>>>>>>>>        End
77087>>>>>>>>>>>>>>>>
77087>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77093>>>>>>>>>>>>>>>>
77093>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77096>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77098>>>>>>>>>>>>>>>                Move iCount to iDriver
77099>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77100>>>>>>>>>>>>>>>            End
77100>>>>>>>>>>>>>>>>
77100>>>>>>>>>>>>>>>        Loop
77101>>>>>>>>>>>>>>>>
77101>>>>>>>>>>>>>>>    
77101>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77101>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77103>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77106>>>>>>>>>>>>>>>        End
77106>>>>>>>>>>>>>>>>
77106>>>>>>>>>>>>>>>        Function_Return iClientVersion
77107>>>>>>>>>>>>>>>    End_Function
77108>>>>>>>>>>>>>>>    
77108>>>>>>>>>>>>>>>End_Class
77109>>>>>>>>>>>>>>>
77109>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77110>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77112>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77112>>>>>>>>>>>>>>>        String sDriverID
77112>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77113>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77114>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77116>>>>>>>>>>>>>>>            Function_Return True
77117>>>>>>>>>>>>>>>        End
77117>>>>>>>>>>>>>>>>
77117>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77118>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77120>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77122>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77123>>>>>>>>>>>>>>>            End
77123>>>>>>>>>>>>>>>>
77123>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77126>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77127>>>>>>>>>>>>>>>            End
77127>>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77129>>>>>>>>>>>>>>>        End
77129>>>>>>>>>>>>>>>>
77129>>>>>>>>>>>>>>>        Else Begin
77130>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77132>>>>>>>>>>>>>>>        End
77132>>>>>>>>>>>>>>>>
77132>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77133>>>>>>>>>>>>>>>
77133>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77134>>>>>>>>>>>>>>>    End_Function
77135>>>>>>>>>>>>>>>End_Class
77136>>>>>>>>>>>>>>>
77136>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77137>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77139>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77139>>>>>>>>>>>>>>>        String sDriverID
77139>>>>>>>>>>>>>>>
77139>>>>>>>>>>>>>>>        Move False to Err
77140>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77141>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77143>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77144>>>>>>>>>>>>>>>        End
77144>>>>>>>>>>>>>>>>
77144>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77146>>>>>>>>>>>>>>>
77146>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77147>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77148>>>>>>>>>>>>>>>    End_Function
77149>>>>>>>>>>>>>>>End_Class
77150>>>>>>>>>>>>>>>
77150>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77151>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77153>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77153>>>>>>>>>>>>>>>        String sDriverID
77153>>>>>>>>>>>>>>>
77153>>>>>>>>>>>>>>>        Move False to Err
77154>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77155>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77155>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77155>>>>>>>>>>>>>>>//        End
77155>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77157>>>>>>>>>>>>>>>
77157>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77158>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77159>>>>>>>>>>>>>>>    End_Function
77160>>>>>>>>>>>>>>>End_Class
77161>>>>>>>>>>>>>>>
77161>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77162>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77164>>>>>>>>>>>>>>>        Function_Return ""
77165>>>>>>>>>>>>>>>    End_Function
77166>>>>>>>>>>>>>>>End_Class
77167>>>>>>>>>>>>>>>
77167>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77168>>>>>>>>>>>>>>>    Procedure Construct_Object
77170>>>>>>>>>>>>>>>        Forward Send Construct_Object
77172>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77173>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77174>>>>>>>>>>>>>>>    End_Procedure
77175>>>>>>>>>>>>>>>
77175>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77177>>>>>>>>>>>>>>>        String sDriverID sObjectName
77177>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77177>>>>>>>>>>>>>>>
77177>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77178>>>>>>>>>>>>>>>        Case Begin
77178>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77180>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77181>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77182>>>>>>>>>>>>>>>                Case Break
77183>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77186>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77187>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77188>>>>>>>>>>>>>>>                Case Break
77189>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77192>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77193>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77194>>>>>>>>>>>>>>>                Case Break               
77195>>>>>>>>>>>>>>>            Case Else
77195>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77195>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77196>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77197>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77198>>>>>>>>>>>>>>>        Case End
77198>>>>>>>>>>>>>>>
77198>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77199>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77200>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77201>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77202>>>>>>>>>>>>>>>
77202>>>>>>>>>>>>>>>        Function_Return hoDriver
77203>>>>>>>>>>>>>>>    End_Function
77204>>>>>>>>>>>>>>>
77204>>>>>>>>>>>>>>>    Procedure DestroyDriver
77206>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77208>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77209>>>>>>>>>>>>>>>        End
77209>>>>>>>>>>>>>>>>
77209>>>>>>>>>>>>>>>    End_Procedure
77210>>>>>>>>>>>>>>>
77210>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77212>>>>>>>>>>>>>>>        String sConnect
77212>>>>>>>>>>>>>>>        Handle hoDriver
77212>>>>>>>>>>>>>>>
77212>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77213>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77215>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77216>>>>>>>>>>>>>>>        End
77216>>>>>>>>>>>>>>>>
77216>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77217>>>>>>>>>>>>>>>        Send DestroyDriver
77218>>>>>>>>>>>>>>>        Function_Return sConnect
77219>>>>>>>>>>>>>>>    End_Function
77220>>>>>>>>>>>>>>>
77220>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77222>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77222>>>>>>>>>>>>>>>        Handle hoDriver
77222>>>>>>>>>>>>>>>
77222>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77223>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77225>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77226>>>>>>>>>>>>>>>        End
77226>>>>>>>>>>>>>>>>
77226>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77227>>>>>>>>>>>>>>>        Send DestroyDriver
77228>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77229>>>>>>>>>>>>>>>    End_Function
77230>>>>>>>>>>>>>>>
77230>>>>>>>>>>>>>>>End_Class
77231>>>>>>>>>>>>>
77231>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77231>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77231>>>>>>>>>>>>>>>
77231>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77232>>>>>>>>>>>>>>>    
77232>>>>>>>>>>>>>>>    Procedure Construct_Object
77234>>>>>>>>>>>>>>>        Forward Send Construct_Object
77236>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77236>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77237>>>>>>>>>>>>>>>        
77237>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77239>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77240>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77241>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77242>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77243>>>>>>>>>>>>>>>        End_Object
77244>>>>>>>>>>>>>>>    End_Procedure
77245>>>>>>>>>>>>>>>    
77245>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77245>>>>>>>>>>>>>>>    // hidden mechanism desired.
77245>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77247>>>>>>>>>>>>>>>        String sPassword
77247>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77248>>>>>>>>>>>>>>>        Function_Return sPassword
77249>>>>>>>>>>>>>>>    End_Function
77250>>>>>>>>>>>>>>>    
77250>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77250>>>>>>>>>>>>>>>    //
77250>>>>>>>>>>>>>>>    // Params:
77250>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77250>>>>>>>>>>>>>>>    // Returns:
77250>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77250>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77252>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77252>>>>>>>>>>>>>>>        UChar[] ucBinary
77253>>>>>>>>>>>>>>>        Pointer pBase64
77253>>>>>>>>>>>>>>>        Integer iVoid
77253>>>>>>>>>>>>>>>        
77253>>>>>>>>>>>>>>>        //  Encrypt Key
77253>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77254>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77256>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77257>>>>>>>>>>>>>>>>
77257>>>>>>>>>>>>>>>        End
77257>>>>>>>>>>>>>>>>
77257>>>>>>>>>>>>>>>        
77257>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77258>>>>>>>>>>>>>>>        
77258>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77260>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77261>>>>>>>>>>>>>>>>
77261>>>>>>>>>>>>>>>            Function_Return ""
77262>>>>>>>>>>>>>>>        End
77262>>>>>>>>>>>>>>>>
77262>>>>>>>>>>>>>>>        
77262>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77262>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77263>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77264>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77265>>>>>>>>>>>>>>>        
77265>>>>>>>>>>>>>>>        Function_Return sBase64
77266>>>>>>>>>>>>>>>    End_Function
77267>>>>>>>>>>>>>>>    
77267>>>>>>>>>>>>>>>    
77267>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77267>>>>>>>>>>>>>>>    //
77267>>>>>>>>>>>>>>>    // Params:
77267>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77267>>>>>>>>>>>>>>>    // Returns:
77267>>>>>>>>>>>>>>>    //   Readable plain text password
77267>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77269>>>>>>>>>>>>>>>        String sEncryptPassword
77269>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77271>>>>>>>>>>>>>>>        Boolean bIsHex
77271>>>>>>>>>>>>>>>        Integer iLen iVoid
77271>>>>>>>>>>>>>>>        Pointer pBinary
77271>>>>>>>>>>>>>>>        
77271>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77273>>>>>>>>>>>>>>>            //  Decode from Base64
77273>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77274>>>>>>>>>>>>>>>            
77274>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77275>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77276>>>>>>>>>>>>>>>                        
77276>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77277>>>>>>>>>>>>>>>            
77277>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77277>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77278>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77279>>>>>>>>>>>>>>>        End
77279>>>>>>>>>>>>>>>>
77279>>>>>>>>>>>>>>>        
77279>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77280>>>>>>>>>>>>>>>    End_Function
77281>>>>>>>>>>>>>>>End_Class
77282>>>>>>>>>>>>>
77282>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77283>>>>>>>>>>>>>    Procedure Construct_Object
77285>>>>>>>>>>>>>        Forward Send Construct_Object
77287>>>>>>>>>>>>>
77287>>>>>>>>>>>>>        Property String Private_psIniFilePath
77288>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77289>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77290>>>>>>>>>>>>>
77290>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77291>>>>>>>>>>>>>
77291>>>>>>>>>>>>>        // *** You really want to change this value! ***
77291>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77291>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77292>>>>>>>>>>>>>
77292>>>>>>>>>>>>>    End_Procedure
77293>>>>>>>>>>>>>
77293>>>>>>>>>>>>>    Procedure End_Construct_Object
77295>>>>>>>>>>>>>        Forward Send End_Construct_Object
77297>>>>>>>>>>>>>    End_Procedure
77298>>>>>>>>>>>>>
77298>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77300>>>>>>>>>>>>>        String sIniFile
77300>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77301>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77302>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77303>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77304>>>>>>>>>>>>>    End_Procedure
77305>>>>>>>>>>>>>
77305>>>>>>>>>>>>>    Function psIniFilePath Returns String
77307>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77308>>>>>>>>>>>>>    End_Function
77309>>>>>>>>>>>>>
77309>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77311>>>>>>>>>>>>>        String sPath
77311>>>>>>>>>>>>>        Get psIniFilePath to sPath
77312>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77313>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77314>>>>>>>>>>>>>    End_Procedure
77315>>>>>>>>>>>>>
77315>>>>>>>>>>>>>    Function psIniFileName Returns String
77317>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77318>>>>>>>>>>>>>    End_Function
77319>>>>>>>>>>>>>
77319>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77319>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77319>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77319>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77321>>>>>>>>>>>>>        String sIniFile sPath
77321>>>>>>>>>>>>>
77321>>>>>>>>>>>>>        Get psIniFilePath to sPath
77322>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77323>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77324>>>>>>>>>>>>>        Set psFileName to sIniFile
77325>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77326>>>>>>>>>>>>>    End_Procedure
77327>>>>>>>>>>>>>
77327>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77327>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77327>>>>>>>>>>>>>    // Returns the value
77327>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77329>>>>>>>>>>>>>        String sValue sIniFile sPath
77329>>>>>>>>>>>>>
77329>>>>>>>>>>>>>        Get psIniFilePath to sPath
77330>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77331>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77332>>>>>>>>>>>>>        Set psFileName to sIniFile
77333>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77334>>>>>>>>>>>>>
77334>>>>>>>>>>>>>        Function_Return sValue
77335>>>>>>>>>>>>>    End_Function
77336>>>>>>>>>>>>>
77336>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77336>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77338>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77341>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77344>>>>>>>>>>>>>
77344>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77347>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77350>>>>>>>>>>>>>
77350>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77353>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77356>>>>>>>>>>>>>
77356>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77359>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77362>>>>>>>>>>>>>
77362>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77365>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77368>>>>>>>>>>>>>
77368>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77371>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77374>>>>>>>>>>>>>
77374>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77377>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77380>>>>>>>>>>>>>
77380>>>>>>>>>>>>>        Function_Return (EQ)
77381>>>>>>>>>>>>>    End_Function
77382>>>>>>>>>>>>>
77382>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77384>>>>>>>>>>>>>        Handle hoSections
77384>>>>>>>>>>>>>        Integer iItems
77384>>>>>>>>>>>>>
77384>>>>>>>>>>>>>        Send ReadSections hoSections
77385>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77386>>>>>>>>>>>>>        Function_Return iItems
77387>>>>>>>>>>>>>    End_Function
77388>>>>>>>>>>>>>
77388>>>>>>>>>>>>>    // The normal connection string looks something like this;
77388>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77388>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77388>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77388>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77388>>>>>>>>>>>>>//        String sSection
77388>>>>>>>>>>>>>//        Integer iCount
77388>>>>>>>>>>>>>//
77388>>>>>>>>>>>>>//        Move False to Err
77388>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77388>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77388>>>>>>>>>>>>>//        Increment iCount
77388>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77388>>>>>>>>>>>>>//
77388>>>>>>>>>>>>>//        Function_Return (Err = False)
77388>>>>>>>>>>>>>//    End_Function
77388>>>>>>>>>>>>>
77388>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77390>>>>>>>>>>>>>        Integer iCount
77390>>>>>>>>>>>>>        Boolean bExists
77390>>>>>>>>>>>>>        String sSection
77390>>>>>>>>>>>>>
77390>>>>>>>>>>>>>        Move False to Err
77391>>>>>>>>>>>>>        Move 1 to iCount
77392>>>>>>>>>>>>>        Get psIniSectionName to sSection
77393>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77394>>>>>>>>>>>>>        While (bExists = True)
77398>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77399>>>>>>>>>>>>>            Increment iCount
77400>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77401>>>>>>>>>>>>>        Loop
77402>>>>>>>>>>>>>>
77402>>>>>>>>>>>>>        Function_Return (Err = False)
77403>>>>>>>>>>>>>    End_Function
77404>>>>>>>>>>>>>
77404>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77406>>>>>>>>>>>>>        Integer iCount
77406>>>>>>>>>>>>>        String sSection
77406>>>>>>>>>>>>>        Boolean bExists
77406>>>>>>>>>>>>>
77406>>>>>>>>>>>>>        Move False to Err
77407>>>>>>>>>>>>>        Move 1 to iCount
77408>>>>>>>>>>>>>        Get psIniSectionName to sSection
77409>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77410>>>>>>>>>>>>>        While (bExists = True)
77414>>>>>>>>>>>>>            If (iCount = iItem) Begin
77416>>>>>>>>>>>>>                Send DeleteSection sSection
77417>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77417>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77418>>>>>>>>>>>>>            End
77418>>>>>>>>>>>>>>
77418>>>>>>>>>>>>>            Increment iCount
77419>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77420>>>>>>>>>>>>>        Loop
77421>>>>>>>>>>>>>>
77421>>>>>>>>>>>>>
77421>>>>>>>>>>>>>        Function_Return (Err = False)
77422>>>>>>>>>>>>>    End_Function
77423>>>>>>>>>>>>>
77423>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77423>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77423>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77425>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77425>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77426>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77426>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77426>>>>>>>>>>>>>        Integer iIndex
77426>>>>>>>>>>>>>
77426>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77427>>>>>>>>>>>>>        If (iIndex = -1) Begin
77429>>>>>>>>>>>>>            Move True to SQLConnection.bError
77430>>>>>>>>>>>>>            Function_Return SQLConnection
77431>>>>>>>>>>>>>        End
77431>>>>>>>>>>>>>>
77431>>>>>>>>>>>>>
77431>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77432>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77433>>>>>>>>>>>>>
77433>>>>>>>>>>>>>        Function_Return SQLConnection
77434>>>>>>>>>>>>>    End_Function
77435>>>>>>>>>>>>>
77435>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77435>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77437>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77437>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77438>>>>>>>>>>>>>        Integer iRetval iCount iSize
77438>>>>>>>>>>>>>        String sValue
77438>>>>>>>>>>>>>        Boolean bExists
77438>>>>>>>>>>>>>
77438>>>>>>>>>>>>>        Move -1 to iRetval
77439>>>>>>>>>>>>>
77439>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77440>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77441>>>>>>>>>>>>>        Decrement iSize
77442>>>>>>>>>>>>>        For iCount from 0 to iSize
77448>>>>>>>>>>>>>>
77448>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77449>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77450>>>>>>>>>>>>>            If (bExists) Begin
77452>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77453>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77454>>>>>>>>>>>>>            End
77454>>>>>>>>>>>>>>
77454>>>>>>>>>>>>>        Loop
77455>>>>>>>>>>>>>>
77455>>>>>>>>>>>>>
77455>>>>>>>>>>>>>        Function_Return iRetval
77456>>>>>>>>>>>>>    End_Function
77457>>>>>>>>>>>>>
77457>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77457>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77457>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77459>>>>>>>>>>>>>        Integer iCount iSize iItems
77459>>>>>>>>>>>>>        String sValue
77459>>>>>>>>>>>>>        Boolean bExists
77459>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77459>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77460>>>>>>>>>>>>>
77460>>>>>>>>>>>>>        Move 0 to iItems
77461>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77462>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77463>>>>>>>>>>>>>        Decrement iSize
77464>>>>>>>>>>>>>        For iCount from 0 to iSize
77470>>>>>>>>>>>>>>
77470>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77471>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77472>>>>>>>>>>>>>            If (bExists) Begin
77474>>>>>>>>>>>>>                Increment iItems
77475>>>>>>>>>>>>>            End
77475>>>>>>>>>>>>>>
77475>>>>>>>>>>>>>        Loop
77476>>>>>>>>>>>>>>
77476>>>>>>>>>>>>>
77476>>>>>>>>>>>>>        Function_Return (iItems > 1)
77477>>>>>>>>>>>>>    End_Function
77478>>>>>>>>>>>>>
77478>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77478>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77480>>>>>>>>>>>>>        Boolean bOK
77480>>>>>>>>>>>>>        Integer iSize iCount
77480>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77480>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77481>>>>>>>>>>>>>        tSQLConnection SQLConnection
77481>>>>>>>>>>>>>        tSQLConnection SQLConnection
77481>>>>>>>>>>>>>        String sConnectionString
77481>>>>>>>>>>>>>
77481>>>>>>>>>>>>>        Move False to Err
77482>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77483>>>>>>>>>>>>>
77483>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77484>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77485>>>>>>>>>>>>>        Decrement iSize
77486>>>>>>>>>>>>>        // Set all current connection to inactive.
77486>>>>>>>>>>>>>        For iCount from 0 to iSize
77492>>>>>>>>>>>>>>
77492>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77493>>>>>>>>>>>>>        Loop
77494>>>>>>>>>>>>>>
77494>>>>>>>>>>>>>
77494>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77495>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77496>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77497>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77498>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77499>>>>>>>>>>>>>
77499>>>>>>>>>>>>>        Function_Return (bOK = True)
77500>>>>>>>>>>>>>    End_Function
77501>>>>>>>>>>>>>
77501>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77501>>>>>>>>>>>>>    // Returns True if successful.
77501>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77503>>>>>>>>>>>>>        Boolean bOK
77503>>>>>>>>>>>>>        Integer iItem iSize iCount
77503>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77503>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>        Move False to Err
77505>>>>>>>>>>>>>        Move -1 to iItem
77506>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77507>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77508>>>>>>>>>>>>>        Decrement iSize
77509>>>>>>>>>>>>>        // Set all current connection to inactive.
77509>>>>>>>>>>>>>        For iCount from 0 to iSize
77515>>>>>>>>>>>>>>
77515>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77516>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77518>>>>>>>>>>>>>                Move iCount to iItem
77519>>>>>>>>>>>>>            End
77519>>>>>>>>>>>>>>
77519>>>>>>>>>>>>>        Loop
77520>>>>>>>>>>>>>>
77520>>>>>>>>>>>>>
77520>>>>>>>>>>>>>        If (iItem <> -1) Begin
77522>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77523>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77524>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77525>>>>>>>>>>>>>        End
77525>>>>>>>>>>>>>>
77525>>>>>>>>>>>>>
77525>>>>>>>>>>>>>        Function_Return (bOK = True)
77526>>>>>>>>>>>>>    End_Function
77527>>>>>>>>>>>>>
77527>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77529>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77529>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77530>>>>>>>>>>>>>        String sSection sValue
77530>>>>>>>>>>>>>        Integer iCount
77530>>>>>>>>>>>>>        Boolean bExists
77530>>>>>>>>>>>>>
77530>>>>>>>>>>>>>        Get psIniSectionName to sSection
77531>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77532>>>>>>>>>>>>>        If (bExists = False) Begin
77534>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77535>>>>>>>>>>>>>        End
77535>>>>>>>>>>>>>>
77535>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77536>>>>>>>>>>>>>        If (bExists = True) Begin
77538>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>        End
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>
77539>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77540>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77541>>>>>>>>>>>>>
77541>>>>>>>>>>>>>        While (bExists = True)                 
77545>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77545>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77545>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77545>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77545>>>>>>>>>>>>>
77545>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77546>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77547>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77548>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77549>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77550>>>>>>>>>>>>>            If (sValue = "99") Begin
77552>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77553>>>>>>>>>>>>>            End
77553>>>>>>>>>>>>>>
77553>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77554>>>>>>>>>>>>>
77554>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77555>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77556>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77558>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77559>>>>>>>>>>>>>            End
77559>>>>>>>>>>>>>>
77559>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77561>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77562>>>>>>>>>>>>>            End
77562>>>>>>>>>>>>>>
77562>>>>>>>>>>>>>
77562>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77563>>>>>>>>>>>>>
77563>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77564>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77565>>>>>>>>>>>>>
77565>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77566>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77567>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77569>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77570>>>>>>>>>>>>>            End
77570>>>>>>>>>>>>>>
77570>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77571>>>>>>>>>>>>>
77571>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77571>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77572>>>>>>>>>>>>>
77572>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77573>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77574>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77575>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77576>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77577>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77578>>>>>>>>>>>>>
77578>>>>>>>>>>>>>            Increment iCount
77579>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77580>>>>>>>>>>>>>        Loop
77581>>>>>>>>>>>>>>
77581>>>>>>>>>>>>>
77581>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77581>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77583>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77584>>>>>>>>>>>>>        End
77584>>>>>>>>>>>>>>
77584>>>>>>>>>>>>>
77584>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77585>>>>>>>>>>>>>    End_Function
77586>>>>>>>>>>>>>
77586>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77588>>>>>>>>>>>>>        Integer iCount iSize
77588>>>>>>>>>>>>>        Boolean bOK
77588>>>>>>>>>>>>>        String sSection sValue
77588>>>>>>>>>>>>>
77588>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77588>>>>>>>>>>>>>        Move 0 to iCount
77589>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77590>>>>>>>>>>>>>        If (bOK = False) Begin
77592>>>>>>>>>>>>>            Function_Return False
77593>>>>>>>>>>>>>        End
77593>>>>>>>>>>>>>>
77593>>>>>>>>>>>>>
77593>>>>>>>>>>>>>        Move False to Err
77594>>>>>>>>>>>>>        Get psIniSectionName to sSection
77595>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77595>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77596>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77597>>>>>>>>>>>>>        Decrement iSize
77598>>>>>>>>>>>>>
77598>>>>>>>>>>>>>        For iCount from 0 to iSize
77604>>>>>>>>>>>>>>
77604>>>>>>>>>>>>>            // DF 19 compatible settings:
77604>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77605>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77606>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77607>>>>>>>>>>>>>            
77607>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77608>>>>>>>>>>>>>
77608>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77609>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77611>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77612>>>>>>>>>>>>>            End
77612>>>>>>>>>>>>>>
77612>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77613>>>>>>>>>>>>>
77613>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77615>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77616>>>>>>>>>>>>>            End
77616>>>>>>>>>>>>>>
77616>>>>>>>>>>>>>
77616>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77617>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77618>>>>>>>>>>>>>
77618>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77618>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77619>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77620>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77621>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77622>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77623>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77624>>>>>>>>>>>>>        Loop
77625>>>>>>>>>>>>>>
77625>>>>>>>>>>>>>
77625>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77626>>>>>>>>>>>>>    End_Function
77627>>>>>>>>>>>>>
77627>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77627>>>>>>>>>>>>>    //
77627>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77627>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77627>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77629>>>>>>>>>>>>>        String sRetval
77629>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77631>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77632>>>>>>>>>>>>>        End
77632>>>>>>>>>>>>>>
77632>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77634>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77635>>>>>>>>>>>>>        End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77637>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77638>>>>>>>>>>>>>        End
77638>>>>>>>>>>>>>>
77638>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77640>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77641>>>>>>>>>>>>>        End
77641>>>>>>>>>>>>>>
77641>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77643>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77644>>>>>>>>>>>>>        End
77644>>>>>>>>>>>>>>
77644>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77646>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77647>>>>>>>>>>>>>        End
77647>>>>>>>>>>>>>>
77647>>>>>>>>>>>>>        Function_Return sRetval
77648>>>>>>>>>>>>>    End_Function
77649>>>>>>>>>>>>>
77649>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77649>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77649>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77651>>>>>>>>>>>>>        Integer iRetval
77651>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77653>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77654>>>>>>>>>>>>>        End
77654>>>>>>>>>>>>>>
77654>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77656>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77657>>>>>>>>>>>>>        End
77657>>>>>>>>>>>>>>
77657>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77659>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77660>>>>>>>>>>>>>        End
77660>>>>>>>>>>>>>>
77660>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77662>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77663>>>>>>>>>>>>>        End
77663>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77665>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77666>>>>>>>>>>>>>        End
77666>>>>>>>>>>>>>>
77666>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77668>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77669>>>>>>>>>>>>>        End
77669>>>>>>>>>>>>>>
77669>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77671>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77672>>>>>>>>>>>>>        End
77672>>>>>>>>>>>>>>
77672>>>>>>>>>>>>>        Function_Return iRetval
77673>>>>>>>>>>>>>    End_Function
77674>>>>>>>>>>>>>
77674>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77674>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77674>>>>>>>>>>>>>    // the SQL Connection program's grid.
77674>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77676>>>>>>>>>>>>>        String sRetval
77676>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77678>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77679>>>>>>>>>>>>>        End
77679>>>>>>>>>>>>>>
77679>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77681>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77682>>>>>>>>>>>>>        End
77682>>>>>>>>>>>>>>
77682>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77684>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77685>>>>>>>>>>>>>        End
77685>>>>>>>>>>>>>>
77685>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77687>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77688>>>>>>>>>>>>>        End
77688>>>>>>>>>>>>>>
77688>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77690>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77691>>>>>>>>>>>>>        End
77691>>>>>>>>>>>>>>
77691>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77693>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77694>>>>>>>>>>>>>        End
77694>>>>>>>>>>>>>>
77694>>>>>>>>>>>>>        Function_Return sRetval
77695>>>>>>>>>>>>>    End_Function
77696>>>>>>>>>>>>>
77696>>>>>>>>>>>>>    // Pass a driver id and the function will return
77696>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77696>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77696>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77698>>>>>>>>>>>>>        Integer iRetval
77698>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77700>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77701>>>>>>>>>>>>>        End
77701>>>>>>>>>>>>>>
77701>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77703>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77704>>>>>>>>>>>>>        End
77704>>>>>>>>>>>>>>
77704>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77706>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77707>>>>>>>>>>>>>        End
77707>>>>>>>>>>>>>>
77707>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77709>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77710>>>>>>>>>>>>>        End
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>        Function_Return iRetval
77711>>>>>>>>>>>>>    End_Function
77712>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77712>>>>>>>>>>>>>>
77712>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77714>>>>>>>>>>>>>>    Integer iStart iEnd
77714>>>>>>>>>>>>>>    String sRetval
77714>>>>>>>>>>>>>>
77714>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77715>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77716>>>>>>>>>>>>>>    If (iStart = 0) Begin
77718>>>>>>>>>>>>>>        Function_Return ""
77719>>>>>>>>>>>>>>    End
77719>>>>>>>>>>>>>>>
77719>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77720>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77721>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77723>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77724>>>>>>>>>>>>>>    End
77724>>>>>>>>>>>>>>>
77724>>>>>>>>>>>>>>    Else Begin
77725>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77726>>>>>>>>>>>>>>    End
77726>>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77728>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77729>>>>>>>>>>>>>>        Decrement iEnd
77730>>>>>>>>>>>>>>    End
77730>>>>>>>>>>>>>>>
77730>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77732>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77733>>>>>>>>>>>>>>    End
77733>>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77734>>>>>>>>>>>>>>
77734>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77735>>>>>>>>>>>>>>End_Function
77736>>>>>>>>>>>>>>
77736>>>>>>>>>>>>>>
77736>>>>>>>>>>>>>
77736>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77738>>>>>>>>>>>>>        String sConnect
77738>>>>>>>>>>>>>        Handle hoDriver
77738>>>>>>>>>>>>>
77738>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77739>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77740>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77741>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77742>>>>>>>>>>>>>        Send Destroy of hoDriver
77743>>>>>>>>>>>>>
77743>>>>>>>>>>>>>        Function_Return sConnect
77744>>>>>>>>>>>>>    End_Function
77745>>>>>>>>>>>>>
77745>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77745>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77747>>>>>>>>>>>>>        String sConnect
77747>>>>>>>>>>>>>
77747>>>>>>>>>>>>>        Case Begin
77747>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77749>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77750>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77752>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77753>>>>>>>>>>>>>                End
77753>>>>>>>>>>>>>>
77753>>>>>>>>>>>>>                Case Break
77754>>>>>>>>>>>>>
77754>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77757>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77759>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77760>>>>>>>>>>>>>                End
77760>>>>>>>>>>>>>>
77760>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77763>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77764>>>>>>>>>>>>>                End
77764>>>>>>>>>>>>>>
77764>>>>>>>>>>>>>
77764>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77766>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77767>>>>>>>>>>>>>                End
77767>>>>>>>>>>>>>>
77767>>>>>>>>>>>>>                Case Break
77768>>>>>>>>>>>>>
77768>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77771>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77772>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77774>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77775>>>>>>>>>>>>>                End
77775>>>>>>>>>>>>>>
77775>>>>>>>>>>>>>                Case Break
77776>>>>>>>>>>>>>
77776>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77779>>>>>>>>>>>>>                Break
77780>>>>>>>>>>>>>
77780>>>>>>>>>>>>>            Case Else
77780>>>>>>>>>>>>>                Move "" to sConnect
77781>>>>>>>>>>>>>        Case End
77781>>>>>>>>>>>>>
77781>>>>>>>>>>>>>        Function_Return sConnect
77782>>>>>>>>>>>>>    End_Function
77783>>>>>>>>>>>>>
77783>>>>>>>>>>>>>    // Use Base64
77783>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77785>>>>>>>>>>>>>        String sRetval
77785>>>>>>>>>>>>>        Handle hoLoginEncryption
77785>>>>>>>>>>>>>
77785>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77786>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77787>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77788>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77789>>>>>>>>>>>>>          
77789>>>>>>>>>>>>>        Function_Return sRetval
77790>>>>>>>>>>>>>    End_Function
77791>>>>>>>>>>>>>
77791>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77793>>>>>>>>>>>>>        String sRetval
77793>>>>>>>>>>>>>        Handle hoLoginEncryption
77793>>>>>>>>>>>>>
77793>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77794>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77795>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77796>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77797>>>>>>>>>>>>>
77797>>>>>>>>>>>>>        Function_Return sRetval
77798>>>>>>>>>>>>>    End_Function
77799>>>>>>>>>>>>>
77799>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77799>>>>>>>>>>>>>    Function ApplicationPath Returns String
77801>>>>>>>>>>>>>        String sApplicationFileName sPath
77801>>>>>>>>>>>>>        Integer iNumChars iRetval
77801>>>>>>>>>>>>>
77801>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77802>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77803>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77804>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77805>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77806>>>>>>>>>>>>>
77806>>>>>>>>>>>>>        Function_Return sPath
77807>>>>>>>>>>>>>    End_Function
77808>>>>>>>>>>>>>
77808>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77808>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77808>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77808>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77810>>>>>>>>>>>>>        Boolean bExists
77810>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77810>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77811>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77811>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77811>>>>>>>>>>>>>        
77811>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77812>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77813>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77814>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77815>>>>>>>>>>>>>        If (bExists = True) Begin
77817>>>>>>>>>>>>>            Function_Return sProgramsPath
77818>>>>>>>>>>>>>        End                      
77818>>>>>>>>>>>>>>
77818>>>>>>>>>>>>>    
77818>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77819>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77821>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77822>>>>>>>>>>>>>        End                                              
77822>>>>>>>>>>>>>>
77822>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77823>>>>>>>>>>>>>        
77823>>>>>>>>>>>>>        Move False to bExists
77824>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77825>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77826>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77827>>>>>>>>>>>>>        Decrement iSize       
77828>>>>>>>>>>>>>        
77828>>>>>>>>>>>>>        For iCount from 0 to iSize
77834>>>>>>>>>>>>>>
77834>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77835>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77836>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77837>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77838>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77844>>>>>>>>>>>>>>
77844>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77845>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77846>>>>>>>>>>>>>                // Check if there are more than one path specified;
77846>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77847>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77849>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77850>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77856>>>>>>>>>>>>>>
77856>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77857>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77858>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77859>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77860>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77861>>>>>>>>>>>>>                        If (bExists = True) Begin
77863>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77864>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77865>>>>>>>>>>>>>                            Move iSize to iCount
77866>>>>>>>>>>>>>                        End                                                    
77866>>>>>>>>>>>>>>
77866>>>>>>>>>>>>>                    Loop
77867>>>>>>>>>>>>>>
77867>>>>>>>>>>>>>                End
77867>>>>>>>>>>>>>>
77867>>>>>>>>>>>>>                Else Begin
77868>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77869>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77870>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77871>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77872>>>>>>>>>>>>>                    If (bExists = True) Begin
77874>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77875>>>>>>>>>>>>>                        Move iSize to iCount
77876>>>>>>>>>>>>>                    End                                                    
77876>>>>>>>>>>>>>>
77876>>>>>>>>>>>>>                End
77876>>>>>>>>>>>>>>
77876>>>>>>>>>>>>>            Loop
77877>>>>>>>>>>>>>>
77877>>>>>>>>>>>>>            If (bExists = False) Begin
77879>>>>>>>>>>>>>                Move "" to sPath    
77880>>>>>>>>>>>>>            End
77880>>>>>>>>>>>>>>
77880>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77881>>>>>>>>>>>>>        Loop        
77882>>>>>>>>>>>>>>
77882>>>>>>>>>>>>>        Send Destroy of hoPaths
77883>>>>>>>>>>>>>        
77883>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77883>>>>>>>>>>>>>        If (sPath = "") Begin
77885>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77886>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77887>>>>>>>>>>>>>        End                  
77887>>>>>>>>>>>>>>
77887>>>>>>>>>>>>>        
77887>>>>>>>>>>>>>        Function_Return sPath    
77888>>>>>>>>>>>>>    End_Function
77889>>>>>>>>>>>>>    
77889>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77889>>>>>>>>>>>>>    // with one or more .ws file names.
77889>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77889>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77889>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77889>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77891>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77893>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77893>>>>>>>>>>>>>        Integer iCh iSize
77893>>>>>>>>>>>>>        Boolean bExists      
77893>>>>>>>>>>>>>        Handle hoIniFile 
77893>>>>>>>>>>>>>        
77893>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77894>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77895>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77897>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77898>>>>>>>>>>>>>        End                                              
77898>>>>>>>>>>>>>>
77898>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77899>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77900>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77901>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77902>>>>>>>>>>>>>        
77902>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77902>>>>>>>>>>>>>        // read the name of the .ws file name.
77902>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77903>>>>>>>>>>>>>        If (bExists = True) Begin
77905>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77906>>>>>>>>>>>>>            If (iCh < 0) Begin
77908>>>>>>>>>>>>>                Function_Return asSWSFiles
77909>>>>>>>>>>>>>            End                                 
77909>>>>>>>>>>>>>>
77909>>>>>>>>>>>>>            
77909>>>>>>>>>>>>>            Repeat
77909>>>>>>>>>>>>>>
77909>>>>>>>>>>>>>                Readln channel iCh sFile
77911>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77913>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77914>>>>>>>>>>>>>                End
77914>>>>>>>>>>>>>>
77914>>>>>>>>>>>>>            Until (SeqEof = True)
77916>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77917>>>>>>>>>>>>>            
77917>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77918>>>>>>>>>>>>>            If (iSize <> 0) Begin
77920>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77921>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77921>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77921>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77922>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77923>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77924>>>>>>>>>>>>>                If (sFile <> "") Begin
77926>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77927>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77928>>>>>>>>>>>>>                    File_Exist sFile bExists
77929>>>>>>>>>>>>>                    If (bExists = True) Begin
77931>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77932>>>>>>>>>>>>>                    End
77932>>>>>>>>>>>>>>
77932>>>>>>>>>>>>>                End
77932>>>>>>>>>>>>>>
77932>>>>>>>>>>>>>                Send Destroy of hoIniFile
77933>>>>>>>>>>>>>            End
77933>>>>>>>>>>>>>>
77933>>>>>>>>>>>>>        End
77933>>>>>>>>>>>>>>
77933>>>>>>>>>>>>>        
77933>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77933>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77935>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77936>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77937>>>>>>>>>>>>>            If (bExists = False) Begin
77939>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77940>>>>>>>>>>>>>            End
77940>>>>>>>>>>>>>>
77940>>>>>>>>>>>>>        
77940>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77941>>>>>>>>>>>>>            If (iCh < 0) Begin
77943>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77944>>>>>>>>>>>>>            End                                 
77944>>>>>>>>>>>>>>
77944>>>>>>>>>>>>>            
77944>>>>>>>>>>>>>            Repeat
77944>>>>>>>>>>>>>>
77944>>>>>>>>>>>>>                Readln channel iCh sFile
77946>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77948>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77949>>>>>>>>>>>>>                End
77949>>>>>>>>>>>>>>
77949>>>>>>>>>>>>>            Until (SeqEof = True)
77951>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77952>>>>>>>>>>>>>        End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>        
77952>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77953>>>>>>>>>>>>>    End_Function
77954>>>>>>>>>>>>>
77954>>>>>>>>>>>>>End_Class
77955>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77955>>>>>>>>>>>Use vWin32fh.pkg
77955>>>>>>>>>>>
77955>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77955>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77955>>>>>>>>>>>
77955>>>>>>>>>>>// We're making references to this object handle so we need it defined
77955>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77955>>>>>>>>>>>
77955>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77955>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77956>>>>>>>>>>>
77956>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77957>>>>>>>>>>>
77957>>>>>>>>>>>    Procedure Construct_Object
77959>>>>>>>>>>>        Handle ho
77959>>>>>>>>>>>        Forward Send Construct_Object
77961>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77962>>>>>>>>>>>
77962>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77963>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77964>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77965>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77966>>>>>>>>>>>        
77966>>>>>>>>>>>
77966>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77966>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77966>>>>>>>>>>>        // methods to this class.
77966>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77967>>>>>>>>>>>        Property Boolean pbToANSI          True
77968>>>>>>>>>>>        Property Boolean pbRecnum          True
77969>>>>>>>>>>>        Property Boolean pbCopyData        True
77970>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77971>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77972>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77973>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77974>>>>>>>>>>>
77974>>>>>>>>>>>        // Driver default value settings:
77974>>>>>>>>>>>        // Note: When the object is created the corresponding values
77974>>>>>>>>>>>        // from the driver .int files are read.
77974>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77974>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77975>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77976>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77977>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77978>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77979>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77980>>>>>>>>>>>
77980>>>>>>>>>>>        // Driver "nullability" settings:
77980>>>>>>>>>>>        // Note: When the object is created the corresponding values
77980>>>>>>>>>>>        // from the driver .int files are read.
77980>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77980>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77981>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77982>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77983>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77984>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77985>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77986>>>>>>>>>>>
77986>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77986>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
77986>>>>>>>>>>>        //     driver interfaces.
77986>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77986>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77986>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77987>>>>>>>>>>>
77987>>>>>>>>>>>    End_Procedure
77988>>>>>>>>>>>
77988>>>>>>>>>>>    Procedure End_Construct_Object
77990>>>>>>>>>>>        tSQLConnection SQLConnection
77990>>>>>>>>>>>        tSQLConnection SQLConnection
77990>>>>>>>>>>>
77990>>>>>>>>>>>        Forward Send End_Construct_Object
77992>>>>>>>>>>>
77992>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77992>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77993>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77994>>>>>>>>>>>    End_Procedure
77995>>>>>>>>>>>
77995>>>>>>>>>>>    // *** Properties ***
77995>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77995>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77995>>>>>>>>>>>    // merely here for conveniance.
77995>>>>>>>>>>>    //
77995>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77995>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77995>>>>>>>>>>>    // This struct property contains all the connection data.
77995>>>>>>>>>>>    //
77995>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77997>>>>>>>>>>>        Boolean bOK
77997>>>>>>>>>>>
77997>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77998>>>>>>>>>>>
77998>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
77998>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78000>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78000>>>>>>>>>>>            Procedure_Return
78001>>>>>>>>>>>        End
78001>>>>>>>>>>>>
78001>>>>>>>>>>>
78001>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78001>>>>>>>>>>>        // be logged in already and don't want to do it again.
78001>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78003>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78003>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78003>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78004>>>>>>>>>>>            If (bOK = False) Begin
78006>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78007>>>>>>>>>>>>
78007>>>>>>>>>>>            End
78007>>>>>>>>>>>>
78007>>>>>>>>>>>        End
78007>>>>>>>>>>>>
78007>>>>>>>>>>>
78007>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78007>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78008>>>>>>>>>>>
78008>>>>>>>>>>>    End_Procedure
78009>>>>>>>>>>>
78009>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78009>>>>>>>>>>>    // attempt to load the driver.
78009>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78009>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78011>>>>>>>>>>>        Boolean bOK
78011>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78012>>>>>>>>>>>        Function_Return bOK
78013>>>>>>>>>>>    End_Function
78014>>>>>>>>>>>
78014>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78014>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78016>>>>>>>>>>>        String sAttributeValue sServer
78016>>>>>>>>>>>        Integer iDriverID
78016>>>>>>>>>>>        Boolean bNULL bSQLDriver
78016>>>>>>>>>>>        Handle hDatabase
78016>>>>>>>>>>>        
78016>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78017>>>>>>>>>>>        If (bSQLDriver = False) Begin
78019>>>>>>>>>>>            Procedure_Return
78020>>>>>>>>>>>        End                                      
78020>>>>>>>>>>>>
78020>>>>>>>>>>>        
78020>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78021>>>>>>>>>>>        
78021>>>>>>>>>>>        // ToDo: Testing!
78021>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78021>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78021>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78021>>>>>>>>>>>
78021>>>>>>>>>>>        // Driver default values for various data types:
78021>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78024>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78025>>>>>>>>>>>
78025>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78028>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78029>>>>>>>>>>>
78029>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78032>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78033>>>>>>>>>>>
78033>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78036>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78037>>>>>>>>>>>
78037>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78040>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78041>>>>>>>>>>>
78041>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78044>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78045>>>>>>>>>>>
78045>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78045>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78048>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78049>>>>>>>>>>>
78049>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78052>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78053>>>>>>>>>>>
78053>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78056>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78057>>>>>>>>>>>
78057>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78060>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78061>>>>>>>>>>>
78061>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78064>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78065>>>>>>>>>>>
78065>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78068>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78069>>>>>>>>>>>
78069>>>>>>>>>>>    End_Procedure
78070>>>>>>>>>>>
78070>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78072>>>>>>>>>>>        Boolean bOK bIsDaw
78072>>>>>>>>>>>        String sConnectionString
78072>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78072>>>>>>>>>>>        Integer iDriverID
78072>>>>>>>>>>>
78072>>>>>>>>>>>        Move False to bOK
78073>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78074>>>>>>>>>>>
78074>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78075>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78076>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78077>>>>>>>>>>>        If (iDriverID = 0) Begin
78079>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78080>>>>>>>>>>>            Function_Return False
78081>>>>>>>>>>>        End
78081>>>>>>>>>>>>
78081>>>>>>>>>>>
78081>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78084>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78085>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78086>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78087>>>>>>>>>>>        Send Destroy   of hoDriver
78088>>>>>>>>>>>
78088>>>>>>>>>>>        Function_Return bOK
78089>>>>>>>>>>>    End_Function
78090>>>>>>>>>>>
78090>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78092>>>>>>>>>>>        tSQLConnection SQLConnection
78092>>>>>>>>>>>        tSQLConnection SQLConnection
78092>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78093>>>>>>>>>>>        Function_Return SQLConnection
78094>>>>>>>>>>>    End_Function
78095>>>>>>>>>>>
78095>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78097>>>>>>>>>>>        tSQLConnection SQLConnection
78097>>>>>>>>>>>        tSQLConnection SQLConnection
78097>>>>>>>>>>>
78097>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78098>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78100>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78101>>>>>>>>>>>        End
78101>>>>>>>>>>>>
78101>>>>>>>>>>>
78101>>>>>>>>>>>        // Else we might want to change the current connection ID
78101>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78104>>>>>>>>>>>            Move False to Err
78105>>>>>>>>>>>            Logout SQLConnection.sDriverID
78106>>>>>>>>>>>            // This will also make a login to the new server.
78106>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78107>>>>>>>>>>>        End
78107>>>>>>>>>>>>
78107>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78108>>>>>>>>>>>    End_Procedure
78109>>>>>>>>>>>
78109>>>>>>>>>>>    Function psConnectionID Returns String
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78112>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78113>>>>>>>>>>>    End_Function
78114>>>>>>>>>>>
78114>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78114>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78114>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78114>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78114>>>>>>>>>>>    Procedure Set psDriverID String sValue
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78117>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78118>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78119>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78121>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78122>>>>>>>>>>>        End
78122>>>>>>>>>>>>
78122>>>>>>>>>>>    End_Procedure
78123>>>>>>>>>>>
78123>>>>>>>>>>>    Function psDriverID Returns String
78125>>>>>>>>>>>        tSQLConnection SQLConnection
78125>>>>>>>>>>>        tSQLConnection SQLConnection
78125>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78126>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78128>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78129>>>>>>>>>>>        End
78129>>>>>>>>>>>>
78129>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78130>>>>>>>>>>>    End_Function
78131>>>>>>>>>>>
78131>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78133>>>>>>>>>>>        tSQLConnection SQLConnection
78133>>>>>>>>>>>        tSQLConnection SQLConnection
78133>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78134>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78135>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78136>>>>>>>>>>>    End_Procedure
78137>>>>>>>>>>>
78137>>>>>>>>>>>    Function psConnectionString Returns String
78139>>>>>>>>>>>        tSQLConnection SQLConnection
78139>>>>>>>>>>>        tSQLConnection SQLConnection
78139>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78140>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78141>>>>>>>>>>>    End_Function
78142>>>>>>>>>>>
78142>>>>>>>>>>>    Procedure Set psServer String sValue
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78145>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78146>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78147>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78148>>>>>>>>>>>    End_Procedure
78149>>>>>>>>>>>
78149>>>>>>>>>>>    Function psServer Returns String
78151>>>>>>>>>>>        tSQLConnection SQLConnection
78151>>>>>>>>>>>        tSQLConnection SQLConnection
78151>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78152>>>>>>>>>>>        Function_Return SQLConnection.sServer
78153>>>>>>>>>>>    End_Function
78154>>>>>>>>>>>
78154>>>>>>>>>>>    Procedure Set psDatabase String sValue
78156>>>>>>>>>>>        tSQLConnection SQLConnection
78156>>>>>>>>>>>        tSQLConnection SQLConnection
78156>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78157>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78158>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78159>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78160>>>>>>>>>>>    End_Procedure
78161>>>>>>>>>>>
78161>>>>>>>>>>>    Function psDatabase Returns String
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78164>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78165>>>>>>>>>>>    End_Function
78166>>>>>>>>>>>
78166>>>>>>>>>>>    Procedure Set psUserID String sValue
78168>>>>>>>>>>>        tSQLConnection SQLConnection
78168>>>>>>>>>>>        tSQLConnection SQLConnection
78168>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78169>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78170>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78171>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78172>>>>>>>>>>>    End_Procedure
78173>>>>>>>>>>>
78173>>>>>>>>>>>    Function psUserID Returns String
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78176>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78177>>>>>>>>>>>    End_Function
78178>>>>>>>>>>>
78178>>>>>>>>>>>    // This is the uncrypted password
78178>>>>>>>>>>>    Procedure Set psPassword String sValue
78180>>>>>>>>>>>        tSQLConnection SQLConnection
78180>>>>>>>>>>>        tSQLConnection SQLConnection
78180>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78181>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78182>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78183>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78184>>>>>>>>>>>    End_Procedure
78185>>>>>>>>>>>
78185>>>>>>>>>>>    Function psPassword Returns String
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78188>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78189>>>>>>>>>>>    End_Function
78190>>>>>>>>>>>
78190>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78192>>>>>>>>>>>        tSQLConnection SQLConnection
78192>>>>>>>>>>>        tSQLConnection SQLConnection
78192>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78193>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78194>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78195>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78196>>>>>>>>>>>    End_Procedure
78197>>>>>>>>>>>
78197>>>>>>>>>>>    Function pbTrusted Returns Boolean
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78200>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78201>>>>>>>>>>>    End_Function
78202>>>>>>>>>>>
78202>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78202>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78202>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78202>>>>>>>>>>>    //     the central pSQLConnection "hub".
78202>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78204>>>>>>>>>>>        tSQLConnection SQLConnection
78204>>>>>>>>>>>        tSQLConnection SQLConnection
78204>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78205>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78206>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78207>>>>>>>>>>>    End_Procedure
78208>>>>>>>>>>>
78208>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78210>>>>>>>>>>>        tSQLConnection SQLConnection
78210>>>>>>>>>>>        tSQLConnection SQLConnection
78210>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78211>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78212>>>>>>>>>>>    End_Function
78213>>>>>>>>>>>
78213>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78215>>>>>>>>>>>        tSQLConnection SQLConnection
78215>>>>>>>>>>>        tSQLConnection SQLConnection
78215>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78216>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78217>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78218>>>>>>>>>>>    End_Procedure
78219>>>>>>>>>>>
78219>>>>>>>>>>>    Function piDbType Returns Integer
78221>>>>>>>>>>>        tSQLConnection SQLConnection
78221>>>>>>>>>>>        tSQLConnection SQLConnection
78221>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78222>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78223>>>>>>>>>>>    End_Function
78224>>>>>>>>>>>
78224>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78226>>>>>>>>>>>        tSQLConnection SQLConnection
78226>>>>>>>>>>>        tSQLConnection SQLConnection
78226>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78227>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78228>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78229>>>>>>>>>>>    End_Procedure
78230>>>>>>>>>>>
78230>>>>>>>>>>>    Function psBaseTableSpace Returns String
78232>>>>>>>>>>>        tSQLConnection SQLConnection
78232>>>>>>>>>>>        tSQLConnection SQLConnection
78232>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78233>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78234>>>>>>>>>>>    End_Function
78235>>>>>>>>>>>
78235>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78237>>>>>>>>>>>        tSQLConnection SQLConnection
78237>>>>>>>>>>>        tSQLConnection SQLConnection
78237>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78238>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78239>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78240>>>>>>>>>>>    End_Procedure
78241>>>>>>>>>>>
78241>>>>>>>>>>>    Function psIndexTableSpace Returns String
78243>>>>>>>>>>>        tSQLConnection SQLConnection
78243>>>>>>>>>>>        tSQLConnection SQLConnection
78243>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78244>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78245>>>>>>>>>>>    End_Function
78246>>>>>>>>>>>
78246>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78248>>>>>>>>>>>        tSQLConnection SQLConnection
78248>>>>>>>>>>>        tSQLConnection SQLConnection
78248>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78249>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78250>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78251>>>>>>>>>>>    End_Procedure
78252>>>>>>>>>>>
78252>>>>>>>>>>>    Function psLongTableSpace Returns String
78254>>>>>>>>>>>        tSQLConnection SQLConnection
78254>>>>>>>>>>>        tSQLConnection SQLConnection
78254>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78255>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78256>>>>>>>>>>>    End_Function
78257>>>>>>>>>>>
78257>>>>>>>>>>>    Procedure Set psSchema String sValue
78259>>>>>>>>>>>        tSQLConnection SQLConnection
78259>>>>>>>>>>>        tSQLConnection SQLConnection
78259>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78260>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78261>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78262>>>>>>>>>>>    End_Procedure
78263>>>>>>>>>>>
78263>>>>>>>>>>>    Function psSchema Returns String
78265>>>>>>>>>>>        tSQLConnection SQLConnection
78265>>>>>>>>>>>        tSQLConnection SQLConnection
78265>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78266>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78267>>>>>>>>>>>    End_Function
78268>>>>>>>>>>>
78268>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78270>>>>>>>>>>>        tSQLConnection SQLConnection
78270>>>>>>>>>>>        tSQLConnection SQLConnection
78270>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78271>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78272>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78273>>>>>>>>>>>    End_Procedure
78274>>>>>>>>>>>
78274>>>>>>>>>>>    Function pbEnabled Returns Boolean
78276>>>>>>>>>>>        tSQLConnection SQLConnection
78276>>>>>>>>>>>        tSQLConnection SQLConnection
78276>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78277>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78278>>>>>>>>>>>    End_Function
78279>>>>>>>>>>>
78279>>>>>>>>>>>
78279>>>>>>>>>>>    // ************************************
78279>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78281>>>>>>>>>>>        tSQLConnection SQLConnection
78281>>>>>>>>>>>        tSQLConnection SQLConnection
78281>>>>>>>>>>>
78281>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78281>>>>>>>>>>>        // deferr reading SQL connection values until later.
78281>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78283>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78283>>>>>>>>>>>            If (ghoConnection > 0) Begin
78285>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78286>>>>>>>>>>>            End
78286>>>>>>>>>>>>
78286>>>>>>>>>>>
78286>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78286>>>>>>>>>>>            // object is used.
78286>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78288>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78289>>>>>>>>>>>            End
78289>>>>>>>>>>>>
78289>>>>>>>>>>>        End
78289>>>>>>>>>>>>
78289>>>>>>>>>>>
78289>>>>>>>>>>>        Function_Return SQLConnection
78290>>>>>>>>>>>    End_Function
78291>>>>>>>>>>>
78291>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78291>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78293>>>>>>>>>>>        tConnection Connection
78293>>>>>>>>>>>        tConnection Connection
78293>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78293>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78293>>>>>>>>>>>        Integer iRetval iDbType
78293>>>>>>>>>>>        Boolean bOK bConnected
78293>>>>>>>>>>>        String sConnectionID
78293>>>>>>>>>>>
78293>>>>>>>>>>>            tConnection[] Connections
78293>>>>>>>>>>>            tConnection[] Connections
78294>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78294>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78294>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78294>>>>>>>>>>>            //   we then generate an error and abort the program...
78294>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78295>>>>>>>>>>>            If (bOK = False) Begin
78297>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78298>>>>>>>>>>>>
78298>>>>>>>>>>>                Abort
78299>>>>>>>>>>>>
78299>>>>>>>>>>>            End
78299>>>>>>>>>>>>
78299>>>>>>>>>>>            If (sConnectionID = "") Begin
78301>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78302>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78304>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78305>>>>>>>>>>>                End
78305>>>>>>>>>>>>
78305>>>>>>>>>>>            End
78305>>>>>>>>>>>>
78305>>>>>>>>>>>
78305>>>>>>>>>>>            Move 0 to iRetval
78306>>>>>>>>>>>            // DAW DF19 connection info:
78306>>>>>>>>>>>            // We first check that the connection is OK:
78306>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78307>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78307>>>>>>>>>>>            If (iRetval = -1) Begin
78309>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78310>>>>>>>>>>>            End
78310>>>>>>>>>>>>
78310>>>>>>>>>>>
78310>>>>>>>>>>>            If (sConnectionID <> "") Begin
78312>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78313>>>>>>>>>>>            End
78313>>>>>>>>>>>>
78313>>>>>>>>>>>            If (Connection.sId = "") Begin
78315>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78316>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78317>>>>>>>>>>>            End
78317>>>>>>>>>>>>
78317>>>>>>>>>>>
78317>>>>>>>>>>>            // DUF connection info struct property:
78317>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78318>>>>>>>>>>>
78318>>>>>>>>>>>            Move Connection.sId to sConnectionID
78319>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78320>>>>>>>>>>>
78320>>>>>>>>>>>            If (bConnected = False) Begin
78322>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78323>>>>>>>>>>>                If (iRetval <> 0) Begin
78325>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78326>>>>>>>>>>>                    Send Exit_Application
78327>>>>>>>>>>>                End
78327>>>>>>>>>>>>
78327>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78328>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78328>>>>>>>>>>>                // been changed in the DAW db login dialog.
78328>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78329>>>>>>>>>>>            End
78329>>>>>>>>>>>>
78329>>>>>>>>>>>
78329>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78330>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78331>>>>>>>>>>>
78331>>>>>>>>>>>            // Not used in DUF:
78331>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78331>>>>>>>>>>>
78331>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78332>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78333>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78334>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78335>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78336>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78337>>>>>>>>>>>
78337>>>>>>>>>>>            // Not used in DUF:
78337>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78337>>>>>>>>>>>
78337>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78337>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78337>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78339>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78340>>>>>>>>>>>            End
78340>>>>>>>>>>>>
78340>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78342>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78343>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78345>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78346>>>>>>>>>>>                End
78346>>>>>>>>>>>>
78346>>>>>>>>>>>            End
78346>>>>>>>>>>>>
78346>>>>>>>>>>>
78346>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78347>>>>>>>>>>>
78347>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78347>>>>>>>>>>>            // the value from the driver id:
78347>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78348>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78350>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78350>>>>>>>>>>>            Get piDbType                                     to iDbType
78351>>>>>>>>>>>            End
78351>>>>>>>>>>>>
78351>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78353>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78354>>>>>>>>>>>            End
78354>>>>>>>>>>>>
78354>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78355>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78356>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78357>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78358>>>>>>>>>>>
78358>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78358>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78359>>>>>>>>>>>
78359>>>>>>>>>>>        Function_Return SQLConnection
78360>>>>>>>>>>>    End_Function
78361>>>>>>>>>>>
78361>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78361>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78361>>>>>>>>>>>    // connection id for a particular driver.
78361>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78361>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78361>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78361>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78361>>>>>>>>>>>    // connections of the DAW cConnect class.
78361>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78363>>>>>>>>>>>        tConnection[] ConnIdArray
78363>>>>>>>>>>>        tConnection[] ConnIdArray
78364>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78364>>>>>>>>>>>        Boolean bEnabled bFound
78364>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78364>>>>>>>>>>>
78364>>>>>>>>>>>        Move False to bFound
78365>>>>>>>>>>>        If (ghoConnection > 0) Begin
78367>>>>>>>>>>>
78367>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78367>>>>>>>>>>>            Get psDriverID to sDriverID
78368>>>>>>>>>>>
78368>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78369>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78369>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78370>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78371>>>>>>>>>>>            Decrement iSize
78372>>>>>>>>>>>            For iCount from 0 to iSize
78378>>>>>>>>>>>>
78378>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78379>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78380>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78381>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78381>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78381>>>>>>>>>>>                If (sConnectionID = "") Begin
78383>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78384>>>>>>>>>>>                End
78384>>>>>>>>>>>>
78384>>>>>>>>>>>                Else Begin
78385>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78387>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78388>>>>>>>>>>>                    End
78388>>>>>>>>>>>>
78388>>>>>>>>>>>                End
78388>>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>                If (bFound = True) Begin
78390>>>>>>>>>>>                    Increment iConnectionIDCounter
78391>>>>>>>>>>>                End
78391>>>>>>>>>>>>
78391>>>>>>>>>>>            Loop
78392>>>>>>>>>>>>
78392>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78393>>>>>>>>>>>            If (bFound = True) Begin
78395>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78396>>>>>>>>>>>            End
78396>>>>>>>>>>>>
78396>>>>>>>>>>>        End
78396>>>>>>>>>>>>
78396>>>>>>>>>>>
78396>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78396>>>>>>>>>>>        // but no DFConn.ini record has been created.
78396>>>>>>>>>>>        If (iSize = -1) Begin
78398>>>>>>>>>>>            Move True to bFound
78399>>>>>>>>>>>        End
78399>>>>>>>>>>>>
78399>>>>>>>>>>>
78399>>>>>>>>>>>        Function_Return bFound
78400>>>>>>>>>>>    End_Function
78401>>>>>>>>>>>
78401>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78401>>>>>>>>>>>    // create a connection to the server.
78401>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78403>>>>>>>>>>>        String sPath sFileName
78403>>>>>>>>>>>        Boolean bExists bActive
78403>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78403>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78404>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78404>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78404>>>>>>>>>>>        Handle hoIniFile
78404>>>>>>>>>>>        Integer iSize iCount iRetval
78404>>>>>>>>>>>
78404>>>>>>>>>>>        Get psIniFilePath to sPath
78405>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78406>>>>>>>>>>>        If (sPath = "") Begin
78408>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78409>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78410>>>>>>>>>>>        End
78410>>>>>>>>>>>>
78410>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78411>>>>>>>>>>>        Get psIniFileName to sFileName
78412>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78413>>>>>>>>>>>
78413>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78414>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78415>>>>>>>>>>>        If (iSize = 0) Begin
78417>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78417>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78417>>>>>>>>>>>            // in the cApplication object.
78417>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78418>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78420>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78421>>>>>>>>>>>            End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78422>>>>>>>>>>>            Move 1 to iSize
78423>>>>>>>>>>>        End
78423>>>>>>>>>>>>
78423>>>>>>>>>>>
78423>>>>>>>>>>>        Move False to bActive
78424>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78424>>>>>>>>>>>        Decrement iSize
78425>>>>>>>>>>>        For iCount from 0 to iSize
78431>>>>>>>>>>>>
78431>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78432>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78434>>>>>>>>>>>                Move True to bActive
78435>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78436>>>>>>>>>>>            End
78436>>>>>>>>>>>>
78436>>>>>>>>>>>        Loop
78437>>>>>>>>>>>>
78437>>>>>>>>>>>
78437>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78437>>>>>>>>>>>        If (bActive = False) Begin
78439>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78440>>>>>>>>>>>        End
78440>>>>>>>>>>>>
78440>>>>>>>>>>>
78440>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78441>>>>>>>>>>>
78441>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78442>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78443>>>>>>>>>>>
78443>>>>>>>>>>>        Function_Return SQLConnection
78444>>>>>>>>>>>    End_Function
78445>>>>>>>>>>>
78445>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78447>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78448>>>>>>>>>>>    End_Procedure
78449>>>>>>>>>>>
78449>>>>>>>>>>>    Function psIniFilePath Returns String
78451>>>>>>>>>>>        String sRetval
78451>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78452>>>>>>>>>>>        Function_Return sRetval
78453>>>>>>>>>>>    End_Function
78454>>>>>>>>>>>
78454>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78456>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78457>>>>>>>>>>>    End_Procedure
78458>>>>>>>>>>>
78458>>>>>>>>>>>    Function psIniFileName Returns String
78460>>>>>>>>>>>        String sRetval
78460>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78461>>>>>>>>>>>        Function_Return sRetval
78462>>>>>>>>>>>    End_Function
78463>>>>>>>>>>>
78463>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78465>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78466>>>>>>>>>>>    End_Procedure
78467>>>>>>>>>>>
78467>>>>>>>>>>>    Function psIniSectionName Returns String
78469>>>>>>>>>>>        String sRetval
78469>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78470>>>>>>>>>>>        Function_Return sRetval
78471>>>>>>>>>>>    End_Function
78472>>>>>>>>>>>
78472>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78474>>>>>>>>>>>        Handle ho
78474>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78475>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78476>>>>>>>>>>>    End_Procedure
78477>>>>>>>>>>>
78477>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78479>>>>>>>>>>>        Handle ho
78479>>>>>>>>>>>        String sRetval
78479>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78480>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78481>>>>>>>>>>>        Function_Return sRetval
78482>>>>>>>>>>>    End_Function
78483>>>>>>>>>>>
78483>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78485>>>>>>>>>>>        Handle ho
78485>>>>>>>>>>>        Boolean bRetval
78485>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78486>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78487>>>>>>>>>>>        Function_Return bRetval
78488>>>>>>>>>>>    End_Function
78489>>>>>>>>>>>
78489>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78491>>>>>>>>>>>        Handle ho
78491>>>>>>>>>>>        Boolean bRetval
78491>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78492>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78493>>>>>>>>>>>        Function_Return bRetval
78494>>>>>>>>>>>    End_Function
78495>>>>>>>>>>>
78495>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78497>>>>>>>>>>>        Handle ho
78497>>>>>>>>>>>        String sRetval
78497>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78498>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78499>>>>>>>>>>>        Function_Return sRetval
78500>>>>>>>>>>>    End_Function
78501>>>>>>>>>>>
78501>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78503>>>>>>>>>>>        Handle ho
78503>>>>>>>>>>>        String sRetval
78503>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78504>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78505>>>>>>>>>>>        Function_Return sRetval
78506>>>>>>>>>>>    End_Function
78507>>>>>>>>>>>
78507>>>>>>>>>>>    // *** Main Connection Message ***
78507>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78509>>>>>>>>>>>        Handle hoDriver
78509>>>>>>>>>>>        String sConnectionString sError
78509>>>>>>>>>>>        Boolean bLoginSuccessful
78509>>>>>>>>>>>
78509>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78510>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78511>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78512>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78513>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78515>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78516>>>>>>>>>>>>
78516>>>>>>>>>>>            If (bExitProgram = True) Begin
78518>>>>>>>>>>>                Send Exit_Application
78519>>>>>>>>>>>            End
78519>>>>>>>>>>>>
78519>>>>>>>>>>>        End
78519>>>>>>>>>>>>
78519>>>>>>>>>>>        Send Destroy of hoDriver
78520>>>>>>>>>>>    End_Procedure
78521>>>>>>>>>>>
78521>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78523>>>>>>>>>>>        Integer iRetval
78523>>>>>>>>>>>        Handle hoCLI
78523>>>>>>>>>>>        String sDriverID
78523>>>>>>>>>>>
78523>>>>>>>>>>>        Get psDriverID to sDriverID
78524>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78525>>>>>>>>>>>        If (hoCLI <> 0) Begin
78527>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78528>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78529>>>>>>>>>>>            Send Destroy of hoCLI
78530>>>>>>>>>>>        End
78530>>>>>>>>>>>>
78530>>>>>>>>>>>
78530>>>>>>>>>>>        Function_Return iRetval
78531>>>>>>>>>>>    End_Function
78532>>>>>>>>>>>
78532>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78534>>>>>>>>>>>        tSQLConnection SQLConnection
78534>>>>>>>>>>>        tSQLConnection SQLConnection
78534>>>>>>>>>>>
78534>>>>>>>>>>>        Set psDriverID to sDriverID
78535>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78536>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78537>>>>>>>>>>>    End_Procedure
78538>>>>>>>>>>>
78538>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78538>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78538>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78538>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78538>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78538>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78538>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78538>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78540>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78540>>>>>>>>>>>        Handle hoCLI
78540>>>>>>>>>>>        String sID
78540>>>>>>>>>>>
78540>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78542>>>>>>>>>>>            Procedure_Return
78543>>>>>>>>>>>        End
78543>>>>>>>>>>>>
78543>>>>>>>>>>>
78543>>>>>>>>>>>        Move 0 to iResult
78544>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78545>>>>>>>>>>>        If (hoCLI <> 0) Begin
78547>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78548>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78549>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78552>>>>>>>>>>>            Decrement iNumConn
78553>>>>>>>>>>>            For iConn from 0 to iNumConn
78559>>>>>>>>>>>>
78559>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78562>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78564>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78565>>>>>>>>>>>                End
78565>>>>>>>>>>>>
78565>>>>>>>>>>>            Loop
78566>>>>>>>>>>>>
78566>>>>>>>>>>>            Send Destroy of hoCLI
78567>>>>>>>>>>>        End
78567>>>>>>>>>>>>
78567>>>>>>>>>>>
78567>>>>>>>>>>>    End_Procedure
78568>>>>>>>>>>>
78568>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78570>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78570>>>>>>>>>>>        Handle hoCLI
78570>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78570>>>>>>>>>>>        tSQLConnection SQLConnection
78570>>>>>>>>>>>        tSQLConnection SQLConnection
78570>>>>>>>>>>>        Boolean bTrusted
78570>>>>>>>>>>>
78570>>>>>>>>>>>        Move 0 to iResult
78571>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78572>>>>>>>>>>>        If (hoCLI <> 0) Begin
78574>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78575>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78576>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78579>>>>>>>>>>>            Decrement iNumConn
78580>>>>>>>>>>>            For iConn from 0 to iNumConn
78586>>>>>>>>>>>>
78586>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78589>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78591>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78592>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78595>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78598>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78599>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78602>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78603>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78604>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78605>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78606>>>>>>>>>>>
78606>>>>>>>>>>>                    Case Begin
78606>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78608>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78609>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78610>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78611>>>>>>>>>>>                            Case Break
78612>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78615>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78616>>>>>>>>>>>                            Case Break
78617>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78620>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78621>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78623>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78624>>>>>>>>>>>                            End
78624>>>>>>>>>>>>
78624>>>>>>>>>>>                            Case Break
78625>>>>>>>>>>>                        Case Else
78625>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78626>>>>>>>>>>>>
78626>>>>>>>>>>>                            Case Break
78627>>>>>>>>>>>                    Case End
78627>>>>>>>>>>>                End
78627>>>>>>>>>>>>
78627>>>>>>>>>>>            Loop
78628>>>>>>>>>>>>
78628>>>>>>>>>>>            Send Destroy of hoCLI
78629>>>>>>>>>>>        End
78629>>>>>>>>>>>>
78629>>>>>>>>>>>
78629>>>>>>>>>>>        Function_Return SQLConnection
78630>>>>>>>>>>>    End_Function
78631>>>>>>>>>>>
78631>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78633>>>>>>>>>>>        String  sCurrentDriver
78633>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78633>>>>>>>>>>>
78633>>>>>>>>>>>        Move 0 to iDriver
78634>>>>>>>>>>>        Move 0 to iCount
78635>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78638>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78644>>>>>>>>>>>>
78644>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78647>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78649>>>>>>>>>>>                Function_Return iCount
78650>>>>>>>>>>>            End
78650>>>>>>>>>>>>
78650>>>>>>>>>>>        Loop
78651>>>>>>>>>>>>
78651>>>>>>>>>>>
78651>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78651>>>>>>>>>>>        If (iDriver = 0) Begin
78653>>>>>>>>>>>            Move 0 to LastErr
78654>>>>>>>>>>>            Load_Driver sDriverID
78655>>>>>>>>>>>            // If driver could not be loaded.
78655>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78657>>>>>>>>>>>                Move -1 to iCount
78658>>>>>>>>>>>            End
78658>>>>>>>>>>>>
78658>>>>>>>>>>>        End
78658>>>>>>>>>>>>
78658>>>>>>>>>>>        Function_Return iCount
78659>>>>>>>>>>>    End_Function
78660>>>>>>>>>>>
78660>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78660>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78662>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78662>>>>>>>>>>>        Boolean bTrusted bSilent
78662>>>>>>>>>>>        Integer iRetval
78662>>>>>>>>>>>
78662>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78663>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78664>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78665>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78666>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78667>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78668>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78669>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78670>>>>>>>>>>>
78670>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78671>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78671>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78672>>>>>>>>>>>    End_Procedure
78673>>>>>>>>>>>
78673>>>>>>>>>>>    // Called when the object is constructed.
78673>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78673>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78673>>>>>>>>>>>    // the database is needed.
78673>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78675>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78675>>>>>>>>>>>        Integer iDriver iRetval
78675>>>>>>>>>>>        Handle hoCLI
78675>>>>>>>>>>>        Boolean bOK bSilent
78675>>>>>>>>>>>
78675>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78676>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78677>>>>>>>>>>>        Get psConnectionString to sConnectionString
78678>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78678>>>>>>>>>>>        Get psDriverID to sDriverID
78679>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78680>>>>>>>>>>>        If (bOK = False) Begin
78682>>>>>>>>>>>            Function_Return False
78683>>>>>>>>>>>        End
78683>>>>>>>>>>>>
78683>>>>>>>>>>>
78683>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78684>>>>>>>>>>>        // If driver not loaded; load it.
78684>>>>>>>>>>>        If (iDriver = 0) Begin
78686>>>>>>>>>>>            Load_Driver sDriverID
78687>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78688>>>>>>>>>>>        End
78688>>>>>>>>>>>>
78688>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78688>>>>>>>>>>>        If (iDriver = 0) Begin
78690>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78691>>>>>>>>>>>>
78691>>>>>>>>>>>            Function_Return False
78692>>>>>>>>>>>        End           
78692>>>>>>>>>>>>
78692>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78695>>>>>>>>>>>        
78695>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78696>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78697>>>>>>>>>>>        // Delete the connection first; in case it exists
78697>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78698>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78699>>>>>>>>>>>        Send Destroy of hoCLI
78700>>>>>>>>>>>
78700>>>>>>>>>>>        Function_Return (iRetval = 0)
78701>>>>>>>>>>>    End_Function
78702>>>>>>>>>>>
78702>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78704>>>>>>>>>>>        Boolean bOK
78704>>>>>>>>>>>
78704>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78705>>>>>>>>>>>
78705>>>>>>>>>>>        If (bOK = False) Begin
78707>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78708>>>>>>>>>>>>
78708>>>>>>>>>>>            Function_Return False
78709>>>>>>>>>>>        End
78709>>>>>>>>>>>>
78709>>>>>>>>>>>
78709>>>>>>>>>>>        Function_Return True
78710>>>>>>>>>>>    End_Function
78711>>>>>>>>>>>
78711>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78713>>>>>>>>>>>        Boolean bOK
78713>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78714>>>>>>>>>>>        Function_Return bOK
78715>>>>>>>>>>>    End_Function
78716>>>>>>>>>>>
78716>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78718>>>>>>>>>>>        Handle hoIniFile
78718>>>>>>>>>>>        String sConnect
78718>>>>>>>>>>>
78718>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78719>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78720>>>>>>>>>>>
78720>>>>>>>>>>>        Function_Return sConnect
78721>>>>>>>>>>>    End_Function
78722>>>>>>>>>>>
78722>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78722>>>>>>>>>>>    // Pass a complete driver connection string
78722>>>>>>>>>>>    // Returns the following as a struct:
78722>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78722>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78722>>>>>>>>>>>    //
78722>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78724>>>>>>>>>>>        tSQLConnection SQLConnection
78724>>>>>>>>>>>        tSQLConnection SQLConnection
78724>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78724>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78724>>>>>>>>>>>        Integer iPos
78724>>>>>>>>>>>
78724>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78725>>>>>>>>>>>        If (bOK = False) Begin
78727>>>>>>>>>>>            Function_Return SQLConnection
78728>>>>>>>>>>>        End
78728>>>>>>>>>>>>
78728>>>>>>>>>>>
78728>>>>>>>>>>>        Move False to bTrusted
78729>>>>>>>>>>>        Move False to bSilent
78730>>>>>>>>>>>
78730>>>>>>>>>>>        Case Begin
78730>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78732>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78733>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78734>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78735>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78736>>>>>>>>>>>                If (bTrusted = False) Begin
78738>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78739>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78740>>>>>>>>>>>                End
78740>>>>>>>>>>>>
78740>>>>>>>>>>>                Case Break
78741>>>>>>>>>>>
78741>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78744>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78746>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78747>>>>>>>>>>>                End
78747>>>>>>>>>>>>
78747>>>>>>>>>>>                Else Begin
78748>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78749>>>>>>>>>>>                End
78749>>>>>>>>>>>>
78749>>>>>>>>>>>
78749>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78750>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78751>>>>>>>>>>>                If (bTrusted = False) Begin
78753>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78754>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78755>>>>>>>>>>>                End
78755>>>>>>>>>>>>
78755>>>>>>>>>>>                Case Break
78756>>>>>>>>>>>
78756>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78759>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78760>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78761>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78762>>>>>>>>>>>                Case Break
78763>>>>>>>>>>>
78763>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78766>>>>>>>>>>>                Break
78767>>>>>>>>>>>        Case End
78767>>>>>>>>>>>
78767>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78768>>>>>>>>>>>
78768>>>>>>>>>>>        // bSilent?
78768>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78769>>>>>>>>>>>        If (iPos = 0) Begin
78771>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78772>>>>>>>>>>>        End
78772>>>>>>>>>>>>
78772>>>>>>>>>>>        If (iPos = 0) Begin
78774>>>>>>>>>>>            Move "0"                                                            to sValue
78775>>>>>>>>>>>        End
78775>>>>>>>>>>>>
78775>>>>>>>>>>>        Else Begin
78776>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78777>>>>>>>>>>>        End
78777>>>>>>>>>>>>
78777>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78778>>>>>>>>>>>
78778>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78779>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78780>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78781>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78782>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78783>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78784>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78785>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78786>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78787>>>>>>>>>>>
78787>>>>>>>>>>>        Function_Return SQLConnection
78788>>>>>>>>>>>    End_Function
78789>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78789>>>>>>>>>>>>
78789>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78791>>>>>>>>>>>>    Integer iStart iEnd
78791>>>>>>>>>>>>    String sRetval
78791>>>>>>>>>>>>
78791>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78792>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78793>>>>>>>>>>>>    If (iStart = 0) Begin
78795>>>>>>>>>>>>        Function_Return ""
78796>>>>>>>>>>>>    End
78796>>>>>>>>>>>>>
78796>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78797>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78798>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78800>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78801>>>>>>>>>>>>    End
78801>>>>>>>>>>>>>
78801>>>>>>>>>>>>    Else Begin
78802>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78803>>>>>>>>>>>>    End
78803>>>>>>>>>>>>>
78803>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78805>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78806>>>>>>>>>>>>        Decrement iEnd
78807>>>>>>>>>>>>    End
78807>>>>>>>>>>>>>
78807>>>>>>>>>>>>    If (iEnd <> 0) Begin
78809>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78810>>>>>>>>>>>>    End
78810>>>>>>>>>>>>>
78810>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78811>>>>>>>>>>>>
78811>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78812>>>>>>>>>>>>End_Function
78813>>>>>>>>>>>>
78813>>>>>>>>>>>>
78813>>>>>>>>>>>
78813>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78813>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78815>>>>>>>>>>>        Handle ho
78815>>>>>>>>>>>        Integer iIndex
78815>>>>>>>>>>>        Boolean bRetval bOK
78815>>>>>>>>>>>        tSQLConnection SQLConnection
78815>>>>>>>>>>>        tSQLConnection SQLConnection
78815>>>>>>>>>>>
78815>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78816>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78817>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78818>>>>>>>>>>>        If (iIndex = -1) Begin
78820>>>>>>>>>>>            Function_Return False
78821>>>>>>>>>>>        End
78821>>>>>>>>>>>>
78821>>>>>>>>>>>
78821>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78822>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78823>>>>>>>>>>>        If (ghoConnection > 0) Begin
78825>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78826>>>>>>>>>>>            If (iIndex <> -1) Begin
78828>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78829>>>>>>>>>>>            End
78829>>>>>>>>>>>>
78829>>>>>>>>>>>        End
78829>>>>>>>>>>>>
78829>>>>>>>>>>>
78829>>>>>>>>>>>        Function_Return bRetval
78830>>>>>>>>>>>    End_Function
78831>>>>>>>>>>>
78831>>>>>>>>>>>End_Class
78832>>>>>>>>>Use vWin32fh.pkg
78832>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78832>>>>>>>>>>>Use LanguageText.pkg
78832>>>>>>>>>>>Use Windows.pkg
78832>>>>>>>>>>>Use Dfclient.pkg
78832>>>>>>>>>>>Use DFbitmap.pkg
78832>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78832>>>>>>>>>>>Use cRichEdit.pkg
78832>>>>>>>>>>>Use cTextEdit.pkg
78832>>>>>>>>>>>Use cRichEdit.pkg
78832>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78832>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78832>>>>>>>>>>>>>>>Use VDFBase.pkg
78832>>>>>>>>>>>>>>>
78832>>>>>>>>>>>>>>>Class cFormatter is an cObject
78833>>>>>>>>>>>>>>>    
78833>>>>>>>>>>>>>>>    Procedure Construct_object
78835>>>>>>>>>>>>>>>        Integer iCh
78835>>>>>>>>>>>>>>>        Forward Send construct_object
78837>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78838>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78839>>>>>>>>>>>>>>>        
78839>>>>>>>>>>>>>>>        Property String  psLeft
78840>>>>>>>>>>>>>>>        Property String  psright
78841>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78842>>>>>>>>>>>>>>>        Property Integer piPoints
78843>>>>>>>>>>>>>>>        
78843>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78844>>>>>>>>>>>>>>>        Property String  psCurPosright
78845>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78846>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78847>>>>>>>>>>>>>>>        
78847>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78848>>>>>>>>>>>>>>>        Property String  psCurNegright
78849>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78850>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78851>>>>>>>>>>>>>>>        
78851>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78852>>>>>>>>>>>>>>>        Property String  psNumPosright
78853>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78854>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78855>>>>>>>>>>>>>>>        
78855>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78856>>>>>>>>>>>>>>>        Property String  psNumNegright
78857>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78858>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78859>>>>>>>>>>>>>>>        
78859>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78860>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78861>>>>>>>>>>>>>>>        
78861>>>>>>>>>>>>>>>    End_Procedure
78862>>>>>>>>>>>>>>>    
78862>>>>>>>>>>>>>>>    // internal
78862>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78862>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78864>>>>>>>>>>>>>>>        
78864>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78864>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78864>>>>>>>>>>>>>>>        
78864>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78864>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78864>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78865>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78866>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78867>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78868>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78869>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78870>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78871>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78872>>>>>>>>>>>>>>>        
78872>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78873>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78876>>>>>>>>>>>>>>>        
78876>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78877>>>>>>>>>>>>>>>        
78877>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78878>>>>>>>>>>>>>>>        
78878>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78878>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78879>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78880>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78881>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78882>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78883>>>>>>>>>>>>>>>        
78883>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78885>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78886>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78888>>>>>>>>>>>>>>>                Move -2 to iDigits
78889>>>>>>>>>>>>>>>                Increment i
78890>>>>>>>>>>>>>>>            End
78890>>>>>>>>>>>>>>>>
78890>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78894>>>>>>>>>>>>>>>                Increment i
78895>>>>>>>>>>>>>>>            Loop
78896>>>>>>>>>>>>>>>>
78896>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78897>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78900>>>>>>>>>>>>>>>            //
78900>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78901>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78905>>>>>>>>>>>>>>>                Increment i
78906>>>>>>>>>>>>>>>            Loop
78907>>>>>>>>>>>>>>>>
78907>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78908>>>>>>>>>>>>>>>        End
78908>>>>>>>>>>>>>>>>
78908>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78909>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78910>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78911>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78913>>>>>>>>>>>>>>>                Move sFmt to sLeft
78914>>>>>>>>>>>>>>>                Move ""   to sRight
78915>>>>>>>>>>>>>>>            End
78915>>>>>>>>>>>>>>>>
78915>>>>>>>>>>>>>>>            Else Begin
78916>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78917>>>>>>>>>>>>>>>                Move 1 to i
78918>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78922>>>>>>>>>>>>>>>                    Increment i
78923>>>>>>>>>>>>>>>                Loop
78924>>>>>>>>>>>>>>>>
78924>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78925>>>>>>>>>>>>>>>            End
78925>>>>>>>>>>>>>>>>
78925>>>>>>>>>>>>>>>        End
78925>>>>>>>>>>>>>>>>
78925>>>>>>>>>>>>>>>        // set temporary format properties and exit
78925>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78926>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78927>>>>>>>>>>>>>>>        Set psRight        to sRight
78928>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78929>>>>>>>>>>>>>>>    End_Procedure
78930>>>>>>>>>>>>>>>    
78930>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78930>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78930>>>>>>>>>>>>>>>    //
78930>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78930>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78932>>>>>>>>>>>>>>>        String sPos sNeg
78932>>>>>>>>>>>>>>>        Integer iPos
78932>>>>>>>>>>>>>>>        
78932>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78933>>>>>>>>>>>>>>>        If iPos Begin
78935>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78936>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78937>>>>>>>>>>>>>>>        End
78937>>>>>>>>>>>>>>>>
78937>>>>>>>>>>>>>>>        Else Begin
78938>>>>>>>>>>>>>>>            Move sFmt         to sPos
78939>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78940>>>>>>>>>>>>>>>        End
78940>>>>>>>>>>>>>>>>
78940>>>>>>>>>>>>>>>        Send ParseFormat sPos
78941>>>>>>>>>>>>>>>        If bCurrency Begin
78943>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78944>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78945>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78946>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78947>>>>>>>>>>>>>>>        End
78947>>>>>>>>>>>>>>>>
78947>>>>>>>>>>>>>>>        Else Begin
78948>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78949>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78950>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78951>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78952>>>>>>>>>>>>>>>        End
78952>>>>>>>>>>>>>>>>
78952>>>>>>>>>>>>>>>        
78952>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78953>>>>>>>>>>>>>>>        If bCurrency Begin
78955>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78956>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78957>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78958>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78959>>>>>>>>>>>>>>>        End
78959>>>>>>>>>>>>>>>>
78959>>>>>>>>>>>>>>>        Else Begin
78960>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78961>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78962>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78963>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78964>>>>>>>>>>>>>>>        End
78964>>>>>>>>>>>>>>>>
78964>>>>>>>>>>>>>>>    End_Procedure
78965>>>>>>>>>>>>>>>    
78965>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78965>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78967>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78967>>>>>>>>>>>>>>>        Integer iDec iLen iCh
78967>>>>>>>>>>>>>>>        
78967>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78970>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78971>>>>>>>>>>>>>>>        
78971>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78972>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78973>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78974>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78975>>>>>>>>>>>>>>>        // format for decimal separator
78975>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78978>>>>>>>>>>>>>>>        
78978>>>>>>>>>>>>>>>        // format for thousand sep.
78978>>>>>>>>>>>>>>>        If bSep Begin
78980>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78983>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78984>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78985>>>>>>>>>>>>>>>            While (iLen>3)
78989>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78990>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
78991>>>>>>>>>>>>>>>            Loop
78992>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>        End
78992>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78992>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78995>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78996>>>>>>>>>>>>>>>    End_Function
78997>>>>>>>>>>>>>>>    
78997>>>>>>>>>>>>>>>    // Public: Format for currency
78997>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78999>>>>>>>>>>>>>>>        String  sLeft sRight
78999>>>>>>>>>>>>>>>        Integer bSep
78999>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79001>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79002>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79003>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79004>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79007>>>>>>>>>>>>>>>        End
79007>>>>>>>>>>>>>>>>
79007>>>>>>>>>>>>>>>        Else Begin
79008>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79009>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79010>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79011>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79014>>>>>>>>>>>>>>>        End
79014>>>>>>>>>>>>>>>>
79014>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79015>>>>>>>>>>>>>>>    End_Function
79016>>>>>>>>>>>>>>>    
79016>>>>>>>>>>>>>>>    // Public: Format for numeric
79016>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79018>>>>>>>>>>>>>>>        String  sLeft sRight
79018>>>>>>>>>>>>>>>        Integer bSep
79018>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79020>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79021>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79022>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79023>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79026>>>>>>>>>>>>>>>        End
79026>>>>>>>>>>>>>>>>
79026>>>>>>>>>>>>>>>        Else Begin
79027>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79028>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79029>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79030>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79033>>>>>>>>>>>>>>>        End
79033>>>>>>>>>>>>>>>>
79033>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79034>>>>>>>>>>>>>>>    End_Function
79035>>>>>>>>>>>>>>>    
79035>>>>>>>>>>>>>>>    
79035>>>>>>>>>>>>>>>    // Public: Format passing format string
79035>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79037>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79037>>>>>>>>>>>>>>>        String  sLeft sRight
79037>>>>>>>>>>>>>>>        Integer iPoints bSep
79037>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79038>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79039>>>>>>>>>>>>>>>        Case Begin
79039>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79042>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79046>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79050>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79052>>>>>>>>>>>>>>>        Case End
79052>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79053>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79054>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79055>>>>>>>>>>>>>>>        Get psRight        to sRight
79056>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79057>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79058>>>>>>>>>>>>>>>    End_Function
79059>>>>>>>>>>>>>>>    
79059>>>>>>>>>>>>>>>End_Class
79060>>>>>>>>>>>>>
79060>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79060>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79061>>>>>>>>>>>>>
79061>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79063>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79064>>>>>>>>>>>>>End_Function
79065>>>>>>>>>>>>>
79065>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79067>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79068>>>>>>>>>>>>>End_Function
79069>>>>>>>>>>>>>
79069>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79071>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79072>>>>>>>>>>>>>End_Function
79073>>>>>>>>>>>>>
79073>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79075>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79076>>>>>>>>>>>>>End_Procedure
79077>>>>>>>>>>>>>
79077>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79079>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79080>>>>>>>>>>>>>End_Procedure
79081>>>>>>>>>>>>>
79081>>>>>>>>>>>>>
79081>>>>>>>>>>>Use tWinStructs.pkg
79081>>>>>>>>>>>
79081>>>>>>>>>>>Use cli.pkg
79081>>>>>>>>>>>Use DFBTRDRV.PKG
79081>>>>>>>>>>>Use MSSqldrv.pkg
79081>>>>>>>>>>>Use db2_drv.pkg
79081>>>>>>>>>>>Use odbc_drv.pkg
79081>>>>>>>>>>>Use seq_chnl.pkg
79081>>>>>>>>>>>
79081>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79081>>>>>>>>>>>Register_Function Help_filename Returns String
79081>>>>>>>>>>>Register_Function GetHelpFile Returns String
79081>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79081>>>>>>>>>>>
79081>>>>>>>>>>>// *** Constant Declarations: ***
79081>>>>>>>>>>>//
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>// System icon menu constants. If the upper left hand
79081>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79081>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79081>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79081>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79081>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79081>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79081>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79081>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79081>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79081>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79081>>>>>>>>>>>
79081>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79081>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79081>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79081>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79081>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79081>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79081>>>>>>>>>>>
79081>>>>>>>>>>>// *** Struct Declarations: ***
79081>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79081>>>>>>>>>>>    DWord   cbSize
79081>>>>>>>>>>>    Integer fMask
79081>>>>>>>>>>>    Handle  hwnd
79081>>>>>>>>>>>    Pointer lpVerb
79081>>>>>>>>>>>    Pointer lpFile
79081>>>>>>>>>>>    Pointer lpParameters
79081>>>>>>>>>>>    Pointer lpDirectory
79081>>>>>>>>>>>    Integer nShow
79081>>>>>>>>>>>    Integer iMissingAlignment1
79081>>>>>>>>>>>    Pointer hInstApp
79081>>>>>>>>>>>    Pointer lpIDList
79081>>>>>>>>>>>    Pointer lpClass
79081>>>>>>>>>>>    Handle  hkeyClass
79081>>>>>>>>>>>    DWord   dwHotKey
79081>>>>>>>>>>>    Integer iMissingAlignment2
79081>>>>>>>>>>>    Handle  hIconMonitor // Union
79081>>>>>>>>>>>    //Handle  hMonitor     // Union
79081>>>>>>>>>>>    Handle  hProcess
79081>>>>>>>>>>>End_Struct
79081>>>>>>>>>>>
79081>>>>>>>>>>>
79081>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79081>>>>>>>>>>>//Type MEMORYSTATUS
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79081>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79081>>>>>>>>>>>//End_Type
79081>>>>>>>>>>>
79081>>>>>>>>>>>// *** External Function calls: ***
79081>>>>>>>>>>>//
79081>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79082>>>>>>>>>>>
79082>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79083>>>>>>>>>>>
79083>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79083>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79084>>>>>>>>>>>
79084>>>>>>>>>>>    // Wrapper Function WNetGetUser
79084>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79086>>>>>>>>>>>
79086>>>>>>>>>>>        DWord   dwResult
79086>>>>>>>>>>>        UWide   uwName uwUserName
79086>>>>>>>>>>>        UWide   uwName uwUserName
79086>>>>>>>>>>>
79086>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79087>>>>>>>>>>>
79087>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79088>>>>>>>>>>>
79088>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79089>>>>>>>>>>>
79089>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79090>>>>>>>>>>>
79090>>>>>>>>>>>        Function_Return dwResult
79091>>>>>>>>>>>    End_Function
79092>>>>>>>>>>>
79092>>>>>>>>>>>
79092>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79093>>>>>>>>>>>
79093>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79094>>>>>>>>>>>
79094>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79095>>>>>>>>>>>
79095>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79096>>>>>>>>>>>
79096>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79097>>>>>>>>>>>
79097>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79097>>>>>>>>>>>
79097>>>>>>>>>>>Function ComputerName Desktop Returns String
79099>>>>>>>>>>>    String sName
79099>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79100>>>>>>>>>>>>
79100>>>>>>>>>>>    Function_Return sName
79101>>>>>>>>>>>End_Function
79102>>>>>>>>>>>
79102>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79104>>>>>>>>>>>    WString wName
79104>>>>>>>>>>>    Integer iRetval iLength
79104>>>>>>>>>>>
79104>>>>>>>>>>>    Move 0 to iLength
79105>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79106>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79107>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79108>>>>>>>>>>>
79108>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79110>>>>>>>>>>>        Function_Return (CString (wName))
79111>>>>>>>>>>>    End
79111>>>>>>>>>>>>
79111>>>>>>>>>>>
79111>>>>>>>>>>>    Function_Return "User Unknown"
79112>>>>>>>>>>>End_Function
79113>>>>>>>>>>>
79113>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79115>>>>>>>>>>>    String sClient sDriver sClientDriver
79115>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79115>>>>>>>>>>>    Handle hoMsqlDrv
79115>>>>>>>>>>>
79115>>>>>>>>>>>    Move 0 to iDriver
79116>>>>>>>>>>>    Move "" to sClient
79117>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79120>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79126>>>>>>>>>>>>
79126>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79129>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79131>>>>>>>>>>>            Move iCount to iDriver
79132>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79133>>>>>>>>>>>        End
79133>>>>>>>>>>>>
79133>>>>>>>>>>>    Loop
79134>>>>>>>>>>>>
79134>>>>>>>>>>>
79134>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79134>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79136>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79139>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79140>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79141>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79142>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79143>>>>>>>>>>>    End
79143>>>>>>>>>>>>
79143>>>>>>>>>>>
79143>>>>>>>>>>>    Function_Return sClient
79144>>>>>>>>>>>End_Function
79145>>>>>>>>>>>
79145>>>>>>>>>>>// *** Class Declarations: ***
79145>>>>>>>>>>>//
79145>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79146>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79148>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79149>>>>>>>>>>>    End_Procedure
79150>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79152>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79154>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79155>>>>>>>>>>>    End_Procedure
79156>>>>>>>>>>>End_Class
79157>>>>>>>>>>>
79157>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79158>>>>>>>>>>>    Procedure Construct_Object
79160>>>>>>>>>>>        Forward Send Construct_Object
79162>>>>>>>>>>>        Property Handle phoEditorHandle
79163>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79164>>>>>>>>>>>    End_Procedure
79165>>>>>>>>>>>
79165>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79167>>>>>>>>>>>        Handle hoEditor
79167>>>>>>>>>>>        Boolean bCanCopy
79167>>>>>>>>>>>        Address aEditorAddress
79167>>>>>>>>>>>
79167>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79168>>>>>>>>>>>        Send Select_All of hoEditor
79169>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79170>>>>>>>>>>>        If (bCanCopy = True) Begin
79172>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79173>>>>>>>>>>>            Send Copy   of hoEditor
79174>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79174>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79175>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79176>>>>>>>>>>>        End
79176>>>>>>>>>>>>
79176>>>>>>>>>>>    End_Procedure
79177>>>>>>>>>>>End_Class
79178>>>>>>>>>>>
79178>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79179>>>>>>>>>>>    Procedure Construct_Object
79181>>>>>>>>>>>        Forward Send Construct_Object
79183>>>>>>>>>>>
79183>>>>>>>>>>>        Set Size to 100 245
79184>>>>>>>>>>>        Set Location to 6 6
79185>>>>>>>>>>>        Set Border_Style to Border_None
79186>>>>>>>>>>>        Set Read_Only_State to True
79187>>>>>>>>>>>        Set pbWrap to True
79188>>>>>>>>>>>        Set peAnchors to anAll
79189>>>>>>>>>>>    End_Procedure
79190>>>>>>>>>>>
79190>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79190>>>>>>>>>>>
79190>>>>>>>>>>>    Procedure AppendTextLn String sText
79192>>>>>>>>>>>        String sWorkspaceWSFile
79192>>>>>>>>>>>
79192>>>>>>>>>>>        // Only works for English:
79192>>>>>>>>>>>        If (ghoApplication > 0) Begin
79194>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79196>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79197>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79198>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79199>>>>>>>>>>>            End
79199>>>>>>>>>>>>
79199>>>>>>>>>>>        End
79199>>>>>>>>>>>>
79199>>>>>>>>>>>        Send AppendText sText
79200>>>>>>>>>>>        Send AppendText (character(10))
79201>>>>>>>>>>>    End_Procedure
79202>>>>>>>>>>>
79202>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79202>>>>>>>>>>>    //    information box
79202>>>>>>>>>>>    Procedure Show_Current_Directory
79204>>>>>>>>>>>        String sDir
79204>>>>>>>>>>>
79204>>>>>>>>>>>        Get_Current_Directory To sDir
79205>>>>>>>>>>>
79205>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79206>>>>>>>>>>>    End_Procedure
79207>>>>>>>>>>>
79207>>>>>>>>>>>    Procedure Show_Windows_Directory
79209>>>>>>>>>>>        String sWindir
79209>>>>>>>>>>>
79209>>>>>>>>>>>        Get_Windows_Directory To sWindir
79210>>>>>>>>>>>
79210>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79211>>>>>>>>>>>    End_Procedure
79212>>>>>>>>>>>
79212>>>>>>>>>>>    Procedure Show_Current_User
79214>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79215>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79216>>>>>>>>>>>    End_Procedure
79217>>>>>>>>>>>
79217>>>>>>>>>>>    Procedure Show_Number_Format
79219>>>>>>>>>>>        Integer iFormat
79219>>>>>>>>>>>        String sFormatText
79219>>>>>>>>>>>
79219>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79222>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79223>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79224>>>>>>>>>>>
79224>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79227>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79228>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79229>>>>>>>>>>>    End_Procedure
79230>>>>>>>>>>>
79230>>>>>>>>>>>    Procedure Show_Filelist_Name
79232>>>>>>>>>>>        String sFilename
79232>>>>>>>>>>>
79232>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79235>>>>>>>>>>>
79235>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79236>>>>>>>>>>>    End_Procedure
79237>>>>>>>>>>>
79237>>>>>>>>>>>    Procedure Show_Lock_Delay
79239>>>>>>>>>>>        Integer iLockdelay
79239>>>>>>>>>>>
79239>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79242>>>>>>>>>>>
79242>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79243>>>>>>>>>>>    End_Procedure
79244>>>>>>>>>>>
79244>>>>>>>>>>>    Procedure Show_Lock_Timeout
79246>>>>>>>>>>>        Integer iLockTimeout
79246>>>>>>>>>>>
79246>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79249>>>>>>>>>>>
79249>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79250>>>>>>>>>>>    End_Procedure
79251>>>>>>>>>>>
79251>>>>>>>>>>>    Procedure Show_Screen_Size
79253>>>>>>>>>>>        Integer iYscreensize iXscreensize
79253>>>>>>>>>>>
79253>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79254>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79255>>>>>>>>>>>
79255>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79256>>>>>>>>>>>    End_Procedure
79257>>>>>>>>>>>
79257>>>>>>>>>>>    Procedure Show_Page_Size
79259>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79260>>>>>>>>>>>    End_procedure
79261>>>>>>>>>>>
79261>>>>>>>>>>>    Procedure Show_Date
79263>>>>>>>>>>>        Date dToday
79263>>>>>>>>>>>
79263>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79264>>>>>>>>>>>
79264>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79265>>>>>>>>>>>    End_procedure
79266>>>>>>>>>>>
79266>>>>>>>>>>>    Procedure Show_Date_Format
79268>>>>>>>>>>>        Integer iDateFormat
79268>>>>>>>>>>>        String sDateFormat
79268>>>>>>>>>>>
79268>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79271>>>>>>>>>>>        Case Begin
79271>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79273>>>>>>>>>>>                Move C_$USA To sDateFormat
79274>>>>>>>>>>>                Case Break
79275>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79278>>>>>>>>>>>                Move C_$European To sDateFormat
79279>>>>>>>>>>>                Case Break
79280>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79283>>>>>>>>>>>                Move C_$Military To sDateFormat
79284>>>>>>>>>>>                Case Break
79285>>>>>>>>>>>            Case Else
79285>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79286>>>>>>>>>>>                Case Break
79287>>>>>>>>>>>        Case End
79287>>>>>>>>>>>
79287>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79288>>>>>>>>>>>    End_Procedure
79289>>>>>>>>>>>
79289>>>>>>>>>>>    // 2013-08-14 NGS
79289>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79289>>>>>>>>>>>    Procedure Show_Systemresources
79291>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79291>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79291>>>>>>>>>>>        Integer iRetval
79291>>>>>>>>>>>        Number nValue
79291>>>>>>>>>>>        String sValue
79291>>>>>>>>>>>
79291>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79292>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79293>>>>>>>>>>>        If (iRetval = 0) Begin
79295>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79296>>>>>>>>>>>            Procedure_Return
79297>>>>>>>>>>>        End
79297>>>>>>>>>>>>
79297>>>>>>>>>>>
79297>>>>>>>>>>>        Send AppendTextLn ""
79298>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79299>>>>>>>>>>>
79299>>>>>>>>>>>        // Show memory in Gigabytes:
79299>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79300>>>>>>>>>>>        Move (Round(nValue)) to nValue
79301>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79302>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79303>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79304>>>>>>>>>>>
79304>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79304>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79305>>>>>>>>>>>        Move (Round(nValue)) to nValue
79306>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79307>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79308>>>>>>>>>>>
79308>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79308>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79309>>>>>>>>>>>        Move (Round(nValue)) to nValue
79310>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79311>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79312>>>>>>>>>>>
79312>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79312>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79313>>>>>>>>>>>        Move (Round(nValue)) to nValue
79314>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79315>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79316>>>>>>>>>>>
79316>>>>>>>>>>>        // Add an empty row after the memory information:
79316>>>>>>>>>>>        Send AppendTextLn ""
79317>>>>>>>>>>>    End_Procedure
79318>>>>>>>>>>>
79318>>>>>>>>>>>    Procedure Show_Registration
79320>>>>>>>>>>>        String sRegName
79320>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79320>>>>>>>>>>>
79320>>>>>>>>>>>        Registration sRegName iSN
79321>>>>>>>>>>>>
79321>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79322>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79323>>>>>>>>>>>
79323>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79324>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79325>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79326>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79327>>>>>>>>>>>    End_Procedure
79328>>>>>>>>>>>
79328>>>>>>>>>>>    //****************************************************************************
79328>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79328>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79328>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79328>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79328>>>>>>>>>>>    // information To be displayed
79328>>>>>>>>>>>    //****************************************************************************
79328>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79328>>>>>>>>>>>
79328>>>>>>>>>>>    Procedure Show_ServicePack
79330>>>>>>>>>>>        String sKey sVersion sDataFlex
79330>>>>>>>>>>>        Handle hoRegistry
79330>>>>>>>>>>>        Boolean bExists bOpened
79330>>>>>>>>>>>
79330>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79331>>>>>>>>>>>
79331>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79332>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79333>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79334>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79335>>>>>>>>>>>
79335>>>>>>>>>>>        If (bExists) Begin
79337>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79338>>>>>>>>>>>        End
79338>>>>>>>>>>>>
79338>>>>>>>>>>>        Else Begin
79339>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79340>>>>>>>>>>>        End
79340>>>>>>>>>>>>
79340>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79341>>>>>>>>>>>        If (bExists) Begin
79343>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79344>>>>>>>>>>>            If (bOpened) Begin
79346>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79347>>>>>>>>>>>                If (bExists) Begin
79349>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79350>>>>>>>>>>>                End
79350>>>>>>>>>>>>
79350>>>>>>>>>>>                Send CloseKey of hoRegistry
79351>>>>>>>>>>>            End
79351>>>>>>>>>>>>
79351>>>>>>>>>>>        End
79351>>>>>>>>>>>>
79351>>>>>>>>>>>        Send Destroy of hoRegistry
79352>>>>>>>>>>>
79352>>>>>>>>>>>        If (sVersion <> "") Begin
79354>>>>>>>>>>>           Send AppendTextLn sVersion
79355>>>>>>>>>>>           Send AppendTextLn ""
79356>>>>>>>>>>>        End
79356>>>>>>>>>>>>
79356>>>>>>>>>>>    End_Procedure
79357>>>>>>>>>>>
79357>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79359>>>>>>>>>>>        Integer hoWorkspace
79359>>>>>>>>>>>
79359>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79361>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79362>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79364>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79365>>>>>>>>>>>            End
79365>>>>>>>>>>>>
79365>>>>>>>>>>>        End
79365>>>>>>>>>>>>
79365>>>>>>>>>>>    End_Procedure
79366>>>>>>>>>>>
79366>>>>>>>>>>>    //****************************************************************************
79366>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79366>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79366>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79366>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79366>>>>>>>>>>>    // the information To be displayed
79366>>>>>>>>>>>    //****************************************************************************
79366>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79366>>>>>>>>>>>
79366>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79368>>>>>>>>>>>        If (ghoConnection > 0) Begin
79370>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79371>>>>>>>>>>>            Send AppendTextLn ""
79372>>>>>>>>>>>        End
79372>>>>>>>>>>>>
79372>>>>>>>>>>>    End_Procedure
79373>>>>>>>>>>>
79373>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79375>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79376>>>>>>>>>>>    End_Function
79377>>>>>>>>>>>
79377>>>>>>>>>>>    Procedure Show_Versions
79379>>>>>>>>>>>        Integer iVersion iRevision iBuild
79379>>>>>>>>>>>
79379>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79381>>>>>>>>>>>
79381>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79382>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79383>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79384>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
79385>>>>>>>>>>>    End_Procedure
79386>>>>>>>>>>>
79386>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79388>>>>>>>>>>>        Boolean bOK
79388>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79389>>>>>>>>>>>        Function_Return bOK
79390>>>>>>>>>>>    End_Function
79391>>>>>>>>>>>
79391>>>>>>>>>>>    //***
79391>>>>>>>>>>>    //*** BW
79391>>>>>>>>>>>    //*** Procedure: Show_Drivers
79391>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79391>>>>>>>>>>>    //***
79391>>>>>>>>>>>
79391>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79391>>>>>>>>>>>//    #Warning -3
79391>>>>>>>>>>>//#ENDIF
79391>>>>>>>>>>>    Procedure Show_Drivers
79393>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79393>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79393>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79393>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79393>>>>>>>>>>>
79393>>>>>>>>>>>        Move False to bStudioLicense
79394>>>>>>>>>>>
79394>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79395>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79396>>>>>>>>>>>
79396>>>>>>>>>>>        // For testing purposes:
79396>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79396>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79396>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79396>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79396>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79396>>>>>>>>>>>//
79396>>>>>>>>>>>        Move False to Err
79397>>>>>>>>>>>
79397>>>>>>>>>>>        // Loop through all loaded drivers.
79397>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79400>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79402>>>>>>>>>>>            Send AppendTextLn ""
79403>>>>>>>>>>>        End
79403>>>>>>>>>>>>
79403>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79409>>>>>>>>>>>>
79409>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79410>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79413>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79414>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79415>>>>>>>>>>>
79415>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79417>>>>>>>>>>>
79417>>>>>>>>>>>                // Pervasive/Btrieve database
79417>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79419>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79420>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79421>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79423>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79424>>>>>>>>>>>                    End
79424>>>>>>>>>>>>
79424>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79425>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79427>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79428>>>>>>>>>>>                    End
79428>>>>>>>>>>>>
79428>>>>>>>>>>>                End
79428>>>>>>>>>>>>
79428>>>>>>>>>>>
79428>>>>>>>>>>>                Else Begin
79429>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79430>>>>>>>>>>>                    Move 0 to iNumServers
79431>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79433>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79436>>>>>>>>>>>                    End
79436>>>>>>>>>>>>
79436>>>>>>>>>>>
79436>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79438>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79440>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79441>>>>>>>>>>>                        End
79441>>>>>>>>>>>>
79441>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79442>>>>>>>>>>>                    End
79442>>>>>>>>>>>>
79442>>>>>>>>>>>
79442>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79442>>>>>>>>>>>                    // Studio licens is in use and there is no
79442>>>>>>>>>>>                    // number of max users defined because the driver is
79442>>>>>>>>>>>                    // relying on the info from the VDF license.
79442>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79444>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79445>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79446>>>>>>>>>>>                    End
79446>>>>>>>>>>>>
79446>>>>>>>>>>>                End
79446>>>>>>>>>>>>
79446>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79447>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79449>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79450>>>>>>>>>>>                End
79450>>>>>>>>>>>>
79450>>>>>>>>>>>                If (iNumServers <> 0) Begin
79452>>>>>>>>>>>                    For iCount from 1 to iNumServers
79458>>>>>>>>>>>>
79458>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79461>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79463>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79464>>>>>>>>>>>                        End
79464>>>>>>>>>>>>
79464>>>>>>>>>>>                    Loop
79465>>>>>>>>>>>>
79465>>>>>>>>>>>                End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>            End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>        Loop
79466>>>>>>>>>>>>
79466>>>>>>>>>>>
79466>>>>>>>>>>>        Send AppendTextLn ""
79467>>>>>>>>>>>        If (bStudioLicense = False) Begin
79469>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79470>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79471>>>>>>>>>>>        End
79471>>>>>>>>>>>>
79471>>>>>>>>>>>        Else Begin
79472>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79473>>>>>>>>>>>        End
79473>>>>>>>>>>>>
79473>>>>>>>>>>>        Send Destroy of hoCLIHandler
79474>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79475>>>>>>>>>>>    End_Procedure
79476>>>>>>>>>>>
79476>>>>>>>>>>>    Procedure Show_HelpFile
79478>>>>>>>>>>>        String sHelpFile
79478>>>>>>>>>>>        Integer eHelpType
79478>>>>>>>>>>>
79478>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79480>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79481>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79483>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79484>>>>>>>>>>>            End
79484>>>>>>>>>>>>
79484>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79487>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79488>>>>>>>>>>>            End
79488>>>>>>>>>>>>
79488>>>>>>>>>>>            Else Begin
79489>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79490>>>>>>>>>>>            End
79490>>>>>>>>>>>>
79490>>>>>>>>>>>
79490>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79491>>>>>>>>>>>        End
79491>>>>>>>>>>>>
79491>>>>>>>>>>>    End_Procedure
79492>>>>>>>>>>>
79492>>>>>>>>>>>    Procedure Show_EnterAsTab
79494>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79494>>>>>>>>>>>        String sText
79494>>>>>>>>>>>
79494>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79496>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79497>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79499>>>>>>>>>>>                Move "True" To sText
79500>>>>>>>>>>>            End
79500>>>>>>>>>>>>
79500>>>>>>>>>>>            Else Begin
79501>>>>>>>>>>>                Move "False" To sText
79502>>>>>>>>>>>            End
79502>>>>>>>>>>>>
79502>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79503>>>>>>>>>>>        End
79503>>>>>>>>>>>>
79503>>>>>>>>>>>    End_Procedure
79504>>>>>>>>>>>
79504>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79504>>>>>>>>>>>    //    found systeminformation
79504>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79506>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79508>>>>>>>>>>>
79508>>>>>>>>>>>        Send Delete_Data
79509>>>>>>>>>>>
79509>>>>>>>>>>>        Set Changed_State To False
79510>>>>>>>>>>>        Set Read_Only_State To True
79511>>>>>>>>>>>
79511>>>>>>>>>>>        Send Show_Registration
79512>>>>>>>>>>>        Send Show_Drivers
79513>>>>>>>>>>>        Send Show_ServicePack
79514>>>>>>>>>>>        Send Show_Versions
79515>>>>>>>>>>>        Send AppendTextLn ""
79516>>>>>>>>>>>
79516>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79518>>>>>>>>>>>            Send Show_WorkSpaceInformation
79519>>>>>>>>>>>            Send Show_HelpFile
79520>>>>>>>>>>>            Send AppendTextLn ""
79521>>>>>>>>>>>        End
79521>>>>>>>>>>>>
79521>>>>>>>>>>>        Else Begin
79522>>>>>>>>>>>            Send AppendTextLn ""
79523>>>>>>>>>>>        End
79523>>>>>>>>>>>>
79523>>>>>>>>>>>
79523>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79525>>>>>>>>>>>            Send Show_ConnectionIdInformation
79526>>>>>>>>>>>        End
79526>>>>>>>>>>>>
79526>>>>>>>>>>>
79526>>>>>>>>>>>        Send Show_Current_User
79527>>>>>>>>>>>        Send Show_Windows_Directory
79528>>>>>>>>>>>        Send Show_Current_Directory
79529>>>>>>>>>>>
79529>>>>>>>>>>>        // This is already shown in the workspace details,
79529>>>>>>>>>>>        // unless no workspace object is present:
79529>>>>>>>>>>>        If (ghoApplication = 0) Begin
79531>>>>>>>>>>>            Send Show_Filelist_Name
79532>>>>>>>>>>>        End
79532>>>>>>>>>>>>
79532>>>>>>>>>>>
79532>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79534>>>>>>>>>>>            Send AppendTextLn ""
79535>>>>>>>>>>>            Send Show_EnterAsTab
79536>>>>>>>>>>>        End
79536>>>>>>>>>>>>
79536>>>>>>>>>>>
79536>>>>>>>>>>>        Send Show_Screen_Size
79537>>>>>>>>>>>        Send Show_Page_Size
79538>>>>>>>>>>>        Send Show_Number_Format
79539>>>>>>>>>>>        Send Show_Date_Format
79540>>>>>>>>>>>        Send Show_Lock_Delay
79541>>>>>>>>>>>        Send Show_Lock_Timeout
79542>>>>>>>>>>>        Send Show_Date
79543>>>>>>>>>>>        Send Show_Systemresources
79544>>>>>>>>>>>        Send Beginning_of_Data
79545>>>>>>>>>>>
79545>>>>>>>>>>>        Set Icon to 'default.ico'
79546>>>>>>>>>>>    End_Procedure
79547>>>>>>>>>>>End_Class
79548>>>>>>>>>>>
79548>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79549>>>>>>>>>>>    Procedure Construct_Object
79551>>>>>>>>>>>        Forward Send Construct_Object
79553>>>>>>>>>>>
79553>>>>>>>>>>>        Set Label to C_$SystemInformation
79554>>>>>>>>>>>        Set Size to 140 267
79555>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79556>>>>>>>>>>>        Set Border_Style to Border_Thick
79557>>>>>>>>>>>        Set Sysmenu_Icon to False
79558>>>>>>>>>>>
79558>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79558>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79559>>>>>>>>>>>
79559>>>>>>>>>>>        // 2014-09-14 NGS
79559>>>>>>>>>>>        // Added a container object around the cTexteditor
79559>>>>>>>>>>>        // object to get a border around the text.
79559>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79561>>>>>>>>>>>            Set Location to 2 4
79562>>>>>>>>>>>            Set Size to 110 255
79563>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79564>>>>>>>>>>>            Set Color to clWhite
79565>>>>>>>>>>>            Set peAnchors to anAll
79566>>>>>>>>>>>
79566>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79568>>>>>>>>>>>            End_Object
79569>>>>>>>>>>>
79569>>>>>>>>>>>        End_Object
79570>>>>>>>>>>>
79570>>>>>>>>>>>        Object oCloseButton is a Button
79572>>>>>>>>>>>            Set Label to C_$Close
79573>>>>>>>>>>>            Set Location to 120 210
79574>>>>>>>>>>>            CompilerWarnings Off
79574>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79575>>>>>>>>>>>            CompilerWarnings On
79575>>>>>>>>>>>            Set Default_State To True
79576>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79576>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79576>>>>>>>>>>>            // for that situation.
79576>>>>>>>>>>>            Set peAnchors to anBottomRight
79577>>>>>>>>>>>        End_Object
79578>>>>>>>>>>>
79578>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79580>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79581>>>>>>>>>>>            Set Size to 14 50
79582>>>>>>>>>>>            Set Location to 120 158
79583>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79583>>>>>>>>>>>            // we might as well prepare the object for it.
79583>>>>>>>>>>>            Set peAnchors to anBottomRight
79584>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79585>>>>>>>>>>>        End_Object
79586>>>>>>>>>>>
79586>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79587>>>>>>>>>>>    End_Procedure
79588>>>>>>>>>>>
79588>>>>>>>>>>>    Procedure Page Integer iPageObject
79590>>>>>>>>>>>        Handle hMenu
79590>>>>>>>>>>>        Integer iPrevState
79590>>>>>>>>>>>
79590>>>>>>>>>>>        Forward Send Page iPageObject
79592>>>>>>>>>>>
79592>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79592>>>>>>>>>>>        //
79592>>>>>>>>>>>    End_Procedure
79593>>>>>>>>>>>
79593>>>>>>>>>>>End_Class
79594>>>>>>>>>>>
79594>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79595>>>>>>>>>>>    Procedure Construct_Object
79597>>>>>>>>>>>        Forward Send Construct_Object
79599>>>>>>>>>>>
79599>>>>>>>>>>>        Property String psContentText
79600>>>>>>>>>>>
79600>>>>>>>>>>>        Set Size to 77 153
79601>>>>>>>>>>>        Set Location to 8 60
79602>>>>>>>>>>>        Set Read_Only_State to True
79603>>>>>>>>>>>        Set Skip_State to True
79604>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79604>>>>>>>>>>>        // or 1/20 of a printer's point.
79604>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79605>>>>>>>>>>>        Set Border_Style  to Border_None
79606>>>>>>>>>>>    End_Procedure
79607>>>>>>>>>>>
79607>>>>>>>>>>>    // Adds a line of text to the edit object
79607>>>>>>>>>>>    Procedure Add_Line String sText
79609>>>>>>>>>>>        String sContentText
79609>>>>>>>>>>>        Get psContentText to sContentText
79610>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79611>>>>>>>>>>>        Set psContentText to sContentText
79612>>>>>>>>>>>    End_Procedure
79613>>>>>>>>>>>
79613>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79613>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79613>>>>>>>>>>>    // because the object isn't paged yet when we add these
79613>>>>>>>>>>>    // values and the COM edit object needs to be paged
79613>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79613>>>>>>>>>>>    Procedure Add_LineLn String sText
79615>>>>>>>>>>>        String sContentText sCR
79615>>>>>>>>>>>
79615>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79616>>>>>>>>>>>        Get psContentText to sContentText
79617>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79618>>>>>>>>>>>        Set psContentText to sContentText
79619>>>>>>>>>>>    End_Procedure
79620>>>>>>>>>>>
79620>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79622>>>>>>>>>>>        String sLinkText
79622>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79623>>>>>>>>>>>        Send Show_HomePage sLinkText
79624>>>>>>>>>>>    End_Procedure
79625>>>>>>>>>>>
79625>>>>>>>>>>>    Procedure Page Integer iPageObject
79627>>>>>>>>>>>        String sContentText
79627>>>>>>>>>>>
79627>>>>>>>>>>>        Forward Send Page iPageObject
79629>>>>>>>>>>>        Get psContentText to sContentText
79630>>>>>>>>>>>        Send AppendText sContentText
79631>>>>>>>>>>>        send Beginning_of_Data
79632>>>>>>>>>>>    End_Procedure
79633>>>>>>>>>>>
79633>>>>>>>>>>>End_Class
79634>>>>>>>>>>>
79634>>>>>>>>>>>Class AboutDialog is a ModalPanel
79635>>>>>>>>>>>    Procedure Construct_Object
79637>>>>>>>>>>>
79637>>>>>>>>>>>        Forward Send Construct_Object
79639>>>>>>>>>>>
79639>>>>>>>>>>>        Set Label to C_$About
79640>>>>>>>>>>>        Set Size to 118 230
79641>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79642>>>>>>>>>>>        Set Border_Style to Border_Thick
79643>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79644>>>>>>>>>>>
79644>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79646>>>>>>>>>>>        End_Object
79647>>>>>>>>>>>
79647>>>>>>>>>>>        Object oBox is a Container3d
79649>>>>>>>>>>>            Set Border_Style to Border_Normal
79650>>>>>>>>>>>            Set Size to 90 220
79651>>>>>>>>>>>            Set Location to 4 5
79652>>>>>>>>>>>            Set Color to clWhite
79653>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79653>>>>>>>>>>>            // we might as well prepare the object for it.
79653>>>>>>>>>>>            Set peAnchors to anAll
79654>>>>>>>>>>>
79654>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79656>>>>>>>>>>>                Set Border_Style To Border_None
79657>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79658>>>>>>>>>>>                Set Color to clWhite
79659>>>>>>>>>>>                Set Size to 45 50
79660>>>>>>>>>>>                Set Location to 0 3
79661>>>>>>>>>>>            End_Object
79662>>>>>>>>>>>
79662>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79664>>>>>>>>>>>                Set Border_Style to Border_None
79665>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79666>>>>>>>>>>>                Set Color to clWhite
79667>>>>>>>>>>>                Set Size to 30 55
79668>>>>>>>>>>>                Set Location to 50 3
79669>>>>>>>>>>>            End_Object
79670>>>>>>>>>>>
79670>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79672>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79672>>>>>>>>>>>                // we might as well prepare the object for it.
79672>>>>>>>>>>>                Set peAnchors to anAll
79673>>>>>>>>>>>            End_Object
79674>>>>>>>>>>>
79674>>>>>>>>>>>            // These objects are here for backwards compatability only.
79674>>>>>>>>>>>            // They are not used.
79674>>>>>>>>>>>            Object oProductName is a TextBox
79676>>>>>>>>>>>                Set Label To C_$ProductName
79677>>>>>>>>>>>                Set Size To 10 45
79678>>>>>>>>>>>                Set Location To 8 53
79679>>>>>>>>>>>                Set Visible_State to False
79680>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79681>>>>>>>>>>>            End_Object
79682>>>>>>>>>>>
79682>>>>>>>>>>>            Object oVersion is a TextBox
79684>>>>>>>>>>>                Set Label To C_$Version
79685>>>>>>>>>>>                Set Size To 10 25
79686>>>>>>>>>>>                Set Location To 21 53
79687>>>>>>>>>>>                Set Visible_State to False
79688>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79689>>>>>>>>>>>            End_Object
79690>>>>>>>>>>>
79690>>>>>>>>>>>            Object oCopyright is a TextBox
79692>>>>>>>>>>>                Set Label To C_$Copyright
79693>>>>>>>>>>>                Set Size To 10 31
79694>>>>>>>>>>>                Set Location To 34 53
79695>>>>>>>>>>>                Set Visible_State to False
79696>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79697>>>>>>>>>>>            End_Object
79698>>>>>>>>>>>
79698>>>>>>>>>>>            Object oAuthor is a TextBox
79700>>>>>>>>>>>                Set Label To C_$Author
79701>>>>>>>>>>>                Set Size To 10 22
79702>>>>>>>>>>>                Set Location To 46 53
79703>>>>>>>>>>>                Set Visible_State to False
79704>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79705>>>>>>>>>>>            End_Object
79706>>>>>>>>>>>
79706>>>>>>>>>>>        End_Object
79707>>>>>>>>>>>
79707>>>>>>>>>>>        Object oOKButton is a Button
79709>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79710>>>>>>>>>>>            Set Location to 98 176
79711>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79711>>>>>>>>>>>            // we might as well prepare the object for it.
79711>>>>>>>>>>>            Set peAnchors to anBottomRight
79712>>>>>>>>>>>        End_Object
79713>>>>>>>>>>>
79713>>>>>>>>>>>        Object oSysInfoButton is a Button
79715>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79716>>>>>>>>>>>            Set Location to 98 123
79717>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79717>>>>>>>>>>>            // we might as well prepare the object for it.
79717>>>>>>>>>>>            Set peAnchors to anBottomRight
79718>>>>>>>>>>>        End_Object
79719>>>>>>>>>>>
79719>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79721>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79722>>>>>>>>>>>            Set Size to 14 50
79723>>>>>>>>>>>            Set Location to 98 70
79724>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79724>>>>>>>>>>>            // we might as well prepare the object for it.
79724>>>>>>>>>>>            Set peAnchors to anBottomRight
79725>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79726>>>>>>>>>>>        End_Object
79727>>>>>>>>>>>
79727>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79728>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79729>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79730>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79730>>>>>>>>>>>    End_Procedure
79731>>>>>>>>>>>
79731>>>>>>>>>>>    Procedure Page Integer iPageObject
79733>>>>>>>>>>>        Handle hMenu
79733>>>>>>>>>>>        Integer iPrevState
79733>>>>>>>>>>>
79733>>>>>>>>>>>        Forward Send Page iPageObject
79735>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79735>>>>>>>>>>>        Set Icon to "Default.ico"
79736>>>>>>>>>>>
79736>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79736>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79737>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79738>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79738>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79738>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79739>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79740>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79741>>>>>>>>>>>        // The "Close" menu command may be good to have.
79741>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79741>>>>>>>>>>>    End_Procedure
79742>>>>>>>>>>>
79742>>>>>>>>>>>    Procedure Set ProductName String sText
79744>>>>>>>>>>>        Set Value of oProductName to sText
79745>>>>>>>>>>>    End_Procedure
79746>>>>>>>>>>>
79746>>>>>>>>>>>    Procedure Set Copyright String sText
79748>>>>>>>>>>>        Set Value of oCopyright to sText
79749>>>>>>>>>>>    End_Procedure
79750>>>>>>>>>>>
79750>>>>>>>>>>>    Procedure Set Author String sText
79752>>>>>>>>>>>        Set Value of oAuthor to sText
79753>>>>>>>>>>>    End_Procedure
79754>>>>>>>>>>>
79754>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79754>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79754>>>>>>>>>>>    //       program as a pre-compile!
79754>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79754>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79754>>>>>>>>>>>
79754>>>>>>>>>>>    Procedure Set Version String sVersion
79756>>>>>>>>>>>        Handle hoVersionInfo
79756>>>>>>>>>>>        Boolean bIncluded
79756>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79756>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79756>>>>>>>>>>>
79756>>>>>>>>>>>        If (sVersion = "") Begin
79758>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79758>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79758>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79760>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79761>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79763>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79764>>>>>>>>>>>                    If (bIncluded) Begin
79766>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79767>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79768>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79769>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79770>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79771>>>>>>>>>>>                    End
79771>>>>>>>>>>>>
79771>>>>>>>>>>>                End
79771>>>>>>>>>>>>
79771>>>>>>>>>>>            End
79771>>>>>>>>>>>>
79771>>>>>>>>>>>        End
79771>>>>>>>>>>>>
79771>>>>>>>>>>>
79771>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79771>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79772>>>>>>>>>>>        Readln sCompileDateAndTime
79773>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79774>>>>>>>>>>>        If (iPos <> 0) Begin
79776>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79777>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79778>>>>>>>>>>>        End
79778>>>>>>>>>>>>
79778>>>>>>>>>>>        Close_Input
79779>>>>>>>>>>>
79779>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79781>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79782>>>>>>>>>>>        End
79782>>>>>>>>>>>>
79782>>>>>>>>>>>
79782>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79783>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79785>>>>>>>>>>>            If (sCertInfo <> "") Begin
79787>>>>>>>>>>>                Send Add_LineLn sCertInfo
79788>>>>>>>>>>>            End
79788>>>>>>>>>>>>
79788>>>>>>>>>>>            Else Begin
79789>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79790>>>>>>>>>>>            End
79790>>>>>>>>>>>>
79790>>>>>>>>>>>        End
79790>>>>>>>>>>>>
79790>>>>>>>>>>>    End_Procedure
79791>>>>>>>>>>>
79791>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79793>>>>>>>>>>>        Boolean bIsDate
79793>>>>>>>>>>>        String sGoodCharacters sChar
79793>>>>>>>>>>>        Integer iCount iLength
79793>>>>>>>>>>>
79793>>>>>>>>>>>        Move True to bIsDate
79794>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79795>>>>>>>>>>>        Move (Length(sDate)) to iLength
79796>>>>>>>>>>>        For iCount from 1 to iLength
79802>>>>>>>>>>>>
79802>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79803>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79804>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79805>>>>>>>>>>>            If (bIsDate = False) Begin
79807>>>>>>>>>>>                Move iLength to iCount
79808>>>>>>>>>>>            End
79808>>>>>>>>>>>>
79808>>>>>>>>>>>        Loop
79809>>>>>>>>>>>>
79809>>>>>>>>>>>        Function_Return bIsDate
79810>>>>>>>>>>>    End_Function
79811>>>>>>>>>>>
79811>>>>>>>>>>>    Function GetCompileDate Returns Date
79813>>>>>>>>>>>        Date dCompileDate
79813>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79813>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79813>>>>>>>>>>>        Boolean bIsValid   
79813>>>>>>>>>>>        
79813>>>>>>>>>>>        Move 0 to dCompileDate
79814>>>>>>>>>>>        // Get full path to the current running executable
79814>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79815>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79816>>>>>>>>>>>
79816>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79816>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79817>>>>>>>>>>>
79817>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79819>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79820>>>>>>>>>>>        If (iPos > 0) Begin
79822>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79822>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79823>>>>>>>>>>>
79823>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79823>>>>>>>>>>>            // change the format and then move the string to the date variable.
79823>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79826>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79829>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79830>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79832>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79833>>>>>>>>>>>            End
79833>>>>>>>>>>>>
79833>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79834>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79835>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79838>>>>>>>>>>>        End
79838>>>>>>>>>>>>
79838>>>>>>>>>>>        Else Begin
79839>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79840>>>>>>>>>>>>
79840>>>>>>>>>>>        End
79840>>>>>>>>>>>>
79840>>>>>>>>>>>
79840>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79841>>>>>>>>>>>
79841>>>>>>>>>>>        Function_Return dCompileDate
79842>>>>>>>>>>>    End_Function
79843>>>>>>>>>>>
79843>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79843>>>>>>>>>>>    // (the passed program), has been finished
79843>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79843>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79845>>>>>>>>>>>        Handle hProcess
79845>>>>>>>>>>>        Integer iVoid
79845>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79845>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79845>>>>>>>>>>>
79845>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79846>>>>>>>>>>>
79846>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79847>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79848>>>>>>>>>>>
79848>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79849>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79850>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79850>>>>>>>>>>>        Move 0                       to sInfo.nShow
79851>>>>>>>>>>>
79851>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79852>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79853>>>>>>>>>>>        If (hProcess) Begin
79855>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79856>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79857>>>>>>>>>>>        End
79857>>>>>>>>>>>>
79857>>>>>>>>>>>    End_Procedure
79858>>>>>>>>>>>
79858>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79860>>>>>>>>>>>        String sDirSep
79860>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79861>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79862>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79864>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79865>>>>>>>>>>>        End
79865>>>>>>>>>>>>
79865>>>>>>>>>>>        Function_Return sPath
79866>>>>>>>>>>>    End_Function
79867>>>>>>>>>>>
79867>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79867>>>>>>>>>>>    // or there is a problem with the certificate.
79867>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79867>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79867>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79869>>>>>>>>>>>        Boolean bExists
79869>>>>>>>>>>>        String sPath sProgram sParams sRetval
79869>>>>>>>>>>>        Integer iCh
79869>>>>>>>>>>>
79869>>>>>>>>>>>        Move "" to sRetval
79870>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79871>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79872>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79873>>>>>>>>>>>        If (bExists = False) Begin
79875>>>>>>>>>>>            Function_Return "-1"
79876>>>>>>>>>>>        End
79876>>>>>>>>>>>>
79876>>>>>>>>>>>
79876>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79877>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79878>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79879>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79880>>>>>>>>>>>        Get Seq_New_Channel to iCh
79881>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79883>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79886>>>>>>>>>>>        Close_Output channel iCh
79888>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79888>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79889>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79891>>>>>>>>>>>            Readln channel iCh sRetval
79893>>>>>>>>>>>            Readln channel iCh sRetval
79895>>>>>>>>>>>            Readln channel iCh sRetval
79897>>>>>>>>>>>            Readln channel iCh sRetval
79899>>>>>>>>>>>        Close_Input channel iCh
79901>>>>>>>>>>>        Send Seq_Release_Channel iCh
79902>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79904>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79905>>>>>>>>>>>        End
79905>>>>>>>>>>>>
79905>>>>>>>>>>>        Else Begin
79906>>>>>>>>>>>            Move "" to sRetval
79907>>>>>>>>>>>        End
79907>>>>>>>>>>>>
79907>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79907>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79908>>>>>>>>>>>>
79908>>>>>>>>>>>        Function_Return sRetval
79909>>>>>>>>>>>    End_Function
79910>>>>>>>>>>>
79910>>>>>>>>>>>    Procedure Add_LineLn String sValue
79912>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79913>>>>>>>>>>>    End_Procedure
79914>>>>>>>>>>>
79914>>>>>>>>>>>    Procedure Add_Line String sValue
79916>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79917>>>>>>>>>>>    End_Procedure
79918>>>>>>>>>>>
79918>>>>>>>>>>>    Procedure Set Logo string sLogo
79920>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79920>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79921>>>>>>>>>>>    End_Procedure
79922>>>>>>>>>>>
79922>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79924>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79925>>>>>>>>>>>    End_Procedure
79926>>>>>>>>>>>
79926>>>>>>>>>>>    Procedure Show_Sysinfo
79928>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79929>>>>>>>>>>>    End_Procedure
79930>>>>>>>>>>>
79930>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79932>>>>>>>>>>>        Handle hWnd
79932>>>>>>>>>>>        Get Window_Handle to hWnd
79933>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79934>>>>>>>>>>>    End_Procedure
79935>>>>>>>>>>>
79935>>>>>>>>>>>End_Class
79936>>>>>>>>>
79936>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79938>>>>>>>>>    End_Function
79939>>>>>>>>>
79939>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
79939>>>>>>>>>
79939>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79940>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79941>>>>>>>>>>
79941>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79943>>>>>>>>>>    Integer iStart iEnd
79943>>>>>>>>>>    String sRetval
79943>>>>>>>>>>
79943>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79944>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79945>>>>>>>>>>    If (iStart = 0) Begin
79947>>>>>>>>>>        Function_Return ""
79948>>>>>>>>>>    End
79948>>>>>>>>>>>
79948>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79949>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79950>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79952>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79953>>>>>>>>>>    End
79953>>>>>>>>>>>
79953>>>>>>>>>>    Else Begin
79954>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79955>>>>>>>>>>    End
79955>>>>>>>>>>>
79955>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79957>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79958>>>>>>>>>>        Decrement iEnd
79959>>>>>>>>>>    End
79959>>>>>>>>>>>
79959>>>>>>>>>>    If (iEnd <> 0) Begin
79961>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79962>>>>>>>>>>    End
79962>>>>>>>>>>>
79962>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79963>>>>>>>>>>
79963>>>>>>>>>>    Function_Return (Trim(sRetval))
79964>>>>>>>>>>End_Function
79965>>>>>>>>>>
79965>>>>>>>>>>
79965>>>>>>>>>    
79965>>>>>>>>>    Procedure Construct_Object
79967>>>>>>>>>        Handle ho
79967>>>>>>>>>        Forward Send Construct_Object
79969>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79970>>>>>>>>>        
79970>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79971>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79972>>>>>>>>>
79972>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79972>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79972>>>>>>>>>        // etc settings.
79972>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79974>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79975>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
79976>>>>>>>>>            Set phoSQLConnectionHandler to ho
79977>>>>>>>>>        End
79977>>>>>>>>>>
79977>>>>>>>>>
79977>>>>>>>>>    End_Procedure
79978>>>>>>>>>
79978>>>>>>>>>    Procedure End_Construct_Object
79980>>>>>>>>>        Forward Send End_Construct_Object
79982>>>>>>>>>
79982>>>>>>>>>    End_Procedure
79983>>>>>>>>>
79983>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79983>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79983>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79983>>>>>>>>>    // Good read about which collation to select:
79983>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79983>>>>>>>>>    Procedure Set psCollation String sCollation
79985>>>>>>>>>        Set private.psCollation to sCollation
79986>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79988>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79989>>>>>>>>>        End
79989>>>>>>>>>>
79989>>>>>>>>>    End_Procedure
79990>>>>>>>>>
79990>>>>>>>>>    Function psCollation Returns String
79992>>>>>>>>>        String sCollation
79992>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79994>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79995>>>>>>>>>        End   
79995>>>>>>>>>>
79995>>>>>>>>>        Else Begin
79996>>>>>>>>>            Get private.psCollation to sCollation
79997>>>>>>>>>        End
79997>>>>>>>>>>
79997>>>>>>>>>        Function_Return sCollation
79998>>>>>>>>>    End_Function
79999>>>>>>>>>
79999>>>>>>>>>    // Array sorting helper functions:
79999>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80001>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80003>>>>>>>>>            Function_Return (EQ)
80004>>>>>>>>>        End
80004>>>>>>>>>>
80004>>>>>>>>>
80004>>>>>>>>>        Function_Return (GT)
80005>>>>>>>>>    End_Function
80006>>>>>>>>>
80006>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80008>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80011>>>>>>>>>
80011>>>>>>>>>        Function_Return (GT)
80012>>>>>>>>>    End_Function
80013>>>>>>>>>
80013>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80013>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80013>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80015>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80015>>>>>>>>>        Handle hTable
80015>>>>>>>>>        Boolean bIsSame
80015>>>>>>>>>
80015>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80016>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80017>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80020>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80021>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80024>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80027>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80028>>>>>>>>>
80028>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80030>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80031>>>>>>>>>        End
80031>>>>>>>>>>
80031>>>>>>>>>        Else Begin
80032>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80033>>>>>>>>>        End
80033>>>>>>>>>>
80033>>>>>>>>>
80033>>>>>>>>>        Function_Return bIsSame
80034>>>>>>>>>    End_Function
80035>>>>>>>>>
80035>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80037>>>>>>>>>        Integer iRetval
80037>>>>>>>>>        Move 1 to iRetval
80038>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80040>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80041>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80042>>>>>>>>>        End
80042>>>>>>>>>>
80042>>>>>>>>>        Function_Return (iRetval = 0)
80043>>>>>>>>>    End_Function
80044>>>>>>>>>
80044>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80046>>>>>>>>>        String sDirSep
80046>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80047>>>>>>>>>        Move (Trim(sPath)) to sPath
80048>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80050>>>>>>>>>            Move (sPath + sDirSep) to sPath
80051>>>>>>>>>        End
80051>>>>>>>>>>
80051>>>>>>>>>        Function_Return sPath
80052>>>>>>>>>    End_Function
80053>>>>>>>>>
80053>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80055>>>>>>>>>        Integer i iCols iItem
80055>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80055>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80056>>>>>>>>>
80056>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80057>>>>>>>>>        For i from 1 to iCols
80063>>>>>>>>>>
80063>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80064>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80065>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80066>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80067>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80068>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80069>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80070>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80071>>>>>>>>>        Loop
80072>>>>>>>>>>
80072>>>>>>>>>        Set piColumns to iCols
80073>>>>>>>>>        Set paQueryColumns to aQueryColumns
80074>>>>>>>>>    End_Procedure
80075>>>>>>>>>
80075>>>>>>>>>    // *** Property Messages ***
80075>>>>>>>>>    //
80075>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80075>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80075>>>>>>>>>    //
80075>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80077>>>>>>>>>        tSQLConnection SQLConnection
80077>>>>>>>>>        tSQLConnection SQLConnection
80077>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80079>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80079>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80080>>>>>>>>>>
80080>>>>>>>>>            Function_Return
80081>>>>>>>>>        End
80081>>>>>>>>>>
80081>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80082>>>>>>>>>        Function_Return SQLConnection
80083>>>>>>>>>    End_Function
80084>>>>>>>>>
80084>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80084>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80086>>>>>>>>>        Function_Return False
80087>>>>>>>>>    End_Function
80088>>>>>>>>>
80088>>>>>>>>>    Procedure Set psServer String sValue
80090>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80092>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80092>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80093>>>>>>>>>>
80093>>>>>>>>>            Procedure_Return
80094>>>>>>>>>        End
80094>>>>>>>>>>
80094>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80095>>>>>>>>>    End_Procedure
80096>>>>>>>>>
80096>>>>>>>>>    Function psServer Returns String
80098>>>>>>>>>        String sValue
80098>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80100>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80101>>>>>>>>>>
80101>>>>>>>>>            Function_Return
80102>>>>>>>>>        End
80102>>>>>>>>>>
80102>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80103>>>>>>>>>        Function_Return sValue
80104>>>>>>>>>    End_Function
80105>>>>>>>>>
80105>>>>>>>>>    Procedure Set psDatabase String sValue
80107>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80109>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80110>>>>>>>>>>
80110>>>>>>>>>            Procedure_Return
80111>>>>>>>>>        End
80111>>>>>>>>>>
80111>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80112>>>>>>>>>    End_Procedure
80113>>>>>>>>>
80113>>>>>>>>>    Function psDatabase Returns String
80115>>>>>>>>>        String sValue
80115>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80117>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80118>>>>>>>>>>
80118>>>>>>>>>            Function_Return
80119>>>>>>>>>        End
80119>>>>>>>>>>
80119>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80120>>>>>>>>>        Function_Return sValue
80121>>>>>>>>>    End_Function
80122>>>>>>>>>
80122>>>>>>>>>    Procedure Set psUserID String sValue
80124>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80126>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80127>>>>>>>>>>
80127>>>>>>>>>            Procedure_Return
80128>>>>>>>>>        End
80128>>>>>>>>>>
80128>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80129>>>>>>>>>    End_Procedure
80130>>>>>>>>>
80130>>>>>>>>>    Function psUserID Returns String
80132>>>>>>>>>        String sValue
80132>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80134>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80135>>>>>>>>>>
80135>>>>>>>>>            Function_Return
80136>>>>>>>>>        End
80136>>>>>>>>>>
80136>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80137>>>>>>>>>        Function_Return sValue
80138>>>>>>>>>    End_Function
80139>>>>>>>>>
80139>>>>>>>>>    Procedure Set psPassword String sValue
80141>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80143>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80144>>>>>>>>>>
80144>>>>>>>>>            Procedure_Return
80145>>>>>>>>>        End
80145>>>>>>>>>>
80145>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80146>>>>>>>>>    End_Procedure
80147>>>>>>>>>
80147>>>>>>>>>    Function psPassword Returns String
80149>>>>>>>>>        String sValue
80149>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80151>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80152>>>>>>>>>>
80152>>>>>>>>>            Function_Return
80153>>>>>>>>>        End
80153>>>>>>>>>>
80153>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80154>>>>>>>>>        Function_Return sValue
80155>>>>>>>>>    End_Function
80156>>>>>>>>>
80156>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80158>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80160>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80161>>>>>>>>>>
80161>>>>>>>>>            Procedure_Return
80162>>>>>>>>>        End
80162>>>>>>>>>>
80162>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80163>>>>>>>>>    End_Procedure
80164>>>>>>>>>
80164>>>>>>>>>    Function pbTrusted Returns Boolean
80166>>>>>>>>>        Boolean bValue
80166>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80168>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80169>>>>>>>>>>
80169>>>>>>>>>            Function_Return
80170>>>>>>>>>        End
80170>>>>>>>>>>
80170>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80171>>>>>>>>>        Function_Return bValue
80172>>>>>>>>>    End_Function
80173>>>>>>>>>
80173>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80175>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80177>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80178>>>>>>>>>>
80178>>>>>>>>>            Procedure_Return
80179>>>>>>>>>        End
80179>>>>>>>>>>
80179>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80180>>>>>>>>>    End_Procedure
80181>>>>>>>>>
80181>>>>>>>>>    Function pbSilentLogin Returns Boolean
80183>>>>>>>>>        Boolean bValue
80183>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80185>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80186>>>>>>>>>>
80186>>>>>>>>>            Function_Return
80187>>>>>>>>>        End
80187>>>>>>>>>>
80187>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80188>>>>>>>>>        Function_Return bValue
80189>>>>>>>>>    End_Function
80190>>>>>>>>>
80190>>>>>>>>>    Procedure Set psConnectionID String sValue
80192>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80194>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80195>>>>>>>>>>
80195>>>>>>>>>            Procedure_Return
80196>>>>>>>>>        End
80196>>>>>>>>>>
80196>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80197>>>>>>>>>    End_Procedure
80198>>>>>>>>>
80198>>>>>>>>>    Function psConnectionID Returns String
80200>>>>>>>>>        String sValue
80200>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80202>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80203>>>>>>>>>>
80203>>>>>>>>>            Function_Return
80204>>>>>>>>>        End
80204>>>>>>>>>>
80204>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80205>>>>>>>>>        Function_Return sValue
80206>>>>>>>>>    End_Function
80207>>>>>>>>>
80207>>>>>>>>>    Procedure Set psConnectionString String sValue
80209>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80211>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80212>>>>>>>>>>
80212>>>>>>>>>            Procedure_Return
80213>>>>>>>>>        End
80213>>>>>>>>>>
80213>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80214>>>>>>>>>    End_Procedure
80215>>>>>>>>>
80215>>>>>>>>>    Function psConnectionString Returns String
80217>>>>>>>>>        String sValue
80217>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80219>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80220>>>>>>>>>>
80220>>>>>>>>>            Function_Return
80221>>>>>>>>>        End
80221>>>>>>>>>>
80221>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80222>>>>>>>>>        Function_Return sValue
80223>>>>>>>>>    End_Function
80224>>>>>>>>>
80224>>>>>>>>>    // The normal connection string looks something like this;
80224>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80224>>>>>>>>>    // ...and the full connection string looks like this;
80224>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80224>>>>>>>>>    Function psFullConnectionString Returns String
80226>>>>>>>>>        String sConnectionID sConnectionString
80226>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80228>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80229>>>>>>>>>>
80229>>>>>>>>>            Function_Return
80230>>>>>>>>>        End
80230>>>>>>>>>>
80230>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80231>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80232>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80233>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80234>>>>>>>>>    End_Function
80235>>>>>>>>>
80235>>>>>>>>>    Function piConnectionOptions Returns Integer
80237>>>>>>>>>        Integer iValue
80237>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80239>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80240>>>>>>>>>>
80240>>>>>>>>>            Function_Return
80241>>>>>>>>>        End
80241>>>>>>>>>>
80241>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80242>>>>>>>>>        Function_Return iValue
80243>>>>>>>>>    End_Function
80244>>>>>>>>>
80244>>>>>>>>>    Procedure Set psSchema String sValue
80246>>>>>>>>>        tSQLConnection SQLConnection
80246>>>>>>>>>        tSQLConnection SQLConnection
80246>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80248>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80249>>>>>>>>>>
80249>>>>>>>>>            Procedure_Return
80250>>>>>>>>>        End
80250>>>>>>>>>>
80250>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80251>>>>>>>>>    End_Procedure
80252>>>>>>>>>
80252>>>>>>>>>    Function psSchema Returns String
80254>>>>>>>>>        String sRetval
80254>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80256>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80257>>>>>>>>>>
80257>>>>>>>>>            Function_Return
80258>>>>>>>>>        End
80258>>>>>>>>>>
80258>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80259>>>>>>>>>        Function_Return sRetval
80260>>>>>>>>>    End_Function
80261>>>>>>>>>
80261>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80263>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80265>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80266>>>>>>>>>>
80266>>>>>>>>>            Procedure_Return
80267>>>>>>>>>        End
80267>>>>>>>>>>
80267>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80268>>>>>>>>>    End_Procedure
80269>>>>>>>>>
80269>>>>>>>>>    Function psBaseTableSpace Returns String
80271>>>>>>>>>        String sRetval
80271>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80273>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80274>>>>>>>>>>
80274>>>>>>>>>            Function_Return
80275>>>>>>>>>        End
80275>>>>>>>>>>
80275>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80276>>>>>>>>>        Function_Return sRetval
80277>>>>>>>>>    End_Function
80278>>>>>>>>>
80278>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80280>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80282>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80283>>>>>>>>>>
80283>>>>>>>>>            Procedure_Return
80284>>>>>>>>>        End
80284>>>>>>>>>>
80284>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80285>>>>>>>>>    End_Procedure
80286>>>>>>>>>
80286>>>>>>>>>    Function psLongTableSpace Returns String
80288>>>>>>>>>        String sRetval
80288>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80290>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80291>>>>>>>>>>
80291>>>>>>>>>            Function_Return
80292>>>>>>>>>        End
80292>>>>>>>>>>
80292>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80293>>>>>>>>>        Function_Return sRetval
80294>>>>>>>>>    End_Function
80295>>>>>>>>>
80295>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80297>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80299>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80300>>>>>>>>>>
80300>>>>>>>>>            Procedure_Return
80301>>>>>>>>>        End
80301>>>>>>>>>>
80301>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80302>>>>>>>>>    End_Procedure
80303>>>>>>>>>
80303>>>>>>>>>    Function psIndexTableSpace Returns String
80305>>>>>>>>>        String sRetval
80305>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80307>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80308>>>>>>>>>>
80308>>>>>>>>>            Function_Return
80309>>>>>>>>>        End
80309>>>>>>>>>>
80309>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80310>>>>>>>>>        Function_Return sRetval
80311>>>>>>>>>    End_Function
80312>>>>>>>>>
80312>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80314>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80316>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80317>>>>>>>>>>
80317>>>>>>>>>            Procedure_Return
80318>>>>>>>>>        End
80318>>>>>>>>>>
80318>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80319>>>>>>>>>    End_Procedure
80320>>>>>>>>>
80320>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80322>>>>>>>>>        Boolean bState
80322>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80324>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80325>>>>>>>>>>
80325>>>>>>>>>            Function_Return
80326>>>>>>>>>        End
80326>>>>>>>>>>
80326>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80327>>>>>>>>>        Function_Return bState
80328>>>>>>>>>    End_Function
80329>>>>>>>>>
80329>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80331>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80333>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80334>>>>>>>>>>
80334>>>>>>>>>            Procedure_Return
80335>>>>>>>>>        End
80335>>>>>>>>>>
80335>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80336>>>>>>>>>    End_Procedure
80337>>>>>>>>>
80337>>>>>>>>>    Function pbToANSI Returns Boolean
80339>>>>>>>>>        Boolean bState
80339>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80341>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80342>>>>>>>>>>
80342>>>>>>>>>            Function_Return
80343>>>>>>>>>        End
80343>>>>>>>>>>
80343>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80344>>>>>>>>>        Function_Return bState
80345>>>>>>>>>    End_Function
80346>>>>>>>>>
80346>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80348>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80350>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80351>>>>>>>>>>
80351>>>>>>>>>            Procedure_Return
80352>>>>>>>>>        End
80352>>>>>>>>>>
80352>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80353>>>>>>>>>    End_Procedure
80354>>>>>>>>>
80354>>>>>>>>>    Function pbRecnum Returns Boolean
80356>>>>>>>>>        Boolean bState
80356>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80358>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80359>>>>>>>>>>
80359>>>>>>>>>            Function_Return
80360>>>>>>>>>        End
80360>>>>>>>>>>
80360>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80361>>>>>>>>>        Function_Return bState
80362>>>>>>>>>    End_Function
80363>>>>>>>>>
80363>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80365>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80367>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80368>>>>>>>>>>
80368>>>>>>>>>            Procedure_Return
80369>>>>>>>>>        End
80369>>>>>>>>>>
80369>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80370>>>>>>>>>    End_Procedure
80371>>>>>>>>>
80371>>>>>>>>>    Function pbCopyData Returns Boolean
80373>>>>>>>>>        Boolean bState
80373>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80375>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80376>>>>>>>>>>
80376>>>>>>>>>            Function_Return
80377>>>>>>>>>        End
80377>>>>>>>>>>
80377>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80378>>>>>>>>>        Function_Return bState
80379>>>>>>>>>    End_Function
80380>>>>>>>>>
80380>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80382>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80384>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80385>>>>>>>>>>
80385>>>>>>>>>            Procedure_Return
80386>>>>>>>>>        End
80386>>>>>>>>>>
80386>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80387>>>>>>>>>    End_Procedure
80388>>>>>>>>>
80388>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80390>>>>>>>>>        Boolean bState
80390>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80392>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80393>>>>>>>>>>
80393>>>>>>>>>            Function_Return
80394>>>>>>>>>        End
80394>>>>>>>>>>
80394>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80395>>>>>>>>>        Function_Return bState
80396>>>>>>>>>    End_Function
80397>>>>>>>>>
80397>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80399>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80401>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80402>>>>>>>>>>
80402>>>>>>>>>            Procedure_Return
80403>>>>>>>>>        End
80403>>>>>>>>>>
80403>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80404>>>>>>>>>    End_Procedure
80405>>>>>>>>>
80405>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80407>>>>>>>>>        Boolean bState
80407>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80409>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80410>>>>>>>>>>
80410>>>>>>>>>            Function_Return
80411>>>>>>>>>        End
80411>>>>>>>>>>
80411>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80412>>>>>>>>>        Function_Return bState
80413>>>>>>>>>    End_Function
80414>>>>>>>>>
80414>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80416>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80418>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80419>>>>>>>>>>
80419>>>>>>>>>            Procedure_Return
80420>>>>>>>>>        End
80420>>>>>>>>>>
80420>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80421>>>>>>>>>    End_Procedure
80422>>>>>>>>>
80422>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80424>>>>>>>>>        Boolean bState
80424>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80426>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80427>>>>>>>>>>
80427>>>>>>>>>            Function_Return
80428>>>>>>>>>        End
80428>>>>>>>>>>
80428>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80429>>>>>>>>>        Function_Return bState
80430>>>>>>>>>    End_Function
80431>>>>>>>>>
80431>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80433>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80435>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80436>>>>>>>>>>
80436>>>>>>>>>            Procedure_Return
80437>>>>>>>>>        End
80437>>>>>>>>>>
80437>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80438>>>>>>>>>    End_Procedure
80439>>>>>>>>>
80439>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80441>>>>>>>>>        Boolean bState
80441>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80443>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80444>>>>>>>>>>
80444>>>>>>>>>            Function_Return
80445>>>>>>>>>        End
80445>>>>>>>>>>
80445>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80446>>>>>>>>>        Function_Return bState
80447>>>>>>>>>    End_Function
80448>>>>>>>>>
80448>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80450>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80452>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80453>>>>>>>>>>
80453>>>>>>>>>            Procedure_Return
80454>>>>>>>>>        End
80454>>>>>>>>>>
80454>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80455>>>>>>>>>    End_Procedure
80456>>>>>>>>>
80456>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80458>>>>>>>>>        String sRetval
80458>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80460>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80461>>>>>>>>>>
80461>>>>>>>>>            Function_Return
80462>>>>>>>>>        End
80462>>>>>>>>>>
80462>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80463>>>>>>>>>        Function_Return sRetval
80464>>>>>>>>>    End_Function
80465>>>>>>>>>
80465>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80467>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80469>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80470>>>>>>>>>>
80470>>>>>>>>>            Procedure_Return
80471>>>>>>>>>        End
80471>>>>>>>>>>
80471>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80472>>>>>>>>>    End_Procedure
80473>>>>>>>>>
80473>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80475>>>>>>>>>        String sRetval
80475>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80477>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80478>>>>>>>>>>
80478>>>>>>>>>            Function_Return
80479>>>>>>>>>        End
80479>>>>>>>>>>
80479>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80480>>>>>>>>>        Function_Return sRetval
80481>>>>>>>>>    End_Function
80482>>>>>>>>>
80482>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80484>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80486>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80487>>>>>>>>>>
80487>>>>>>>>>            Procedure_Return
80488>>>>>>>>>        End
80488>>>>>>>>>>
80488>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80489>>>>>>>>>    End_Procedure
80490>>>>>>>>>
80490>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80492>>>>>>>>>        String sRetval
80492>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80494>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80495>>>>>>>>>>
80495>>>>>>>>>            Function_Return
80496>>>>>>>>>        End
80496>>>>>>>>>>
80496>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80497>>>>>>>>>        Function_Return sRetval
80498>>>>>>>>>    End_Function
80499>>>>>>>>>
80499>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80501>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80503>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80504>>>>>>>>>>
80504>>>>>>>>>            Procedure_Return
80505>>>>>>>>>        End
80505>>>>>>>>>>
80505>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80506>>>>>>>>>    End_Procedure
80507>>>>>>>>>
80507>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80509>>>>>>>>>        String sRetval
80509>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80511>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80512>>>>>>>>>>
80512>>>>>>>>>            Function_Return
80513>>>>>>>>>        End
80513>>>>>>>>>>
80513>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80514>>>>>>>>>        Function_Return sRetval
80515>>>>>>>>>    End_Function
80516>>>>>>>>>
80516>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80518>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80520>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80521>>>>>>>>>>
80521>>>>>>>>>            Procedure_Return
80522>>>>>>>>>        End
80522>>>>>>>>>>
80522>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80523>>>>>>>>>    End_Procedure
80524>>>>>>>>>
80524>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80526>>>>>>>>>        String sRetval
80526>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80528>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80529>>>>>>>>>>
80529>>>>>>>>>            Function_Return
80530>>>>>>>>>        End
80530>>>>>>>>>>
80530>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80531>>>>>>>>>        Function_Return sRetval
80532>>>>>>>>>    End_Function
80533>>>>>>>>>
80533>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80535>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80537>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80538>>>>>>>>>>
80538>>>>>>>>>            Procedure_Return
80539>>>>>>>>>        End
80539>>>>>>>>>>
80539>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80540>>>>>>>>>    End_Procedure
80541>>>>>>>>>
80541>>>>>>>>>    Function psDriverDefaultValueText Returns String
80543>>>>>>>>>        String sRetval
80543>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80545>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80546>>>>>>>>>>
80546>>>>>>>>>            Function_Return
80547>>>>>>>>>        End
80547>>>>>>>>>>
80547>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80548>>>>>>>>>        Function_Return sRetval
80549>>>>>>>>>    End_Function
80550>>>>>>>>>
80550>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80552>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80554>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80555>>>>>>>>>>
80555>>>>>>>>>            Procedure_Return
80556>>>>>>>>>        End
80556>>>>>>>>>>
80556>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80557>>>>>>>>>    End_Procedure
80558>>>>>>>>>
80558>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80560>>>>>>>>>        Boolean bState
80560>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80562>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80563>>>>>>>>>>
80563>>>>>>>>>            Function_Return
80564>>>>>>>>>        End
80564>>>>>>>>>>
80564>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80565>>>>>>>>>        Function_Return bState
80566>>>>>>>>>    End_Function
80567>>>>>>>>>
80567>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80569>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80571>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80572>>>>>>>>>>
80572>>>>>>>>>            Procedure_Return
80573>>>>>>>>>        End
80573>>>>>>>>>>
80573>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80574>>>>>>>>>    End_Procedure
80575>>>>>>>>>
80575>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80577>>>>>>>>>        Boolean bState
80577>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80579>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80580>>>>>>>>>>
80580>>>>>>>>>            Function_Return
80581>>>>>>>>>        End
80581>>>>>>>>>>
80581>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80582>>>>>>>>>        Function_Return bState
80583>>>>>>>>>    End_Function
80584>>>>>>>>>
80584>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80586>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80588>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80589>>>>>>>>>>
80589>>>>>>>>>            Procedure_Return
80590>>>>>>>>>        End
80590>>>>>>>>>>
80590>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80591>>>>>>>>>    End_Procedure
80592>>>>>>>>>
80592>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80594>>>>>>>>>        Boolean bState
80594>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80596>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80597>>>>>>>>>>
80597>>>>>>>>>            Function_Return
80598>>>>>>>>>        End
80598>>>>>>>>>>
80598>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80599>>>>>>>>>        Function_Return bState
80600>>>>>>>>>    End_Function
80601>>>>>>>>>
80601>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80603>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80605>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80606>>>>>>>>>>
80606>>>>>>>>>            Procedure_Return
80607>>>>>>>>>        End
80607>>>>>>>>>>
80607>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80608>>>>>>>>>    End_Procedure
80609>>>>>>>>>
80609>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80611>>>>>>>>>        Boolean bState
80611>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80613>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80614>>>>>>>>>>
80614>>>>>>>>>            Function_Return
80615>>>>>>>>>        End
80615>>>>>>>>>>
80615>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80616>>>>>>>>>        Function_Return bState
80617>>>>>>>>>    End_Function
80618>>>>>>>>>
80618>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80620>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80622>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80623>>>>>>>>>>
80623>>>>>>>>>            Procedure_Return
80624>>>>>>>>>        End
80624>>>>>>>>>>
80624>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80625>>>>>>>>>    End_Procedure
80626>>>>>>>>>
80626>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80628>>>>>>>>>        Boolean bState
80628>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80630>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80631>>>>>>>>>>
80631>>>>>>>>>            Function_Return
80632>>>>>>>>>        End
80632>>>>>>>>>>
80632>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80633>>>>>>>>>        Function_Return bState
80634>>>>>>>>>    End_Function
80635>>>>>>>>>
80635>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80637>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80639>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80640>>>>>>>>>>
80640>>>>>>>>>            Procedure_Return
80641>>>>>>>>>        End
80641>>>>>>>>>>
80641>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80642>>>>>>>>>    End_Procedure
80643>>>>>>>>>
80643>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80645>>>>>>>>>        Boolean bState
80645>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80647>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80648>>>>>>>>>>
80648>>>>>>>>>            Function_Return
80649>>>>>>>>>        End
80649>>>>>>>>>>
80649>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80650>>>>>>>>>        Function_Return bState
80651>>>>>>>>>    End_Function
80652>>>>>>>>>
80652>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80652>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80652>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80652>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80652>>>>>>>>>    Procedure Set psDriverID String sValue
80654>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80655>>>>>>>>>        Delegate Set psDriverID to sValue
80657>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80658>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80659>>>>>>>>>    End_Procedure
80660>>>>>>>>>
80660>>>>>>>>>    Function psDriverID Returns String
80662>>>>>>>>>        String sDriverID
80662>>>>>>>>>
80662>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80663>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80663>>>>>>>>>        Delegate Get psDriverID to sDriverID
80665>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80666>>>>>>>>>        Move False to Err
80667>>>>>>>>>
80667>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80667>>>>>>>>>        // probably used as "utilites" from a special made program and
80667>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80667>>>>>>>>>        If (sDriverID = "") Begin
80669>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80670>>>>>>>>>        End
80670>>>>>>>>>>
80670>>>>>>>>>        Function_Return sDriverID
80671>>>>>>>>>    End_Function
80672>>>>>>>>>
80672>>>>>>>>>    Procedure Set piDbType Integer iValue
80674>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80675>>>>>>>>>        Delegate Set piDbType to iValue
80677>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80678>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80679>>>>>>>>>    End_Procedure
80680>>>>>>>>>
80680>>>>>>>>>    Function piDbType Returns Integer
80682>>>>>>>>>        Integer iRetval
80682>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80683>>>>>>>>>        Function_Return iRetval
80684>>>>>>>>>    End_Function
80685>>>>>>>>>
80685>>>>>>>>>    // Returns the index for the passed sTableName
80685>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80685>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80687>>>>>>>>>        Integer iIndex iSize iCount
80687>>>>>>>>>        String[] sTablesArray
80688>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80688>>>>>>>>>
80688>>>>>>>>>        Move -1 to iIndex
80689>>>>>>>>>        Get psConnectionString to sConnectionString
80690>>>>>>>>>        Get psDatabase to sDatabase
80691>>>>>>>>>        Get psSchema   to sSchema
80692>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80693>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80694>>>>>>>>>        Decrement iSize
80695>>>>>>>>>        For iCount from 0 to iSize
80701>>>>>>>>>>
80701>>>>>>>>>            Move sTablesArray[iCount] to sVal
80702>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80704>>>>>>>>>                Move iCount to iIndex // We found it!
80705>>>>>>>>>                Move iSize to iCount  // End the loop
80706>>>>>>>>>            End
80706>>>>>>>>>>
80706>>>>>>>>>        Loop
80707>>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>        Function_Return iIndex
80708>>>>>>>>>    End_Function
80709>>>>>>>>>
80709>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80709>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80711>>>>>>>>>        String[] sReturnArray
80712>>>>>>>>>        Boolean bOK
80712>>>>>>>>>
80712>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80713>>>>>>>>>        If (bOK = False) Begin
80715>>>>>>>>>            Function_Return sReturnArray
80716>>>>>>>>>        End
80716>>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>        Case Begin
80716>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80718>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80719>>>>>>>>>                Case Break
80720>>>>>>>>>
80720>>>>>>>>>            Case Else
80720>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80721>>>>>>>>>>
80721>>>>>>>>>                Case Break
80722>>>>>>>>>        Case End
80722>>>>>>>>>
80722>>>>>>>>>        Function_Return sReturnArray
80723>>>>>>>>>    End_Function
80724>>>>>>>>>
80724>>>>>>>>>    // Returns a string array with all tables for the current database.
80724>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80726>>>>>>>>>        String[] asReturnArray
80727>>>>>>>>>        String sConnectionString sSelect
80727>>>>>>>>>        Integer iSize iCount iDbType
80727>>>>>>>>>        Boolean bOK
80727>>>>>>>>>
80727>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80729>>>>>>>>>            Function_Return asReturnArray
80730>>>>>>>>>        End
80730>>>>>>>>>>
80730>>>>>>>>>
80730>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80731>>>>>>>>>        If (bOK = False) Begin
80733>>>>>>>>>            Function_Return asReturnArray
80734>>>>>>>>>        End
80734>>>>>>>>>>
80734>>>>>>>>>        If (sSchema = "") Begin
80736>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80737>>>>>>>>>        End
80737>>>>>>>>>>
80737>>>>>>>>>
80737>>>>>>>>>        Get psConnectionString to sConnectionString
80738>>>>>>>>>
80738>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80738>>>>>>>>>        // the dbType.
80738>>>>>>>>>        Get piDbType to iDbType
80739>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80741>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80743>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80744>>>>>>>>>            End
80744>>>>>>>>>>
80744>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80746>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80747>>>>>>>>>            End
80747>>>>>>>>>>
80747>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80749>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80750>>>>>>>>>            End
80750>>>>>>>>>>
80750>>>>>>>>>        End
80750>>>>>>>>>>
80750>>>>>>>>>
80750>>>>>>>>>        Case Begin
80750>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80752>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80753>>>>>>>>>                Case Break
80754>>>>>>>>>
80754>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80757>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80758>>>>>>>>>                Case Break
80759>>>>>>>>>
80759>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80762>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80763>>>>>>>>>                Case Break
80764>>>>>>>>>
80764>>>>>>>>>            Case Else
80764>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80765>>>>>>>>>>
80765>>>>>>>>>                Case Break
80766>>>>>>>>>        Case End
80766>>>>>>>>>
80766>>>>>>>>>        Function_Return asReturnArray
80767>>>>>>>>>    End_Function
80768>>>>>>>>>
80768>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80768>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80770>>>>>>>>>        String[] sReturnArray
80771>>>>>>>>>        Boolean bOK
80771>>>>>>>>>
80771>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80772>>>>>>>>>        If (bOK = False) Begin
80774>>>>>>>>>            Function_Return sReturnArray
80775>>>>>>>>>        End
80775>>>>>>>>>>
80775>>>>>>>>>
80775>>>>>>>>>        Case Begin
80775>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80777>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80778>>>>>>>>>                Case Break
80779>>>>>>>>>
80779>>>>>>>>>            Case Else
80779>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80780>>>>>>>>>>
80780>>>>>>>>>                Case Break
80781>>>>>>>>>        Case End
80781>>>>>>>>>
80781>>>>>>>>>        Function_Return sReturnArray
80782>>>>>>>>>    End_Function
80783>>>>>>>>>
80783>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80783>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80785>>>>>>>>>        String[] sReturnArray
80786>>>>>>>>>        String sConnectionString sSelect sSchema
80786>>>>>>>>>        Boolean bOK
80786>>>>>>>>>        Integer iDbType
80786>>>>>>>>>
80786>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80787>>>>>>>>>        If (bOK = False) Begin
80789>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80790>>>>>>>>>>
80790>>>>>>>>>            Function_Return sReturnArray
80791>>>>>>>>>        End
80791>>>>>>>>>>
80791>>>>>>>>>
80791>>>>>>>>>        Get psConnectionString to sConnectionString
80792>>>>>>>>>        Get psSchema to sSchema
80793>>>>>>>>>
80793>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80793>>>>>>>>>        // the dbType.
80793>>>>>>>>>        Get piDbType to iDbType
80794>>>>>>>>>
80794>>>>>>>>>        Case Begin
80794>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80796>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80798>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80799>>>>>>>>>                End
80799>>>>>>>>>>
80799>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80801>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80802>>>>>>>>>                End
80802>>>>>>>>>>
80802>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80804>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80805>>>>>>>>>                End
80805>>>>>>>>>>
80805>>>>>>>>>
80805>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80806>>>>>>>>>                Case Break
80807>>>>>>>>>
80807>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80810>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80811>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80812>>>>>>>>>                Case Break
80813>>>>>>>>>
80813>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80816>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80817>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80818>>>>>>>>>                Case Break
80819>>>>>>>>>
80819>>>>>>>>>            Case Else
80819>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80820>>>>>>>>>>
80820>>>>>>>>>                Case Break
80821>>>>>>>>>        Case End
80821>>>>>>>>>
80821>>>>>>>>>        Function_Return sReturnArray
80822>>>>>>>>>    End_Function
80823>>>>>>>>>
80823>>>>>>>>>
80823>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80823>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80825>>>>>>>>>        String[] sReturnArray sReturnArray2
80827>>>>>>>>>        String sConnectionString sSelect sSchema
80827>>>>>>>>>        Boolean bOK
80827>>>>>>>>>        Integer iCount iSize
80827>>>>>>>>>
80827>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80828>>>>>>>>>        If (bOK = False) Begin
80830>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80831>>>>>>>>>>
80831>>>>>>>>>            Function_Return sReturnArray
80832>>>>>>>>>        End
80832>>>>>>>>>>
80832>>>>>>>>>
80832>>>>>>>>>        Get psConnectionString to sConnectionString
80833>>>>>>>>>        Get psSchema to sSchema
80834>>>>>>>>>
80834>>>>>>>>>        Case Begin
80834>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80836>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80837>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80838>>>>>>>>>                Case Break
80839>>>>>>>>>
80839>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80842>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80843>>>>>>>>>>
80843>>>>>>>>>//                Move () to sSelect
80843>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80843>>>>>>>>>                Case Break
80844>>>>>>>>>
80844>>>>>>>>>            Case Else
80844>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80845>>>>>>>>>>
80845>>>>>>>>>                Case Break
80846>>>>>>>>>        Case End
80846>>>>>>>>>
80846>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80847>>>>>>>>>        Decrement iSize
80848>>>>>>>>>        For iCount from 0 to iSize
80854>>>>>>>>>>
80854>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80856>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80857>>>>>>>>>            End
80857>>>>>>>>>>
80857>>>>>>>>>        Loop
80858>>>>>>>>>>
80858>>>>>>>>>
80858>>>>>>>>>        Function_Return sReturnArray2
80859>>>>>>>>>    End_Function
80860>>>>>>>>>
80860>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80860>>>>>>>>>    // The format of the array is "TableName.FieldName"
80860>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80862>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80864>>>>>>>>>        tSQLRelation[] sRelationsArray
80864>>>>>>>>>        tSQLRelation[] sRelationsArray
80865>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80865>>>>>>>>>        Boolean bOK
80865>>>>>>>>>        Integer iCount iSize iLength
80865>>>>>>>>>
80865>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80866>>>>>>>>>        If (bOK = False) Begin
80868>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80869>>>>>>>>>>
80869>>>>>>>>>            Function_Return sRelationsArray
80870>>>>>>>>>        End
80870>>>>>>>>>>
80870>>>>>>>>>
80870>>>>>>>>>        Get psConnectionString to sConnectionString
80871>>>>>>>>>        Get psSchema to sSchema
80872>>>>>>>>>
80872>>>>>>>>>        Case Begin
80872>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80874>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80875>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80876>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80877>>>>>>>>>                Case Break
80878>>>>>>>>>
80878>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80881>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80882>>>>>>>>>>
80882>>>>>>>>>//                Move () to sSelect
80882>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80882>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80882>>>>>>>>>                Case Break
80883>>>>>>>>>
80883>>>>>>>>>            Case Else
80883>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80884>>>>>>>>>>
80884>>>>>>>>>                Case Break
80885>>>>>>>>>        Case End
80885>>>>>>>>>
80885>>>>>>>>>        Move (Length(sTableName)) to iLength
80886>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80887>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80888>>>>>>>>>        Decrement iSize
80889>>>>>>>>>        For iCount from 0 to iSize
80895>>>>>>>>>>
80895>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80897>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80898>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80899>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80900>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80901>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80902>>>>>>>>>            End
80902>>>>>>>>>>
80902>>>>>>>>>        Loop
80903>>>>>>>>>>
80903>>>>>>>>>
80903>>>>>>>>>        Function_Return sRelationsArray
80904>>>>>>>>>    End_Function
80905>>>>>>>>>
80905>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80907>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80907>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80908>>>>>>>>>        String[] sUsers sPrograms
80910>>>>>>>>>        String sSelect
80910>>>>>>>>>        Integer iSize iCount
80910>>>>>>>>>
80910>>>>>>>>>        Case Begin
80910>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80912>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80913>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80914>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80915>>>>>>>>>                Case Break
80916>>>>>>>>>            Case Else
80916>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80917>>>>>>>>>>
80917>>>>>>>>>        Case End
80917>>>>>>>>>
80917>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80918>>>>>>>>>        Decrement iSize
80919>>>>>>>>>        For iCount from 0 to iSize
80925>>>>>>>>>>
80925>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80926>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80927>>>>>>>>>        Loop
80928>>>>>>>>>>
80928>>>>>>>>>
80928>>>>>>>>>        Function_Return SQLLoggedInUser
80929>>>>>>>>>    End_Function
80930>>>>>>>>>
80930>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80930>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80930>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80932>>>>>>>>>        String[] sFilesData
80933>>>>>>>>>        Boolean bExists
80933>>>>>>>>>        Integer iCh
80933>>>>>>>>>        String sFileName sExt
80933>>>>>>>>>
80933>>>>>>>>>        Get vFolderExists sDataPath to bExists
80934>>>>>>>>>        If (bExists = True) Begin
80936>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80937>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80938>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80939>>>>>>>>>            Direct_Input channel iCh sDataPath
80941>>>>>>>>>                Repeat
80941>>>>>>>>>>
80941>>>>>>>>>                    Readln channel iCh sFileName
80943>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80944>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80946>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80948>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80949>>>>>>>>>                        End
80949>>>>>>>>>>
80949>>>>>>>>>                    End
80949>>>>>>>>>>
80949>>>>>>>>>                Until (SeqEof = True)
80951>>>>>>>>>            Close_Input channel iCh
80953>>>>>>>>>            Send Seq_Release_Channel iCh
80954>>>>>>>>>        End
80954>>>>>>>>>>
80954>>>>>>>>>        Function_Return sFilesData
80955>>>>>>>>>    End_Function
80956>>>>>>>>>
80956>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80956>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80958>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80958>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80958>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80958>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80958>>>>>>>>>        tSQLConnection SQLConnection
80958>>>>>>>>>        tSQLConnection SQLConnection
80958>>>>>>>>>        String[] asCollations
80959>>>>>>>>>        
80959>>>>>>>>>        If (sDriverID = "") Begin
80961>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80962>>>>>>>>>>
80962>>>>>>>>>            Function_Return asCollations
80963>>>>>>>>>        End
80963>>>>>>>>>>
80963>>>>>>>>>
80963>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80963>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80965>>>>>>>>>            Function_Return asCollations
80966>>>>>>>>>        End                 
80966>>>>>>>>>>
80966>>>>>>>>>
80966>>>>>>>>>        Get phoSQLManager to hoSQLManager
80967>>>>>>>>>        Get psConnectionID     to sConnectionID
80968>>>>>>>>>        Get psConnectionString to sConnectionString
80969>>>>>>>>>        Move 0 to LastErr
80970>>>>>>>>>
80970>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80971>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80972>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80973>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80975>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80976>>>>>>>>>>
80976>>>>>>>>>            Function_Return asCollations
80977>>>>>>>>>        End
80977>>>>>>>>>>
80977>>>>>>>>>
80977>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80978>>>>>>>>>
80978>>>>>>>>>        If (hStmt = 0) Begin
80980>>>>>>>>>            Send SqlDisconnect of hoSQLManager
80981>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80982>>>>>>>>>>
80982>>>>>>>>>            Function_Return asCollations
80983>>>>>>>>>        End
80983>>>>>>>>>>
80983>>>>>>>>>
80983>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80984>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80985>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80986>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80987>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80988>>>>>>>>>
80988>>>>>>>>>        // MS-SQL Syntax:  
80988>>>>>>>>>        // SELECT name, description
80988>>>>>>>>>        //   from sys.fn_helpcollations();
80988>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80989>>>>>>>>>
80989>>>>>>>>>        Move 1 to iColumn
80990>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
80991>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80992>>>>>>>>>        Repeat
80992>>>>>>>>>>
80992>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
80993>>>>>>>>>            If (iFetchResult <> 0) Begin
80995>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80996>>>>>>>>>                If (sValue <> sPrevious) Begin         
80998>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
80998>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
80998>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80999>>>>>>>>>                    If (iPos <> 1) Begin
81001>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81002>>>>>>>>>                    End
81002>>>>>>>>>>
81002>>>>>>>>>                End
81002>>>>>>>>>>
81002>>>>>>>>>                Move sValue to sPrevious
81003>>>>>>>>>            End
81003>>>>>>>>>>
81003>>>>>>>>>        Until (iFetchResult = 0)
81005>>>>>>>>>        Send SQLClose of hStmt
81006>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81007>>>>>>>>>
81007>>>>>>>>>        Function_Return asCollations
81008>>>>>>>>>    End_Function
81009>>>>>>>>>
81009>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81009>>>>>>>>>    // for DAW drivers.
81009>>>>>>>>>    // Returns: A string array.
81009>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81011>>>>>>>>>        String[] sReturnArray
81012>>>>>>>>>        String sValue sPrevious
81012>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81012>>>>>>>>>        Integer iFetchResult iRows
81012>>>>>>>>>        tSQLConnection SQLConnection
81012>>>>>>>>>        tSQLConnection SQLConnection
81012>>>>>>>>>
81012>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81013>>>>>>>>>
81013>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81015>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81016>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81017>>>>>>>>>
81017>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81019>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81020>>>>>>>>>                If (hstmt <> 0) Begin
81022>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81023>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81024>>>>>>>>>                    Repeat
81024>>>>>>>>>>
81024>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81025>>>>>>>>>                        If (iFetchResult <> 0) Begin
81027>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81028>>>>>>>>>                            If (sValue <> sPrevious) Begin
81030>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81031>>>>>>>>>                            End
81031>>>>>>>>>>
81031>>>>>>>>>                            Move sValue to sPrevious
81032>>>>>>>>>                        End
81032>>>>>>>>>>
81032>>>>>>>>>                    Until (iFetchResult = 0)
81034>>>>>>>>>                    Send SQLClose of hstmt
81035>>>>>>>>>                End
81035>>>>>>>>>>
81035>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81036>>>>>>>>>            End
81036>>>>>>>>>>
81036>>>>>>>>>        End
81036>>>>>>>>>>
81036>>>>>>>>>
81036>>>>>>>>>        Function_Return sReturnArray
81037>>>>>>>>>    End_Function
81038>>>>>>>>>
81038>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81040>>>>>>>>>        String[] sReturnArray
81041>>>>>>>>>        String sDataSource
81041>>>>>>>>>        Handle hoSQLHandler
81041>>>>>>>>>        Integer iItem
81041>>>>>>>>>
81041>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81042>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81043>>>>>>>>>
81043>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81044>>>>>>>>>
81044>>>>>>>>>        Repeat
81044>>>>>>>>>>
81044>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81045>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81046>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81047>>>>>>>>>            Increment iItem
81048>>>>>>>>>        Until (sDataSource = "")
81050>>>>>>>>>
81050>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81051>>>>>>>>>
81051>>>>>>>>>        Function_Return sReturnArray
81052>>>>>>>>>    End_Function
81053>>>>>>>>>
81053>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81055>>>>>>>>>        String[] sReturnArray
81056>>>>>>>>>        String sDataSource
81056>>>>>>>>>        Handle hoSQLHandler
81056>>>>>>>>>        Integer iItem
81056>>>>>>>>>
81056>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81057>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81058>>>>>>>>>
81058>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81059>>>>>>>>>
81059>>>>>>>>>        Repeat
81059>>>>>>>>>>
81059>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81060>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81062>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81063>>>>>>>>>                Increment iItem
81064>>>>>>>>>            End
81064>>>>>>>>>>
81064>>>>>>>>>        Until (sDataSource = "")
81066>>>>>>>>>
81066>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81067>>>>>>>>>
81067>>>>>>>>>        Function_Return sReturnArray
81068>>>>>>>>>    End_Function
81069>>>>>>>>>
81069>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81071>>>>>>>>>        String[] sDataSources
81072>>>>>>>>>        tSQLConnection SQLConnection
81072>>>>>>>>>        tSQLConnection SQLConnection
81072>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81072>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81073>>>>>>>>>        Integer iDataSources iCount iItem
81073>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81073>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81073>>>>>>>>>        Boolean bExists bKeyOpened
81073>>>>>>>>>
81073>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81074>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81075>>>>>>>>>        Move SQLConnection.sServer           to sServer
81076>>>>>>>>>
81076>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81076>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81078>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81079>>>>>>>>>            Set psFileName of hoIniFile to sServer
81080>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81081>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81082>>>>>>>>>            Send Destroy of hoIniFile
81083>>>>>>>>>        End
81083>>>>>>>>>>
81083>>>>>>>>>
81083>>>>>>>>>        // DSN - read DATABASE name from the registry
81083>>>>>>>>>        Else Begin
81084>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81085>>>>>>>>>
81085>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81085>>>>>>>>>            // most probably place the info is kept that we're after.
81085>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81086>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81087>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81088>>>>>>>>>            If (bExists = True) Begin
81090>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81091>>>>>>>>>            End
81091>>>>>>>>>>
81091>>>>>>>>>            Else Begin
81092>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81093>>>>>>>>>            End
81093>>>>>>>>>>
81093>>>>>>>>>
81093>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81094>>>>>>>>>            If (bExists) Begin
81096>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81097>>>>>>>>>                If (bKeyOpened) Begin
81099>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81100>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81101>>>>>>>>>                    If (iDataSources > 0) Begin
81103>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81104>>>>>>>>>                        Decrement iDataSources
81105>>>>>>>>>                        for iCount from 0 to iDataSources
81111>>>>>>>>>>
81111>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81112>>>>>>>>>                        Loop
81113>>>>>>>>>>
81113>>>>>>>>>                        Move 0 to iItem
81114>>>>>>>>>                        for iCount from 0 to iDataSources
81120>>>>>>>>>>
81120>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81121>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81122>>>>>>>>>                            If (bKeyOpened = True) Begin
81124>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81125>>>>>>>>>                                If (bExists = True) Begin
81127>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81128>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81129>>>>>>>>>                                    Increment iItem
81130>>>>>>>>>                                End
81130>>>>>>>>>>
81130>>>>>>>>>                            End
81130>>>>>>>>>>
81130>>>>>>>>>                        Loop
81131>>>>>>>>>>
81131>>>>>>>>>                    End
81131>>>>>>>>>>
81131>>>>>>>>>                    Send CloseKey of hoRegistry
81132>>>>>>>>>                    Send Destroy of hoODBCDataSources
81133>>>>>>>>>                End
81133>>>>>>>>>>
81133>>>>>>>>>            End
81133>>>>>>>>>>
81133>>>>>>>>>
81133>>>>>>>>>            // We then check the "User DNS" area in the registry.
81133>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81134>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81135>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81136>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81137>>>>>>>>>
81137>>>>>>>>>            If (bExists) Begin
81139>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81140>>>>>>>>>                If (bKeyOpened) Begin
81142>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81143>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81144>>>>>>>>>                    If (iDataSources > 0) Begin
81146>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81147>>>>>>>>>                        Decrement iDataSources
81148>>>>>>>>>                        for iCount from 0 to iDataSources
81154>>>>>>>>>>
81154>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81155>>>>>>>>>                        Loop
81156>>>>>>>>>>
81156>>>>>>>>>                        for iCount from 0 to iDataSources
81162>>>>>>>>>>
81162>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81163>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81164>>>>>>>>>                            If (bKeyOpened = True) Begin
81166>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81167>>>>>>>>>                                If (bExists = True) Begin
81169>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81170>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81171>>>>>>>>>                                    Increment iItem
81172>>>>>>>>>                                End
81172>>>>>>>>>>
81172>>>>>>>>>                            End
81172>>>>>>>>>>
81172>>>>>>>>>                        Loop
81173>>>>>>>>>>
81173>>>>>>>>>                    End
81173>>>>>>>>>>
81173>>>>>>>>>                    Send CloseKey of hoRegistry
81174>>>>>>>>>                    Send Destroy of hoODBCDataSources
81175>>>>>>>>>                End
81175>>>>>>>>>>
81175>>>>>>>>>            End
81175>>>>>>>>>>
81175>>>>>>>>>
81175>>>>>>>>>            Send Destroy of hoRegistry
81176>>>>>>>>>        End
81176>>>>>>>>>>
81176>>>>>>>>>
81176>>>>>>>>>        Function_Return sReturnArray
81177>>>>>>>>>    End_Function
81178>>>>>>>>>
81178>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81178>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81178>>>>>>>>>    // insert it for scriplets to come after the first one.
81178>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81180>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81180>>>>>>>>>        Integer iStart iEnd iDbType
81180>>>>>>>>>        Boolean bOK
81180>>>>>>>>>
81180>>>>>>>>>        Get piDbType to iDbType
81181>>>>>>>>>        Get psDriverID to sDriverID
81182>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81183>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81184>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81185>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81186>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81187>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81189>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81190>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81191>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81192>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81193>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81194>>>>>>>>>        End
81194>>>>>>>>>>
81194>>>>>>>>>        Else Begin
81195>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81196>>>>>>>>>
81196>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81196>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81198>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81199>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81200>>>>>>>>>            End
81200>>>>>>>>>>
81200>>>>>>>>>
81200>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81200>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81200>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81200>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81203>>>>>>>>>                // Make sure we only have one space between statements/words.
81203>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81204>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81205>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81206>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81207>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81208>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81210>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81211>>>>>>>>>                End
81211>>>>>>>>>>
81211>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81212>>>>>>>>>                // Remove data view as it already exists!
81212>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81213>>>>>>>>>            End
81213>>>>>>>>>>
81213>>>>>>>>>        End
81213>>>>>>>>>>
81213>>>>>>>>>
81213>>>>>>>>>        Function_Return sStmt
81214>>>>>>>>>    End_Function
81215>>>>>>>>>
81215>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81215>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81217>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81217>>>>>>>>>        Integer iRetval
81217>>>>>>>>>        Boolean bOK
81217>>>>>>>>>
81217>>>>>>>>>        Get psDriverID to sDriverID
81218>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81219>>>>>>>>>
81219>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81220>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81221>>>>>>>>>        Set psSQLStatementString to sSQLString
81222>>>>>>>>>
81222>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81222>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81222>>>>>>>>>        Move False to Err
81223>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81224>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81225>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81226>>>>>>>>>        Move 0 to LastErr
81227>>>>>>>>>
81227>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81227>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81228>>>>>>>>>
81228>>>>>>>>>        Function_Return (Err = False)
81229>>>>>>>>>    End_Function
81230>>>>>>>>>
81230>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81230>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81232>>>>>>>>>        String sRetval
81232>>>>>>>>>        Integer iDbType iIndex
81232>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81232>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81233>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81233>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81233>>>>>>>>>
81233>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81233>>>>>>>>>        Move "" to sRetval
81234>>>>>>>>>        Get piDbType to iDbType
81235>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81236>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81237>>>>>>>>>
81237>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81238>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81239>>>>>>>>>        If (iIndex >= 0) Begin
81241>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81242>>>>>>>>>        End
81242>>>>>>>>>>
81242>>>>>>>>>
81242>>>>>>>>>        Function_Return sRetval
81243>>>>>>>>>    End_Function
81244>>>>>>>>>
81244>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81244>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81246>>>>>>>>>        String[] sSQLScriptArray
81247>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81247>>>>>>>>>        Integer iSize iCount
81247>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81247>>>>>>>>>
81247>>>>>>>>>        Move False to bCommentStart
81248>>>>>>>>>        Move False to bCommentEnd
81249>>>>>>>>>        Move False to bDashComment
81250>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81251>>>>>>>>>        Move "*/"  to sCommentEnd
81252>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81253>>>>>>>>>
81253>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81254>>>>>>>>>        Decrement iSize
81255>>>>>>>>>        Move "" to sText
81256>>>>>>>>>
81256>>>>>>>>>        for iCount from 0 to iSize
81262>>>>>>>>>>
81262>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81263>>>>>>>>>            Move (Trim(sLine)) to sTmp
81264>>>>>>>>>            If (sTmp <> "") Begin
81266>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81267>>>>>>>>>                If (bCommentStart = False) Begin
81269>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81270>>>>>>>>>                    If (bCommentStart = False) Begin
81272>>>>>>>>>                    End
81272>>>>>>>>>>
81272>>>>>>>>>                End
81272>>>>>>>>>>
81272>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81273>>>>>>>>>                If (bCommentEnd = True) Begin
81275>>>>>>>>>                    Move False to bCommentStart
81276>>>>>>>>>                End
81276>>>>>>>>>>
81276>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81278>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81279>>>>>>>>>                End
81279>>>>>>>>>>
81279>>>>>>>>>            End
81279>>>>>>>>>>
81279>>>>>>>>>        Loop
81280>>>>>>>>>>
81280>>>>>>>>>
81280>>>>>>>>>        // Update the retval struct array:
81280>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81281>>>>>>>>>        Function_Return SqlScriptArray
81282>>>>>>>>>    End_Function
81283>>>>>>>>>
81283>>>>>>>>>    // Helper function that builds a string like;
81283>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81283>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81285>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81285>>>>>>>>>
81285>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81286>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81287>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81288>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81289>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81290>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81291>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81292>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81293>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81294>>>>>>>>>        Function_Return sRetval
81295>>>>>>>>>    End_Function
81296>>>>>>>>>
81296>>>>>>>>>    // Helper function to create a SQL statement like;
81296>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81296>>>>>>>>>    // Used for checking if an index exists.
81296>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81298>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81298>>>>>>>>>
81298>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81299>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81300>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81301>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81302>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81303>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81304>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81305>>>>>>>>>
81305>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81306>>>>>>>>>
81306>>>>>>>>>        Function_Return sRetval
81307>>>>>>>>>    End_Function
81308>>>>>>>>>
81308>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81308>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81308>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81310>>>>>>>>>        String sRetval
81310>>>>>>>>>        If (iLength <> 0) Begin
81312>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81313>>>>>>>>>            If (iDecimals <> 0) Begin
81315>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81316>>>>>>>>>            End
81316>>>>>>>>>>
81316>>>>>>>>>            Move (sRetval + ")") to sRetval
81317>>>>>>>>>        End
81317>>>>>>>>>>
81317>>>>>>>>>        Function_Return sRetval
81318>>>>>>>>>    End_Function
81319>>>>>>>>>
81319>>>>>>>>>    // Checks that the passed sDriverID is defined.
81319>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81319>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81321>>>>>>>>>        Boolean bOK
81321>>>>>>>>>        Integer iDriver
81321>>>>>>>>>
81321>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81323>>>>>>>>>            Function_Return False
81324>>>>>>>>>        End
81324>>>>>>>>>>
81324>>>>>>>>>
81324>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81325>>>>>>>>>
81325>>>>>>>>>        If (bOK = False) Begin
81327>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81328>>>>>>>>>>
81328>>>>>>>>>            Function_Return False
81329>>>>>>>>>        End
81329>>>>>>>>>>
81329>>>>>>>>>
81329>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81330>>>>>>>>>        If (iDriver = 0) Begin
81332>>>>>>>>>            Load_Driver sDriverID
81333>>>>>>>>>        End
81333>>>>>>>>>>
81333>>>>>>>>>
81333>>>>>>>>>        Function_Return True
81334>>>>>>>>>    End_Function
81335>>>>>>>>>
81335>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81335>>>>>>>>>    // This is only of concern for certain SQL data types.
81335>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81337>>>>>>>>>        Integer iLength
81337>>>>>>>>>        Boolean bOK bCheckTypeLength
81337>>>>>>>>>
81337>>>>>>>>>        If (num_arguments > 1) Begin
81339>>>>>>>>>            Move iLen to iLength
81340>>>>>>>>>        End
81340>>>>>>>>>>
81340>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81341>>>>>>>>>
81341>>>>>>>>>        If (bCheckTypeLength = True) Begin
81343>>>>>>>>>            Move (iLength > 0) to bOK
81344>>>>>>>>>        End
81344>>>>>>>>>>
81344>>>>>>>>>
81344>>>>>>>>>        Function_Return (bOK = True)
81345>>>>>>>>>    End_Function
81346>>>>>>>>>
81346>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81348>>>>>>>>>        String sVal sSchema sDriverID
81348>>>>>>>>>        Integer iDbType
81348>>>>>>>>>
81348>>>>>>>>>        If (Trim(sTableName) = "") Begin
81350>>>>>>>>>            Function_Return ""
81351>>>>>>>>>        End
81351>>>>>>>>>>
81351>>>>>>>>>
81351>>>>>>>>>        Get psDriverID to sDriverID
81352>>>>>>>>>        Get piDbType   to iDbType
81353>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81355>>>>>>>>>            Get psUserID to sSchema
81356>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81356>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81357>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81358>>>>>>>>>            Function_Return sTableName
81359>>>>>>>>>        End
81359>>>>>>>>>>
81359>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81361>>>>>>>>>            Get psDatabase to sVal
81362>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81363>>>>>>>>>            Function_Return sTableName
81364>>>>>>>>>        End
81364>>>>>>>>>>
81364>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81366>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81367>>>>>>>>>            Function_Return sTableName
81368>>>>>>>>>        End
81368>>>>>>>>>>
81368>>>>>>>>>
81368>>>>>>>>>        Get psSchema to sSchema
81369>>>>>>>>>        If (sSchema = "") Begin
81371>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81372>>>>>>>>>        End
81372>>>>>>>>>>
81372>>>>>>>>>
81372>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81373>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81375>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81377>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81378>>>>>>>>>            End
81378>>>>>>>>>>
81378>>>>>>>>>            Else Begin
81379>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81380>>>>>>>>>            End
81380>>>>>>>>>>
81380>>>>>>>>>        End
81380>>>>>>>>>>
81380>>>>>>>>>
81380>>>>>>>>>        Function_Return sTableName
81381>>>>>>>>>    End_Function
81382>>>>>>>>>
81382>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81382>>>>>>>>>    // the passed sFieldName has the correct spelling.
81382>>>>>>>>>    // Used with Embedded SQL statement calls.
81382>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81382>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81384>>>>>>>>>        String sRetval sValue sDriverID
81384>>>>>>>>>        String[] sColumnNamesArray
81385>>>>>>>>>        Integer iCount iColumns
81385>>>>>>>>>
81385>>>>>>>>>        Move "" to sRetval
81386>>>>>>>>>        Get psDriverID to sDriverID
81387>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81388>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81389>>>>>>>>>        Decrement iColumns
81390>>>>>>>>>
81390>>>>>>>>>        For iCount from 0 to iColumns
81396>>>>>>>>>>
81396>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81397>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81399>>>>>>>>>                Move sValue to sRetval
81400>>>>>>>>>                Move iColumns to iCount // We're done.
81401>>>>>>>>>            End
81401>>>>>>>>>>
81401>>>>>>>>>        Loop
81402>>>>>>>>>>
81402>>>>>>>>>
81402>>>>>>>>>        Function_Return sRetval
81403>>>>>>>>>    End_Function
81404>>>>>>>>>
81404>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81406>>>>>>>>>        String[] sReturnArray
81407>>>>>>>>>        Handle hoSQLHandler
81407>>>>>>>>>        Integer iCount iSize iItem
81407>>>>>>>>>        String sServer
81407>>>>>>>>>        tSQLConnection SQLConnection
81407>>>>>>>>>        tSQLConnection SQLConnection
81407>>>>>>>>>
81407>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81408>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81409>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81410>>>>>>>>>
81410>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81411>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81412>>>>>>>>>        Decrement iSize
81413>>>>>>>>>
81413>>>>>>>>>        For iCount from 0 to iSize
81419>>>>>>>>>>
81419>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81420>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81421>>>>>>>>>            Increment iItem
81422>>>>>>>>>        Loop
81423>>>>>>>>>>
81423>>>>>>>>>
81423>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81424>>>>>>>>>
81424>>>>>>>>>        Function_Return sReturnArray
81425>>>>>>>>>    End_Function
81426>>>>>>>>>
81426>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81428>>>>>>>>>        String[] sReturnArray
81429>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81429>>>>>>>>>        Handle hoSQLHandler
81429>>>>>>>>>        Integer iCount iSize iItem iPos
81429>>>>>>>>>        Boolean bOK
81429>>>>>>>>>        tSQLConnection SQLConnection
81429>>>>>>>>>        tSQLConnection SQLConnection
81429>>>>>>>>>
81429>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81430>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81432>>>>>>>>>            Function_Return sReturnArray
81433>>>>>>>>>        End
81433>>>>>>>>>>
81433>>>>>>>>>
81433>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81434>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81435>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81436>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81437>>>>>>>>>
81437>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81438>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81439>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81440>>>>>>>>>
81440>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81441>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81442>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81442>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81442>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81442>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81442>>>>>>>>>//                If (iPos > 0) Begin
81442>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81442>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81442>>>>>>>>>//                End
81442>>>>>>>>>//            End
81442>>>>>>>>>//        End
81442>>>>>>>>>
81442>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81443>>>>>>>>>        Move False to Err
81444>>>>>>>>>        Move 0 to iItem
81445>>>>>>>>>
81445>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81445>>>>>>>>>        For iCount from 1 to iSize
81451>>>>>>>>>>
81451>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81452>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81453>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81454>>>>>>>>>            If (sSchema = "") Begin
81456>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81457>>>>>>>>>            End
81457>>>>>>>>>>
81457>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81458>>>>>>>>>            Move (Trim(sTable)) to sTable
81459>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81461>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81462>>>>>>>>>            End
81462>>>>>>>>>>
81462>>>>>>>>>            Else Begin
81463>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81464>>>>>>>>>            End
81464>>>>>>>>>>
81464>>>>>>>>>            If (bOK = True) Begin
81466>>>>>>>>>                Move sTable to sReturnArray[iItem]
81467>>>>>>>>>                Increment iItem
81468>>>>>>>>>            End
81468>>>>>>>>>>
81468>>>>>>>>>        Loop
81469>>>>>>>>>>
81469>>>>>>>>>
81469>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81470>>>>>>>>>
81470>>>>>>>>>        Function_Return sReturnArray
81471>>>>>>>>>    End_Function
81472>>>>>>>>>
81472>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81474>>>>>>>>>        String[] sReturnArray
81475>>>>>>>>>        String sValue
81475>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81475>>>>>>>>>        Integer iRetval iCols iFetchResult
81475>>>>>>>>>        tSQLConnection SQLConnection
81475>>>>>>>>>        tSQLConnection SQLConnection
81475>>>>>>>>>
81475>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81476>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81477>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81478>>>>>>>>>
81478>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81480>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81481>>>>>>>>>            If (hStmt <> 0) Begin
81483>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81484>>>>>>>>>                If (sArgument <> "") Begin
81486>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81487>>>>>>>>>                End
81487>>>>>>>>>>
81487>>>>>>>>>
81487>>>>>>>>>                Send SqlCall             of hStmt
81488>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81489>>>>>>>>>                If (iRetval = 0) Begin
81491>>>>>>>>>                    Repeat
81491>>>>>>>>>>
81491>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81492>>>>>>>>>                        If (iCols > 0) Begin
81494>>>>>>>>>                            Repeat
81494>>>>>>>>>>
81494>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81495>>>>>>>>>                                If (iFetchResult <> 0) Begin
81497>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81498>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81499>>>>>>>>>                                End
81499>>>>>>>>>>
81499>>>>>>>>>                            Until (iFetchResult = 0)
81501>>>>>>>>>                        End
81501>>>>>>>>>>
81501>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81502>>>>>>>>>                    Until (iRetval = 0)
81504>>>>>>>>>                    Send SqlClose of hStmt
81505>>>>>>>>>                End
81505>>>>>>>>>>
81505>>>>>>>>>            End
81505>>>>>>>>>>
81505>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81506>>>>>>>>>        End
81506>>>>>>>>>>
81506>>>>>>>>>        Function_Return sReturnArray
81507>>>>>>>>>    End_Function
81508>>>>>>>>>
81508>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81510>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81510>>>>>>>>>        Boolean bOpened bOK
81510>>>>>>>>>
81510>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81510>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81510>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81510>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81510>>>>>>>>>        // proper .int files for the two tables.
81510>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81512>>>>>>>>>            Function_Return True
81513>>>>>>>>>        End
81513>>>>>>>>>>
81513>>>>>>>>>
81513>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81516>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81517>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81518>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81519>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81520>>>>>>>>>
81520>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81520>>>>>>>>>        Sleep 1
81521>>>>>>>>>
81521>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81524>>>>>>>>>        If (bOpened = False) Begin
81526>>>>>>>>>            Open hTable
81528>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81531>>>>>>>>>        End
81531>>>>>>>>>>
81531>>>>>>>>>        If (bOpened = False) Begin
81533>>>>>>>>>            Function_Return False
81534>>>>>>>>>        End
81534>>>>>>>>>>
81534>>>>>>>>>
81534>>>>>>>>>        Get psDriverID to sDriverID
81535>>>>>>>>>
81535>>>>>>>>>        Move False to Err
81536>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81539>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81540>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81540>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81540>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81541>>>>>>>>>
81541>>>>>>>>>        Move False to Err
81542>>>>>>>>>
81542>>>>>>>>>        If (hTable > 0) Begin
81544>>>>>>>>>            Structure_Start hTable
81545>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81548>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81551>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81553>>>>>>>>>        End
81553>>>>>>>>>>
81553>>>>>>>>>        Else Begin
81554>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81557>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81560>>>>>>>>>        End
81560>>>>>>>>>>
81560>>>>>>>>>        Function_Return (Err = False)
81561>>>>>>>>>    End_Function
81562>>>>>>>>>
81562>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81562>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81564>>>>>>>>>        Handle hTable
81564>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81564>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81564>>>>>>>>>
81564>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81565>>>>>>>>>        If (bSameTableNames = True) Begin
81567>>>>>>>>>            Function_Return True
81568>>>>>>>>>        End
81568>>>>>>>>>>
81568>>>>>>>>>
81568>>>>>>>>>        Move True to bOK
81569>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81570>>>>>>>>>        Set Private.phCurrentTable              to hTable
81571>>>>>>>>>        
81571>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81574>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81576>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81579>>>>>>>>>        End
81579>>>>>>>>>>
81579>>>>>>>>>        
81579>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81582>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81584>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81587>>>>>>>>>        End
81587>>>>>>>>>>
81587>>>>>>>>>        
81587>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81590>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81592>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81595>>>>>>>>>        End
81595>>>>>>>>>>
81595>>>>>>>>>
81595>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81597>>>>>>>>>            Get psConnectionID to sConnectionID
81598>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81599>>>>>>>>>            If (bTableExists = True) Begin
81601>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81602>>>>>>>>>            End
81602>>>>>>>>>>
81602>>>>>>>>>            Else Begin
81603>>>>>>>>>                Get pbToANSI to bANSI
81604>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81605>>>>>>>>>            End
81605>>>>>>>>>>
81605>>>>>>>>>        End
81605>>>>>>>>>>
81605>>>>>>>>>
81605>>>>>>>>>        Function_Return bOK
81606>>>>>>>>>    End_Function
81607>>>>>>>>>
81607>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81607>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81607>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81609>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81609>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81609>>>>>>>>>        String[] sIndexArray
81610>>>>>>>>>        Integer iCount iCh iSize
81610>>>>>>>>>
81610>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81611>>>>>>>>>        Get psConnectionString to sConnectionString
81612>>>>>>>>>
81612>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81613>>>>>>>>>        If (bANSI = False) Begin
81615>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81616>>>>>>>>>        End
81616>>>>>>>>>>
81616>>>>>>>>>
81616>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81617>>>>>>>>>        Get vFolderExists sDataPath to bOK
81618>>>>>>>>>        If (bOK = False) Begin
81620>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81621>>>>>>>>>>
81621>>>>>>>>>            Function_Return False
81622>>>>>>>>>        End
81622>>>>>>>>>>
81622>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81623>>>>>>>>>
81623>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81626>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81629>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81630>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81631>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81632>>>>>>>>>
81632>>>>>>>>>        Get psSchema hTable to sSchemaName
81633>>>>>>>>>        If (sSchemaName = "") Begin
81635>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81636>>>>>>>>>        End
81636>>>>>>>>>>
81636>>>>>>>>>
81636>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81636>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81637>>>>>>>>>        If (bExists = True) Begin
81639>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81640>>>>>>>>>        End
81640>>>>>>>>>>
81640>>>>>>>>>
81640>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81641>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81642>>>>>>>>>
81642>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81643>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81648>>>>>>>>>            If (bUseConnectionID = True) Begin
81650>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81657>>>>>>>>>            End
81657>>>>>>>>>>
81657>>>>>>>>>            Else Begin
81658>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81665>>>>>>>>>            End
81665>>>>>>>>>>
81665>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81670>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81675>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81675>>>>>>>>>            If (bSysFile = True) Begin
81677>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81682>>>>>>>>>            End
81682>>>>>>>>>>
81682>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81687>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81692>>>>>>>>>            If (bSysFile = True) Begin
81694>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81699>>>>>>>>>            End
81699>>>>>>>>>>
81699>>>>>>>>>
81699>>>>>>>>>            If (bSysFile = False) Begin
81701>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81702>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81703>>>>>>>>>                If (iSize > 0) Begin
81705>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81708>>>>>>>>>                    Writeln channel iCh // Just an empty line
81710>>>>>>>>>                End
81710>>>>>>>>>>
81710>>>>>>>>>                Decrement iSize
81711>>>>>>>>>                for iCount from 0 to iSize
81717>>>>>>>>>>
81717>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81720>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81723>>>>>>>>>                    Writeln channel iCh
81725>>>>>>>>>                Loop
81726>>>>>>>>>>
81726>>>>>>>>>            End
81726>>>>>>>>>>
81726>>>>>>>>>        Send Seq_Close_Channel iCh
81727>>>>>>>>>
81727>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81727>>>>>>>>>        Sleep 1
81728>>>>>>>>>
81728>>>>>>>>>        Function_Return (bOK = True)
81729>>>>>>>>>    End_Function
81730>>>>>>>>>
81730>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81732>>>>>>>>>        String sDataPath sDriverID
81732>>>>>>>>>        Boolean bOK
81732>>>>>>>>>        Integer iPos
81732>>>>>>>>>
81732>>>>>>>>>        If (sTableName contains ".") Begin
81734>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81735>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81736>>>>>>>>>        End
81736>>>>>>>>>>
81736>>>>>>>>>
81736>>>>>>>>>        Get psDriverID to sDriverID
81737>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81738>>>>>>>>>        // First delete the cache file:
81738>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81739>>>>>>>>>
81739>>>>>>>>>        Function_Return bOK
81740>>>>>>>>>    End_Function
81741>>>>>>>>>
81741>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81741>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81741>>>>>>>>>    // if it is an SQL table
81741>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81743>>>>>>>>>        Boolean bExists bIsSQLTable
81743>>>>>>>>>        String sDataPath sRootName
81743>>>>>>>>>
81743>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81744>>>>>>>>>        If (bExists = False) Begin
81746>>>>>>>>>            Function_Return False
81747>>>>>>>>>        End
81747>>>>>>>>>>
81747>>>>>>>>>
81747>>>>>>>>>        Move False to bIsSQLTable
81748>>>>>>>>>        If (hTable > 0) Begin
81750>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81753>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81754>>>>>>>>>        End
81754>>>>>>>>>>
81754>>>>>>>>>        If (bIsSQLTable = True) Begin
81756>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81757>>>>>>>>>            Function_Return bExists
81758>>>>>>>>>        End
81758>>>>>>>>>>
81758>>>>>>>>>        Else Begin
81759>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81760>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81761>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81762>>>>>>>>>        End
81762>>>>>>>>>>
81762>>>>>>>>>
81762>>>>>>>>>        Function_Return bExists
81763>>>>>>>>>    End_Function
81764>>>>>>>>>
81764>>>>>>>>>    // Pass a table handle
81764>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81764>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81766>>>>>>>>>        Handle hTable
81766>>>>>>>>>        Boolean bFound
81766>>>>>>>>>
81766>>>>>>>>>        Move False to bFound
81767>>>>>>>>>        Move 0 to hTable
81768>>>>>>>>>        Repeat
81768>>>>>>>>>>
81768>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81771>>>>>>>>>            If (hTable > 0) Begin
81773>>>>>>>>>                If (hTable = hCheckTable) Begin
81775>>>>>>>>>                    Move True to bFound
81776>>>>>>>>>                End
81776>>>>>>>>>>
81776>>>>>>>>>            End
81776>>>>>>>>>>
81776>>>>>>>>>            If (bFound = True) ;                Break
81779>>>>>>>>>        Until (hTable = 0)
81781>>>>>>>>>
81781>>>>>>>>>        Function_Return (bFound = True)
81782>>>>>>>>>    End_Function
81783>>>>>>>>>
81783>>>>>>>>>    // DataFlex Embedded Database Data Types:
81783>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81783>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81785>>>>>>>>>        tColumnType[] ColumnType
81785>>>>>>>>>        tColumnType[] ColumnType
81786>>>>>>>>>        Integer i
81786>>>>>>>>>
81786>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81787>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81788>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81789>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81790>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81791>>>>>>>>>        Increment i
81792>>>>>>>>>
81792>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81793>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81794>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81795>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81796>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81797>>>>>>>>>        Increment i
81798>>>>>>>>>
81798>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81799>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81800>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81801>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81802>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81803>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81804>>>>>>>>>        Increment i
81805>>>>>>>>>
81805>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81806>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81807>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81808>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81809>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81810>>>>>>>>>        Increment i
81811>>>>>>>>>
81811>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81812>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81813>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81814>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81815>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81816>>>>>>>>>        Increment i
81817>>>>>>>>>
81817>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81818>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81819>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81820>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81821>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81822>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81823>>>>>>>>>        Increment i
81824>>>>>>>>>
81824>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81825>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81826>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81827>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81828>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81829>>>>>>>>>
81829>>>>>>>>>        Function_Return ColumnType
81830>>>>>>>>>    End_Function
81831>>>>>>>>>
81831>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81833>>>>>>>>>        tColumnType[] aColumnType
81833>>>>>>>>>        tColumnType[] aColumnType
81834>>>>>>>>>        Integer i
81834>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81834>>>>>>>>>>// Generated By The Database Update Framework
81834>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81834>>>>>>>>>>// Driver COLUMN DATA TYPES
81834>>>>>>>>>>//
81834>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
81834>>>>>>>>>>
81834>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81835>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81836>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81837>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81838>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81839>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81840>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81841>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81842>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81843>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81844>>>>>>>>>>            Increment i
81845>>>>>>>>>>
81845>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81846>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81847>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81848>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81849>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81850>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81851>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81852>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81853>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81854>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81855>>>>>>>>>>            Increment i
81856>>>>>>>>>>
81856>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81857>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81858>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81859>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81860>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81861>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81862>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81863>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81864>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81865>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81866>>>>>>>>>>            Increment i
81867>>>>>>>>>>
81867>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81868>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81869>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81870>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81871>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81872>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81873>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81874>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81875>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81876>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81877>>>>>>>>>>            Increment i
81878>>>>>>>>>>
81878>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81879>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81880>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81881>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81882>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81883>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81884>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81885>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81886>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81887>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81888>>>>>>>>>>            Increment i
81889>>>>>>>>>>
81889>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81890>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81891>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81892>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81893>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81894>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81895>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81896>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81897>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81898>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81899>>>>>>>>>>            Increment i
81900>>>>>>>>>>
81900>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81901>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81902>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81903>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81904>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81905>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81906>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81907>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81908>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81909>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81910>>>>>>>>>>            Increment i
81911>>>>>>>>>>
81911>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81912>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81913>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81914>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81915>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81916>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81917>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81918>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81919>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81920>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81921>>>>>>>>>>            Increment i
81922>>>>>>>>>>
81922>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81923>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81924>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81925>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81926>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81927>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81928>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81929>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81930>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81931>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81932>>>>>>>>>>            Increment i
81933>>>>>>>>>>
81933>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81934>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81935>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81936>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81937>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81938>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81939>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81940>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81941>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81942>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81943>>>>>>>>>>            Increment i
81944>>>>>>>>>>
81944>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81945>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81946>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81947>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81948>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81949>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81950>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81951>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81952>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81953>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81954>>>>>>>>>>            Increment i
81955>>>>>>>>>>
81955>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81956>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81957>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81958>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81959>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81960>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81961>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81962>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81963>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81964>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81965>>>>>>>>>>            Increment i
81966>>>>>>>>>>
81966>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81967>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81968>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81969>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81970>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81971>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81972>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81973>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81974>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81975>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81976>>>>>>>>>>            Increment i
81977>>>>>>>>>>
81977>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81978>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81979>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81980>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81981>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81982>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81983>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81984>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81985>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81986>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81987>>>>>>>>>>            Increment i
81988>>>>>>>>>>
81988>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81989>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81990>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81991>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81992>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81993>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81994>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81995>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81996>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81997>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81998>>>>>>>>>>            Increment i
81999>>>>>>>>>>
81999>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82000>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82001>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82002>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82003>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82004>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82005>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82006>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82007>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82008>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82009>>>>>>>>>>            Increment i
82010>>>>>>>>>>
82010>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82011>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82012>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82013>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82014>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82015>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82016>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82017>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82018>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82019>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82020>>>>>>>>>>            Increment i
82021>>>>>>>>>>
82021>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82022>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82023>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82024>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82025>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82026>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82027>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82028>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82029>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82030>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82031>>>>>>>>>>            Increment i
82032>>>>>>>>>>
82032>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82033>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82034>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82035>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82036>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82037>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82038>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82039>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82040>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82041>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82042>>>>>>>>>>            Increment i
82043>>>>>>>>>>
82043>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82044>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82045>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82046>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82047>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82048>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82049>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82050>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82051>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82052>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82053>>>>>>>>>>            Increment i
82054>>>>>>>>>>
82054>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82055>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82056>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82057>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82058>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82059>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82060>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82061>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82062>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82063>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82064>>>>>>>>>>            Increment i
82065>>>>>>>>>>
82065>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82066>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82067>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82068>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82069>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82070>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82071>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82072>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82073>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82074>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82075>>>>>>>>>>            Increment i
82076>>>>>>>>>>
82076>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82077>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82078>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82079>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82080>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82081>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82082>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82083>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82084>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82085>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82086>>>>>>>>>>            Increment i
82087>>>>>>>>>>
82087>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82088>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82089>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82090>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82091>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82092>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82093>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82094>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82095>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82096>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82097>>>>>>>>>>            Increment i
82098>>>>>>>>>>
82098>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82099>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82100>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82101>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82102>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82103>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82104>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82105>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82106>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82107>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82108>>>>>>>>>>            Increment i
82109>>>>>>>>>>
82109>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82110>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82111>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82112>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82113>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82114>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82115>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82116>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82117>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82118>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82119>>>>>>>>>>            Increment i
82120>>>>>>>>>>
82120>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82121>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82122>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82123>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82124>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82125>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82126>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82127>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82128>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82129>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82130>>>>>>>>>>            Increment i
82131>>>>>>>>>>
82131>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82132>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82133>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82134>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82135>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82136>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82137>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82138>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82139>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82140>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82141>>>>>>>>>>            Increment i
82142>>>>>>>>>>
82142>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82143>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82144>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82145>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82146>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82147>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82148>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82149>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82150>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82151>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82152>>>>>>>>>>            Increment i
82153>>>>>>>>>>
82153>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82154>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82155>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82156>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82157>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82158>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82159>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82160>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82161>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82162>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82163>>>>>>>>>>            Increment i
82164>>>>>>>>>>
82164>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82165>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82166>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82167>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82168>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82169>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82170>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82171>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82172>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82173>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82174>>>>>>>>>>            Increment i
82175>>>>>>>>>>
82175>>>>>>>>>>
82175>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82175>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82175>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82175>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82175>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82175>>>>>>>>>//        Increment i
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>//
82175>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82175>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82175>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82175>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82175>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82175>>>>>>>>>
82175>>>>>>>>>        Function_Return aColumnType
82176>>>>>>>>>    End_Function
82177>>>>>>>>>
82177>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82177>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82177>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82179>>>>>>>>>        tColumnType[] aColumnType
82179>>>>>>>>>        tColumnType[] aColumnType
82180>>>>>>>>>        Integer i
82180>>>>>>>>>
82180>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82182>>>>>>>>>>// Generated By The Database Update Framework
82182>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82182>>>>>>>>>>// Driver COLUMN DATA TYPES
82182>>>>>>>>>>//
82182>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82182>>>>>>>>>>
82182>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82183>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82184>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82185>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82186>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82187>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82188>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82189>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82190>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82191>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82192>>>>>>>>>>            Increment i
82193>>>>>>>>>>
82193>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82194>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82195>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82196>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82197>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82198>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82199>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82200>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82201>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82202>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82203>>>>>>>>>>            Increment i
82204>>>>>>>>>>
82204>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82205>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82206>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82207>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82208>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82209>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82210>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82211>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82212>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82213>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82214>>>>>>>>>>            Increment i
82215>>>>>>>>>>
82215>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82216>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82217>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82218>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82219>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82220>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82221>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82222>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82223>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82224>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82225>>>>>>>>>>            Increment i
82226>>>>>>>>>>
82226>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82227>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82228>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82229>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82230>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82231>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82232>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82233>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82234>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82235>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82236>>>>>>>>>>            Increment i
82237>>>>>>>>>>
82237>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82238>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82239>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82240>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82241>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82242>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82243>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82244>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82245>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82246>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82247>>>>>>>>>>            Increment i
82248>>>>>>>>>>
82248>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82249>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82250>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82251>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82252>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82253>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82254>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82255>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82256>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82257>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82258>>>>>>>>>>            Increment i
82259>>>>>>>>>>
82259>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82260>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82261>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82262>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82263>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82264>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82265>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82266>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82267>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82268>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82269>>>>>>>>>>            Increment i
82270>>>>>>>>>>
82270>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82271>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82272>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82273>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82274>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82275>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82276>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82277>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82278>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82279>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82280>>>>>>>>>>            Increment i
82281>>>>>>>>>>
82281>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82282>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82283>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82284>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82285>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82286>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82287>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82288>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82289>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82290>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82291>>>>>>>>>>            Increment i
82292>>>>>>>>>>
82292>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82293>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82294>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82295>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82296>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82297>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82298>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82299>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82300>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82301>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82302>>>>>>>>>>            Increment i
82303>>>>>>>>>>
82303>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82304>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82305>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82306>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82307>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82308>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82309>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82310>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82311>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82312>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82313>>>>>>>>>>            Increment i
82314>>>>>>>>>>
82314>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82315>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82316>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82317>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82318>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82319>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82320>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82321>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82322>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82323>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82324>>>>>>>>>>            Increment i
82325>>>>>>>>>>
82325>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82326>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82327>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82328>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82329>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82330>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82331>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82332>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82333>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82334>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82335>>>>>>>>>>            Increment i
82336>>>>>>>>>>
82336>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82337>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82338>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82339>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82340>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82341>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82342>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82343>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82344>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82345>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82346>>>>>>>>>>            Increment i
82347>>>>>>>>>>
82347>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82348>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82349>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82350>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82351>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82352>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82353>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82354>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82355>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82356>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82357>>>>>>>>>>            Increment i
82358>>>>>>>>>>
82358>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82359>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82360>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82361>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82362>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82363>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82364>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82365>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82366>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82367>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82368>>>>>>>>>>            Increment i
82369>>>>>>>>>>
82369>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82370>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82371>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82372>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82373>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82374>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82375>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82376>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82377>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82378>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82379>>>>>>>>>>            Increment i
82380>>>>>>>>>>
82380>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82381>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82382>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82383>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82384>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82385>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82386>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82387>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82388>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82389>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82390>>>>>>>>>>            Increment i
82391>>>>>>>>>>
82391>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82392>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82393>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82394>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82395>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82396>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82397>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82398>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82399>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82400>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82401>>>>>>>>>>            Increment i
82402>>>>>>>>>>
82402>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82403>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82404>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82405>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82406>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82407>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82408>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82409>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82410>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82411>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82412>>>>>>>>>>            Increment i
82413>>>>>>>>>>
82413>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82414>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82415>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82416>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82417>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82418>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82419>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82420>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82421>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82422>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82423>>>>>>>>>>            Increment i
82424>>>>>>>>>>
82424>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82425>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82426>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82427>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82428>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82429>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82430>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82431>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82432>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82433>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82434>>>>>>>>>>            Increment i
82435>>>>>>>>>>
82435>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82436>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82437>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82438>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82439>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82440>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82441>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82442>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82443>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82444>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82445>>>>>>>>>>            Increment i
82446>>>>>>>>>>
82446>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82447>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82448>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82449>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82450>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82451>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82452>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82453>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82454>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82455>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82456>>>>>>>>>>            Increment i
82457>>>>>>>>>>
82457>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82458>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82459>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82460>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82461>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82462>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82463>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82464>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82465>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82466>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82467>>>>>>>>>>            Increment i
82468>>>>>>>>>>
82468>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82469>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82470>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82471>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82472>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82473>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82474>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82475>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82476>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82477>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82478>>>>>>>>>>            Increment i
82479>>>>>>>>>>
82479>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82480>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82481>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82482>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82483>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82484>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82485>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82486>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82487>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82488>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82489>>>>>>>>>>            Increment i
82490>>>>>>>>>>
82490>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82491>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82492>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82493>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82494>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82495>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82496>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82497>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82498>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82499>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82500>>>>>>>>>>            Increment i
82501>>>>>>>>>>
82501>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82502>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82503>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82504>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82505>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82506>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82507>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82508>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82509>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82510>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82511>>>>>>>>>>            Increment i
82512>>>>>>>>>>
82512>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82513>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82514>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82515>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82516>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82517>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82518>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82519>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82520>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82521>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82522>>>>>>>>>>            Increment i
82523>>>>>>>>>>
82523>>>>>>>>>>
82523>>>>>>>>>
82523>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>//
82523>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82523>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82523>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82523>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82523>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82523>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82523>>>>>>>>>//            Increment i
82523>>>>>>>>>
82523>>>>>>>>>        End
82523>>>>>>>>>>
82523>>>>>>>>>
82523>>>>>>>>>        Function_Return aColumnType
82524>>>>>>>>>    End_Function
82525>>>>>>>>>
82525>>>>>>>>>    // MySQL Data Types
82525>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82527>>>>>>>>>        tColumnType[] aColumnType
82527>>>>>>>>>        tColumnType[] aColumnType
82528>>>>>>>>>        Integer i
82528>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82528>>>>>>>>>>// Generated By The Database Update Framework
82528>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82528>>>>>>>>>>// Driver COLUMN DATA TYPES
82528>>>>>>>>>>//
82528>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82528>>>>>>>>>>
82528>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82529>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82532>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82533>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82534>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82535>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82536>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82537>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82538>>>>>>>>>>            Increment i
82539>>>>>>>>>>
82539>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82540>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82543>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82544>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82545>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82546>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82547>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82548>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82549>>>>>>>>>>            Increment i
82550>>>>>>>>>>
82550>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82551>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82552>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82554>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82555>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82556>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82557>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82558>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82559>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82560>>>>>>>>>>            Increment i
82561>>>>>>>>>>
82561>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82562>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82563>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82565>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82566>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82567>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82568>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82569>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82570>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82571>>>>>>>>>>            Increment i
82572>>>>>>>>>>
82572>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82573>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82574>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82576>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82577>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82578>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82579>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82580>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82581>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82582>>>>>>>>>>            Increment i
82583>>>>>>>>>>
82583>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82584>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82585>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82587>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82588>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82589>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82590>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82591>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82592>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82593>>>>>>>>>>            Increment i
82594>>>>>>>>>>
82594>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82595>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82596>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82598>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82599>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82600>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82601>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82602>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82603>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82604>>>>>>>>>>            Increment i
82605>>>>>>>>>>
82605>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82606>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82609>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82610>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82611>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82612>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82613>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82614>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82615>>>>>>>>>>            Increment i
82616>>>>>>>>>>
82616>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82617>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82618>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82619>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82620>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82621>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82622>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82623>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82624>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82625>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82626>>>>>>>>>>            Increment i
82627>>>>>>>>>>
82627>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82628>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82629>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82630>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82631>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82632>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82633>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82634>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82635>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82636>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82637>>>>>>>>>>            Increment i
82638>>>>>>>>>>
82638>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82639>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82640>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82641>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82642>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82643>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82644>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82645>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82646>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82647>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82648>>>>>>>>>>            Increment i
82649>>>>>>>>>>
82649>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82650>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82651>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82652>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82653>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82654>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82655>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82656>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82657>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82658>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82659>>>>>>>>>>            Increment i
82660>>>>>>>>>>
82660>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82661>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82662>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82663>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82664>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82665>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82666>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82667>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82668>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82669>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82670>>>>>>>>>>            Increment i
82671>>>>>>>>>>
82671>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82672>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82673>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82674>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82675>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82676>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82677>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82678>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82679>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82680>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82681>>>>>>>>>>            Increment i
82682>>>>>>>>>>
82682>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82683>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82684>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82685>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82686>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82687>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82688>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82689>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82690>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82691>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82692>>>>>>>>>>            Increment i
82693>>>>>>>>>>
82693>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82694>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82695>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82696>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82697>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82698>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82699>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82700>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82701>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82702>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82703>>>>>>>>>>            Increment i
82704>>>>>>>>>>
82704>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82705>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82706>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82707>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82708>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82709>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82710>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82711>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82712>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82713>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82714>>>>>>>>>>            Increment i
82715>>>>>>>>>>
82715>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82716>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82717>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82718>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82719>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82720>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82721>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82722>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82723>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82724>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82725>>>>>>>>>>            Increment i
82726>>>>>>>>>>
82726>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82727>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82728>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82729>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82730>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82731>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82732>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82733>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82734>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82735>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82736>>>>>>>>>>            Increment i
82737>>>>>>>>>>
82737>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82738>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82739>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82740>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82741>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82742>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82743>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82744>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82745>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82746>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82747>>>>>>>>>>            Increment i
82748>>>>>>>>>>
82748>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82749>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82750>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82751>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82752>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82753>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82754>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82755>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82756>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82757>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82758>>>>>>>>>>            Increment i
82759>>>>>>>>>>
82759>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82760>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82761>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82762>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82763>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82764>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82765>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82766>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82767>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82768>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82769>>>>>>>>>>            Increment i
82770>>>>>>>>>>
82770>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82771>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82772>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82773>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82774>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82775>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82776>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82777>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82778>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82779>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82780>>>>>>>>>>            Increment i
82781>>>>>>>>>>
82781>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82782>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82783>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82784>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82785>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82786>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82787>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82788>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82789>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82790>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82791>>>>>>>>>>            Increment i
82792>>>>>>>>>>
82792>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82793>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82794>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82795>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82796>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82797>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82798>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82799>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82800>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82801>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82802>>>>>>>>>>            Increment i
82803>>>>>>>>>>
82803>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82804>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82805>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82806>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82807>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82808>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82809>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82810>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82811>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82812>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82813>>>>>>>>>>            Increment i
82814>>>>>>>>>>
82814>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82815>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82816>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82817>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82818>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82819>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82820>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82821>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82822>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82823>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82824>>>>>>>>>>            Increment i
82825>>>>>>>>>>
82825>>>>>>>>>>
82825>>>>>>>>>
82825>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>//
82825>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82825>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82825>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82825>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82825>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82825>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82825>>>>>>>>>//        Increment i
82825>>>>>>>>>
82825>>>>>>>>>        Function_Return aColumnType
82826>>>>>>>>>    End_Function
82827>>>>>>>>>
82827>>>>>>>>>    // Oracle Data Types
82827>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82829>>>>>>>>>        tColumnType[] aColumnType
82829>>>>>>>>>        tColumnType[] aColumnType
82830>>>>>>>>>        Integer i
82830>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82830>>>>>>>>>>// Generated By The Database Update Framework
82830>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82830>>>>>>>>>>// Driver COLUMN DATA TYPES
82830>>>>>>>>>>//
82830>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82830>>>>>>>>>>
82830>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82831>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82834>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82835>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82836>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82837>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82838>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82839>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82840>>>>>>>>>>            Increment i
82841>>>>>>>>>>
82841>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82842>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82843>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82844>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82845>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82846>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82847>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82848>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82849>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82850>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82851>>>>>>>>>>            Increment i
82852>>>>>>>>>>
82852>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82853>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82854>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82855>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82856>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82857>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82858>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82859>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82860>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82861>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82862>>>>>>>>>>            Increment i
82863>>>>>>>>>>
82863>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82864>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82867>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82868>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82869>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82870>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82871>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82872>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82873>>>>>>>>>>            Increment i
82874>>>>>>>>>>
82874>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82875>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82876>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82878>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82879>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82880>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82881>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82882>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82883>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82884>>>>>>>>>>            Increment i
82885>>>>>>>>>>
82885>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82886>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82887>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82889>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82890>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82891>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82892>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82893>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82894>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82895>>>>>>>>>>            Increment i
82896>>>>>>>>>>
82896>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82897>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82898>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82900>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82901>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82902>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82903>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82904>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82905>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82906>>>>>>>>>>            Increment i
82907>>>>>>>>>>
82907>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82908>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82909>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82911>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82912>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82913>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82914>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82915>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82916>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82917>>>>>>>>>>            Increment i
82918>>>>>>>>>>
82918>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82919>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82920>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82921>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82922>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82923>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82924>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82925>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82926>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82927>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82928>>>>>>>>>>            Increment i
82929>>>>>>>>>>
82929>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82930>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82931>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82932>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82933>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82934>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82935>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82936>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82937>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82938>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82939>>>>>>>>>>            Increment i
82940>>>>>>>>>>
82940>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82941>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82942>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82943>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82944>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82945>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82946>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82947>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82948>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82949>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82950>>>>>>>>>>            Increment i
82951>>>>>>>>>>
82951>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82952>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82953>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82954>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82955>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82956>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82957>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82958>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82959>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82960>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82961>>>>>>>>>>            Increment i
82962>>>>>>>>>>
82962>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82963>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82964>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82965>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82966>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82967>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82968>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82969>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82970>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82971>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82972>>>>>>>>>>            Increment i
82973>>>>>>>>>>
82973>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82974>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82975>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82976>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82977>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82978>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82979>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82980>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82981>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82982>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82983>>>>>>>>>>            Increment i
82984>>>>>>>>>>
82984>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82985>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82986>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82987>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82988>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82989>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82990>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82991>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82992>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82993>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82994>>>>>>>>>>            Increment i
82995>>>>>>>>>>
82995>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82996>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82997>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82998>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82999>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83000>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83001>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83002>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83003>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83004>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83005>>>>>>>>>>            Increment i
83006>>>>>>>>>>
83006>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83007>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83008>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83009>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83010>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83011>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83012>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83013>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83014>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83015>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83016>>>>>>>>>>            Increment i
83017>>>>>>>>>>
83017>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83018>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83019>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83020>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83021>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83022>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83023>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83024>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83025>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83026>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83027>>>>>>>>>>            Increment i
83028>>>>>>>>>>
83028>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83029>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83030>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83031>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83032>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83033>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83034>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83035>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83036>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83037>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83038>>>>>>>>>>            Increment i
83039>>>>>>>>>>
83039>>>>>>>>>>
83039>>>>>>>>>
83039>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83039>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83039>>>>>>>>>//        Increment i
83039>>>>>>>>>//
83039>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83039>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83039>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83039>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83039>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83039>>>>>>>>>
83039>>>>>>>>>        Function_Return aColumnType
83040>>>>>>>>>    End_Function
83041>>>>>>>>>
83041>>>>>>>>>    // PostgreSQL Data Types
83041>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83043>>>>>>>>>        tColumnType[] aColumnType
83043>>>>>>>>>        tColumnType[] aColumnType
83044>>>>>>>>>        Integer i
83044>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83044>>>>>>>>>>// Generated By The Database Update Framework
83044>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83044>>>>>>>>>>// Driver COLUMN DATA TYPES
83044>>>>>>>>>>//
83044>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83044>>>>>>>>>>
83044>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83045>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83048>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83050>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83051>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83052>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83053>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83054>>>>>>>>>>            Increment i
83055>>>>>>>>>>
83055>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83056>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83059>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83060>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83061>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83062>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83063>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83064>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83065>>>>>>>>>>            Increment i
83066>>>>>>>>>>
83066>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83067>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83068>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83070>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83071>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83072>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83073>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83074>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83075>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83076>>>>>>>>>>            Increment i
83077>>>>>>>>>>
83077>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83078>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83079>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83081>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83082>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83083>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83084>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83085>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83086>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83087>>>>>>>>>>            Increment i
83088>>>>>>>>>>
83088>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83089>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83090>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83092>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83093>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83094>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83095>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83096>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83097>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83098>>>>>>>>>>            Increment i
83099>>>>>>>>>>
83099>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83100>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83101>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83103>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83104>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83105>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83106>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83107>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83108>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83109>>>>>>>>>>            Increment i
83110>>>>>>>>>>
83110>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83111>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83112>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83114>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83115>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83116>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83117>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83118>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83119>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83120>>>>>>>>>>            Increment i
83121>>>>>>>>>>
83121>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83122>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83123>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83125>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83126>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83127>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83128>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83129>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83130>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83131>>>>>>>>>>            Increment i
83132>>>>>>>>>>
83132>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83133>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83134>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83135>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83136>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83137>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83138>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83139>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83140>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83141>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83142>>>>>>>>>>            Increment i
83143>>>>>>>>>>
83143>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83144>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83145>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83146>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83147>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83148>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83149>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83150>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83151>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83152>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83153>>>>>>>>>>            Increment i
83154>>>>>>>>>>
83154>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83155>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83156>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83157>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83158>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83159>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83160>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83161>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83162>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83163>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83164>>>>>>>>>>            Increment i
83165>>>>>>>>>>
83165>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83166>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83167>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83168>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83169>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83170>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83171>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83172>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83173>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83174>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83175>>>>>>>>>>            Increment i
83176>>>>>>>>>>
83176>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83177>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83178>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83179>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83180>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83181>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83182>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83183>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83184>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83185>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83186>>>>>>>>>>            Increment i
83187>>>>>>>>>>
83187>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83188>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83189>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83190>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83191>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83192>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83193>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83194>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83195>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83196>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83197>>>>>>>>>>            Increment i
83198>>>>>>>>>>
83198>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83199>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83200>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83201>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83202>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83203>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83204>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83205>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83206>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83207>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83208>>>>>>>>>>            Increment i
83209>>>>>>>>>>
83209>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83210>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83211>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83212>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83213>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83214>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83215>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83216>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83217>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83218>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83219>>>>>>>>>>            Increment i
83220>>>>>>>>>>
83220>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83221>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83222>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83223>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83224>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83225>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83226>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83227>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83228>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83229>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83230>>>>>>>>>>            Increment i
83231>>>>>>>>>>
83231>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83232>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83233>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83234>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83235>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83236>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83237>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83238>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83239>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83240>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83241>>>>>>>>>>            Increment i
83242>>>>>>>>>>
83242>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83243>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83244>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83245>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83246>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83247>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83248>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83249>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83250>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83251>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83252>>>>>>>>>>            Increment i
83253>>>>>>>>>>
83253>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83254>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83255>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83256>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83257>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83258>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83259>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83260>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83261>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83262>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83263>>>>>>>>>>            Increment i
83264>>>>>>>>>>
83264>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83265>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83266>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83267>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83268>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83269>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83270>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83271>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83272>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83273>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83274>>>>>>>>>>            Increment i
83275>>>>>>>>>>
83275>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83276>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83277>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83278>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83279>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83280>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83281>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83282>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83283>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83284>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83285>>>>>>>>>>            Increment i
83286>>>>>>>>>>
83286>>>>>>>>>>
83286>>>>>>>>>
83286>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83286>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83286>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83286>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>//
83286>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83286>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83286>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83286>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83286>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83286>>>>>>>>>//        Increment i
83286>>>>>>>>>
83286>>>>>>>>>        Function_Return aColumnType
83287>>>>>>>>>    End_Function
83288>>>>>>>>>
83288>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83288>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83290>>>>>>>>>        Integer iValue iSize iCount iStart
83290>>>>>>>>>        tColumnType[] ColumnTypeArray
83290>>>>>>>>>        tColumnType[] ColumnTypeArray
83291>>>>>>>>>        tColumnType RetvalType
83291>>>>>>>>>        tColumnType RetvalType
83291>>>>>>>>>        String sValue
83291>>>>>>>>>        Boolean bFrameworkDataFlexType
83291>>>>>>>>>
83291>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83292>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83293>>>>>>>>>
83293>>>>>>>>>        Move 0 to iStart
83294>>>>>>>>>        Move (Uppercase(sType)) to sType
83295>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83296>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83298>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83299>>>>>>>>>            Function_Return RetvalType
83300>>>>>>>>>        End
83300>>>>>>>>>>
83300>>>>>>>>>
83300>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83301>>>>>>>>>
83301>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83302>>>>>>>>>        Decrement iSize
83303>>>>>>>>>
83303>>>>>>>>>        For iCount from iStart to iSize
83309>>>>>>>>>>
83309>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
83310>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
83311>>>>>>>>>            If (bIntegerInputType = True) Begin
83313>>>>>>>>>                If (iValue = iType) Begin
83315>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83316>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83317>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83318>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83319>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83320>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83321>>>>>>>>>                    Move iSize to iCount // We're done!
83322>>>>>>>>>                End
83322>>>>>>>>>>
83322>>>>>>>>>            End
83322>>>>>>>>>>
83322>>>>>>>>>            Else Begin
83323>>>>>>>>>                Move (Uppercase(sValue)) to sValue
83324>>>>>>>>>                If (sValue = sType) Begin
83326>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
83327>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
83328>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83329>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83330>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83331>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83332>>>>>>>>>                    Move iSize to iCount // We're done!
83333>>>>>>>>>                End
83333>>>>>>>>>>
83333>>>>>>>>>            End
83333>>>>>>>>>>
83333>>>>>>>>>        Loop
83334>>>>>>>>>>
83334>>>>>>>>>
83334>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
83334>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
83334>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
83336>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83337>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
83338>>>>>>>>>            Decrement iSize
83339>>>>>>>>>
83339>>>>>>>>>            For iCount from iStart to iSize
83345>>>>>>>>>>
83345>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
83346>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
83347>>>>>>>>>                If (iValue = iType) Begin
83349>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83350>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83351>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83352>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83353>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83354>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83355>>>>>>>>>                    Move iSize to iCount // We're done!
83356>>>>>>>>>                End
83356>>>>>>>>>>
83356>>>>>>>>>            Loop
83357>>>>>>>>>>
83357>>>>>>>>>        End
83357>>>>>>>>>>
83357>>>>>>>>>
83357>>>>>>>>>        Function_Return RetvalType
83358>>>>>>>>>    End_Function
83359>>>>>>>>>
83359>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83359>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83361>>>>>>>>>        tColumnType[] ColumnType
83361>>>>>>>>>        tColumnType[] ColumnType
83362>>>>>>>>>
83362>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83362>>>>>>>>>        // the dbType.
83362>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83364>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83366>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83367>>>>>>>>>            End
83367>>>>>>>>>>
83367>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83369>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83370>>>>>>>>>            End
83370>>>>>>>>>>
83370>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83372>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83373>>>>>>>>>            End
83373>>>>>>>>>>
83373>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83375>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83376>>>>>>>>>            End
83376>>>>>>>>>>
83376>>>>>>>>>        End
83376>>>>>>>>>>
83376>>>>>>>>>
83376>>>>>>>>>        Case Begin
83376>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83378>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83379>>>>>>>>>                Case Break
83380>>>>>>>>>
83380>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83383>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83384>>>>>>>>>                Case Break
83385>>>>>>>>>
83385>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83388>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83389>>>>>>>>>                Case Break
83390>>>>>>>>>        Case End
83390>>>>>>>>>
83390>>>>>>>>>        Function_Return ColumnType
83391>>>>>>>>>    End_Function
83392>>>>>>>>>
83392>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83392>>>>>>>>>    // are mapped to a DUF data type.
83392>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83394>>>>>>>>>        tColumnType ColumnType
83394>>>>>>>>>        tColumnType ColumnType
83394>>>>>>>>>        String sDataType
83394>>>>>>>>>        Integer iDriverID iCount
83394>>>>>>>>>
83394>>>>>>>>>        Move 0 to iCount
83395>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83396>>>>>>>>>
83396>>>>>>>>>        Case Begin
83396>>>>>>>>>            // DF_ASCII
83396>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83398>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83400>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83403>>>>>>>>>                End
83403>>>>>>>>>>
83403>>>>>>>>>                Else Begin
83404>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83407>>>>>>>>>                End
83407>>>>>>>>>>
83407>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83408>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83409>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83410>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83411>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83412>>>>>>>>>                Case Break
83413>>>>>>>>>
83413>>>>>>>>>            // DF_BINARY
83413>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83416>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83418>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83421>>>>>>>>>                End
83421>>>>>>>>>>
83421>>>>>>>>>                Else Begin
83422>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83425>>>>>>>>>                End
83425>>>>>>>>>>
83425>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83426>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83427>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83428>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83429>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83430>>>>>>>>>                Case Break
83431>>>>>>>>>
83431>>>>>>>>>            // DF_DATE
83431>>>>>>>>>            Case (iType = DF_DATE_DUF)
83434>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83436>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83439>>>>>>>>>                End
83439>>>>>>>>>>
83439>>>>>>>>>                Else Begin
83440>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83443>>>>>>>>>                End
83443>>>>>>>>>>
83443>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83444>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83445>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83446>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83447>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83448>>>>>>>>>                Case Break
83449>>>>>>>>>
83449>>>>>>>>>            // DF_DATETIME
83449>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83452>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83454>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83457>>>>>>>>>                End
83457>>>>>>>>>>
83457>>>>>>>>>                Else Begin
83458>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83461>>>>>>>>>                End
83461>>>>>>>>>>
83461>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83462>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83463>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83464>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83465>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83466>>>>>>>>>                Case Break
83467>>>>>>>>>
83467>>>>>>>>>            // DF_NUMERIC
83467>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83467>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83467>>>>>>>>>            // we make them here all "Numeric"...
83467>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83467>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83467>>>>>>>>>            // End
83467>>>>>>>>>            // Else Begin
83467>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83467>>>>>>>>>            // End
83467>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83467>>>>>>>>>            Case (iType = DF_BCD_DUF)
83470>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83471>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83472>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83473>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83474>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83475>>>>>>>>>                Case Break
83476>>>>>>>>>
83476>>>>>>>>>            // DF_TEXT
83476>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83479>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83481>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83484>>>>>>>>>                End
83484>>>>>>>>>>
83484>>>>>>>>>                Else Begin
83485>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83488>>>>>>>>>                End
83488>>>>>>>>>>
83488>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83489>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83490>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83491>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83492>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83493>>>>>>>>>                Case Break
83494>>>>>>>>>
83494>>>>>>>>>            Case Else
83494>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83495>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83496>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83497>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83498>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83499>>>>>>>>>
83499>>>>>>>>>        Case End
83499>>>>>>>>>
83499>>>>>>>>>        Function_Return ColumnType
83500>>>>>>>>>    End_Function
83501>>>>>>>>>
83501>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83503>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83505>>>>>>>>>        Handle hTable
83505>>>>>>>>>        Integer iIndex
83505>>>>>>>>>        String sTableName
83505>>>>>>>>>        Boolean bFlexErrs
83505>>>>>>>>>
83505>>>>>>>>>        // a) Get the exception table array the developer has specified
83505>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83506>>>>>>>>>
83506>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83506>>>>>>>>>        Repeat
83506>>>>>>>>>>
83506>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83509>>>>>>>>>            If (hTable <> 0) Begin
83511>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83514>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83515>>>>>>>>>                If (bFlexErrs = False) Begin
83517>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83519>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83520>>>>>>>>>                        If (iIndex = -1) Begin
83522>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83523>>>>>>>>>                        End
83523>>>>>>>>>>
83523>>>>>>>>>                    End
83523>>>>>>>>>>
83523>>>>>>>>>                End
83523>>>>>>>>>>
83523>>>>>>>>>            End
83523>>>>>>>>>>
83523>>>>>>>>>        Until (hTable = 0)
83525>>>>>>>>>
83525>>>>>>>>>        Move 0 to hTable
83526>>>>>>>>>
83526>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83526>>>>>>>>>        Repeat
83526>>>>>>>>>>
83526>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83529>>>>>>>>>            If (hTable > 0) Begin
83531>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83534>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83535>>>>>>>>>                If (bFlexErrs = False) Begin
83537>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83538>>>>>>>>>                    If (iIndex = -1) Begin
83540>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83541>>>>>>>>>                    End
83541>>>>>>>>>>
83541>>>>>>>>>                End
83541>>>>>>>>>>
83541>>>>>>>>>            End
83541>>>>>>>>>>
83541>>>>>>>>>        Until (hTable = 0)
83543>>>>>>>>>
83543>>>>>>>>>        Function_Return iTablesArray
83544>>>>>>>>>    End_Function
83545>>>>>>>>>
83545>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83547>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83549>>>>>>>>>        Handle hTable
83549>>>>>>>>>        Integer iIndex
83549>>>>>>>>>        String sTableName
83549>>>>>>>>>        Boolean bFlexErrs
83549>>>>>>>>>
83549>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83550>>>>>>>>>        Move 0 to hTable
83551>>>>>>>>>
83551>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83551>>>>>>>>>        Repeat
83551>>>>>>>>>>
83551>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83554>>>>>>>>>            If (hTable > 0) Begin
83556>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83559>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83560>>>>>>>>>                If (bFlexErrs = False) Begin
83562>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83563>>>>>>>>>                    If (iIndex = -1) Begin
83565>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83566>>>>>>>>>                    End
83566>>>>>>>>>>
83566>>>>>>>>>                End
83566>>>>>>>>>>
83566>>>>>>>>>            End
83566>>>>>>>>>>
83566>>>>>>>>>        Until (hTable = 0)
83568>>>>>>>>>
83568>>>>>>>>>        Function_Return iTablesArray
83569>>>>>>>>>    End_Function
83570>>>>>>>>>
83570>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83572>>>>>>>>>        tAPIColumn NewAPIColumn
83572>>>>>>>>>        tAPIColumn NewAPIColumn
83572>>>>>>>>>
83572>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83573>>>>>>>>>        Move iType      to NewAPIColumn.iType
83574>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83575>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83576>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83577>>>>>>>>>
83577>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83578>>>>>>>>>
83578>>>>>>>>>        Function_Return aCurrent
83579>>>>>>>>>    End_Function
83580>>>>>>>>>
83580>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83582>>>>>>>>>        String sRetval sFieldName
83582>>>>>>>>>        Integer iCount iSize
83582>>>>>>>>>
83582>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83583>>>>>>>>>        Decrement iSize
83584>>>>>>>>>        For iCount from 0 to iSize
83590>>>>>>>>>>
83590>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83591>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83592>>>>>>>>>        Loop
83593>>>>>>>>>>
83593>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83594>>>>>>>>>
83594>>>>>>>>>        Function_Return sRetval
83595>>>>>>>>>    End_Function
83596>>>>>>>>>
83596>>>>>>>>>    // *** Miscellaneous other functions ***
83596>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83596>>>>>>>>>    //
83596>>>>>>>>>
83596>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83596>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83598>>>>>>>>>        Integer iPerc
83598>>>>>>>>>        Number nReady nTotal
83598>>>>>>>>>
83598>>>>>>>>>        Send DoAdvance of ghoProgressBar
83599>>>>>>>>>
83599>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83601>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83602>>>>>>>>>        End
83602>>>>>>>>>>
83602>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83604>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83605>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83606>>>>>>>>>        End
83606>>>>>>>>>>
83606>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83608>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83609>>>>>>>>>        End
83609>>>>>>>>>>
83609>>>>>>>>>
83609>>>>>>>>>        Case Begin
83609>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83611>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83612>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83613>>>>>>>>>                Case Break
83614>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83617>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83618>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83619>>>>>>>>>                Case Break
83620>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83623>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83624>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83625>>>>>>>>>                Case Break
83626>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83629>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83630>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83631>>>>>>>>>                Case Break
83632>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83635>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83636>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83637>>>>>>>>>                Case Break
83638>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83641>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83642>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83643>>>>>>>>>                Case Break
83644>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83647>>>>>>>>>                Send None
83648>>>>>>>>>                Case Break
83649>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83652>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83653>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83654>>>>>>>>>                Case Break
83655>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83658>>>>>>>>>                //*** Interpret numbers
83658>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83659>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83660>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83661>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83662>>>>>>>>>                Case Break
83663>>>>>>>>>            Case Else
83663>>>>>>>>>                Set Message_Text to ""
83664>>>>>>>>>                Set Action_Text  to ""
83665>>>>>>>>>        Case End
83665>>>>>>>>>
83665>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83666>>>>>>>>>        Function_Return False
83667>>>>>>>>>    End_Function
83668>>>>>>>>>
83668>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83668>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83670>>>>>>>>>        Function_Return False
83671>>>>>>>>>    End_Function
83672>>>>>>>>>
83672>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83672>>>>>>>>>    //
83672>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83672>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83672>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83672>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83672>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83672>>>>>>>>>    //   ALTER TABLE MyTable
83672>>>>>>>>>    //       REBUILD
83672>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83674>>>>>>>>>        Boolean bOK
83674>>>>>>>>>
83674>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83676>>>>>>>>>            Function_Return False
83677>>>>>>>>>        End
83677>>>>>>>>>>
83677>>>>>>>>>
83677>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83677>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83678>>>>>>>>>
83678>>>>>>>>>        Function_Return (bOK = True)
83679>>>>>>>>>    End_Function
83680>>>>>>>>>
83680>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83680>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83680>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83680>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83680>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83680>>>>>>>>>    //   ALTER TABLE MyTable
83680>>>>>>>>>    //       REBUILD
83680>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83682>>>>>>>>>        tSQLScriptArray SQLScriptArray
83682>>>>>>>>>        tSQLScriptArray SQLScriptArray
83682>>>>>>>>>        String sDriverID
83682>>>>>>>>>        Boolean bOK
83682>>>>>>>>>        Integer iSize iCount
83682>>>>>>>>>
83682>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83684>>>>>>>>>            Function_Return False
83685>>>>>>>>>        End
83685>>>>>>>>>>
83685>>>>>>>>>
83685>>>>>>>>>        Get psDriverID to sDriverID
83686>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83687>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83689>>>>>>>>>            Function_Return False
83690>>>>>>>>>        End
83690>>>>>>>>>>
83690>>>>>>>>>
83690>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83691>>>>>>>>>        Decrement iSize
83692>>>>>>>>>
83692>>>>>>>>>        For iCount from 0 to iSize
83698>>>>>>>>>>
83698>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83700>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83701>>>>>>>>>            End
83701>>>>>>>>>>
83701>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83703>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83704>>>>>>>>>            End
83704>>>>>>>>>>
83704>>>>>>>>>        Loop
83705>>>>>>>>>>
83705>>>>>>>>>
83705>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83706>>>>>>>>>
83706>>>>>>>>>        Function_Return (bOK = True)
83707>>>>>>>>>    End_Function
83708>>>>>>>>>
83708>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83708>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83708>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83708>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83710>>>>>>>>>        Integer iChannel iArgumentSize iCount
83710>>>>>>>>>        Number nByteCount
83710>>>>>>>>>        String sSQLScript
83710>>>>>>>>>        tSQLScriptArray SqlScriptArray
83710>>>>>>>>>        tSQLScriptArray SqlScriptArray
83710>>>>>>>>>        UChar[] uCharData
83711>>>>>>>>>
83711>>>>>>>>>        Move False to Err
83712>>>>>>>>>        Get Seq_New_Channel to iChannel
83713>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83715>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83716>>>>>>>>>>
83716>>>>>>>>>            Move True to SqlScriptArray.bError
83717>>>>>>>>>            Function_Return SqlScriptArray
83718>>>>>>>>>        End
83718>>>>>>>>>>
83718>>>>>>>>>
83718>>>>>>>>>        // First decide the size of the script
83718>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83720>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83722>>>>>>>>>        Close_Input channel iChannel
83724>>>>>>>>>
83724>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83725>>>>>>>>>        If (nByteCount  < 1) Begin
83727>>>>>>>>>            Send Seq_Release_Channel iChannel
83728>>>>>>>>>            Move True to SqlScriptArray.bError
83729>>>>>>>>>            Function_Return SqlScriptArray
83730>>>>>>>>>        End
83730>>>>>>>>>>
83730>>>>>>>>>
83730>>>>>>>>>        // If necessary change the string argument_size
83730>>>>>>>>>        // Read the script file from memory line-by-line
83730>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83732>>>>>>>>>            Move 0 to iCount
83733>>>>>>>>>            Repeat
83733>>>>>>>>>>
83733>>>>>>>>>                Readln channel iChannel sSQLScript
83735>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83736>>>>>>>>>                Increment iCount
83737>>>>>>>>>            Until (SeqEof = True)
83739>>>>>>>>>        Close_Input channel iChannel
83741>>>>>>>>>        Send Seq_Release_Channel iChannel
83742>>>>>>>>>
83742>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83742>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83743>>>>>>>>>
83743>>>>>>>>>        Function_Return SqlScriptArray
83744>>>>>>>>>    End_Function
83745>>>>>>>>>
83745>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83747>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83747>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83747>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83747>>>>>>>>>        String[] sMsg aSQLQueryMessages
83749>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83749>>>>>>>>>        TimeSpan tsQuery
83749>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83749>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83749>>>>>>>>>        tSQLConnection SQLConnection
83749>>>>>>>>>        tSQLConnection SQLConnection
83749>>>>>>>>>        Boolean bShowProgress
83749>>>>>>>>>
83749>>>>>>>>>        If (num_arguments > 4) Begin
83751>>>>>>>>>            Move bShowProgr to bShowProgress
83752>>>>>>>>>        End
83752>>>>>>>>>>
83752>>>>>>>>>        Get phoSQLManager to hoSql
83753>>>>>>>>>
83753>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83754>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83754>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83754>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83754>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83754>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83754>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83754>>>>>>>>>        Get piChunkMax to iChunkMax
83755>>>>>>>>>        Move 0 to iChunkCounter
83756>>>>>>>>>        Move "" to sStmt
83757>>>>>>>>>
83757>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83758>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83759>>>>>>>>>
83759>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83760>>>>>>>>>
83760>>>>>>>>>        Get phoSQLManager  to hoSQL
83761>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83763>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83765>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83766>>>>>>>>>                If (iPos > 0) Begin
83768>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83769>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83770>>>>>>>>>                End
83770>>>>>>>>>>
83770>>>>>>>>>            End
83770>>>>>>>>>>
83770>>>>>>>>>        End
83770>>>>>>>>>>
83770>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83771>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83772>>>>>>>>>
83772>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83774>>>>>>>>>            Move False to Err
83775>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83776>>>>>>>>>            If (hoStmt <> 0) Begin
83778>>>>>>>>>
83778>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83778>>>>>>>>>                If (bCreateScriptFile = True) Begin
83780>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83781>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83782>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83783>>>>>>>>>                    Get Seq_New_Channel to iOut
83784>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83786>>>>>>>>>                        Direct_Output channel iOut sExportFile
83788>>>>>>>>>                    End
83788>>>>>>>>>>
83788>>>>>>>>>                End
83788>>>>>>>>>>
83788>>>>>>>>>
83788>>>>>>>>>                // Record starting date/time stamp
83788>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83789>>>>>>>>>                // Turn on error handling if enabled
83789>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83791>>>>>>>>>                    Set pbSqlError to False
83792>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83793>>>>>>>>>                    Move Error_Object_Id to hoError
83794>>>>>>>>>                    Move Self to Error_Object_Id
83795>>>>>>>>>                End
83795>>>>>>>>>>
83795>>>>>>>>>
83795>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83796>>>>>>>>>                Decrement iRows
83797>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83799>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83800>>>>>>>>>                End
83800>>>>>>>>>>
83800>>>>>>>>>
83800>>>>>>>>>                for iCount from 0 to iRows
83806>>>>>>>>>>
83806>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83807>>>>>>>>>
83807>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83809>>>>>>>>>                        If (sSQLVal <> "") Begin
83811>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83812>>>>>>>>>                        End
83812>>>>>>>>>>
83812>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83813>>>>>>>>>                    End
83813>>>>>>>>>>
83813>>>>>>>>>
83813>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83813>>>>>>>>>                    // or if at the very end of the script.
83813>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83815>>>>>>>>>
83815>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83815>>>>>>>>>                        // instead of all in one go.
83815>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83816>>>>>>>>>
83816>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83818>>>>>>>>>                            Write channel iOut sStmt
83820>>>>>>>>>                        End
83820>>>>>>>>>>
83820>>>>>>>>>                        Move "" to sStmt
83821>>>>>>>>>                        Move 0 to iChunkCounter
83822>>>>>>>>>                    End
83822>>>>>>>>>>
83822>>>>>>>>>                    Increment iChunkCounter
83823>>>>>>>>>                Loop
83824>>>>>>>>>>
83824>>>>>>>>>
83824>>>>>>>>>                Repeat
83824>>>>>>>>>>
83824>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83826>>>>>>>>>                        Move hoError to Error_Object_Id
83827>>>>>>>>>                    End
83827>>>>>>>>>>
83827>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83828>>>>>>>>>
83828>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83829>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83830>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83831>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83832>>>>>>>>>                    Set piRows    to iRows
83833>>>>>>>>>                    Set piRowType to iRowType
83834>>>>>>>>>
83834>>>>>>>>>                    If (iMsgs <> 0) Begin
83836>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83838>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83839>>>>>>>>>                        End
83839>>>>>>>>>>
83839>>>>>>>>>                        for i from 1 to iMsgs
83845>>>>>>>>>>
83845>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83846>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83847>>>>>>>>>                            If (bShowProgress = True) Begin
83849>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83851>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83852>>>>>>>>>                                End
83852>>>>>>>>>>
83852>>>>>>>>>                                Else Begin
83853>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83855>>>>>>>>>                                End
83855>>>>>>>>>>
83855>>>>>>>>>                            End
83855>>>>>>>>>>
83855>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83856>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83857>>>>>>>>>                        Loop
83858>>>>>>>>>>
83858>>>>>>>>>
83858>>>>>>>>>
83858>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83860>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83861>>>>>>>>>                        End
83861>>>>>>>>>>
83861>>>>>>>>>                        Set paQueryMessages to sMsg
83862>>>>>>>>>                    End
83862>>>>>>>>>>
83862>>>>>>>>>
83862>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83863>>>>>>>>>                Until (iNextSet = 0)
83865>>>>>>>>>
83865>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83866>>>>>>>>>            End
83866>>>>>>>>>>
83866>>>>>>>>>
83866>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83867>>>>>>>>>            Set ptsQueryExec to tsQuery
83868>>>>>>>>>            Send SqlClose of hoStmt
83869>>>>>>>>>
83869>>>>>>>>>            If (bCreateScriptFile = True) Begin
83871>>>>>>>>>                Close_Output channel iOut
83873>>>>>>>>>                Send Seq_Release_Channel iOut
83874>>>>>>>>>            End
83874>>>>>>>>>>
83874>>>>>>>>>        End
83874>>>>>>>>>>
83874>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83875>>>>>>>>>
83875>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83876>>>>>>>>>    End_Function
83877>>>>>>>>>
83877>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83879>>>>>>>>>        tSQLScriptArray SQLScriptArray
83879>>>>>>>>>        tSQLScriptArray SQLScriptArray
83879>>>>>>>>>        String sDriverID sCollation
83879>>>>>>>>>        Boolean bOK
83879>>>>>>>>>        Integer iSize iCount
83879>>>>>>>>>
83879>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83881>>>>>>>>>            Function_Return False
83882>>>>>>>>>        End
83882>>>>>>>>>>
83882>>>>>>>>>
83882>>>>>>>>>        Get psDriverID  to sDriverID
83883>>>>>>>>>        Get psCollation to sCollation
83884>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83885>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83887>>>>>>>>>            Function_Return False
83888>>>>>>>>>        End
83888>>>>>>>>>>
83888>>>>>>>>>
83888>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83889>>>>>>>>>        Decrement iSize
83890>>>>>>>>>
83890>>>>>>>>>        For iCount from 0 to iSize
83896>>>>>>>>>>
83896>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83898>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83899>>>>>>>>>            End
83899>>>>>>>>>>
83899>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83901>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83902>>>>>>>>>            End
83902>>>>>>>>>>
83902>>>>>>>>>        Loop
83903>>>>>>>>>>
83903>>>>>>>>>
83903>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83904>>>>>>>>>
83904>>>>>>>>>        Function_Return (bOK = True)
83905>>>>>>>>>    End_Function
83906>>>>>>>>>
83906>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83908>>>>>>>>>        tSQLScriptArray SQLScriptArray
83908>>>>>>>>>        tSQLScriptArray SQLScriptArray
83908>>>>>>>>>        String sDriverID sCollation
83908>>>>>>>>>        Boolean bOK
83908>>>>>>>>>        Integer iSize iCount
83908>>>>>>>>>
83908>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83910>>>>>>>>>            Function_Return False
83911>>>>>>>>>        End
83911>>>>>>>>>>
83911>>>>>>>>>
83911>>>>>>>>>        Get psDriverID  to sDriverID
83912>>>>>>>>>        Get psCollation to sCollation
83913>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83914>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83916>>>>>>>>>            Function_Return False
83917>>>>>>>>>        End
83917>>>>>>>>>>
83917>>>>>>>>>
83917>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83918>>>>>>>>>        Decrement iSize
83919>>>>>>>>>
83919>>>>>>>>>        For iCount from 0 to iSize
83925>>>>>>>>>>
83925>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83927>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83928>>>>>>>>>            End
83928>>>>>>>>>>
83928>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83930>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83931>>>>>>>>>            End
83931>>>>>>>>>>
83931>>>>>>>>>        Loop
83932>>>>>>>>>>
83932>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83932>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83933>>>>>>>>>
83933>>>>>>>>>        Function_Return (bOK = True)
83934>>>>>>>>>    End_Function
83935>>>>>>>>>
83935>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83937>>>>>>>>>        Integer iMax iPos
83937>>>>>>>>>        String sName
83937>>>>>>>>>
83937>>>>>>>>>        Move (Lowercase(sField)) to sField
83938>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83941>>>>>>>>>        For iPos from 0 to iMax
83947>>>>>>>>>>
83947>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83950>>>>>>>>>            Move (Lowercase(sName)) to sName
83951>>>>>>>>>            If (sName = sField) Begin
83953>>>>>>>>>                Function_Return iPos
83954>>>>>>>>>            End
83954>>>>>>>>>>
83954>>>>>>>>>        Loop
83955>>>>>>>>>>
83955>>>>>>>>>        Function_Return -1
83956>>>>>>>>>    End_Function
83957>>>>>>>>>
83957>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
83957>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
83957>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83957>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
83957>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83959>>>>>>>>>        String sID sConnString
83959>>>>>>>>>        Integer iDriver iNumConn iCount
83959>>>>>>>>>        Handle hoCLI
83959>>>>>>>>>        Boolean bOK
83959>>>>>>>>>
83959>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83960>>>>>>>>>        If (bOK = False) Begin
83962>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83963>>>>>>>>>>
83963>>>>>>>>>            Function_Return False
83964>>>>>>>>>        End
83964>>>>>>>>>>
83964>>>>>>>>>
83964>>>>>>>>>        Move False to bOK
83965>>>>>>>>>        Get phoCLIHandler to hoCLI
83966>>>>>>>>>        If (hoCLI <> 0) Begin
83968>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83969>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83970>>>>>>>>>
83970>>>>>>>>>            // If driver not loaded; load it.
83970>>>>>>>>>            If (iDriver = 0) Begin
83972>>>>>>>>>                Load_Driver sDriverID
83973>>>>>>>>>                Get DriverIndex sDriverID to iDriver
83974>>>>>>>>>            End
83974>>>>>>>>>>
83974>>>>>>>>>            If (iDriver <> 0) Begin
83976>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83979>>>>>>>>>                Decrement iNumConn
83980>>>>>>>>>                For iCount from 0 to iNumConn
83986>>>>>>>>>>
83986>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83989>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83992>>>>>>>>>                    If (sID = sConnectionID) Begin
83994>>>>>>>>>                        Move True to bOK
83995>>>>>>>>>                    End
83995>>>>>>>>>>
83995>>>>>>>>>                Loop
83996>>>>>>>>>>
83996>>>>>>>>>            End
83996>>>>>>>>>>
83996>>>>>>>>>        End
83996>>>>>>>>>>
83996>>>>>>>>>
83996>>>>>>>>>        Function_Return bOK
83997>>>>>>>>>    End_Function
83998>>>>>>>>>
83998>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84000>>>>>>>>>        Boolean bOK
84000>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84001>>>>>>>>>        Function_Return bOK
84002>>>>>>>>>    End_Function
84003>>>>>>>>>
84003>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84005>>>>>>>>>        Integer iDriverIndex
84005>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84006>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84007>>>>>>>>>    End_Function
84008>>>>>>>>>
84008>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84008>>>>>>>>>    // attempt to load the driver.
84008>>>>>>>>>    // Returns true if the passed driver is SQL based.
84008>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84010>>>>>>>>>        Boolean bOK
84010>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84011>>>>>>>>>        Function_Return bOK
84012>>>>>>>>>    End_Function
84013>>>>>>>>>
84013>>>>>>>>>    // *** Error Handler ***
84013>>>>>>>>>    //
84013>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84013>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84013>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84015>>>>>>>>>        Integer iSize iErrorMode
84015>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84015>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84015>>>>>>>>>
84015>>>>>>>>>        If (pbProcessingError(Self)) Begin
84017>>>>>>>>>            Procedure_Return
84018>>>>>>>>>        End
84018>>>>>>>>>>
84018>>>>>>>>>
84018>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84019>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84021>>>>>>>>>            Set Private.pbProcessingError to False
84022>>>>>>>>>            Procedure_Return
84023>>>>>>>>>        End
84023>>>>>>>>>>
84023>>>>>>>>>
84023>>>>>>>>>        Set pbProcessingError to True
84024>>>>>>>>>        Set pbSqlError to True
84025>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84026>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84027>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84028>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84029>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84030>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84031>>>>>>>>>        Set pbProcessingError to False
84032>>>>>>>>>    End_Procedure
84033>>>>>>>>>
84033>>>>>>>>>    // *** Miscellanous Helper Functions ***
84033>>>>>>>>>    //
84033>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
84033>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
84033>>>>>>>>>    Function _TableNameOnly String sName Returns String
84035>>>>>>>>>        String sPath sExt
84035>>>>>>>>>
84035>>>>>>>>>        Get ParseFolderName sName to sPath
84036>>>>>>>>>        If (sPath <> "") Begin
84038>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
84039>>>>>>>>>        End
84039>>>>>>>>>>
84039>>>>>>>>>        Get ParseFileExtension sName to sExt
84040>>>>>>>>>        If (sExt <> "") Begin
84042>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
84043>>>>>>>>>        End
84043>>>>>>>>>>
84043>>>>>>>>>
84043>>>>>>>>>        Function_Return sName
84044>>>>>>>>>    End_Function
84045>>>>>>>>>
84045>>>>>>>>>    // Removes any prefix to a table name.
84045>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84045>>>>>>>>>    //         dbo.mytable returns mytable
84045>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84047>>>>>>>>>        Integer iPos
84047>>>>>>>>>
84047>>>>>>>>>        Move (Pos(":", sName)) to iPos
84048>>>>>>>>>        If (iPos <> 0) Begin
84050>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84051>>>>>>>>>        End
84051>>>>>>>>>>
84051>>>>>>>>>        Move (Pos(".", sName)) to iPos
84052>>>>>>>>>        If (iPos <> 0) Begin
84054>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84055>>>>>>>>>        End
84055>>>>>>>>>>
84055>>>>>>>>>
84055>>>>>>>>>        Function_Return sName
84056>>>>>>>>>    End_Function
84057>>>>>>>>>
84057>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84057>>>>>>>>>    // The returned path always ends with a "\"
84057>>>>>>>>>    Function psDataPathFirstPart Returns String
84059>>>>>>>>>        String sDataPath
84059>>>>>>>>>        Integer iCount
84059>>>>>>>>>
84059>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84060>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84061>>>>>>>>>        If (iCount > 1) Begin
84063>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84064>>>>>>>>>        End
84064>>>>>>>>>>
84064>>>>>>>>>        If (sDataPath <> "") Begin
84066>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84067>>>>>>>>>        End
84067>>>>>>>>>>
84067>>>>>>>>>
84067>>>>>>>>>        Function_Return sDataPath
84068>>>>>>>>>    End_Function
84069>>>>>>>>>
84069>>>>>>>>>    Function psLogTextFileWithPath Returns String
84071>>>>>>>>>        String sFileName
84071>>>>>>>>>        Handle hoLogFile
84071>>>>>>>>>        Get phoLogFile to hoLogFile
84072>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84073>>>>>>>>>        Function_Return sFileName
84074>>>>>>>>>    End_Function
84075>>>>>>>>>
84075>>>>>>>>>    Function phoLogFile Returns Handle
84077>>>>>>>>>        Handle hoLogFile   
84077>>>>>>>>>        Boolean bErr
84077>>>>>>>>>        
84077>>>>>>>>>        Move Err to bErr
84078>>>>>>>>>        Move 0 to hoLogFile
84079>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84080>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84081>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84083>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84084>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84085>>>>>>>>>        Move bErr to Err
84086>>>>>>>>>        
84086>>>>>>>>>        Function_Return hoLogFile
84087>>>>>>>>>    End_Function
84088>>>>>>>>>
84088>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84090>>>>>>>>>        Number nCurrentVersionUpdate
84090>>>>>>>>>
84090>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84091>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84093>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84094>>>>>>>>>
84094>>>>>>>>>        Function_Return nCurrentVersionUpdate
84095>>>>>>>>>    End_Function
84096>>>>>>>>>
84096>>>>>>>>>    Procedure LogError String sText Boolean bError
84098>>>>>>>>>        Handle hoLogFile
84098>>>>>>>>>        Number nCurrentVersionUpdate
84098>>>>>>>>>
84098>>>>>>>>>        Get phoLogFile to hoLogFile
84099>>>>>>>>>        If (hoLogFile = 0) Begin
84101>>>>>>>>>            Procedure_Return
84102>>>>>>>>>        End
84102>>>>>>>>>>
84102>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84103>>>>>>>>>
84103>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84104>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84105>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84106>>>>>>>>>    End_Procedure
84107>>>>>>>>>
84107>>>>>>>>>    Function pbContinueOnError Returns Boolean
84109>>>>>>>>>        Boolean bContinueOnError
84109>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84111>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84112>>>>>>>>>        End
84112>>>>>>>>>>
84112>>>>>>>>>        Function_Return bContinueOnError
84113>>>>>>>>>    End_Function
84114>>>>>>>>>
84114>>>>>>>>>
84114>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84116>>>>>>>>>        Integer iChIn iChOut // iCount
84116>>>>>>>>>        Boolean bExists
84116>>>>>>>>>        String sExistingColumn
84116>>>>>>>>>
84116>>>>>>>>>        Move False to bExists
84117>>>>>>>>>        Get Seq_New_Channel to iChIn
84118>>>>>>>>>        Get Seq_New_Channel to iChOut
84119>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84121>>>>>>>>>            Function_Return True
84122>>>>>>>>>        End
84122>>>>>>>>>>
84122>>>>>>>>>
84122>>>>>>>>>        Move False to Err
84123>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84123>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84125>>>>>>>>>        While (not(SeqEof))
84129>>>>>>>>>            Readln channel iChIn sExistingColumn
84131>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84133>>>>>>>>>                Move True to bExists
84134>>>>>>>>>            End
84134>>>>>>>>>>
84134>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84136>>>>>>>>>                Move True to SeqEof
84137>>>>>>>>>            End
84137>>>>>>>>>>
84137>>>>>>>>>        Loop
84138>>>>>>>>>>
84138>>>>>>>>>        Close_Input channel iChIn
84140>>>>>>>>>        Send Seq_Release_Channel iChIn
84141>>>>>>>>>
84141>>>>>>>>>        If (bExists = False) Begin
84143>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84145>>>>>>>>>            Writeln channel iChOut sColumnName
84148>>>>>>>>>            Close_Output channel iChOut
84150>>>>>>>>>            Send Seq_Release_Channel iChOut
84151>>>>>>>>>        End
84151>>>>>>>>>>
84151>>>>>>>>>
84151>>>>>>>>>        Function_Return (Err = False)
84152>>>>>>>>>    End_Function
84153>>>>>>>>>
84153>>>>>>>>>    // Changes source code files.
84153>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84153>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84153>>>>>>>>>    // to use a Connection ID.
84153>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84153>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84153>>>>>>>>>    // Returns True if no errors occured.
84153>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84155>>>>>>>>>        Integer iCh iRow iItems iCount
84155>>>>>>>>>        String sValue sRow
84155>>>>>>>>>        String[] sFileArray
84156>>>>>>>>>        Boolean bExists bIsActive bFileChange
84156>>>>>>>>>
84156>>>>>>>>>        Move False to Err
84157>>>>>>>>>        Move 0 to iRow
84158>>>>>>>>>        Move False to bFileChange
84159>>>>>>>>>
84159>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84161>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84162>>>>>>>>>        End
84162>>>>>>>>>>
84162>>>>>>>>>
84162>>>>>>>>>        Get vFilePathExists sFileName to bExists
84163>>>>>>>>>        If (bExists = False) Begin
84165>>>>>>>>>            If (bShowResult = True) Begin
84167>>>>>>>>>                If (bIsActive = True) Begin
84169>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84170>>>>>>>>>                End
84170>>>>>>>>>>
84170>>>>>>>>>                Else Begin
84171>>>>>>>>>                    Showln "File does not exist: " sFileName
84174>>>>>>>>>                End
84174>>>>>>>>>>
84174>>>>>>>>>            End
84174>>>>>>>>>>
84174>>>>>>>>>            Function_Return False
84175>>>>>>>>>        End
84175>>>>>>>>>>
84175>>>>>>>>>
84175>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84176>>>>>>>>>        If (iCh < 1) Begin
84178>>>>>>>>>            Function_Return False
84179>>>>>>>>>        End
84179>>>>>>>>>>
84179>>>>>>>>>
84179>>>>>>>>>        If (bShowResult = True) Begin
84181>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84183>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84184>>>>>>>>>                If (bIsActive = True) Begin
84186>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84187>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84188>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84189>>>>>>>>>                End
84189>>>>>>>>>>
84189>>>>>>>>>            End
84189>>>>>>>>>>
84189>>>>>>>>>            Else Begin
84190>>>>>>>>>                Showln ""
84192>>>>>>>>>                Showln "sFileName = " sFileName
84195>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84200>>>>>>>>>            End
84200>>>>>>>>>>
84200>>>>>>>>>        End
84200>>>>>>>>>>
84200>>>>>>>>>
84200>>>>>>>>>        While (not(SeqEof))
84204>>>>>>>>>            Readln channel iCh sRow
84206>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84208>>>>>>>>>                // Change the whole line to the new connection id:
84208>>>>>>>>>                Move sChangeTo to sRow 
84209>>>>>>>>>                Move True to bFileChange
84210>>>>>>>>>            End
84210>>>>>>>>>>
84210>>>>>>>>>            Move sRow to sFileArray[iRow]
84211>>>>>>>>>            Increment iRow
84212>>>>>>>>>        Loop
84213>>>>>>>>>>
84213>>>>>>>>>        Send Seq_Close_Channel iCh
84214>>>>>>>>>
84214>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84214>>>>>>>>>
84214>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84215>>>>>>>>>        If (iCh < 1) Begin
84217>>>>>>>>>            Function_Return False
84218>>>>>>>>>        End
84218>>>>>>>>>>
84218>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84219>>>>>>>>>        Decrement iItems
84220>>>>>>>>>
84220>>>>>>>>>        for iCount from 0 to iItems
84226>>>>>>>>>>
84226>>>>>>>>>            Move sFileArray[iCount] to sValue
84227>>>>>>>>>            Writeln channel iCh sValue
84230>>>>>>>>>        Loop
84231>>>>>>>>>>
84231>>>>>>>>>        Send Seq_Close_Channel iCh
84232>>>>>>>>>
84232>>>>>>>>>        Function_Return bFileChange
84233>>>>>>>>>    End_Function
84234>>>>>>>>>
84234>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84234>>>>>>>>>    // and opens it in "notepad.exe".
84234>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84234>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84234>>>>>>>>>    Procedure _UtilShowErrorList
84236>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84236>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84236>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84236>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84236>>>>>>>>>
84236>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84237>>>>>>>>>        Get vFolderFormat sPath to sPath
84238>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84239>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84240>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84241>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84242>>>>>>>>>            If (iRows > 0) Begin
84244>>>>>>>>>                Decrement iRows
84245>>>>>>>>>                for iCount from 0 to iRows
84251>>>>>>>>>>
84251>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84252>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84253>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84254>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84260>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84264>>>>>>>>>                Loop
84265>>>>>>>>>>
84265>>>>>>>>>            End
84265>>>>>>>>>>
84265>>>>>>>>>        Send Seq_Close_Channel iCh
84266>>>>>>>>>
84266>>>>>>>>>        If (iRows > 0) Begin
84268>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84269>>>>>>>>>        End
84269>>>>>>>>>>
84269>>>>>>>>>    End_Procedure
84270>>>>>>>>>
84270>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84270>>>>>>>>>    // and the table needs to exist as an SQL table.
84270>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84272>>>>>>>>>        String sRootName sDriverID
84272>>>>>>>>>        Boolean bIsSQL
84272>>>>>>>>>
84272>>>>>>>>>        Move False to bIsSQL
84273>>>>>>>>>        If (hTable > 0) Begin
84275>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84278>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84279>>>>>>>>>            If (bIsSQL = True) Begin
84281>>>>>>>>>                Get psDriverID to sDriverID
84282>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84283>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84284>>>>>>>>>            End
84284>>>>>>>>>>
84284>>>>>>>>>        End
84284>>>>>>>>>>
84284>>>>>>>>>
84284>>>>>>>>>        Function_Return bIsSQL
84285>>>>>>>>>    End_Function
84286>>>>>>>>>
84286>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84288>>>>>>>>>        Boolean bIsSQL
84288>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84289>>>>>>>>>        Function_Return bIsSQL
84290>>>>>>>>>    End_Function
84291>>>>>>>>>
84291>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84291>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84293>>>>>>>>>        String sDatabase sSchema sVal
84293>>>>>>>>>        Boolean bExists
84293>>>>>>>>>        String[] sTablesArray
84294>>>>>>>>>        Integer iSize iCount
84294>>>>>>>>>
84294>>>>>>>>>        Move False to bExists
84295>>>>>>>>>        Get psDatabase to sDatabase
84296>>>>>>>>>        Get psSchema   to sSchema
84297>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84299>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84300>>>>>>>>>>
84300>>>>>>>>>            Function_Return False
84301>>>>>>>>>        End
84301>>>>>>>>>>
84301>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84302>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
84303>>>>>>>>>        Decrement iSize
84304>>>>>>>>>        for iCount from 0 to iSize
84310>>>>>>>>>>
84310>>>>>>>>>            Move sTablesArray[iCount] to sVal
84311>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
84313>>>>>>>>>                Move True to bExists
84314>>>>>>>>>                Move iSize to iCount // We're done!
84315>>>>>>>>>            End
84315>>>>>>>>>>
84315>>>>>>>>>        Loop
84316>>>>>>>>>>
84316>>>>>>>>>
84316>>>>>>>>>        Function_Return bExists
84317>>>>>>>>>    End_Function
84318>>>>>>>>>
84318>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84318>>>>>>>>>    // that the embedded .dat file exists on disk.
84318>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84320>>>>>>>>>        Boolean bExists bIsEmbedded
84320>>>>>>>>>        String sDataPath sRootName
84320>>>>>>>>>
84320>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84321>>>>>>>>>        If (bExists = False) Begin
84323>>>>>>>>>            Function_Return False
84324>>>>>>>>>        End
84324>>>>>>>>>>
84324>>>>>>>>>
84324>>>>>>>>>        Move False to bIsEmbedded
84325>>>>>>>>>        If (hTable > 0) Begin
84327>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84330>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84331>>>>>>>>>        End
84331>>>>>>>>>>
84331>>>>>>>>>        If (bIsEmbedded = True) Begin
84333>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84334>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84335>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84336>>>>>>>>>        End
84336>>>>>>>>>>
84336>>>>>>>>>
84336>>>>>>>>>        Function_Return bIsEmbedded
84337>>>>>>>>>    End_Function
84338>>>>>>>>>
84338>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84338>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84340>>>>>>>>>        Date dDate
84340>>>>>>>>>        Integer iYY iHH iMM iSS
84340>>>>>>>>>        Boolean bExists
84340>>>>>>>>>        DateTime dtFileDateTime
84340>>>>>>>>>
84340>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84341>>>>>>>>>        Get vFilePathExists sFileName to bExists
84342>>>>>>>>>        If (bExists = True) Begin
84344>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84348>>>>>>>>>            Move dDate            to dtFileDateTime
84349>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84350>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84351>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84352>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84353>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84354>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84355>>>>>>>>>        End
84355>>>>>>>>>>
84355>>>>>>>>>
84355>>>>>>>>>        Function_Return dtFileDateTime
84356>>>>>>>>>    End_Function
84357>>>>>>>>>
84357>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84357>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84359>>>>>>>>>        Boolean bExists bIsNewer
84359>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84359>>>>>>>>>
84359>>>>>>>>>        Move False to bIsNewer
84360>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84361>>>>>>>>>        If (bExists = True) Begin
84363>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84364>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84365>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84366>>>>>>>>>        End
84366>>>>>>>>>>
84366>>>>>>>>>        Function_Return bIsNewer
84367>>>>>>>>>    End_Function
84368>>>>>>>>>
84368>>>>>>>>>End_Class
84369>>>>>>>
84369>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84369>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84370>>>>>>>
84370>>>>>>>    Procedure Construct_Object
84372>>>>>>>        Forward Send Construct_Object
84374>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84375>>>>>>>    End_Procedure
84376>>>>>>>
84376>>>>>>>    Procedure End_Construct_Object
84378>>>>>>>        Forward Send End_Construct_Object
84380>>>>>>>    End_Procedure
84381>>>>>>>
84381>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84381>>>>>>>    //
84381>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84381>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84383>>>>>>>        Function_Return False
84384>>>>>>>    End_Function
84385>>>>>>>
84385>>>>>>>    // Function for creating a new *Database*.
84385>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84385>>>>>>>    // Returns True if successful.
84385>>>>>>>    // ToDo: Currently only works for MS-SQL...
84385>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84387>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84387>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84387>>>>>>>        Handle hConnection hStmt hoSQLManager
84387>>>>>>>        Integer iFetchResult iDbType
84387>>>>>>>        Boolean bOK bExists
84387>>>>>>>
84387>>>>>>>        Get piDbType to iDbType
84388>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84390>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84391>>>>>>>>
84391>>>>>>>            Function_Return False
84392>>>>>>>        End
84392>>>>>>>>
84392>>>>>>>
84392>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84393>>>>>>>        If (bExists = True) Begin
84395>>>>>>>            Function_Return True
84396>>>>>>>        End
84396>>>>>>>>
84396>>>>>>>
84396>>>>>>>        Get phoSQLManager to hoSQLManager
84397>>>>>>>
84397>>>>>>>        Get psConnectionID     to sConnectionID
84398>>>>>>>        Get psConnectionString to sConnectionString
84399>>>>>>>        Move 0 to LastErr
84400>>>>>>>
84400>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84402>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84402>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84402>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84402>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84402>>>>>>>//                If (iPos > 0) Begin
84402>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84402>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84402>>>>>>>//                End
84402>>>>>>>//            End
84402>>>>>>>        End
84402>>>>>>>>
84402>>>>>>>
84402>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84403>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84404>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84405>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84407>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84408>>>>>>>>
84408>>>>>>>            Function_Return False
84409>>>>>>>        End
84409>>>>>>>>
84409>>>>>>>
84409>>>>>>>        Get SqlOpen of hConnection to hStmt
84410>>>>>>>
84410>>>>>>>        If (hStmt = 0) Begin
84412>>>>>>>            Send SqlDisconnect of hoSQLManager
84413>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84414>>>>>>>>
84414>>>>>>>            Function_Return False
84415>>>>>>>        End
84415>>>>>>>>
84415>>>>>>>
84415>>>>>>>        Get psCollation to sCollation
84416>>>>>>>
84416>>>>>>>        Case Begin
84416>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84418>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84419>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84420>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84421>>>>>>>
84421>>>>>>>                // Check if database exists
84421>>>>>>>                Send SqlExecDirect of hStmt sSQL
84422>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84423>>>>>>>                Send SqlClose of hStmt
84424>>>>>>>                Send SqlDisconnect of hConnection
84425>>>>>>>                // If database already exists we're out of here!
84425>>>>>>>                // Note that we return True as this is not an error.
84425>>>>>>>                If (iFetchResult > 0) Begin
84427>>>>>>>                    Function_Return True
84428>>>>>>>                End
84428>>>>>>>>
84428>>>>>>>                // Database doesn't exist, create it.
84428>>>>>>>                If (iFetchResult = 0) Begin
84430>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84431>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84432>>>>>>>                    If (sCollation <> "") Begin
84434>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84435>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84436>>>>>>>                    End
84436>>>>>>>>
84436>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84437>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84438>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84440>>>>>>>                        Function_Return False
84441>>>>>>>                    End
84441>>>>>>>>
84441>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84441>>>>>>>                    Sleep 1
84442>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84443>>>>>>>                End
84443>>>>>>>>
84443>>>>>>>                Case Break
84444>>>>>>>
84444>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84447>>>>>>>                // ToDo: How should this be set/checked?
84447>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84447>>>>>>>//                    Set psCollation to "utf8"
84447>>>>>>>//                End
84447>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84447>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84448>>>>>>>                Case Break
84449>>>>>>>
84449>>>>>>>            Case Else
84449>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84450>>>>>>>>
84450>>>>>>>        Case End
84450>>>>>>>
84450>>>>>>>        If (Err = False) Begin
84452>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84453>>>>>>>        End
84453>>>>>>>>
84453>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84453>>>>>>>        // the one we just created.
84453>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84455>>>>>>>            Set psDatabase to sDatabase
84456>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84456>>>>>>>            If (bPermanantly = True) Begin
84458>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84460>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84461>>>>>>>                End
84461>>>>>>>>
84461>>>>>>>            End
84461>>>>>>>>
84461>>>>>>>        End
84461>>>>>>>>
84461>>>>>>>
84461>>>>>>>        Function_Return (Err = False)
84462>>>>>>>    End_Function
84463>>>>>>>
84463>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84463>>>>>>>    // will be used.
84463>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84465>>>>>>>        Boolean bOK bExists bShowProgress bErr
84465>>>>>>>        String sStatement sDriverID
84465>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84465>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84465>>>>>>>        Integer iDbType
84465>>>>>>>
84465>>>>>>>        If (sDatabase = "") Begin
84467>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84468>>>>>>>>
84468>>>>>>>            Function_Return False
84469>>>>>>>        End
84469>>>>>>>>
84469>>>>>>>        If (sBackupName = "") Begin
84471>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84472>>>>>>>>
84472>>>>>>>            Function_Return False
84473>>>>>>>        End
84473>>>>>>>>
84473>>>>>>>
84473>>>>>>>        // Create backup-folder if it doesn't exist
84473>>>>>>>        Get vFolderExists sPath to bExists
84474>>>>>>>        If (bExists = False) Begin
84476>>>>>>>            Get vCreateDirectory sPath to bErr
84477>>>>>>>            If (bErr = True) Begin
84479>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84480>>>>>>>>
84480>>>>>>>                Function_Return False
84481>>>>>>>            End
84481>>>>>>>>
84481>>>>>>>        End
84481>>>>>>>>
84481>>>>>>>        // Make sure the path ends with a back-slash
84481>>>>>>>        If (sPath <> "") Begin
84483>>>>>>>            Get vFolderFormat sPath to sPath
84484>>>>>>>        End
84484>>>>>>>>
84484>>>>>>>
84484>>>>>>>        Get psDriverID to sDriverID
84485>>>>>>>        Get piDbType   to iDbType
84486>>>>>>>        If (num_arguments > 3) Begin
84488>>>>>>>            Move bShowProg to bShowProgress
84489>>>>>>>        End
84489>>>>>>>>
84489>>>>>>>
84489>>>>>>>        Case Begin
84489>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84491>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84491>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84491>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84492>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84493>>>>>>>
84493>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84494>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84495>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84496>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84497>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84498>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84499>>>>>>>                Case Break
84500>>>>>>>            Case Else
84500>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84501>>>>>>>        Case End
84501>>>>>>>
84501>>>>>>>        Function_Return bOK
84502>>>>>>>    End_Function
84503>>>>>>>
84503>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84505>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84505>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84505>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84505>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84505>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84505>>>>>>>        tSQLConnection SQLConnection
84505>>>>>>>        tSQLConnection SQLConnection
84505>>>>>>>
84505>>>>>>>        If (sDatabase = "") Begin
84507>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84508>>>>>>>>
84508>>>>>>>            Function_Return ""
84509>>>>>>>        End
84509>>>>>>>>
84509>>>>>>>
84509>>>>>>>        Move "" to sRetval
84510>>>>>>>        Get psDriverID to sDriverID
84511>>>>>>>        Get piDbType   to iDbType
84512>>>>>>>
84512>>>>>>>        Case Begin
84512>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84514>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84514>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84515>>>>>>>
84515>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84516>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84517>>>>>>>                Get phoSQLManager to hoSQLHandler
84518>>>>>>>
84518>>>>>>>                If (hoSQLHandler <> 0) Begin
84520>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84521>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84522>>>>>>>
84522>>>>>>>                    If (hoSQLConnect <> 0) Begin
84524>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84525>>>>>>>                        If (hstmt <> 0) Begin
84527>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84528>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84529>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84530>>>>>>>                            If (iFetchResult <> 0) Begin
84532>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84533>>>>>>>                            End
84533>>>>>>>>
84533>>>>>>>                            Send SQLClose of hstmt
84534>>>>>>>                        End
84534>>>>>>>>
84534>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84535>>>>>>>                    End
84535>>>>>>>>
84535>>>>>>>                End
84535>>>>>>>>
84535>>>>>>>                Case Break
84536>>>>>>>            Case Else
84536>>>>>>>                If (bSilent = False) Begin
84538>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84539>>>>>>>                End
84539>>>>>>>>
84539>>>>>>>        Case End
84539>>>>>>>
84539>>>>>>>        Function_Return sRetval
84540>>>>>>>    End_Function
84541>>>>>>>
84541>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84543>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84543>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84543>>>>>>>        Handle hConnection hStmt hoSQLManager
84543>>>>>>>        Integer iDbType // iFetchResult
84543>>>>>>>
84543>>>>>>>        If (sDatabase = "") Begin
84545>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84546>>>>>>>>
84546>>>>>>>            Function_Return False
84547>>>>>>>        End
84547>>>>>>>>
84547>>>>>>>
84547>>>>>>>        If (sSQLCollation = "") Begin
84549>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84550>>>>>>>>
84550>>>>>>>            Function_Return False
84551>>>>>>>        End
84551>>>>>>>>
84551>>>>>>>
84551>>>>>>>        Get psDriverID to sDriverID
84552>>>>>>>        Get piDbType   to iDbType
84553>>>>>>>
84553>>>>>>>        Get phoSQLManager to hoSQLManager
84554>>>>>>>        Get psConnectionID     to sConnectionID
84555>>>>>>>        Get psConnectionString to sConnectionString
84556>>>>>>>        Move 0 to LastErr
84557>>>>>>>
84557>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84558>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84559>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84560>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84562>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84563>>>>>>>>
84563>>>>>>>            Function_Return False
84564>>>>>>>        End
84564>>>>>>>>
84564>>>>>>>
84564>>>>>>>        Get SqlOpen of hConnection to hStmt
84565>>>>>>>
84565>>>>>>>        If (hStmt = 0) Begin
84567>>>>>>>            Send SqlDisconnect of hoSQLManager
84568>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84569>>>>>>>>
84569>>>>>>>            Function_Return False
84570>>>>>>>        End
84570>>>>>>>>
84570>>>>>>>
84570>>>>>>>        // Check if collation already exists
84570>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84571>>>>>>>        // If the current collate is the same as the new; do nothing.
84571>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84573>>>>>>>            Function_Return True
84574>>>>>>>        End
84574>>>>>>>>
84574>>>>>>>
84574>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84575>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84576>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84577>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84578>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84579>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84580>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84581>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84582>>>>>>>
84582>>>>>>>        // MS-SQL Syntax:
84582>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84582>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84582>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84582>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84583>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84584>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84585>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84585>>>>>>>
84585>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84586>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84587>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84588>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84590>>>>>>>           Function_Return False
84591>>>>>>>        End
84591>>>>>>>>
84591>>>>>>>
84591>>>>>>>        Function_Return (Err = False)
84592>>>>>>>    End_Function
84593>>>>>>>
84593>>>>>>>
84593>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84593>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84595>>>>>>>        Function_Return False
84596>>>>>>>    End_Function
84597>>>>>>>
84597>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84597>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84597>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84597>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84597>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84597>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84599>>>>>>>        Handle hToTable
84599>>>>>>>        Boolean bOK bExists bOpened bCopyData
84599>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84599>>>>>>>        tSQLConnection SQLConnection
84599>>>>>>>        tSQLConnection SQLConnection
84599>>>>>>>        Integer iPos iMaxRecords
84599>>>>>>>
84599>>>>>>>        Get psDriverID to sDriverID
84600>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84601>>>>>>>        If (bExists = False) Begin
84603>>>>>>>            Function_Return False
84604>>>>>>>        End
84604>>>>>>>>
84604>>>>>>>
84604>>>>>>>        If (num_arguments > 1) Begin
84606>>>>>>>            Move bCpyDat to bCopyData
84607>>>>>>>        End
84607>>>>>>>>
84607>>>>>>>        Else Begin
84608>>>>>>>            Move False to bCopyData
84609>>>>>>>        End
84609>>>>>>>>
84609>>>>>>>
84609>>>>>>>        Open hTable
84611>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84614>>>>>>>        If (bOpened = False) Begin
84616>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84617>>>>>>>>
84617>>>>>>>            Function_Return False
84618>>>>>>>        End
84618>>>>>>>>
84618>>>>>>>        Move 0 to hToTable
84619>>>>>>>
84619>>>>>>>        Move 16711679 to iMaxRecords
84620>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84623>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84624>>>>>>>        If (iPos > 0) Begin
84626>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84627>>>>>>>        End
84627>>>>>>>>
84627>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84630>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84631>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84632>>>>>>>
84632>>>>>>>        If (ghoProgressBar <> 0) Begin
84634>>>>>>>            Send DoAdvance of ghoProgressBar
84635>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84636>>>>>>>        End
84636>>>>>>>>
84636>>>>>>>
84636>>>>>>>        Move False to Err
84637>>>>>>>
84637>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84638>>>>>>>            Structure_Copy hTable to hToTable
84639>>>>>>>
84639>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84642>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84645>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84648>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84651>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84654>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84655>>>>>>>
84655>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84657>>>>>>>
84657>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84658>>>>>>>        Move (not(Err)) to bOK
84659>>>>>>>        If (bOK = True and bCopyData = True) Begin
84661>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84662>>>>>>>        End
84662>>>>>>>>
84662>>>>>>>
84662>>>>>>>        // This must be after copying data...
84662>>>>>>>        If (Err = False) Begin
84664>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84667>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84670>>>>>>>        End
84670>>>>>>>>
84670>>>>>>>        Move (not(Err)) to bOK
84671>>>>>>>
84671>>>>>>>        Function_Return (bOK = True)
84672>>>>>>>    End_Function
84673>>>>>>>
84673>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84673>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84673>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84675>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84675>>>>>>>        Integer iDbType
84675>>>>>>>        Boolean bExists
84675>>>>>>>
84675>>>>>>>        Get psDriverID to sDriverID
84676>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84677>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84678>>>>>>>        If (bExists = True) Begin
84680>>>>>>>            Function_Return False
84681>>>>>>>        End
84681>>>>>>>>
84681>>>>>>>
84681>>>>>>>        Get psDataPathFirstPart to sPath
84682>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84683>>>>>>>
84683>>>>>>>        Get piDbType to iDbType
84684>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84685>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84686>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84687>>>>>>>
84687>>>>>>>        Move False to Err
84688>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84689>>>>>>>
84689>>>>>>>        Function_Return (Err = False)
84690>>>>>>>    End_Function
84691>>>>>>>
84691>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84691>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84691>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84693>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84693>>>>>>>        Integer iDbType
84693>>>>>>>        Boolean bExists
84693>>>>>>>
84693>>>>>>>        Get psDriverID to sDriverID
84694>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84695>>>>>>>        If (bExists = True) Begin
84697>>>>>>>            Function_Return False
84698>>>>>>>        End
84698>>>>>>>>
84698>>>>>>>
84698>>>>>>>        Get psDataPathFirstPart to sPath
84699>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84700>>>>>>>        If (bExists = True) Begin
84702>>>>>>>            // ToDo: What should we do if an .int file already exists?
84702>>>>>>>        End
84702>>>>>>>>
84702>>>>>>>
84702>>>>>>>        Get piDbType to iDbType
84703>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84704>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84705>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84706>>>>>>>
84706>>>>>>>        Move False to Err
84707>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84708>>>>>>>
84708>>>>>>>        Function_Return (Err = False)
84709>>>>>>>    End_Function
84710>>>>>>>    
84710>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
84710>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
84710>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84712>>>>>>>        Boolean bOK                                                            
84712>>>>>>>        String sStatement
84712>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84713>>>>>>>        Function_Return bOK
84714>>>>>>>    End_Function
84715>>>>>>>    
84715>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84715>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84715>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84715>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
84717>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84717>>>>>>>        Integer iRetval iDbType
84717>>>>>>>        Boolean bExists bOK
84717>>>>>>>
84717>>>>>>>        Get psDriverID to sDriverID
84718>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84719>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84720>>>>>>>        If (bExists = False) Begin
84722>>>>>>>            Function_Return False
84723>>>>>>>        End
84723>>>>>>>>
84723>>>>>>>
84723>>>>>>>        Get psDataPathFirstPart to sPath
84724>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84725>>>>>>>
84725>>>>>>>        Get piDbType to iDbType
84726>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84727>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84728>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84729>>>>>>>
84729>>>>>>>        Move False to Err
84730>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84731>>>>>>>
84731>>>>>>>        // We also need to remove the cache-file since the table has been changed
84731>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84732>>>>>>>
84732>>>>>>>        Function_Return (Err = False)
84733>>>>>>>    End_Function
84734>>>>>>>
84734>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84734>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84736>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84736>>>>>>>        Integer iRetval iDbType
84736>>>>>>>        Boolean bOK
84736>>>>>>>
84736>>>>>>>        Get psDriverID to sDriverID
84737>>>>>>>        Get psDataPathFirstPart to sPath
84738>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84739>>>>>>>
84739>>>>>>>        Get piDbType to iDbType
84740>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84741>>>>>>>        Get psSchema to sSchema
84742>>>>>>>        If (sSchema = "") Begin
84744>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84745>>>>>>>        End
84745>>>>>>>>
84745>>>>>>>        Move (Uppercase(sTableName)) to sVal
84746>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84748>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84749>>>>>>>        End
84749>>>>>>>>
84749>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84750>>>>>>>
84750>>>>>>>        Move False to Err
84751>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84752>>>>>>>
84752>>>>>>>        // We also need to remove the cache-file since the table has been changed
84752>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84753>>>>>>>
84753>>>>>>>        Function_Return (Err = False)
84754>>>>>>>    End_Function
84755>>>>>>>
84755>>>>>>>    // *** Sql View Messages ***
84755>>>>>>>
84755>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
84755>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
84757>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
84757>>>>>>>        Integer iRetval
84757>>>>>>>        Boolean bOK
84757>>>>>>>
84757>>>>>>>        Get psDriverID to sDriverID
84758>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
84759>>>>>>>
84759>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84760>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84761>>>>>>>        Set psSQLStatementString to sSQLString
84762>>>>>>>
84762>>>>>>>        // As we don't check if the view exist or not, it might happen
84762>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84762>>>>>>>        Move False to Err
84763>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84764>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84765>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84766>>>>>>>        Move 0 to LastErr
84767>>>>>>>
84767>>>>>>>        // We also need to remove the cache-file since the table has been changed
84767>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
84768>>>>>>>
84768>>>>>>>        Function_Return (Err = False)
84769>>>>>>>    End_Function
84770>>>>>>>
84770>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84772>>>>>>>        Boolean bOK
84772>>>>>>>        Integer iDbType
84772>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84772>>>>>>>
84772>>>>>>>        Get psDriverID to sDriverID
84773>>>>>>>        Get piDbType   to iDbType
84774>>>>>>>
84774>>>>>>>        Case Begin
84774>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84776>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84777>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84778>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84779>>>>>>>            Break
84780>>>>>>>
84780>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84783>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84784>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84785>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84786>>>>>>>            Break
84787>>>>>>>
84787>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84790>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84791>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84792>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84793>>>>>>>            Break
84794>>>>>>>
84794>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84797>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84798>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84799>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84800>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84801>>>>>>>            Break
84802>>>>>>>
84802>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84805>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84806>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84807>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84808>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84809>>>>>>>            Break
84810>>>>>>>        Case End
84810>>>>>>>
84810>>>>>>>        Move False to Err
84811>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84812>>>>>>>        Move (Err = False) to bOK
84813>>>>>>>
84813>>>>>>>        Function_Return bOK
84814>>>>>>>    End_Function
84815>>>>>>>
84815>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84815>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84817>>>>>>>        Function_Return False
84818>>>>>>>    End_Function
84819>>>>>>>
84819>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84819>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84821>>>>>>>        Integer iLength iDecimals
84821>>>>>>>        String sColumnValue
84821>>>>>>>        String sTableName sDriverID
84821>>>>>>>        Boolean bOK bInitializeValue
84821>>>>>>>
84821>>>>>>>        Get psDriverID to sDriverID
84822>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84823>>>>>>>        If (bOK = False) Begin
84825>>>>>>>            Function_Return False
84826>>>>>>>        End
84826>>>>>>>>
84826>>>>>>>
84826>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84827>>>>>>>        If (sTableName = "") Begin
84829>>>>>>>            Function_Return False
84830>>>>>>>        End
84830>>>>>>>>
84830>>>>>>>
84830>>>>>>>        If (num_arguments > 3) Begin
84832>>>>>>>            Move iLen     to iLength
84833>>>>>>>            Move iDec     to iDecimals
84834>>>>>>>            Move bInitVal to bInitializeValue
84835>>>>>>>            Move sColVal  to sColumnValue
84836>>>>>>>        End
84836>>>>>>>>
84836>>>>>>>
84836>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84837>>>>>>>
84837>>>>>>>        Function_Return (bOK = True)
84838>>>>>>>    End_Function
84839>>>>>>>
84839>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84839>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84841>>>>>>>        Integer iDbType iLength iDecimals iDriver
84841>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84841>>>>>>>        String sDriverID sNotNull
84841>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84841>>>>>>>        Handle hTable
84841>>>>>>>
84841>>>>>>>        Get psDriverID to sDriverID
84842>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84843>>>>>>>        If (bOK = False) Begin
84845>>>>>>>            Function_Return True
84846>>>>>>>        End
84846>>>>>>>>
84846>>>>>>>
84846>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84847>>>>>>>        If (hTable = 0) Begin
84849>>>>>>>            Get NextFreeFilelistSlot to hTable
84850>>>>>>>        End
84850>>>>>>>>
84850>>>>>>>
84850>>>>>>>        Get piDbType to iDbType
84851>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84851>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84852>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84854>>>>>>>            Function_Return True
84855>>>>>>>        End
84855>>>>>>>>
84855>>>>>>>
84855>>>>>>>        Get DriverIndex sDriverID to iDriver
84856>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84859>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84862>>>>>>>
84862>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84863>>>>>>>        If (num_arguments > 3) Begin
84865>>>>>>>            Move iLen     to iLength
84866>>>>>>>            Move iDec     to iDecimals
84867>>>>>>>            Move bInitVal to bInitializeValue
84868>>>>>>>            Move sColVal  to sColumnValue
84869>>>>>>>        End
84869>>>>>>>>
84869>>>>>>>
84869>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84870>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84871>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84872>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84873>>>>>>>
84873>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84874>>>>>>>        If (bFixed = False) Begin
84876>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84877>>>>>>>        End
84877>>>>>>>>
84877>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84878>>>>>>>
84878>>>>>>>        Move False to Err
84879>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84880>>>>>>>
84880>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84882>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84883>>>>>>>        End
84883>>>>>>>>
84883>>>>>>>
84883>>>>>>>        If (Err = False) Begin
84885>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84886>>>>>>>        End
84886>>>>>>>>
84886>>>>>>>
84886>>>>>>>        Move (not(Err)) to bRetval
84887>>>>>>>
84887>>>>>>>        // We also need to remove the cache-file since the table has been changed
84887>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84888>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84891>>>>>>>
84891>>>>>>>        Function_Return bRetval
84892>>>>>>>    End_Function
84893>>>>>>>
84893>>>>>>>    // To update all current rows for a table column with a common value.
84893>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84895>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84895>>>>>>>        Boolean bRetval bSQLDriver
84895>>>>>>>        Integer iCurrErr iDbType
84895>>>>>>>
84895>>>>>>>        Move False to bRetval
84896>>>>>>>        Get piDbType to iDbType
84897>>>>>>>        Get psDriverID to sDriverID
84898>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84899>>>>>>>        If (bSQLDriver = False) Begin
84901>>>>>>>            Function_Return bRetval
84902>>>>>>>        End
84902>>>>>>>>
84902>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84903>>>>>>>
84903>>>>>>>        Move Err to iCurrErr
84904>>>>>>>        Move False to Err
84905>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84906>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84907>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84908>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84908>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
84910>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84911>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84912>>>>>>>        End
84912>>>>>>>>
84912>>>>>>>        Else Begin
84913>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84914>>>>>>>        End
84914>>>>>>>>
84914>>>>>>>
84914>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84915>>>>>>>        Move (Err = False) to bRetval
84916>>>>>>>        Move iCurrErr to Err
84917>>>>>>>
84917>>>>>>>        Function_Return bRetval
84918>>>>>>>    End_Function
84919>>>>>>>
84919>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84919>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84919>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84921>>>>>>>        String sDriverID sTableName
84921>>>>>>>        Boolean bOK
84921>>>>>>>
84921>>>>>>>        Get psDriverID to sDriverID
84922>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84923>>>>>>>        If (bOK = False) Begin
84925>>>>>>>            Function_Return False
84926>>>>>>>        End
84926>>>>>>>>
84926>>>>>>>
84926>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84927>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84928>>>>>>>
84928>>>>>>>        Function_Return (Err = False)
84929>>>>>>>    End_Function
84930>>>>>>>
84930>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84930>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84930>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84930>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84932>>>>>>>        Integer iDbType iLength iDecimals
84932>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84932>>>>>>>        Boolean bExists bOK bFixed
84932>>>>>>>        Handle hTable
84932>>>>>>>
84932>>>>>>>        Get psDriverID to sDriverID
84933>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84934>>>>>>>        If (bOK = False) Begin
84936>>>>>>>            Function_Return False
84937>>>>>>>        End
84937>>>>>>>>
84937>>>>>>>
84937>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84938>>>>>>>        If (hTable = 0) Begin
84940>>>>>>>            Get NextFreeFilelistSlot to hTable
84941>>>>>>>        End
84941>>>>>>>>
84941>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84942>>>>>>>        If (bExists = False) Begin
84944>>>>>>>            Function_Return False
84945>>>>>>>        End
84945>>>>>>>>
84945>>>>>>>
84945>>>>>>>        If (num_arguments > 3) Begin
84947>>>>>>>            Move iLen to iLength
84948>>>>>>>        End
84948>>>>>>>>
84948>>>>>>>        If (num_arguments > 4) Begin
84950>>>>>>>            Move iDec to iDecimals
84951>>>>>>>        End
84951>>>>>>>>
84951>>>>>>>
84951>>>>>>>        Get piDbType to iDbType
84952>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84953>>>>>>>
84953>>>>>>>        Move False to Err
84954>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84955>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84956>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84957>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84958>>>>>>>
84958>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84959>>>>>>>        If (bFixed = False) Begin
84961>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84962>>>>>>>        End
84962>>>>>>>>
84962>>>>>>>
84962>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84963>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84964>>>>>>>
84964>>>>>>>        // We also need to remove the cache-file since the table has been changed
84964>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84965>>>>>>>
84965>>>>>>>        Function_Return (Err = False)
84966>>>>>>>    End_Function
84967>>>>>>>
84967>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84969>>>>>>>        Boolean bOK bErr bIsSQLDriver
84969>>>>>>>        String sDriverID
84969>>>>>>>        Integer iDataType
84969>>>>>>>
84969>>>>>>>        Get psDriverID to sDriverID
84970>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84971>>>>>>>        If (bIsSQLDriver = False) Begin
84973>>>>>>>            Function_Return False
84974>>>>>>>        End
84974>>>>>>>>
84974>>>>>>>
84974>>>>>>>        Move Err to bErr
84975>>>>>>>        Move False to bErr
84976>>>>>>>
84976>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84976>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84976>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84977>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84980>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84982>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
84983>>>>>>>        End
84983>>>>>>>>
84983>>>>>>>
84983>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84986>>>>>>>        Move (not(Err)) to bOK
84987>>>>>>>        Move bErr to Err
84988>>>>>>>
84988>>>>>>>        Function_Return bOK
84989>>>>>>>    End_Function
84990>>>>>>>
84990>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84992>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84992>>>>>>>        String sDriverID
84992>>>>>>>
84992>>>>>>>        Get psDriverID to sDriverID
84993>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84994>>>>>>>        If (bIsSQLDriver = False) Begin
84996>>>>>>>            Function_Return False
84997>>>>>>>        End
84997>>>>>>>>
84997>>>>>>>
84997>>>>>>>        Move Err to bErr
84998>>>>>>>        Move False to bErr
84999>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85002>>>>>>>        If (bNullable = bCurrentState) Begin
85004>>>>>>>            Function_Return True
85005>>>>>>>        End
85005>>>>>>>>
85005>>>>>>>
85005>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85008>>>>>>>        If (bOpen = False) Begin
85010>>>>>>>            Get AutoConnectionIDLogin to bOK
85011>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85012>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85013>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85014>>>>>>>            Open hTable
85016>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85017>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85018>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85019>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85022>>>>>>>        End
85022>>>>>>>>
85022>>>>>>>        If (bOpen = True) Begin
85024>>>>>>>            Structure_Start hTable sDriverID
85025>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85028>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85029>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85031>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85032>>>>>>>        End
85032>>>>>>>>
85032>>>>>>>
85032>>>>>>>        Move (not(Err)) to bOK
85033>>>>>>>        Move bErr to Err
85034>>>>>>>
85034>>>>>>>        Function_Return bOK
85035>>>>>>>    End_Function
85036>>>>>>>
85036>>>>>>>    // Drop column by its table handle
85036>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85038>>>>>>>        String sDriverID sTableName
85038>>>>>>>        Boolean bOK
85038>>>>>>>
85038>>>>>>>        Get psDriverID to sDriverID
85039>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85040>>>>>>>        If (bOK = False) Begin
85042>>>>>>>            Function_Return False
85043>>>>>>>        End
85043>>>>>>>>
85043>>>>>>>
85043>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85044>>>>>>>        If (sTableName = "") Begin
85046>>>>>>>            Function_Return False
85047>>>>>>>        End
85047>>>>>>>>
85047>>>>>>>
85047>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85048>>>>>>>
85048>>>>>>>        Function_Return (bOK = True)
85049>>>>>>>    End_Function
85050>>>>>>>
85050>>>>>>>    // Drop column by its table name as a string.
85050>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85052>>>>>>>        Integer iDbType iDriver
85052>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85052>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85052>>>>>>>        Handle hTable
85052>>>>>>>
85052>>>>>>>        Get psDriverID to sDriverID
85053>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85054>>>>>>>        If (bOK = False) Begin
85056>>>>>>>            Function_Return False
85057>>>>>>>        End
85057>>>>>>>>
85057>>>>>>>
85057>>>>>>>        Get DriverIndex sDriverID to iDriver
85058>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85061>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85064>>>>>>>
85064>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85065>>>>>>>        If (hTable <> 0) Begin
85067>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85068>>>>>>>            If (bExists = False) Begin
85070>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85073>>>>>>>                Function_Return False
85074>>>>>>>            End
85074>>>>>>>>
85074>>>>>>>        End
85074>>>>>>>>
85074>>>>>>>
85074>>>>>>>        Get piDbType to iDbType
85075>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85077>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85078>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85079>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85082>>>>>>>            Function_Return bOK
85083>>>>>>>        End
85083>>>>>>>>
85083>>>>>>>
85083>>>>>>>        Move False to Err
85084>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85085>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85086>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85087>>>>>>>
85087>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85088>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85089>>>>>>>        Move (not(Err)) to bRetval
85090>>>>>>>
85090>>>>>>>        // We also need to remove the cache-file since the table has been changed
85090>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85091>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85094>>>>>>>
85094>>>>>>>        Function_Return bRetval
85095>>>>>>>    End_Function
85096>>>>>>>
85096>>>>>>>    // Rename a field/column by table handle (filelist number)
85096>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85098>>>>>>>        String sDriverID sTableName
85098>>>>>>>        Boolean bOK
85098>>>>>>>
85098>>>>>>>        Get psDriverID to sDriverID
85099>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85100>>>>>>>        If (bOK = False) Begin
85102>>>>>>>            Function_Return False
85103>>>>>>>        End
85103>>>>>>>>
85103>>>>>>>
85103>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85104>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85105>>>>>>>
85105>>>>>>>        Function_Return (Err = False)
85106>>>>>>>    End_Function
85107>>>>>>>
85107>>>>>>>    // Rename a field/column by table name.
85107>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85109>>>>>>>        Integer iDbType iDataType
85109>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85109>>>>>>>        Boolean bOK bRetval
85109>>>>>>>        Handle hTable
85109>>>>>>>
85109>>>>>>>        Move sTableName to sOrgTableName
85110>>>>>>>        Get psDriverID to sDriverID
85111>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85112>>>>>>>        If (bOK = False) Begin
85114>>>>>>>            Function_Return False
85115>>>>>>>        End
85115>>>>>>>>
85115>>>>>>>
85115>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85116>>>>>>>        If (sVal = "") Begin
85118>>>>>>>            Function_Return False
85119>>>>>>>        End
85119>>>>>>>>
85119>>>>>>>
85119>>>>>>>        Get piDbType to iDbType
85120>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85121>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85122>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85123>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85124>>>>>>>
85124>>>>>>>        Case Begin
85124>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85126>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85127>>>>>>>                Case Break
85128>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85128>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85131>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85132>>>>>>>                Case Break
85133>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85133>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85136>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85137>>>>>>>                Case Break
85138>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85138>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85141>>>>>>>                Move sOrgTableName to sTableName
85142>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85143>>>>>>>                Case Break
85144>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85147>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85147>>>>>>>                Move sOrgTableName to sTableName
85148>>>>>>>                Get psDatabase to sDatabase
85149>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85150>>>>>>>                If (hTable = 0) Begin
85152>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85153>>>>>>>                    If (bOK = False) Begin
85155>>>>>>>                        Function_Return False
85156>>>>>>>                    End
85156>>>>>>>>
85156>>>>>>>                    Get NextFreeFilelistSlot to hTable
85157>>>>>>>                End
85157>>>>>>>>
85157>>>>>>>                Else Begin
85158>>>>>>>                    Open hTable
85160>>>>>>>                End
85160>>>>>>>>
85160>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85161>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85162>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85163>>>>>>>                Case Break
85164>>>>>>>            Case Else
85164>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85165>>>>>>>        Case End
85165>>>>>>>
85165>>>>>>>        Move False to Err
85166>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85167>>>>>>>        Move (Err = False) to bRetval
85168>>>>>>>        // We also need to remove the cache-file since the table has been changed
85168>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85169>>>>>>>
85169>>>>>>>        Function_Return bRetval
85170>>>>>>>    End_Function
85171>>>>>>>
85171>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85173>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85173>>>>>>>        Integer iNumCols iCount iDataType
85173>>>>>>>        String sValue
85173>>>>>>>
85173>>>>>>>        Get phoSQLManager to hoSQLHandler
85174>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85175>>>>>>>        If (hSQLConnect <> 0) Begin
85177>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85178>>>>>>>            If (hStmt <> 0) Begin
85180>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85181>>>>>>>
85181>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85182>>>>>>>                For iCount from 1 to iNumCols
85188>>>>>>>>
85188>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85189>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85191>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85192>>>>>>>                        Move iNumCols to iCount // We're out of here
85193>>>>>>>                    End
85193>>>>>>>>
85193>>>>>>>                Loop
85194>>>>>>>>
85194>>>>>>>
85194>>>>>>>                Send SQLClose of hStmt
85195>>>>>>>            End
85195>>>>>>>>
85195>>>>>>>            Send SQLDisconnect of hSQLConnect
85196>>>>>>>        End
85196>>>>>>>>
85196>>>>>>>
85196>>>>>>>        Function_Return iDataType
85197>>>>>>>    End_Function
85198>>>>>>>
85198>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85198>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85200>>>>>>>        Function_Return False
85201>>>>>>>    End_Function
85202>>>>>>>
85202>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85204>>>>>>>        String sMessage // sConnectionString
85204>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85204>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85204>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85207>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85207>>>>>>>        TimeSpan tsQuery tsFetch
85207>>>>>>>        tSqlErrorArray aSqlErrorArray
85207>>>>>>>        tSqlErrorArray aSqlErrorArray
85207>>>>>>>        Boolean bOK bShowProgress
85207>>>>>>>        tSQLConnection SQLConnection
85207>>>>>>>        tSQLConnection SQLConnection
85207>>>>>>>
85207>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85208>>>>>>>        If (bOK = False) Begin
85210>>>>>>>            Procedure_Return
85211>>>>>>>        End
85211>>>>>>>>
85211>>>>>>>
85211>>>>>>>        If (num_arguments > 2) Begin
85213>>>>>>>            Move bShowProgr to bShowProgress
85214>>>>>>>        End
85214>>>>>>>>
85214>>>>>>>
85214>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85215>>>>>>>        Get phoSQLManager to hoSqlHandler
85216>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85217>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85218>>>>>>>
85218>>>>>>>        If (hoSQLConnect <> 0) Begin
85220>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85221>>>>>>>            If (hoStmt <> 0) Begin
85223>>>>>>>                // record starting date/time stamp
85223>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85224>>>>>>>                // turn on error handling if enabled
85224>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85226>>>>>>>                    Set pbSqlError to False
85227>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85228>>>>>>>                    Move Error_Object_Id to hoError
85229>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85231>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85232>>>>>>>                    End
85232>>>>>>>>
85232>>>>>>>                    Else Begin
85233>>>>>>>                        Move Self to Error_Object_Id
85234>>>>>>>                    End
85234>>>>>>>>
85234>>>>>>>                End
85234>>>>>>>>
85234>>>>>>>
85234>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85234>>>>>>>                Set psSQLStatementString to sStmt
85235>>>>>>>                Send Cursor_Wait of Cursor_Control
85236>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85237>>>>>>>                Send Cursor_Ready of Cursor_Control
85238>>>>>>>
85238>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85240>>>>>>>                    Move hoError to Error_Object_Id
85241>>>>>>>                End
85241>>>>>>>>
85241>>>>>>>
85241>>>>>>>                Move 0 to iMsgs
85242>>>>>>>                Move Err to iErr
85243>>>>>>>                Move LastErr to iLastErr
85244>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85245>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85246>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85247>>>>>>>                Send _SqlColumnInfo hoStmt
85248>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85249>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85250>>>>>>>                Repeat
85250>>>>>>>>
85250>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85251>>>>>>>                    If (iFetchResult <> 0) Begin
85253>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85254>>>>>>>                    End
85254>>>>>>>>
85254>>>>>>>                Until (iFetchResult = 0)
85256>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85257>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85258>>>>>>>                Move iErr to Err
85259>>>>>>>                Move iLastErr to LastErr
85260>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85261>>>>>>>
85261>>>>>>>                Set piRows    to iRows
85262>>>>>>>                Set piRowType to iRowType
85263>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85264>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85265>>>>>>>
85265>>>>>>>                If (iMsgs <> 0) Begin
85267>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85269>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85270>>>>>>>                    End
85270>>>>>>>>
85270>>>>>>>                    For i from 1 to iMsgs
85276>>>>>>>>
85276>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85277>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85278>>>>>>>                        If (bShowProgress = True) Begin
85280>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85282>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85283>>>>>>>                            End
85283>>>>>>>>
85283>>>>>>>                            Else Begin
85284>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85286>>>>>>>                            End
85286>>>>>>>>
85286>>>>>>>                        End
85286>>>>>>>>
85286>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85287>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85288>>>>>>>                    Loop
85289>>>>>>>>
85289>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85291>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85292>>>>>>>                    End
85292>>>>>>>>
85292>>>>>>>                    Set paQueryMessages to sMsg
85293>>>>>>>                End
85293>>>>>>>>
85293>>>>>>>                Else Begin
85294>>>>>>>                    If (bShowProgress = True) Begin
85296>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85297>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85299>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85300>>>>>>>                            Decrement iMsgs
85301>>>>>>>                            For i from 0 to iMsgs
85307>>>>>>>>
85307>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85310>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85313>>>>>>>                            Loop
85314>>>>>>>>
85314>>>>>>>                        End
85314>>>>>>>>
85314>>>>>>>                    End
85314>>>>>>>>
85314>>>>>>>                End
85314>>>>>>>>
85314>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85315>>>>>>>            End
85315>>>>>>>>
85315>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85316>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85317>>>>>>>            Set ptsQueryExec to tsQuery
85318>>>>>>>            Set ptsFetchResults to tsFetch
85319>>>>>>>            Send SqlClose of hoStmt
85320>>>>>>>        End
85320>>>>>>>>
85320>>>>>>>
85320>>>>>>>        Send SqlDisconnect of hoSQLConnect
85321>>>>>>>    End_Procedure
85322>>>>>>>
85322>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85322>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85322>>>>>>>    // Returns False if no error occured.
85322>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85324>>>>>>>        Boolean bOK bShowProgress
85324>>>>>>>        tSQLScriptArray SQLScriptArray
85324>>>>>>>        tSQLScriptArray SQLScriptArray
85324>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85324>>>>>>>        TimeSpan tsTotalTime
85324>>>>>>>
85324>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85325>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85326>>>>>>>        If (SQLScriptArray.bError = True) Begin
85328>>>>>>>            Function_Return False
85329>>>>>>>        End
85329>>>>>>>>
85329>>>>>>>
85329>>>>>>>        If (num_arguments > 3) Begin
85331>>>>>>>            Move bShowProgr to bShowProgress
85332>>>>>>>        End
85332>>>>>>>>
85332>>>>>>>
85332>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85333>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85334>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85335>>>>>>>
85335>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85336>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85337>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85338>>>>>>>
85338>>>>>>>        Function_Return bOK
85339>>>>>>>    End_Function
85340>>>>>>>
85340>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85340>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85342>>>>>>>        Function_Return False
85343>>>>>>>    End_Function
85344>>>>>>>
85344>>>>>>>    // Does three things with auxilirary files;
85344>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85344>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85344>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85344>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85346>>>>>>>        String sDataPath sDDSrcPath sDriverID
85346>>>>>>>        Boolean bOK bExists
85346>>>>>>>        Integer iCount iCh iPos
85346>>>>>>>
85346>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85346>>>>>>>        If (sTableName contains ".") Begin
85348>>>>>>>            Move (Pos(".", sTableName)) to iPos
85349>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85350>>>>>>>        End
85350>>>>>>>>
85350>>>>>>>
85350>>>>>>>        Get psDriverID to sDriverID
85351>>>>>>>        Get psDataPathFirstPart to sDataPath
85352>>>>>>>        Get vFolderExists sDataPath to bOK
85353>>>>>>>        If (bOK = False) Begin
85355>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85356>>>>>>>>
85356>>>>>>>            Function_Return False
85357>>>>>>>        End
85357>>>>>>>>
85357>>>>>>>
85357>>>>>>>        // First delete the cache file:
85357>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85358>>>>>>>
85358>>>>>>>        Get Seq_New_Channel to iCh
85359>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85361>>>>>>>            Function_Return False
85362>>>>>>>        End
85362>>>>>>>>
85362>>>>>>>
85362>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85363>>>>>>>        If (bExists = False) Begin
85365>>>>>>>            Function_Return False
85366>>>>>>>        End
85366>>>>>>>>
85366>>>>>>>
85366>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85367>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85367>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85368>>>>>>>
85368>>>>>>>        // If in development environment; output new .fd file:
85368>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85369>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85370>>>>>>>        If (iCount > 1) Begin
85372>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85373>>>>>>>        End
85373>>>>>>>>
85373>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85374>>>>>>>        If (bExists = True) Begin
85376>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85377>>>>>>>            Move False to Err
85378>>>>>>>            Get AutoConnectionIDLogin to bOK
85379>>>>>>>            If (hTable <> 0) Begin
85381>>>>>>>                Open hTable
85383>>>>>>>            End
85383>>>>>>>>
85383>>>>>>>            Else Begin
85384>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85385>>>>>>>            End
85385>>>>>>>>
85385>>>>>>>
85385>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85388>>>>>>>            If (bOK = True) Begin
85390>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85392>>>>>>>            End
85392>>>>>>>>
85392>>>>>>>            If (Err = True) Begin
85394>>>>>>>                Move False to bOK
85395>>>>>>>            End
85395>>>>>>>>
85395>>>>>>>        End
85395>>>>>>>>
85395>>>>>>>
85395>>>>>>>        Function_Return (bOK = True)
85396>>>>>>>    End_Function
85397>>>>>>>
85397>>>>>>>    // Message for changing .int files to use connection ID's
85397>>>>>>>    //
85397>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85397>>>>>>>    // OR changes an existing connection id to a new id.
85397>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85397>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85397>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult String[] ByRef asErrorFiles Returns Integer
85399>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85399>>>>>>>        String[] sFilesData
85400>>>>>>>        Boolean bOK bCancel
85400>>>>>>>        Integer iSize iCount iFileErrors
85400>>>>>>>
85400>>>>>>>        Move 0 to iFileErrors
85401>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85402>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85403>>>>>>>        If (iSize = 0) Begin
85405>>>>>>>            If (ghoStatusPanel <> 0) Begin
85407>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85409>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85410>>>>>>>                End
85410>>>>>>>>
85410>>>>>>>            End
85410>>>>>>>>
85410>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85411>>>>>>>            Function_Return 0
85412>>>>>>>        End
85412>>>>>>>>
85412>>>>>>>
85412>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85413>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85414>>>>>>>        Decrement iSize
85415>>>>>>>        For iCount from 0 to iSize
85421>>>>>>>>
85421>>>>>>>            Move sFilesData[iCount] to sFileName
85422>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85424>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85424>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85425>>>>>>>            If (bOK = False) Begin
85427>>>>>>>                    Move sFileName to asErrorFiles[SizeOfArray(asErrorFiles)]
85428>>>>>>>                Increment iFileErrors
85429>>>>>>>            End
85429>>>>>>>>
85429>>>>>>>            If (ghoStatusPanel <> 0) Begin
85431>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85433>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85434>>>>>>>                    If (bCancel = True) Begin
85436>>>>>>>                        Send Deactivate of ghoStatusPanel
85437>>>>>>>                        Function_Return iFileErrors
85438>>>>>>>                        End
85438>>>>>>>>
85438>>>>>>>                    End
85438>>>>>>>>
85438>>>>>>>                End
85438>>>>>>>>
85438>>>>>>>            End
85438>>>>>>>>
85438>>>>>>>        Loop
85439>>>>>>>>
85439>>>>>>>
85439>>>>>>>        Get psDriverID to sDriverID
85440>>>>>>>
85440>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85440>>>>>>>        Move "" to sFileName
85441>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85443>>>>>>>            Move "MSSQLDrv.int" to sFileName
85444>>>>>>>        End
85444>>>>>>>>
85444>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85446>>>>>>>            Move "DB2_Drv.int" to sFileName
85447>>>>>>>        End
85447>>>>>>>>
85447>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85449>>>>>>>            Move "ODBC_Drv.int" to sFileName
85450>>>>>>>        End
85450>>>>>>>>
85450>>>>>>>        If (sFileName <> "") Begin
85452>>>>>>>            Move "" to sDriverFile
85453>>>>>>>            Get_File_Path sFileName to sDriverFile
85454>>>>>>>            Get ParseFolderName sDriverFile to sPath
85455>>>>>>>            If (sDataPath <> sPath) Begin
85457>>>>>>>                Move "" to sDriverFile
85458>>>>>>>            End
85458>>>>>>>>
85458>>>>>>>            If (sDriverFile <> "") Begin
85460>>>>>>>                Get psConnectionString to sConnectionString
85461>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85462>>>>>>>            End
85462>>>>>>>>
85462>>>>>>>        End     
85462>>>>>>>>
85462>>>>>>>        
85462>>>>>>>        Function_Return iFileErrors
85463>>>>>>>    End_Function
85464>>>>>>>
85464>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85464>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85466>>>>>>>        String[] sDatabaseArray
85467>>>>>>>        String sVal sServer sDriverID
85467>>>>>>>        Integer iCount iSize iPos
85467>>>>>>>        Boolean bExists
85467>>>>>>>        tSQLConnection SQLConnection
85467>>>>>>>        tSQLConnection SQLConnection
85467>>>>>>>
85467>>>>>>>        Move False to bExists
85468>>>>>>>        Get psDriverID to sDriverID
85469>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85469>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85471>>>>>>>            Function_Return bExists
85472>>>>>>>        End
85472>>>>>>>>
85472>>>>>>>
85472>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85473>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85475>>>>>>>            Function_Return False
85476>>>>>>>        End
85476>>>>>>>>
85476>>>>>>>
85476>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85477>>>>>>>        Move SQLConnection.sServer to sServer
85478>>>>>>>
85478>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85478>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85480>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85481>>>>>>>        End
85481>>>>>>>>
85481>>>>>>>        Else If (sServer contains "/") Begin
85484>>>>>>>            Move (Pos("/", sServer)) to iPos
85485>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85486>>>>>>>        End
85486>>>>>>>>
85486>>>>>>>
85486>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85487>>>>>>>        Decrement iSize
85488>>>>>>>        For iCount from 0 to iSize
85494>>>>>>>>
85494>>>>>>>            Move sDatabaseArray[iCount] to sVal
85495>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85497>>>>>>>                Move True to bExists
85498>>>>>>>                If (bExists = True) Begin
85500>>>>>>>                    Move iSize to iCount // We're done.
85501>>>>>>>                End
85501>>>>>>>>
85501>>>>>>>            End
85501>>>>>>>>
85501>>>>>>>        Loop
85502>>>>>>>>
85502>>>>>>>
85502>>>>>>>        Function_Return bExists
85503>>>>>>>    End_Function
85504>>>>>>>
85504>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85504>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85506>>>>>>>        String sDatabase sSchema sTableName sVal
85506>>>>>>>        Boolean bExists
85506>>>>>>>        String[] sTablesArray
85507>>>>>>>        Integer iSize iCount
85507>>>>>>>
85507>>>>>>>        Move False to bExists
85508>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85509>>>>>>>        Get psDatabase to sDatabase
85510>>>>>>>        Get psSchema   to sSchema
85511>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85512>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85513>>>>>>>        Decrement iSize
85514>>>>>>>        For iCount from 0 to iSize
85520>>>>>>>>
85520>>>>>>>            Move sTablesArray[iCount] to sVal
85521>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85523>>>>>>>                Move True to bExists
85524>>>>>>>                Move iSize to iCount // We're done!
85525>>>>>>>            End
85525>>>>>>>>
85525>>>>>>>        Loop
85526>>>>>>>>
85526>>>>>>>
85526>>>>>>>        Function_Return bExists
85527>>>>>>>    End_Function
85528>>>>>>>
85528>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85530>>>>>>>        String sVal sTableSpelledCorrectly
85530>>>>>>>        Boolean bExists
85530>>>>>>>        String[] sTablesArray
85531>>>>>>>        Integer iSize iCount
85531>>>>>>>
85531>>>>>>>        Move False to bExists
85532>>>>>>>        Move sTableName to sTableSpelledCorrectly
85533>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85534>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85535>>>>>>>        Decrement iSize
85536>>>>>>>        For iCount from 0 to iSize
85542>>>>>>>>
85542>>>>>>>            Move sTablesArray[iCount] to sVal
85543>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85545>>>>>>>                Move sVal to sTableSpelledCorrectly
85546>>>>>>>                Move iSize to iCount // We're done!
85547>>>>>>>            End
85547>>>>>>>>
85547>>>>>>>        Loop
85548>>>>>>>>
85548>>>>>>>
85548>>>>>>>        Function_Return sTableSpelledCorrectly
85549>>>>>>>    End_Function
85550>>>>>>>
85550>>>>>>>    // ToDo: This index name function needs to be finished...
85550>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85552>>>>>>>        String sSchema sTableName sDriverID
85552>>>>>>>        Boolean bExists
85552>>>>>>>
85552>>>>>>>        Get psDriverID to sDriverID
85553>>>>>>>        Get psSchema to sSchema
85554>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85555>>>>>>>
85555>>>>>>>        Function_Return bExists
85556>>>>>>>    End_Function
85557>>>>>>>
85557>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85557>>>>>>>    // Returns True if it does
85557>>>>>>>    // Sample:
85557>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85557>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85559>>>>>>>        Integer iNumColumns iColumn
85559>>>>>>>        String sColumn sDriverID
85559>>>>>>>        String[] sColumnsArray
85560>>>>>>>        Boolean bExists bOK
85560>>>>>>>
85560>>>>>>>        Move False to bExists
85561>>>>>>>        Get AutoConnectionIDLogin to bOK
85562>>>>>>>        Get psDriverID to sDriverID
85563>>>>>>>
85563>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85564>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85565>>>>>>>        Decrement iNumColumns
85566>>>>>>>        For iColumn from 0 to iNumColumns
85572>>>>>>>>
85572>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85573>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85575>>>>>>>                Move True to bExists
85576>>>>>>>                Move iNumColumns to iColumn // We're out of here
85577>>>>>>>            End
85577>>>>>>>>
85577>>>>>>>        Loop
85578>>>>>>>>
85578>>>>>>>
85578>>>>>>>        Function_Return bExists
85579>>>>>>>    End_Function
85580>>>>>>>
85580>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85582>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85582>>>>>>>        Boolean bOpened bOK
85582>>>>>>>        String sColumnName sNativeTypeName
85582>>>>>>>
85582>>>>>>>        Get AutoConnectionIDLogin to bOK
85583>>>>>>>        Get OpenTableExclusive hTable to bOK
85584>>>>>>>        If (bOK = False) Begin
85586>>>>>>>            Function_Return False
85587>>>>>>>        End
85587>>>>>>>>
85587>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85590>>>>>>>        If (bOpened = False) Begin
85592>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85593>>>>>>>>
85593>>>>>>>            Function_Return False
85594>>>>>>>        End
85594>>>>>>>>
85594>>>>>>>
85594>>>>>>>        Move False to Err
85595>>>>>>>
85595>>>>>>>        Structure_Start hTable
85596>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85599>>>>>>>
85599>>>>>>>            For iColumn from 1 to iNumColumns
85605>>>>>>>>
85605>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85608>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85611>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85614>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85617>>>>>>>
85617>>>>>>>                Case Begin
85617>>>>>>>                    Case (iDFType = DF_DATE)
85619>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85621>>>>>>>                            // Convert datetime to date
85621>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85624>>>>>>>                        End
85624>>>>>>>>
85624>>>>>>>                        Case Break
85625>>>>>>>                    Case (iDFType = DF_DATETIME)
85628>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85630>>>>>>>                            // Convert datetime to datetime2
85630>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85633>>>>>>>                        End
85633>>>>>>>>
85633>>>>>>>                        Case Break
85634>>>>>>>                    Case (iDFType = DF_ASCII)
85637>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85639>>>>>>>                            // Convert char to varchar
85639>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85642>>>>>>>                        End
85642>>>>>>>>
85642>>>>>>>                        Case Break
85643>>>>>>>                    Case (iDFType = DF_TEXT)
85646>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85648>>>>>>>                            // Convert text to varchar(max)
85648>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85651>>>>>>>                        End
85651>>>>>>>>
85651>>>>>>>                        Case Break
85652>>>>>>>                    Case (iDFType = DF_BINARY)
85655>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85657>>>>>>>                            // Convert image to varbinary(max)
85657>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85660>>>>>>>                        End
85660>>>>>>>>
85660>>>>>>>                        Case Break
85661>>>>>>>                Case End
85661>>>>>>>            Loop
85662>>>>>>>>
85662>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85663>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85665>>>>>>>
85665>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85666>>>>>>>        Function_Return (Err = False)
85667>>>>>>>    End_Function
85668>>>>>>>
85668>>>>>>>
85668>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85668>>>>>>>    // the DbUpdateVersion database revision in.
85668>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85668>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85668>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85670>>>>>>>        Boolean bOK bOpened
85670>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85670>>>>>>>
85670>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85673>>>>>>>        Get _TableNameOnly sTableName to sTableName
85674>>>>>>>        If (sTableName = "") Begin
85676>>>>>>>            Function_Return False
85677>>>>>>>        End
85677>>>>>>>>
85677>>>>>>>
85677>>>>>>>        // This just creates the table and a "dummy" column.
85677>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85678>>>>>>>        If (bOK = False) Begin
85680>>>>>>>            Function_Return False
85681>>>>>>>        End
85681>>>>>>>>
85681>>>>>>>
85681>>>>>>>        Close hTable
85682>>>>>>>        Move False to Err
85683>>>>>>>
85683>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85684>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85685>>>>>>>        Move "Decimal" to sDataType
85686>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85687>>>>>>>
85687>>>>>>>        // Adds the "sColumnName" passed to the function
85687>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85688>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85689>>>>>>>
85689>>>>>>>        // Now we can delete the dummy column:
85689>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85690>>>>>>>
85690>>>>>>>        // Finally, we attach to the newly created table.
85690>>>>>>>        If (Err = False) Begin
85692>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85693>>>>>>>        End
85693>>>>>>>>
85693>>>>>>>        Open hTable
85695>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85698>>>>>>>
85698>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85699>>>>>>>    End_Function
85700>>>>>>>
85700>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85700>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85700>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85700>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85700>>>>>>>    // column types.
85700>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85702>>>>>>>        Handle hDatabase
85702>>>>>>>        Integer iDriver iServers iCount
85702>>>>>>>        String sValue
85702>>>>>>>
85702>>>>>>>        If (sServer = "") Begin
85704>>>>>>>            Function_Return 0
85705>>>>>>>        End
85705>>>>>>>>
85705>>>>>>>
85705>>>>>>>        Get DriverIndex sDriverID to iDriver
85706>>>>>>>        If (iDriver = 0) Begin
85708>>>>>>>            Function_Return 0
85709>>>>>>>        End
85709>>>>>>>>
85709>>>>>>>
85709>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85712>>>>>>>        For iCount from 1 to iServers
85718>>>>>>>>
85718>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85721>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85723>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85726>>>>>>>            End
85726>>>>>>>>
85726>>>>>>>        Loop
85727>>>>>>>>
85727>>>>>>>
85727>>>>>>>        Function_Return hDatabase
85728>>>>>>>    End_Function
85729>>>>>>>
85729>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85729>>>>>>>//        String sRootName
85729>>>>>>>//        Boolean bOK
85729>>>>>>>//
85729>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85729>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85729>>>>>>>//
85729>>>>>>>//        Function_Return bOK
85729>>>>>>>//    End_Function
85729>>>>>>>
85729>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85729>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85729>>>>>>>//        Integer iDbType
85729>>>>>>>//        Boolean bOK
85729>>>>>>>//
85729>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85729>>>>>>>//        If (bOK = True) Begin
85729>>>>>>>//            Function_Return False
85729>>>>>>>//        End
85729>>>>>>>//
85729>>>>>>>//        Get psDriverID to sDriverID
85729>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85729>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85729>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85729>>>>>>>//
85729>>>>>>>//        Get psDriverID to sDriverID
85729>>>>>>>//        Get piDbType   to iDbType
85729>>>>>>>//        Get psSchema   to sSchema
85729>>>>>>>//        If (sSchema = "") Begin
85729>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85729>>>>>>>//        End
85729>>>>>>>//
85729>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85729>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85729>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85729>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85729>>>>>>>//            End
85729>>>>>>>//            Else Begin
85729>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85729>>>>>>>//            End
85729>>>>>>>//        End
85729>>>>>>>//
85729>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85729>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85729>>>>>>>//
85729>>>>>>>//        Function_Return True
85729>>>>>>>//    End_Function
85729>>>>>>>
85729>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85729>>>>>>>    // from the passed filelist.
85729>>>>>>>    // Returns the number of tables affected.
85729>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85731>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85731>>>>>>>        Integer iRetval
85731>>>>>>>        Handle hTable
85731>>>>>>>
85731>>>>>>>        // We first save the current filelist as the passed filelist name
85731>>>>>>>        // may come from another workspace, to restore it when we're ready.
85731>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85734>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85737>>>>>>>        Move 0 to hTable
85738>>>>>>>        Move 0 to iRetval
85739>>>>>>>
85739>>>>>>>        Repeat
85739>>>>>>>>
85739>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85742>>>>>>>            If (hTable <> 0) Begin
85744>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85747>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85750>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85753>>>>>>>                Move (Uppercase(sRootName)) to sVal
85754>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85756>>>>>>>                    // Prefixes:
85756>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85757>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85758>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85759>>>>>>>                    // Suffixes:
85759>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85760>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85761>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85762>>>>>>>
85762>>>>>>>                    // Change Filelist entry:
85762>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85765>>>>>>>
85765>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85766>>>>>>>                    If (sVal contains "dbo.") Begin
85768>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85769>>>>>>>
85769>>>>>>>                        // Change Filelist entry:
85769>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85772>>>>>>>                    End
85772>>>>>>>>
85772>>>>>>>                    Increment iRetval
85773>>>>>>>                End
85773>>>>>>>>
85773>>>>>>>            End
85773>>>>>>>>
85773>>>>>>>        Until (hTable = 0)
85775>>>>>>>
85775>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85778>>>>>>>
85778>>>>>>>        Function_Return iRetval
85779>>>>>>>    End_Function
85780>>>>>>>
85780>>>>>>>    // To open all Sql based tables in Filelist.cfg
85780>>>>>>>    Procedure SqlUtilOpenAllTables
85782>>>>>>>        Handle hTable
85782>>>>>>>        String sRoot sDriverID
85782>>>>>>>        Boolean bOK
85782>>>>>>>
85782>>>>>>>        Move 0 to hTable
85783>>>>>>>        Move "" to sDriverID
85784>>>>>>>        Get AutoConnectionIDLogin to bOK
85785>>>>>>>
85785>>>>>>>        Repeat
85785>>>>>>>>
85785>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85788>>>>>>>            If (hTable > 0) Begin
85790>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85793>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85795>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85798>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85800>>>>>>>                        Open hTable
85802>>>>>>>                    End
85802>>>>>>>>
85802>>>>>>>                End
85802>>>>>>>>
85802>>>>>>>            End
85802>>>>>>>>
85802>>>>>>>
85802>>>>>>>        Until (hTable = 0)
85804>>>>>>>    End_Procedure
85805>>>>>>>
85805>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85805>>>>>>>//        String sRetval sDriverID
85805>>>>>>>//        String sTableName
85805>>>>>>>//        Integer iDbType iIndex
85805>>>>>>>//        Boolean bOK
85805>>>>>>>//
85805>>>>>>>//        Get psDriverID to sDriverID
85805>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85805>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85805>>>>>>>//            Function_Return ""
85805>>>>>>>//        End
85805>>>>>>>//
85805>>>>>>>//        Move False to Err
85805>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85805>>>>>>>//        Get piDbType to iDbType
85805>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85805>>>>>>>//        If (iIndex = -1) Begin
85805>>>>>>>//            Function_Return ""
85805>>>>>>>//        End
85805>>>>>>>//
85805>>>>>>>//        Function_Return sRetval
85805>>>>>>>//    End_Function
85805>>>>>>>
85805>>>>>>>    // Checks if the passed Table;
85805>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
85805>>>>>>>    // 2) It has an .int file.
85805>>>>>>>    // If both is True it should already be connected to SQL
85805>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85807>>>>>>>        Boolean bExists bRootName
85807>>>>>>>        String sRootName sDataPath
85807>>>>>>>
85807>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85810>>>>>>>        Move (sRootName contains sDriverID) to bRootName
85811>>>>>>>
85811>>>>>>>        Get psDataPathFirstPart to sDataPath
85812>>>>>>>        Get vFolderExists sDataPath to bExists
85813>>>>>>>        If (bExists = False) Begin
85815>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85815>>>>>>>            Function_Return False
85816>>>>>>>        End
85816>>>>>>>>
85816>>>>>>>
85816>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85817>>>>>>>        Get _TableNameOnly sRootName to sRootName
85818>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85819>>>>>>>
85819>>>>>>>        Function_Return (bRootName = True and bExists = True)
85820>>>>>>>    End_Function
85821>>>>>>>
85821>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85823>>>>>>>        Boolean bViewTableType bOpen bOK
85823>>>>>>>        Integer iTableCount iNumTables
85823>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85823>>>>>>>        Handle hoCliHandler
85823>>>>>>>        tSQLConnection SQLConnection
85823>>>>>>>        tSQLConnection SQLConnection
85823>>>>>>>
85823>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85826>>>>>>>        If (bOpen = False) Begin
85828>>>>>>>            Get AutoConnectionIDLogin to bOK
85829>>>>>>>            Open hTable
85831>>>>>>>        End
85831>>>>>>>>
85831>>>>>>>
85831>>>>>>>        Get pSQLConnection to SQLConnection
85832>>>>>>>        Get phoCLIHandler to hoCliHandler
85833>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
85834>>>>>>>
85834>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85837>>>>>>>        Get _TableNameOnly sTableName to sTableName
85838>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85841>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85842>>>>>>>
85842>>>>>>>        For iTableCount from 1 to iNumTables
85848>>>>>>>>
85848>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85849>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85850>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85852>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
85853>>>>>>>                Move iNumTables to iTableCount // We're done.
85854>>>>>>>            End
85854>>>>>>>>
85854>>>>>>>        Loop
85855>>>>>>>>
85855>>>>>>>
85855>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
85856>>>>>>>        If (bOpen = False) Begin
85858>>>>>>>            Close hTable
85859>>>>>>>        End
85859>>>>>>>>
85859>>>>>>>
85859>>>>>>>        Function_Return bViewTableType
85860>>>>>>>    End_Function
85861>>>>>>>
85861>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85861>>>>>>>    //
85861>>>>>>>    // SQL utility function that returns a database type (string) constant
85861>>>>>>>    // corresponding to the passed iDbType.
85861>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85863>>>>>>>        String sRetval
85863>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85864>>>>>>>        Function_Return sRetval
85865>>>>>>>    End_Function
85866>>>>>>>
85866>>>>>>>    // SQL utility function that returns a database type constant (integer)
85866>>>>>>>    // corresponding to the passed sDbType string constant.
85866>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85868>>>>>>>        Integer iRetval
85868>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85869>>>>>>>        Function_Return iRetval
85870>>>>>>>    End_Function
85871>>>>>>>
85871>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85871>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85871>>>>>>>    // the SQL Connection program's grid.
85871>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85873>>>>>>>        String sRetval
85873>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85874>>>>>>>        Function_Return sRetval
85875>>>>>>>    End_Function
85876>>>>>>>
85876>>>>>>>    // Pass a driver name as a string and the function will return
85876>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85876>>>>>>>    // quite work and always returns "MS SQL Server"
85876>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85878>>>>>>>        Integer iRetval
85878>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85879>>>>>>>        Function_Return iRetval
85880>>>>>>>    End_Function
85881>>>>>>>
85881>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85881>>>>>>>    // that "fits" in the max allowed length for table names.
85881>>>>>>>    // Max number of characters allowed for table names;
85881>>>>>>>    // IBM DB2      = 128
85881>>>>>>>    // MS-SQL       = 128
85881>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85881>>>>>>>    // MySQL        = 64
85881>>>>>>>    // PostgreSQL   = 64
85881>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85883>>>>>>>        String sGUIDName
85883>>>>>>>        Integer iDbType iLength
85883>>>>>>>
85883>>>>>>>        Get piDbType to iDbType
85884>>>>>>>        Move (RandomHexUUID()) to sGUIDName
85885>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85886>>>>>>>        Move (Length(sGUIDName)) to iLength
85887>>>>>>>
85887>>>>>>>        Case Begin
85887>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85889>>>>>>>            If (iLength > 128) Begin
85891>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85892>>>>>>>            End
85892>>>>>>>>
85892>>>>>>>            Case Break
85893>>>>>>>
85893>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85896>>>>>>>            If (iLength > 128) Begin
85898>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85899>>>>>>>            End
85899>>>>>>>>
85899>>>>>>>            Case Break
85900>>>>>>>
85900>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85903>>>>>>>            If (iLength > 128) Begin
85905>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85906>>>>>>>            End
85906>>>>>>>>
85906>>>>>>>            Case Break
85907>>>>>>>
85907>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85910>>>>>>>            If (iLength > 64) Begin
85912>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85913>>>>>>>            End
85913>>>>>>>>
85913>>>>>>>            Case Break
85914>>>>>>>
85914>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85917>>>>>>>            If (iLength > 64) Begin
85919>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85920>>>>>>>            End
85920>>>>>>>>
85920>>>>>>>        Case End
85920>>>>>>>
85920>>>>>>>        Function_Return sGUIDName
85921>>>>>>>    End_Function
85922>>>>>>>
85922>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85922>>>>>>>    // Pass the memory resource file reference and the filename to be created,
85922>>>>>>>    // including full path.
85922>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85924>>>>>>>        String sText
85924>>>>>>>        Integer iCh iSize iArgSize
85924>>>>>>>
85924>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85925>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85926>>>>>>>        Get_Channel_Size iCh to iSize
85927>>>>>>>        Read_Block channel iCh sText iSize
85929>>>>>>>        Send Seq_Close_Channel iCh
85930>>>>>>>
85930>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
85931>>>>>>>            Write channel iCh sText
85933>>>>>>>        Send Seq_Close_Channel iCh
85934>>>>>>>
85934>>>>>>>        // Wait for file to be written to disk.
85934>>>>>>>        Sleep 2
85935>>>>>>>    End_Procedure
85936>>>>>>>
85936>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85938>>>>>>>        String sNotNull sRetval sDefaultValue
85938>>>>>>>        Boolean bOK
85938>>>>>>>
85938>>>>>>>        Get IsSQLDriver sDriverID to bOK
85939>>>>>>>        If (bOK = False) Begin
85941>>>>>>>            Function_Return ""
85942>>>>>>>        End
85942>>>>>>>>
85942>>>>>>>
85942>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85943>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85944>>>>>>>
85944>>>>>>>        Case Begin
85944>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85946>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85947>>>>>>>                Case Break
85948>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85951>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85952>>>>>>>                Case Break
85953>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85956>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85957>>>>>>>                Case Break
85958>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85961>>>>>>>                Move (String(sNotNull))                                     to sRetval
85962>>>>>>>                Case Break
85963>>>>>>>
85963>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85963>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85963>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85966>>>>>>>                Move  ""                                                    to sRetval
85967>>>>>>>                Case Break
85968>>>>>>>
85968>>>>>>>            Case Else
85968>>>>>>>                Move  ""                                                    to sRetval
85969>>>>>>>        Case End
85969>>>>>>>
85969>>>>>>>        Function_Return sRetval
85970>>>>>>>    End_Function
85971>>>>>>>
85971>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85971>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85973>>>>>>>        Function_Return False
85974>>>>>>>    End_Function
85975>>>>>>>
85975>>>>>>>    // Enumerate SQL Servers.
85975>>>>>>>    // Pass a driver id. Returns a string array.
85975>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85975>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85975>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85977>>>>>>>        String[] sReturnArray
85978>>>>>>>        Handle hoSQLHandler
85978>>>>>>>        String sServer
85978>>>>>>>        Integer iCount iNumItems iDataSourceType
85978>>>>>>>
85978>>>>>>>        If (num_arguments > 1) Begin
85980>>>>>>>            Move iDatSrcType to iDataSourceType
85981>>>>>>>        End
85981>>>>>>>>
85981>>>>>>>
85981>>>>>>>        Case Begin
85981>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85983>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
85984>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
85985>>>>>>>                If (iNumItems = 0) Begin
85987>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
85988>>>>>>>                End
85988>>>>>>>>
85988>>>>>>>                For iCount from 0 to (iNumItems - 1)
85994>>>>>>>>
85994>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
85995>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85996>>>>>>>                Loop
85997>>>>>>>>
85997>>>>>>>                Case Break
85998>>>>>>>
85998>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86001>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86002>>>>>>>                Send SeedDataSources of hoSQLHandler
86003>>>>>>>                Move 0 to iCount
86004>>>>>>>                Repeat
86004>>>>>>>>
86004>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86005>>>>>>>                    If (sServer <> "") Begin
86007>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86008>>>>>>>                        Move sServer to sReturnArray[iCount]
86009>>>>>>>                    End
86009>>>>>>>>
86009>>>>>>>                    Increment iCount
86010>>>>>>>                Until (sServer = "")
86012>>>>>>>                Case Break
86013>>>>>>>
86013>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86016>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86017>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86018>>>>>>>                Move 0 to iCount
86019>>>>>>>                Repeat
86019>>>>>>>>
86019>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86020>>>>>>>                    If (sServer <> "") Begin
86022>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86023>>>>>>>                        Move sServer to sReturnArray[iCount]
86024>>>>>>>                    End
86024>>>>>>>>
86024>>>>>>>                    Increment iCount
86025>>>>>>>                Until (sServer = "")
86027>>>>>>>                Case Break
86028>>>>>>>
86028>>>>>>>            Case Else
86028>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86029>>>>>>>>
86029>>>>>>>        Case End
86029>>>>>>>
86029>>>>>>>        Function_Return sReturnArray
86030>>>>>>>    End_Function
86031>>>>>>>
86031>>>>>>>    // Returns all databases as a string array for the passed driver id.
86031>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86033>>>>>>>        String[] sReturnArray
86034>>>>>>>        String sServer sVal
86034>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86034>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86035>>>>>>>        tSQLConnection SQLConnection
86035>>>>>>>        tSQLConnection SQLConnection
86035>>>>>>>        Boolean bOK
86035>>>>>>>        Integer iCount iSize
86035>>>>>>>
86035>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86036>>>>>>>        If (bOK = False) Begin
86038>>>>>>>            Function_Return sReturnArray
86039>>>>>>>        End
86039>>>>>>>>
86039>>>>>>>
86039>>>>>>>        Case Begin
86039>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86041>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86042>>>>>>>                Case Break
86043>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86046>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86047>>>>>>>                Case Break
86048>>>>>>>
86048>>>>>>>            // This is needed to be able to check if a database exists or not.
86048>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86051>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86052>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86054>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86056>>>>>>>                        // If a FILEDSN: (can only be one database name)
86056>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86057>>>>>>>                    End
86057>>>>>>>>
86057>>>>>>>                    Else Begin
86058>>>>>>>                        // Else the DSN's were read from the registry.
86058>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86059>>>>>>>                        Move SQLConnection.sServer to sServer
86060>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86061>>>>>>>                        Decrement iSize
86062>>>>>>>                        for iCount from 0 to iSize
86068>>>>>>>>
86068>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86069>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86071>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86072>>>>>>>                                Move iSize to iCount // We're done.
86073>>>>>>>                            End
86073>>>>>>>>
86073>>>>>>>                        Loop
86074>>>>>>>>
86074>>>>>>>                    End
86074>>>>>>>>
86074>>>>>>>                End
86074>>>>>>>>
86074>>>>>>>                Case Break
86075>>>>>>>
86075>>>>>>>            Case Else
86075>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86075>>>>>>>        Case End
86075>>>>>>>
86075>>>>>>>        Function_Return sReturnArray
86076>>>>>>>    End_Function
86077>>>>>>>
86077>>>>>>>    
86077>>>>>>>    // *** Database API Functions: ***
86077>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86077>>>>>>>    // make changes/updates to the database.
86077>>>>>>>
86077>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86077>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86079>>>>>>>        Function_Return False
86080>>>>>>>    End_Function
86081>>>>>>>
86081>>>>>>>    // This might not do what you think - Here's what it does:
86081>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86081>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86081>>>>>>>    // to the SQL table.
86081>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86081>>>>>>>    // already exists in SQL.
86081>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86081>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86081>>>>>>>    // restructuring an existing table.
86081>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86083>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86083>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86083>>>>>>>        Handle hToTable
86083>>>>>>>
86083>>>>>>>        Move True to bUseConnectionID
86084>>>>>>>        If (num_arguments > 1) Begin
86086>>>>>>>            Move bUseConnID to bUseConnectionID
86087>>>>>>>        End
86087>>>>>>>>
86087>>>>>>>
86087>>>>>>>        Get psDriverID to sDriverID
86088>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86088>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86089>>>>>>>        If (bExists = False) Begin
86091>>>>>>>            Function_Return False
86092>>>>>>>        End
86092>>>>>>>>
86092>>>>>>>
86092>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86093>>>>>>>
86093>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86094>>>>>>>        If (bOK = False) Begin
86096>>>>>>>            Function_Return False
86097>>>>>>>        End
86097>>>>>>>>
86097>>>>>>>
86097>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86097>>>>>>>        // we do nothing
86097>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86098>>>>>>>        If (bExists = True) Begin
86100>>>>>>>            Function_Return False
86101>>>>>>>        End
86101>>>>>>>>
86101>>>>>>>
86101>>>>>>>        Get psConnectionID     to sConnectionID
86102>>>>>>>        Get psConnectionString to sConnectionString
86103>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86105>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86106>>>>>>>>
86106>>>>>>>            Function_Return False
86107>>>>>>>        End
86107>>>>>>>>
86107>>>>>>>
86107>>>>>>>        Set Private.phCurrentTable to hTable
86108>>>>>>>        Get psSchema to sSchema
86109>>>>>>>        If (sSchema = "") Begin
86111>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86112>>>>>>>        End
86112>>>>>>>>
86112>>>>>>>
86112>>>>>>>        // If we should use a connection id we need to check it exists;
86112>>>>>>>        // else we create it before attempting creating the table
86112>>>>>>>        If (bUseConnectionID = True) Begin
86114>>>>>>>            Get AutoConnectionIDLogin to bOK
86115>>>>>>>            If (bOk = False) Begin
86117>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86118>>>>>>>>
86118>>>>>>>                Function_Return False
86119>>>>>>>            End
86119>>>>>>>>
86119>>>>>>>        End
86119>>>>>>>>
86119>>>>>>>
86119>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86122>>>>>>>        Get _TableNameOnly sRootName to sRootName
86123>>>>>>>        If (sRootName = "") Begin
86125>>>>>>>            Function_Return False
86126>>>>>>>        End
86126>>>>>>>>
86126>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86127>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86130>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86133>>>>>>>
86133>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86133>>>>>>>        //
86133>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86133>>>>>>>        // because then the table should not be visible to users.
86133>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86133>>>>>>>//        If (iPos <> 1) Begin
86133>>>>>>>//            If (sDisplayName contains ".") Begin
86133>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86133>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86133>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86133>>>>>>>//            End
86133>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86133>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86133>>>>>>>//            End
86133>>>>>>>//        End
86133>>>>>>>
86133>>>>>>>        If (bIsAlias = False) Begin
86135>>>>>>>            Get OpenTableExclusive hTable to bOpened
86136>>>>>>>            If (bOpened = False) Begin
86138>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86139>>>>>>>>
86139>>>>>>>                Function_Return False
86140>>>>>>>            End
86140>>>>>>>>
86140>>>>>>>        End
86140>>>>>>>>
86140>>>>>>>
86140>>>>>>>        If (ghoProgressBar <> 0) Begin
86142>>>>>>>            Send DoAdvance of ghoProgressBar
86143>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86144>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86145>>>>>>>        End
86145>>>>>>>>
86145>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86145>>>>>>>        Move hTable to hToTable
86146>>>>>>>        Move False to Err
86147>>>>>>>
86147>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86147>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86147>>>>>>>        // a proper and updated .int file.
86147>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86150>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86151>>>>>>>
86151>>>>>>>        If (bIsAlias = False) Begin
86153>>>>>>>            Structure_Start hToTable sDriverID
86154>>>>>>>                Set Private.phCurrentTable to hTable
86155>>>>>>>                If (bUseConnectionID = True) Begin
86157>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86160>>>>>>>                End
86160>>>>>>>>
86160>>>>>>>                Else Begin
86161>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86164>>>>>>>                End
86164>>>>>>>>
86164>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86167>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86167>>>>>>>                Move False to Err
86168>>>>>>>                Move 0 to LastErr
86169>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86170>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86172>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86173>>>>>>>        End
86173>>>>>>>>
86173>>>>>>>
86173>>>>>>>        Move (not(Err)) to bOK
86174>>>>>>>        If (bOK = True) Begin
86176>>>>>>>            // The attributes set above will always trigger an error
86176>>>>>>>            // We also adjust the Filelist entries
86176>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86179>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86182>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86185>>>>>>>
86185>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86185>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86186>>>>>>>        End
86186>>>>>>>>
86186>>>>>>>
86186>>>>>>>        Function_Return (bOK = True)
86187>>>>>>>    End_Function
86188>>>>>>>
86188>>>>>>>    // Sample usage:
86188>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86188>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86188>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86190>>>>>>>        Boolean bOK bIsSQLTable
86190>>>>>>>
86190>>>>>>>        Get AutoConnectionIDLogin to bOK
86191>>>>>>>        Move False to Err
86192>>>>>>>        Get OpenTableExclusive hTable to bOK
86193>>>>>>>        If (bOK = False) Begin
86195>>>>>>>            Function_Return False
86196>>>>>>>        End
86196>>>>>>>>
86196>>>>>>>
86196>>>>>>>        // ToDo: Add to all table change functions!
86196>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86197>>>>>>>            If (bIsSQLTable = True) Begin
86199>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86202>>>>>>>            End
86202>>>>>>>>
86202>>>>>>>
86202>>>>>>>        Set Private.phCurrentTable to hTable
86203>>>>>>>        Structure_Start hTable
86204>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86207>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86208>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86210>>>>>>>
86210>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86211>>>>>>>        Function_Return (Err = False)
86212>>>>>>>    End_Function
86213>>>>>>>
86213>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86215>>>>>>>        Boolean bOK
86215>>>>>>>        
86215>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86216>>>>>>>        If (bOK = True) Begin
86218>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86219>>>>>>>        End
86219>>>>>>>>
86219>>>>>>>        
86219>>>>>>>        Function_Return (bOK = True)
86220>>>>>>>    End_Function
86221>>>>>>>    
86221>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86221>>>>>>>    // or to change the filelist slot names.
86221>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86223>>>>>>>        String sFileListName
86223>>>>>>>        
86223>>>>>>>        Move False to Err
86224>>>>>>>
86224>>>>>>>        If (ghoProgressBar <> 0) Begin
86226>>>>>>>            Send DoAdvance of ghoProgressBar
86227>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86228>>>>>>>        End
86228>>>>>>>>
86228>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86228>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86230>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86233>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86236>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86239>>>>>>>            Function_Return (Err = False) // And we're done.
86240>>>>>>>        End
86240>>>>>>>>
86240>>>>>>>
86240>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86242>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86242>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86243>>>>>>>        End
86243>>>>>>>>
86243>>>>>>>//        Else Begin
86243>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86243>>>>>>>//        End
86243>>>>>>>//
86243>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86243>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86243>>>>>>>
86243>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86246>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86249>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86252>>>>>>>        
86252>>>>>>>        Function_Return (Err = False)
86253>>>>>>>    End_Function
86254>>>>>>>
86254>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86256>>>>>>>        Boolean bOK
86256>>>>>>>
86256>>>>>>>        Get AutoConnectionIDLogin to bOK
86257>>>>>>>        Move False to Err
86258>>>>>>>        Get OpenTableExclusive hTable to bOK
86259>>>>>>>        If (bOK = False) Begin
86261>>>>>>>            Function_Return False
86262>>>>>>>        End
86262>>>>>>>>
86262>>>>>>>
86262>>>>>>>        Set Private.phCurrentTable to hTable
86263>>>>>>>        Structure_Start hTable
86264>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86267>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86268>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86270>>>>>>>
86270>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86271>>>>>>>        Function_Return (Err = False)
86272>>>>>>>    End_Function
86273>>>>>>>
86273>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86275>>>>>>>        Boolean bOK bIsSQLTable
86275>>>>>>>
86275>>>>>>>        Move False to Err
86276>>>>>>>        Get AutoConnectionIDLogin to bOK
86277>>>>>>>        Open hToTable
86279>>>>>>>        Get OpenTableExclusive hTable to bOK
86280>>>>>>>        If (bOK = False) Begin
86282>>>>>>>            Function_Return False
86283>>>>>>>        End
86283>>>>>>>>
86283>>>>>>>
86283>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86284>>>>>>>            If (bIsSQLTable = True) Begin
86286>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86289>>>>>>>            End
86289>>>>>>>>
86289>>>>>>>
86289>>>>>>>        Set Private.phCurrentTable to hTable
86290>>>>>>>        Structure_Start hTable
86291>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86294>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86297>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86298>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86300>>>>>>>
86300>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86301>>>>>>>        Function_Return (Err = False)
86302>>>>>>>    End_Function
86303>>>>>>>
86303>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86305>>>>>>>        Integer[] aTableConvertExceptions
86306>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86307>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86308>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86309>>>>>>>    End_Procedure
86310>>>>>>>
86310>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86312>>>>>>>        Integer[] aTableDateCorrectionExceptions
86313>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86314>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86315>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86316>>>>>>>    End_Procedure
86317>>>>>>>
86317>>>>>>>    Procedure ApiTableConvertALLToSql
86319>>>>>>>        Integer[] iTablesArray
86320>>>>>>>        Integer iSize iCount
86320>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86320>>>>>>>        String sDriverID
86320>>>>>>>
86320>>>>>>>        Get psDriverID to sDriverID
86321>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86322>>>>>>>        Get pbToANSI          to bToANSI
86323>>>>>>>        Get pbRecnum          to bRecnum
86324>>>>>>>        Get pbCopyData        to bCopyData
86325>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86327>>>>>>>            Get pbContinueOnError to bContinueOnError
86328>>>>>>>        End
86328>>>>>>>>
86328>>>>>>>
86328>>>>>>>        Get _AllTablesToConvert to iTablesArray
86329>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86330>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86331>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86332>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86333>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86334>>>>>>>
86334>>>>>>>        Decrement iSize
86335>>>>>>>        For iCount from 0 to iSize
86341>>>>>>>>
86341>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86342>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86343>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86343>>>>>>>            // if there was an error converting one table...
86343>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86343>>>>>>>        Loop
86344>>>>>>>>
86344>>>>>>>
86344>>>>>>>    End_Procedure
86345>>>>>>>
86345>>>>>>>    Procedure ApiTableAttachALLToSql
86347>>>>>>>        Integer[] iTablesArray
86348>>>>>>>        Integer iSize iCount
86348>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86348>>>>>>>        String sDriverID
86348>>>>>>>
86348>>>>>>>        Get psDriverID to sDriverID
86349>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86350>>>>>>>        Get pbToANSI          to bToANSI
86351>>>>>>>        Get pbRecnum          to bRecnum
86352>>>>>>>        Get pbCopyData        to bCopyData
86353>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86355>>>>>>>            Get pbContinueOnError to bContinueOnError
86356>>>>>>>        End
86356>>>>>>>>
86356>>>>>>>
86356>>>>>>>        Get _AllTablesToConvert to iTablesArray
86357>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86358>>>>>>>        Decrement iSize
86359>>>>>>>        For iCount from 0 to iSize
86365>>>>>>>>
86365>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86366>>>>>>>        Loop
86367>>>>>>>>
86367>>>>>>>
86367>>>>>>>    End_Procedure
86368>>>>>>>
86368>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86370>>>>>>>        Handle hToTable hoLogFile
86370>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86370>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86370>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86370>>>>>>>        tSQLConnection SQLConnection
86370>>>>>>>        tSQLConnection SQLConnection
86370>>>>>>>
86370>>>>>>>        Get _UtilTableExists hTable to bExists
86371>>>>>>>        If (bExists = False) Begin
86373>>>>>>>            Set Private.phCurrentTable to hTable
86374>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86375>>>>>>>>
86375>>>>>>>            Function_Return False
86376>>>>>>>        End
86376>>>>>>>>
86376>>>>>>>
86376>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86377>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86377>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86377>>>>>>>        If (bIsAlias = True) Begin
86379>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86382>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86384>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86387>>>>>>>                Get psConnectionID to sConnectionID
86388>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86389>>>>>>>            End
86389>>>>>>>>
86389>>>>>>>            Function_Return True
86390>>>>>>>        End
86390>>>>>>>>
86390>>>>>>>
86390>>>>>>>        Set Private.phCurrentTable to hTable
86391>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86394>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86397>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86400>>>>>>>
86400>>>>>>>        If (ghoProgressBar <> 0) Begin
86402>>>>>>>            Send DoAdvance of ghoProgressBar
86403>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86404>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86405>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86406>>>>>>>        End
86406>>>>>>>>
86406>>>>>>>
86406>>>>>>>        // Marco Kuipers suggestion;
86406>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86406>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86406>>>>>>>        // SQL table.
86406>>>>>>>        Get _UtilTableIsSql hTable to bOK
86407>>>>>>>        If (bOK = False) Begin
86409>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86410>>>>>>>            If (bExists = True) Begin
86412>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86412>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86412>>>>>>>                Get phoLogFile to hoLogFile
86413>>>>>>>                If (hoLogFile <> 0) Begin          
86415>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86416>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86416>>>>>>>                    Send LogError sWarning False
86417>>>>>>>                End
86417>>>>>>>>
86417>>>>>>>                Else Begin
86418>>>>>>>                    Error DFERR_PROGRAM sWarning
86419>>>>>>>>
86419>>>>>>>                End                                                       
86419>>>>>>>>
86419>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86420>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86421>>>>>>>            End
86421>>>>>>>>
86421>>>>>>>        End
86421>>>>>>>>
86421>>>>>>>
86421>>>>>>>        // Does the rootname contain a driver?
86421>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86423>>>>>>>            // Does the table already exist as an SQL table?
86423>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86424>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86424>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86424>>>>>>>            If (bExists = False) Begin
86426>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86427>>>>>>>            End
86427>>>>>>>>
86427>>>>>>>            If (bExists = True) Begin
86429>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86430>>>>>>>                Function_Return False
86431>>>>>>>            End
86431>>>>>>>>
86431>>>>>>>        End
86431>>>>>>>>
86431>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86432>>>>>>>
86432>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86433>>>>>>>        If (bUseConnectionID = True) Begin
86435>>>>>>>            Move False to bUseConnectionID
86436>>>>>>>        End
86436>>>>>>>>
86436>>>>>>>
86436>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86437>>>>>>>        Move SQLConnection.sSchema           to sSchema
86438>>>>>>>        If (sSchema = "") Begin
86440>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86441>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86442>>>>>>>        End
86442>>>>>>>>
86442>>>>>>>
86442>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86443>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86444>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86445>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86447>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86448>>>>>>>>
86448>>>>>>>            Function_Return False
86449>>>>>>>        End
86449>>>>>>>>
86449>>>>>>>
86449>>>>>>>        Get AutoConnectionIDLogin to bOK
86450>>>>>>>        Open hTable
86452>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86455>>>>>>>        If (bOpened = False) Begin
86457>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86458>>>>>>>>
86458>>>>>>>            Function_Return False
86459>>>>>>>        End
86459>>>>>>>>
86459>>>>>>>
86459>>>>>>>        If (ghoProgressBar <> 0) Begin
86461>>>>>>>            Send DoAdvance of ghoProgressBar
86462>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86463>>>>>>>        End
86463>>>>>>>>
86463>>>>>>>
86463>>>>>>>        Move 0 to hToTable
86464>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86465>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86466>>>>>>>
86466>>>>>>>        Case Begin
86466>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86468>>>>>>>                Case Break
86469>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86472>>>>>>>                Case Break
86473>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86476>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86477>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86478>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86479>>>>>>>                Case Break
86480>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86483>>>>>>>                Case Break
86484>>>>>>>            Case Else
86484>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86485>>>>>>>>
86485>>>>>>>                Case Break
86486>>>>>>>        Case End
86486>>>>>>>
86486>>>>>>>        Move False to Err
86487>>>>>>>
86487>>>>>>>        Structure_Start hToTable sDriverID
86488>>>>>>>            Structure_Copy hTable to hToTable
86489>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86492>>>>>>>
86492>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86494>>>>>>>                If (bUseConnectionID = True) Begin
86496>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86499>>>>>>>                End
86499>>>>>>>>
86499>>>>>>>                Else Begin
86500>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86503>>>>>>>                End
86503>>>>>>>>
86503>>>>>>>
86503>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86506>>>>>>>
86506>>>>>>>                If (sSchema <> "") Begin
86508>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86511>>>>>>>                End
86511>>>>>>>>
86511>>>>>>>
86511>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86513>>>>>>>                    If (sLongTableSpace <> "") Begin
86515>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86518>>>>>>>                    End
86518>>>>>>>>
86518>>>>>>>                    If (sBaseTableSpace <> "") Begin
86520>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86523>>>>>>>                    End
86523>>>>>>>>
86523>>>>>>>                    If (sIndexTableSpace <> "") Begin
86525>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86528>>>>>>>                    End
86528>>>>>>>>
86528>>>>>>>                End
86528>>>>>>>>
86528>>>>>>>            End
86528>>>>>>>>
86528>>>>>>>
86528>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86529>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86531>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86532>>>>>>>
86532>>>>>>>        Move (not(Err)) to bOK
86533>>>>>>>
86533>>>>>>>        If (bOK = True and bCopyData = True) Begin
86535>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86536>>>>>>>
86536>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86538>>>>>>>                Get pbContinueOnError to bContinueOnError
86539>>>>>>>            End
86539>>>>>>>>
86539>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86539>>>>>>>            // rename it by adding a GUID to the end of the table name
86539>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86539>>>>>>>            // different rules how long a table name can be.
86539>>>>>>>            // The new table will probably contain data but something went
86539>>>>>>>            // wrong while converting the data from embedded to SQL.
86539>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86541>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86542>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86543>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86544>>>>>>>>
86544>>>>>>>            End
86544>>>>>>>>
86544>>>>>>>        End
86544>>>>>>>>
86544>>>>>>>
86544>>>>>>>        // This must be after copying data...
86544>>>>>>>        If (Err = False) Begin
86546>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86549>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86549>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86549>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86549>>>>>>>            //                // The max length for the display_name is 31 characters...
86549>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86549>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86549>>>>>>>            //                End
86549>>>>>>>            //            End
86549>>>>>>>        End
86549>>>>>>>>
86549>>>>>>>
86549>>>>>>>        Close hTable
86550>>>>>>>        Move (not(Err)) to bOK
86551>>>>>>>        Function_Return bOK
86552>>>>>>>    End_Function
86553>>>>>>>
86553>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86553>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86553>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86553>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86555>>>>>>>        Boolean bOpened bOK
86555>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86555>>>>>>>        String sErrorFile sEmpty sPath
86555>>>>>>>
86555>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86558>>>>>>>        Get AutoConnectionIDLogin to bOK
86559>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86561>>>>>>>            Send IncreaseSortBufferSize
86562>>>>>>>//            Send SetAllIndexesToBatch hToTable
86562>>>>>>>        End
86562>>>>>>>>
86562>>>>>>>
86562>>>>>>>        Move False to Err
86563>>>>>>>        Open sPhysicalName as hToTable
86565>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86568>>>>>>>        If (bOpened = False) Begin
86570>>>>>>>            Function_Return False
86571>>>>>>>        End
86571>>>>>>>>
86571>>>>>>>
86571>>>>>>>        If (ghoStatusPanel <> 0) Begin
86573>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86574>>>>>>>            Set piMinimum of ghoProgressBar to 0
86575>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86576>>>>>>>        End
86576>>>>>>>>
86576>>>>>>>
86576>>>>>>>        Move "" to sEmpty
86577>>>>>>>        Move False to Err
86578>>>>>>>        Move True to bOK
86579>>>>>>>        Set Private.phCurrentTable to hToTable
86580>>>>>>>
86580>>>>>>>        // No need to get the record identifier
86580>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86583>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86586>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86588>>>>>>>            // Remove all indices to speed up copying of data:
86588>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86593>>>>>>>            If (iRetval <> 0) Begin       
86595>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86596>>>>>>>>
86596>>>>>>>                Close hToTable
86597>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86600>>>>>>>                Function_Return False
86601>>>>>>>            End
86601>>>>>>>>
86601>>>>>>>        End
86601>>>>>>>>
86601>>>>>>>
86601>>>>>>>        Move (sRootName + ".err") to sErrorFile
86602>>>>>>>        Move 0 to iIndex
86603>>>>>>>        Move False to Err
86604>>>>>>>
86604>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86606>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86609>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86614>>>>>>>            If (iRetval <> 0) Begin
86616>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86617>>>>>>>>
86617>>>>>>>                Close hToTable
86618>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86621>>>>>>>                Function_Return False
86622>>>>>>>            End
86622>>>>>>>>
86622>>>>>>>        End
86622>>>>>>>>
86622>>>>>>>        Else Begin
86623>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86626>>>>>>>        End
86626>>>>>>>>
86626>>>>>>>
86626>>>>>>>        If (Err = False) Begin
86628>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86629>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86630>>>>>>>        End
86630>>>>>>>>
86630>>>>>>>
86630>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86632>>>>>>>            // Recreate indices:
86632>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86637>>>>>>>            If (iRetval <> 0) Begin
86639>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86640>>>>>>>>
86640>>>>>>>                Close hToTable
86641>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86644>>>>>>>                Function_Return False
86645>>>>>>>            End
86645>>>>>>>>
86645>>>>>>>        End
86645>>>>>>>>
86645>>>>>>>
86645>>>>>>>        Close hToTable
86646>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86649>>>>>>>
86649>>>>>>>        If (bOK = True) Begin
86651>>>>>>>            Move (not(Err)) to bOK
86652>>>>>>>        End
86652>>>>>>>>
86652>>>>>>>
86652>>>>>>>        If (ghoStatusPanel <> 0) Begin
86654>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86655>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86656>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86657>>>>>>>        End
86657>>>>>>>>
86657>>>>>>>
86657>>>>>>>        Function_Return (bOK = True)
86658>>>>>>>    End_Function
86659>>>>>>>
86659>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86659>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86659>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86661>>>>>>>        Handle hFile
86661>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86661>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86661>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86661>>>>>>>        tSQLConnection SQLConnection
86661>>>>>>>        tSQLConnection SQLConnection
86661>>>>>>>        tAPIColumn[] aColumns
86661>>>>>>>        tAPIColumn[] aColumns
86662>>>>>>>        tColumnType ColumnType
86662>>>>>>>        tColumnType ColumnType
86662>>>>>>>
86662>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86662>>>>>>>        Get _UtilTableExists hTable to bOk
86663>>>>>>>        If (bOk = True) Begin
86665>>>>>>>            Function_Return False
86666>>>>>>>        End
86666>>>>>>>>
86666>>>>>>>
86666>>>>>>>        Set Private.phCurrentTable to hTable
86667>>>>>>>        Move sLogicalName to sTableName
86668>>>>>>>        If (ghoProgressBar <> 0) Begin
86670>>>>>>>            Send DoAdvance of ghoProgressBar
86671>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86672>>>>>>>        End
86672>>>>>>>>
86672>>>>>>>
86672>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86673>>>>>>>        Get psDriverID to sDriverID
86674>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86675>>>>>>>        Get piDbType to iDbType
86676>>>>>>>
86676>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86676>>>>>>>        Move False to bDeleteDummy
86677>>>>>>>        If (Num_Arguments = 8) Begin
86679>>>>>>>            Move aColumnIn to aColumns
86680>>>>>>>        End
86680>>>>>>>>
86680>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86682>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86683>>>>>>>            Move ColumnType.iSQLType to iDataType
86684>>>>>>>            If (bRecnum = False) Begin
86686>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86687>>>>>>>            End
86687>>>>>>>>
86687>>>>>>>            Else Begin
86688>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86689>>>>>>>            End
86689>>>>>>>>
86689>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86690>>>>>>>            Move True to bDeleteDummy
86691>>>>>>>        End
86691>>>>>>>>
86691>>>>>>>
86691>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86691>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86691>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86691>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86691>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86693>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86694>>>>>>>            Decrement iSize
86695>>>>>>>            for iCount from 0 to iSize
86701>>>>>>>>
86701>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86703>>>>>>>                    Move False to bRecnum
86704>>>>>>>                    Move iSize to iCount
86705>>>>>>>                End
86705>>>>>>>>
86705>>>>>>>            Loop
86706>>>>>>>>
86706>>>>>>>        End
86706>>>>>>>>
86706>>>>>>>
86706>>>>>>>        // If this is a SQL based driver we also check if the table exists
86706>>>>>>>        // in the SQL back end; in case we do nothing.
86706>>>>>>>        If (bSqlDriver = True) Begin
86708>>>>>>>            // Get all connection properties
86708>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86709>>>>>>>            Move SQLConnection.sSchema to sSchema
86710>>>>>>>            If (sSchema = "") Begin
86712>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86713>>>>>>>            End
86713>>>>>>>>
86713>>>>>>>
86713>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86714>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86714>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86714>>>>>>>            If (bExists = False) Begin
86716>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86717>>>>>>>            End
86717>>>>>>>>
86717>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86717>>>>>>>            // we will just add it to Filelist.cfg
86717>>>>>>>            If (bExists = True) Begin
86719>>>>>>>                If (bExistsInFilelist = False) Begin
86721>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86723>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86724>>>>>>>                    End
86724>>>>>>>>
86724>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86727>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86730>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86733>>>>>>>                    Move False to bSysFile
86734>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86735>>>>>>>                End
86735>>>>>>>>
86735>>>>>>>                Function_Return False
86736>>>>>>>            End
86736>>>>>>>>
86736>>>>>>>        End
86736>>>>>>>>
86736>>>>>>>
86736>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86737>>>>>>>        If (num_arguments > 6) Begin
86739>>>>>>>            If (bANSI = False) Begin
86741>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86742>>>>>>>            End
86742>>>>>>>>
86742>>>>>>>        End
86742>>>>>>>>
86742>>>>>>>
86742>>>>>>>        Move False to Err
86743>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86745>>>>>>>            Move sRootName to sPhysicalFile
86746>>>>>>>        End
86746>>>>>>>>
86746>>>>>>>
86746>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86748>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86749>>>>>>>
86749>>>>>>>            // If DAW driver and we should use a connection id we need to
86749>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86749>>>>>>>            If (bUseConnectionID = True) Begin
86751>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86752>>>>>>>                If (bExists = False) Begin
86754>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86755>>>>>>>                    If (bOk = False) Begin
86757>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86758>>>>>>>>
86758>>>>>>>                        Function_Return False
86759>>>>>>>                    End
86759>>>>>>>>
86759>>>>>>>                End
86759>>>>>>>>
86759>>>>>>>            End
86759>>>>>>>>
86759>>>>>>>
86759>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86761>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86762>>>>>>>            End
86762>>>>>>>>
86762>>>>>>>            Else Begin
86763>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86764>>>>>>>            End
86764>>>>>>>>
86764>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86765>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86765>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86765>>>>>>>//            End
86765>>>>>>>        End
86765>>>>>>>>
86765>>>>>>>        Move False to Err
86766>>>>>>>        Move 0 to hFile
86767>>>>>>>
86767>>>>>>>        Structure_Start hFile sDriverID
86768>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86770>>>>>>>                If (bUseConnectionID = True) Begin
86772>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86775>>>>>>>                End
86775>>>>>>>>
86775>>>>>>>                Else Begin
86776>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86779>>>>>>>                End
86779>>>>>>>>
86779>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86782>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86785>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86788>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86791>>>>>>>
86791>>>>>>>                If (sSchema <> "") Begin
86793>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86796>>>>>>>                End
86796>>>>>>>>
86796>>>>>>>
86796>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86798>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86800>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86803>>>>>>>                    End
86803>>>>>>>>
86803>>>>>>>                End
86803>>>>>>>>
86803>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86805>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86807>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86810>>>>>>>                    End
86810>>>>>>>>
86810>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86812>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86815>>>>>>>                    End
86815>>>>>>>>
86815>>>>>>>                End
86815>>>>>>>>
86815>>>>>>>            End
86815>>>>>>>>
86815>>>>>>>
86815>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86818>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86819>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86820>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86822>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86823>>>>>>>
86823>>>>>>>        Move (not(Err)) to bOK
86824>>>>>>>        If (bOk = True) Begin
86826>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86828>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86829>>>>>>>            End
86829>>>>>>>>
86829>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86832>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86835>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86838>>>>>>>
86838>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86838>>>>>>>            If (bDeleteDummy) Begin
86840>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86841>>>>>>>            End
86841>>>>>>>>
86841>>>>>>>        End
86841>>>>>>>>
86841>>>>>>>
86841>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86842>>>>>>>        Close hTable
86843>>>>>>>        Function_Return (bOK = True)
86844>>>>>>>    End_Function
86845>>>>>>>
86845>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86847>>>>>>>        Move False to Err
86848>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86851>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86854>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86857>>>>>>>
86857>>>>>>>        Function_Return (Err = False)
86858>>>>>>>    End_Function
86859>>>>>>>
86859>>>>>>>    // ToDo: Needs to be revised
86859>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86861>>>>>>>        Handle hTable
86861>>>>>>>        String sDEFName sDataPath
86861>>>>>>>        Boolean bExists
86861>>>>>>>
86861>>>>>>>        // Do nothing if MSSQL Driver.
86861>>>>>>>//        Get IsMSSQLDriver to bExists
86861>>>>>>>//        If (bExists = True) Begin
86861>>>>>>>//            Procedure_Return
86861>>>>>>>//        End
86861>>>>>>>
86861>>>>>>>        Get psDataPathFirstPart to sDataPath
86862>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86863>>>>>>>        If (bExists = True) Begin
86865>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86865>>>>>>>            // still be missing from the filelist and needs to be added.
86865>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86866>>>>>>>            If (bExists = True) Begin
86868>>>>>>>                Procedure_Return
86869>>>>>>>            End
86869>>>>>>>>
86869>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86869>>>>>>>            Else Begin
86870>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86873>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86876>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86879>>>>>>>                Procedure_Return
86880>>>>>>>            End
86880>>>>>>>>
86880>>>>>>>        End
86880>>>>>>>>
86880>>>>>>>
86880>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86881>>>>>>>        Move 0 to hTable
86882>>>>>>>        Move False to Err
86883>>>>>>>
86883>>>>>>>        Structure_Start hTable DATAFLEX_ID
86884>>>>>>>            Load_Def sDEFName Onto hTable
86885>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86888>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86889>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86891>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86892>>>>>>>
86892>>>>>>>        Move iFilelistSlot to hTable
86893>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86896>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86899>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86902>>>>>>>
86902>>>>>>>    End_Procedure
86903>>>>>>>
86903>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86905>>>>>>>        Boolean bTmp bErr bOK
86905>>>>>>>        String sTableName sDisplayName sFileName
86905>>>>>>>
86905>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86905>>>>>>>        Move Err to bTmp
86906>>>>>>>        Move False to Err
86907>>>>>>>
86907>>>>>>>        Get AutoConnectionIDLogin to bOK
86908>>>>>>>        // First get the info for the current filelist slot:
86908>>>>>>>        Open iFromFileSlot
86910>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86913>>>>>>>        If (bOK = True) Begin
86915>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86918>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86921>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86924>>>>>>>
86924>>>>>>>            //...then move it.
86924>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86927>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86930>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86933>>>>>>>
86933>>>>>>>            //...and finally remove the old filelist values.
86933>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86936>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86939>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86942>>>>>>>        End
86942>>>>>>>>
86942>>>>>>>        Close iFromFileSlot
86943>>>>>>>
86943>>>>>>>        Move Err to bErr
86944>>>>>>>        Move bTmp to Err
86945>>>>>>>        Function_Return (bErr = False)
86946>>>>>>>    End_Function
86947>>>>>>>
86947>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86949>>>>>>>        Handle hTable
86949>>>>>>>        Boolean bOK
86949>>>>>>>        String sDriverID
86949>>>>>>>
86949>>>>>>>        Get _UtilTableExists hTableFrom to bOK
86950>>>>>>>        If (bOK = False) Begin
86952>>>>>>>            Set Private.phCurrentTable to hTableFrom
86953>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86954>>>>>>>>
86954>>>>>>>            Function_Return False
86955>>>>>>>        End
86955>>>>>>>>
86955>>>>>>>
86955>>>>>>>        Get _UtilTableExists hTableTo to bOK
86956>>>>>>>        If (bOK = False) Begin
86958>>>>>>>            Set Private.phCurrentTable to hTableTo
86959>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86960>>>>>>>>
86960>>>>>>>            Function_Return False
86961>>>>>>>        End
86961>>>>>>>>
86961>>>>>>>
86961>>>>>>>        Get AutoConnectionIDLogin to bOK
86962>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86963>>>>>>>        If (bOK = False) Begin
86965>>>>>>>            Function_Return False
86966>>>>>>>        End
86966>>>>>>>>
86966>>>>>>>
86966>>>>>>>        Move False to Err
86967>>>>>>>        Open hTableTo
86969>>>>>>>
86969>>>>>>>        Move hTableFrom to hTable
86970>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86973>>>>>>>        Set Private.phCurrentTable to hTable
86974>>>>>>>
86974>>>>>>>        Structure_Start hTable sDriverID
86975>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86978>>>>>>>            If (iColumnTo <> 0) Begin
86980>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86983>>>>>>>            End
86983>>>>>>>>
86983>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86984>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86986>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86987>>>>>>>
86987>>>>>>>        If (hTableTo > 0) Begin
86989>>>>>>>            Close hTableTo
86990>>>>>>>        End
86990>>>>>>>>
86990>>>>>>>
86990>>>>>>>        Function_Return (Err = False)
86991>>>>>>>    End_Function
86992>>>>>>>
86992>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86992>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
86994>>>>>>>        String sTableName sDriverID
86994>>>>>>>        Boolean bOk
86994>>>>>>>        String sDataPath
86994>>>>>>>
86994>>>>>>>        Get AutoConnectionIDLogin to bOK
86995>>>>>>>        Move False to Err
86996>>>>>>>        Get psDriverID to sDriverID
86997>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86998>>>>>>>        If (sTableName = "") Begin
87000>>>>>>>            Function_Return False
87001>>>>>>>        End
87001>>>>>>>>
87001>>>>>>>
87001>>>>>>>        Set Private.phCurrentTable to hTable
87002>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87003>>>>>>>        Delete_db sTableName
87004>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87005>>>>>>>
87005>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87007>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87007>>>>>>>            Get psDataPathFirstPart to sDataPath
87008>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87009>>>>>>>        End
87009>>>>>>>>
87009>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87009>>>>>>>        If (hTable <> 0) Begin
87011>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87014>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87017>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87020>>>>>>>        End
87020>>>>>>>>
87020>>>>>>>
87020>>>>>>>        Close hTable
87021>>>>>>>        Function_Return (hTable <> 0)
87022>>>>>>>    End_Function
87023>>>>>>>
87023>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87025>>>>>>>        Handle hTable
87025>>>>>>>        Boolean bOK
87025>>>>>>>
87025>>>>>>>        Get AutoConnectionIDLogin to bOK
87026>>>>>>>        Move False to Err
87027>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87029>>>>>>>        Move hTableFrom to hTable
87030>>>>>>>
87030>>>>>>>        Structure_Start hTable
87031>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87034>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87035>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87037>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87038>>>>>>>
87038>>>>>>>        Close hTableFrom
87039>>>>>>>        Function_Return (Err = False)
87040>>>>>>>    End_Function
87041>>>>>>>
87041>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87043>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87043>>>>>>>        Boolean bOK bExists bOpened
87043>>>>>>>        tAPITableNameInfo APITableNameInfo
87043>>>>>>>        tAPITableNameInfo APITableNameInfo
87043>>>>>>>
87043>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87046>>>>>>>        If (bOpened = False) Begin
87048>>>>>>>            Get OpenTableExclusive hTable to bOpened
87049>>>>>>>            If (bOpened = False) Begin
87051>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87052>>>>>>>                Function_Return False
87053>>>>>>>            End
87053>>>>>>>>
87053>>>>>>>        End
87053>>>>>>>>
87053>>>>>>>
87053>>>>>>>        Set Private.phCurrentTable to hTable
87054>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87055>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87056>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87057>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87058>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87059>>>>>>>        If (bExists = True) Begin
87061>>>>>>>            Function_Return True
87062>>>>>>>        End
87062>>>>>>>>
87062>>>>>>>
87062>>>>>>>        Set Private.phCurrentTable to hTable
87063>>>>>>>        Move False to Err
87064>>>>>>>        Get psDataPathFirstPart to sDataPath
87065>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87068>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87071>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87074>>>>>>>
87074>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87077>>>>>>>        Close hTable
87078>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87080>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87081>>>>>>>            If (bExists = True) Begin
87083>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87085>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87088>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87088>>>>>>>                    // might report "File in use..." and the deletion will fail.
87088>>>>>>>                    Sleep 2
87089>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87090>>>>>>>                End
87090>>>>>>>>
87090>>>>>>>            End
87090>>>>>>>>
87090>>>>>>>        End
87090>>>>>>>>
87090>>>>>>>
87090>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87092>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87094>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87095>>>>>>>            End
87095>>>>>>>>
87095>>>>>>>
87095>>>>>>>            // Change the table name in the .int file to the new table new:
87095>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87096>>>>>>>            If (bOK = False) Begin
87098>>>>>>>                Function_Return False
87099>>>>>>>            End
87099>>>>>>>>
87099>>>>>>>
87099>>>>>>>            // Change table name at the SQL side:
87099>>>>>>>            Get psSchema to sSchema
87100>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87101>>>>>>>
87101>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87102>>>>>>>            // Remove cache file and Rename the physical file names:
87102>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87103>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87104>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87105>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87106>>>>>>>
87106>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87106>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87106>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87106>>>>>>>//            End
87106>>>>>>>        End
87106>>>>>>>>
87106>>>>>>>
87106>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87109>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87112>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87115>>>>>>>
87115>>>>>>>        Function_Return (Err = False)
87116>>>>>>>    End_Function
87117>>>>>>>
87117>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87119>>>>>>>        Move False to Err
87120>>>>>>>        Set Private.phCurrentTable to hTable
87121>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87124>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87127>>>>>>>
87127>>>>>>>        Function_Return (Err = False)
87128>>>>>>>    End_Function
87129>>>>>>>
87129>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
87129>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87131>>>>>>>        Handle hTable
87131>>>>>>>        String sTableName
87131>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87131>>>>>>>        Integer iDbType
87131>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK
87131>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87131>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87131>>>>>>>        tSQLConnection SQLConnection
87131>>>>>>>        tSQLConnection SQLConnection
87131>>>>>>>        tAPITable      APITableFrom APITableTo
87131>>>>>>>        tAPITable      APITableFrom APITableTo
87131>>>>>>>        tColumnType    ColumnType
87131>>>>>>>        tColumnType    ColumnType
87131>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87131>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87132>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87132>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87133>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87133>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87134>>>>>>>
87134>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87134>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87136>>>>>>>            Function_Return False
87137>>>>>>>        End
87137>>>>>>>>
87137>>>>>>>        
87137>>>>>>>        Move True to bOk
87138>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87139>>>>>>>        Get piDbType                            to iDbType
87140>>>>>>>        Get pbRecnum                            to bRecnum
87141>>>>>>>        Get pbToANSI                            to bToANSI
87142>>>>>>>        Get pbCopyData                          to bCopyData
87143>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87144>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87145>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87146>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87147>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87148>>>>>>>
87148>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87149>>>>>>>        Set Private.phCurrentTable              to hTable
87150>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87151>>>>>>>
87151>>>>>>>        If (ghoProgressBar <> 0) Begin
87153>>>>>>>            Send DoAdvance of ghoProgressBar
87154>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87155>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87156>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87157>>>>>>>        End
87157>>>>>>>>
87157>>>>>>>
87157>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87158>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87159>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87160>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87161>>>>>>>        Move True                               to APITableFrom.bFromTable
87162>>>>>>>        Move hTable                             to APITableFrom.hTable
87163>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87164>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87165>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87166>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87167>>>>>>>
87167>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87167>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87169>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87170>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87171>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87173>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87176>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87177>>>>>>>>
87177>>>>>>>                Function_Return False
87178>>>>>>>            End
87178>>>>>>>>
87178>>>>>>>        End
87178>>>>>>>>
87178>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin 
87180>>>>>>>            If (bOk = True) Begin
87182>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
87183>>>>>>>                Function_Return bOk
87184>>>>>>>            End 
87184>>>>>>>>
87184>>>>>>>        End
87184>>>>>>>>
87184>>>>>>>
87184>>>>>>>        If (bTableExists = True) Begin
87186>>>>>>>            If (bIsSQLTableTo = True) Begin
87188>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87189>>>>>>>            End
87189>>>>>>>>
87189>>>>>>>
87189>>>>>>>            Get OpenTableExclusive hTable to bOpened
87190>>>>>>>            If (bOpened = False) Begin
87192>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87193>>>>>>>                Function_Return False
87194>>>>>>>            End
87194>>>>>>>>
87194>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87195>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87196>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87197>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87198>>>>>>>        End
87198>>>>>>>>
87198>>>>>>>
87198>>>>>>>        Move True to bOk
87199>>>>>>>        Move False to Err
87200>>>>>>>        Case Begin
87200>>>>>>>            // Alias table:
87200>>>>>>>            Case (bIsAliasFrom = True)
87202>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87202>>>>>>>                Case Break
87203>>>>>>>
87203>>>>>>>            // New Table:
87203>>>>>>>            Case (bTableExists = False)
87206>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87207>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87207>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87209>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87210>>>>>>>                End                                                                 
87210>>>>>>>>
87210>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87211>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87212>>>>>>>                Case Break
87213>>>>>>>
87213>>>>>>>            // Update table:
87213>>>>>>>            Case (bTableExists = True)
87216>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87217>>>>>>>                If (bIsSame = True) Begin
87219>>>>>>>                    Case Break
87220>>>>>>>                End
87220>>>>>>>>
87220>>>>>>>                If (bFilelistError = True) Begin
87222>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87223>>>>>>>                    If (bOk = False) Begin
87225>>>>>>>                        Case Break
87226>>>>>>>                    End
87226>>>>>>>>
87226>>>>>>>                End
87226>>>>>>>>
87226>>>>>>>
87226>>>>>>>                If (ghoProgressBar <> 0) Begin
87228>>>>>>>                    Send DoAdvance of ghoProgressBar
87229>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87230>>>>>>>                End
87230>>>>>>>>
87230>>>>>>>
87230>>>>>>>                // Columns:
87230>>>>>>>                Move True to bOk
87231>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87232>>>>>>>                If (bIsSame = False) Begin
87234>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87235>>>>>>>                End
87235>>>>>>>>
87235>>>>>>>                If (bOk = False) Begin
87237>>>>>>>                    Case Break
87238>>>>>>>                End
87238>>>>>>>>
87238>>>>>>>
87238>>>>>>>                // Indexes:
87238>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87239>>>>>>>                If (bIsSame = False) Begin
87241>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87242>>>>>>>                End
87242>>>>>>>>
87242>>>>>>>
87242>>>>>>>                // Relations:
87242>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87243>>>>>>>                If (bIsSame = False) Begin
87245>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87246>>>>>>>                    If (bOk = False) Begin
87248>>>>>>>                        Case Break
87249>>>>>>>                    End
87249>>>>>>>>
87249>>>>>>>                End
87249>>>>>>>>
87249>>>>>>>
87249>>>>>>>                Case Break
87250>>>>>>>
87250>>>>>>>            Case Else
87250>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87251>>>>>>>>
87251>>>>>>>                Move False to bOk
87252>>>>>>>        Case End
87252>>>>>>>        
87252>>>>>>>        If (bOk = True) Begin
87254>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87254>>>>>>>            // or convert an embedded table to SQL
87254>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87256>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87257>>>>>>>                If (bOk = False) Begin
87259>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87260>>>>>>>                End
87260>>>>>>>>
87260>>>>>>>            End
87260>>>>>>>>
87260>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87263>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87264>>>>>>>            End
87264>>>>>>>>
87264>>>>>>>            
87264>>>>>>>            // Filelist Names:
87264>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87265>>>>>>>        End
87265>>>>>>>>
87265>>>>>>>        
87265>>>>>>>        Close hTable
87266>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87267>>>>>>>
87267>>>>>>>        Function_Return bOK
87268>>>>>>>    End_Function
87269>>>>>>>
87269>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87269>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87271>>>>>>>        Function_Return False
87272>>>>>>>    End_Function
87273>>>>>>>
87273>>>>>>>    // Adds a column name to the passed table number.
87273>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87275>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87275>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87275>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87275>>>>>>>
87275>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87276>>>>>>>        If (bExists = True) Begin
87278>>>>>>>            Function_Return False
87279>>>>>>>        End
87279>>>>>>>>
87279>>>>>>>
87279>>>>>>>        Move False to Err
87280>>>>>>>        If (num_arguments > 4) Begin
87282>>>>>>>            Move iPrec to iPrecision
87283>>>>>>>        End
87283>>>>>>>>
87283>>>>>>>        If (num_arguments > 6) Begin
87285>>>>>>>            Move bInitVal to bInitializeValue
87286>>>>>>>            Move sColVal  to sColumnValue
87287>>>>>>>        End
87287>>>>>>>>
87287>>>>>>>        If (iType < -1490) Begin
87289>>>>>>>            Move (iType + 1500) to iType
87290>>>>>>>        End
87290>>>>>>>>
87290>>>>>>>
87290>>>>>>>        Move hTable to iFile
87291>>>>>>>        Get psDriverID to sDriverID
87292>>>>>>>        Get AutoConnectionIDLogin to bOK
87293>>>>>>>        Move False to Err
87294>>>>>>>        Move LastErr to iLastErr
87295>>>>>>>        Get OpenTableExclusive iFile to bOK
87296>>>>>>>        Set Private.phCurrentTable to hTable
87297>>>>>>>
87297>>>>>>>        Structure_Start iFile sDriverID
87298>>>>>>>            Move 0 to iColumn
87299>>>>>>>            Set Private.piCurrentField to iColumn
87300>>>>>>>            Create_Field hTable At iColumn
87301>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87304>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87307>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87310>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87313>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87314>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87316>>>>>>>
87316>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87317>>>>>>>
87317>>>>>>>        // If in development environment; create .fd file:
87317>>>>>>>        Open hTable
87319>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87320>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87321>>>>>>>        If (iCount > 1) Begin
87323>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87324>>>>>>>        End
87324>>>>>>>>
87324>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87325>>>>>>>        If (bExists = True) Begin
87327>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87328>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87331>>>>>>>            Get _TableNameOnly sTableName to sTableName
87332>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87334>>>>>>>        End
87334>>>>>>>>
87334>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87336>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87337>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87338>>>>>>>            If (iCount > 1) Begin
87340>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87341>>>>>>>            End
87341>>>>>>>>
87341>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87342>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87342>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87342>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87342>>>>>>>        End
87342>>>>>>>>
87342>>>>>>>        // Check for a default value
87342>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87344>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87345>>>>>>>        End
87345>>>>>>>>
87345>>>>>>>        Close hTable
87346>>>>>>>
87346>>>>>>>        Function_Return (Err = False)
87347>>>>>>>    End_Function
87348>>>>>>>
87348>>>>>>>    // Adds a column name to the passed table number.
87348>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87350>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87350>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87350>>>>>>>        String sDdSrcPath sTableName
87350>>>>>>>
87350>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87351>>>>>>>        Move False to Err
87352>>>>>>>        If (bExists = True) Begin
87354>>>>>>>            Function_Return False
87355>>>>>>>        End
87355>>>>>>>>
87355>>>>>>>        If (num_arguments > 4) Begin
87357>>>>>>>            Move iPrec to iPrecision
87358>>>>>>>        End
87358>>>>>>>>
87358>>>>>>>        If (iType < -1490) Begin
87360>>>>>>>            Move (iType + 1500) to iType
87361>>>>>>>        End
87361>>>>>>>>
87361>>>>>>>
87361>>>>>>>        Get AutoConnectionIDLogin to bOK
87362>>>>>>>        Move False to Err
87363>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87364>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87364>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87364>>>>>>>        Get piDbType to iDbType
87365>>>>>>>        If (bIsSQLTypeTo = False) Begin
87367>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87368>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87370>>>>>>>                Move DF_DATE to iType
87371>>>>>>>            End
87371>>>>>>>>
87371>>>>>>>        End
87371>>>>>>>>
87371>>>>>>>
87371>>>>>>>        // Structure_start will change the value of hTable...
87371>>>>>>>        Move hTable to iFile
87372>>>>>>>        Get OpenTableExclusive iFile to bOK
87373>>>>>>>        If (bOK = False) Begin
87375>>>>>>>            Function_Return False
87376>>>>>>>        End
87376>>>>>>>>
87376>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87379>>>>>>>
87379>>>>>>>        // If the passed column number is higher than the current number of fields
87379>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87379>>>>>>>        // a new field to the end:
87379>>>>>>>        If (iColumn > iNumberOfFields) Begin
87381>>>>>>>            Move 0 to iColumn
87382>>>>>>>        End
87382>>>>>>>>
87382>>>>>>>
87382>>>>>>>        Set Private.phCurrentTable to hTable
87383>>>>>>>        Set Private.piCurrentField to iColumn
87384>>>>>>>
87384>>>>>>>        Structure_Start iFile
87385>>>>>>>            Create_Field iFile At iColumn
87386>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87389>>>>>>>            If (bIsSQLTypeTo = False) Begin
87391>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87394>>>>>>>            End
87394>>>>>>>>
87394>>>>>>>            Else Begin
87395>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87398>>>>>>>            End
87398>>>>>>>>
87398>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87399>>>>>>>            If (bIsDateType = False) Begin
87401>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87404>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87407>>>>>>>            End
87407>>>>>>>>
87407>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87408>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87410>>>>>>>
87410>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87411>>>>>>>        // If in development environment; create .fd file:
87411>>>>>>>        Open hTable
87413>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87414>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87415>>>>>>>        If (iCount > 1) Begin
87417>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87418>>>>>>>        End
87418>>>>>>>>
87418>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87419>>>>>>>        If (bExists = True) Begin
87421>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87422>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87425>>>>>>>            Get _TableNameOnly sTableName to sTableName
87426>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87428>>>>>>>        End
87428>>>>>>>>
87428>>>>>>>
87428>>>>>>>        // Check for a default value
87428>>>>>>>        Close hTable
87429>>>>>>>
87429>>>>>>>        Function_Return (Err = False)
87430>>>>>>>    End_Function
87431>>>>>>>
87431>>>>>>>    // To update all records for a table column with a fixed value.
87431>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87433>>>>>>>        Integer iRecs iCurrErr iField iRecord
87433>>>>>>>        Boolean bRetval bOpen
87433>>>>>>>
87433>>>>>>>        Move 0 to iRecs
87434>>>>>>>        Move False to bRetval
87435>>>>>>>        Move Err to iCurrErr
87436>>>>>>>        Move False to Err
87437>>>>>>>
87437>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87440>>>>>>>        If (bOpen = False) Begin
87442>>>>>>>            Open hTable
87444>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87447>>>>>>>            If (bOpen = False) Begin
87449>>>>>>>                Function_Return bRetval
87450>>>>>>>            End
87450>>>>>>>>
87450>>>>>>>        End
87450>>>>>>>>
87450>>>>>>>
87450>>>>>>>        Field_Map hTable sFieldName to iField
87452>>>>>>>        If (iField <> 0) Begin
87454>>>>>>>            Set Private.phCurrentTable to hTable
87455>>>>>>>            Set Private.piCurrentField to iField
87456>>>>>>>            Clear hTable
87457>>>>>>>            Repeat
87457>>>>>>>>
87457>>>>>>>                Vfind hTable 0 GT
87459>>>>>>>                If (Found) Begin
87461>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87463>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87466>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87467>>>>>>>                    End
87467>>>>>>>>
87467>>>>>>>                    Reread hTable
87471>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87474>>>>>>>                        SaveRecord hTable
87475>>>>>>>                    Unlock
87476>>>>>>>>
87476>>>>>>>                End
87476>>>>>>>>
87476>>>>>>>           Until (not(Found))
87478>>>>>>>        End
87478>>>>>>>>
87478>>>>>>>
87478>>>>>>>        Move (Err = False) to bRetval
87479>>>>>>>        Move iCurrErr to Err
87480>>>>>>>
87480>>>>>>>        Function_Return bRetval
87481>>>>>>>    End_Function
87482>>>>>>>
87482>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87482>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87484>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87484>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87484>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87484>>>>>>>
87484>>>>>>>        Get psDriverID to sDriverID
87485>>>>>>>        Get piDbType to iDbType
87486>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87487>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87488>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87489>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87490>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87492>>>>>>>            Move True to bIsSqlTable
87493>>>>>>>        End
87493>>>>>>>>
87493>>>>>>>        Move False to bIsOpen
87494>>>>>>>        If (hTable > 0) Begin
87496>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87499>>>>>>>        End
87499>>>>>>>>
87499>>>>>>>        If (bIsOpen = True) Begin
87501>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87504>>>>>>>        End
87504>>>>>>>>
87504>>>>>>>        Else Begin
87505>>>>>>>            Get pbRecnum to bRecnumTable
87506>>>>>>>        End
87506>>>>>>>>
87506>>>>>>>
87506>>>>>>>        Move False to Err
87507>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87508>>>>>>>        Decrement iSize
87509>>>>>>>        for iCount from 0 to iSize
87515>>>>>>>>
87515>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87516>>>>>>>            If (hTable > 0) Begin
87518>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87519>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87520>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87523>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87524>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87525>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87526>>>>>>>            End
87526>>>>>>>>
87526>>>>>>>            Else Begin
87527>>>>>>>                Move False to bFieldExists
87528>>>>>>>            End
87528>>>>>>>>
87528>>>>>>>
87528>>>>>>>            If (bFieldExists = False) Begin
87530>>>>>>>                Move 0 to iColumn
87531>>>>>>>                Create_Field hTable At iColumn
87532>>>>>>>            End
87532>>>>>>>>
87532>>>>>>>            Else Begin
87533>>>>>>>                Move iCount to iColumn
87534>>>>>>>            End
87534>>>>>>>>
87534>>>>>>>
87534>>>>>>>            Set Private.piCurrentField to iColumn
87535>>>>>>>
87535>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87536>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87539>>>>>>>
87539>>>>>>>            Move aColumns[iCount].iType to iType
87540>>>>>>>            Move (not(iType < -1490)) to bNativeType
87541>>>>>>>            If (iType < -1490) Begin
87543>>>>>>>                Move (iType + 1500) to iType
87544>>>>>>>            End
87544>>>>>>>>
87544>>>>>>>
87544>>>>>>>            If (bIsSqlTable = True) Begin
87546>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87548>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87549>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87552>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87555>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87558>>>>>>>
87558>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87559>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87561>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87562>>>>>>>                    End
87562>>>>>>>>
87562>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87565>>>>>>>
87565>>>>>>>                End
87565>>>>>>>>
87565>>>>>>>                Else Begin
87566>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87569>>>>>>>                End
87569>>>>>>>>
87569>>>>>>>            End
87569>>>>>>>>
87569>>>>>>>            Else Begin
87570>>>>>>>                If (bCreating = False) Begin
87572>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87573>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87575>>>>>>>                        Move DF_DATE to iType
87576>>>>>>>                    End
87576>>>>>>>>
87576>>>>>>>                End
87576>>>>>>>>
87576>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87579>>>>>>>            End
87579>>>>>>>>
87579>>>>>>>
87579>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87580>>>>>>>            If (bIsDateType = False) Begin
87582>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87585>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87588>>>>>>>            End
87588>>>>>>>>
87588>>>>>>>
87588>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87590>>>>>>>                Move 0 to iIndex
87591>>>>>>>                Create_Index hTable at iIndex
87592>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87595>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87598>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87601>>>>>>>
87601>>>>>>>                // If we have an identity table - we must create a primary_key table.
87601>>>>>>>                If (bIsSqlTable = True) Begin
87603>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87606>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87609>>>>>>>                End
87609>>>>>>>>
87609>>>>>>>            End
87609>>>>>>>>
87609>>>>>>>        Loop
87610>>>>>>>>
87610>>>>>>>
87610>>>>>>>        Function_Return (Err = False)
87611>>>>>>>    End_Function
87612>>>>>>>
87612>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87612>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87614>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87614>>>>>>>        Boolean bOK bIsSqlTable
87614>>>>>>>        String sFieldNameTo
87614>>>>>>>
87614>>>>>>>        If (num_arguments > 4) Begin
87616>>>>>>>            Move iPrec to iPrecFrom
87617>>>>>>>        End
87617>>>>>>>>
87617>>>>>>>        If (iTypeFrom < -1490) Begin
87619>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87620>>>>>>>        End
87620>>>>>>>>
87620>>>>>>>
87620>>>>>>>        Get AutoConnectionIDLogin to bOK
87621>>>>>>>        Move False to Err
87622>>>>>>>        Get OpenTableExclusive hTable to bOK
87623>>>>>>>        If (bOK = False) Begin
87625>>>>>>>            Function_Return False
87626>>>>>>>        End
87626>>>>>>>>
87626>>>>>>>
87626>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87627>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87628>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87630>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87631>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87632>>>>>>>        If (Err = True) Begin
87634>>>>>>>            Function_Return False
87635>>>>>>>        End
87635>>>>>>>>
87635>>>>>>>
87635>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87638>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87639>>>>>>>        If (bIsSqlTable = False) Begin
87641>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87644>>>>>>>        End
87644>>>>>>>>
87644>>>>>>>        Else Begin
87645>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87648>>>>>>>        End
87648>>>>>>>>
87648>>>>>>>        // Let the driver decide the other values;
87648>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87651>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87654>>>>>>>
87654>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87656>>>>>>>            Function_Return False
87657>>>>>>>        End
87657>>>>>>>>
87657>>>>>>>
87657>>>>>>>        Set Private.phCurrentTable to hTable
87658>>>>>>>        Set Private.piCurrentField to iColumn
87659>>>>>>>
87659>>>>>>>        Structure_Start hTable
87660>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87663>>>>>>>//            If (bIsSqlTable = False) Begin
87663>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87666>>>>>>>//            End
87666>>>>>>>//            Else Begin
87666>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87666>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87666>>>>>>>//            End
87666>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87669>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87672>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87673>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87675>>>>>>>
87675>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87676>>>>>>>        Function_Return (Err = False)
87677>>>>>>>    End_Function
87678>>>>>>>
87678>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87678>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87680>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87680>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87680>>>>>>>        String sFieldNameTo sDriverIDTo
87680>>>>>>>        tColumnType ColumnType
87680>>>>>>>        tColumnType ColumnType
87680>>>>>>>
87680>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87681>>>>>>>        Get piDbType to iDbType
87682>>>>>>>        If (num_arguments > 4) Begin
87684>>>>>>>            Move iPrec to iPrecFrom
87685>>>>>>>            Move iOpt  to iOptionFrom
87686>>>>>>>        End
87686>>>>>>>>
87686>>>>>>>        If (iTypeFrom < -1490) Begin
87688>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87689>>>>>>>        End
87689>>>>>>>>
87689>>>>>>>
87689>>>>>>>        Get AutoConnectionIDLogin to bOK
87690>>>>>>>        Move False to Err
87691>>>>>>>        Close hTable
87692>>>>>>>        Get OpenTableExclusive hTable to bOK
87693>>>>>>>        If (bOK = False) Begin
87695>>>>>>>            Function_Return False
87696>>>>>>>        End
87696>>>>>>>>
87696>>>>>>>
87696>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87699>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87702>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87703>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87705>>>>>>>            Move DF_DATE to iDataFlexType
87706>>>>>>>        End
87706>>>>>>>>
87706>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87709>>>>>>>
87709>>>>>>>        If (bIsSQLTableTo = True) Begin
87711>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87714>>>>>>>        End
87714>>>>>>>>
87714>>>>>>>        Else Begin
87715>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87718>>>>>>>        End
87718>>>>>>>>
87718>>>>>>>
87718>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87721>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87724>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87727>>>>>>>
87727>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87727>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87727>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87729>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87730>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87732>>>>>>>                Move DF_DATE to iTypeTo  
87733>>>>>>>            End
87733>>>>>>>>
87733>>>>>>>        End
87733>>>>>>>>
87733>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87736>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87737>>>>>>>        End
87737>>>>>>>>
87737>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87738>>>>>>>
87738>>>>>>>        If (bCompareDate_DateTime = False) Begin
87740>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87741>>>>>>>            If (bSkip = True) Begin
87743>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87745>>>>>>>                    Function_Return True
87746>>>>>>>                End
87746>>>>>>>>
87746>>>>>>>            End
87746>>>>>>>>
87746>>>>>>>        End
87746>>>>>>>>
87746>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87749>>>>>>>            Function_Return True
87750>>>>>>>        End
87750>>>>>>>>
87750>>>>>>>
87750>>>>>>>        Set Private.phCurrentTable to hTable
87751>>>>>>>        Set Private.piCurrentField to iColumn
87752>>>>>>>
87752>>>>>>>        Structure_Start hTable
87753>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87755>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87758>>>>>>>            End
87758>>>>>>>>
87758>>>>>>>
87758>>>>>>>            If (bIsSameDataType = False) Begin
87760>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87763>>>>>>>                If (bIsSQLTableTo = True) Begin
87765>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87768>>>>>>>                End
87768>>>>>>>>
87768>>>>>>>            End
87768>>>>>>>>
87768>>>>>>>
87768>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87770>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87773>>>>>>>            End
87773>>>>>>>>
87773>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87775>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87778>>>>>>>            End
87778>>>>>>>>
87778>>>>>>>
87778>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87780>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87780>>>>>>>                If (bRecnumTable = True) Begin
87782>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87785>>>>>>>                End
87785>>>>>>>>
87785>>>>>>>
87785>>>>>>>                // We might need to create an index here.
87785>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87785>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87785>>>>>>>                // index update checking logic.
87785>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87788>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87790>>>>>>>                    Create_Index hTable At iIndex
87791>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87794>>>>>>>                End
87794>>>>>>>>
87794>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87797>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87800>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87803>>>>>>>                If (bIsSQLTableTo = True) Begin
87805>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87808>>>>>>>                End
87808>>>>>>>>
87808>>>>>>>            End
87808>>>>>>>>
87808>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87809>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87811>>>>>>>
87811>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87812>>>>>>>        Function_Return (Err = False)
87813>>>>>>>    End_Function
87814>>>>>>>
87814>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87816>>>>>>>        Boolean bOK
87816>>>>>>>
87816>>>>>>>        Get AutoConnectionIDLogin to bOK
87817>>>>>>>        Move False to Err
87818>>>>>>>        Get OpenTableExclusive hTable to bOK
87819>>>>>>>        If (bOK = False) Begin
87821>>>>>>>            Function_Return False
87822>>>>>>>        End
87822>>>>>>>>
87822>>>>>>>
87822>>>>>>>        Structure_Start hTable
87823>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87826>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87827>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87829>>>>>>>
87829>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87830>>>>>>>        Function_Return (Err = False)
87831>>>>>>>    End_Function
87832>>>>>>>
87832>>>>>>>    // To move an existing field to another position in a table.
87832>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87834>>>>>>>        String sColumn sDriverID
87834>>>>>>>        Integer iType
87834>>>>>>>        Boolean bOK bIsDate
87834>>>>>>>
87834>>>>>>>        Close hTable
87835>>>>>>>        Get AutoConnectionIDLogin to bOK
87836>>>>>>>        Get OpenTableExclusive hTable to bOK
87837>>>>>>>        If (bOK = False) Begin
87839>>>>>>>            Function_Return False
87840>>>>>>>        End
87840>>>>>>>>
87840>>>>>>>
87840>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87843>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87845>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87846>>>>>>>>
87846>>>>>>>            Function_Return False
87847>>>>>>>        End
87847>>>>>>>>
87847>>>>>>>
87847>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87850>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87853>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87854>>>>>>>
87854>>>>>>>        Set Private.phCurrentTable to hTable
87855>>>>>>>        Set Private.piCurrentField to iOld
87856>>>>>>>
87856>>>>>>>//        If (bIsDate = False) Begin
87856>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87856>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87856>>>>>>>//        End
87856>>>>>>>//        Else Begin
87856>>>>>>>//            Move 6 to iLength
87856>>>>>>>//            Move 0 to iPrecision
87856>>>>>>>//        End
87856>>>>>>>
87856>>>>>>>        Move False to Err
87857>>>>>>>
87857>>>>>>>        Structure_Start hTable
87858>>>>>>>            Delete_Field hTable iOld
87859>>>>>>>            Create_Field hTable At iNew
87860>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87863>>>>>>>
87863>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87866>>>>>>>            If (bIsSQLType = False) Begin
87868>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87871>>>>>>>            End
87871>>>>>>>>
87871>>>>>>>            Else Begin
87872>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87875>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87875>>>>>>>            End
87875>>>>>>>>
87875>>>>>>>
87875>>>>>>>            If (bIsDate = False) Begin
87877>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87880>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87883>>>>>>>            End
87883>>>>>>>>
87883>>>>>>>
87883>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87884>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87886>>>>>>>
87886>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87887>>>>>>>        Function_Return (Err = False)
87888>>>>>>>    End_Function
87889>>>>>>>
87889>>>>>>>    // Deletes a column name for the passed table number (and column number).
87889>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87891>>>>>>>        Integer iColumn
87891>>>>>>>        Boolean bOK
87891>>>>>>>
87891>>>>>>>        Get AutoConnectionIDLogin to bOK
87892>>>>>>>        Move False to Err
87893>>>>>>>        Close hTable
87894>>>>>>>        Get OpenTableExclusive hTable to bOK
87895>>>>>>>        If (bOK = False) Begin
87897>>>>>>>            Function_Return False
87898>>>>>>>        End
87898>>>>>>>>
87898>>>>>>>
87898>>>>>>>        If (not(Err)) Begin
87900>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87901>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87902>>>>>>>            Field_Map hTable sFieldName to iColumn
87904>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87905>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87906>>>>>>>            If (iColumn = 0) Begin
87908>>>>>>>                Move 0 to LastErr
87909>>>>>>>                Function_Return False
87910>>>>>>>            End
87910>>>>>>>>
87910>>>>>>>            Move False to Err
87911>>>>>>>
87911>>>>>>>            Set Private.phCurrentTable to hTable
87912>>>>>>>            Set Private.piCurrentField to iColumn
87913>>>>>>>
87913>>>>>>>            Structure_Start hTable
87914>>>>>>>                Delete_Field hTable iColumn
87915>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87916>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87918>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87919>>>>>>>        End
87919>>>>>>>>
87919>>>>>>>        Else Begin
87920>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87921>>>>>>>>
87921>>>>>>>        End
87921>>>>>>>>
87921>>>>>>>
87921>>>>>>>        Function_Return (Err = False)
87922>>>>>>>    End_Function
87923>>>>>>>
87923>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87923>>>>>>>    // Returns True if no errors occured.
87923>>>>>>>    // Sample usage:
87923>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87923>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87925>>>>>>>        Integer iField
87925>>>>>>>        Boolean bOK bExists bIsOpen
87925>>>>>>>
87925>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87926>>>>>>>        If (bExists = True) Begin
87928>>>>>>>            Function_Return False
87929>>>>>>>        End
87929>>>>>>>>
87929>>>>>>>
87929>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87929>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87929>>>>>>>        Close hTable
87930>>>>>>>        Open hTable
87932>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87935>>>>>>>        If (bIsOpen = False) Begin
87937>>>>>>>            Function_Return False
87938>>>>>>>        End
87938>>>>>>>>
87938>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87939>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87940>>>>>>>        Field_Map hTable sOldFieldName to iField
87942>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87943>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87944>>>>>>>
87944>>>>>>>        Get AutoConnectionIDLogin to bOK
87945>>>>>>>        Get OpenTableExclusive hTable to bOK
87946>>>>>>>        If (bOK = False) Begin
87948>>>>>>>            Function_Return False
87949>>>>>>>        End
87949>>>>>>>>
87949>>>>>>>
87949>>>>>>>        Move False to Err
87950>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87951>>>>>>>        Set Private.phCurrentTable to hTable
87952>>>>>>>        Set Private.piCurrentField to iField
87953>>>>>>>
87953>>>>>>>        If (iField > 0) Begin
87955>>>>>>>            Structure_Start hTable
87956>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87959>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87960>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87962>>>>>>>        End
87962>>>>>>>>
87962>>>>>>>        Else Begin
87963>>>>>>>            Move 0 to LastErr
87964>>>>>>>            Move False to Err
87965>>>>>>>        End
87965>>>>>>>>
87965>>>>>>>
87965>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87966>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87967>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87968>>>>>>>
87968>>>>>>>        Function_Return (Err = False)
87969>>>>>>>    End_Function
87970>>>>>>>
87970>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87972>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87972>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87973>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87973>>>>>>>        Boolean bRenameField
87973>>>>>>>
87973>>>>>>>        Open hTable
87975>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87976>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87977>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87978>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87981>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87982>>>>>>>        Decrement iSize
87983>>>>>>>        for iCount from 0 to iSize
87989>>>>>>>>
87989>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87991>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87992>>>>>>>
87992>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87994>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87996>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87997>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87998>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88000>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88001>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88002>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88003>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88004>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88005>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88006>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88007>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88008>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88009>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88010>>>>>>>                        Increment iItem
88011>>>>>>>                    End
88011>>>>>>>>
88011>>>>>>>                End
88011>>>>>>>>
88011>>>>>>>            End
88011>>>>>>>>
88011>>>>>>>        Loop
88012>>>>>>>>
88012>>>>>>>
88012>>>>>>>        Move False to Err
88013>>>>>>>        Move 0 to LastErr
88014>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88015>>>>>>>        Function_Return aAPIColumnsToInsert
88016>>>>>>>    End_Function
88017>>>>>>>
88017>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88019>>>>>>>        Integer iSize iCount
88019>>>>>>>        Boolean bOK
88019>>>>>>>        tAPIColumn[] aColumnsTo
88019>>>>>>>        tAPIColumn[] aColumnsTo
88020>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88020>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88021>>>>>>>
88021>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88022>>>>>>>        If (iSize = 0) Begin
88024>>>>>>>            Function_Return True
88025>>>>>>>        End
88025>>>>>>>>
88025>>>>>>>
88025>>>>>>>        Move False to Err
88026>>>>>>>        Decrement iSize
88027>>>>>>>        for iCount from 0 to iSize
88033>>>>>>>>
88033>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88034>>>>>>>        Loop
88035>>>>>>>>
88035>>>>>>>
88035>>>>>>>        Function_Return bOK
88036>>>>>>>    End_Function
88037>>>>>>>
88037>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88037>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88039>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88039>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88040>>>>>>>        Integer iSize iCount iItem iShouldMove
88040>>>>>>>
88040>>>>>>>        Move 0 to iItem
88041>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88042>>>>>>>        Decrement iSize
88043>>>>>>>        for iCount from 0 to iSize
88049>>>>>>>>
88049>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88051>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88052>>>>>>>                If (iShouldMove <> -1) Begin
88054>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88055>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88056>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88057>>>>>>>                    Increment iItem
88058>>>>>>>                End
88058>>>>>>>>
88058>>>>>>>            End
88058>>>>>>>>
88058>>>>>>>        Loop
88059>>>>>>>>
88059>>>>>>>
88059>>>>>>>        Move False to Err
88060>>>>>>>        Move 0 to LastErr
88061>>>>>>>        Function_Return aAPIColumnsToMove
88062>>>>>>>    End_Function
88063>>>>>>>
88063>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88065>>>>>>>        Integer iSize iCount
88065>>>>>>>        Boolean bOK
88065>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88065>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88066>>>>>>>
88066>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88067>>>>>>>        If (iSize = 0) Begin
88069>>>>>>>            Function_Return True
88070>>>>>>>        End
88070>>>>>>>>
88070>>>>>>>
88070>>>>>>>        Move False to Err
88071>>>>>>>        Decrement iSize
88072>>>>>>>        for iCount from 0 to iSize
88078>>>>>>>>
88078>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88079>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88081>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88082>>>>>>>                If (bOK = True) Begin
88084>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88085>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88086>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88087>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88089>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88090>>>>>>>                        Decrement iSize
88091>>>>>>>                        Move 0 to iCount
88092>>>>>>>                    End
88092>>>>>>>>
88092>>>>>>>                End
88092>>>>>>>>
88092>>>>>>>                Else Begin
88093>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88094>>>>>>>                End
88094>>>>>>>>
88094>>>>>>>            End
88094>>>>>>>>
88094>>>>>>>        Loop
88095>>>>>>>>
88095>>>>>>>
88095>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88096>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88098>>>>>>>            Move 0 to LastErr
88099>>>>>>>        End
88099>>>>>>>>
88099>>>>>>>        Function_Return bOK
88100>>>>>>>    End_Function
88101>>>>>>>
88101>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88101>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88101>>>>>>>    // - The "FROM" field name is <> "TO" field name
88101>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88101>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88101>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88103>>>>>>>        Boolean bShouldRename
88103>>>>>>>        String sFieldNameFrom sFieldNameTo
88103>>>>>>>
88103>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88104>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88105>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88107>>>>>>>            Function_Return False
88108>>>>>>>        End
88108>>>>>>>>
88108>>>>>>>
88108>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88109>>>>>>>//        If (bShouldRename = False) Begin
88109>>>>>>>//            Function_Return False
88109>>>>>>>//        End
88109>>>>>>>//
88109>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88109>>>>>>>//            Function_Return True
88109>>>>>>>//        End
88109>>>>>>>
88109>>>>>>>        Function_Return bShouldRename
88110>>>>>>>    End_Function
88111>>>>>>>
88111>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88111>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88111>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88113>>>>>>>        Integer iCount iSize iRetval
88113>>>>>>>        String sFieldNameFrom
88113>>>>>>>
88113>>>>>>>        Move -1 to iRetval
88114>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88116>>>>>>>            Function_Return iRetval
88117>>>>>>>        End
88117>>>>>>>>
88117>>>>>>>
88117>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88118>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88119>>>>>>>        Decrement iSize
88120>>>>>>>        for iCount from 0 to iSize
88126>>>>>>>>
88126>>>>>>>            // We're only interested in fields other than the passed field/column number:
88126>>>>>>>            If (iCount <> iColumn) Begin
88128>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88130>>>>>>>                    Move (iCount + 1) to iRetval
88131>>>>>>>                End
88131>>>>>>>>
88131>>>>>>>            End
88131>>>>>>>>
88131>>>>>>>        Loop
88132>>>>>>>>
88132>>>>>>>
88132>>>>>>>        Move 0 to LastErr
88133>>>>>>>        Function_Return iRetval
88134>>>>>>>    End_Function
88135>>>>>>>
88135>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88137>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88137>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88138>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88138>>>>>>>        Boolean bRenameField
88138>>>>>>>
88138>>>>>>>        Open hTable
88140>>>>>>>        Move 0 to iItem
88141>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88142>>>>>>>        Decrement iSize
88143>>>>>>>        for iCount from 0 to iSize
88149>>>>>>>>
88149>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88151>>>>>>>                // Check if the field exists in another position (other field number)
88151>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88152>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88153>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88155>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88156>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88157>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88158>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88159>>>>>>>                    Increment iItem
88160>>>>>>>                End
88160>>>>>>>>
88160>>>>>>>            End
88160>>>>>>>>
88160>>>>>>>        Loop
88161>>>>>>>>
88161>>>>>>>
88161>>>>>>>        Move False to Err
88162>>>>>>>        Move 0 to LastErr
88163>>>>>>>        Function_Return aAPIColumnsToRename
88164>>>>>>>    End_Function
88165>>>>>>>
88165>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88167>>>>>>>        Integer iSize iCount
88167>>>>>>>        Boolean bOK
88167>>>>>>>        tAPIColumn[] aColumnsTo
88167>>>>>>>        tAPIColumn[] aColumnsTo
88168>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88168>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88169>>>>>>>
88169>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88170>>>>>>>        If (iSize = 0) Begin
88172>>>>>>>            Function_Return True
88173>>>>>>>        End
88173>>>>>>>>
88173>>>>>>>
88173>>>>>>>        Move False to Err
88174>>>>>>>        Decrement iSize
88175>>>>>>>        For iCount from 0 to iSize
88181>>>>>>>>
88181>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88182>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88183>>>>>>>        Loop
88184>>>>>>>>
88184>>>>>>>
88184>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88185>>>>>>>        Function_Return bOK
88186>>>>>>>    End_Function
88187>>>>>>>
88187>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88189>>>>>>>        Boolean bDateType
88189>>>>>>>
88189>>>>>>>        If (bIsSQLTableTo = True) Begin
88191>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88192>>>>>>>        End
88192>>>>>>>>
88192>>>>>>>        Else Begin
88193>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88194>>>>>>>        End
88194>>>>>>>>
88194>>>>>>>
88194>>>>>>>        Function_Return bDateType
88195>>>>>>>    End_Function
88196>>>>>>>
88196>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88198>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88198>>>>>>>        Integer iCount2 iColumn2
88198>>>>>>>        Handle hFile
88198>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88198>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88198>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88198>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88198>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88203>>>>>>>        tColumnType ColumnType
88203>>>>>>>        tColumnType ColumnType
88203>>>>>>>
88203>>>>>>>        Move False to Err
88204>>>>>>>        Close hTable
88205>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88206>>>>>>>        If (bIsOpen = False) Begin
88208>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88209>>>>>>>>
88209>>>>>>>            Function_Return False
88210>>>>>>>        End 
88210>>>>>>>>
88210>>>>>>>        
88210>>>>>>>        Get piDbType to iDbType
88211>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88214>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88215>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88216>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88219>>>>>>>
88219>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88220>>>>>>>
88220>>>>>>>        // Before we start to change the table we need to do three things;
88220>>>>>>>        // 1) Insert any new fields
88220>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88221>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88223>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88224>>>>>>>            If (bOK = False) Begin
88226>>>>>>>                Function_Return False
88227>>>>>>>            End
88227>>>>>>>>
88227>>>>>>>            // Update info with changes made.
88227>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88228>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88229>>>>>>>        End
88229>>>>>>>>
88229>>>>>>>
88229>>>>>>>        // 2) Move fields with same names
88229>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88230>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88232>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88233>>>>>>>            If (bOK = False) Begin
88235>>>>>>>                Function_Return False
88236>>>>>>>            End
88236>>>>>>>>
88236>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88237>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88238>>>>>>>        End
88238>>>>>>>>
88238>>>>>>>        
88238>>>>>>>        // 3) Rename fields
88238>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88239>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88241>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88242>>>>>>>            If (bOK = False) Begin
88244>>>>>>>                Function_Return False
88245>>>>>>>            End
88245>>>>>>>>
88245>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88246>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88247>>>>>>>        End
88247>>>>>>>>
88247>>>>>>>
88247>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88247>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88247>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88247>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88247>>>>>>>//            If (bOK = False) Begin
88247>>>>>>>//                Function_Return False
88247>>>>>>>//            End
88247>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88247>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88247>>>>>>>//        End
88247>>>>>>>
88247>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88247>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88249>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88250>>>>>>>            If (bIsSame = True) Begin
88252>>>>>>>                Function_Return True
88253>>>>>>>            End
88253>>>>>>>>
88253>>>>>>>        End
88253>>>>>>>>
88253>>>>>>>
88253>>>>>>>        Move False to Err
88254>>>>>>>        // We can now continue to make standard field changes:
88254>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88255>>>>>>>        Set Private.phCurrentTable to hTable
88256>>>>>>>        Move hTable to hFile
88257>>>>>>>        Structure_Start hFile sDriverIDTo
88258>>>>>>>
88258>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88259>>>>>>>            Decrement iColumns
88260>>>>>>>            for iCount from 0 to iColumns
88266>>>>>>>>
88266>>>>>>>                Send DoAdvance of ghoProgressBar
88267>>>>>>>
88267>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88268>>>>>>>                Set Private.piCurrentField                  to iColumn
88269>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88270>>>>>>>                If (bIsSame = False) Begin
88272>>>>>>>
88272>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88273>>>>>>>                    If (bFieldExistsFrom = True) Begin
88275>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88276>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88277>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88278>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88279>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88280>>>>>>>
88280>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88281>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88282>>>>>>>                        If (iTypeFrom < -1490) Begin
88284>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88285>>>>>>>                        End
88285>>>>>>>>
88285>>>>>>>
88285>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88285>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88285>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88287>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88288>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88290>>>>>>>                                Move DF_DATE to iTypeFrom
88291>>>>>>>                            End
88291>>>>>>>>
88291>>>>>>>                        End
88291>>>>>>>>
88291>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88294>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88295>>>>>>>                        End
88295>>>>>>>>
88295>>>>>>>
88295>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88296>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88297>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88298>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88299>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88300>>>>>>>
88300>>>>>>>                        Move False to bSkipTypeChange
88301>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88303>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88304>>>>>>>                        End
88304>>>>>>>>
88304>>>>>>>
88304>>>>>>>                        If (bFieldExistsTo = False) Begin
88306>>>>>>>                            Move 0 to iColumn
88307>>>>>>>                            Create_Field hFile At iColumn
88308>>>>>>>                            Set Private.piCurrentField to iColumn
88309>>>>>>>                        End
88309>>>>>>>>
88309>>>>>>>
88309>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88311>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88314>>>>>>>                        End
88314>>>>>>>>
88314>>>>>>>
88314>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88316>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88319>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88320>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88322>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88323>>>>>>>                            End
88323>>>>>>>>
88323>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88326>>>>>>>                        End
88326>>>>>>>>
88326>>>>>>>
88326>>>>>>>                        If (bSkipTypeChange = False) Begin
88328>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88330>>>>>>>                                If (bIsSQLTableTo = True) Begin
88332>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88335>>>>>>>                                End
88335>>>>>>>>
88335>>>>>>>                                Else Begin                                                   
88336>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88338>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88339>>>>>>>                                    End
88339>>>>>>>>
88339>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88342>>>>>>>                                End
88342>>>>>>>>
88342>>>>>>>                            End
88342>>>>>>>>
88342>>>>>>>                        End
88342>>>>>>>>
88342>>>>>>>
88342>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88343>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88343>>>>>>>                        If (bIsDateType = False) Begin
88345>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88347>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88350>>>>>>>                            End
88350>>>>>>>>
88350>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88352>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88355>>>>>>>                            End
88355>>>>>>>>
88355>>>>>>>                        End
88355>>>>>>>>
88355>>>>>>>
88355>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88357>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88357>>>>>>>                            If (bRecnumTable = True) Begin
88359>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88362>>>>>>>                            End
88362>>>>>>>>
88362>>>>>>>
88362>>>>>>>                            // We might need to create an index here.
88362>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88362>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88362>>>>>>>                            // index update checking logic.
88362>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88365>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88367>>>>>>>                                Create_Index hFile at iIndex
88368>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88371>>>>>>>                            End
88371>>>>>>>>
88371>>>>>>>
88371>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88374>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88377>>>>>>>                                // Note: The order here is crucial!
88377>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88380>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88383>>>>>>>                        End
88383>>>>>>>>
88383>>>>>>>                    End
88383>>>>>>>>
88383>>>>>>>                    Else Begin
88384>>>>>>>                        Delete_Field hFile iColumn
88385>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88386>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88387>>>>>>>                        Decrement iCount2
88388>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88388>>>>>>>                        // starting with the array number we just deleted the field for.
88388>>>>>>>                        for iColumn2 from iCount to iCount2
88394>>>>>>>>
88394>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88395>>>>>>>                        Loop
88396>>>>>>>>
88396>>>>>>>                        Decrement iCount
88397>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88398>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88399>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88401>>>>>>>                            Move iColumns to iCount 
88402>>>>>>>                        End
88402>>>>>>>>
88402>>>>>>>                    End
88402>>>>>>>>
88402>>>>>>>                End 
88402>>>>>>>>
88402>>>>>>>                If (Err = True) Begin 
88404>>>>>>>                    Move False to bOK
88405>>>>>>>                    Move iColumns to iCount
88406>>>>>>>                End
88406>>>>>>>>
88406>>>>>>>            Loop
88407>>>>>>>>
88407>>>>>>>
88407>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88408>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88410>>>>>>>
88410>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88411>>>>>>>        Function_Return (Err = False)
88412>>>>>>>    End_Function
88413>>>>>>>
88413>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88413>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88415>>>>>>>        Function_Return False
88416>>>>>>>    End_Function
88417>>>>>>>
88417>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88417>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88417>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88417>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88419>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88419>>>>>>>        String sDriverID
88419>>>>>>>        Boolean bOK bExists bIsSQLTable
88419>>>>>>>
88419>>>>>>>        Get AutoConnectionIDLogin to bOK
88420>>>>>>>        Get OpenTableExclusive hTable to bOK
88421>>>>>>>        If (bOK = False) Begin
88423>>>>>>>            Function_Return False
88424>>>>>>>        End
88424>>>>>>>>
88424>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88427>>>>>>>
88427>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88428>>>>>>>            If (bIsSQLTable = True) Begin
88430>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88433>>>>>>>            End
88433>>>>>>>>
88433>>>>>>>
88433>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88436>>>>>>>        Move (iIndexSegments > 0) to bExists
88437>>>>>>>        If (bExists = True) Begin
88439>>>>>>>            Function_Return True
88440>>>>>>>        End
88440>>>>>>>>
88440>>>>>>>
88440>>>>>>>        Move -1 to iSegment1
88441>>>>>>>        Move -1 to iSegment2
88442>>>>>>>        Move -1 to iSegment3
88443>>>>>>>        Move -1 to iSegment4
88444>>>>>>>        Move -1 to iSegment5
88445>>>>>>>        Move -1 to iSegment6
88446>>>>>>>        Move -1 to iSegment7
88447>>>>>>>        Move -1 to iSegment8
88448>>>>>>>        Move -1 to iSegment9
88449>>>>>>>        Move -1 to iSegment10
88450>>>>>>>
88450>>>>>>>        If (num_arguments > 3) Begin
88452>>>>>>>            Move iSgmnt1 to iSegment1
88453>>>>>>>        End
88453>>>>>>>>
88453>>>>>>>        If (num_arguments > 4) Begin
88455>>>>>>>            Move iSgmnt2 to iSegment2
88456>>>>>>>        End
88456>>>>>>>>
88456>>>>>>>        If (num_arguments > 5) Begin
88458>>>>>>>            Move iSgmnt3 to iSegment3
88459>>>>>>>        End
88459>>>>>>>>
88459>>>>>>>        If (num_arguments > 6) Begin
88461>>>>>>>            Move iSgmnt4 to iSegment4
88462>>>>>>>        End
88462>>>>>>>>
88462>>>>>>>        If (num_arguments > 7) Begin
88464>>>>>>>            Move iSgmnt5 to iSegment5
88465>>>>>>>        End
88465>>>>>>>>
88465>>>>>>>        If (num_arguments > 8) Begin
88467>>>>>>>            Move iSgmnt6 to iSegment6
88468>>>>>>>        End
88468>>>>>>>>
88468>>>>>>>        If (num_arguments > 9) Begin
88470>>>>>>>            Move iSgmnt7 to iSegment7
88471>>>>>>>        End
88471>>>>>>>>
88471>>>>>>>        If (num_arguments > 10) Begin
88473>>>>>>>            Move iSgmnt8 to iSegment8
88474>>>>>>>        End
88474>>>>>>>>
88474>>>>>>>        If (num_arguments > 11) Begin
88476>>>>>>>            Move iSgmnt9 to iSegment9
88477>>>>>>>        End
88477>>>>>>>>
88477>>>>>>>        If (num_arguments > 12) Begin
88479>>>>>>>            Move iSgmnt10 to iSegment10
88480>>>>>>>        End
88480>>>>>>>>
88480>>>>>>>
88480>>>>>>>        Move False to Err
88481>>>>>>>        Move hTable to iTableNo
88482>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88483>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88484>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88485>>>>>>>
88485>>>>>>>        // We start by deleting the index, if it exists.
88485>>>>>>>        If (bExists = True) Begin
88487>>>>>>>            Structure_Start hTable sDriverID
88488>>>>>>>                Delete_Index iTableNo iIndex
88489>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88490>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88492>>>>>>>        End
88492>>>>>>>>
88492>>>>>>>
88492>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88493>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88494>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88495>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88496>>>>>>>        Move False to Err
88497>>>>>>>        Move 0 to LastErr
88498>>>>>>>
88498>>>>>>>        // Need to re-open if index deleted.
88498>>>>>>>        Move iTableNo to hTable
88499>>>>>>>        Get OpenTableExclusive hTable to bOK
88500>>>>>>>        If (bOK = False) Begin
88502>>>>>>>            Function_Return False
88503>>>>>>>        End
88503>>>>>>>>
88503>>>>>>>
88503>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88504>>>>>>>        Structure_Start hTable sDriverID
88505>>>>>>>            Create_Index hTable At iIndex
88506>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88509>>>>>>>
88509>>>>>>>            If (iSgmnt1 <> -1) Begin
88511>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88514>>>>>>>            End
88514>>>>>>>>
88514>>>>>>>            If (iSegment2 <> -1) Begin
88516>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88519>>>>>>>            End
88519>>>>>>>>
88519>>>>>>>            If (iSegment3 <> -1) Begin
88521>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88524>>>>>>>            End
88524>>>>>>>>
88524>>>>>>>            If (iSegment4 <> -1) Begin
88526>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88529>>>>>>>            End
88529>>>>>>>>
88529>>>>>>>            If (iSegment5 <> -1) Begin
88531>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88534>>>>>>>            End
88534>>>>>>>>
88534>>>>>>>            If (iSegment6 <> -1) Begin
88536>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88539>>>>>>>            End
88539>>>>>>>>
88539>>>>>>>            If (iSegment7 <> -1) Begin
88541>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88544>>>>>>>            End
88544>>>>>>>>
88544>>>>>>>            If (iSegment8 <> -1) Begin
88546>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88549>>>>>>>            End
88549>>>>>>>>
88549>>>>>>>            If (iSegment9 <> -1) Begin
88551>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88554>>>>>>>            End
88554>>>>>>>>
88554>>>>>>>            If (iSegment10 <> -1) Begin
88556>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88559>>>>>>>            End
88559>>>>>>>>
88559>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88560>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88562>>>>>>>
88562>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88563>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88564>>>>>>>
88564>>>>>>>        Function_Return (Err = False)
88565>>>>>>>    End_Function
88566>>>>>>>
88566>>>>>>>    // Example:
88566>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88566>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88566>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88568>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88568>>>>>>>        String sDriverID
88568>>>>>>>        Boolean bOK bIsSQLTable
88568>>>>>>>
88568>>>>>>>        Get AutoConnectionIDLogin to bOK
88569>>>>>>>
88569>>>>>>>        Move False to Err
88570>>>>>>>        Move hTable to iTableNo
88571>>>>>>>        Get OpenTableExclusive hTable to bOK
88572>>>>>>>        If (bOK = False) Begin
88574>>>>>>>            Function_Return False
88575>>>>>>>        End
88575>>>>>>>>
88575>>>>>>>
88575>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88578>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88579>>>>>>>            If (bIsSQLTable = True) Begin
88581>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88584>>>>>>>            End
88584>>>>>>>>
88584>>>>>>>
88584>>>>>>>        // We start by deleting the index
88584>>>>>>>        Structure_Start hTable sDriverID
88585>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88586>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88587>>>>>>>            Delete_Index iTableNo iIndex
88588>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88589>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88590>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88592>>>>>>>
88592>>>>>>>        Move False to Err
88593>>>>>>>        Move iTableNo to hTable
88594>>>>>>>        Get OpenTableExclusive hTable to bOK
88595>>>>>>>        If (bOK = False) Begin
88597>>>>>>>            Function_Return False
88598>>>>>>>        End
88598>>>>>>>>
88598>>>>>>>
88598>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88599>>>>>>>        Structure_Start hTable sDriverID
88600>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88601>>>>>>>
88601>>>>>>>            Create_Index hTable at iIndex
88602>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88605>>>>>>>
88605>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88611>>>>>>>>
88611>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88614>>>>>>>            Loop
88615>>>>>>>>
88615>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88617>>>>>>>
88617>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88618>>>>>>>
88618>>>>>>>        Function_Return (Err = False)
88619>>>>>>>    End_Function
88620>>>>>>>
88620>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88622>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88622>>>>>>>        String sDriverID sSQLIndexName
88622>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88622>>>>>>>
88622>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88623>>>>>>>        If (iSegmentsFrom = 0) Begin
88625>>>>>>>            Function_Return False
88626>>>>>>>        End
88626>>>>>>>>
88626>>>>>>>
88626>>>>>>>        Get AutoConnectionIDLogin to bOK
88627>>>>>>>        Move False to Err
88628>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88629>>>>>>>        If (bIsOpen = False) Begin
88631>>>>>>>            Function_Return False
88632>>>>>>>        End
88632>>>>>>>>
88632>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88635>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88636>>>>>>>            If (bIsSQLTable = True) Begin
88638>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88641>>>>>>>            End
88641>>>>>>>>
88641>>>>>>>
88641>>>>>>>        Move 0     to iSegmentsTo
88642>>>>>>>        Move 0     to iSQLIndexType
88643>>>>>>>        Move ""    to sSQLIndexName
88644>>>>>>>        Move False to bIsSQLTemporaryIndex
88645>>>>>>>        Move False to bIsSQLPrimaryKey
88646>>>>>>>        Move False to bIsSQLClustered
88647>>>>>>>
88647>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88648>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88651>>>>>>>        Move (iSegmentsTo > 0) to bExists
88652>>>>>>>        If (bExists = True) Begin
88654>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88656>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88659>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88662>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88663>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88666>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88669>>>>>>>            End
88669>>>>>>>>
88669>>>>>>>        End
88669>>>>>>>>
88669>>>>>>>
88669>>>>>>>        Move hTable to iTableNo
88670>>>>>>>        Move False to Err
88671>>>>>>>        Move 0 to LastErr
88672>>>>>>>
88672>>>>>>>        Structure_Start hTable sDriverID
88673>>>>>>>            If (bExists = True) Begin
88675>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88676>>>>>>>            End
88676>>>>>>>>
88676>>>>>>>
88676>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88677>>>>>>>
88677>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88679>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88682>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88685>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88688>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88691>>>>>>>                End
88691>>>>>>>>
88691>>>>>>>
88691>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88694>>>>>>>
88694>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88700>>>>>>>>
88700>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88701>>>>>>>                If (iFieldFrom <> -1 ) Begin
88703>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88706>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88709>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88712>>>>>>>                End
88712>>>>>>>>
88712>>>>>>>            Loop
88713>>>>>>>>
88713>>>>>>>
88713>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88714>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88716>>>>>>>
88716>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88717>>>>>>>
88717>>>>>>>        Function_Return (Err = False)
88718>>>>>>>    End_Function
88719>>>>>>>
88719>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88719>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88719>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88721>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88721>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88721>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
88721>>>>>>>
88721>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88722>>>>>>>        
88722>>>>>>>        If (bIsSQLDriver = False) Begin
88724>>>>>>>            Function_Return False
88725>>>>>>>        End
88725>>>>>>>>
88725>>>>>>>
88725>>>>>>>        Move False to Err
88726>>>>>>>        Move hTable to iTableNo
88727>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88730>>>>>>>        for iCount from 0 to iLastIndex
88736>>>>>>>>
88736>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88739>>>>>>>            Move (iSegments > 0) to bExists
88740>>>>>>>            If (bExists = True) Begin
88742>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88745>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88747>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88748>>>>>>>                    Structure_Start iTableNo sDriverID
88749>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88752>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88754>>>>>>>                    Open hTable
88756>>>>>>>                End
88756>>>>>>>>
88756>>>>>>>            End
88756>>>>>>>>
88756>>>>>>>        Loop
88757>>>>>>>>
88757>>>>>>>
88757>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88760>>>>>>>        If (bIsOpen = False) Begin
88762>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88763>>>>>>>        End
88763>>>>>>>>
88763>>>>>>>        If (bIsOpen = False) Begin
88765>>>>>>>            Function_Return False
88766>>>>>>>        End
88766>>>>>>>>
88766>>>>>>>
88766>>>>>>>        Function_Return (Err = False)
88767>>>>>>>    End_Function
88768>>>>>>>
88768>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88768>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88768>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88770>>>>>>>        Integer iSize iCount
88770>>>>>>>        Integer iRetVal
88770>>>>>>>
88770>>>>>>>        Move 0 to iRetVal
88771>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88774>>>>>>>        If (iRetVal = 0) Begin
88776>>>>>>>            Function_Return 0
88777>>>>>>>        End
88777>>>>>>>>
88777>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88778>>>>>>>        Decrement iSize
88779>>>>>>>        for iCount from 0 to iSize
88785>>>>>>>>
88785>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88787>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88789>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88790>>>>>>>                End
88790>>>>>>>>
88790>>>>>>>            End
88790>>>>>>>>
88790>>>>>>>        Loop
88791>>>>>>>>
88791>>>>>>>
88791>>>>>>>        Function_Return iRetVal
88792>>>>>>>    End_Function
88793>>>>>>>
88793>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88795>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88795>>>>>>>        Boolean bIsSQLTable
88795>>>>>>>        
88795>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88796>>>>>>>            If (bIsSQLTable = True) Begin
88798>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88801>>>>>>>            End
88801>>>>>>>>
88801>>>>>>>
88801>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88804>>>>>>>        If (iSegment = iNumSegments) Begin
88806>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88806>>>>>>>        End
88806>>>>>>>>
88806>>>>>>>
88806>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88809>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88815>>>>>>>>
88815>>>>>>>                //*** Move index segment attributes
88815>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88818>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88821>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88824>>>>>>>
88824>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88827>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88830>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88833>>>>>>>            Loop
88834>>>>>>>>
88834>>>>>>>
88834>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88837>>>>>>>        End
88837>>>>>>>>
88837>>>>>>>
88837>>>>>>>        Function_Return (Err = False)
88838>>>>>>>    End_Function
88839>>>>>>>
88839>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88841>>>>>>>        Integer iCount iSize iIndex
88841>>>>>>>        String sDriverID
88841>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88841>>>>>>>
88841>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88842>>>>>>>        If (iSize = 0) Begin
88844>>>>>>>            Function_Return True
88845>>>>>>>        End
88845>>>>>>>>
88845>>>>>>>
88845>>>>>>>        Get AutoConnectionIDLogin to bOK
88846>>>>>>>        Move False to Err
88847>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88850>>>>>>>        If (bIsOpen = False) Begin
88852>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88853>>>>>>>            If (bIsOpen = False) Begin
88855>>>>>>>                Function_Return False
88856>>>>>>>            End
88856>>>>>>>>
88856>>>>>>>        End
88856>>>>>>>>
88856>>>>>>>
88856>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88859>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88860>>>>>>>            If (bIsSQLTable = True) Begin
88862>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88865>>>>>>>            End
88865>>>>>>>>
88865>>>>>>>
88865>>>>>>>        Move False to Err
88866>>>>>>>        Move 0 to LastErr
88867>>>>>>>        Decrement iSize
88868>>>>>>>
88868>>>>>>>        Structure_Start hTable sDriverID
88869>>>>>>>            for iCount from 0 to iSize
88875>>>>>>>>
88875>>>>>>>//                Move False to bIsSQLPrimaryKey
88875>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88875>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88875>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88875>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88875>>>>>>>//                #ENDIF
88875>>>>>>>                // We can't delete if this is a primary key index:
88875>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88875>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88876>>>>>>>                    Delete_Index hTable iIndex
88877>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88877>>>>>>>//                End
88877>>>>>>>            Loop
88878>>>>>>>>
88878>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88879>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88881>>>>>>>//        Move False to Err
88881>>>>>>>        Move 0 to LastErr
88882>>>>>>>
88882>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88883>>>>>>>        Function_Return (Err = False)
88884>>>>>>>    End_Function
88885>>>>>>>
88885>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88887>>>>>>>        Boolean bOK
88887>>>>>>>
88887>>>>>>>        Get AutoConnectionIDLogin to bOK
88888>>>>>>>        Move False to Err
88889>>>>>>>        Get OpenTableExclusive hTable to bOK
88890>>>>>>>        If (bOK = False) Begin
88892>>>>>>>            Function_Return False
88893>>>>>>>        End
88893>>>>>>>>
88893>>>>>>>        Structure_Start hTable
88894>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88897>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88898>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88900>>>>>>>
88900>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88901>>>>>>>        Function_Return (Err = False)
88902>>>>>>>    End_Function
88903>>>>>>>
88903>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88905>>>>>>>        Integer iCase
88905>>>>>>>        Boolean bOK
88905>>>>>>>
88905>>>>>>>        If (bUppercase = True) Begin
88907>>>>>>>            Move DF_CASE_IGNORED to iCase
88908>>>>>>>        End
88908>>>>>>>>
88908>>>>>>>        Else Begin
88909>>>>>>>            Move DF_CASE_USED to iCase
88910>>>>>>>        End
88910>>>>>>>>
88910>>>>>>>
88910>>>>>>>        Get AutoConnectionIDLogin to bOK
88911>>>>>>>        Move False to Err
88912>>>>>>>        Get OpenTableExclusive hTable to bOK
88913>>>>>>>        If (bOK = False) Begin
88915>>>>>>>            Function_Return False
88916>>>>>>>        End
88916>>>>>>>>
88916>>>>>>>        Structure_Start hTable
88917>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88920>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88921>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88923>>>>>>>
88923>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88924>>>>>>>        Function_Return (Err = False)
88925>>>>>>>    End_Function
88926>>>>>>>
88926>>>>>>>    // To delete an index
88926>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88928>>>>>>>        Integer iTableNo iNumSegments
88928>>>>>>>        String sDriverID
88928>>>>>>>        Boolean bOK bIsSQLTable
88928>>>>>>>
88928>>>>>>>        Get AutoConnectionIDLogin to bOK
88929>>>>>>>        Move False to Err
88930>>>>>>>        Move hTable to iTableNo
88931>>>>>>>        Get OpenTableExclusive hTable to bOK
88932>>>>>>>        If (bOK = False) Begin
88934>>>>>>>            Function_Return False
88935>>>>>>>        End
88935>>>>>>>>
88935>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88938>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88939>>>>>>>            If (bIsSQLTable = True) Begin
88941>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88944>>>>>>>            End
88944>>>>>>>>
88944>>>>>>>
88944>>>>>>>        // Check to see if the index exists or not...
88944>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88947>>>>>>>        If (iNumSegments = 0) Begin
88949>>>>>>>            Function_Return True // Then nothing to do.
88950>>>>>>>        End
88950>>>>>>>>
88950>>>>>>>
88950>>>>>>>        Structure_Start hTable sDriverID
88951>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88952>>>>>>>            Delete_Index iTableNo iIndex
88953>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88954>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88955>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88957>>>>>>>
88957>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88958>>>>>>>        Function_Return (Err = False)
88959>>>>>>>    End_Function
88960>>>>>>>
88960>>>>>>>    // Delete an Index Segment
88960>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88962>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88962>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88962>>>>>>>        Integer iIndexType
88962>>>>>>>        String sDriverID
88962>>>>>>>
88962>>>>>>>        Get AutoConnectionIDLogin to bOK
88963>>>>>>>        Move False to Err
88964>>>>>>>
88964>>>>>>>        Get OpenTableExclusive hTable to bOK
88965>>>>>>>        If (bOK = False) Begin
88967>>>>>>>            Function_Return False
88968>>>>>>>        End
88968>>>>>>>>
88968>>>>>>>
88968>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88969>>>>>>>            If (bIsSQLTable = True) Begin
88971>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88974>>>>>>>            End
88974>>>>>>>>
88974>>>>>>>
88974>>>>>>>        // Check to see if the index exists or not...
88974>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88977>>>>>>>        If (iNumSegments = 0) Begin
88979>>>>>>>            Function_Return False
88980>>>>>>>        End
88980>>>>>>>>
88980>>>>>>>
88980>>>>>>>        Move False to bIndexTemporary
88981>>>>>>>        Get psDriverID to sDriverID
88982>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88983>>>>>>>        If (bSQLDriver) Begin
88985>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88988>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88991>>>>>>>                Move True to bIndexTemporary
88992>>>>>>>        End
88992>>>>>>>>
88992>>>>>>>
88992>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88992>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88994>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88997>>>>>>>            If (iSegment = iNumSegments) Begin
88999>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89002>>>>>>>            End
89002>>>>>>>>
89002>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89005>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89011>>>>>>>>
89011>>>>>>>                    //*** Move index segment attributes
89011>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89014>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89017>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89020>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89023>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89026>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89029>>>>>>>                Loop
89030>>>>>>>>
89030>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89033>>>>>>>            End
89033>>>>>>>>
89033>>>>>>>        End
89033>>>>>>>>
89033>>>>>>>
89033>>>>>>>        Else Begin
89034>>>>>>>           Structure_Start hTable
89035>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89038>>>>>>>               If (iSegment = iNumSegments) Begin
89040>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89043>>>>>>>               End
89043>>>>>>>>
89043>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89046>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89052>>>>>>>>
89052>>>>>>>                       //*** Move index segment attributes
89052>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89055>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89058>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89061>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89064>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89067>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89070>>>>>>>                   Loop
89071>>>>>>>>
89071>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89074>>>>>>>               End
89074>>>>>>>>
89074>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89075>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89077>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89078>>>>>>>        End
89078>>>>>>>>
89078>>>>>>>
89078>>>>>>>        Function_Return (Err = False)
89079>>>>>>>    End_Function
89080>>>>>>>
89080>>>>>>>    // Add/Insert an Index Segment
89080>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89082>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89082>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89082>>>>>>>        Integer iIndexType
89082>>>>>>>        String sDriverId
89082>>>>>>>
89082>>>>>>>        Get AutoConnectionIDLogin to bOK
89083>>>>>>>        Move False to Err
89084>>>>>>>
89084>>>>>>>        Get OpenTableExclusive hTable to bOK
89085>>>>>>>        If (bOK = False) Begin
89087>>>>>>>            Function_Return False
89088>>>>>>>        End
89088>>>>>>>>
89088>>>>>>>
89088>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89089>>>>>>>            If (bIsSQLTable = True) Begin
89091>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89094>>>>>>>            End
89094>>>>>>>>
89094>>>>>>>
89094>>>>>>>        Move False to bIndexTemporary
89095>>>>>>>        // Check to see if the index exists or not...
89095>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89098>>>>>>>        If (iNumSegments = 0) Begin
89100>>>>>>>            Function_Return False
89101>>>>>>>        End
89101>>>>>>>>
89101>>>>>>>
89101>>>>>>>        Get psDriverID to sDriverID
89102>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89103>>>>>>>        If (bSQLDriver) Begin
89105>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89108>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89111>>>>>>>                Move True to bIndexTemporary
89112>>>>>>>        End
89112>>>>>>>>
89112>>>>>>>
89112>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89112>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89114>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89117>>>>>>>
89117>>>>>>>           If (iSegment > iNumSegments) Begin
89119>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89122>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89123>>>>>>>           End
89123>>>>>>>>
89123>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89126>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89129>>>>>>>               Move iNumSegments to iCurSegment
89130>>>>>>>
89130>>>>>>>               While (iCurSegment > iSegment)
89134>>>>>>>                   //*** Move index segment attributes
89134>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89137>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89140>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89143>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89146>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89149>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89152>>>>>>>                   Decrement iCurSegment
89153>>>>>>>               Loop
89154>>>>>>>>
89154>>>>>>>
89154>>>>>>>               //*** Now set new segment attributes
89154>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89157>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89160>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89163>>>>>>>           End
89163>>>>>>>>
89163>>>>>>>        End
89163>>>>>>>>
89163>>>>>>>
89163>>>>>>>        Else Begin
89164>>>>>>>        Structure_Start hTable
89165>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89168>>>>>>>
89168>>>>>>>            If (iSegment > iNumSegments) Begin
89170>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89173>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89174>>>>>>>            End
89174>>>>>>>>
89174>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89177>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89180>>>>>>>                Move iNumSegments to iCurSegment
89181>>>>>>>
89181>>>>>>>                While (iCurSegment > iSegment)
89185>>>>>>>                    //*** Move index segment attributes
89185>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89188>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89191>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89194>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89197>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89200>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89203>>>>>>>                    Decrement iCurSegment
89204>>>>>>>                Loop
89205>>>>>>>>
89205>>>>>>>
89205>>>>>>>                //*** Now set new segment attributes
89205>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89208>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89211>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89214>>>>>>>            End
89214>>>>>>>>
89214>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89215>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89217>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89218>>>>>>>        End
89218>>>>>>>>
89218>>>>>>>
89218>>>>>>>        Function_Return (Err = False)
89219>>>>>>>    End_Function
89220>>>>>>>
89220>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89220>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89222>>>>>>>        Function_Return False
89223>>>>>>>    End_Function  
89224>>>>>>>    
89224>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89224>>>>>>>    // for an SQL conversion.
89224>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89226>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89226>>>>>>>        
89226>>>>>>>        Move True to bConvertTo30FormatbOK
89227>>>>>>>        Move True to bRepairAndReindexOK
89228>>>>>>>        Move True to bFixBogusDatesOK
89229>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89230>>>>>>>        
89230>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89232>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89233>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89234>>>>>>>        End                                                                                
89234>>>>>>>>
89234>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89236>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89237>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89238>>>>>>>        End
89238>>>>>>>>
89238>>>>>>>        If (bConvertTo30Format = True) Begin
89240>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89241>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89242>>>>>>>        End                                                 
89242>>>>>>>>
89242>>>>>>>        If (bRepairAndReindex = True) Begin
89244>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89245>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89246>>>>>>>        End  
89246>>>>>>>>
89246>>>>>>>        If (bFixBogusDates = True) Begin
89248>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89249>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89250>>>>>>>        End                                    
89250>>>>>>>>
89250>>>>>>>        
89250>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89251>>>>>>>    End_Function
89252>>>>>>>
89252>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89254>>>>>>>        Boolean bOK bFlexErrs bTemp
89254>>>>>>>        Handle hTable
89254>>>>>>>        String sTableName
89254>>>>>>>        Integer iCount iSize
89254>>>>>>>        
89254>>>>>>>        Move True to bOK
89255>>>>>>>        Move 0 to hTable    
89256>>>>>>>
89256>>>>>>>        Get UtilFilelistNoOfTables to iSize
89257>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89258>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89259>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89260>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89261>>>>>>>
89261>>>>>>>        Repeat
89261>>>>>>>>
89261>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89262>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89263>>>>>>>            Increment iCount
89264>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89267>>>>>>>            If (hTable > 0) Begin
89269>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89272>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89273>>>>>>>                If (bFlexErrs = False) Begin
89275>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89276>>>>>>>                    If (bTemp = False) Begin
89278>>>>>>>                        Move False to bOK
89279>>>>>>>                    End
89279>>>>>>>>
89279>>>>>>>                End
89279>>>>>>>>
89279>>>>>>>            End
89279>>>>>>>>
89279>>>>>>>        Until (hTable = 0)
89281>>>>>>>        
89281>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89282>>>>>>>        Function_Return bOK
89283>>>>>>>    End_Function
89284>>>>>>>    
89284>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89284>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89284>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89284>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89286>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89286>>>>>>>        String sRevision
89286>>>>>>>        
89286>>>>>>>        Get AutoConnectionIDLogin to bOK
89287>>>>>>>        If (bOK = False) Begin
89289>>>>>>>            Function_Return True
89290>>>>>>>        End
89290>>>>>>>>
89290>>>>>>>        Get OpenTableExclusive hTable to bOK
89291>>>>>>>        If (bOK = False) Begin
89293>>>>>>>            Function_Return True
89294>>>>>>>        End
89294>>>>>>>>
89294>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89295>>>>>>>        If (bIsEmbedded = False) Begin
89297>>>>>>>            Function_Return True
89298>>>>>>>        End                             
89298>>>>>>>>
89298>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89299>>>>>>>        If (bIsAlias = True) Begin
89301>>>>>>>            Function_Return True
89302>>>>>>>        End                     
89302>>>>>>>>
89302>>>>>>>        
89302>>>>>>>        Move False to Err
89303>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89306>>>>>>>        If (sRevision contains "2.3") Begin
89308>>>>>>>            Move False to Err
89309>>>>>>>            Set Private.phCurrentTable to hTable
89310>>>>>>>            Structure_Start hTable    
89311>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89314>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89315>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89317>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89318>>>>>>>        End
89318>>>>>>>>
89318>>>>>>>        
89318>>>>>>>        Function_Return (Err = False)
89319>>>>>>>    End_Function
89320>>>>>>>
89320>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89322>>>>>>>        Boolean bIgnore bExists bOK bResponse
89322>>>>>>>        Handle hTable   
89322>>>>>>>        String sTableName
89322>>>>>>>        
89322>>>>>>>        Move False to Err 
89323>>>>>>>        Move True to bOK
89324>>>>>>>        Move 0 to hTable
89325>>>>>>>        Repeat
89325>>>>>>>>
89325>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89328>>>>>>>            If (hTable > 0) Begin
89330>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89333>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89334>>>>>>>                If (bIgnore = False) Begin
89336>>>>>>>                    Get _UtilTableExists hTable to bExists
89337>>>>>>>                    If (bExists = False) Begin
89339>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89340>>>>>>>                        If (bResponse = False) Begin
89342>>>>>>>                            Move False to bOK
89343>>>>>>>                        End
89343>>>>>>>>
89343>>>>>>>                        
89343>>>>>>>                    End
89343>>>>>>>>
89343>>>>>>>                End
89343>>>>>>>>
89343>>>>>>>            End
89343>>>>>>>>
89343>>>>>>>        Until (hTable = 0)                     
89345>>>>>>>        
89345>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89346>>>>>>>        Function_Return bOK
89347>>>>>>>    End_Function
89348>>>>>>>    
89348>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89348>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89348>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89348>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89348>>>>>>>    //
89348>>>>>>>    // The root of the problem is the following:
89348>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89348>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89348>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89348>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89348>>>>>>>    // an SQL error will be thrown;
89348>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89348>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89350>>>>>>>        Boolean bOK bIsAlias bIsSQL
89350>>>>>>>        Integer iCount iSize iDateSize
89350>>>>>>>        Handle hTable
89350>>>>>>>        String sLogicalName
89350>>>>>>>        Integer[] aTablesToCheck aDateFields
89352>>>>>>>
89352>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89353>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89354>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89355>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89356>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89357>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89358>>>>>>>
89358>>>>>>>        Move True to bOK
89359>>>>>>>        Decrement iSize
89360>>>>>>>        for iCount from 0 to iSize
89366>>>>>>>>
89366>>>>>>>            Move aTablesToCheck[iCount] to hTable
89367>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89368>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89369>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89370>>>>>>>
89370>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89373>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89374>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89375>>>>>>>
89375>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89377>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89378>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89379>>>>>>>                If (iDateSize > 0) Begin
89381>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89382>>>>>>>                    Close hTable
89383>>>>>>>                End
89383>>>>>>>>
89383>>>>>>>            End
89383>>>>>>>>
89383>>>>>>>        Loop
89384>>>>>>>>
89384>>>>>>>
89384>>>>>>>        Close DF_ALL
89385>>>>>>>        Function_Return bOK
89386>>>>>>>    End_Function
89387>>>>>>>
89387>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89387>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89389>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89391>>>>>>>        Integer iSize iCount iType
89391>>>>>>>        Boolean bOpen bOK
89391>>>>>>>        
89391>>>>>>>        Get _UtilTableExists hTable to bOK
89392>>>>>>>        If (bOK = False) Begin
89394>>>>>>>            Set Private.phCurrentTable to hTable
89395>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89396>>>>>>>>
89396>>>>>>>            Function_Return aDateFieldsEmpty
89397>>>>>>>        End
89397>>>>>>>>
89397>>>>>>>        Set Private.phCurrentTable to hTable
89398>>>>>>>        Set Private.piCurrentField to 0
89399>>>>>>>
89399>>>>>>>        Open hTable
89401>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89404>>>>>>>        If (bOpen = False) Begin
89406>>>>>>>            Function_Return aDateFieldsEmpty
89407>>>>>>>        End
89407>>>>>>>>
89407>>>>>>>
89407>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89410>>>>>>>        For iCount from 1 to iSize
89416>>>>>>>>
89416>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89419>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89421>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89422>>>>>>>            End
89422>>>>>>>>
89422>>>>>>>        Loop
89423>>>>>>>>
89423>>>>>>>
89423>>>>>>>        Function_Return aDateFields
89424>>>>>>>    End_Function
89425>>>>>>>
89425>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89425>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89425>>>>>>>    // and the record is saved
89425>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89425>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89425>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89427>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89427>>>>>>>        String sDriverID sDateMin
89427>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89427>>>>>>>        Date dDate dDateMin
89427>>>>>>>        Integer[] iaChangeField
89428>>>>>>>
89428>>>>>>>        Get _UtilTableExists hTable to bOK
89429>>>>>>>        // I believe we should just skip files not found and not report an error.
89429>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89429>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89429>>>>>>>        // Especially considering that this call is probably done at the very
89429>>>>>>>        // beginning of a DUF update.
89429>>>>>>>        If (bOK = False) Begin
89431>>>>>>>//            Set Private.phCurrentTable to hTable
89431>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89431>>>>>>>//            Function_Return False
89431>>>>>>>            Function_Return True
89432>>>>>>>        End
89432>>>>>>>>
89432>>>>>>>
89432>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89432>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89432>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89435>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89438>>>>>>>
89438>>>>>>>//        Send SetAllIndexesToBatch hTable True
89438>>>>>>>        Open hTable
89440>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89443>>>>>>>        If (bOpened = False) Begin
89445>>>>>>>            Function_Return False
89446>>>>>>>        End
89446>>>>>>>>
89446>>>>>>>        
89446>>>>>>>        Set Private.phCurrentTable to hTable
89447>>>>>>>        Move 0 to iRecord
89448>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89449>>>>>>>        Decrement iSize
89450>>>>>>>
89450>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89453>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89454>>>>>>>        If (iDriverIndex <> 0) Begin
89456>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89459>>>>>>>            If (sDateMin = "") Begin
89461>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89462>>>>>>>            End
89462>>>>>>>>
89462>>>>>>>            Else Begin
89463>>>>>>>                If (IsDate(sDateMin)) Begin
89465>>>>>>>                    Move sDateMin to dDateMin
89466>>>>>>>                End
89466>>>>>>>>
89466>>>>>>>                Else Begin
89467>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89468>>>>>>>                End
89468>>>>>>>>
89468>>>>>>>            End
89468>>>>>>>>
89468>>>>>>>        End
89468>>>>>>>>
89468>>>>>>>        Else Begin
89469>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89470>>>>>>>        End
89470>>>>>>>>
89470>>>>>>>
89470>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89473>>>>>>>        Set piPosition   of ghoProgressBar to 0
89474>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89475>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89476>>>>>>>        Move False to Err
89477>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89478>>>>>>>
89478>>>>>>>        Clear hTable
89479>>>>>>>        Repeat
89479>>>>>>>>
89479>>>>>>>            Vfind hTable 0 GT
89481>>>>>>>            Move Found to bFound
89482>>>>>>>            If (bFound = True) Begin
89484>>>>>>>                Move False to bSaveChanges
89485>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89486>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89487>>>>>>>                Decrement iSize
89488>>>>>>>                For iCount from 0 to iSize
89494>>>>>>>>
89494>>>>>>>                    Move aDateFields[iCount] to iField
89495>>>>>>>                    Get_Field_Value hTable iField to dDate
89498>>>>>>>                    If (bFixZeroDates = True) Begin
89500>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89501>>>>>>>                    End
89501>>>>>>>>
89501>>>>>>>                    Else Begin
89502>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89503>>>>>>>                    End
89503>>>>>>>>
89503>>>>>>>                    If (bChange = True) Begin
89505>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89506>>>>>>>                    End
89506>>>>>>>>
89506>>>>>>>                Loop
89507>>>>>>>>
89507>>>>>>>
89507>>>>>>>                // Only change Date fields that needs to be changed.
89507>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89509>>>>>>>                    Reread hTable
89513>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89514>>>>>>>                        Decrement iSize
89515>>>>>>>                        For iCount from 0 to iSize
89521>>>>>>>>
89521>>>>>>>                            Move iaChangeField[iCount] to iField
89522>>>>>>>                            Set Private.piCurrentField to iField
89523>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89526>>>>>>>                        Loop
89527>>>>>>>>
89527>>>>>>>                        Move False to Err
89528>>>>>>>                        SaveRecord hTable
89529>>>>>>>                    Unlock
89530>>>>>>>>
89530>>>>>>>                End
89530>>>>>>>>
89530>>>>>>>
89530>>>>>>>                Increment iRecord
89531>>>>>>>                // Increment the StatusPanel counter and check the
89531>>>>>>>                // cancel status every 100 records rather than every
89531>>>>>>>                // record, it's way faster.
89531>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89533>>>>>>>                    Send DoAdvance of ghoProgressBar
89534>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89535>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89536>>>>>>>                End
89536>>>>>>>>
89536>>>>>>>            End
89536>>>>>>>>
89536>>>>>>>        Until (bFound = False)
89538>>>>>>>
89538>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89541>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89543>>>>>>>            Send SetAllIndexesToBatch hTable False
89544>>>>>>>        End
89544>>>>>>>>
89544>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89545>>>>>>>
89545>>>>>>>        Function_Return (Err = False)
89546>>>>>>>    End_Function
89547>>>>>>>
89547>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89547>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89547>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89549>>>>>>>        Boolean bIsSame
89549>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89549>>>>>>>
89549>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89550>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89551>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89552>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89553>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89554>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89555>>>>>>>
89555>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89557>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89558>>>>>>>        End
89558>>>>>>>>
89558>>>>>>>        Else Begin
89559>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89560>>>>>>>        End
89560>>>>>>>>
89560>>>>>>>        If (bIsSame = False) Begin
89562>>>>>>>            Function_Return False
89563>>>>>>>        End
89563>>>>>>>>
89563>>>>>>>
89563>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89564>>>>>>>        If (bIsSame = False) Begin
89566>>>>>>>            Function_Return False
89567>>>>>>>        End
89567>>>>>>>>
89567>>>>>>>
89567>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89568>>>>>>>        If (bIsSame = False) Begin
89570>>>>>>>            Function_Return False
89571>>>>>>>        End
89571>>>>>>>>
89571>>>>>>>
89571>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89572>>>>>>>        If (bIsSame = False) Begin
89574>>>>>>>            Function_Return False
89575>>>>>>>        End
89575>>>>>>>>
89575>>>>>>>
89575>>>>>>>        Function_Return bIsSame
89576>>>>>>>    End_Function
89577>>>>>>>
89577>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89579>>>>>>>        Handle hTableFrom hTableTo
89579>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89579>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89579>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89579>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89579>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89580>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89580>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89581>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89581>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89582>>>>>>>
89582>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89583>>>>>>>        If (bIsSame = True) Begin
89585>>>>>>>            Function_Return True
89586>>>>>>>        End
89586>>>>>>>>
89586>>>>>>>
89586>>>>>>>        Move False to bFilelistError
89587>>>>>>>        Move True to bIsSame
89588>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89589>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89590>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89591>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89592>>>>>>>        Set Private.phCurrentTable to hTableFrom
89593>>>>>>>        
89593>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89594>>>>>>>
89594>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89595>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89596>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89597>>>>>>>
89597>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89597>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89597>>>>>>>        If (bCodeGenerateMode = True) Begin
89599>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89599>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89601>>>>>>>                Function_Return False
89602>>>>>>>            End
89602>>>>>>>>
89602>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89603>>>>>>>            If (bIsSame = False) Begin
89605>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89606>>>>>>>                Move True to bFilelistError
89607>>>>>>>                Function_Return False
89608>>>>>>>            End
89608>>>>>>>>
89608>>>>>>>        End
89608>>>>>>>>
89608>>>>>>>
89608>>>>>>>        If (bCodeGenerateMode = False) Begin
89610>>>>>>>            // Then we want to create this table
89610>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89612>>>>>>>                Function_Return False
89613>>>>>>>            End
89613>>>>>>>>
89613>>>>>>>
89613>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89614>>>>>>>            If (bIsSame = False) Begin
89616>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89617>>>>>>>>
89617>>>>>>>                Move True to bFilelistError
89618>>>>>>>                Function_Return False
89619>>>>>>>            End
89619>>>>>>>>
89619>>>>>>>        End
89619>>>>>>>>
89619>>>>>>>
89619>>>>>>>        // Check columns:
89619>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89620>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89621>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89622>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89623>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89624>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89625>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89626>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89627>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89628>>>>>>>        If (bIsSame = False) Begin
89630>>>>>>>            Function_Return False
89631>>>>>>>        End
89631>>>>>>>>
89631>>>>>>>
89631>>>>>>>        // ...then check indexes:
89631>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89632>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89633>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89634>>>>>>>        If (bIsSame = False) Begin
89636>>>>>>>            Function_Return False
89637>>>>>>>        End
89637>>>>>>>>
89637>>>>>>>
89637>>>>>>>        // ...and finally relationships:
89637>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89638>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89639>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89640>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89641>>>>>>>
89641>>>>>>>        Function_Return (bIsSame = True)
89642>>>>>>>    End_Function
89643>>>>>>>
89643>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89643>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89645>>>>>>>        Handle hTable
89645>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89645>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89645>>>>>>>
89645>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89647>>>>>>>            Move True to bFilelistError
89648>>>>>>>            Function_Return False
89649>>>>>>>        End
89649>>>>>>>>
89649>>>>>>>
89649>>>>>>>        Move APITableCompare.hTable to hTable
89650>>>>>>>        Move True  to bIsSame
89651>>>>>>>        Move False to bFilelistError
89652>>>>>>>
89652>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89654>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89655>>>>>>>        End
89655>>>>>>>>
89655>>>>>>>        Else Begin
89656>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89657>>>>>>>        End
89657>>>>>>>>
89657>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89658>>>>>>>
89658>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89659>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89660>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89661>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89662>>>>>>>
89662>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89662>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89662>>>>>>>        If (bCodeGenerateMode = True) Begin
89664>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89664>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89666>>>>>>>                Function_Return False
89667>>>>>>>            End
89667>>>>>>>>
89667>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89668>>>>>>>            If (bIsSame = False) Begin
89670>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89671>>>>>>>                Move True to bFilelistError
89672>>>>>>>                Function_Return False
89673>>>>>>>            End
89673>>>>>>>>
89673>>>>>>>        End
89673>>>>>>>>
89673>>>>>>>
89673>>>>>>>        If (bCodeGenerateMode = False) Begin
89675>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89677>>>>>>>                // Then we might want to create this table
89677>>>>>>>                Function_Return False
89678>>>>>>>            End
89678>>>>>>>>
89678>>>>>>>
89678>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89679>>>>>>>            If (bIsSame = False) Begin
89681>>>>>>>                Function_Return False
89682>>>>>>>            End
89682>>>>>>>>
89682>>>>>>>
89682>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89683>>>>>>>            If (bIsSame = False) Begin
89685>>>>>>>                Function_Return False
89686>>>>>>>            End
89686>>>>>>>>
89686>>>>>>>
89686>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89687>>>>>>>            If (bIsSame = False) Begin
89689>>>>>>>                Function_Return False
89690>>>>>>>            End
89690>>>>>>>>
89690>>>>>>>
89690>>>>>>>            // Check table names et al.
89690>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89691>>>>>>>            If (bIsSame = False) Begin
89693>>>>>>>                Function_Return False
89694>>>>>>>            End
89694>>>>>>>>
89694>>>>>>>        End
89694>>>>>>>>
89694>>>>>>>
89694>>>>>>>        // Check Columns:
89694>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89695>>>>>>>        If (bIsSame = False) Begin
89697>>>>>>>            Function_Return False
89698>>>>>>>        End
89698>>>>>>>>
89698>>>>>>>
89698>>>>>>>        // ...then check Indexes:
89698>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89699>>>>>>>        If (bIsSame = False) Begin
89701>>>>>>>            Function_Return False
89702>>>>>>>        End
89702>>>>>>>>
89702>>>>>>>
89702>>>>>>>        // ...and finally Relationships:
89702>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89703>>>>>>>
89703>>>>>>>        Function_Return (bIsSame = True)
89704>>>>>>>    End_Function
89705>>>>>>>
89705>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89705>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89705>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89705>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89705>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89707>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89707>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89707>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89707>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89709>>>>>>>        tAPIColumn[]    aApiColumns
89709>>>>>>>        tAPIColumn[]    aApiColumns
89710>>>>>>>        tAPIIndex[]     aApiIndexes
89710>>>>>>>        tAPIIndex[]     aApiIndexes
89711>>>>>>>        tAPIRelation[]  aApiRelations
89711>>>>>>>        tAPIRelation[]  aApiRelations
89712>>>>>>>        Handle hTable
89712>>>>>>>        Integer iCount
89712>>>>>>>        Boolean bUserCancel bOK
89712>>>>>>>        String sLogicalName sMessageText
89712>>>>>>>
89712>>>>>>>        Get AutoConnectionIDLogin to bOK
89713>>>>>>>        Move 0 to hTable
89714>>>>>>>        If (bFromTables = True) Begin
89716>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89717>>>>>>>            If (bCompareUtil = True) Begin
89719>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89720>>>>>>>            End
89720>>>>>>>>
89720>>>>>>>        End
89720>>>>>>>>
89720>>>>>>>        Else Begin
89721>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89722>>>>>>>            If (bCompareUtil = True) Begin
89724>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89725>>>>>>>            End
89725>>>>>>>>
89725>>>>>>>        End
89725>>>>>>>>
89725>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89726>>>>>>>
89726>>>>>>>        Get UtilFilelistNoOfTables to iCount
89727>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89728>>>>>>>        Move 0 to iCount
89729>>>>>>>
89729>>>>>>>        Repeat
89729>>>>>>>>
89729>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89732>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89734>>>>>>>
89734>>>>>>>                Open hTable
89736>>>>>>>                // ToDo: Needs to be revised
89736>>>>>>>                // For some reason tables may be reported as "unopened", while in
89736>>>>>>>                // fact the open was successful (!)
89736>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89736>>>>>>>//                If (bIsOpen = False) Begin
89736>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89736>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89736>>>>>>>//                    Function_Return aApiTablesEmpty
89736>>>>>>>//                End
89736>>>>>>>
89736>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89739>>>>>>>                Set piPosition of ghoProgressBar to iCount
89740>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89741>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89742>>>>>>>
89742>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89743>>>>>>>//                Close hTable DF_PERMANENT
89743>>>>>>>                Increment iCount
89744>>>>>>>            End
89744>>>>>>>>
89744>>>>>>>
89744>>>>>>>            If (bStatusPanel = True) Begin
89746>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89747>>>>>>>                If (bUserCancel = True) Begin
89749>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89750>>>>>>>                    Function_Return aApiTablesEmpty
89751>>>>>>>                End
89751>>>>>>>>
89751>>>>>>>            End
89751>>>>>>>>
89751>>>>>>>
89751>>>>>>>        Until (hTable = 0)
89753>>>>>>>
89753>>>>>>>        Function_Return aApiTables
89754>>>>>>>    End_Function
89755>>>>>>>
89755>>>>>>>    // Returns a 'single' table APITable struct.
89755>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89757>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89757>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89757>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89757>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89757>>>>>>>        tAPIColumn[]     aApiColumns
89757>>>>>>>        tAPIColumn[]     aApiColumns
89758>>>>>>>        tAPIIndex[]      aApiIndexes
89758>>>>>>>        tAPIIndex[]      aApiIndexes
89759>>>>>>>        tAPIRelation[]   aApiRelations
89759>>>>>>>        tAPIRelation[]   aApiRelations
89760>>>>>>>        Boolean bIsOpen
89760>>>>>>>
89760>>>>>>>        Open hTable
89762>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89765>>>>>>>        If (bIsOpen = False) Begin
89767>>>>>>>            Move True to ApiTableEmpty.bError
89768>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89769>>>>>>>            Function_Return ApiTableEmpty
89770>>>>>>>        End
89770>>>>>>>>
89770>>>>>>>
89770>>>>>>>        // Fill Table Name Info
89770>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89771>>>>>>>
89771>>>>>>>        // Fill columns
89771>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89772>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89774>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89776>>>>>>>                Move True to ApiTableEmpty.bError
89777>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89778>>>>>>>                Function_Return ApiTableEmpty
89779>>>>>>>            End
89779>>>>>>>>
89779>>>>>>>        End
89779>>>>>>>>
89779>>>>>>>
89779>>>>>>>        // Fill indexes
89779>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89780>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89782>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89784>>>>>>>                Move True to ApiTableEmpty.bError
89785>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89786>>>>>>>                Function_Return ApiTableEmpty
89787>>>>>>>            End
89787>>>>>>>>
89787>>>>>>>        End
89787>>>>>>>>
89787>>>>>>>
89787>>>>>>>        // Fill relationships
89787>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89788>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89790>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89792>>>>>>>                Move True to ApiTableEmpty.bError
89793>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89794>>>>>>>                Function_Return ApiTableEmpty
89795>>>>>>>            End
89795>>>>>>>>
89795>>>>>>>        End
89795>>>>>>>>
89795>>>>>>>
89795>>>>>>>        Move hTable             to ApiTable.hTable
89796>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89797>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89798>>>>>>>
89798>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89799>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89800>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89801>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89802>>>>>>>
89802>>>>>>>        Function_Return ApiTable
89803>>>>>>>    End_Function
89804>>>>>>>
89804>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89806>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89806>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89806>>>>>>>        Boolean bIsOpen
89806>>>>>>>
89806>>>>>>>        Open hTable
89808>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89811>>>>>>>        If (bIsOpen = False) Begin
89813>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89814>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89815>>>>>>>            Function_Return APITableNameInfoEmpty
89816>>>>>>>        End
89816>>>>>>>>
89816>>>>>>>
89816>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89817>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89820>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89823>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89826>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89829>>>>>>>
89829>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89830>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
89831>>>>>>>
89831>>>>>>>        Function_Return APITableNameInfo
89832>>>>>>>    End_Function
89833>>>>>>>
89833>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89835>>>>>>>        Integer iSize iCount iItem
89835>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89835>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89835>>>>>>>
89835>>>>>>>        Move -1 to iItem
89836>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89837>>>>>>>        Decrement iSize
89838>>>>>>>        for iCount from 0 to iSize
89844>>>>>>>>
89844>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89845>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89847>>>>>>>                Move iCount to iItem
89848>>>>>>>                Move iSize  to iCount // We're done.
89849>>>>>>>            End
89849>>>>>>>>
89849>>>>>>>        Loop
89850>>>>>>>>
89850>>>>>>>
89850>>>>>>>        Function_Return iItem
89851>>>>>>>    End_Function
89852>>>>>>>
89852>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89854>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89857>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89860>>>>>>>
89860>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89863>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89866>>>>>>>
89866>>>>>>>        Function_Return (EQ)
89867>>>>>>>    End_Function
89868>>>>>>>
89868>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89870>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89870>>>>>>>        Handle hTable
89870>>>>>>>        tAPITable[] aAPITableFromAndTo
89870>>>>>>>        tAPITable[] aAPITableFromAndTo
89871>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89871>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89871>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89871>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89871>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89871>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89872>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89872>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89873>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89873>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89874>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89874>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89875>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89875>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89875>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89875>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89878>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89878>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89881>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89881>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89884>>>>>>>
89884>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89885>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89886>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89888>>>>>>>            Function_Return aAPITableCompare
89889>>>>>>>        End
89889>>>>>>>>
89889>>>>>>>
89889>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89890>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89891>>>>>>>
89891>>>>>>>        Move 0 to iItem
89892>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89893>>>>>>>        Decrement iSize
89894>>>>>>>        for iCount from 0 to iSize
89900>>>>>>>>
89900>>>>>>>
89900>>>>>>>            Move iCount to iItemFrom
89901>>>>>>>            Move iCount to iItemTo
89902>>>>>>>            Move APITableEmpty to APITableFrom
89903>>>>>>>            Move APITableEmpty to APITableTo
89904>>>>>>>
89904>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89906>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89907>>>>>>>            End
89907>>>>>>>>
89907>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89909>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89910>>>>>>>            End
89910>>>>>>>>
89910>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89912>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89913>>>>>>>                Move (iCount + 1) to iItemTo
89914>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89915>>>>>>>            End
89915>>>>>>>>
89915>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89917>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89918>>>>>>>                If (iItemTo <> -1) Begin
89920>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89921>>>>>>>                End
89921>>>>>>>>
89921>>>>>>>                Else Begin
89922>>>>>>>                    Move APITableEmpty to APITableTo
89923>>>>>>>                End
89923>>>>>>>>
89923>>>>>>>            End
89923>>>>>>>>
89923>>>>>>>
89923>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89924>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89925>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89926>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89927>>>>>>>
89927>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89928>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89929>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89930>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89931>>>>>>>
89931>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89932>>>>>>>
89932>>>>>>>            If (hTable > 0) Begin
89934>>>>>>>
89934>>>>>>>                // Table info:
89934>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89935>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89936>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89937>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89938>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89939>>>>>>>
89939>>>>>>>                // Column info:
89939>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89940>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89941>>>>>>>
89941>>>>>>>                // Index info:
89941>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89942>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89943>>>>>>>
89943>>>>>>>                // Relation info:
89943>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89944>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89945>>>>>>>
89945>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89946>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89947>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89948>>>>>>>                If (iItemTo > iItemFrom) Begin
89950>>>>>>>                    Increment iCount
89951>>>>>>>                End
89951>>>>>>>>
89951>>>>>>>                Increment iItem
89952>>>>>>>            End
89952>>>>>>>>
89952>>>>>>>
89952>>>>>>>        Loop
89953>>>>>>>>
89953>>>>>>>
89953>>>>>>>        Function_Return aAPITableCompare
89954>>>>>>>    End_Function
89955>>>>>>>
89955>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89957>>>>>>>        Integer iSize iCount iItem
89957>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89957>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89957>>>>>>>
89957>>>>>>>        Move -1 to iItem
89958>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89959>>>>>>>        Decrement iSize
89960>>>>>>>        For iCount from 0 to iSize
89966>>>>>>>>
89966>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89967>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89969>>>>>>>                Move iCount to iItem
89970>>>>>>>                Move iSize  to iCount // We're done.
89971>>>>>>>            End
89971>>>>>>>>
89971>>>>>>>        Loop
89972>>>>>>>>
89972>>>>>>>
89972>>>>>>>        Function_Return iItem
89973>>>>>>>    End_Function
89974>>>>>>>
89974>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89976>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89976>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89976>>>>>>>
89976>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89978>>>>>>>            Function_Return APITableNameInfoCompare
89979>>>>>>>        End
89979>>>>>>>>
89979>>>>>>>
89979>>>>>>>        // FROM database info:
89979>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89981>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89982>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89983>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89984>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89985>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89986>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89987>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89988>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89989>>>>>>>        End
89989>>>>>>>>
89989>>>>>>>
89989>>>>>>>        // TO database info:
89989>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89991>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89992>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89993>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89994>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89995>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89996>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89997>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89998>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89999>>>>>>>        End
89999>>>>>>>>
89999>>>>>>>
89999>>>>>>>        Function_Return APITableNameInfoCompare
90000>>>>>>>    End_Function
90001>>>>>>>
90001>>>>>>>    // Note:
90001>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90001>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90001>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90001>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90001>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90001>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90003>>>>>>>        String sTableName
90003>>>>>>>        Boolean bOpen bExists bOK
90003>>>>>>>
90003>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90004>>>>>>>        If (bExists = False) Begin
90006>>>>>>>            Function_Return ""
90007>>>>>>>        End
90007>>>>>>>>
90007>>>>>>>
90007>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90008>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90011>>>>>>>        If (bOpen = False) Begin
90013>>>>>>>            Get AutoConnectionIDLogin to bOK
90014>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90015>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90016>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90017>>>>>>>            Open hTable
90019>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90020>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90021>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90022>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90025>>>>>>>        End
90025>>>>>>>>
90025>>>>>>>        If (bOpen = True) Begin
90027>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90028>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90031>>>>>>>            // If blank it is an embedded table:
90031>>>>>>>            If (sTableName = "") Begin
90033>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90036>>>>>>>                Move 0 to LastErr
90037>>>>>>>                Move False to Err
90038>>>>>>>            End
90038>>>>>>>>
90038>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90039>>>>>>>        End
90039>>>>>>>>
90039>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90040>>>>>>>        Move 0 to LastErr
90041>>>>>>>
90041>>>>>>>        Function_Return sTableName
90042>>>>>>>    End_Function
90043>>>>>>>
90043>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90043>>>>>>>    // Returns 0 if unsuccessful.
90043>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90043>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90045>>>>>>>        String sValue sPrefixTableName sDriverID
90045>>>>>>>        Handle hTable hRetval
90045>>>>>>>
90045>>>>>>>        Get psDriverID to sDriverID
90046>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90048>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90049>>>>>>>        End
90049>>>>>>>>
90049>>>>>>>        Move 0 to hTable
90050>>>>>>>        Move 0 to hRetval
90051>>>>>>>        Repeat
90051>>>>>>>>
90051>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90054>>>>>>>            If (hTable <> 0) Begin
90056>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90059>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90061>>>>>>>                    Move hTable to hRetval
90062>>>>>>>                    Move 0 to hTable
90063>>>>>>>                End
90063>>>>>>>>
90063>>>>>>>            End
90063>>>>>>>>
90063>>>>>>>        Until (hTable = 0)
90065>>>>>>>
90065>>>>>>>        Function_Return hRetval
90066>>>>>>>    End_Function
90067>>>>>>>
90067>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90067>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90067>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90069>>>>>>>        Boolean bOK bExists
90069>>>>>>>        String sDataPath sBackupFolder
90069>>>>>>>
90069>>>>>>>        Close DF_ALL DF_PERMANENT
90070>>>>>>>        Send DoAdvance of ghoProgressBar
90071>>>>>>>
90071>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90072>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90073>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90074>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90075>>>>>>>
90075>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90076>>>>>>>        If (bExists = False) Begin
90078>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90079>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90080>>>>>>>            If (bExists = False) Begin
90082>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90083>>>>>>>>
90083>>>>>>>                Function_Return False
90084>>>>>>>            End
90084>>>>>>>>
90084>>>>>>>        End
90084>>>>>>>>
90084>>>>>>>
90084>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90085>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90086>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90087>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90088>>>>>>>        // We need to wait for Windows before we can copy files back
90088>>>>>>>        Sleep 2  
90089>>>>>>>        
90089>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90089>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90090>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90091>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90092>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90093>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90094>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90095>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90095>>>>>>>        
90095>>>>>>>
90095>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90096>>>>>>>        Function_Return True
90097>>>>>>>    End_Function
90098>>>>>>>    
90098>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90100>>>>>>>        Boolean bOK bRetval
90100>>>>>>>        Handle hTable
90100>>>>>>>        Integer iSize iCount
90100>>>>>>>        
90100>>>>>>>        Move True to bOK
90101>>>>>>>        Get UtilFilelistNoOfTables to iSize
90102>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90103>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90104>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90105>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90106>>>>>>>
90106>>>>>>>        Repeat
90106>>>>>>>>
90106>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90107>>>>>>>            Increment iCount
90108>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90111>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90113>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90114>>>>>>>                If (bRetval = False) Begin
90116>>>>>>>                    Move False to bOK
90117>>>>>>>                End
90117>>>>>>>>
90117>>>>>>>            End
90117>>>>>>>>
90117>>>>>>>        Until (hTable = 0)
90119>>>>>>>                
90119>>>>>>>        Function_Return bOK
90120>>>>>>>    End_Function           
90121>>>>>>>    
90121>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90121>>>>>>>    // After the header has been repaired - also makes a re-index.  
90121>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90121>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90123>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90123>>>>>>>        Integer iRetval
90123>>>>>>>        String sRootName sFileName sDataPath
90123>>>>>>>        
90123>>>>>>>        Move False to Err
90124>>>>>>>        Move 0 to LastErr 
90125>>>>>>>        Move True to bOK
90126>>>>>>>        
90126>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90127>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90129>>>>>>>            Function_Return True
90130>>>>>>>        End
90130>>>>>>>>
90130>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90131>>>>>>>        If (bIsAlias = True) Begin
90133>>>>>>>            Function_Return True
90134>>>>>>>        End
90134>>>>>>>>
90134>>>>>>>        
90134>>>>>>>        // Check for bad file and remove if exists
90134>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90137>>>>>>>        Set private.phCurrentTable to hTable  
90138>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90139>>>>>>>        
90139>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90139>>>>>>>        // with a "4077 - File in use" error.
90139>>>>>>>        Close DF_ALL DF_PERMANENT    
90140>>>>>>>        Open hTable
90142>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90145>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90146>>>>>>>        If (bIsOpen = False) Begin
90148>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90149>>>>>>>>
90149>>>>>>>            Function_Return False        
90150>>>>>>>        End
90150>>>>>>>>
90150>>>>>>>
90150>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90151>>>>>>>        If (bBadExists = True) Begin
90153>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90154>>>>>>>            Get vDeleteFile sFileName to iRetval
90155>>>>>>>        End
90155>>>>>>>>
90155>>>>>>>        
90155>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90156>>>>>>>        
90156>>>>>>>        Move False to Err
90157>>>>>>>        // **** Repair and reindex the table. ****
90157>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90158>>>>>>>
90158>>>>>>>        // Check for bad file: if it exists, something went wrong
90158>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90159>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90160>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90161>>>>>>>        If (bBadExists = True) Begin
90163>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90164>>>>>>>>
90164>>>>>>>            Move False to bOK
90165>>>>>>>        End
90165>>>>>>>>
90165>>>>>>>        Close hTable
90166>>>>>>>
90166>>>>>>>        Function_Return bOK
90167>>>>>>>    End_Function
90168>>>>>>>
90168>>>>>>>    // Repair and reindex the named DataFlex data-table.
90168>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90168>>>>>>>    // so use with care (make sure you only pass embedded table names).
90168>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90170>>>>>>>        String sMode
90170>>>>>>>        Integer iVoid
90170>>>>>>>
90170>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90171>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90172>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90173>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90178>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90179>>>>>>>        Function_Return (iVoid = 0)
90180>>>>>>>    End_Function
90181>>>>>>>
90181>>>>>>>    // Returns _two_ arrays.
90181>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90181>>>>>>>    // Also returns all files that are Alias files in a second array.
90181>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90181>>>>>>>    //            the DoSetAllMasterAndAlias message.
90181>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90183>>>>>>>        Integer[] iaFileIsAlias
90184>>>>>>>        Integer hTable iFileAlias iSize
90184>>>>>>>        Boolean bOpen
90184>>>>>>>
90184>>>>>>>        Move 0 to hTable
90185>>>>>>>        Repeat
90185>>>>>>>>
90185>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90188>>>>>>>            If (hTable <> 0) Begin
90190>>>>>>>                Open hTable
90192>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90195>>>>>>>                If (bOpen = True) Begin
90197>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90200>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90202>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90203>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90204>>>>>>>                    End
90204>>>>>>>>
90204>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90207>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90208>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90209>>>>>>>                    End
90209>>>>>>>>
90209>>>>>>>                End
90209>>>>>>>>
90209>>>>>>>            End
90209>>>>>>>>
90209>>>>>>>        Until (hTable = 0)
90211>>>>>>>
90211>>>>>>>        Function_Return iaFileIsAlias
90212>>>>>>>    End_Function  
90213>>>>>>>    
90213>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90213>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90215>>>>>>>        String sMode
90215>>>>>>>        Integer iRepairNeeded bIsOpen
90215>>>>>>>
90215>>>>>>>        Move "0" to sMode
90216>>>>>>>        Set private.phCurrentTable to hTable 
90217>>>>>>>        Close hTable
90218>>>>>>>        Open hTable
90220>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90223>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90228>>>>>>>
90228>>>>>>>        Function_Return iRepairNeeded
90229>>>>>>>    End_Function
90230>>>>>>>
90230>>>>>>>    // Helper function
90230>>>>>>>    // Takes two params:
90230>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90230>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90230>>>>>>>    // Returns:
90230>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90230>>>>>>>    //  DF_FILE_IS_MASTER if master
90230>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90230>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90232>>>>>>>        Integer i iSize
90232>>>>>>>
90232>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90233>>>>>>>        Decrement iSize
90234>>>>>>>        for i from 0 to iSize
90240>>>>>>>>
90240>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90242>>>>>>>                Function_Return DF_FILE_IS_MASTER
90243>>>>>>>            End
90243>>>>>>>>
90243>>>>>>>        Loop
90244>>>>>>>>
90244>>>>>>>
90244>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90245>>>>>>>        Decrement iSize
90246>>>>>>>        for i from 0 to iSize
90252>>>>>>>>
90252>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90254>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90255>>>>>>>            End
90255>>>>>>>>
90255>>>>>>>        Loop
90256>>>>>>>>
90256>>>>>>>
90256>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90257>>>>>>>    End_Function
90258>>>>>>>
90258>>>>>>>    // Determine the available indexes of a table.
90258>>>>>>>    //
90258>>>>>>>    // Arguments:
90258>>>>>>>    //   Handle hTable - The number of the table
90258>>>>>>>    //
90258>>>>>>>    // Returns:
90258>>>>>>>    //   String - A string to be used with the sort command
90258>>>>>>>    //   to re-index all indexes of a table.
90258>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90260>>>>>>>        String  sSortString
90260>>>>>>>        Integer iLastIndex iNumSegments iCount
90260>>>>>>>
90260>>>>>>>        Move "" to sSortString
90261>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90264>>>>>>>
90264>>>>>>>        for iCount from 1 to iLastIndex
90270>>>>>>>>
90270>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90273>>>>>>>            If iNumSegments Begin
90275>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90278>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90279>>>>>>>            End
90279>>>>>>>>
90279>>>>>>>        Loop
90280>>>>>>>>
90280>>>>>>>
90280>>>>>>>        Function_Return sSortString
90281>>>>>>>    End_Function
90282>>>>>>>
90282>>>>>>>    
90282>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90282>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90284>>>>>>>        Function_Return False
90285>>>>>>>    End_Function
90286>>>>>>>
90286>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90286>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90288>>>>>>>        Boolean bIsSame
90288>>>>>>>        Integer iCount iColumns iColumn
90288>>>>>>>
90288>>>>>>>        Move True to bIsSame
90289>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90290>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90291>>>>>>>        Decrement iColumns
90292>>>>>>>
90292>>>>>>>        for iCount from 0 to iColumns
90298>>>>>>>>
90298>>>>>>>            Set piPosition of ghoProgressBar to iCount
90299>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90300>>>>>>>            If (bIsSame = False) Begin
90302>>>>>>>                Function_Return False
90303>>>>>>>            End
90303>>>>>>>>
90303>>>>>>>        Loop
90304>>>>>>>>
90304>>>>>>>
90304>>>>>>>        Function_Return (bIsSame = True)
90305>>>>>>>    End_Function
90306>>>>>>>
90306>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90306>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90308>>>>>>>        Integer iFromType iToType iDbType
90308>>>>>>>        tColumnType ColumnType
90308>>>>>>>        tColumnType ColumnType
90308>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90308>>>>>>>
90308>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90310>>>>>>>            Function_Return False
90311>>>>>>>        End
90311>>>>>>>>
90311>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90313>>>>>>>            Function_Return False
90314>>>>>>>        End
90314>>>>>>>>
90314>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90316>>>>>>>            Function_Return False
90317>>>>>>>        End                                                                
90317>>>>>>>>
90317>>>>>>>
90317>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90319>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90321>>>>>>>                Function_Return False
90322>>>>>>>            End
90322>>>>>>>>
90322>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90324>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90326>>>>>>>                    End
90326>>>>>>>>
90326>>>>>>>                Else Begin
90327>>>>>>>                    Function_Return False
90328>>>>>>>                End
90328>>>>>>>>
90328>>>>>>>            End
90328>>>>>>>>
90328>>>>>>>        End
90328>>>>>>>>
90328>>>>>>>
90328>>>>>>>        Get piDbType                       to iDbType
90329>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90330>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90331>>>>>>>
90331>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90331>>>>>>>        // data types between Embedded and SQL.
90331>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90333>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90334>>>>>>>        End
90334>>>>>>>>
90334>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90336>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90337>>>>>>>        End
90337>>>>>>>>
90337>>>>>>>
90337>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90338>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90339>>>>>>>
90339>>>>>>>        // Make Date and DateTime comparison?
90339>>>>>>>        If (bCompareDate_DataTime = True) Begin
90341>>>>>>>            If (iFromType <> iToType) Begin
90343>>>>>>>                Function_Return False
90344>>>>>>>            End
90344>>>>>>>>
90344>>>>>>>        End
90344>>>>>>>>
90344>>>>>>>
90344>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90344>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90346>>>>>>>            If (iFromType <> iToType) Begin
90348>>>>>>>                Function_Return False
90349>>>>>>>            End
90349>>>>>>>>
90349>>>>>>>        End
90349>>>>>>>>
90349>>>>>>>
90349>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90349>>>>>>>        If (bIsDateTypeFrom = False) Begin
90351>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90353>>>>>>>                Function_Return False
90354>>>>>>>            End
90354>>>>>>>>
90354>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90356>>>>>>>                Function_Return False
90357>>>>>>>            End
90357>>>>>>>>
90357>>>>>>>        End
90357>>>>>>>>
90357>>>>>>>
90357>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90359>>>>>>>            Function_Return False
90360>>>>>>>        End
90360>>>>>>>>
90360>>>>>>>
90360>>>>>>>        Function_Return True
90361>>>>>>>    End_Function
90362>>>>>>>
90362>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90364>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90364>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90364>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90364>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90366>>>>>>>        String sDriverID sRootName sLogicalName
90366>>>>>>>
90366>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90367>>>>>>>        Get piDbType to iDbType
90368>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90371>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90374>>>>>>>
90374>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90377>>>>>>>        If (bIsOpen = False) Begin
90379>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90380>>>>>>>            Open hTable
90382>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90383>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90386>>>>>>>            If (bIsOpen = False) Begin
90388>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90389>>>>>>>                Move True to APIColumnsEmpty[0].bError
90390>>>>>>>                Function_Return APIColumnsEmpty
90391>>>>>>>            End
90391>>>>>>>>
90391>>>>>>>        End
90391>>>>>>>>
90391>>>>>>>
90391>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90394>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90395>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90396>>>>>>>
90396>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90397>>>>>>>        If (bIsSqlTable = True) Begin
90399>>>>>>>            Get _UtilTableExists hTable to bExists
90400>>>>>>>            If (bExists = False) Begin
90402>>>>>>>                Move True to APIColumnsEmpty[0].bError
90403>>>>>>>                Function_Return APIColumnsEmpty
90404>>>>>>>            End
90404>>>>>>>>
90404>>>>>>>        End
90404>>>>>>>>
90404>>>>>>>
90404>>>>>>>        Move 0 to iCount
90405>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90408>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90409>>>>>>>
90409>>>>>>>        for iColumn from 1 to iNumColumns
90415>>>>>>>>
90415>>>>>>>            Move 0 to iOptions
90416>>>>>>>            Move False to bIdentityKey
90417>>>>>>>            Move False to Err
90418>>>>>>>            Move 0     to LastErr
90419>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90420>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90421>>>>>>>            If (bDawSqlDriver = True) Begin
90423>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90424>>>>>>>                If (bIsSqlTable = True) Begin
90426>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90429>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90430>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90433>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90436>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90439>>>>>>>                End
90439>>>>>>>>
90439>>>>>>>                Else Begin
90440>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90443>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90444>>>>>>>                End
90444>>>>>>>>
90444>>>>>>>
90444>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90444>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90447>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90448>>>>>>>                If (bExists = False) Begin
90450>>>>>>>                    Move 0 to APIColumns[iCount].iType
90451>>>>>>>                End
90451>>>>>>>>
90451>>>>>>>                If (bExists = True) Begin
90453>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90456>>>>>>>                End
90456>>>>>>>>
90456>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90457>>>>>>>                If (bIdentityKey = True) Begin
90459>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90460>>>>>>>                End
90460>>>>>>>>
90460>>>>>>>            End
90460>>>>>>>>
90460>>>>>>>            Else Begin
90461>>>>>>>                Move False to Err
90462>>>>>>>                Move 0     to LastErr
90463>>>>>>>                If (bIsSqlTable = True) Begin
90465>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90468>>>>>>>                End
90468>>>>>>>>
90468>>>>>>>                Else Begin
90469>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90472>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90473>>>>>>>                End
90473>>>>>>>>
90473>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90473>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90474>>>>>>>                If (bExists = False) Begin
90476>>>>>>>                    Move 0 to APIColumns[iCount].iType
90477>>>>>>>                End
90477>>>>>>>>
90477>>>>>>>            End
90477>>>>>>>>
90477>>>>>>>
90477>>>>>>>            If (bExists = True) Begin
90479>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90480>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90483>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90483>>>>>>>//                If (bIsSqlTable = True) Begin
90483>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90483>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90483>>>>>>>//                End
90483>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90486>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90489>>>>>>>
90489>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90489>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90489>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90491>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90494>>>>>>>                    If (iType = DF_OVERLAP) Begin
90496>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90497>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90498>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90499>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90500>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90501>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90502>>>>>>>                        Decrement iCount
90503>>>>>>>                    End
90503>>>>>>>>
90503>>>>>>>                End
90503>>>>>>>>
90503>>>>>>>            End
90503>>>>>>>>
90503>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90504>>>>>>>            If (bUserCancel = True) Begin
90506>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90507>>>>>>>                Function_Return APIColumnsEmpty
90508>>>>>>>            End
90508>>>>>>>>
90508>>>>>>>            Increment iCount
90509>>>>>>>        Loop
90510>>>>>>>>
90510>>>>>>>
90510>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90511>>>>>>>        Function_Return APIColumns
90512>>>>>>>    End_Function
90513>>>>>>>
90513>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90513>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90513>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90513>>>>>>>    // have "holes" in the series of index numbers.
90513>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90515>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90515>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90516>>>>>>>        tAPIColumnCompare   APIColumnCompare
90516>>>>>>>        tAPIColumnCompare   APIColumnCompare
90516>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90516>>>>>>>
90516>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90517>>>>>>>        Decrement iSizeFrom
90518>>>>>>>        for iCount from 0 to iSizeFrom
90524>>>>>>>>
90524>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90525>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90526>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90527>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90528>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90529>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90530>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90531>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90532>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90533>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90534>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90535>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90536>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90537>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90538>>>>>>>        Loop
90539>>>>>>>>
90539>>>>>>>
90539>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90540>>>>>>>        Decrement iSizeTo
90541>>>>>>>        for iCount from 0 to iSizeTo
90547>>>>>>>>
90547>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90548>>>>>>>            // Search if the field number already exists in the array; else add it.
90548>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90549>>>>>>>            If (iItem = -1) Begin
90551>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90552>>>>>>>            End
90552>>>>>>>>
90552>>>>>>>
90552>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90553>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90554>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90555>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90556>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90557>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90558>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90559>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90560>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90561>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90562>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90563>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90564>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90565>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90566>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90567>>>>>>>        Loop
90568>>>>>>>>
90568>>>>>>>
90568>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90569>>>>>>>
90569>>>>>>>        Function_Return aAPIColumnCompare
90570>>>>>>>    End_Function
90571>>>>>>>
90571>>>>>>>    // Checks if a field name exists in a table definition
90571>>>>>>>    // Returns True if it does
90571>>>>>>>    // Sample:
90571>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90571>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90573>>>>>>>        Integer iNumColumns iColumn
90573>>>>>>>        String sColumn
90573>>>>>>>        Boolean bExists bOK bOpen
90573>>>>>>>
90573>>>>>>>        Get AutoConnectionIDLogin to bOK
90574>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90575>>>>>>>        Open hTable
90577>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90578>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90581>>>>>>>        If (bOpen = False) Begin
90583>>>>>>>            Function_Return False
90584>>>>>>>        End
90584>>>>>>>>
90584>>>>>>>
90584>>>>>>>        Move False to bExists
90585>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90588>>>>>>>        for iColumn from 1 to iNumColumns
90594>>>>>>>>
90594>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90597>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90599>>>>>>>                Move iNumColumns to iColumn
90600>>>>>>>                Move True to bExists
90601>>>>>>>            End
90601>>>>>>>>
90601>>>>>>>        Loop
90602>>>>>>>>
90602>>>>>>>        Close hTable
90603>>>>>>>
90603>>>>>>>        Function_Return bExists
90604>>>>>>>    End_Function
90605>>>>>>>
90605>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90605>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90607>>>>>>>        Integer iNumColumns iColumn iRetval
90607>>>>>>>        String sColumn
90607>>>>>>>        Boolean bOK bOpen
90607>>>>>>>
90607>>>>>>>        Get AutoConnectionIDLogin to bOK
90608>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90609>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90610>>>>>>>        Open hTable
90612>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90613>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90616>>>>>>>        If (bOpen = False) Begin
90618>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90619>>>>>>>            Function_Return False
90620>>>>>>>        End
90620>>>>>>>>
90620>>>>>>>
90620>>>>>>>        Move 0 to iColumn
90621>>>>>>>        Move 0 to iRetval
90622>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90625>>>>>>>        for iColumn from 1 to iNumColumns
90631>>>>>>>>
90631>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90634>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90636>>>>>>>                Move iColumn to iRetval
90637>>>>>>>                Move iNumColumns to iColumn
90638>>>>>>>            End
90638>>>>>>>>
90638>>>>>>>        Loop
90639>>>>>>>>
90639>>>>>>>        Close hTable
90640>>>>>>>
90640>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90641>>>>>>>        Function_Return iRetval
90642>>>>>>>    End_Function
90643>>>>>>>
90643>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90643>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90643>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90645>>>>>>>        tColumnType RetvalType
90645>>>>>>>        tColumnType RetvalType
90645>>>>>>>
90645>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90646>>>>>>>        Function_Return RetvalType.iSQLType
90647>>>>>>>    End_Function
90648>>>>>>>
90648>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90648>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90648>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90650>>>>>>>        tColumnType RetvalType
90650>>>>>>>        tColumnType RetvalType
90650>>>>>>>
90650>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90651>>>>>>>        Function_Return RetvalType.sSQLType
90652>>>>>>>    End_Function
90653>>>>>>>
90653>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90655>>>>>>>        tColumnType RetvalType
90655>>>>>>>        tColumnType RetvalType
90655>>>>>>>
90655>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90656>>>>>>>        Function_Return RetvalType.sPrecision
90657>>>>>>>    End_Function
90658>>>>>>>
90658>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90660>>>>>>>        tColumnType RetvalType
90660>>>>>>>        tColumnType RetvalType
90660>>>>>>>
90660>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90661>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90661>>>>>>>        // if the column type length is _not_ fixed.
90661>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90662>>>>>>>    End_Function
90663>>>>>>>
90663>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90665>>>>>>>        tColumnType RetvalType
90665>>>>>>>        tColumnType RetvalType
90665>>>>>>>        String sValue
90665>>>>>>>        Integer iRetval iPos
90665>>>>>>>
90665>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90666>>>>>>>        Move RetvalType.sPrecision to sValue
90667>>>>>>>        Move (Pos(".", sValue)) to iPos
90668>>>>>>>        If (iPos <> 0) Begin
90670>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90671>>>>>>>        End
90671>>>>>>>>
90671>>>>>>>        Else Begin
90672>>>>>>>            Move sValue to iRetval
90673>>>>>>>        End
90673>>>>>>>>
90673>>>>>>>        Function_Return iRetval
90674>>>>>>>    End_Function
90675>>>>>>>
90675>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90677>>>>>>>        tColumnType RetvalType
90677>>>>>>>        tColumnType RetvalType
90677>>>>>>>        String sValue
90677>>>>>>>        Integer iRetval iPos
90677>>>>>>>
90677>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90678>>>>>>>        Move RetvalType.sPrecision to sValue
90679>>>>>>>        Move (Pos(".", sValue)) to iPos
90680>>>>>>>        If (iPos = 0) Begin
90682>>>>>>>            Function_Return 0
90683>>>>>>>        End
90683>>>>>>>>
90683>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90684>>>>>>>
90684>>>>>>>        Function_Return iRetval
90685>>>>>>>    End_Function
90686>>>>>>>
90686>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90686>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90688>>>>>>>        Function_Return False
90689>>>>>>>    End_Function
90690>>>>>>>
90690>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90690>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90692>>>>>>>        Boolean bIsSame
90692>>>>>>>        Integer iCount iSize
90692>>>>>>>
90692>>>>>>>        Move True to bIsSame
90693>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90694>>>>>>>        Decrement iSize
90695>>>>>>>        For iCount from 0 to iSize
90701>>>>>>>>
90701>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90702>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90703>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90704>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90705>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90706>>>>>>>            If (bIsSame = False) Begin
90708>>>>>>>                Function_Return False
90709>>>>>>>            End
90709>>>>>>>>
90709>>>>>>>        Loop
90710>>>>>>>>
90710>>>>>>>
90710>>>>>>>        Function_Return bIsSame
90711>>>>>>>    End_Function
90712>>>>>>>
90712>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90712>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90714>>>>>>>        Boolean bIsSame
90714>>>>>>>        Integer iSegment
90714>>>>>>>
90714>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90715>>>>>>>        If (bIsSame = False) Begin
90717>>>>>>>            Function_Return False
90718>>>>>>>        End
90718>>>>>>>>
90718>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90719>>>>>>>        If (bIsSame = False) Begin
90721>>>>>>>            Function_Return False
90722>>>>>>>        End
90722>>>>>>>>
90722>>>>>>>
90722>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90724>>>>>>>            // * We should probably not compare SQL index names?
90724>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90724>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90724>>>>>>>            //     Function_Return False
90724>>>>>>>            // End
90724>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90725>>>>>>>            If (bIsSame = False) Begin
90727>>>>>>>                Function_Return False
90728>>>>>>>            End
90728>>>>>>>>
90728>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90729>>>>>>>            If (bIsSame = False) Begin
90731>>>>>>>                Function_Return False
90732>>>>>>>            End
90732>>>>>>>>
90732>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90733>>>>>>>            If (bIsSame = False) Begin
90735>>>>>>>                Function_Return False
90736>>>>>>>            End
90736>>>>>>>>
90736>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90737>>>>>>>            If (bIsSame = False) Begin
90739>>>>>>>                Function_Return False
90740>>>>>>>            End
90740>>>>>>>>
90740>>>>>>>        End
90740>>>>>>>>
90740>>>>>>>
90740>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90741>>>>>>>        Move (iSegment = -1) to bIsSame
90742>>>>>>>
90742>>>>>>>        Function_Return (bIsSame = True)
90743>>>>>>>    End_Function
90744>>>>>>>
90744>>>>>>>    // Compares each segment for the passed index.
90744>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90744>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90746>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90746>>>>>>>        Boolean bIsSame
90746>>>>>>>
90746>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90747>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90748>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90749>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90750>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90751>>>>>>>
90751>>>>>>>        Decrement iNumSegments
90752>>>>>>>        for iSegment from 0 to iNumSegments
90758>>>>>>>>
90758>>>>>>>            Move False to bIsSame
90759>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90761>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90762>>>>>>>            End
90762>>>>>>>>
90762>>>>>>>            If (bIsSame = False) Begin
90764>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90765>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90766>>>>>>>                Function_Return iSegment
90767>>>>>>>            End
90767>>>>>>>>
90767>>>>>>>        Loop
90768>>>>>>>>
90768>>>>>>>
90768>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90769>>>>>>>        Function_Return -1 // This means bIsSame = True
90770>>>>>>>    End_Function
90771>>>>>>>
90771>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90773>>>>>>>        Boolean bIsSame
90773>>>>>>>
90773>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90774>>>>>>>        If (bIsSame = False) Begin
90776>>>>>>>            Function_Return False
90777>>>>>>>        End
90777>>>>>>>>
90777>>>>>>>        If (bCompareIndexUppercase = True) Begin
90779>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90780>>>>>>>            If (bIsSame = False) Begin
90782>>>>>>>                Function_Return False
90783>>>>>>>            End
90783>>>>>>>>
90783>>>>>>>        End
90783>>>>>>>>
90783>>>>>>>        If (bCompareIndexAscending = True) Begin
90785>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90786>>>>>>>            If (bIsSame = False) Begin
90788>>>>>>>                Function_Return False
90789>>>>>>>            End
90789>>>>>>>>
90789>>>>>>>        End
90789>>>>>>>>
90789>>>>>>>
90789>>>>>>>        Function_Return True
90790>>>>>>>    End_Function
90791>>>>>>>
90791>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90793>>>>>>>        Boolean bIsSame bOK
90793>>>>>>>        Integer iSize iSizeTo iCount
90793>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90793>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90794>>>>>>>
90794>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90795>>>>>>>        If (iSize = 0) Begin
90797>>>>>>>            Function_Return True
90798>>>>>>>        End
90798>>>>>>>>
90798>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90799>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90800>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90801>>>>>>>
90801>>>>>>>        for iCount from 0 to (iSize - 1)
90807>>>>>>>>
90807>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90808>>>>>>>            If (bIsSame = False) Begin
90810>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90811>>>>>>>            End
90811>>>>>>>>
90811>>>>>>>        Loop
90812>>>>>>>>
90812>>>>>>>
90812>>>>>>>        // We probably should delete other indexes if they exists.
90812>>>>>>>        for iCount from (iSize +1) to iSizeTo
90818>>>>>>>>
90818>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90819>>>>>>>        Loop
90820>>>>>>>>
90820>>>>>>>
90820>>>>>>>        Function_Return bOK
90821>>>>>>>    End_Function
90822>>>>>>>
90822>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90824>>>>>>>        tAPIIndex[] APIIndexes
90824>>>>>>>        tAPIIndex[] APIIndexes
90825>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90825>>>>>>>        String sDriverID
90825>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90825>>>>>>>
90825>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90826>>>>>>>        Get psDriverID to sDriverID
90827>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90828>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90829>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90832>>>>>>>        If (bIsOpen = False) Begin
90834>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90835>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90836>>>>>>>            Open hTable
90838>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90839>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90840>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90843>>>>>>>            If (bIsOpen = False) Begin
90845>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90846>>>>>>>                Move True to APIIndexes[0].bError
90847>>>>>>>                Function_Return APIIndexes
90848>>>>>>>            End
90848>>>>>>>>
90848>>>>>>>        End
90848>>>>>>>>
90848>>>>>>>
90848>>>>>>>        Move 0 to iCount
90849>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90852>>>>>>>        for iIndex from 1 to iIndexes
90858>>>>>>>>
90858>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90858>>>>>>>            // numbers doesn't not need to be consequitive:
90858>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90861>>>>>>>            If (iNumSegments > 0) Begin
90863>>>>>>>
90863>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90864>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90867>>>>>>>                If (bIsSQLTable = True) Begin
90869>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90872>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90875>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90878>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90881>>>>>>>                End
90881>>>>>>>>
90881>>>>>>>
90881>>>>>>>                Move 0 to iSegmentCount
90882>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90885>>>>>>>                For iSegment from 1 to iNumSegments
90891>>>>>>>>
90891>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90894>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90895>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90898>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90901>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90904>>>>>>>                    Increment iSegmentCount
90905>>>>>>>                Loop
90906>>>>>>>>
90906>>>>>>>                Increment iCount
90907>>>>>>>            End
90907>>>>>>>>
90907>>>>>>>        Loop
90908>>>>>>>>
90908>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90909>>>>>>>
90909>>>>>>>        Function_Return APIIndexes
90910>>>>>>>    End_Function
90911>>>>>>>
90911>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90911>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90911>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90911>>>>>>>    // have "holes" in the series of index numbers.
90911>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90913>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90913>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90914>>>>>>>        tAPIIndexCompare   APIIndexCompare
90914>>>>>>>        tAPIIndexCompare   APIIndexCompare
90914>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90914>>>>>>>
90914>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90915>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90916>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90918>>>>>>>            Function_Return aAPIIndexCompare
90919>>>>>>>        End
90919>>>>>>>>
90919>>>>>>>
90919>>>>>>>        Decrement iSizeFrom
90920>>>>>>>        for iCount from 0 to iSizeFrom
90926>>>>>>>>
90926>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90927>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90928>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90929>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90930>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90931>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90932>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90933>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90934>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90935>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90936>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90937>>>>>>>        Loop
90938>>>>>>>>
90938>>>>>>>
90938>>>>>>>        Decrement iSizeTo
90939>>>>>>>        for iCount from 0 to iSizeTo
90945>>>>>>>>
90945>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90946>>>>>>>            // Search if the Index number already exists in the array; else add it.
90946>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90947>>>>>>>            If (iItem = -1) Begin
90949>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90950>>>>>>>            End
90950>>>>>>>>
90950>>>>>>>
90950>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90951>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90952>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90953>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90954>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90955>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90956>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90957>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90958>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90959>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90960>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90961>>>>>>>        Loop
90962>>>>>>>>
90962>>>>>>>
90962>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90963>>>>>>>
90963>>>>>>>        Function_Return aAPIIndexCompare
90964>>>>>>>    End_Function
90965>>>>>>>
90965>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90965>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90967>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90967>>>>>>>        String sDriverID
90967>>>>>>>
90967>>>>>>>        Get psDriverID to sDriverID
90968>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90969>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90970>>>>>>>        If (bIsSqlTable = True) Begin
90972>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90973>>>>>>>        End
90973>>>>>>>>
90973>>>>>>>
90973>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90974>>>>>>>        If (bIsSame = False) Begin
90976>>>>>>>            Function_Return False
90977>>>>>>>        End
90977>>>>>>>>
90977>>>>>>>
90977>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90979>>>>>>>            // Don't think we should do this. Or should we?
90979>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90979>>>>>>>
90979>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90980>>>>>>>            If (bIsSame = False) Begin
90982>>>>>>>                Function_Return False
90983>>>>>>>            End
90983>>>>>>>>
90983>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90984>>>>>>>            If (bIsSame = False) Begin
90986>>>>>>>                Function_Return False
90987>>>>>>>            End
90987>>>>>>>>
90987>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90988>>>>>>>            If (bIsSame = False) Begin
90990>>>>>>>                Function_Return False
90991>>>>>>>            End
90991>>>>>>>>
90991>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90992>>>>>>>            If (bIsSame = False) Begin
90994>>>>>>>                Function_Return False
90995>>>>>>>            End
90995>>>>>>>>
90995>>>>>>>        End
90995>>>>>>>>
90995>>>>>>>
90995>>>>>>>        Function_Return bIsSame
90996>>>>>>>    End_Function
90997>>>>>>>
90997>>>>>>>    // DF_INDEX_SQL_TYPE values
90997>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90997>>>>>>>    // returns a string with the name.
90997>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90999>>>>>>>        String sRetval
90999>>>>>>>            Case Begin
90999>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91001>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91002>>>>>>>                    Case Break
91003>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91006>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91007>>>>>>>                    Case Break
91008>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91011>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91012>>>>>>>                    Case Break
91013>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91016>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91017>>>>>>>                    Case Break
91018>>>>>>>                Case Else
91018>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91019>>>>>>>            Case End
91019>>>>>>>        Function_Return sRetval
91020>>>>>>>    End_Function
91021>>>>>>>
91021>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91021>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91023>>>>>>>        Function_Return False
91024>>>>>>>    End_Function
91025>>>>>>>
91025>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91025>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91027>>>>>>>        Boolean bIsSame
91027>>>>>>>        Integer iSize iCount
91027>>>>>>>
91027>>>>>>>        Move True to bIsSame
91028>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91029>>>>>>>        Decrement iSize
91030>>>>>>>        For iCount from 0 to iSize
91036>>>>>>>>
91036>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91037>>>>>>>            If (bIsSame = False) Begin
91039>>>>>>>                Function_Return False
91040>>>>>>>            End
91040>>>>>>>>
91040>>>>>>>        Loop
91041>>>>>>>>
91041>>>>>>>
91041>>>>>>>        Function_Return bIsSame
91042>>>>>>>    End_Function
91043>>>>>>>
91043>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91043>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91045>>>>>>>        Boolean bIsSame
91045>>>>>>>
91045>>>>>>>        Move True to bIsSame
91046>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91048>>>>>>>            Function_Return False
91049>>>>>>>        End
91049>>>>>>>>
91049>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91051>>>>>>>            Function_Return False
91052>>>>>>>        End
91052>>>>>>>>
91052>>>>>>>
91052>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91052>>>>>>>
91052>>>>>>>        Function_Return bIsSame
91053>>>>>>>    End_Function
91054>>>>>>>
91054>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91054>>>>>>>    // already exists.
91054>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91056>>>>>>>        Boolean bOK
91056>>>>>>>        Integer iSizeTo iSize iCount iColumn
91056>>>>>>>        String sDriverID
91056>>>>>>>
91056>>>>>>>        Move True to bOK
91057>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91058>>>>>>>        If (iSizeTo > 0) Begin
91060>>>>>>>            Get AutoConnectionIDLogin to bOK
91061>>>>>>>            Move False to Err
91062>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91064>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91067>>>>>>>            Decrement iSizeTo
91068>>>>>>>
91068>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91068>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91068>>>>>>>            Structure_Start hTable sDriverID
91069>>>>>>>                for iCount from 0 to iSizeTo
91075>>>>>>>>
91075>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91076>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91079>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91082>>>>>>>                Loop
91083>>>>>>>>
91083>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91084>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91086>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91087>>>>>>>        End
91087>>>>>>>>
91087>>>>>>>
91087>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91088>>>>>>>        Decrement iSize
91089>>>>>>>        for iCount from 0 to iSize
91095>>>>>>>>
91095>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91096>>>>>>>        Loop
91097>>>>>>>>
91097>>>>>>>
91097>>>>>>>        Function_Return bOK
91098>>>>>>>    End_Function
91099>>>>>>>
91099>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91101>>>>>>>        tAPIRelation[] APIRelations
91101>>>>>>>        tAPIRelation[] APIRelations
91102>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91102>>>>>>>        Handle hParent
91102>>>>>>>        Boolean bIsOpen
91102>>>>>>>
91102>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91103>>>>>>>        Move 0 to iCount
91104>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91107>>>>>>>        If (bIsOpen = False) Begin
91109>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91110>>>>>>>            Open hTable
91112>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91113>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91116>>>>>>>            If (bIsOpen = False) Begin
91118>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91119>>>>>>>                Move True to APIRelations[0].bError
91120>>>>>>>                Function_Return APIRelations
91121>>>>>>>            End
91121>>>>>>>>
91121>>>>>>>        End
91121>>>>>>>>
91121>>>>>>>
91121>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91124>>>>>>>        For iColumn from 1 to iNumColumns
91130>>>>>>>>
91130>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91133>>>>>>>            If (hParent <> 0) Begin
91135>>>>>>>                Open hParent
91137>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91138>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91141>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91142>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91145>>>>>>>
91145>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91146>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91149>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91152>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91153>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91156>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91157>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91158>>>>>>>                Move False                                              to APIRelations[iCount].bError
91159>>>>>>>                Close hParent
91160>>>>>>>                Increment iCount
91161>>>>>>>            End
91161>>>>>>>>
91161>>>>>>>        Loop
91162>>>>>>>>
91162>>>>>>>
91162>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91163>>>>>>>        Function_Return APIRelations
91164>>>>>>>    End_Function
91165>>>>>>>
91165>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91165>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91165>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91167>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91167>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91168>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91168>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91169>>>>>>>        tAPIRelationCompare   APIRelationCompare
91169>>>>>>>        tAPIRelationCompare   APIRelationCompare
91169>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91169>>>>>>>
91169>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91170>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91171>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91173>>>>>>>            Function_Return aAPIRelationCompare
91174>>>>>>>        End
91174>>>>>>>>
91174>>>>>>>
91174>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91175>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91176>>>>>>>
91176>>>>>>>        Decrement iSizeFrom
91177>>>>>>>        for iCount from 0 to iSizeFrom
91183>>>>>>>>
91183>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91184>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91185>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91186>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91187>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91188>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91189>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91190>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91191>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91192>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91193>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91194>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91195>>>>>>>        Loop
91196>>>>>>>>
91196>>>>>>>
91196>>>>>>>        Decrement iSizeTo
91197>>>>>>>        for iCount from 0 to iSizeTo
91203>>>>>>>>
91203>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91204>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91205>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91206>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91207>>>>>>>
91207>>>>>>>            // Search if the relation already exists in the array; else add it.
91207>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91208>>>>>>>            If (iItem = -1) Begin
91210>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91211>>>>>>>            End
91211>>>>>>>>
91211>>>>>>>
91211>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91212>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91213>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91214>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91215>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91216>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91217>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91218>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91219>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91220>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91221>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91222>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91223>>>>>>>        Loop
91224>>>>>>>>
91224>>>>>>>
91224>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91225>>>>>>>
91225>>>>>>>        Function_Return aAPIRelationCompare
91226>>>>>>>    End_Function
91227>>>>>>>
91227>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91227>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91229>>>>>>>        Function_Return False
91230>>>>>>>    End_Function
91231>>>>>>>
91231>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91231>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91231>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91231>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91233>>>>>>>        Boolean bFound
91233>>>>>>>
91233>>>>>>>        Move False to Err
91234>>>>>>>        Open CodeMast
91236>>>>>>>        Open CodeType
91238>>>>>>>
91238>>>>>>>        If (bCodeType = True) Begin
91240>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91241>>>>>>>            Clear CodeType
91242>>>>>>>            Move sTypeValue to CODETYPE.Type
91243>>>>>>>            Find eq CODETYPE by 1
91244>>>>>>>>
91244>>>>>>>            Move Found to bFound
91245>>>>>>>            If (bFound = True) Begin
91247>>>>>>>                Reread CodeType
91251>>>>>>>            End
91251>>>>>>>>
91251>>>>>>>            Else Begin
91252>>>>>>>                Clear CodeType
91253>>>>>>>            End
91253>>>>>>>>
91253>>>>>>>
91253>>>>>>>            Move sTypeValue to CODETYPE.Type
91254>>>>>>>            Move sValue2    to CODETYPE.Description
91255>>>>>>>            Move sValue3    to CODETYPE.Comment
91256>>>>>>>            SaveRecord CODETYPE
91257>>>>>>>
91257>>>>>>>            If (bFound = True) Begin
91259>>>>>>>                Unlock
91260>>>>>>>>
91260>>>>>>>            End
91260>>>>>>>>
91260>>>>>>>        End
91260>>>>>>>>
91260>>>>>>>
91260>>>>>>>        If (bCodeType = False) Begin
91262>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91263>>>>>>>            Clear CODEMAST
91264>>>>>>>            Move sTypeValue to CODEMAST.Type
91265>>>>>>>            Move sValue2    to CODEMAST.Code
91266>>>>>>>            Find eq CODEMAST by 1
91267>>>>>>>>
91267>>>>>>>            Move Found to bFound
91268>>>>>>>            If (bFound = True) Begin
91270>>>>>>>                Reread CODEMAST
91274>>>>>>>            End
91274>>>>>>>>
91274>>>>>>>            Else Begin
91275>>>>>>>                Clear CODEMAST
91276>>>>>>>            End
91276>>>>>>>>
91276>>>>>>>
91276>>>>>>>            Move sTypeValue to CODEMAST.Type
91277>>>>>>>            Move sValue2    to CODEMAST.Code
91278>>>>>>>            Move sValue3    to CODEMAST.Description
91279>>>>>>>            SaveRecord CODEMAST
91280>>>>>>>
91280>>>>>>>            If (bFound = True) Begin
91282>>>>>>>                Unlock
91283>>>>>>>>
91283>>>>>>>            End
91283>>>>>>>>
91283>>>>>>>        End
91283>>>>>>>>
91283>>>>>>>
91283>>>>>>>        Close CodeMast
91284>>>>>>>        Close CodeType
91285>>>>>>>
91285>>>>>>>        Function_Return (Err = False)
91286>>>>>>>    End_Function
91287>>>>>>>
91287>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91287>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91287>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91289>>>>>>>        Boolean bFound
91289>>>>>>>
91289>>>>>>>        Move False to Err
91290>>>>>>>        Open CodeMast
91292>>>>>>>        Open CodeType
91294>>>>>>>
91294>>>>>>>        Clear CodeType
91295>>>>>>>        Move sFromValue to CODETYPE.Type
91296>>>>>>>        Find eq CODETYPE.Type
91297>>>>>>>>
91297>>>>>>>        If (Found = True) Begin
91299>>>>>>>            Reread CODETYPE
91303>>>>>>>                Move sToValue to CODETYPE.Type
91304>>>>>>>                SaveRecord CODETYPE
91305>>>>>>>            Unlock
91306>>>>>>>>
91306>>>>>>>        End
91306>>>>>>>>
91306>>>>>>>
91306>>>>>>>        Clear CODEMAST
91307>>>>>>>        Find gt CODEMAST by Recnum
91308>>>>>>>>
91308>>>>>>>        While (Found = True)
91312>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91313>>>>>>>            If (bFound = True) Begin
91315>>>>>>>                Reread CODEMAST
91319>>>>>>>                    Move sToValue to CODEMAST.Type
91320>>>>>>>                    SaveRecord CODEMAST
91321>>>>>>>                Unlock
91322>>>>>>>>
91322>>>>>>>            End
91322>>>>>>>>
91322>>>>>>>            Find gt CODEMAST by Recnum
91323>>>>>>>>
91323>>>>>>>        Loop
91324>>>>>>>>
91324>>>>>>>
91324>>>>>>>        Close CodeMast
91325>>>>>>>        Close CodeType
91326>>>>>>>
91326>>>>>>>        Function_Return (Err = False)
91327>>>>>>>    End_Function
91328>>>>>>>
91328>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91328>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91330>>>>>>>        Boolean bFound
91330>>>>>>>
91330>>>>>>>        Move False to Err
91331>>>>>>>        Open CodeMast
91333>>>>>>>
91333>>>>>>>        Clear CODEMAST
91334>>>>>>>        Move sTypeValue to CODEMAST.Type
91335>>>>>>>        Move sValue2    to CODEMAST.Code
91336>>>>>>>        Find eq CODEMAST.Code
91337>>>>>>>>
91337>>>>>>>        Move Found to bFound
91338>>>>>>>        If (bFound = True) Begin
91340>>>>>>>            Delete CODEMAST
91341>>>>>>>        End
91341>>>>>>>>
91341>>>>>>>
91341>>>>>>>        Close CodeMast
91342>>>>>>>
91342>>>>>>>        Function_Return (Err = False)
91343>>>>>>>    End_Function
91344>>>>>>>
91344>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91346>>>>>>>        Boolean bRecnum bToAnsi
91346>>>>>>>        Integer iCh
91346>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91346>>>>>>>
91346>>>>>>>        If (Trim(sDataPath) = "") Begin
91348>>>>>>>            Function_Return False
91349>>>>>>>        End
91349>>>>>>>>
91349>>>>>>>
91349>>>>>>>        Move False to Err
91350>>>>>>>        Get psDriverID     to sDriverID
91351>>>>>>>        Get psConnectionID to sConnectionID
91352>>>>>>>        Get psSchema       to sSchemaName
91353>>>>>>>        Get True           to bRecnum
91354>>>>>>>        Get pbToANSI       to bToAnsi
91355>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91356>>>>>>>        If (bToAnsi = False) Begin
91358>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91359>>>>>>>        End
91359>>>>>>>>
91359>>>>>>>
91359>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91360>>>>>>>        Move "CodeMast.int"         to sFileName
91361>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91362>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91365>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91368>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91371>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91374>>>>>>>            Writeln channel iCh ("")
91377>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91380>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91383>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91386>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91389>>>>>>>            Writeln channel iCh ("")
91392>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91395>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91398>>>>>>>            Writeln channel iCh ("")
91401>>>>>>>        Send Seq_Close_Channel iCh
91402>>>>>>>
91402>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91403>>>>>>>        Move "CodeType.int"         to sFileName
91404>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91405>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91408>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91411>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91414>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91417>>>>>>>            Writeln channel iCh ("")
91420>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91423>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91426>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91429>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91432>>>>>>>            Writeln channel iCh ("")
91435>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91438>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91441>>>>>>>            Writeln channel iCh ("")
91444>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91447>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91450>>>>>>>            Writeln channel iCh ("")
91453>>>>>>>        Send Seq_Close_Channel iCh
91454>>>>>>>
91454>>>>>>>        Function_Return (Err = False)
91455>>>>>>>    End_Function
91456>>>>>>>
91456>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91456>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91458>>>>>>>        Function_Return False
91459>>>>>>>    End_Function
91460>>>>>>>
91460>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91460>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91460>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91462>>>>>>>        Boolean bOK bExists
91462>>>>>>>        String sDataPath sBackupFolder
91462>>>>>>>
91462>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91463>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91464>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91465>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91466>>>>>>>
91466>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91467>>>>>>>        If (bExists = False) Begin
91469>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91470>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91471>>>>>>>            If (bExists = False) Begin
91473>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91474>>>>>>>>
91474>>>>>>>                Function_Return False
91475>>>>>>>            End
91475>>>>>>>>
91475>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91476>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91477>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91478>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91479>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91480>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91481>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91482>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91483>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91484>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91485>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91486>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91487>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91488>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91489>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91490>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91491>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91492>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91493>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91494>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91495>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91496>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91497>>>>>>>        End
91497>>>>>>>>
91497>>>>>>>
91497>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91498>>>>>>>        Function_Return True
91499>>>>>>>    End_Function
91500>>>>>>>    
91500>>>>>>>    // Check if the file exists in the Data folder,
91500>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91500>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91502>>>>>>>        String sPath
91502>>>>>>>        Boolean bExists
91502>>>>>>>
91502>>>>>>>        Get psDataPathFirstPart to sPath
91503>>>>>>>        Move (sPath + sFileName) to sFileName
91504>>>>>>>        Get vFilePathExists sFileName to bExists
91505>>>>>>>
91505>>>>>>>        If (bExists = False) Begin
91507>>>>>>>            // Read from memory & create file on disk.
91507>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91508>>>>>>>            Get vFilePathExists sFileName to bExists
91509>>>>>>>        End
91509>>>>>>>>
91509>>>>>>>        Function_Return bExists
91510>>>>>>>    End_Function
91511>>>>>>>
91511>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91513>>>>>>>        tColumnType RetvalType
91513>>>>>>>        tColumnType RetvalType
91513>>>>>>>        Integer iRetval
91513>>>>>>>
91513>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91514>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91515>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91517>>>>>>>            If (iLength <= 255) Begin
91519>>>>>>>                Move DF_ASCII to iRetval
91520>>>>>>>            End
91520>>>>>>>>
91520>>>>>>>        End
91520>>>>>>>>
91520>>>>>>>        Function_Return iRetval
91521>>>>>>>    End_Function
91522>>>>>>>
91522>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91524>>>>>>>        String sRetval
91524>>>>>>>
91524>>>>>>>        Case Begin
91524>>>>>>>            Case (iDataType = DF_ASCII)
91526>>>>>>>                Move "DF_ASCII" to sRetval
91527>>>>>>>                Case Break
91528>>>>>>>            Case (iDataType = DF_BCD)
91531>>>>>>>                Move "DF_BCD" to sRetval
91532>>>>>>>                Case Break
91533>>>>>>>            Case (iDataType = DF_BINARY)
91536>>>>>>>                Move "DF_BINARY" to sRetval
91537>>>>>>>                Case Break
91538>>>>>>>            Case (iDataType = DF_DATE)
91541>>>>>>>                Move "DF_DATE" to sRetval
91542>>>>>>>                Case Break
91543>>>>>>>            Case (iDataType = DF_DATETIME)
91546>>>>>>>                Move "DF_DATETIME" to sRetval
91547>>>>>>>                Case Break
91548>>>>>>>            Case (iDataType = DF_TEXT)
91551>>>>>>>                Move "DF_TEXT" to sRetval
91552>>>>>>>                Case Break
91553>>>>>>>            Case Else
91553>>>>>>>                Move "" to sRetval
91554>>>>>>>        Case End
91554>>>>>>>
91554>>>>>>>        Function_Return sRetval
91555>>>>>>>    End_Function
91556>>>>>>>
91556>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91556>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91558>>>>>>>        String sRetval sServer
91558>>>>>>>        tColumnType RetvalType
91558>>>>>>>        tColumnType RetvalType
91558>>>>>>>        Integer iDriver iDataFlexType
91558>>>>>>>        Handle hDatabase
91558>>>>>>>
91558>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91559>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91560>>>>>>>        Get DriverIndex sDriverID to iDriver
91561>>>>>>>        Get psServer to sServer
91562>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91563>>>>>>>        If (hDatabase = 0) Begin
91565>>>>>>>            Function_Return ""
91566>>>>>>>        End
91566>>>>>>>>
91566>>>>>>>
91566>>>>>>>        Case Begin
91566>>>>>>>            Case (iDataFlexType = DF_ASCII)
91568>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91571>>>>>>>                Case Break
91572>>>>>>>            Case (iDataFlexType = DF_BCD)
91575>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91578>>>>>>>                Case Break
91579>>>>>>>            Case (iDataFlexType = DF_BINARY)
91582>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91585>>>>>>>                Case Break
91586>>>>>>>            Case (iDataFlexType = DF_DATE)
91589>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91592>>>>>>>                Case Break
91593>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91596>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91599>>>>>>>                Case Break
91600>>>>>>>            Case (iDataFlexType = DF_TEXT)
91603>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91606>>>>>>>                Case Break
91607>>>>>>>            Case Else
91607>>>>>>>                Move "" to sRetval
91608>>>>>>>        Case End
91608>>>>>>>
91608>>>>>>>        Function_Return sRetval
91609>>>>>>>    End_Function
91610>>>>>>>
91610>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91612>>>>>>>        String sDriverID sServer
91612>>>>>>>        tColumnType RetvalType
91612>>>>>>>        tColumnType RetvalType
91612>>>>>>>        Integer iDbType iDriver
91612>>>>>>>        Handle hDatabase
91612>>>>>>>
91612>>>>>>>        Get psDriverID to sDriverID
91613>>>>>>>        Get piDbType   to iDbType
91614>>>>>>>        Get DriverIndex sDriverID to iDriver
91615>>>>>>>        Get psServer to sServer
91616>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91617>>>>>>>        If (hDatabase = 0) Begin
91619>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91620>>>>>>>>
91620>>>>>>>            Procedure_Return
91621>>>>>>>        End
91621>>>>>>>>
91621>>>>>>>
91621>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91624>>>>>>>
91624>>>>>>>    End_Procedure
91625>>>>>>>
91625>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91627>>>>>>>        String sDriverID sServer
91627>>>>>>>        tColumnType RetvalType
91627>>>>>>>        tColumnType RetvalType
91627>>>>>>>        Integer iDbType iDriver
91627>>>>>>>        Handle hDatabase
91627>>>>>>>
91627>>>>>>>        Get psDriverID to sDriverID
91628>>>>>>>        Get piDbType   to iDbType
91629>>>>>>>        Get DriverIndex sDriverID to iDriver
91630>>>>>>>        Get psServer to sServer
91631>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91632>>>>>>>        If (hDatabase = 0) Begin
91634>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91635>>>>>>>>
91635>>>>>>>            Procedure_Return
91636>>>>>>>        End
91636>>>>>>>>
91636>>>>>>>
91636>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91639>>>>>>>
91639>>>>>>>    End_Procedure
91640>>>>>>>
91640>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91640>>>>>>>    // are mapped to the standard DataFlex data types.
91640>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91640>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91642>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91642>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91644>>>>>>>        String sDataType
91644>>>>>>>        Integer iDataType iDriverID iCount
91644>>>>>>>        Boolean bSQLDriver
91644>>>>>>>
91644>>>>>>>        Move 0 to iCount
91645>>>>>>>        Get DriverIndex sDriverID to iDriverID
91646>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91647>>>>>>>        If (bSQLDriver = False) Begin
91649>>>>>>>            Function_Return EmptyArray
91650>>>>>>>        End
91650>>>>>>>>
91650>>>>>>>
91650>>>>>>>        // DF_ASCII
91650>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91652>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91655>>>>>>>        End
91655>>>>>>>>
91655>>>>>>>        Else Begin
91656>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91659>>>>>>>        End
91659>>>>>>>>
91659>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91660>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91661>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91662>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91663>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91664>>>>>>>        Increment iCount
91665>>>>>>>
91665>>>>>>>        // DF_BINARY
91665>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91667>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91670>>>>>>>        End
91670>>>>>>>>
91670>>>>>>>        Else Begin
91671>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91674>>>>>>>        End
91674>>>>>>>>
91674>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91675>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91676>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91677>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91678>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91679>>>>>>>        Increment iCount
91680>>>>>>>
91680>>>>>>>        // DF_DATE
91680>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91682>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91685>>>>>>>        End
91685>>>>>>>>
91685>>>>>>>        Else Begin
91686>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91689>>>>>>>        End
91689>>>>>>>>
91689>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91690>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91691>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91692>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91693>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91694>>>>>>>        Increment iCount
91695>>>>>>>
91695>>>>>>>        // DF_DATETIME
91695>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91697>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91700>>>>>>>        End
91700>>>>>>>>
91700>>>>>>>        Else Begin
91701>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91704>>>>>>>        End
91704>>>>>>>>
91704>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91705>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91706>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91707>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91708>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91709>>>>>>>        Increment iCount
91710>>>>>>>
91710>>>>>>>        // DF_NUMERIC
91710>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91710>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91710>>>>>>>        // we make them here all "Numeric"...
91710>>>>>>>        Case Begin
91710>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91712>>>>>>>                Move SQL_NUMERIC to iDataType
91713>>>>>>>                Move "numeric"   to sDataType
91714>>>>>>>                Case Break
91715>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91718>>>>>>>                Move SQL_NUMERIC to iDataType
91719>>>>>>>                Move "NUMERIC"   to sDataType
91720>>>>>>>                Case Break
91721>>>>>>>            Case Else
91721>>>>>>>                Move DF_BCD      to iDataType
91722>>>>>>>                Move "Numeric"   to sDataType
91723>>>>>>>        Case End
91723>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91724>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91725>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91726>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91727>>>>>>>        Increment iCount
91728>>>>>>>
91728>>>>>>>        // DF_TEXT
91728>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91730>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91733>>>>>>>        End
91733>>>>>>>>
91733>>>>>>>        Else Begin
91734>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91737>>>>>>>        End
91737>>>>>>>>
91737>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91738>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91739>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91740>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91741>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91742>>>>>>>
91742>>>>>>>        Function_Return ColumnTypeArray
91743>>>>>>>    End_Function
91744>>>>>>>
91744>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91746>>>>>>>        tColumnType[] ColumnTypeArray
91746>>>>>>>        tColumnType[] ColumnTypeArray
91747>>>>>>>        tColumnType   ColumnType
91747>>>>>>>        tColumnType   ColumnType
91747>>>>>>>        Integer iCount iSize
91747>>>>>>>
91747>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91748>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91749>>>>>>>        Decrement iSize
91750>>>>>>>
91750>>>>>>>        for iCount from 0 to iSize
91756>>>>>>>>
91756>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91758>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91759>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91760>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91761>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91762>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91763>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91764>>>>>>>                Move iSize to iCount
91765>>>>>>>            End
91765>>>>>>>>
91765>>>>>>>        Loop
91766>>>>>>>>
91766>>>>>>>
91766>>>>>>>        Function_Return ColumnType
91767>>>>>>>    End_Function
91768>>>>>>>
91768>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91768>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91768>>>>>>>    // but the Logical name is different.
91768>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91768>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91770>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91770>>>>>>>        Handle hInTable hMasterTable 
91770>>>>>>>        Boolean bIsAlias
91770>>>>>>>        
91770>>>>>>>        Move hTable to hInTable
91771>>>>>>>        Move False to bIsAlias
91772>>>>>>>        Move 0 to hMasterTable
91773>>>>>>>        
91773>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91776>>>>>>>        // Remove any prefix with a driver name.
91776>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91777>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91780>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91781>>>>>>>        
91781>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91781>>>>>>>        // so we can safely return a "False".
91781>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
91783>>>>>>>            Function_Return True
91784>>>>>>>        End
91784>>>>>>>>
91784>>>>>>>        
91784>>>>>>>        Function_Return False
91785>>>>>>>        
91785>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91785>>>>>>>        // as the passed hTable root name.
91785>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
91785>>>>>>>//        Move 0 to hTable
91785>>>>>>>//        Repeat
91785>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91785>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
91785>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91785>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91785>>>>>>>//                // If we found another table with the same root and logical name
91785>>>>>>>//                // we have found a master table.
91785>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91785>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91785>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91785>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91785>>>>>>>//                        Move hTable to hMasterTable   
91785>>>>>>>//                        Move 0 to hTable // To end the loop.
91785>>>>>>>//                    End
91785>>>>>>>//                End
91785>>>>>>>//            End
91785>>>>>>>//        Until (hTable = 0)
91785>>>>>>>//        
91785>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91785>>>>>>>//            Move True to bIsAlias
91785>>>>>>>//        End
91785>>>>>>>//        
91785>>>>>>>//        Function_Return bIsAlias
91785>>>>>>>    End_Function
91786>>>>>>>
91786>>>>>>>    // To Open a table with any driver.
91786>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91786>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91786>>>>>>>    //
91786>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91786>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
91786>>>>>>>    // returns a True if successful (table could be opened).
91786>>>>>>>    //
91786>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91786>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91786>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91786>>>>>>>    // set properly we can open the table.
91786>>>>>>>    //
91786>>>>>>>    // DAW Driver Syntax:
91786>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91786>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91786>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91786>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91786>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91786>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91786>>>>>>>    //
91786>>>>>>>    // DAW Driver Sample:
91786>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91786>>>>>>>    //
91786>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91788>>>>>>>        String sTableNameOrg
91788>>>>>>>        Boolean bOpen bOK
91788>>>>>>>        tSQLConnection SQLConnection
91788>>>>>>>        tSQLConnection SQLConnection
91788>>>>>>>        
91788>>>>>>>        Move False to bOpen
91789>>>>>>>        Move sTableName to sTableNameOrg
91790>>>>>>>        If (hTable > 0) Begin
91792>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
91793>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91794>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91795>>>>>>>            Send Ignore_Error of Error_Object_Id 10
91796>>>>>>>            Open hTable Mode iMode
91798>>>>>>>            Send Trap_Error of Error_Object_Id 20529
91799>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91800>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91801>>>>>>>            Send Trap_Error of Error_Object_Id 10
91802>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91805>>>>>>>            If (bOpen = True) Begin
91807>>>>>>>                Function_Return True
91808>>>>>>>            End
91808>>>>>>>>
91808>>>>>>>        End
91808>>>>>>>>
91808>>>>>>>
91808>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91809>>>>>>>        If (hTable > 0) Begin
91811>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91814>>>>>>>        End
91814>>>>>>>>
91814>>>>>>>
91814>>>>>>>        Function_Return bOpen
91815>>>>>>>    End_Function
91816>>>>>>>
91816>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91818>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91818>>>>>>>        Boolean bOpen bOK
91818>>>>>>>        tSQLConnection SQLConnection
91818>>>>>>>        tSQLConnection SQLConnection
91818>>>>>>>
91818>>>>>>>        If (hTable < 1) Begin
91820>>>>>>>            Function_Return False
91821>>>>>>>        End
91821>>>>>>>>
91821>>>>>>>
91821>>>>>>>        Move sTableName to sTableNameOrg
91822>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91823>>>>>>>        Move SQLConnection.sDriverID to sDriverID
91824>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91825>>>>>>>        Move SQLConnection.sSchema to sSchema
91826>>>>>>>        If (sSchema = "") Begin
91828>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91829>>>>>>>        End
91829>>>>>>>>
91829>>>>>>>
91829>>>>>>>        // We need to remove the ".int" part of the table name because
91829>>>>>>>        // the table name after the "#" in the connection syntax below wants the
91829>>>>>>>        // "bare" table name without any extension.
91829>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91831>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
91833>>>>>>>                Get ParseFileExtension sTableName to sExt
91834>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91835>>>>>>>            End
91835>>>>>>>>
91835>>>>>>>            Else Begin
91836>>>>>>>                Move sTableName to sTableNameShort
91837>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
91838>>>>>>>            End
91838>>>>>>>>
91838>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91839>>>>>>>            Move sConnection to sTableName
91840>>>>>>>        End
91840>>>>>>>>
91840>>>>>>>
91840>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91841>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91842>>>>>>>        If (hTable = 0) Begin
91844>>>>>>>            Get NextFreeFilelistSlot to hTable
91845>>>>>>>        End
91845>>>>>>>>
91845>>>>>>>
91845>>>>>>>        Case Begin
91845>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91847>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91847>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91849>>>>>>>                    Close hTable
91850>>>>>>>                    Open sTableName as hTable
91852>>>>>>>                End
91852>>>>>>>>
91852>>>>>>>                Else Begin
91853>>>>>>>                    Get OpenTableExclusive hTable to bOK
91854>>>>>>>                    If (bOK = False) Begin
91856>>>>>>>                        Function_Return False
91857>>>>>>>                    End
91857>>>>>>>>
91857>>>>>>>                End
91857>>>>>>>>
91857>>>>>>>                Case Break
91858>>>>>>>
91858>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91861>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91861>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91863>>>>>>>                    Close hTable
91864>>>>>>>                    Open sTableName as hTable
91866>>>>>>>                End
91866>>>>>>>>
91866>>>>>>>                Else Begin
91867>>>>>>>                    Get OpenTableExclusive hTable to bOK
91868>>>>>>>                    If (bOK = False) Begin
91870>>>>>>>                        Function_Return False
91871>>>>>>>                    End
91871>>>>>>>>
91871>>>>>>>                End
91871>>>>>>>>
91871>>>>>>>                Case Break
91872>>>>>>>
91872>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91875>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91875>>>>>>>                If (iMode = DF_SHARE) Begin
91877>>>>>>>                    Close hTable
91878>>>>>>>                    Open sTableName as hTable
91880>>>>>>>                End
91880>>>>>>>>
91880>>>>>>>                Else Begin
91881>>>>>>>                    Get OpenTableExclusive hTable to bOK
91882>>>>>>>                    If (bOK = False) Begin
91884>>>>>>>                        Function_Return False
91885>>>>>>>                    End
91885>>>>>>>>
91885>>>>>>>                End
91885>>>>>>>>
91885>>>>>>>                Case Break
91886>>>>>>>
91886>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91889>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91891>>>>>>>                    Close hTable
91892>>>>>>>                    Open sTableName as hTable
91894>>>>>>>                End
91894>>>>>>>>
91894>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91897>>>>>>>                    Get OpenTableExclusive hTable to bOK
91898>>>>>>>                    If (bOK = False) Begin
91900>>>>>>>                        Function_Return False
91901>>>>>>>                    End
91901>>>>>>>>
91901>>>>>>>                End
91901>>>>>>>>
91901>>>>>>>                Else Begin
91902>>>>>>>                    Open hTable
91904>>>>>>>                End
91904>>>>>>>>
91904>>>>>>>                Case Break
91905>>>>>>>
91905>>>>>>>            Case Else
91905>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91906>>>>>>>>
91906>>>>>>>        Case End
91906>>>>>>>
91906>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91907>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91908>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91910>>>>>>>            Move False to Found
91911>>>>>>>        End
91911>>>>>>>>
91911>>>>>>>        // If open failed, the Err is set to true,
91911>>>>>>>        // but we don't want that because it could end our loop.
91911>>>>>>>        Move False to Err
91912>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91915>>>>>>>
91915>>>>>>>        Function_Return bOpen
91916>>>>>>>    End_Function
91917>>>>>>>
91917>>>>>>>    // Pass a table's logical name
91917>>>>>>>    // Returns True if the table exists in filelist.cfg.
91917>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91919>>>>>>>        Handle hTable
91919>>>>>>>        Boolean bFound
91919>>>>>>>        String sCompareTable
91919>>>>>>>
91919>>>>>>>        Move False to bFound
91920>>>>>>>        Move 0 to hTable
91921>>>>>>>        Repeat
91921>>>>>>>>
91921>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91924>>>>>>>            If (hTable > 0) Begin
91926>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91929>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91931>>>>>>>                    Move True to bFound
91932>>>>>>>                End
91932>>>>>>>>
91932>>>>>>>            End
91932>>>>>>>>
91932>>>>>>>            If (bFound = True) ;                Break
91935>>>>>>>        Until (hTable = 0)
91937>>>>>>>
91937>>>>>>>        Function_Return (bFound = True)
91938>>>>>>>    End_Function
91939>>>>>>>
91939>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91939>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91941>>>>>>>        Boolean bOK bExists
91941>>>>>>>        String sDriverID
91941>>>>>>>
91941>>>>>>>        Get _UtilTableExists hTable to bExists
91942>>>>>>>        If (bExists = False) Begin
91944>>>>>>>            Function_Return DATAFLEX_ID
91945>>>>>>>        End
91945>>>>>>>>
91945>>>>>>>        Get OpenTableExclusive hTable to bOK
91946>>>>>>>        If (bOK = False) Begin
91948>>>>>>>            Function_Return DATAFLEX_ID
91949>>>>>>>        End
91949>>>>>>>>
91949>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91952>>>>>>>        Function_Return sDriverID
91953>>>>>>>    End_Function
91954>>>>>>>
91954>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
91954>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
91956>>>>>>>        Handle hTable
91956>>>>>>>        Integer iRetval
91956>>>>>>>
91956>>>>>>>        Move 0 to hTable
91957>>>>>>>        Move 0 to iRetval
91958>>>>>>>
91958>>>>>>>        Repeat
91958>>>>>>>>
91958>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91961>>>>>>>            If (hTable > 0) Begin
91963>>>>>>>                Increment iRetval
91964>>>>>>>            End
91964>>>>>>>>
91964>>>>>>>        Until (hTable = 0)
91966>>>>>>>
91966>>>>>>>        Function_Return iRetval
91967>>>>>>>    End_Function
91968>>>>>>>
91968>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91968>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91970>>>>>>>        Handle hTable
91970>>>>>>>        String sRoot sDriverID
91970>>>>>>>        Boolean bIsSQLTable
91970>>>>>>>        Integer iPos
91970>>>>>>>
91970>>>>>>>        Move 0 to hTable
91971>>>>>>>        Move "" to sDriverID
91972>>>>>>>        Move False to bIsSQLTable
91973>>>>>>>
91973>>>>>>>        Repeat
91973>>>>>>>>
91973>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91976>>>>>>>            If (hTable > 0) Begin
91978>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91981>>>>>>>                If (sRoot contains ":") Begin
91983>>>>>>>                    Move (Pos(":", sRoot)) to iPos
91984>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91985>>>>>>>                End
91985>>>>>>>>
91985>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91986>>>>>>>            End
91986>>>>>>>>
91986>>>>>>>
91986>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
91988>>>>>>>
91988>>>>>>>        Function_Return sDriverID
91989>>>>>>>    End_Function
91990>>>>>>>
91990>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91992>>>>>>>        String sRootName
91992>>>>>>>        Boolean bIsSQL
91992>>>>>>>        Handle hTable
91992>>>>>>>
91992>>>>>>>        Move False to bIsSQL
91993>>>>>>>        Move 0 to hTable
91994>>>>>>>        Repeat
91994>>>>>>>>
91994>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91997>>>>>>>            If (hTable > 0) Begin
91999>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92002>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92003>>>>>>>                If (bIsSQL = True) Begin
92005>>>>>>>                    Move 0 to hTable
92006>>>>>>>                End
92006>>>>>>>>
92006>>>>>>>            End
92006>>>>>>>>
92006>>>>>>>        Until (hTable = 0)
92008>>>>>>>
92008>>>>>>>        Function_Return (bIsSQL = False)
92009>>>>>>>    End_Function
92010>>>>>>>
92010>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92010>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92012>>>>>>>        Function_Return False
92013>>>>>>>    End_Function
92014>>>>>>>
92014>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92016>>>>>>>        String  sRetval
92016>>>>>>>        String[] sOverlapFieldsArray
92017>>>>>>>        Integer iType iColumn iColumns
92017>>>>>>>        Boolean bOpen bOverlap
92017>>>>>>>
92017>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92020>>>>>>>        If (bOpen = False) Begin
92022>>>>>>>            Open hTable
92024>>>>>>>        End
92024>>>>>>>>
92024>>>>>>>
92024>>>>>>>        Move "" to sRetval
92025>>>>>>>
92025>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92028>>>>>>>
92028>>>>>>>        for iColumn from 0 to iColumns
92034>>>>>>>>
92034>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92037>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92039>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92042>>>>>>>                If (bOverlap) Begin
92044>>>>>>>                    If (sRetval <> "") Begin
92046>>>>>>>                        Append sRetval ","
92047>>>>>>>                    End
92047>>>>>>>>
92047>>>>>>>                    Append sRetval iColumn
92048>>>>>>>                End
92048>>>>>>>>
92048>>>>>>>            End
92048>>>>>>>>
92048>>>>>>>        Loop
92049>>>>>>>>
92049>>>>>>>
92049>>>>>>>        If (bOpen = False) Begin
92051>>>>>>>            Close hTable
92052>>>>>>>        End
92052>>>>>>>>
92052>>>>>>>
92052>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92053>>>>>>>
92053>>>>>>>        Function_Return sOverlapFieldsArray
92054>>>>>>>    End_Function
92055>>>>>>>
92055>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92057>>>>>>>        Handle hoRegistry hoODBCDriverNames
92057>>>>>>>        Boolean bExists bKeyOpened
92057>>>>>>>        String sKey
92057>>>>>>>        String[] sDrivers
92058>>>>>>>        Integer iDriverNames iDriverName
92058>>>>>>>
92058>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92059>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92060>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92061>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92062>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92063>>>>>>>        If (bExists) Begin
92065>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92066>>>>>>>            If (bKeyOpened) Begin
92068>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92069>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92070>>>>>>>                If (iDriverNames > 0) Begin
92072>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92073>>>>>>>                    Decrement iDriverNames
92074>>>>>>>                    for iDriverName from 0 to iDriverNames
92080>>>>>>>>
92080>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92081>>>>>>>                    Loop
92082>>>>>>>>
92082>>>>>>>                End
92082>>>>>>>>
92082>>>>>>>                Send CloseKey of hoRegistry
92083>>>>>>>            End
92083>>>>>>>>
92083>>>>>>>        End
92083>>>>>>>>
92083>>>>>>>        Send Destroy of hoRegistry
92084>>>>>>>
92084>>>>>>>        Function_Return sDrivers
92085>>>>>>>    End_Function
92086>>>>>>>
92086>>>>>>>    Procedure IncreaseSortBufferSize
92088>>>>>>>        String sNull
92088>>>>>>>        Integer iSortBufferSize
92088>>>>>>>        Boolean bBufferSet
92088>>>>>>>
92088>>>>>>>        Move "" to sNull
92089>>>>>>>        Move (1024 * 128) to iSortBufferSize
92090>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92095>>>>>>>
92095>>>>>>>    End_Procedure
92096>>>>>>>
92096>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92098>>>>>>>        Integer iLastIndex iIndex iNumSegments
92098>>>>>>>        Boolean bOK
92098>>>>>>>        String sDriverID
92098>>>>>>>
92098>>>>>>>        If (hTable > 0) Begin
92100>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92101>>>>>>>            Close hTable
92102>>>>>>>            Get OpenTableExclusive hTable to bOK
92103>>>>>>>            If (bOK = False) Begin
92105>>>>>>>                Procedure_Return
92106>>>>>>>            End
92106>>>>>>>>
92106>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92109>>>>>>>            Structure_Start hTable sDriverID
92110>>>>>>>                for iIndex from 1 to iLastIndex
92116>>>>>>>>
92116>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92119>>>>>>>                    If (iNumSegments > 0) Begin
92121>>>>>>>                        If (bSetToBatch = True) Begin
92123>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92126>>>>>>>                        End
92126>>>>>>>>
92126>>>>>>>                        Else Begin
92127>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92130>>>>>>>                        End
92130>>>>>>>>
92130>>>>>>>                    End
92130>>>>>>>>
92130>>>>>>>                Loop
92131>>>>>>>>
92131>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92133>>>>>>>        End
92133>>>>>>>>
92133>>>>>>>    End_Procedure
92134>>>>>>>
92134>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92136>>>>>>>        Handle hTable
92136>>>>>>>
92136>>>>>>>        Move 0 to hTable
92137>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92140>>>>>>>
92140>>>>>>>        Function_Return hTable
92141>>>>>>>    End_Function
92142>>>>>>>
92142>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92142>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92144>>>>>>>        Integer iCh
92144>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92145>>>>>>>            Write channel iCh sStmt
92147>>>>>>>        Send Seq_Close_Channel iCh
92148>>>>>>>    End_Procedure
92149>>>>>>>
92149>>>>>>>    // Returns the integer number for the passed Driver ID that is
92149>>>>>>>    // needed by some database API calls.
92149>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92151>>>>>>>        String  sCurrentDriver
92151>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92151>>>>>>>
92151>>>>>>>        Move 0 to iDriver
92152>>>>>>>
92152>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92155>>>>>>>        for iCount from 1 to iNumberOfDrivers
92161>>>>>>>>
92161>>>>>>>
92161>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92164>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92166>>>>>>>                Move iCount to iDriver
92167>>>>>>>            End
92167>>>>>>>>
92167>>>>>>>        Loop
92168>>>>>>>>
92168>>>>>>>
92168>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92168>>>>>>>        If (iDriver = 0) Begin
92170>>>>>>>            Move False to Err
92171>>>>>>>            Load_Driver sDriverID
92172>>>>>>>            If (Err = False) Begin
92174>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92177>>>>>>>            End
92177>>>>>>>>
92177>>>>>>>        End
92177>>>>>>>>
92177>>>>>>>
92177>>>>>>>        Function_Return iDriver
92178>>>>>>>    End_Function
92179>>>>>>>
92179>>>>>>>
92179>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92181>>>>>>>        String  sSqlServerClientVersionName
92181>>>>>>>        
92181>>>>>>>        Case Begin
92181>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92183>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92184>>>>>>>                Case Break
92185>>>>>>>
92185>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92188>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92189>>>>>>>                Case Break
92190>>>>>>>                
92190>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92193>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92194>>>>>>>                Case Break
92195>>>>>>>            
92195>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92198>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92199>>>>>>>                Case Break
92200>>>>>>>            
92200>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92203>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92204>>>>>>>                Case Break
92205>>>>>>>            
92205>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92208>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92209>>>>>>>                Case Break
92210>>>>>>>            
92210>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92213>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92214>>>>>>>                Case Break
92215>>>>>>>            
92215>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92218>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92219>>>>>>>                Case Break
92220>>>>>>>            
92220>>>>>>>            Case Else
92220>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92221>>>>>>>        Case End
92221>>>>>>>        
92221>>>>>>>        Function_Return sSqlServerClientVersionName
92222>>>>>>>    End_Function
92223>>>>>>>
92223>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92225>>>>>>>        String  sSqlServerClientDriverName
92225>>>>>>>        
92225>>>>>>>        Case Begin
92225>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92227>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92228>>>>>>>                Case Break
92229>>>>>>>
92229>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92232>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92233>>>>>>>                Case Break
92234>>>>>>>                
92234>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92237>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92238>>>>>>>                Case Break
92239>>>>>>>            
92239>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92242>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92243>>>>>>>                Case Break
92244>>>>>>>            
92244>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92247>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92248>>>>>>>                Case Break
92249>>>>>>>            
92249>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92252>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92253>>>>>>>                Case Break
92254>>>>>>>            
92254>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92257>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92258>>>>>>>                Case Break
92259>>>>>>>            
92259>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92262>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92263>>>>>>>                Case Break
92264>>>>>>>            
92264>>>>>>>            Case Else
92264>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92265>>>>>>>        Case End
92265>>>>>>>        
92265>>>>>>>        Function_Return sSqlServerClientDriverName
92266>>>>>>>    End_Function
92267>>>>>>>    
92267>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92269>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92269>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92269>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92269>>>>>>>        Boolean bOK
92269>>>>>>>        
92269>>>>>>>        Move "" to sRetval
92270>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92271>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92272>>>>>>>        Load_Driver MSSQLDRV_ID
92273>>>>>>>
92273>>>>>>>        // Loop through all loaded drivers.
92273>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92276>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92282>>>>>>>>
92282>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92285>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92287>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92288>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92291>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92292>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92293>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92294>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92295>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92297>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92298>>>>>>>                End                                
92298>>>>>>>>
92298>>>>>>>                Else Begin
92299>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92300>>>>>>>                End
92300>>>>>>>>
92300>>>>>>>            End
92300>>>>>>>>
92300>>>>>>>        Loop
92301>>>>>>>>
92301>>>>>>>        Send Destroy of hoCLIHandler  
92302>>>>>>>        Send Destroy of hoMSSQLHandler  
92303>>>>>>>        If (bShowErrorDialog = True) Begin
92305>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92306>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92308>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92309>>>>>>>                If (bExitProgram = True) Begin
92311>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92312>>>>>>>                End
92312>>>>>>>>
92312>>>>>>>                Send Stop_Box sRetval  
92313>>>>>>>                If (bExitProgram = True) Begin
92315>>>>>>>                    Send Exit_Application
92316>>>>>>>                End
92316>>>>>>>>
92316>>>>>>>            End
92316>>>>>>>>
92316>>>>>>>        End
92316>>>>>>>>
92316>>>>>>>        
92316>>>>>>>        Function_Return sRetval
92317>>>>>>>    End_Function  
92318>>>>>>>    
92318>>>>>>>    // Returns True if first "." separated string is greater than the second.
92318>>>>>>>    // It checks from left to right, one part of the string at a time.
92318>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92318>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92320>>>>>>>        String[] asVersion asSQLVersion          
92322>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92322>>>>>>>        
92322>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92323>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92324>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92325>>>>>>>        // Make sure the two arrays are of the same size:
92325>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92327>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92328>>>>>>>        End
92328>>>>>>>>
92328>>>>>>>        Decrement iSize
92329>>>>>>>        for iCount from 0 to iSize
92335>>>>>>>>
92335>>>>>>>            Move asVersion[iCount]    to iVersion
92336>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92337>>>>>>>            CompilerWarnings Off
92337>>>>>>>            If (iVersion > iSQLVersion) Break
92340>>>>>>>            CompilerWarnings On
92340>>>>>>>        Loop
92341>>>>>>>>
92341>>>>>>>        
92341>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92342>>>>>>>    End_Function
92343>>>>>>>
92343>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92343>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92343>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92343>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92345>>>>>>>        Integer iMode iErrorObject
92345>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92345>>>>>>>        String sTableName 
92345>>>>>>>        Handle hoCurrentErrorHandler
92345>>>>>>>        
92345>>>>>>>        Move False to bExitIfDebuggerActive
92346>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92348>>>>>>>        Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92349>>>>>>>        End
92349>>>>>>>>
92349>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92350>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92350>>>>>>>        // so we generate an error here:
92350>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92352>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92353>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92354>>>>>>>            If (iErrorObject <> 0) Begin
92356>>>>>>>                Move iErrorObject to Error_Object_Id
92357>>>>>>>            End
92357>>>>>>>>
92357>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92358>>>>>>>>
92358>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92359>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92360>>>>>>>            Function_Return False
92361>>>>>>>        End
92361>>>>>>>>
92361>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92364>>>>>>>        If (bOpened) Begin
92366>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92369>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92371>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92372>>>>>>>                Function_Return True
92373>>>>>>>            End
92373>>>>>>>>
92373>>>>>>>            Close hTable
92374>>>>>>>        End
92374>>>>>>>>
92374>>>>>>>        Else Begin
92375>>>>>>>            Open hTable
92377>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92380>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92382>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92385>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92387>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92388>>>>>>>                    Function_Return True
92389>>>>>>>                End
92389>>>>>>>>
92389>>>>>>>            End
92389>>>>>>>>
92389>>>>>>>
92389>>>>>>>        End
92389>>>>>>>>
92389>>>>>>>
92389>>>>>>>        Close hTable
92390>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92392>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92395>>>>>>>
92395>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92396>>>>>>>        Function_Return bOpened
92397>>>>>>>    End_Function
92398>>>>>>>
92398>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92400>>>>>>>        String sConnectionID sConnectionString sDriverID
92400>>>>>>>        Boolean bExists bOK bSQLDriver
92400>>>>>>>        Handle hoCLI hoDriver
92400>>>>>>>        Integer iRetval
92400>>>>>>>        tSQLConnection SQLConnection
92400>>>>>>>        tSQLConnection SQLConnection
92400>>>>>>>
92400>>>>>>>        Get psDriverID to sDriverID
92401>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92402>>>>>>>        If (bSQLDriver = False) Begin
92404>>>>>>>            Function_Return True
92405>>>>>>>        End
92405>>>>>>>>
92405>>>>>>>
92405>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92406>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92407>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92408>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92409>>>>>>>
92409>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92410>>>>>>>        If (bExists = False) Begin
92412>>>>>>>            // We always start by deleting the current connection - if any - because the
92412>>>>>>>            // login details my have changed.
92412>>>>>>>            Get phoCLIHandler to hoCLI
92413>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92414>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92415>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92416>>>>>>>            If (bOk = False) Begin
92418>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92419>>>>>>>>
92419>>>>>>>                Function_Return False
92420>>>>>>>            End
92420>>>>>>>>
92420>>>>>>>            Move bOK to bExists
92421>>>>>>>        End
92421>>>>>>>>
92421>>>>>>>
92421>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92422>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92423>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92424>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92425>>>>>>>        Send Destroy of hoDriver
92426>>>>>>>
92426>>>>>>>        Function_Return (bExists = True)
92427>>>>>>>    End_Function
92428>>>>>>>
92428>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92428>>>>>>>    // Returns: False if nobody else is running
92428>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92428>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92428>>>>>>>    //      tables are not locked as DataFlex tables are.
92428>>>>>>>    Function IsDatabaseInUse Returns Boolean
92430>>>>>>>        Handle  hTable
92430>>>>>>>        String  sRootName
92430>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92430>>>>>>>        Integer iCount iTables
92430>>>>>>>
92430>>>>>>>        Move 0 to iTables
92431>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92432>>>>>>>        Get AutoConnectionIDLogin to bOK
92433>>>>>>>        Get UtilFilelistNoOfTables to iTables
92434>>>>>>>        Set piPosition   of ghoProgressBar to 0
92435>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92436>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92437>>>>>>>        Close DF_ALL
92438>>>>>>>        Move 0 to hTable
92439>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92442>>>>>>>        Move False to bErr
92443>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92444>>>>>>>
92444>>>>>>>        Repeat
92444>>>>>>>>
92444>>>>>>>            Set piPosition of ghoProgressBar to iCount
92445>>>>>>>            Increment iCount
92446>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92449>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92450>>>>>>>
92450>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92450>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92451>>>>>>>            Move False to bOpen
92452>>>>>>>            Get _UtilTableExists hTable to bExists
92453>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92453>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92455>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92456>>>>>>>                Open hTable
92458>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92461>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92462>>>>>>>                If (bOpen = True) Begin
92464>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92464>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92465>>>>>>>                    If (bAlias = False) Begin
92467>>>>>>>                        Close hTable
92468>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92469>>>>>>>                        If (bOpen = False) Begin
92471>>>>>>>                            Move True to bErr
92472>>>>>>>                        End
92472>>>>>>>>
92472>>>>>>>                    End
92472>>>>>>>>
92472>>>>>>>                End
92472>>>>>>>>
92472>>>>>>>                Close hTable
92473>>>>>>>            End
92473>>>>>>>>
92473>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92476>>>>>>>            If (bErr = True ) ;                Break
92479>>>>>>>        Until (not(hTable))
92481>>>>>>>
92481>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92482>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92483>>>>>>>        Move False to Err
92484>>>>>>>
92484>>>>>>>        Function_Return bErr
92485>>>>>>>    End_Function
92486>>>>>>>
92486>>>>>>>End_Class
92487>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92487>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92487>>>>>>>//
92487>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92487>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92487>>>>>>>// conjunction with constraint-clauses.
92487>>>>>>>//
92487>>>>>>>// SYNTAX:
92487>>>>>>>//
92487>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92487>>>>>>>//    <Constraints...>
92487>>>>>>>//    {DO}
92487>>>>>>>//      <loop body>
92487>>>>>>>//  End_For_All
92487>>>>>>>//
92487>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92487>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92487>>>>>>>//
92487>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92487>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92487>>>>>>>//   End_For_All
92487>>>>>>>//
92487>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92487>>>>>>>//
92487>>>>>>>//   For_All Customer BY Index.1
92487>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92487>>>>>>>//     DO
92487>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92487>>>>>>>//   End_For_All
92487>>>>>>>//
92487>>>>>>>// Constraint clauses are:
92487>>>>>>>//
92487>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92487>>>>>>>//   CONSTRAIN <File> AS <Expression>
92487>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92487>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92487>>>>>>>//
92487>>>>>>>// For example, to list all customers with a bad status whose names start
92487>>>>>>>// with "A" and which have not made a payment in thirty days:
92487>>>>>>>//
92487>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92487>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92487>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92487>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92487>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92487>>>>>>>//      DO
92487>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92487>>>>>>>//    End_For_All
92487>>>>>>>//
92487>>>>>>>
92487>>>>>>>
92487>>>>>>>//This command starts the loop process body when constraints are used;
92487>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92487>>>>>>>//command line, and not on a line by itself
92487>>>>>>>//
92487>>>>>>>
92487>>>>>>>//Ends a For_All loop
92487>>>>>>>//
92487>>>>>>>
92487>>>>>>>
92487>>>>>
92487>>>>>
92487>>>>>Class cDbUpdateVersion is a cObject
92488>>>>>
92488>>>>>    Procedure Construct_Object    
92490>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92490>>>>>        String[] aSQLQueryMessages
92491>>>>>        
92491>>>>>        Forward Send Construct_Object
92493>>>>>
92493>>>>>        // cDbUpdateHandler object event.
92493>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92495>>>>>        If (bOnCreateExecuted = False) Begin    
92497>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92499>>>>>            If (bUseCustomDbVersion = False) Begin
92501>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92503>>>>>            End
92503>>>>>>
92503>>>>>            Delegate Send OnCreate
92505>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92507>>>>>        End
92507>>>>>>
92507>>>>>
92507>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92507>>>>>        // event was triggered, thus an actual change of the database was made.
92507>>>>>        Property Boolean pbVersionUpdate False
92508>>>>>
92508>>>>>        // This property must be manually set within each cDbUpdateVersion object
92508>>>>>        // by the programmer, to a consecutive number.
92508>>>>>        Property Number pnVersionNumber
92509>>>>>
92509>>>>>        Property Boolean pbUseConnectionID True
92510>>>>>        Property Boolean private.pbToANSI   True
92511>>>>>        Property Boolean private.pbRecnum   True
92512>>>>>        Property Boolean private.pbCopyData True
92513>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92514>>>>>        Property Boolean private.pbCompareDate_DateTime False
92515>>>>>        Property Boolean private.pbCompareIndexAscending False
92516>>>>>        Property Boolean private.pbCompareIndexUppercase False
92517>>>>>        Property String private.psSchema
92518>>>>>        Property String private.psBaseTableSpace
92519>>>>>        Property String private.psLongTableSpace
92520>>>>>        Property String private.psIndexTableSpace
92521>>>>>
92521>>>>>        // Driver default value settings:
92521>>>>>        Property String private.psDriverDefaultValueASCII    ""
92522>>>>>        Property String private.psDriverDefaultValueBinary   ""
92523>>>>>        Property String private.psDriverDefaultValueDate     ""
92524>>>>>        Property String private.psDriverDefaultValueDateTime ""
92525>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92526>>>>>        Property String private.psDriverDefaultValueText     ""
92527>>>>>
92527>>>>>        // Driver "nullability" settings:
92527>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92528>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92529>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92530>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92531>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92532>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92533>>>>>
92533>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92533>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92533>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92533>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92533>>>>>        // We reset it here for each cDbUpdateVersion object
92533>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92535>>>>>    End_Procedure
92536>>>>>
92536>>>>>    // *** Main hook event message ***
92536>>>>>    // Place your database update logic here!
92536>>>>>    Procedure OnUpdate
92538>>>>>    End_Procedure
92539>>>>>
92539>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92539>>>>>    // imported to the cDbUpdateHandler container class which should be a
92539>>>>>    // parent object to this object. To have the Studio's Property Panel
92539>>>>>    // "behave" aka show these properties we need to duplicate them in this
92539>>>>>    // class and "relay" them to the parent object.
92539>>>>>    Procedure Set pbToANSI Boolean bState
92541>>>>>        Set private.pbToANSI  to bState
92542>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92543>>>>>        Delegate Set pbToANSI to bState
92545>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92546>>>>>    End_Procedure
92547>>>>>
92547>>>>>    Function pbToANSI Returns Boolean
92549>>>>>        Function_Return (private.pbToAnsi(Self))
92550>>>>>    End_Function
92551>>>>>
92551>>>>>    Procedure Set pbRecnum Boolean bState
92553>>>>>        Set private.pbRecnum  to bState
92554>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92555>>>>>        Delegate Set pbRecnum to bState
92557>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92558>>>>>    End_Procedure
92559>>>>>
92559>>>>>    Function pbRecnum Returns Boolean
92561>>>>>        Function_Return (private.pbRecnum(Self))
92562>>>>>    End_Function
92563>>>>>
92563>>>>>    Procedure Set pbCopyData Boolean bState
92565>>>>>        Set private.pbCopyData  to bState
92566>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92567>>>>>        Delegate Set pbCopyData to bState
92569>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92570>>>>>    End_Procedure
92571>>>>>
92571>>>>>    Function pbCopyData Returns Boolean
92573>>>>>        Function_Return (private.pbCopyData(Self))
92574>>>>>    End_Function
92575>>>>>
92575>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92575>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92577>>>>>        Set private.pbApiTableUpdateAuto  to bState
92578>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92579>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92580>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92581>>>>>    End_Procedure
92582>>>>>
92582>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92584>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92585>>>>>    End_Function
92586>>>>>
92586>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92588>>>>>        Set private.pbCompareDate_DateTime  to bState
92589>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92590>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92591>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92592>>>>>    End_Procedure
92593>>>>>
92593>>>>>    Function pbCompareDate_DateTime Returns Boolean
92595>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92596>>>>>    End_Function
92597>>>>>
92597>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92599>>>>>        Set private.pbCompareIndexAscending  to bState
92600>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92601>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92602>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92603>>>>>    End_Procedure
92604>>>>>
92604>>>>>    Function pbCompareIndexAscending Returns Boolean
92606>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92607>>>>>    End_Function
92608>>>>>
92608>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92610>>>>>        Set private.pbCompareIndexUppercase  to bState
92611>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92612>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92613>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92614>>>>>    End_Procedure
92615>>>>>
92615>>>>>    Function pbCompareIndexUppercase Returns Boolean
92617>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92618>>>>>    End_Function
92619>>>>>
92619>>>>>    Procedure Set psSchema String sValue
92621>>>>>        Set private.psSchema  to sValue
92622>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92623>>>>>        Delegate Set psSchema to sValue
92625>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92626>>>>>    End_Procedure
92627>>>>>
92627>>>>>    // First retrieve the private value that might have been set in the object.
92627>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92627>>>>>    // it might have been specified in the SQLConnections.ini file.
92627>>>>>    Function psSchema Returns String
92629>>>>>        String sValue
92629>>>>>        Get private.psSchema to sValue
92630>>>>>        If (sValue = "") Begin
92632>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92633>>>>>        End
92633>>>>>>
92633>>>>>        Function_Return sValue
92634>>>>>    End_Function
92635>>>>>
92635>>>>>    Procedure Set psBaseTableSpace String sValue
92637>>>>>        Set private.psBaseTableSpace  to sValue
92638>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92639>>>>>        Delegate Set psBaseTableSpace to sValue
92641>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92642>>>>>    End_Procedure
92643>>>>>
92643>>>>>    // First retrieve the private value that might have been set in the object.
92643>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92643>>>>>    // it might have been specified in the SQLConnections.ini file.
92643>>>>>    Function psBaseTableSpace Returns String
92645>>>>>        String sValue
92645>>>>>        Get private.psBaseTableSpace to sValue
92646>>>>>        If (sValue = "") Begin
92648>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92649>>>>>        End
92649>>>>>>
92649>>>>>        Function_Return sValue
92650>>>>>    End_Function
92651>>>>>
92651>>>>>    Procedure Set psLongTableSpace String sValue
92653>>>>>        Set private.psLongTableSpace  to sValue
92654>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92655>>>>>        Delegate Set psLongTableSpace to sValue
92657>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92658>>>>>    End_Procedure
92659>>>>>
92659>>>>>    // First retrieve the private value that might have been set in the object.
92659>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92659>>>>>    // it might have been specified in the SQLConnections.ini file.
92659>>>>>    Function psLongTableSpace Returns String
92661>>>>>        String sValue
92661>>>>>        Get private.psLongTableSpace to sValue
92662>>>>>        If (sValue = "") Begin
92664>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
92665>>>>>        End
92665>>>>>>
92665>>>>>        Function_Return sValue
92666>>>>>    End_Function
92667>>>>>
92667>>>>>    Procedure Set psIndexTableSpace String sValue
92669>>>>>        Set private.psIndexTableSpace  to sValue
92670>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92671>>>>>        Delegate Set psIndexTableSpace to sValue
92673>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92674>>>>>    End_Procedure
92675>>>>>
92675>>>>>    // First retrieve the private value that might have been set in the object.
92675>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92675>>>>>    // it might have been specified in the SQLConnections.ini file.
92675>>>>>    Function psIndexTableSpace Returns String
92677>>>>>        String sValue
92677>>>>>        Get private.psIndexTableSpace to sValue
92678>>>>>        If (sValue = "") Begin
92680>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
92681>>>>>        End
92681>>>>>>
92681>>>>>        Function_Return sValue
92682>>>>>    End_Function
92683>>>>>
92683>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92685>>>>>        Set private.psDriverDefaultValueASCII  to sValue
92686>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92687>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
92689>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92690>>>>>    End_Procedure
92691>>>>>
92691>>>>>    // First retrieve the private value that might have been set in the object.
92691>>>>>    // If blank; get it from the parent object
92691>>>>>    Function psDriverDefaultValueASCII Returns String
92693>>>>>        String sValue
92693>>>>>        Get private.psDriverDefaultValueASCII to sValue
92694>>>>>        If (sValue = "") Begin
92696>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
92698>>>>>        End
92698>>>>>>
92698>>>>>        Function_Return sValue
92699>>>>>    End_Function
92700>>>>>
92700>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92702>>>>>        Set private.psDriverDefaultValueBinary  to sValue
92703>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92704>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
92706>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92707>>>>>    End_Procedure
92708>>>>>
92708>>>>>    // First retrieve the private value that might have been set in the object.
92708>>>>>    // If blank; get it from the parent object
92708>>>>>    Function psDriverDefaultValueBinary Returns String
92710>>>>>        String sValue
92710>>>>>        Get private.psDriverDefaultValueBinary to sValue
92711>>>>>        If (sValue = "") Begin
92713>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
92715>>>>>        End
92715>>>>>>
92715>>>>>        Function_Return sValue
92716>>>>>    End_Function
92717>>>>>
92717>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92719>>>>>        Set private.psDriverDefaultValueDate  to sValue
92720>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92721>>>>>        Delegate Set psDriverDefaultValueDate to sValue
92723>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92724>>>>>    End_Procedure
92725>>>>>
92725>>>>>    // First retrieve the private value that might have been set in the object.
92725>>>>>    // If blank; get it from the parent object
92725>>>>>    Function psDriverDefaultValueDate Returns String
92727>>>>>        String sValue
92727>>>>>        Get private.psDriverDefaultValueDate to sValue
92728>>>>>        If (sValue = "") Begin
92730>>>>>            Delegate Get psDriverDefaultValueDate to sValue
92732>>>>>        End
92732>>>>>>
92732>>>>>        Function_Return sValue
92733>>>>>    End_Function
92734>>>>>
92734>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92736>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
92737>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92738>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
92740>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92741>>>>>    End_Procedure
92742>>>>>
92742>>>>>    // First retrieve the private value that might have been set in the object.
92742>>>>>    // If blank; get it from the parent object
92742>>>>>    Function psDriverDefaultValueDateTime Returns String
92744>>>>>        String sValue
92744>>>>>        Get private.psDriverDefaultValueDateTime to sValue
92745>>>>>        If (sValue = "") Begin
92747>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
92749>>>>>        End
92749>>>>>>
92749>>>>>        Function_Return sValue
92750>>>>>    End_Function
92751>>>>>
92751>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92753>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
92754>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92755>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
92757>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92758>>>>>    End_Procedure
92759>>>>>
92759>>>>>    // First retrieve the private value that might have been set in the object.
92759>>>>>    // If blank; get it from the parent object
92759>>>>>    Function psDriverDefaultValueNumeric Returns String
92761>>>>>        String sValue
92761>>>>>        Get private.psDriverDefaultValueNumeric to sValue
92762>>>>>        If (sValue = "") Begin
92764>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
92766>>>>>        End
92766>>>>>>
92766>>>>>        Function_Return sValue
92767>>>>>    End_Function
92768>>>>>
92768>>>>>    Procedure Set psDriverDefaultValueText String sValue
92770>>>>>        Set private.psDriverDefaultValueText  to sValue
92771>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92772>>>>>        Delegate Set psDriverDefaultValueText to sValue
92774>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92775>>>>>    End_Procedure
92776>>>>>
92776>>>>>    // First retrieve the private value that might have been set in the object.
92776>>>>>    // If blank; get it from the parent object
92776>>>>>    Function psDriverDefaultValueText Returns String
92778>>>>>        String sValue
92778>>>>>        Get private.psDriverDefaultValueText to sValue
92779>>>>>        If (sValue = "") Begin
92781>>>>>            Delegate Get psDriverDefaultValueText to sValue
92783>>>>>        End
92783>>>>>>
92783>>>>>        Function_Return sValue
92784>>>>>    End_Function
92785>>>>>
92785>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92787>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
92788>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92789>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
92791>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92792>>>>>    End_Procedure
92793>>>>>
92793>>>>>    // First retrieve the private value that might have been set in the object.
92793>>>>>    // If blank; get it from the parent object
92793>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92795>>>>>        Boolean bState
92795>>>>>        Get private.pbDriverDefaultNullableASCII to bState
92796>>>>>        If (bState = False) Begin
92798>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
92800>>>>>        End
92800>>>>>>
92800>>>>>        Function_Return bState
92801>>>>>    End_Function
92802>>>>>
92802>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92804>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
92805>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92806>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
92808>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92809>>>>>    End_Procedure
92810>>>>>
92810>>>>>    // First retrieve the private value that might have been set in the object.
92810>>>>>    // If blank; get it from the parent object
92810>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92812>>>>>        Boolean bState
92812>>>>>        Get private.pbDriverDefaultNullableBinary to bState
92813>>>>>        If (bState = False) Begin
92815>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
92817>>>>>        End
92817>>>>>>
92817>>>>>        Function_Return bState
92818>>>>>    End_Function
92819>>>>>
92819>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92821>>>>>        Set private.pbDriverDefaultNullableDate  to bState
92822>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92823>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
92825>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92826>>>>>    End_Procedure
92827>>>>>
92827>>>>>    // First retrieve the private value that might have been set in the object.
92827>>>>>    // If blank; get it from the parent object
92827>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92829>>>>>        Boolean bState
92829>>>>>        Get private.pbDriverDefaultNullableDate to bState
92830>>>>>        If (bState = False) Begin
92832>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
92834>>>>>        End
92834>>>>>>
92834>>>>>        Function_Return bState
92835>>>>>    End_Function
92836>>>>>
92836>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92838>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
92839>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92840>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
92842>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92843>>>>>    End_Procedure
92844>>>>>
92844>>>>>    // First retrieve the private value that might have been set in the object.
92844>>>>>    // If blank; get it from the parent object
92844>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92846>>>>>        Boolean bState
92846>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
92847>>>>>        If (bState = False) Begin
92849>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
92851>>>>>        End
92851>>>>>>
92851>>>>>        Function_Return bState
92852>>>>>    End_Function
92853>>>>>
92853>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92855>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
92856>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92857>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
92859>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92860>>>>>    End_Procedure
92861>>>>>
92861>>>>>    // First retrieve the private value that might have been set in the object.
92861>>>>>    // If blank; get it from the parent object
92861>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92863>>>>>        Boolean bState
92863>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
92864>>>>>        If (bState = False) Begin
92866>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
92868>>>>>        End
92868>>>>>>
92868>>>>>        Function_Return bState
92869>>>>>    End_Function
92870>>>>>
92870>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92872>>>>>        Set private.pbDriverDefaultNullableText  to bState
92873>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92874>>>>>        Delegate Set pbDriverDefaultNullableText to bState
92876>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92877>>>>>    End_Procedure
92878>>>>>
92878>>>>>    // First retrieve the private value that might have been set in the object.
92878>>>>>    // If blank; get it from the parent object
92878>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92880>>>>>        Boolean bState
92880>>>>>        Get private.pbDriverDefaultNullableText to bState
92881>>>>>        If (bState = False) Begin
92883>>>>>            Delegate Get pbDriverDefaultNullableText to bState
92885>>>>>        End
92885>>>>>>
92885>>>>>        Function_Return bState
92886>>>>>    End_Function
92887>>>>>
92887>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
92889>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
92889>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
92889>>>>>
92889>>>>>        Get psDriverID to sDriverID
92890>>>>>        Get psSchema to sSchema
92891>>>>>
92891>>>>>        Get psBaseTableSpace to sBaseTableSpace
92892>>>>>        If (sBaseTableSpace <> "") Begin
92894>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92895>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
92897>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92898>>>>>        End
92898>>>>>>
92898>>>>>
92898>>>>>        Get psLongTableSpace to sLongTableSpace
92899>>>>>        If (sLongTableSpace <> "") Begin
92901>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92902>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
92904>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92905>>>>>        End
92905>>>>>>
92905>>>>>
92905>>>>>        Get psIndexTableSpace to sIndexTableSpace
92906>>>>>        If (sIndexTableSpace <> "") Begin
92908>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92909>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
92911>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92912>>>>>        End
92912>>>>>>
92912>>>>>
92912>>>>>        Get pbUseConnectionID to bUseConnectionID
92913>>>>>        Get pbToANSI          to bToANSI
92914>>>>>        Get pbRecnum          to bRecnum
92915>>>>>        Get pbCopyData        to bCopyData
92916>>>>>
92916>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
92917>>>>>
92917>>>>>        Function_Return bOK
92918>>>>>    End_Function
92919>>>>>
92919>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
92919>>>>>//        Boolean bOK bExists
92919>>>>>//        String sDataPath sBackupFolder
92919>>>>>//        
92919>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
92919>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
92919>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92919>>>>>//        Get vFolderFormat sDataPath to sDataPath
92919>>>>>//        
92919>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92919>>>>>//        If (bExists = False) Begin
92919>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92919>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92919>>>>>//            If (bExists = False) Begin
92919>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
92919>>>>>//                Function_Return False
92919>>>>>//            End                                                                                                                                            
92919>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
92919>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
92919>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
92919>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
92919>>>>>//        End
92919>>>>>//        
92919>>>>>//        Set Message_Text of ghoStatusPanel to ""
92919>>>>>//        Function_Return bOK
92919>>>>>//    End_Function
92919>>>>>//
92919>>>>>    // This is automatically called after the OnUpdate
92919>>>>>    // event has been executed. It will automatically update the
92919>>>>>    // version database field/column with the "pnVersionNumber"
92919>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
92919>>>>>    Procedure UpdateVersionColumnValue
92921>>>>>        Number nVersion nCurrentValue
92921>>>>>        Integer hTable iColumn
92921>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
92921>>>>>
92921>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
92921>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
92921>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92923>>>>>        Get pbVersionUpdate to bVersionUpdate
92924>>>>>
92924>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
92926>>>>>            Get pnVersionNumber to nVersion
92927>>>>>            Delegate Get piDbVersionFileNumber  to hTable
92929>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
92931>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
92931>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
92931>>>>>            Close DF_ALL DF_PERMANENT
92932>>>>>
92932>>>>>            Open hTable
92934>>>>>
92934>>>>>            // It is then the developer responsibility to take care of finding
92934>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
92934>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92936>>>>>            If (bUseCustomDbVersion = True) Begin
92938>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
92940>>>>>            End
92940>>>>>>
92940>>>>>
92940>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92943>>>>>            If (nCurrentValue < nVersion) Begin
92945>>>>>                Lock
92946>>>>>>
92946>>>>>                    If (bUseCustomDbVersion = False) Begin
92948>>>>>                        Vfind hTable Recnum GE                            
92950>>>>>                    End
92950>>>>>>
92950>>>>>                    Set_Field_Value hTable iColumn to nVersion
92953>>>>>                    SaveRecord hTable
92954>>>>>                Unlock
92955>>>>>>
92955>>>>>            End
92955>>>>>>
92955>>>>>            Close hTable
92956>>>>>        End
92956>>>>>>
92956>>>>>    End_Procedure
92957>>>>>
92957>>>>>// Property of the container object (cDbUpdateHandler)
92957>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
92957>>>>>
92957>>>>>    Procedure End_Construct_Object
92959>>>>>        Forward Send End_Construct_Object
92961>>>>>        Send ProcessUpdate True
92962>>>>>    End_Procedure
92963>>>>>    
92963>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
92965>>>>>        Number nVersion nCurrentValue
92965>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
92965>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
92965>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
92965>>>>>        String sObjectName
92965>>>>>        tDbVersionInfo[] dbVersionInfoArray
92965>>>>>        tDbVersionInfo[] dbVersionInfoArray
92966>>>>>
92966>>>>>        Move 0 to nCurrentValue
92967>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
92969>>>>>
92969>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
92971>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92973>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
92975>>>>>            If (iErrorObject <> 0) Begin
92977>>>>>                Move iErrorObject to Error_Object_Id
92978>>>>>            End
92978>>>>>>
92978>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92979>>>>>>
92979>>>>>            Send Exit_Application
92980>>>>>        End
92980>>>>>>
92980>>>>>        // If the programmer forgot to set the version number we do not allow for the application
92980>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
92980>>>>>        // one database update is depended on an earlier update and that earlier version
92980>>>>>        // update was never executed it could lead to disastrous results.
92980>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
92980>>>>>        Get pnVersionNumber to nVersion
92981>>>>>        If (nVersion < 0) Begin
92983>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
92984>>>>>            Move (Name(Self)) to sObjectName
92985>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
92986>>>>>>
92986>>>>>            Send Exit_Application
92987>>>>>        End
92987>>>>>>
92987>>>>>
92987>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
92987>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
92987>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
92989>>>>>        If (bOnPreUpdateExecuted = False) Begin
92991>>>>>            Delegate Send OnPreUpdate
92993>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
92995>>>>>        End
92995>>>>>>
92995>>>>>        
92995>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
92997>>>>>        
92997>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92999>>>>>        If (bUseCustomDbVersion = False) Begin
93001>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93001>>>>>        End
93001>>>>>>
93001>>>>>        Else Begin
93002>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93003>>>>>            If (bTableExists = False) Begin
93005>>>>>                Delegate Send OnCreateCustomDbVersionTable
93007>>>>>            End
93007>>>>>>
93007>>>>>        End
93007>>>>>>
93007>>>>>        
93007>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93007>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93007>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93009>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93011>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93012>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93013>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93014>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93016>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93018>>>>>        End
93018>>>>>>
93018>>>>>
93018>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93020>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93022>>>>>
93022>>>>>        Open hTable
93024>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93027>>>>>        If (bOpened = False) Begin
93029>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93030>>>>>            Send Exit_Application
93031>>>>>        End
93031>>>>>>
93031>>>>>        
93031>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93031>>>>>        // in case we take care of it here.
93031>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93034>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93036>>>>>            Vfind hTable 0 GT
93038>>>>>        End
93038>>>>>>
93038>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93041>>>>>        If (bSystemTable = True) Begin
93043>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93046>>>>>        End
93046>>>>>>
93046>>>>>        Else Begin
93047>>>>>            If (bUseCustomDbVersion = True) Begin
93049>>>>>                Send OnFindVersionRecord
93050>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93053>>>>>            End
93053>>>>>>
93053>>>>>        End
93053>>>>>>
93053>>>>>
93053>>>>>        Close hTable
93054>>>>>
93054>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93054>>>>>        // If not set we do nothing.
93054>>>>>        If (nCurrentValue < nVersion) Begin
93056>>>>>
93056>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93056>>>>>            // execution of database update code. So if true _and_ one error
93056>>>>>            // has already occured; we're out of here.
93056>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93058>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93060>>>>>            If (bStopOnFirstError = True) Begin
93062>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93064>>>>>                    Procedure_Return
93065>>>>>                End
93065>>>>>>
93065>>>>>            End
93065>>>>>>
93065>>>>>
93065>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93065>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93067>>>>>
93067>>>>>            // If the parent property pbContinueOnError = False, an update
93067>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93067>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93069>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93071>>>>>                Procedure_Return
93072>>>>>            End
93072>>>>>>
93072>>>>>
93072>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93074>>>>>
93074>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93075>>>>>
93075>>>>>            // *** Programmer's main hook event for database update functions:
93075>>>>>            Send OnUpdate
93076>>>>>
93076>>>>>            Set pbVersionUpdate to True
93077>>>>>            Send UpdateVersionColumnValue
93078>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93080>>>>>        End
93080>>>>>>
93080>>>>>
93080>>>>>    End_Procedure
93081>>>>>
93081>>>>>End_Class
93082>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93082>>>>>//****************************************************************************
93082>>>>>// $Module type: Class
93082>>>>>// $Module name: cDbUpdateUserCount.pkg
93082>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93082>>>>>//
93082>>>>>//               Collected from DAW's newsgroups.
93082>>>>>//
93082>>>>>// Description : It uses the windows API to lock bytes in a file.
93082>>>>>//               If the application or PC craches it will release the lock
93082>>>>>//               automatically.
93082>>>>>//
93082>>>>>// Note 1      : It will count the number of running app's, so if a
93082>>>>>//               user starts the app twice on one machine it will count as two users.
93082>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93082>>>>>//               However, to not conflict with any other usage of this class it was
93082>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93082>>>>>//               and cDbUpdateVersion classes)
93082>>>>>//
93082>>>>>// $Rev History:
93082>>>>>//    2008-10-17  Module header created (Militaty data format)
93082>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93082>>>>>//                for easy translation to other languages.
93082>>>>>//                Added the tUserCount struct for easier passing of parameters.
93082>>>>>//                Added the ApplicationPath message.
93082>>>>>//****************************************************************************
93082>>>>>Use LanguageText.pkg
93082>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93082>>>>>>>Use GlobalFunctionsProcedures.pkg
93082>>>>>>>// Sample:
93082>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93082>>>>>>>
93082>>>>>>>
93082>>>>>>>// Symbols used by UserCounting
93082>>>>>>>    Define GENERIC_READ         for |CI$80000000
93082>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93082>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93082>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93082>>>>>>>    Define CREATE_NEW           for 1
93082>>>>>>>    Define CREATE_ALWAYS        for 2
93082>>>>>>>    Define OPEN_EXISTING        for 3
93082>>>>>>>    Define OPEN_ALWAYS          for 4
93082>>>>>>>    Define TRUNCATE_EXISTING    for 5
93082>>>>>>>    Define FILE_BEGIN           for 0
93082>>>>>>>    Define FILE_CURRENT         for 1
93082>>>>>>>    Define FILE_END             for 2
93082>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93082>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93082>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93082>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93082>>>>>>>    Define _MAX_PATH  for 260
93082>>>>>>>    Define _MAX_DRIVE for 3
93082>>>>>>>    Define _MAX_DIR   for 256
93082>>>>>>>    Define _MAX_FNAME for 256
93082>>>>>>>    Define _MAX_EXT   for 256
93082>>>>>>>
93082>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93083>>>>>>>
93083>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93084>>>>>>>
93084>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93085>>>>>>>
93085>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93086>>>>>>>
93086>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93087>>>>>>>
93087>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93088>>>>>>>
93088>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93089>>>>>>>
93089>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93090>>>>>>>// Sample:
93090>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93090>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93092>>>>>>>    Boolean bReturn
93092>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93093>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93094>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93095>>>>>>>    Function_Return bReturn
93096>>>>>>>End_Function
93097>>>>>Use vWin32fh.pkg
93097>>>>>Use seq_chnl.pkg
93097>>>>>
93097>>>>>// User interface constant strings:
93097>>>>>    Define CS_UserCountError            for "User count error:"
93097>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93097>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93097>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93097>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>
93097>>>>>    Struct tUserCount
93097>>>>>        Integer iUserCount
93097>>>>>        Integer iError
93097>>>>>        String  sErrorTxt
93097>>>>>    End_Struct
93097>>>>>
93097>>>>>    Define CI_UserCountMaxUsers for 9999
93097>>>>>
93097>>>>>Class cDbUpdateUserCount is a cObject
93098>>>>>    Procedure Construct_Object
93100>>>>>        Forward Send Construct_Object
93102>>>>>
93102>>>>>        Property String  psLockFileName
93103>>>>>        Property Integer piMaxUsers
93104>>>>>        Property Boolean pbCheckDataFlexUserCount True
93105>>>>>
93105>>>>>        Property Handle  phUserCountFile
93106>>>>>        Property Integer pdwLockPosition
93107>>>>>    End_Procedure
93108>>>>>
93108>>>>>    Function IsProgramRunning Returns Boolean
93110>>>>>        tUserCount UserCount
93110>>>>>        tUserCount UserCount
93110>>>>>
93110>>>>>        Get CheckUserCount to UserCount
93111>>>>>
93111>>>>>        Function_Return (UserCount.iUserCount > 1)
93112>>>>>    End_Function
93113>>>>>
93113>>>>>    // Returns the full path of the Application (no trailing "\")
93113>>>>>    Function ApplicationPath Returns String
93115>>>>>        String sApplicationFileName sPath
93115>>>>>        Integer iNumChars iRetval
93115>>>>>
93115>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93116>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93117>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93118>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93119>>>>>        Move (CString(sApplicationFileName)) to sPath
93120>>>>>
93120>>>>>        Function_Return sPath
93121>>>>>    End_Function
93122>>>>>
93122>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93124>>>>>        Handle  hFile
93124>>>>>        Pointer pFileName
93124>>>>>        String sPath sFile
93124>>>>>        Integer iCh
93124>>>>>
93124>>>>>        Move (Addressof(sFileName)) to pFileName
93125>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93126>>>>>
93126>>>>>        // If lock file doesn't exist, create it.
93126>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93128>>>>>            Get ApplicationPath to sPath
93129>>>>>            Get vFolderFormat sPath to sPath
93130>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93131>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93132>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93134>>>>>                Function_Return 0
93135>>>>>            End
93135>>>>>>
93135>>>>>            Direct_Output channel iCh sFile
93137>>>>>                Write channel iCh ""
93139>>>>>            Send Seq_Close_Channel iCh
93140>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93141>>>>>        End
93141>>>>>>
93141>>>>>
93141>>>>>        Function_Return hFile
93142>>>>>    End_Function
93143>>>>>
93143>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93145>>>>>        Integer iReturnValue 
93145>>>>>        Boolean bOK
93145>>>>>
93145>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93146>>>>>        If (iReturnValue = 0) Begin
93148>>>>>            Move False to bOK
93149>>>>>        End
93149>>>>>>
93149>>>>>        Else Begin
93150>>>>>            Move True to bOK
93151>>>>>        End
93151>>>>>>
93151>>>>>        Function_Return bOK
93152>>>>>    End_Function
93153>>>>>
93153>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93155>>>>>        Integer iReturnValue
93155>>>>>        Boolean bOK
93155>>>>>
93155>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93156>>>>>        If (iReturnValue = 0) Begin
93158>>>>>            Move False to bOK
93159>>>>>        End
93159>>>>>>
93159>>>>>        Else Begin
93160>>>>>            Move True to bOK
93161>>>>>        End           
93161>>>>>>
93161>>>>>        Function_Return bOK
93162>>>>>    End_Function
93163>>>>>
93163>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93165>>>>>        dWord dwCurrPos
93165>>>>>
93165>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93166>>>>>        Function_Return dwCurrPos
93167>>>>>    End_Function
93168>>>>>
93168>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93170>>>>>        DWord dwCurrPos
93170>>>>>
93170>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93171>>>>>        Function_Return dwCurrPos
93172>>>>>    End_Function
93173>>>>>
93173>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93175>>>>>        Integer iReturnValue                               
93175>>>>>        Boolean bOK
93175>>>>>        String  sBuffer
93175>>>>>        Pointer pBuffer
93175>>>>>        String  sSize
93175>>>>>        Pointer pSize
93175>>>>>
93175>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93176>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93177>>>>>
93177>>>>>        Move (Repeat((Character(0)),4)) to sSize
93178>>>>>        Move (AddressOf(sSize)) to pSize
93179>>>>>
93179>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93180>>>>>        If (iReturnValue = 0) Begin
93182>>>>>            Move False to bOK
93183>>>>>        End
93183>>>>>>
93183>>>>>        Else Begin
93184>>>>>            Move True to bOK
93185>>>>>        End                 
93185>>>>>>
93185>>>>>        Function_Return bOK
93186>>>>>    End_Function
93187>>>>>
93187>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93189>>>>>        Integer iReturnValue
93189>>>>>
93189>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93190>>>>>        Function_Return iReturnValue
93191>>>>>    End_Function
93192>>>>>
93192>>>>>    Procedure DoCheckUserCount
93194>>>>>        tUserCount UserCount
93194>>>>>        tUserCount UserCount
93194>>>>>
93194>>>>>        Get CheckUserCount to UserCount
93195>>>>>        // If all is fine, we're done.
93195>>>>>        If (UserCount.iError = 0) Begin
93197>>>>>            Procedure_Return
93198>>>>>        End
93198>>>>>>
93198>>>>>
93198>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93199>>>>>
93199>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93201>>>>>            Abort
93202>>>>>>
93202>>>>>        End
93202>>>>>>
93202>>>>>    End_Procedure
93203>>>>>
93203>>>>>    Function CheckUserCount Returns tUserCount
93205>>>>>        Handle  hFile
93205>>>>>        String  sPath sFile
93205>>>>>        Integer iResult
93205>>>>>        DWord   dwFilePos
93205>>>>>        Integer bLocked
93205>>>>>        Integer iMaxUsers
93205>>>>>        Integer iCurUser
93205>>>>>        tUserCount UserCount
93205>>>>>        tUserCount UserCount
93205>>>>>
93205>>>>>        Move 0 to UserCount.iError
93206>>>>>
93206>>>>>        Get phUserCountFile to hFile
93207>>>>>        If (not(hFile)) Begin
93209>>>>>            Get ApplicationPath to sPath
93210>>>>>            Get vFolderFormat sPath to sPath
93211>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93212>>>>>            Get OpenUserCountFile sFile to hFile
93213>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93215>>>>>                Move 1 to UserCount.iUserCount
93216>>>>>                Move 1 to UserCount.iError
93217>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93218>>>>>                Function_Return UserCount
93219>>>>>            End
93219>>>>>>
93219>>>>>            Else Begin
93220>>>>>                Move False to bLocked
93221>>>>>                Set phUserCountFile to hFile
93222>>>>>                Get piMaxUsers to iMaxUsers
93223>>>>>
93223>>>>>                // Set Filepointer to beginning of the file
93223>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93224>>>>>                If (dwFilePos = -1) Begin
93226>>>>>                    Move 1 to UserCount.iUserCount
93227>>>>>                    Move 2 to UserCount.iError
93228>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93229>>>>>                    Function_Return UserCount
93230>>>>>                End
93230>>>>>>
93230>>>>>                For iCurUser from 1 to iMaxUsers
93236>>>>>>
93236>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93237>>>>>                    If (not(iResult)) Begin  // byte is locked
93239>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93240>>>>>                        If (dwFilePos = -1) Begin
93242>>>>>                            Move 1 to UserCount.iUserCount
93243>>>>>                            Move 3 to UserCount.iError
93244>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93245>>>>>                            Function_Return UserCount
93246>>>>>                        End
93246>>>>>>
93246>>>>>                    End
93246>>>>>>
93246>>>>>                    Else Begin  // byte is not locked
93247>>>>>                        Set pdwLockPosition to dwFilePos
93248>>>>>                        Move True to bLocked
93249>>>>>                        Move iMaxUsers to iCurUser
93250>>>>>                    End
93250>>>>>>
93250>>>>>                Loop
93251>>>>>>
93251>>>>>                If (not(bLocked)) Begin
93253>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93254>>>>>                    Move 4 to UserCount.iError
93255>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93256>>>>>                    Function_Return UserCount
93257>>>>>                End
93257>>>>>>
93257>>>>>            End
93257>>>>>>
93257>>>>>        End
93257>>>>>>
93257>>>>>
93257>>>>>        Function_Return UserCount
93258>>>>>    End_Function
93259>>>>>
93259>>>>>
93259>>>>>    Procedure DoReleaseUserCount
93261>>>>>        Integer iResult
93261>>>>>        Handle  hFile
93261>>>>>        DWord   dwLockPos
93261>>>>>
93261>>>>>        Get phUserCountFile to hFile
93262>>>>>        Get pdwLockPosition to dwLockPos
93263>>>>>        If (hFile) Begin
93265>>>>>            If (dwLockPos) Begin
93267>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93268>>>>>            End
93268>>>>>>
93268>>>>>            Get CloseUserCountFile hFile to iResult
93269>>>>>        End
93269>>>>>>
93269>>>>>    End_Procedure
93270>>>>>
93270>>>>>    Function CurrentNumberOfUsers Returns Integer
93272>>>>>        Handle  hFile
93272>>>>>        Integer iMaxUsers
93272>>>>>        DWord   dwFilePos
93272>>>>>        Integer iCurUser
93272>>>>>        Integer iResult
93272>>>>>        Integer iNumberOfLocks
93272>>>>>        String  sPath sFile
93272>>>>>
93272>>>>>        Move 0 to iNumberOfLocks
93273>>>>>
93273>>>>>        Get ApplicationPath to sPath
93274>>>>>        Get vFolderFormat sPath to sPath
93275>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93276>>>>>        Get OpenUserCountFile sFile to hFile
93277>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93279>>>>>            Send UserError CS_UnableToInitUserCountSys
93280>>>>>            Abort
93281>>>>>>
93281>>>>>        End
93281>>>>>>
93281>>>>>
93281>>>>>        If (hFile > 0) Begin
93283>>>>>            Get piMaxUsers To iMaxUsers
93284>>>>>
93284>>>>>            // Set Filepointer to beginning of the file
93284>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93285>>>>>            If (dwFilePos = -1) Begin
93287>>>>>                Send UserError CS_UnableResetUserCountSys
93288>>>>>                Abort
93289>>>>>>
93289>>>>>            End
93289>>>>>>
93289>>>>>            For iCurUser from 1 to iMaxUsers
93295>>>>>>
93295>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93296>>>>>                If (Not(iResult)) Begin  // byte is locked
93298>>>>>                    Increment iNumberOfLocks
93299>>>>>                End
93299>>>>>>
93299>>>>>                Else Begin  // byte is not locked
93300>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93301>>>>>                End
93301>>>>>>
93301>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93302>>>>>                If (dwFilePos = -1) Begin
93304>>>>>                    Send UserError CS_ErrorAdvancingPointer
93305>>>>>                    Abort
93306>>>>>>
93306>>>>>                End
93306>>>>>>
93306>>>>>            Loop
93307>>>>>>
93307>>>>>        End
93307>>>>>>
93307>>>>>        Get CloseUserCountFile hFile to iResult
93308>>>>>        Function_Return iNumberOfLocks
93309>>>>>    End_Function
93310>>>>>
93310>>>>>End_Class
93311>>>Use cDbUpdateFunctionLibrary.pkg
93311>>>
93311>>>//{ DataBindable=True }
93311>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93312>>>
93312>>>    Procedure Construct_Object
93314>>>        tUserCount UserCount
93314>>>        tUserCount UserCount
93314>>>        Integer iUserCount
93314>>>        Handle ho                     
93314>>>
93314>>>        Forward Send Construct_Object
93316>>>        Move Self to ghoDbUpdateHandler  
93317>>>        
93317>>>        // Latin1_General_CI_AS = General Insensitive collation
93317>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93317>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93317>>>        // Good read about which collation to select:
93317>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93317>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93318>>>
93318>>>        // Struct array that will contain pnVersionNumbers & object id's of
93318>>>        // all child cDbVersion objects.
93318>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93319>>>
93319>>>        Property Integer Error_Processing_State False  // internal usage
93320>>>        
93320>>>        Property Boolean Private.pbDbVersionCheckDone False
93321>>>
93321>>>        Property Boolean pbUseCustomDbVersion False  
93322>>>        
93322>>>        // If this property = True _and_ no DbVersion table exists 
93322>>>        // when the framework is started, a DbVersion table will be created automatically.
93322>>>        Property Boolean pbAutoCreateDbVersionTable True
93323>>>
93323>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93323>>>        // the Filelist.cfg slot number indicated by this property will be used
93323>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93323>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93323>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93323>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93323>>>        Property Integer Private.piDbVersionFileNumber -1
93324>>>        Property Integer Private.piDbVersionFieldNumber 1
93325>>>
93325>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93325>>>        // that creates all library properties
93325>>>        Send CreateDbUpdateLibraryProperties
93326>>>
93326>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93327>>>
93327>>>        // Error handling:
93327>>>        Property Boolean Private.pbOnCreateExecuted False
93328>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93329>>>        Property Boolean Private.pbProcessingError False
93330>>>        Property Boolean pbDbUpdateErrorHasOccured False
93331>>>        // Don't touch. It is being used by the cDbUpdateVersion
93331>>>        // subclass to tell if that particular update went OK or not.
93331>>>        Property Boolean Private.pbUpdateVersionObjectError False
93332>>>        Property String[] paSQLQueryMessages
93333>>>        
93333>>>        Property Boolean pbExitIfDebuggerActive True
93334>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93335>>>        Move Self to Error_Object_Id
93336>>>        // Error handling:
93336>>>        // Temporarily redirect all errors to this object so we can silently
93336>>>        // log all errors that might appear while updating the database.
93336>>>        // We temporarily redirect all errors to this object so we can
93336>>>        // log and write errors to the log file. It will be reset after
93336>>>        // the database updates have been finished.
93336>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93337>>>
93337>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93338>>>
93338>>>        // Error Reporting Related
93338>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93338>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93339>>>
93339>>>        // If the pbContinueOnError = False, an update
93339>>>        // of another cDbUpdateVersion object will _not_ be
93339>>>        // performed if an error occured in a previous
93339>>>        // cDbUpdateVersion object.
93339>>>        Property Boolean pbContinueOnError False
93340>>>        // Stops execution in other cDbUpdateVersion objecs,
93340>>>        // if errors occurred in one cDbUpdateVersion object.
93340>>>        Property Boolean pbStopOnFirstError False
93341>>>        // If True errors that occured while updating the database
93341>>>        // will be shown in the default app for .txt files when done.
93341>>>        // Note: The log file will _always_ be created in the Data folder.
93341>>>        Property Boolean pbShowErrorLogPostRun True
93342>>>
93342>>>        // Be _very_ careful to set this property to true!
93342>>>        // If = True, no question will be asked if the update
93342>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93342>>>        // the error log won't be shown. The logfile itself will still be created though.
93342>>>        // You have to know what you're doing!
93342>>>        Property Boolean pbSilentMode False
93343>>>        
93343>>>        Property Boolean pbEnableCancelButton False
93344>>>
93344>>>        // Don't touch! Very private. The value is used by the error log to write for which
93344>>>        // cDbUpdateVersion object an error occured.
93344>>>        Property Number pnCurrentVersionUpdate 0
93345>>>
93345>>>        // The user counting logic is used to safe-guard agains anybody else is
93345>>>        // using the application when a database update is to be performed.
93345>>>        // (Garters & suspenders!)
93345>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93346>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93347>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93348>>>
93348>>>        // This lock file is used to guard against somebody else tries to start the
93348>>>        // application while updates are in progress.
93348>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93349>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93350>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93351>>>                                                                                      // Only the current user allowed.
93351>>>        // Properties for the table & column of a system file field/column where
93351>>>        // the database version update number gets saved.
93351>>>        Property Integer Private.Data_File  0
93352>>>        Property Integer Private.Data_Field 0
93353>>>
93353>>>        // Property that is used to indicate that we have already
93353>>>        // started the database update.
93353>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93354>>>
93354>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93354>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93354>>>        // change of the database has been made.
93354>>>        Property Boolean Private.pbDatabaseWasUpdated False
93355>>>
93355>>>        // We need to trigger the user counting system so that a bit in the
93355>>>        // user counting file is locked. This is to guard that not more than one user
93355>>>        // is currently runnning the program.
93355>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93356>>>
93356>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93357>>>        If (iUserCount > 0) Begin
93359>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93360>>>            Send Exit_Application
93361>>>        End
93361>>>>
93361>>>
93361>>>        Set pbHandleQueryErrors to False
93362>>>            
93362>>>        Property Handle phoSQLConnectionHandler 0
93363>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93363>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93363>>>        // etc information.
93363>>>        If (ghoSQLConnectionHandler = 0) Begin
93365>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93366>>>            Set phoSQLConnectionHandler to ho
93367>>>        End             
93367>>>>
93367>>>        
93367>>>        // Do *not* set this property in this object!
93367>>>        // Instead use logic to set it in the Procedure OnCreate of the cApplication
93367>>>        // object. Aka, use phoCommandLine to retrieve an e.g. "-restore" parameter on
93367>>>        // the command line to the program. If such param has been passed, set  pbRestoreIntFilesNow = True.
93367>>>        // The user will then be informed that .int files will be restored and then the program will exit.
93367>>>        Property Boolean pbRestoreIntFilesNow False   
93368>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93368>>>        // also needs to be created in the ghoApplication object.
93368>>>        Property Boolean pbSaveIntFilesNow False
93369>>>        Property Boolean pbUseIntFilesBackup False   
93370>>>        Property Handle  phIntFilesTable 256
93371>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93372>>>        
93372>>>        Set Icon to "Default.ico"
93373>>>    End_Procedure
93374>>>
93374>>>    Procedure End_Construct_Object
93376>>>        Boolean bCheckIntFiles
93376>>>        
93376>>>        Forward Send End_Construct_Object
93378>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93380>>>            Send OnCreate
93381>>>            Set Private.pbOnCreateExecuted to True
93382>>>        End
93382>>>>
93382>>>        Send Cleanup
93383>>>    End_Procedure
93384>>>    
93384>>>    // Programmers hook event.
93384>>>    Procedure OnCreate
93386>>>    End_Procedure        
93387>>>                                 
93387>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93387>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93387>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93387>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93387>>>    //                                                
93387>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93387>>>    // cDbUpdateHandler object.
93387>>>    //
93387>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93387>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93387>>>    //
93387>>>    // If not done previously the phIntFilesTable will be created and filled with data
93387>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93387>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93387>>>    // of Filelist.cfg is made for backup purposes.
93387>>>    //
93387>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93387>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93387>>>
93387>>>    // Note: Include_Resource is a compiler directive!
93387>>>    // It will embedd the Filelist.cfg from the developers machine
93387>>>    // into the executable.        
93387>>>    //
93387>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93387>>>    // when we get here and then the compiler can't embedd it!        
93387>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93387>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93387>>>    Procedure SaveUpdateIntFiles
93389>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93389>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93389>>>        String sFileListZipFile sParam sProgram sFile 
93389>>>        Integer iDataPaths iCount
93389>>>        Handle hTable hIntFilesTable                    
93389>>>        UChar[] asFileListArray 
93390>>>        String[] asSavedIntFile
93391>>>        tDUFIntFile[] DUFIntFiles
93391>>>        tDUFIntFile[] DUFIntFiles
93392>>>
93392>>>        // This will automatically create the phIntFilesTable if not exists.
93392>>>        // It is used to save data from the current set of .int files.
93392>>>        // We do this on both developer & client machines.
93392>>>        Get IsIntFileTable to bIsIntFileTable
93393>>>        If (bIsIntFileTable = False) Begin
93395>>>            Send AutoCreateIntFilesTable
93396>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93397>>>            If (bOK = False) Begin
93399>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
93400>>>                Send Exit_Application of ghoApplication
93401>>>            End
93401>>>>
93401>>>        End                                                       
93401>>>>
93401>>>        
93401>>>        // Check Filelist.cfg & backup file
93401>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93402>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93403>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93404>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93405>>>
93405>>>        Move (IsDebuggerPresent()) to bDevelop
93406>>>        // Is this a client machine?
93406>>>        If (bDevelop = False) Begin
93408>>>            If (bNewer = True) Begin
93410>>>                // Create filelist.cfg from resource backup file.
93410>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93411>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93412>>>            End
93412>>>>
93412>>>        End
93412>>>>
93412>>>
93412>>>        Else If (bDevelop = True) Begin
93415>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93416>>>            If (bNewer = True) Begin
93418>>>                Get vDeleteFile sFileListNameBackup to bOK
93419>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93420>>>                Send Info_Box "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program.\n\nThe program will now exit."
93421>>>                Send Exit_Application
93422>>>            End
93422>>>>
93422>>>        End
93422>>>>
93422>>>        
93422>>>        Move True to bResult        
93423>>>        Send StartStatusPanel
93424>>>        Get phIntFilesTable to hIntFilesTable
93425>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93426>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93427>>>
93427>>>        For iCount from 1 to iDataPaths
93433>>>>
93433>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93434>>>            Get vFolderFormat sDataPath to sDataPath 
93435>>>            Get vFolderExists sDataPath to bExists
93436>>>            If (bExists = True) Begin                  
93438>>>                Move 0 to hTable
93439>>>                Repeat
93439>>>>
93439>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93442>>>                    If (hTable <> 0 and hTable <> 50) Begin
93444>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93447>>>                        Set Message_Text of ghoStatusPanel to ("Saving info about:" * String(sIntFileName))
93448>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93449>>>                        Get UtilTableIsAlias hTable to bIsAlias 
93450>>>                        If (bIsSQL = True and bIsAlias = False) Begin
93452>>>                            If (bIsSQL = True) Begin     
93454>>>                                Get _TableNameOnly sIntFileName to sIntFileName
93455>>>                                Move (sIntFileName + ".int")    to sIntFileName
93456>>>                                Get IsIntFileSaved sIntFileName to bSaved  
93457>>>                                Move True to bOK            
93458>>>                                
93458>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
93458>>>                                If (bSaved = False) Begin
93460>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93461>>>                                    If (bOK = False) Begin
93463>>>                                        Move False to bResult    
93464>>>                                    End
93464>>>>
93464>>>                                End         
93464>>>>
93464>>>                                Else Begin
93465>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93466>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
93468>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93469>>>                                        If (bOK = False) Begin
93471>>>                                            Move False to bResult
93472>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93473>>>>
93473>>>                                        End
93473>>>>
93473>>>                                    End
93473>>>>
93473>>>                                End
93473>>>>
93473>>>                            End
93473>>>>
93473>>>                        End
93473>>>>
93473>>>                    End
93473>>>>
93473>>>                Until (hTable = 0)
93475>>>            End
93475>>>>
93475>>>        Loop       
93476>>>>
93476>>>        
93476>>>        Send Stop_StatusPanel of ghoStatusPanel
93477>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
93477>>>        If (bResult = False) Begin  
93479>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
93480>>>            Send Exit_Application
93481>>>        End 
93481>>>>
93481>>>        Else Begin
93482>>>            Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
93483>>>        End
93483>>>>
93483>>>    End_Procedure               
93484>>>
93484>>>    // It checks that *.int files on disk corresponds with the content in the
93484>>>    // .int file backup table phIntFilesTable.
93484>>>    Procedure RestoreIntFiles
93486>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
93486>>>        String sPaths sDataPath sIntFileName 
93486>>>        String[] asSavedIntFile
93487>>>        Integer iDataPaths iCount iRetval
93487>>>        Handle hTable hIntFilesTable
93487>>>
93487>>>        Get IsIntFileTable to bIsIntFileTable
93488>>>        If (bIsIntFileTable = False) Begin
93490>>>            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
93491>>>            Procedure_Return
93492>>>        End
93492>>>>
93492>>>        
93492>>>        Get YesNo_Box "This will restore the content of .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed.\n\n Continue?" to iRetval
93493>>>        If (iRetval <> MBR_Yes) Begin
93495>>>            Procedure_Return
93496>>>        End
93496>>>>
93496>>>
93496>>>        Send StartStatusPanel
93497>>>        Move False to bRestored
93498>>>        Get phIntFilesTable to hIntFilesTable
93499>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93500>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93501>>>
93501>>>        For iCount from 1 to iDataPaths
93507>>>>
93507>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93508>>>            Get vFolderFormat sDataPath to sDataPath 
93509>>>            Get vFolderExists sDataPath to bExists
93510>>>            If (bExists = True) Begin                  
93512>>>                Move 0 to hTable
93513>>>                Repeat
93513>>>>
93513>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93516>>>                    If (hTable <> 0) Begin
93518>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93521>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
93522>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93523>>>                        If (bIsSQL = True) Begin     
93525>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93526>>>                            Move (sIntFileName + ".int")    to sIntFileName
93527>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93528>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
93530>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
93531>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
93532>>>                                If (bRestored = False and bOK = True) Begin
93534>>>                                    Move True to bRestored
93535>>>                                End
93535>>>>
93535>>>                                If (bOK = False) Begin
93537>>>                                    Error DFERR_PROGRAM ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName))
93538>>>>
93538>>>                                End
93538>>>>
93538>>>                            End
93538>>>>
93538>>>                        End
93538>>>>
93538>>>                    End
93538>>>>
93538>>>                Until (hTable = 0)
93540>>>            End
93540>>>>
93540>>>        Loop       
93541>>>>
93541>>>        
93541>>>        Send Stop_StatusPanel of ghoStatusPanel
93542>>>        If (bRestored = True) Begin
93544>>>            Send Info_Box "Ready! All .int files checked and updated if different. The program will now exit."
93545>>>            Send Exit_Application
93546>>>        End
93546>>>>
93546>>>    End_Procedure
93547>>>
93547>>>    Function IsIntFileTable Returns Boolean
93549>>>        Boolean bExists
93549>>>        Handle hTable
93549>>>        String sLogicalName
93549>>>        Move False to bExists
93550>>>        Get phIntFilesTable to hTable
93551>>>        If (hTable > 0) Begin
93553>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93556>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
93557>>>        End
93557>>>>
93557>>>        Function_Return bExists    
93558>>>    End_Function
93559>>>    
93559>>>    // To update currently saved IntFile data to the database.
93559>>>    // Because it is much easier, we first delete all current records and
93559>>>    // then saves the changed .int file to the database.
93559>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93561>>>        Boolean bOK
93561>>>        Move False to bOK
93562>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93563>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93564>>>        If (bOK = True) Begin
93566>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93567>>>        End
93567>>>>
93567>>>        Function_Return bOK
93568>>>    End_Function
93569>>>    
93569>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
93569>>>    //       and thus we cannot compile.
93569>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93571>>>        Handle hTable
93571>>>        Boolean bOK
93571>>>        Integer iColumn iIndex   
93571>>>        String sFileName
93571>>>        
93571>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93572>>>        Move False to bOK  
93573>>>        Get phIntFilesTable to hTable
93574>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93575>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93576>>>
93576>>>        Open hTable
93578>>>        Set_Field_Value hTable iColumn to sIntFileName
93581>>>        Vfind hTable iIndex GE
93583>>>        Get_Field_Value hTable iColumn to sFileName
93586>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93588>>>            Move True to bOK    
93589>>>        End
93589>>>>
93589>>>        Close hTable
93590>>>        
93590>>>        Function_Return bOK       
93591>>>    End_Function   
93592>>>    
93592>>>    // Checks that the passed .int file is the same as what is saved in the database.
93592>>>    // If not same, the return string array will contain the read .int file,
93592>>>    // else the returned array will be empty.
93592>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93594>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93598>>>        Boolean bIsSame
93598>>>        
93598>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93599>>>        Get ReadIntFileData  sDataPath sIntFileName to asIntFileOrg   
93600>>>        Get SavedIntFileData sDataPath sIntFileName to asSavedIntFile
93601>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93602>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93603>>>        
93603>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93604>>>        If (bIsSame = False) Begin
93606>>>            Move asIntFileOrg to asReturnIntFile    
93607>>>        End
93607>>>>
93607>>>        
93607>>>        Function_Return asReturnIntFile    
93608>>>    End_Function                                   
93609>>>    
93609>>>    // Takes a string array as parameter and returns a new
93609>>>    // string array without any empty rows and all rows trimmed.
93609>>>    // This is e.g. used by the HasIntFileChanged message to compare
93609>>>    // two .int file arrays. 
93609>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93611>>>        Integer iSize iCount iRow
93611>>>        String sVal        
93611>>>        String[] asRetValArray
93612>>>        
93612>>>        Move (SizeOfArray(asIntFile)) to iSize
93613>>>        If (iSize = 0) Begin
93615>>>            Function_Return asRetValArray
93616>>>        End                          
93616>>>>
93616>>>        Decrement iSize         
93617>>>        Move 0 to iRow
93618>>>        
93618>>>        For iCount from 0  to iSize
93624>>>>
93624>>>            Move asIntFile[iCount] to sVal
93625>>>            Move (Trim(sVal)) to sVal
93626>>>            If (sVal <> "") Begin
93628>>>                Move sVal to asRetValArray[iRow]
93629>>>                Increment iRow        
93630>>>            End
93630>>>>
93630>>>        Loop
93631>>>>
93631>>>        
93631>>>        Function_Return asRetValArray
93632>>>    End_Function
93633>>>    
93633>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93635>>>        Handle hTable
93635>>>        Boolean bOK bErr
93635>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93635>>>        Number iID
93635>>>        String sFileName
93635>>>        String[] asIntFile
93636>>>        
93636>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
93636>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93637>>>        
93637>>>        Move Err to bErr
93638>>>        Move False to Err
93639>>>        Move False to bOK
93640>>>        Get phIntFilesTable to hTable  
93641>>>        Move 1              to iIDCol
93642>>>        Move 2              to iFileCol
93643>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93644>>>        Move 1              to iIDIdx   // Main ID index.
93645>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93646>>>
93646>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93647>>>        Move (SizeOfArray(asIntFile)) to iSize
93648>>>        If (iSize = 0) Begin
93650>>>            Function_Return False
93651>>>        End
93651>>>>
93651>>>        Decrement iSize
93652>>>        Open hTable  
93654>>>                  
93654>>>        // Find the last used ID no:
93654>>>        Fill_Field hTable iIDCol with DF_HIGH
93656>>>        Vfind hTable iIDIdx LE
93658>>>        Get_Field_Value hTable iIDCol to iID 
93661>>>        // This only happens the very first time we save a record.
93661>>>        If (iID = 999999999999) Begin
93663>>>            Move 0 to iID
93664>>>        End
93664>>>>
93664>>>        Increment iID
93665>>>        
93665>>>        Lock
93666>>>>
93666>>>            For iCount from 0 to iSize
93672>>>>
93672>>>                Clear hTable
93673>>>                Set_Field_Value hTable iIDCol   to iID     
93676>>>                Set_Field_Value hTable iFileCol to sIntFileName
93679>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
93682>>>                SaveRecord hTable
93683>>>                Increment iID
93684>>>            Loop
93685>>>>
93685>>>        Unlock
93686>>>>
93686>>>        Close hTable
93687>>>        
93687>>>        Move (not(Err)) to bOK
93688>>>        Move bErr to Err
93689>>>        
93689>>>        Function_Return bOK
93690>>>    End_Function
93691>>>    
93691>>>    // Deletes all records for the passed sIntFileName value,
93691>>>    // from the phIntFilesTable.
93691>>>    // Returns True if no errors occured.
93691>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
93693>>>        Handle hTable
93693>>>        Boolean bOK bErr bFound
93693>>>        Integer iFileCol iIndex
93693>>>        String sVal
93693>>>        String[] asIntFile
93694>>>        
93694>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
93695>>>        Move Err to bErr
93696>>>        Move False to Err
93697>>>        Move False to bOK
93698>>>        Move 2              to iFileCol
93699>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93700>>>        Get phIntFilesTable to hTable  
93701>>>        Open hTable  
93703>>>                  
93703>>>        // Find the first record
93703>>>        Set_Field_Value hTable iFileCol to sIntFileName
93706>>>        Vfind hTable iIndex GE
93708>>>        Get_Field_Value hTable iFileCol to sVal
93711>>>        Move (Trim(Lowercase(sVal))) to sVal
93712>>>        Move (Found and sVal = sIntFileName) to bFound
93713>>>        While (bFound = True)
93717>>>            Delete hTable
93718>>>            Vfind hTable iIndex GT
93720>>>            Get_Field_Value hTable iFileCol to sVal
93723>>>            Move (Trim(Lowercase(sVal))) to sVal
93724>>>            Move (Found and sVal = sIntFileName) to bFound
93725>>>        Loop
93726>>>>
93726>>>        Unlock
93727>>>>
93727>>>        Close hTable
93728>>>        
93728>>>        Move (not(Err)) to bOK
93729>>>        Move bErr to Err
93730>>>        
93730>>>        Function_Return bOK
93731>>>    End_Function
93732>>>
93732>>>    // Returns all saved phIntFilesTable records for the passed 
93732>>>    // sIntFileName value as a string array.
93732>>>    Function SavedIntFileData String sPath String sIntFileName Returns String[]
93734>>>        Handle hTable
93734>>>        Boolean bOK bErr bFound
93734>>>        Integer iFileCol iTextCol iIndex
93734>>>        String sVal sFileName
93734>>>        String[] asIntFile asEmptyArray
93736>>>        
93736>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
93737>>>        Move Err to bErr
93738>>>        Move False to Err
93739>>>        Move False to bOK
93740>>>        Move 2              to iFileCol
93741>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93742>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93743>>>        Get phIntFilesTable to hTable  
93744>>>        Open hTable  
93746>>>        
93746>>>        // Find the first record
93746>>>        Set_Field_Value hTable iFileCol to sIntFileName
93749>>>        Vfind hTable iIndex GE
93751>>>        Get_Field_Value hTable iFileCol to sFileName
93754>>>        Move (Trim(Lowercase(sFileName))) to sFileName
93755>>>        Move (Found and sFileName = sIntFileName) to bFound
93756>>>        While (bFound = True)
93760>>>            Get_Field_Value hTable iFileCol   to sFileName
93763>>>            Move (Trim(Lowercase(sFileName))) to sFileName
93764>>>            Move (Found and sFileName = sIntFileName) to bFound
93765>>>            If (bFound = True) Begin
93767>>>                Get_Field_Value hTable iTextCol to sVal
93770>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
93771>>>            End
93771>>>>
93771>>>            Vfind hTable iIndex GT
93773>>>        Loop
93774>>>>
93774>>>        
93774>>>        Close hTable
93775>>>        Move (not(Err)) to bOK
93776>>>        If (bOK = False) Begin
93778>>>            Move asEmptyArray to asIntFile
93779>>>        End
93779>>>>
93779>>>        Move bErr to Err               
93780>>>        
93780>>>        Function_Return asIntFile
93781>>>    End_Function
93782>>>
93782>>>    // Reads the passed sIntFileName from disk and returns its value
93782>>>    // as a string array.
93782>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
93784>>>        String[] asIntFile       
93785>>>        String sFileName sLine
93785>>>        Integer iCh iSize iCount
93785>>>        
93785>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93786>>>        Get vFolderFormat sPath to sPath
93787>>>        If (not(sIntFileName contains ".")) Begin
93789>>>            Move (sIntFileName + ".int") to sIntFileName
93790>>>        End
93790>>>>
93790>>>        Move (sPath + sIntFileName) to sFileName
93791>>>        Get Seq_Open_input_Channel sFileName to iCh
93792>>>        If (iCh < 0) Begin
93794>>>            Function_Return asIntFile
93795>>>        End                                 
93795>>>>
93795>>>        
93795>>>        Repeat
93795>>>>
93795>>>            Readln channel iCh sLine
93797>>>            If (SeqEof = False) Begin
93799>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
93800>>>            End
93800>>>>
93800>>>        Until (SeqEof = True)
93802>>>        Send Seq_Close_Channel iCh    
93803>>>        
93803>>>        Function_Return asIntFile
93804>>>    End_Function
93805>>>    
93805>>>    // Reads the Filelist.cfg from memeory as a resource.
93805>>>    // The Filelist.cfg has been compiled into the program.
93805>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
93807>>>        Integer iCh iCount
93807>>>        Number nByteCount
93807>>>        String[] asFileListArray sEmptyArray
93809>>>        String sLine
93809>>>        UChar[] uCharData
93810>>>        
93810>>>        Move False to Err
93811>>>        Get Seq_New_Channel to iCh
93812>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93814>>>            Error DFERR_PROGRAM 'No channel available...'
93815>>>>
93815>>>            Function_Return sEmptyArray
93816>>>        End
93816>>>>
93816>>>
93816>>>        // First decide the size of the script
93816>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
93818>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
93820>>>        Close_Input channel iCh
93822>>>        Send Seq_Release_Channel iCh
93823>>>
93823>>>        Function_Return uCharData
93824>>>    End_Function    
93825>>>    
93825>>>    // Writes a copy of the workspace Filelist.cfg to disk.
93825>>>    // It does so by reading from a memory resource, as the file has
93825>>>    // been compiled into the program.
93825>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
93827>>>        Boolean bOK bErr
93827>>>        Integer iSize iCh
93827>>>        
93827>>>        Move Err to bErr
93828>>>        Move False to Err
93829>>>        Move False to bOK
93830>>>        Move (SizeOfArray(asFileListArray)) to iSize
93831>>>        If (iSize = 0) Begin
93833>>>            Function_Return False
93834>>>        End
93834>>>>
93834>>>
93834>>>        Get Seq_New_Channel to iCh
93835>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93837>>>            Error DFERR_PROGRAM 'No channel available...'
93838>>>>
93838>>>            Function_Return False
93839>>>        End                      
93839>>>>
93839>>>        
93839>>>        Direct_Output channel iCh sFileListName
93841>>>        Writeln channel iCh asFileListArray
93844>>>                
93844>>>        Close_Input channel iCh
93846>>>        Send Seq_Release_Channel iCh
93847>>>        Move (not(Err)) to bOK
93848>>>        Move bErr to Err
93849>>>        
93849>>>        Function_Return bOK
93850>>>    End_Function
93851>>>
93851>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
93851>>>    // It first deletes the .cch file (if any).
93851>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
93853>>>        Boolean bOK bFound bExists bErr
93853>>>        Integer iCh iSize iCount
93853>>>        String sFileName sCCHFileName sVal
93853>>>        String[] asIntFile
93854>>>        
93854>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93855>>>        Move Err to bErr   
93856>>>        Move False to Err
93857>>>        Move False to bOK
93858>>>
93858>>>        Get SavedIntFileData sDataPath sIntFileName to asIntFile
93859>>>        Move (SizeOfArray(asIntFile)) to iSize
93860>>>        If (iSize = 0) Begin
93862>>>            Function_Return False        
93863>>>        End                      
93863>>>>
93863>>>        Decrement iSize
93864>>>        
93864>>>        Get Seq_New_Channel to iCh
93865>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93867>>>            Function_Return False
93868>>>        End   
93868>>>>
93868>>>        
93868>>>        // Before we start to actually create the new .int file, make sure we delete
93868>>>        // the .cch file.                                     
93868>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
93869>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
93870>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
93871>>>        If (bExists = True) Begin
93873>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
93874>>>            If (bOK = False) Begin
93876>>>                Function_Return False
93877>>>            End
93877>>>>
93877>>>        End
93877>>>>
93877>>>        
93877>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
93879>>>        For iCount from 0 to iSize
93885>>>>
93885>>>            Writeln channel iCh asIntFile[iCount]
93888>>>        Loop
93889>>>>
93889>>>        
93889>>>        Close_Input channel iCh
93891>>>        Send Seq_Release_Channel iCh
93892>>>        Move (not(Err)) to bOK
93893>>>        Move bErr to Err
93894>>>        
93894>>>        Function_Return bOK
93895>>>    End_Function   
93896>>>              
93896>>>    // Automatically writes .int files to disk that is missing.
93896>>>    // We only need to make this test this once, but because the message is called
93896>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
93896>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
93896>>>    Procedure AutoCreateIntFilesTable
93898>>>        Integer hTable 
93898>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
93898>>>        String sInfoTxt 
93898>>>        
93898>>>        Get phIntFilesTable to hTable  
93899>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93900>>>        If (bIntFilesTablesCheckDone = True) Begin
93902>>>            Procedure_Return
93903>>>        End
93903>>>>
93903>>>
93903>>>        If (hTable < 1) Begin
93905>>>            Set Private.pbIntFilesTablesCheckDone to False
93906>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93907>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
93908>>>>
93908>>>            Procedure_Return
93909>>>        End
93909>>>>
93909>>>        
93909>>>        Get IsIntFileTable hTable to bTableExists
93910>>>        If (bTableExists = True) Begin
93912>>>            Set Private.pbIntFilesTablesCheckDone to True
93913>>>            Procedure_Return
93914>>>        End
93914>>>>
93914>>>
93914>>>        Send SubCreateIntFilesTable hTable
93915>>>    End_Procedure
93916>>>                
93916>>>    Procedure SubCreateIntFilesTable Handle hTable
93918>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
93918>>>        Boolean bTableExists bOK bUseConnectionID bExists
93918>>>        tAPIColumn[] APIColumn
93918>>>        tAPIColumn[] APIColumn
93919>>>
93919>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93920>>>        If (bTableExists = True) Begin
93922>>>            Procedure_Return
93923>>>        End
93923>>>>
93923>>>
93923>>>        Move False to Err
93924>>>        Get psDriverID to sDriverID
93925>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93926>>>
93926>>>        Move CS_IntFilesTableLogicalName to sTableName
93927>>>
93927>>>        Move 1                  to APIColumn[0].iFieldNumber
93928>>>        Move "ID"               to APIColumn[0].sFieldName
93929>>>        Move DF_BCD             to APIColumn[0].iType
93930>>>        Move False              to APIColumn[0].bIsSQLType
93931>>>        Move 12                 to APIColumn[0].iLength
93932>>>        Move 0                  to APIColumn[0].iPrecision
93933>>>
93933>>>        Move 2                  to APIColumn[1].iFieldNumber
93934>>>        Move "IntFileName"      to APIColumn[1].sFieldName
93935>>>        Move DF_ASCII           to APIColumn[1].iType
93936>>>        Move False              to APIColumn[1].bIsSQLType
93937>>>        Move 50                 to APIColumn[1].iLength
93938>>>        Move 0                  to APIColumn[1].iPrecision
93939>>>
93939>>>        Move 3                  to APIColumn[2].iFieldNumber
93940>>>        Move "IntLineText"      to APIColumn[2].sFieldName
93941>>>        Move DF_ASCII           to APIColumn[2].iType
93942>>>        Move False              to APIColumn[2].bIsSQLType
93943>>>        Move 100                to APIColumn[2].iLength
93944>>>        Move 0                  to APIColumn[2].iPrecision
93945>>>
93945>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93946>>>        
93946>>>        If (bOK = True and Err = False) Begin
93948>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93949>>>        End
93949>>>>
93949>>>        Else Begin
93950>>>            Set Private.pbIntFilesTablesCheckDone to False
93951>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93952>>>            Error DFERR_PROGRAM sInfoTxt
93953>>>>
93953>>>            Procedure_Return
93954>>>        End
93954>>>>
93954>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93955>>>        
93955>>>        Open hTable
93957>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
93958>>>        If (bOK = True) Begin
93960>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
93961>>>        End
93961>>>>
93961>>>        If (bOK = False) Begin
93963>>>            Set Private.pbIntFilesTablesCheckDone to False
93964>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93965>>>            Error DFERR_PROGRAM sInfoTxt
93966>>>>
93966>>>            Procedure_Return
93967>>>        End
93967>>>>
93967>>>        
93967>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
93967>>>        If (sDriverID <> DATAFLEX_ID) Begin
93969>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93970>>>            Get vFolderFormat sDataPath to sDataPath
93971>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
93972>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
93973>>>            If (bExists = True) Begin
93975>>>                Move CS_IntFilesTableLogicalName to sTableName
93976>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
93977>>>                If (bExists = True) Begin
93979>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
93980>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
93981>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
93982>>>                End
93982>>>>
93982>>>            End
93982>>>>
93982>>>        End
93982>>>>
93982>>>        
93982>>>        Set Private.pbIntFilesTablesCheckDone to True
93983>>>    End_Procedure
93984>>>
93984>>>    Procedure CheckAutoCreateDbVersionTable
93986>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
93986>>>        Integer iDbVersionFileNumber
93986>>>
93986>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
93987>>>        If (bDbVersionCheckDone = True) Begin
93989>>>            Procedure_Return
93990>>>        End
93990>>>>
93990>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
93991>>>        If (bUseCustomDbVersion = True) Begin
93993>>>            Procedure_Return
93994>>>        End
93994>>>>
93994>>>
93994>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
93995>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
93996>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
93998>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93999>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94000>>>>
94000>>>            Send Exit_Application
94001>>>        End
94001>>>>
94001>>>
94001>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94002>>>        If (bTableExists = True) Begin
94004>>>            Set Private.pbDbVersionCheckDone to True
94005>>>            Procedure_Return
94006>>>        End
94006>>>>
94006>>>
94006>>>        Send CreateDbVersionTable iDbVersionFileNumber
94007>>>
94007>>>        // We only need to these DbVersion checks once, but because this message is called
94007>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94007>>>        // we use a property to only run these tests once.
94007>>>        Set Private.pbDbVersionCheckDone to True
94008>>>    End_Procedure
94009>>>
94009>>>    Procedure CreateDbVersionTable Handle hTable
94011>>>        String sTableName sColumnName sInfoTxt sDriverID 
94011>>>        Boolean bTableExists bOK bUseConnectionID
94011>>>        tAPIColumn[] APIColumn
94011>>>        tAPIColumn[] APIColumn
94012>>>
94012>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94013>>>        If (bTableExists = True) Begin
94015>>>            Procedure_Return
94016>>>        End
94016>>>>
94016>>>
94016>>>        Get psDriverID to sDriverID
94017>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94018>>>
94018>>>        Move "DbVersion"        to sTableName
94019>>>        Move 1                  to APIColumn[0].iFieldNumber
94020>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94021>>>        Move DF_BCD             to APIColumn[0].iType
94022>>>        Move False              to APIColumn[0].bIsSQLType
94023>>>        Move 4                  to APIColumn[0].iLength
94024>>>        Move 2                  to APIColumn[0].iPrecision
94025>>>
94025>>>        Move False to Err                                
94026>>>        
94026>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94026>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94026>>>        Set psDriverID to DATAFLEX_ID
94027>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94028>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94029>>>        Set psDriverID to sDriverID
94030>>>        
94030>>>        If (bOK = True and Err = False) Begin
94032>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94032>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94033>>>        End
94033>>>>
94033>>>        Else Begin
94034>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94035>>>        End
94035>>>>
94035>>>
94035>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94036>>>    End_Procedure
94037>>>
94037>>>    Procedure Set pbVerboseState Boolean bVerboseState
94039>>>        Handle ho
94039>>>        Get phoLogFile to ho
94040>>>        Set pbVerboseState of ho to bVerboseState
94041>>>    End_Procedure
94042>>>
94042>>>    Function pbVerboseState Returns Boolean
94044>>>        Boolean bVerboseState
94044>>>        Handle ho
94044>>>        Get phoLogFile to ho
94045>>>        Get pbVerboseState of ho to bVerboseState
94046>>>        Function_Return bVerboseState
94047>>>    End_Function
94048>>>
94048>>>    // Callback functionality used when e.g. calling driver functions directly.
94048>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94048>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94050>>>        Integer iPerc
94050>>>        Number nReady nTotal nVersion
94050>>>        Boolean bVerboseState
94050>>>        Handle hoLogFile
94050>>>
94050>>>        Get pbVerboseState to bVerboseState
94051>>>        Get pnCurrentVersionUpdate to nVersion
94052>>>        Get phoLogFile     to hoLogFile
94053>>>        Send DoAdvance of ghoProgressBar
94054>>>
94054>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94056>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94057>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94058>>>        End
94058>>>>
94058>>>        If (sCallback_Text contains "Creating index") Begin
94060>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94061>>>        End
94061>>>>
94061>>>
94061>>>        Case Begin
94061>>>            Case (iCallback_Type = DF_Message_Text)
94063>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94064>>>                Set Action_Text  of ghoStatusPanel to ""
94065>>>                If (bVerboseState = True) Begin
94067>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94068>>>                End
94068>>>>
94068>>>                Case Break
94069>>>            Case (iCallback_Type = DF_Message_Heading_1)
94072>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94073>>>                If (bVerboseState = True) Begin
94075>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94076>>>                End
94076>>>>
94076>>>                Case Break
94077>>>            Case (iCallback_Type = DF_Message_Heading_2)
94080>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94081>>>                Set Action_Text  of ghoStatusPanel to ""
94082>>>                If (bVerboseState = True) Begin
94084>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94085>>>                End
94085>>>>
94085>>>                Case Break
94086>>>            Case (iCallback_Type = DF_Message_Heading_3)
94089>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94090>>>                Set Action_Text  of ghoStatusPanel to ""
94091>>>                If (bVerboseState = True) Begin
94093>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94094>>>                End
94094>>>>
94094>>>                Case Break
94095>>>            Case (iCallback_Type = DF_Message_Heading_4)
94098>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94099>>>                Set Action_Text  of ghoStatusPanel to ""
94100>>>                If (bVerboseState = True) Begin
94102>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94103>>>                End
94103>>>>
94103>>>                Case Break
94104>>>            Case (iCallback_Type = DF_Message_Heading_5)
94107>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94108>>>                Set Action_Text  of ghoStatusPanel to ""
94109>>>                If (bVerboseState = True) Begin
94111>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94112>>>                End
94112>>>>
94112>>>                Case Break
94113>>>            Case (iCallback_Type = DF_Message_Warning)
94116>>>                If (bVerboseState = True) Begin
94118>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94119>>>                End
94119>>>>
94119>>>                Case Break
94120>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94123>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94124>>>                Set Action_Text  of ghoStatusPanel to ""
94125>>>                If (bVerboseState = True) Begin
94127>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94128>>>                End
94128>>>>
94128>>>                Case Break
94129>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94132>>>                //*** Interpret numbers
94132>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94133>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94134>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94135>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94136>>>                Set piPosition of ghoProgressBar to iPerc
94137>>>                Case Break
94138>>>            Case Else
94138>>>                Set Message_Text to ""
94139>>>                Set Action_Text  to ""
94140>>>        Case End
94140>>>
94140>>>        Send ProcessEvents of ghoStatusPanel
94141>>>        Function_Return False
94142>>>    End_Function
94143>>>
94143>>>    // This was made to be a procedure/function pair so we
94143>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94143>>>
94143>>>    Procedure Set piDbType Integer iDbType
94145>>>        If (ghoSQLConnectionHandler = 0) Begin
94147>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94148>>>>
94148>>>            Procedure_Return
94149>>>        End
94149>>>>
94149>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94150>>>    End_Procedure
94151>>>
94151>>>    Function piDbType Returns Integer
94153>>>        Integer iDbType
94153>>>        If (ghoSQLConnectionHandler = 0) Begin
94155>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94156>>>>
94156>>>            Function_Return ""
94157>>>        End
94157>>>>
94157>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94158>>>        Function_Return iDbType
94159>>>    End_Function
94160>>>
94160>>>    Procedure Set psDriverID String sDriverID
94162>>>        If (ghoSQLConnectionHandler = 0) Begin
94164>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94165>>>>
94165>>>            Procedure_Return
94166>>>        End
94166>>>>
94166>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94167>>>    End_Procedure
94168>>>
94168>>>    Function psDriverID Returns String
94170>>>        String sValue
94170>>>        If (ghoSQLConnectionHandler = 0) Begin
94172>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94173>>>>
94173>>>            Function_Return ""
94174>>>        End
94174>>>>
94174>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94175>>>        Function_Return sValue
94176>>>    End_Function
94177>>>
94177>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94179>>>        If (ghoSQLConnectionHandler = 0) Begin
94181>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94182>>>>
94182>>>            Procedure_Return
94183>>>        End
94183>>>>
94183>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94184>>>    End_Procedure
94185>>>
94185>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94187>>>        Integer iRetval
94187>>>        If (ghoSQLConnectionHandler = 0) Begin
94189>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94190>>>>
94190>>>            Function_Return 2
94191>>>        End
94191>>>>
94191>>>
94191>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94192>>>        Function_Return iRetval
94193>>>    End_Function
94194>>>
94194>>>    Procedure Set psConnectionID String sValue
94196>>>        If (ghoSQLConnectionHandler = 0) Begin
94198>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94199>>>>
94199>>>            Procedure_Return
94200>>>        End
94200>>>>
94200>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94201>>>    End_Procedure
94202>>>
94202>>>    Function psConnectionID Returns String
94204>>>        String sValue
94204>>>        If (ghoSQLConnectionHandler = 0) Begin
94206>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94207>>>>
94207>>>            Function_Return ""
94208>>>        End
94208>>>>
94208>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94209>>>
94209>>>        Function_Return sValue
94210>>>    End_Function
94211>>>
94211>>>    // These "properties" are settings of the cCLIHandler class, but are being
94211>>>    // relayed to the ghoSQLConnectionHandler object
94211>>>    // simply by changing one of its parameters.
94211>>>    Procedure Set psServer String sValue
94213>>>        If (ghoSQLConnectionHandler = 0) Begin
94215>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94216>>>>
94216>>>            Procedure_Return
94217>>>        End
94217>>>>
94217>>>        Set psServer of ghoSQLConnectionHandler to sValue
94218>>>    End_Procedure
94219>>>
94219>>>    Function psServer Returns String
94221>>>        String sValue
94221>>>        If (ghoSQLConnectionHandler = 0) Begin
94223>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94224>>>>
94224>>>            Function_Return ""
94225>>>        End
94225>>>>
94225>>>        Get psServer of ghoSQLConnectionHandler to sValue
94226>>>
94226>>>        Function_Return sValue
94227>>>    End_Function
94228>>>
94228>>>    Procedure Set psDatabase String sValue
94230>>>        If (ghoSQLConnectionHandler = 0) Begin
94232>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94233>>>>
94233>>>            Procedure_Return
94234>>>        End
94234>>>>
94234>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94235>>>    End_Procedure
94236>>>
94236>>>    Function psDatabase Returns String
94238>>>        String sValue
94238>>>        If (ghoSQLConnectionHandler = 0) Begin
94240>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94241>>>>
94241>>>            Function_Return ""
94242>>>        End
94242>>>>
94242>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94243>>>
94243>>>        Function_Return sValue
94244>>>    End_Function
94245>>>
94245>>>    Procedure Set psUserID String sValue
94247>>>        If (ghoSQLConnectionHandler = 0) Begin
94249>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94250>>>>
94250>>>            Procedure_Return
94251>>>        End
94251>>>>
94251>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94252>>>    End_Procedure
94253>>>
94253>>>    Function psUserID Returns String
94255>>>        String sValue
94255>>>        If (ghoSQLConnectionHandler = 0) Begin
94257>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94258>>>>
94258>>>            Function_Return ""
94259>>>        End
94259>>>>
94259>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94260>>>
94260>>>        Function_Return sValue
94261>>>    End_Function
94262>>>
94262>>>    Procedure Set psPassword String sValue
94264>>>        If (ghoSQLConnectionHandler = 0) Begin
94266>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94267>>>>
94267>>>            Procedure_Return
94268>>>        End
94268>>>>
94268>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94269>>>    End_Procedure
94270>>>
94270>>>    Function psPassword Returns String
94272>>>        String sValue
94272>>>        If (ghoSQLConnectionHandler = 0) Begin
94274>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94275>>>>
94275>>>            Function_Return ""
94276>>>        End
94276>>>>
94276>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94277>>>
94277>>>        Function_Return sValue
94278>>>    End_Function
94279>>>
94279>>>    Procedure Set pbTrusted Boolean bValue
94281>>>        If (ghoSQLConnectionHandler = 0) Begin
94283>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94284>>>>
94284>>>            Procedure_Return
94285>>>        End
94285>>>>
94285>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94286>>>    End_Procedure
94287>>>
94287>>>    Function pbTrusted Returns Boolean
94289>>>        Boolean bValue
94289>>>        If (ghoSQLConnectionHandler = 0) Begin
94291>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94292>>>>
94292>>>            Function_Return False
94293>>>        End
94293>>>>
94293>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94294>>>
94294>>>        Function_Return bValue
94295>>>    End_Function
94296>>>
94296>>>    Procedure Set psConnectionString String sValue
94298>>>        If (ghoSQLConnectionHandler = 0) Begin
94300>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94301>>>>
94301>>>            Procedure_Return
94302>>>        End
94302>>>>
94302>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94303>>>    End_Procedure
94304>>>
94304>>>    Function psConnectionString Returns String
94306>>>        String sValue
94306>>>        If (ghoSQLConnectionHandler = 0) Begin
94308>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94309>>>>
94309>>>            Function_Return ""
94310>>>        End
94310>>>>
94310>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94311>>>
94311>>>        Function_Return sValue
94312>>>    End_Function
94313>>>
94313>>>    Function piConnectionOptions Returns Integer
94315>>>        Integer iValue
94315>>>        If (ghoSQLConnectionHandler = 0) Begin
94317>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94318>>>>
94318>>>            Function_Return 0
94319>>>        End
94319>>>>
94319>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94320>>>
94320>>>        Function_Return iValue
94321>>>    End_Function
94322>>>
94322>>>
94322>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94324>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94325>>>    End_Procedure
94326>>>
94326>>>    Function pbCheckDataFlexUserCount Returns Boolean
94328>>>        Boolean bState
94328>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94329>>>        Function_Return bState
94330>>>    End_Function
94331>>>
94331>>>    Procedure Set psLogTextFile String sValue
94333>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94334>>>    End_Procedure
94335>>>
94335>>>    Function psLogTextFile Returns String
94337>>>        String sValue
94337>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94338>>>        Function_Return sValue
94339>>>    End_Function
94340>>>
94340>>>    Procedure Set psEditorProgram String sValue
94342>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94343>>>    End_Procedure
94344>>>
94344>>>    Function psEditorProgram Returns String
94346>>>        String sValue
94346>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94347>>>        Function_Return sValue
94348>>>    End_Function
94349>>>
94349>>>    Procedure Set pbUseDataTableLog Boolean bState
94351>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94352>>>    End_Procedure
94353>>>
94353>>>    Function pbUseDataTableLog Returns Boolean
94355>>>        Boolean bState
94355>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94356>>>        Function_Return bState
94357>>>    End_Function
94358>>>
94358>>>    Procedure Set pbQuickWrite Boolean bState
94360>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94361>>>    End_Procedure
94362>>>
94362>>>    Function pbQuickWrite Returns Boolean
94364>>>        Boolean bState
94364>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94365>>>        Function_Return bState
94366>>>    End_Function
94367>>>
94367>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94369>>>        Boolean bUpdateVersionObjectError bVerboseState
94369>>>        Integer iSize iCount
94369>>>        Number nVersion
94369>>>        String[] aSQLQueryMessages
94370>>>
94370>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94371>>>        Set Private.pbDatabaseWasUpdated to bState
94372>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94372>>>        // to the log that it was OK.
94372>>>        If (bUpdateVersionObjectError = False) Begin
94374>>>            Get pnCurrentVersionUpdate to nVersion
94375>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94376>>>        End
94376>>>>
94376>>>
94376>>>        Get pbVerboseState to bVerboseState
94377>>>        If (bVerboseState = True) Begin
94379>>>            Get paSQLQueryMessages to aSQLQueryMessages
94380>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94381>>>            Decrement iSize
94382>>>            For iCount from 0 to iSize
94388>>>>
94388>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94389>>>            Loop
94390>>>>
94390>>>        End
94390>>>>
94390>>>
94390>>>    End_Procedure 
94391>>>    
94391>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94393>>>        Set Private.piDbVersionFileNumber to iFileNumber
94394>>>    End_Procedure                                         
94395>>>    
94395>>>    Function piDbVersionFileNumber Returns Integer
94397>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94398>>>    End_Function
94399>>>
94399>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94401>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94402>>>    End_Procedure                                         
94403>>>    
94403>>>    Function piDbVersionFieldNumber Returns Integer
94405>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94406>>>    End_Function
94407>>>
94407>>>    Function pbDatabaseWasUpdated Returns Boolean
94409>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94410>>>    End_Function
94411>>>    
94411>>>    //
94411>>>    Procedure ReinitializeFramework  
94413>>>        tDbVersionInfo[] aDbVersionInfoArray
94413>>>        tDbVersionInfo[] aDbVersionInfoArray
94414>>>        Handle hoDbVersionObject
94414>>>        Integer iSize iCount
94414>>>        
94414>>>        Set Private.pbDatabaseUpdateStarted to False
94415>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94416>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94417>>>        Decrement iSize
94418>>>        
94418>>>        For iCount from 0 to iSize
94424>>>>
94424>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94425>>>            Send ProcessUpdate                  of hoDbVersionObject False
94426>>>        Loop
94427>>>>
94427>>>        Send Cleanup
94428>>>    End_Procedure
94429>>>    
94429>>>    Procedure StartStatusPanel
94431>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94432>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94433>>>        Send Start_StatusPanel      of ghoStatusPanel
94434>>>    End_Procedure
94435>>>    
94435>>>    // This event is triggered by the cDbUpdateVersion child class when
94435>>>    // a database change is to be started, and is considered private.
94435>>>    // It is only executed once for the first cDbUpateVersion object!
94435>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94437>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94437>>>        Integer iRetval iDataFlexUsers iUserCount
94437>>>        Handle hoUserCountSystem
94437>>>        tUserCount UserCount
94437>>>        tUserCount UserCount
94437>>>        DateTime dtUpdateStarted
94437>>>        tSQLConnection SQLConnection
94437>>>        tSQLConnection SQLConnection
94437>>>
94437>>>        // *Important:* If we already started the update; we do no further checking.
94437>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94438>>>        If (bDatabaseUpdateStarted = True) Begin
94440>>>            Procedure_Return
94441>>>        End
94441>>>>
94441>>>
94441>>>        // If not silent mode; Ask user if OK to start database update.
94441>>>        If (pbSilentMode(Self) = False) Begin
94443>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94444>>>            If (iRetval <> MBR_Yes) Begin
94446>>>                Send Exit_Application
94447>>>            End
94447>>>>
94447>>>        End
94447>>>>
94447>>>        
94447>>>        Send StartStatusPanel
94448>>>        // This will save the status of all open tables including Master/Alias settings,
94448>>>        // so we can restore them later;
94448>>>        Send SaveOpenTables
94449>>>
94449>>>        Move 0 to iDataFlexUsers
94450>>>        // Make various tests to check that the database is not in use.
94450>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94451>>>        // We also use our own user counting mechanism to guard against the
94451>>>        // database isn't opened already as we need exclusive access to the tables.:
94451>>>        Get phoUserCountSystem to hoUserCountSystem
94452>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94453>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94454>>>
94454>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94455>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94455>>>        If (bCheckDataFlexUserCount = True) Begin
94457>>>            Get_Current_User_Count to iDataFlexUsers
94458>>>            // For some reason DataFlex - in some cases - might think that 2 users
94458>>>            // are in use while debugging from the Studio.
94458>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94460>>>                Decrement iDataFlexUsers
94461>>>            End
94461>>>>
94461>>>        End 
94461>>>>
94461>>>        Else Begin
94462>>>            Move 1 to iDataFlexUsers 
94463>>>            Move 1 to iUserCount
94464>>>            Move False to bInUse
94465>>>        End
94465>>>>
94465>>>
94465>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94467>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94468>>>            If (iRetval <> MBR_Yes) Begin
94470>>>                Send Exit_Application
94471>>>            End
94471>>>>
94471>>>        End
94471>>>>
94471>>>
94471>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94473>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94474>>>            Send Exit_Application
94475>>>        End
94475>>>>
94475>>>
94475>>>        // This will put a look on the DbUpdateLock.ucf file.
94475>>>        // It is released when the update process is finished
94475>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94476>>>
94476>>>        Move (CurrentDateTime()) to dtUpdateStarted
94477>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94478>>>        Set Private.pbDatabaseUpdateStarted to True
94479>>>
94479>>>        // We need to close all tables before starting to make changes.
94479>>>        Close DF_ALL DF_PERMANENT
94480>>>
94480>>>        // If these properties has not exclicitly been set in the object, set them
94480>>>        // to settings from the SQLConnections.ini file;
94480>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94481>>>        If (psSchema(Self) = "") Begin
94483>>>            Set psSchema            to SQLConnection.sSchema
94484>>>        End
94484>>>>
94484>>>        If (psBaseTableSpace(Self) = "") Begin
94486>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94487>>>        End
94487>>>>
94487>>>        If (psLongTableSpace(Self) = "") Begin
94489>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94490>>>        End
94490>>>>
94490>>>        If (psIndexTableSpace(Self) = "") Begin
94492>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94493>>>        End
94493>>>>
94493>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94495>>>            Procedure_Return
94496>>>        End
94496>>>>
94496>>>
94496>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94497>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94499>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94500>>>            Send Stop_StatusPanel of ghoStatusPanel
94501>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94501>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94502>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94502>>>            Send Exit_Application
94503>>>        End
94503>>>>
94503>>>    End_Procedure
94504>>>
94504>>>    // *** Hook message for pre-processing ***
94504>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94504>>>    // Aka, when another table than the standard "DbVersion" is used.
94504>>>    Procedure OnCreateCustomDbVersionTable
94506>>>    End_Procedure
94507>>>    
94507>>>    // *** Hook message for pre-processing ***
94507>>>    // The programmer can use this event for putting code that
94507>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94507>>>    // child objects are executed.
94507>>>    Procedure OnPreUpdate
94509>>>    End_Procedure
94510>>>
94510>>>    // *** Hook message for post-processing ***
94510>>>    // The programmer should use this event for putting code that
94510>>>    // needs to be executed _after_ all database updates have finished.
94510>>>    Procedure OnPostUpdate
94512>>>    End_Procedure
94513>>>
94513>>>    // *** Hook message for custom DbVersion record find ***
94513>>>    // The programmer can use this event for putting code that
94513>>>    // needs to be executed to find a *custom* DbVersion table record.
94513>>>    // By default the DbVersion table is used but this can be
94513>>>    // customized by adding this line to the code;
94513>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94513>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94513>>>    //       to save the current database version to. Only if you use your own
94513>>>    //       table _and_ it is not a system table (contains only one record).
94513>>>    Procedure OnFindVersionRecord
94515>>>        // Open MyTable
94515>>>        // Move xx to MyTable.Field1
94515>>>        // Move yy to MyTable.Field2
94515>>>        // Find le MyTable by Index.x
94515>>>    End_Procedure
94516>>>
94516>>>    // Hook event for writing header error text (pre-update) to
94516>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94516>>>    // Don't forget to Open the table first (!) as all
94516>>>    // tables have been closed at this stage.
94516>>>    // The start date & time is passed.
94516>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94518>>>    End_Procedure
94519>>>
94519>>>    // Hook event to log errors to a database table.
94519>>>    // Only called if the pbUseDataTableLog = True.
94519>>>    // Don't forget to Open the table first (!) as all
94519>>>    // tables have been closed at this stage.
94519>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94519>>>    // will contain just one row, as it is called for each error
94519>>>    // that occurred. Else it is called once at the end after all updates
94519>>>    // have run and contains all errors.
94519>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94521>>>    End_Procedure
94522>>>
94522>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94522>>>    Procedure Cleanup
94524>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup
94524>>>
94524>>>        Send CheckAutoCreateDbVersionTable
94525>>>        Send RestoreOpenTables
94526>>>
94526>>>        // The function library have two purposes; one is to use it in the
94526>>>        // Database Update Framework, but it can also be used on its own.
94526>>>        // If that is the case it has its own error handling system, which
94526>>>        // we temporarily disbled when running updates because we have
94526>>>        // error handling/logging here too... We now restore its setting.
94526>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94528>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94529>>>        End
94529>>>>
94529>>>        Set pbHandleQueryErrors to True
94530>>>
94530>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94531>>>        Get pbDbUpdateErrorHasOccured to bError
94532>>>        If (bDatabaseWasUpdated = True and bError = False) Begin
94534>>>            // Check/create/update *.int files backup table:
94534>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
94535>>>            If (bUseIntFilesBackup = True) Begin
94537>>>                Send SaveUpdateIntFiles
94538>>>            End
94538>>>>
94538>>>        End            
94538>>>>
94538>>>            
94538>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94540>>>
94540>>>            // We should always create the log as it also contains info about
94540>>>            // the update being successful.
94540>>>            Send WriteErrorLog of (phoLogFile(Self))
94541>>>
94541>>>            // This is a programmer's hook message:
94541>>>            Send OnPostUpdate
94542>>>
94542>>>            Send Stop_StatusPanel of ghoStatusPanel
94543>>>
94543>>>            If (pbSilentMode(Self) = False) Begin
94545>>>                If (bError = True) Begin
94547>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94549>>>                        Send ShowErrorLog of (phoLogFile(Self))
94550>>>                    End
94550>>>>
94550>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94551>>>                    Send Exit_Application
94552>>>                End
94552>>>>
94552>>>                Else Begin
94553>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94555>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94556>>>                    End
94556>>>>
94556>>>                    Else Begin
94557>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94558>>>                    End
94558>>>>
94558>>>                End
94558>>>>
94558>>>            End
94558>>>>
94558>>>        End
94558>>>>
94558>>>
94558>>>        // Restore the standard error handler:
94558>>>        Get piOrgErrorHandlerID to Error_Object_Id
94559>>>    End_Procedure
94560>>>
94560>>>    // We do this _before_ we close the database to make changes, and save
94560>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94560>>>    // we reopen the database.
94560>>>    Procedure SaveOpenTables
94562>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94562>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94563>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94564>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94565>>>    End_Procedure
94566>>>
94566>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94566>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94566>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94568>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94568>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94569>>>        Integer hTable iMasterAliasType iSize
94569>>>        Boolean bOpen
94569>>>
94569>>>        Move 0 to hTable
94570>>>        Repeat
94570>>>>
94570>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94573>>>            If (hTable <> 0) Begin
94575>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94578>>>                If (bOpen = True) Begin
94580>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94583>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94584>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94585>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94586>>>                End
94586>>>>
94586>>>            End
94586>>>>
94586>>>        Until (hTable = 0)
94588>>>
94588>>>        Function_Return aDbUpdateHandlerMasterAlias
94589>>>    End_Function
94590>>>
94590>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94590>>>    // Takes one parameter:
94590>>>    //   A struct array with all master & alias
94590>>>    Procedure RestoreOpenTables
94592>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94592>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94593>>>        Integer hTable iFileAlias iSize iCount
94593>>>        Boolean bOpen
94593>>>        String sRootName
94593>>>
94593>>>        Move 0 to hTable
94594>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94595>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94596>>>        Decrement iSize
94597>>>        For iCount from 0 to iSize
94603>>>>
94603>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94604>>>            // We also need to check that the table hasn't been removed...
94604>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94607>>>            If (hTable <> 0 and sRootName <> "") Begin
94609>>>                Open hTable
94611>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94614>>>                If (bOpen = True) Begin
94616>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94617>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94619>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94622>>>                    End
94622>>>>
94622>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94625>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94628>>>                    End
94628>>>>
94628>>>                End
94628>>>>
94628>>>            End
94628>>>>
94628>>>        Loop
94629>>>>
94629>>>    End_Procedure
94630>>>
94630>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94630>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94630>>>    Procedure CheckForDuplicates Number nVersion
94632>>>        tDbVersionInfo[] DbVersionInfoArray
94632>>>        tDbVersionInfo[] DbVersionInfoArray
94633>>>        Integer iCount iSize iHits iDuplicateIndex
94633>>>        Number nCompare
94633>>>        Handle hObject1 hObject2
94633>>>        String sObjectName1 sObjectName2
94633>>>        Boolean bObjectOrderError
94633>>>
94633>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94634>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94635>>>        Decrement iSize
94636>>>        Move 0 to iHits
94637>>>        Move 0 to nCompare
94638>>>        Move False to bObjectOrderError
94639>>>        For iCount from 0 to iSize
94645>>>>
94645>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94647>>>                Increment iHits
94648>>>                If (iHits > 1) Begin
94650>>>                    Move iCount to iDuplicateIndex
94651>>>                    If (nCompare <> 0) Begin
94653>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94654>>>                    End
94654>>>>
94654>>>                End
94654>>>>
94654>>>            End
94654>>>>
94654>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94655>>>        Loop
94656>>>>
94656>>>        If (iHits > 1) Begin
94658>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94659>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94660>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94661>>>            Move (Name(hObject1)) to sObjectName1
94662>>>            Move (Name(hObject2)) to sObjectName2
94663>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94664>>>>
94664>>>            Send Exit_Application
94665>>>        End
94665>>>>
94665>>>        Else If (bObjectOrderError = True) Begin
94668>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94669>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94670>>>>
94670>>>            Send Exit_Application
94671>>>        End
94671>>>>
94671>>>    End_Procedure
94672>>>
94672>>>    // We take care of all errors in the Error_Report below and
94672>>>    // collect them all to an array property. So just ignore any
94672>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94672>>>    // in some other package.
94672>>>    Procedure Ignore_Error Integer iError
94674>>>    End_Procedure
94675>>>
94675>>>    Procedure Trap_Error Integer iError
94677>>>    End_Procedure
94678>>>
94678>>>    // Build complete error description from Flexerrs and user error message.
94678>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94680>>>        String Full_Error_Text
94680>>>        
94680>>>        Move (Trim(ErrMsg)) to ErrMsg
94681>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94682>>>        
94682>>>        If (ErrMsg <> "") Begin
94684>>>            
94684>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94686>>>                // Make sure last character of error text is a separating symbol.
94686>>>                // if not, add a "." So we have format of "error-text. error-detail"
94686>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
94689>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
94690>>>            End
94690>>>>
94690>>>            Else ;                Move ErrMsg to Full_Error_Text
94692>>>            
94692>>>        End
94692>>>>
94692>>>        
94692>>>        Function_Return Full_Error_Text
94693>>>    End_Function
94694>>>
94694>>>    // While we update the database we collect all errors in
94694>>>    // the struct array paDbUpdateErrorArray.
94694>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94696>>>        Number nVersion
94696>>>        Handle hoLogFile 
94696>>>        
94696>>>        If (Private.pbProcessingError(Self)) Begin
94698>>>            Procedure_Return
94699>>>        End
94699>>>>
94699>>>
94699>>>        // The UtilTableNameFromHandleToString function does a:
94699>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
94699>>>        // and it generates an error if the table is of the embedded type.
94699>>>        // As we don't want to trigger an error in that very specific case,
94699>>>        // we just ignore it here.
94699>>>        //
94699>>>        // If no report mode, just set the err indicator to false.
94699>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
94701>>>            Set Private.pbProcessingError to False
94702>>>            Procedure_Return
94703>>>        End
94703>>>>
94703>>>
94703>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
94705>>>            Set Private.pbProcessingError to False
94706>>>            Procedure_Return
94707>>>        End
94707>>>>
94707>>>
94707>>>        Set Private.pbProcessingError to True
94708>>>        Set Private.pbUpdateVersionObjectError to True
94709>>>
94709>>>        Set pbDbUpdateErrorHasOccured to True
94710>>>        Get pnCurrentVersionUpdate to nVersion
94711>>>        Get phoLogFile to hoLogFile
94712>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
94713>>>
94713>>>        Set Private.pbProcessingError to False
94714>>>    End_Procedure
94715>>>
94715>>>End_Class
94716>
94716>Object oHtmlHelp is a cHtmlHelp
94718>    Set pbAlwaysOnTop to False
94719>
94719>    // Overriden class message to also handle internet HTML Help links;
94719>    // which in which case we should not try to find the path to the help file.
94719>    Function GetHelpFile Returns String
94722>        String sHelpFile
94722>
94722>        Get psHelpFile of ghoApplication to sHelpFile
94723>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
94725>            Get_File_Path sHelpFile to sHelpFile
94726>        End
94726>        Function_Return sHelpFile
94727>    End_Function
94728>
94728>End_Object
94729>
94729>Object oApplication is a cApplication
94731>    Set peHelpType to htHtmlHelp
94732>
94732>    // Note: These help file settings gets changed by the Help toolbar button(s).
94732>    Set psHelpFile to "Developer5.chm"
94733>
94733>    Set pbPreserveEnvironment to True
94734>    Set psProduct to "Database Update Framework Lab"
94735>    Set psCompany to "RDC Tools International" 
94736>
94736>    Object oConnection is a cConnection
94738>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
94738>>>Use cLoginEncryption.pkg
94738>>>
94738>>>Object oLoginEncryption is a cLoginEncryption
94740>>>
94740>>>    // this must be created in your appsrc directory and must contain an encryption
94740>>>    // key that is set to psEncryptPassword. It will look something like this
94740>>>    //
94740>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
94740>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
94740>>>>// Studio generated login encryption key
94740>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
94741>>>>
94741>>>    
94741>>>    // use this to register this object to your cConnection Object. This object
94741>>>    // must be created after the cConnection object
94741>>>    Move Self to ghoLoginEncryption
94742>>>End_Object
94743>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
94743>>>
94743>>>Use Windows.pkg
94743>>>Use cConnection.pkg
94743>>>Use dfLine.pkg
94743>>>
94743>>>Object oDatabaseLoginDialog is a ModalPanel
94745>>>    Set Label to "Database Login"
94746>>>    Set Location to 2 2
94747>>>    Set Size to 110 211
94748>>>    
94748>>>    Property String psId
94750>>>    Property Boolean pbOk False
94752>>>    Property Boolean pbChanged False
94754>>>    Property Boolean pbAllowRemember True
94756>>>    
94756>>>    // this registers this object with the cConnection object.
94756>>>    Move Self to ghoLoginConnectDialog
94757>>>    
94757>>>    Object oUserIDForm is a Form
94759>>>        Set Label to "User Name"
94760>>>        Set Size to 12 85
94761>>>        Set Location to 34 79
94762>>>        Set Label_Col_Offset to 64
94763>>>        Set peAnchors to anTopLeftRight
94764>>>    End_Object
94765>>>    
94765>>>    Object oPwdForm is a Form
94767>>>        Set Size to 12 85
94768>>>        Set Location to 49 79
94769>>>        Set Label_Col_Offset to 64
94770>>>        Set Password_State to True
94771>>>        Set peAnchors to anTopLeftRight
94772>>>        Set Label to "Password"
94773>>>    End_Object
94774>>>    
94774>>>    Object oTrustedConnection is a CheckBox
94776>>>        Set Size to 10 50
94777>>>        Set Location to 65 79
94778>>>        Set Label to "Trusted Connection"
94779>>>    End_Object
94780>>>    
94780>>>    Object oRemember is a CheckBox
94782>>>        Set Size to 10 50
94783>>>        Set Location to 79 14
94784>>>        Set Label to "Remember and don't ask again"
94785>>>        Set Checked_State to True
94786>>>    End_Object
94787>>>    
94787>>>    Object oLogin_btn is a Button
94789>>>        Set Label to "&Login"
94790>>>        Set Location to 92 102
94791>>>        Set peAnchors to anBottomRight
94792>>>        Set Default_State to True
94793>>>        
94793>>>        Procedure OnClick
94796>>>            Boolean bTrust
94796>>>            String sUser sPwd sConn sErr sId
94796>>>            Integer iError
94796>>>            Get psId to sId
94797>>>            Get Value of oUserIDForm to sUser
94798>>>            Get Value of oPwdForm to sPwd
94799>>>            Get Checked_State of oTrustedConnection to bTrust
94800>>>            
94800>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
94801>>>            If (iError=0) Begin
94803>>>                Set pbOk to True
94804>>>                Set pbChanged to True
94805>>>                Send Close_Panel
94806>>>            End
94806>>>>
94806>>>            Else Begin
94807>>>                Get psErrorText of ghoConnection to sErr
94808>>>                Send UserError sErr "Login Error"
94809>>>            End
94809>>>>
94809>>>        End_Procedure
94810>>>    End_Object
94811>>>    
94811>>>    Object oCancel_btn is a Button
94813>>>        Set Label to "&Cancel"
94814>>>        Set Location to 92 157
94815>>>        Set peAnchors to anBottomRight
94816>>>        
94816>>>        Procedure OnClick
94819>>>            Send Close_Panel
94820>>>        End_Procedure
94821>>>    End_Object
94822>>>    
94822>>>    Object oConnectionIdInfo is a TextBox
94824>>>        Set Size to 10 50
94825>>>        Set Location to 4 14
94826>>>        Set Label to 'Connection Id='
94827>>>    End_Object
94828>>>    
94828>>>    Object oConnectionServerInfo is a TextBox
94830>>>        Set Size to 10 50
94831>>>        Set Location to 16 14
94832>>>        Set Label to 'Server'
94833>>>    End_Object
94834>>>    
94834>>>    Object oLineControl1 is a LineControl
94836>>>        Set Size to 2 202
94837>>>        Set Location to 29 5
94838>>>    End_Object
94839>>>    
94839>>>    Function LoginConnectIdDialog String sId Returns Boolean
94842>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
94842>>>        String sUser sPwd sDescription
94842>>>        tConnection Connect
94842>>>        tConnection Connect
94842>>>        
94842>>>        Get pbAllowRemember to bAllowRemember
94843>>>        
94843>>>        
94843>>>        If not bAllowRemember Begin
94845>>>            Set Enabled_State of oRemember to bRemember
94846>>>            Set Visible_State of oRemember to bRemember
94847>>>        End
94847>>>>
94847>>>        
94847>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
94848>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
94849>>>        Set Value of oConnectionServerInfo to Connect.sString
94850>>>        
94850>>>        Set psId to sId
94851>>>        Set pbOk to False
94852>>>        Set pbChanged to False
94853>>>        Set Value of oUserIDForm to Connect.sUID
94854>>>        Set Value of oPwdForm to ""
94855>>>        
94855>>>        Send Popup
94856>>>        
94856>>>        Get pbOk to bOk
94857>>>        Get pbChanged to bChanged
94858>>>        If (bChanged and bOk) Begin
94860>>>            If bAllowRemember Begin
94862>>>                Get Checked_State of oRemember to bRemember
94863>>>                If bRemember Begin
94865>>>                    Get Checked_State of oTrustedConnection to bTrusted
94866>>>                    If not (bTrusted) Begin
94868>>>                        Get Value of oUserIDForm to sUser
94869>>>                        Get Value of oPwdForm to sPwd
94870>>>                    End
94870>>>>
94870>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
94871>>>                End
94871>>>>
94871>>>            End
94871>>>>
94871>>>        End
94871>>>>
94871>>>        Function_Return bOk
94872>>>    End_Function
94873>>>    
94873>>>    
94873>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
94874>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
94875>>>End_Object
94876>>>
94876>    End_Object
94877>
94877>End_Object   
94878>
94878>Object oDbUpdateHandler is a cDbUpdateHandler 
94880>    Set piDbVersionFileNumber to 255
94881>    Set piDbVersionFieldNumber to 1
94882>    
94882>End_Object
94883>
94883>Object oCJSkinFramework is a cCJSkinFramework
94885>    Set pbLoadPreference to True
94886>End_Object
94887>
94887>Object oToolTipController is a cToolTipController
94889>    Set piDurationPopup to 10000
94890>    Set piMaxWidth to 500
94891>    Move Self to ghoToolTipController
94892>End_Object
94893>
94893>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
94893>>>Use cCJStandardMenuItemClasses.pkg
94893>>>
94893>>>Object oEditContextMenu is a cCJContextMenu
94895>>>    
94895>>>    Move Self to Default_Form_Floating_Menu_ID
94896>>>    
94896>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94898>>>    End_Object
94899>>>    
94899>>>    Object oCutMenuItem is a cCJCutMenuItem
94901>>>        Set pbControlBeginGroup to True
94902>>>    End_Object
94903>>>    
94903>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94905>>>    End_Object
94906>>>
94906>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94908>>>    End_Object
94909>>>
94909>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94911>>>    End_Object
94912>>>
94912>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94914>>>        Set pbControlBeginGroup to True
94915>>>    End_Object
94916>>>
94916>>>End_Object
94917>>>
94917>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
94917>>>Use Windows.pkg
94917>>>Use cCJStandardMenuItemClasses.pkg
94917>>>Use cCJDeoMenuItemClasses.pkg
94917>>>
94917>>>
94917>>>Object oDEOEditContextMenu17 is a cCJContextMenu
94919>>>    
94919>>>    Move Self to Default_dbFloating_Menu_ID
94920>>>    
94920>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94922>>>    End_Object
94923>>>    
94923>>>    Object oCutMenuItem is a cCJCutMenuItem
94925>>>        Set pbControlBeginGroup to True
94926>>>    End_Object
94927>>>    
94927>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94929>>>    End_Object
94930>>>
94930>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94932>>>    End_Object
94933>>>
94933>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94935>>>    End_Object
94936>>>
94936>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94938>>>        Set pbControlBeginGroup to True
94939>>>    End_Object
94940>>>
94940>>>    Object oPromptMenuItem is a cCJPromptMenuItem
94942>>>        Set pbControlBeginGroup to True
94943>>>    End_Object
94944>>>
94944>>>    Object oFindNextMenu is a cCJFindNextMenuItem
94946>>>        Set pbControlBeginGroup to True
94947>>>    End_Object
94948>>>
94948>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
94950>>>    End_Object
94951>>>
94951>>>    Object oClearMenuItem is a cCJClearMenuItem
94953>>>        Set pbControlBeginGroup to True
94954>>>    End_Object
94955>>>
94955>>>    Object oClearAllMenu is a cCJClearAllMenuItem
94957>>>    End_Object
94958>>>
94958>>>    Object oSaveMenu is a cCJSaveMenuItem
94960>>>    End_Object
94961>>>    
94961>>>    Object oDeleteMenu is a cCJDeleteMenuItem
94963>>>    End_Object
94964>>>
94964>>>    Object oRememberitem is a cCJRememberFieldMenuItem
94966>>>        Set pbControlBeginGroup to True
94967>>>    End_Object
94968>>>
94968>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
94970>>>    End_Object
94971>>>
94971>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
94973>>>    End_Object
94974>>>
94974>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
94976>>>    End_Object
94977>>>
94977>>>End_Object
94978>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
94978>>>Use cCJCommandBarSystem.pkg
94978>>>Use Wingdi.pkg
94978>>>Use LanguageText.pkg
94978>>>
94978>>>// User interface constant strings:
94978>>>Define CS_NoSkinShort For "-None"
94978>>>Define CS_NoSkinLong  For "Do not use a skin"
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>
94978>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
94979>>>
94979>>>    Procedure Construct_Object
94981>>>        Forward Send Construct_Object
94983>>>
94983>>>        Set peControlType to xtpControlComboBox
94984>>>
94984>>>        Property tSkinInformation[] pSkins
94985>>>
94985>>>    End_Procedure
94986>>>
94986>>>    Procedure End_Construct_Object
94988>>>        Forward Send End_Construct_Object
94990>>>    End_Procedure
94991>>>
94991>>>    // Custom array sort for the tSkinInformation struct array.
94991>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
94991>>>    // Why?
94991>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
94991>>>    // create a custom sort algorithm.
94991>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
94991>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
94991>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
94991>>>    // randomly ordered. This custom sort method will take care of that.
94991>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
94993>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94995>>>            Function_Return (GT)
94996>>>        End
94996>>>>
94996>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94998>>>            Function_Return (LT)
94999>>>        End
94999>>>>
94999>>>        Function_Return (EQ)
95000>>>    End_Function
95001>>>
95001>>>    Procedure OnCreateControl Handle hoObj
95003>>>        Forward Send OnCreateControl hoObj
95005>>>
95005>>>        Send LoadSkins
95006>>>        Send FillComboList hoObj
95007>>>    End_Procedure
95008>>>
95008>>>    // Load all skins. We will only look for skins in expected
95008>>>    // directory which is the Programs folder.
95008>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95008>>>    // This is not the case with the 'standard' VDF behaviour.
95008>>>    Procedure LoadSkins
95010>>>        Integer iCount iItems iSize
95010>>>        Boolean bFound
95010>>>        String sFile sIni sSkin
95010>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95010>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95012>>>        tSkinInformation NoneRow
95012>>>        tSkinInformation NoneRow
95012>>>
95012>>>        If (ghoSkinFramework > 0) Begin
95014>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95015>>>
95015>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95016>>>            Move CS_NoSkinShort to NoneRow.sName
95017>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95018>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95019>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95020>>>
95020>>>            // Get the currently loaded skin.
95020>>>            Get psSkinFile of ghoSkinFramework to sFile
95021>>>            Get psSkinIni  of ghoSkinFramework to sIni
95022>>>
95022>>>            // Remove all Extra Large and Large skins from the array.
95022>>>            Move (SizeOfArray(SkinsArray)) to iItems
95023>>>            Decrement iItems
95024>>>            For iCount From 0 to iItems
95030>>>>
95030>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95031>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95032>>>                If (bFound = False) Begin
95034>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95035>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95036>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95037>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95038>>>                End
95038>>>>
95038>>>            Loop
95039>>>>
95039>>>            Set pSkins to SkinsArrayNoLarge
95040>>>        End
95040>>>>
95040>>>    End_Procedure
95041>>>
95041>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95041>>>    Procedure FillComboList Handle hoCombo
95043>>>        Integer iCount iItems iCurrent iTxtEntentSize
95043>>>        String  sFile sIni sCurrSkin
95043>>>        String  sSkin sSkinText
95043>>>        tSkinInformation[] SkinsArray
95043>>>        tSkinInformation[] SkinsArray
95044>>>        Integer iSize
95044>>>
95044>>>        If (ghoSkinFramework < 1) Begin
95046>>>            Procedure_Return
95047>>>        End
95047>>>>
95047>>>
95047>>>        // Get the currently loaded skin.
95047>>>        Get psSkinFile of ghoSkinFramework to sFile
95048>>>        Get psSkinIni  of ghoSkinFramework to sIni
95049>>>        Get pSkins to SkinsArray
95050>>>        Move (SizeOfArray(SkinsArray)) to iItems
95051>>>        Decrement iItems
95052>>>        Send ComClear of hoCombo
95053>>>
95053>>>        For iCount From 0 to iItems
95059>>>>
95059>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95060>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95061>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95062>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95063>>>            Get Text_Extent sSkinText to iSize
95064>>>            If (iSize > iTxtEntentSize) Begin
95066>>>                Move iSize to iTxtEntentSize
95067>>>            End
95067>>>>
95067>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95068>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95070>>>                Move iCount to iCurrent
95071>>>            End
95071>>>>
95071>>>        Loop
95072>>>>
95072>>>
95072>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95073>>>        Set ComDropDownWidth of hoCombo  to iSize
95074>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95075>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95076>>>    End_Procedure
95077>>>
95077>>>    // Event for when an item is selected from the comboform
95077>>>    Procedure OnExecute Variant vCommandBarControl
95079>>>        Handle  hoCombo
95079>>>        Integer iSelection
95079>>>        String  sSkinFile sSkinIni
95079>>>        tSkinInformation[] SkinsArray
95079>>>        tSkinInformation[] SkinsArray
95080>>>
95080>>>        // Create and bind proxy control
95080>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95081>>>        // Get the current selection
95081>>>        Get ComListIndex of hoCombo to iSelection
95082>>>        Decrement iSelection
95083>>>        Get pSkins to SkinsArray
95084>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95085>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95086>>>
95086>>>        Send DoChangeSkin sSkinFile sSkinIni
95087>>>
95087>>>        // Dispose of the proxy control
95087>>>        Send Destroy of hoCombo
95088>>>    End_Procedure
95089>>>
95089>>>    // Send this message to change the current skin.
95089>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95091>>>        Handle hoClient
95091>>>
95091>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95092>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95093>>>        Send ApplySkin of ghoSkinFramework
95094>>>
95094>>>        // Note: The following line is essential for the resizing logic
95094>>>        // to function properly when changing a skin and a view is maximized.
95094>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95095>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95096>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95097>>>    End_Procedure
95098>>>
95098>>>    // Returns: DPI setting as an integer.
95098>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95098>>>    //                      iDPI=120 is "Medium setting" 125%
95098>>>    //                      iDPI= 144 is "Large setting" 150%
95098>>>    Function GetCurrentDPI Returns Integer
95100>>>        Handle hDC
95100>>>        Integer iPixelsX
95100>>>        Move (GetDC(0)) to hDC
95101>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95102>>>        Move (ReleaseDC(0, hDC)) to hDC
95103>>>        Function_Return iPixelsX
95104>>>    End_Function
95105>>>
95105>>>End_Class
95106>
95106>Object oMain is a Panel
95108>    Set Label to "Test Program - The Database Update Framework"
95109>    Set Location to 2 2
95110>    Set Size to 309 493
95111>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95112>    Set Icon to "TestTools.ico"
95113>
95113>    Property Handle phoViewMenu 0
95115>    Property Handle phoReportMenu 0
95117>
95117>    Object oCommandBarSystem is a cCJCommandBarSystem
95119>        Set pbTimerUpdate to True
95120>            Set pbAutoResizeIcons to True
95121>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95122>            Set peVisualTheme to xtpThemeOffice2013Publisher
95123>            Set pbLargeIcons to True
95124>
95124>        Procedure OnCreateCommandBars
95127>            Handle hoOptions
95127>            Forward Send OnCreateCommandBars
95129>                Get OptionsObject to hoOptions
95130>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95131>        End_Procedure
95132>
95132>
95132>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95135>        Set ComShowIcons of hoTabPaintManager to True
95136>
95136>        // This will truncate the middle part of long items
95136>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95137>    End_Procedure
95138>
95138>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95138>        // the previous tab workspace view.
95138>        Object oPreviousTabAction is a cCJAction
95140>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95141>            Procedure OnExecute Variant vCommandBarControl
95144>                Handle hoCommandBars hoClientArea
95144>                Forward Send OnExecute vCommandBarControl
95146>                Get CommandBarSystemObject to hoCommandBars
95147>                Get ClientAreaObject of hoCommandBars to hoClientArea
95148>                If hoClientArea Begin
95150>                    Send Switch_Next_View of hoClientArea
95151>                End
95151>            End_Procedure
95152>        End_Object
95153>
95153>        Object oToolBar is a cCJToolbar
95155>            Set psTitle to "Edit Toolbar"
95156>            Set pbGripper to False
95157>            Set peStretched to stStretch
95158>
95158>            Object oCutToolbarItem is a cCJCutMenuItem  
95160>                Set psImage to "ActionCut1.ico"
95161>            End_Object
95162>
95162>            Object oCopyToolbarItem is a cCJCopyMenuItem
95164>                Set psImage to "ActionCopy1.ico"
95165>            End_Object
95166>
95166>            Object oPasteToolbarItem is a cCJPasteMenuItem
95168>                Set psImage to "ActionPaste1.ico"
95169>            End_Object
95170>
95170>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95172>                Set psImage to "ActionDelete1.ico"
95173>                Set pbControlBeginGroup to True
95174>            End_Object
95175>
95175>            Object oTheme_tb is a cCJMenuItem
95177>                Set peControlType to xtpControlLabel
95178>                Set psCaption to "Theme:"
95179>                Set pbControlBeginGroup to True
95180>            End_Object
95181>
95181>            Object oThemeItem is a cCJMenuItem
95183>                Set peControlType to xtpControlComboBox
95184>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95185>
95185>                Procedure OnCreateControl Handle hoObj
95188>                    Integer iItem eTheme
95188>                    Set ComWidth of hoObj to 250
95189>                    Send FillComboList hoObj
95190>                    Get peVisualTheme to eTheme
95191>                    Get FindDataItem hoObj eTheme to iItem
95192>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95193>                End_Procedure
95194>
95194>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95197>                    Integer iCount i eTheme
95197>                    Get ComListCount of hoCombo to iCount
95198>                    For i from 1 to iCount
95204>                        Get ComItemData of hoCombo i to eTheme
95205>                        If (eTheme=eVal) Begin
95207>                            Send SetTheTheme eTheme
95208>                            Function_Return i
95209>                        End
95209>                    Loop
95210>                    Function_Return 0
95211>                End_Function
95212>
95212>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95215>                    Integer iCount
95215>                    Get ComListCount of hoCombo to iCount
95216>                    Increment iCount
95217>                    Send ComAddItem  of hoCombo sText iCount
95218>                    Set ComItemData  of hoCombo iCount to  eTheme
95219>                End_Procedure
95220>
95220>                Procedure FillComboList Handle hoCombo
95223>                    Send ComClear     of hoCombo
95224>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95225>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95226>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95227>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95228>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95229>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95230>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95231>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95232>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95233>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95234>    
95234>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95235>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95236>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95237>    
95237>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95238>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95239>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95240>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95241>    
95241>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95242>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95243>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95244>    
95244>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95245>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95246>    
95246>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95247>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95248>    
95248>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95249>    
95249>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95250>    
95250>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95251>                End_Procedure
95252>
95252>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95255>                    Handle hMessage hoCombo
95255>                    Integer iIndex
95255>                    // create and bind  proxy control
95255>                    Get CreateProxyControl vCommandBarControl to hoCombo
95256>                    // get the current selection
95256>                    Get ComListIndex of hoCombo to iIndex
95257>                    // note the index selections are 1 based
95257>                    If (iIndex > 0) Begin
95259>                        // get the ItemData for the selected item and send that message
95259>                        Get ComItemData of hoCombo iIndex to hMessage
95260>                        Function_Return hMessage
95261>                    End
95261>                    // dispose of the proxy control
95261>                    Send Destroy of hoCombo
95262>                    Function_Return 0
95263>                End_Function
95264>
95264>                Procedure OnExecute Variant vCommandBarControl
95267>                    Integer eTheme
95267>                    Integer iColor
95267>                    Get CurrentTheme vCommandBarControl to eTheme
95268>                    Set peVisualTheme of ghoCommandBars to eTheme
95269>                    Send ComRecalcLayout of ghoCommandBars
95270>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95271>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95273>                End_Procedure
95274>
95274>                Procedure SetTheTheme Integer eTheme
95277>                    Integer iColor
95277>                    Set peVisualTheme of ghoCommandBars to eTheme
95278>                    Send ComRecalcLayout of ghoCommandBars
95279>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95280>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95282>                End_Procedure
95283>
95283>                Function ConvertSystemColor Integer iColor Returns Integer
95286>                    Integer iSysColor
95286>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95288>                        Move clNone to iColor
95289>                    End
95289>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95292>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95293>                        Move (GetSysColor(iSysColor)) to iColor
95294>                    End
95294>                    Function_Return iColor
95295>                End_Function
95296>
95296>            End_Object
95297>
95297>            Object oAbout_MenuItem is a cCJMenuItem
95299>                Set psCaption to "About"
95300>                Set psToolTip to "About Info"
95301>                Set psDescription to "About the program"
95302>                Set psImage to "ActionAbout1.ico"
95303>                Set pbControlBeginGroup to True
95304>                Procedure OnExecute Variant vCommandBarControl
95307>                    Forward Send OnExecute vCommandBarControl
95309>                    Send Activate_About of (Client_Id(ghoCommandBars))
95310>                End_Procedure
95311>            End_Object
95312>
95312>            Object oHelpMenuItem is a cCJHelpMenuItem
95314>                Set peControlType to xtpControlSplitButtonPopup
95315>                Set psImage to "ActionHelp1.ico"
95316>
95316>                Procedure OnExecute Variant vCommandBarControl
95319>                    Forward Send OnExecute vCommandBarControl
95321>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95322>                    Send ShowProgramHelp
95323>                End_Procedure
95324>
95324>                Object oHelpMenuItemLocal is a cCJMenuItem
95326>                    Set psCaption to "Local HTML Help"
95327>                    Set psImage to "ActionHelp1.ico"
95328>                    Procedure OnExecute Variant vCommandBarControl
95331>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95332>                        Send ShowProgramHelp
95333>                    End_Procedure
95334>                End_Object
95335>
95335>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95337>                    Set psCaption to "Internet Online HTML Help"
95338>                    Set psImage to "ActionHelp1.ico"
95339>                    Procedure OnExecute Variant vCommandBarControl
95342>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95343>                    End_Procedure
95344>
95344>                End_Object
95345>            End_Object
95346>
95346>            Object oExitMenuItem is a cCJExitMenuItem
95348>                Set psImage to "ActionExit1.ico"
95349>                Set psToolTip to "Exit application"
95350>                Set psDescription to "Exit the program (Alt+F4)"
95351>                Set pbControlBeginGroup to True
95352>            End_Object
95353>        End_Object
95354>
95354>//        Object oSpacerBar is a cCJToolbar
95354>//            Set pbDockNextTo to False
95354>//            Set pbShowExpandButton to False
95354>//            Set pbGripper to False
95354>//            Set peStretched to stStretch
95354>//            Set pbCustomizable to False
95354>//            Set pbCloseable to False
95354>//            Set pbEnableDocking to False
95354>//            Set pbHideWrap to True
95354>//
95354>//            Object oFiller is a cCJMenuItem
95354>//            End_Object
95354>//
95354>//        End_Object
95354>
95354>        Object oStatusBar is a cCJStatusBar
95356>
95356>            Object oStatusPane1 is a cCJStatusBarPane
95358>                Set piID to sbpIDIdlePane
95359>                Set pbStyleStretch to True
95360>            End_Object
95361>            Object oStatusPane2 is a cCJStatusBarPane
95363>                Set phoViewPane to Self
95364>                Set pbStyleStretch to True
95365>            End_Object
95366>
95366>        End_Object
95367>
95367>    End_Object
95368>
95368>    Object oClientArea is a ClientArea
95370>
95370>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95370>
95370>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95370>>>//************************************************************************
95370>>>// Confidential Trade Secret.
95370>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95370>>>// as an unpublished work.  All rights reserved.
95370>>>// DataFlex is a registered trademark of Data Access Corporation.
95370>>>//
95370>>>//************************************************************************
95370>>>//************************************************************************
95370>>>//
95370>>>// $File name  : StdAbout.pkg
95370>>>// $File title : Standard about object package for VDF
95370>>>// Notice      :
95370>>>// $Author(s)  : John Tuohy
95370>>>//
95370>>>// $Rev History
95370>>>//
95370>>>// JT 06/27/97   File created
95370>>>//************************************************************************
95370>>>
95370>>>// This provides a quick and simple way to create an about package for a program.
95370>>>// You need to create a message inside you client area called Activate_About.
95370>>>// Within this message you should send the message DoAbout passing needed
95370>>>// string information.
95370>>>//
95370>>>//       Procedure Activate_About
95370>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95370>>>//       End_Procedure
95370>>>//    where: sTitle =     Name of application. If none provided, uses caption
95370>>>//                        bar title
95370>>>//           sVersion   = Version Line. If none provided, will be blank
95370>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95370>>>//           sAuthor    = Author name, blank if none provided
95370>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95370>>>//                        is used.
95370>>>// It is expected that you will place this in your own object package. For
95370>>>// example an order about package may look like this:
95370>>>//
95370>>>//   // OrderAbout.pkg
95370>>>//   Use StdAbout.pkg
95370>>>//   Procedure Activate_About
95370>>>//      String sTitle sCopyright sVersion sAuthor
95370>>>//      Move "My Order Entry System" to sTitle
95370>>>//      Move "Version 2.1" to sVersion
95370>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95370>>>//      Move "John Smith"  to sAuthor
95370>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95370>>>//   end_procedure
95370>>>//   // end of file.
95370>>>
95370>>>Use DfAbout.pkg
95370>>>
95370>>>// *************************************************************************
95370>>>//  Public message. This is the default message. It is expected that you will
95370>>>//   create your own message to override this
95370>>>// *************************************************************************
95370>>>
95370>>>Procedure Activate_About
95373>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95374>>>End_Procedure
95375>>>
95375>>>// *************************************************************************
95375>>>//  Public message. It is expected that you will send this message (most
95375>>>//  likely from Activate_About. This creates an about object, activates it
95375>>>//  and destroys it when done. It is not exepected that you will augment this.
95375>>>// *************************************************************************
95375>>>// Sample usage:
95375>>>//   The first two params will automatically be filled from the application settings if not provided.
95375>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95375>>>
95375>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95378>>>    Integer hoObj hoMain iArgs
95378>>>    String sValue
95378>>>
95378>>>    // Create object
95378>>>    Object About is an AboutDialog
95380>>>    // Uncomment these two lines if you would like to have a resizable About object.
95380>>>    //            Set Border_Style to Border_Thick
95380>>>    //            Set peAnchors to anAll
95380>>>
95380>>>    // Add checking for the number of arguments passed to avoid runtime errors
95380>>>    // if one of them is not passed. This makes the interface
95380>>>    // more flexible.
95380>>>        Move num_arguments to iArgs
95381>>>
95381>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95381>>>        If (iArgs > 0 and sTitle = "") Begin
95383>>>            Get Main_Window of Desktop to hoMain
95384>>>            If hoMain Begin
95386>>>                Get Label of hoMain to sValue
95387>>>            End
95387>>>>
95387>>>        End
95387>>>>
95387>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95390>>>            Move sTitle to sValue
95391>>>        End
95391>>>>
95391>>>        Else If (iArgs = 0) Begin
95394>>>            Get Main_Window of Desktop to hoMain
95395>>>            If hoMain Begin
95397>>>                Get Label of hoMain to sValue
95398>>>            End
95398>>>>
95398>>>        End
95398>>>>
95398>>>
95398>>>        If (sValue <> "") Begin
95400>>>            Send Add_LineLn sValue
95401>>>        End
95401>>>>
95401>>>        Move "" to sValue
95402>>>
95402>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95402>>>        // For this to work the Project Properties Version must have been set in the Studio.
95402>>>        If (iArgs < 2) Begin
95404>>>            Move "" to sValue
95405>>>        End
95405>>>>
95405>>>        Else Begin
95406>>>            Move sVersion to sValue
95407>>>        End
95407>>>>
95407>>>        Set Version to sValue
95408>>>
95408>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95410>>>            Send Add_LineLn sCopyRight
95411>>>        End
95411>>>>
95411>>>
95411>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95411>>>        // else we do.
95411>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95413>>>            Send Add_Line sAuthor
95414>>>        End
95414>>>>
95414>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95417>>>            Send Add_LineLn sAuthor
95418>>>        End
95418>>>>
95418>>>
95418>>>        // Square bitmaps of 80x80 works best
95418>>>        If (iArgs > 4 and sBitmap <> "") Begin
95420>>>            Set Logo to sBitMap
95421>>>        End
95421>>>>
95421>>>
95421>>>        // Here starts handling of the five optional params:
95421>>>        If (iArgs = 6 and sParam6  <> "") Begin
95423>>>            Send Add_Line sParam6
95424>>>        End
95424>>>>
95424>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95427>>>            Send Add_LineLn sParam6
95428>>>        End
95428>>>>
95428>>>
95428>>>        If (iArgs = 7 and sParam7  <> "") Begin
95430>>>            Send Add_Line sParam7
95431>>>        End
95431>>>>
95431>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95434>>>            Send Add_LineLn sParam7
95435>>>        End
95435>>>>
95435>>>
95435>>>        If (iArgs = 8 and sParam8  <> "") Begin
95437>>>            Send Add_Line sParam8
95438>>>        End
95438>>>>
95438>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95441>>>            Send Add_LineLn sParam8
95442>>>        End
95442>>>>
95442>>>
95442>>>        If (iArgs = 9 and sParam9  <> "") Begin
95444>>>            Send Add_Line sParam9
95445>>>        End
95445>>>>
95445>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95448>>>            Send Add_LineLn sParam9
95449>>>        End
95449>>>>
95449>>>
95449>>>        If (iArgs = 10 and sParam10 <> "") Begin
95451>>>            Send Add_Line sParam10
95452>>>        End
95452>>>>
95452>>>
95452>>>        Move Self to hoObj
95453>>>    End_Object
95454>>>
95454>>>    Send Popup   of hoObj // Popup the about object
95455>>>    Send Destroy of hoObj // When done, it will be destroyed
95456>>>End_Procedure
95457>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95457>>>Use Windows.pkg
95457>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95457>>>>>Use Windows.pkg
95457>>>>>Use cCJGrid.pkg
95457>>>>>Use umPromptRelational.pkg
95457>>>>>
95457>>>>>Class cCJGridPromptList is a cCJGrid
95458>>>>>    
95458>>>>>    Procedure Construct_Object
95460>>>>>        Forward Send Construct_Object
95462>>>>>        
95462>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95463>>>>>        Property Boolean Private_pbAutoOrdering True
95464>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95465>>>>>        Property Integer peUpdateMode umPromptValue
95466>>>>>        Property Integer piUpdateColumn 0
95467>>>>>        Property Integer piInitialColumn -1
95468>>>>>        Property String  psSeedValue ''
95469>>>>>        Property Handle phmPromptUpdateCallback 0
95470>>>>>        Property Integer phoInvokingObject
95471>>>>>        
95471>>>>>        Property Boolean pbStoredAutoSeed
95472>>>>>        Property Boolean pbStoredAutoOrdering
95473>>>>>        Property Boolean pbStoredAutoSearch
95474>>>>>        Property Integer peStoredUpdateMode
95475>>>>>        Property Integer piStoredUpdateColumn
95476>>>>>        Property Integer piStoredInitialColumn
95477>>>>>        Property Handle  phmStoredPromptUpdateCallback
95478>>>>>        Property Boolean pbStoredSelectionEnable
95479>>>>>        Property Boolean pbStoredMultipleSelection
95480>>>>>        
95480>>>>>        // internally set by list
95480>>>>>        // these must be set upon closing the list and can be used for manual list updates
95480>>>>>        Property Boolean pbCanceled
95481>>>>>        Property Integer[] pSelectedRows
95482>>>>>        
95482>>>>>        Property Boolean pbNeedsNewOrdering
95483>>>>>        Property Boolean pbRequestSearch
95484>>>>>        Property tGridKeyPair[] pSearchKeys
95485>>>>>        
95485>>>>>        // these properties makes a prompt list a prompt list
95485>>>>>        // and should not be changed.
95485>>>>>        Set pbEditOnKeyNavigation to False
95486>>>>>        Set pbEditOnClick to False
95487>>>>>        Set pbReadOnly to True
95488>>>>>        Set pbFocusSubItems to True
95489>>>>>        
95489>>>>>        // these could maybe be changed
95489>>>>>        Set pbShadeSortColumn to True
95490>>>>>        Set pbHeaderReorders to True
95491>>>>>        Set pbHeaderTogglesDirection to True
95492>>>>>        Set pbHeaderSelectsColumn to True
95493>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95494>>>>>        Set piFocusCellBackColor to clNone
95495>>>>>        Set piFocusCellForeColor to clNone
95496>>>>>        Set piFocusCellRectangleColor to clBlack
95497>>>>>        Set pbUseFocusCellRectangle to False
95498>>>>>        Set pbSelectionEnable to True
95499>>>>>        
95499>>>>>        On_Key kEnter Send Ok
95500>>>>>        On_Key kCancel Send Cancel
95501>>>>>        
95501>>>>>    End_Procedure
95502>>>>>    
95502>>>>>    // reorder list automatically on column change
95502>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95502>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95504>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95505>>>>>        Set pbFocusSubItems to bAutoOrder
95506>>>>>    End_Procedure
95507>>>>>    
95507>>>>>    Function pbAutoOrdering Returns Boolean
95509>>>>>        Boolean bAutoOrder
95509>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95510>>>>>        Function_Return bAutoOrder
95511>>>>>    End_Function
95512>>>>>    
95512>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95512>>>>>    Procedure OnIdle
95514>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95514>>>>>        Handle hoCol
95514>>>>>        Integer iKy1 iKy2 iCol
95514>>>>>        
95514>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95515>>>>>        If bNeedsReorder Begin
95517>>>>>            Get SelectedColumn to iCol
95518>>>>>            If (iCol<>-1) Begin
95520>>>>>                
95520>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95521>>>>>                Set pbHeaderTogglesDirection to False
95522>>>>>                Send HeaderReorder iCol
95523>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95524>>>>>                
95524>>>>>                Set pbNeedsNewOrdering to False
95525>>>>>            End
95525>>>>>>
95525>>>>>        End
95525>>>>>>
95525>>>>>        
95525>>>>>        Get pbRequestSearch to bSearch
95526>>>>>        If bSearch Begin
95528>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95529>>>>>        End
95529>>>>>>
95529>>>>>        
95529>>>>>        Forward Send OnIdle
95531>>>>>    End_Procedure
95532>>>>>    
95532>>>>>    Procedure OnStoreDefaults
95534>>>>>        Integer iVal
95534>>>>>        Boolean bVal
95534>>>>>        
95534>>>>>        Get pbAutoSeed to bVal
95535>>>>>        Set pbStoredAutoSeed to bVal
95536>>>>>        
95536>>>>>        Get pbAutoOrdering to bVal
95537>>>>>        Set pbStoredAutoOrdering to bVal
95538>>>>>        
95538>>>>>        Get pbAutoSearch to bVal
95539>>>>>        Set pbStoredAutoSearch to bVal
95540>>>>>        
95540>>>>>        Get peUpdateMode to iVal
95541>>>>>        Set peStoredUpdateMode to iVal
95542>>>>>        
95542>>>>>        Get piUpdateColumn to iVal
95543>>>>>        Set piStoredUpdateColumn to iVal
95544>>>>>        
95544>>>>>        Get piInitialColumn to iVal
95545>>>>>        Set piStoredInitialColumn to iVal
95546>>>>>        
95546>>>>>        Get phmPromptUpdateCallback to iVal
95547>>>>>        Set phmStoredPromptUpdateCallback to iVal
95548>>>>>        
95548>>>>>        Get pbSelectionEnable to bVal
95549>>>>>        Set pbStoredSelectionEnable to bVal
95550>>>>>        
95550>>>>>        Get pbMultipleSelection to bVal
95551>>>>>        Set pbStoredMultipleSelection to bVal
95552>>>>>        
95552>>>>>    End_Procedure
95553>>>>>    
95553>>>>>    Procedure OnRestoreDefaults
95555>>>>>        Integer iVal
95555>>>>>        Boolean bVal
95555>>>>>        
95555>>>>>        Get pbStoredAutoSeed to bVal
95556>>>>>        Set pbAutoSeed to bVal
95557>>>>>        
95557>>>>>        Get pbStoredAutoOrdering to bVal
95558>>>>>        Set pbAutoOrdering to bVal
95559>>>>>        
95559>>>>>        Get pbStoredAutoSearch to bVal
95560>>>>>        Set pbAutoSearch to bVal
95561>>>>>        
95561>>>>>        Get peStoredUpdateMode to iVal
95562>>>>>        Set peUpdateMode to iVal
95563>>>>>        
95563>>>>>        Get piStoredUpdateColumn to iVal
95564>>>>>        Set piUpdateColumn to iVal
95565>>>>>        
95565>>>>>        Get piStoredInitialColumn to iVal
95566>>>>>        Set piInitialColumn to iVal
95567>>>>>        
95567>>>>>        Get phmStoredPromptUpdateCallback to iVal
95568>>>>>        Set phmPromptUpdateCallback to iVal
95569>>>>>        
95569>>>>>        Get pbStoredSelectionEnable to bVal
95570>>>>>        Set pbSelectionEnable to bVal
95571>>>>>        
95571>>>>>        Get pbStoredMultipleSelection to bVal
95572>>>>>        Set pbMultipleSelection to bVal
95573>>>>>        
95573>>>>>    End_Procedure
95574>>>>>    
95574>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95574>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95574>>>>>    // Suitable for augmentation
95574>>>>>    Procedure OnSeedData
95576>>>>>        Integer iUpdateColumn iSortColumn
95576>>>>>        Boolean bSeed bAuto
95576>>>>>        String sValue
95576>>>>>        Handle hoCol
95576>>>>>        
95576>>>>>        Get piUpdateColumn to iUpdateColumn
95577>>>>>        Get psSeedValue to sValue
95578>>>>>        Get pbAutoSeed to bSeed
95579>>>>>        Get piSortColumn to iSortColumn
95580>>>>>        Get pbAutoOrdering to bAuto
95581>>>>>        // if not yet sorted and this is auto ordering we will
95581>>>>>        // sort the data for the search column. We do this to make the
95581>>>>>        // column search GE logic work properly.
95581>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95583>>>>>            Get ColumnObject iUpdateColumn to hoCol
95584>>>>>            Send SortGridByColumn hoCol False
95585>>>>>        End
95585>>>>>>
95585>>>>>        
95585>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95587>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95588>>>>>        End
95588>>>>>>
95588>>>>>        Else Begin
95589>>>>>            Send MovetoFirstRow
95590>>>>>        End
95590>>>>>>
95590>>>>>        
95590>>>>>    End_Procedure
95591>>>>>    
95591>>>>>    Procedure OnMoveValueOutByValue
95593>>>>>        String sValue
95593>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95593>>>>>        Integer iRow iCol
95593>>>>>        Integer[] SelRowsIndexes
95594>>>>>        
95594>>>>>        Get phoInvokingObject to hoInvokingObject
95595>>>>>        Get pSelectedRows to SelRowsIndexes
95596>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95598>>>>>            Get piUpdateColumn to iCol
95599>>>>>            Get ColumnObject iCol to hoCol
95600>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95601>>>>>            Set Value of hoInvokingObject to sValue
95602>>>>>            Set Item_Changed_State of hoInvokingObject to True
95603>>>>>        End
95603>>>>>>
95603>>>>>    End_Procedure
95604>>>>>    
95604>>>>>    Procedure OnMoveValueOutByCustom
95606>>>>>    End_Procedure
95607>>>>>    
95607>>>>>    // augment to popup a search window when allowed
95607>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95609>>>>>        Boolean bSubFocus bAutoSearch bChar
95609>>>>>        Integer iVal
95609>>>>>        
95609>>>>>        Get pbFocusSubItems to bSubFocus
95610>>>>>        Get pbAutoSearch to bAutoSearch
95611>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95613>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95615>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95617>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95618>>>>>                Move (iVal<>0) to bChar
95619>>>>>            End
95619>>>>>>
95619>>>>>            If bChar Begin
95621>>>>>                // this can get called multiple times before a search dialog pops up
95621>>>>>                Send AddToSearchKeys llKeyCode llShift
95622>>>>>            End
95622>>>>>>
95622>>>>>        End
95622>>>>>>
95622>>>>>    End_Procedure
95623>>>>>    
95623>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95625>>>>>        Boolean bAutoSearch
95625>>>>>        Integer iKeyCode iShiftCode
95625>>>>>        Get pbAutoSearch to bAutoSearch
95626>>>>>        If bAutoSearch Begin
95628>>>>>            // this can get called multiple times before a search dialog pops up
95628>>>>>            Get piLastKey to iKeyCode
95629>>>>>            Get piLastKey2 to iShiftCode
95630>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95631>>>>>        End
95631>>>>>>
95631>>>>>        Move True to llCancel
95632>>>>>    End_Procedure
95633>>>>>    
95633>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95635>>>>>        Send ClearSearchRequest // kill any deferred search popup
95636>>>>>        Forward Send OnComRowDblClick llRow llItem
95638>>>>>    End_Procedure
95639>>>>>    
95639>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95641>>>>>        Send Ok
95642>>>>>    End_Procedure
95643>>>>>    
95643>>>>>    
95643>>>>>    // we don't want a menu for prompt lists
95643>>>>>    Function CreateContextMenu Returns Handle
95645>>>>>        Function_Return 0
95646>>>>>    End_Function
95647>>>>>    
95647>>>>>    // if we use auto-ordering, change the order when the column changes
95647>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95649>>>>>        Boolean bAutoOrder
95649>>>>>        Forward Send ColumnChanged iOld iNew
95651>>>>>        Get pbAutoOrdering to bAutoOrder
95652>>>>>        If bAutoOrder Begin
95654>>>>>            // will be reordered in idle event
95654>>>>>            Set pbNeedsNewOrdering to True
95655>>>>>        End
95655>>>>>>
95655>>>>>    End_Procedure
95656>>>>>    
95656>>>>>    
95656>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95658>>>>>        Integer eMode
95658>>>>>        Integer[] SelRowsIndexes
95659>>>>>        Set pbCanceled to True // assume cancel unless changed
95660>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95661>>>>>        Get peUpdateMode to eMode
95662>>>>>        If (eMode<>umPromptNonInvoking) Begin
95664>>>>>            Send OnStoreDefaults
95665>>>>>        End
95665>>>>>>
95665>>>>>        Send InitializePromptList
95666>>>>>        Forward Send Add_Focus hoParent
95668>>>>>        Send LoadData
95669>>>>>        Set psSeedValue to ""
95670>>>>>    End_Procedure
95671>>>>>    
95671>>>>>    // called before the list is activated.
95671>>>>>    Procedure InitializePromptList
95673>>>>>        Integer hoInvokingObject
95673>>>>>        Boolean bAutoColumn bAutoSeed
95673>>>>>        Integer i iOldMode eUpdateMode
95673>>>>>        String sValue
95673>>>>>        
95673>>>>>        Get peUpdateMode to eUpdateMode
95674>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95676>>>>>            Get Focus of Desktop to hoInvokingObject
95677>>>>>            If (hoInvokingObject<=Desktop) Begin
95679>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95680>>>>>>
95680>>>>>                Procedure_Return
95681>>>>>            End
95681>>>>>>
95681>>>>>            
95681>>>>>            Set phoInvokingObject to hoInvokingObject
95682>>>>>            
95682>>>>>            Send Prompt_Callback to hoInvokingObject Self
95683>>>>>            Get peUpdateMode to eUpdateMode
95684>>>>>        End
95684>>>>>>
95684>>>>>        
95684>>>>>        Send ClearSearchRequest // clear the search keys
95685>>>>>        Set pbNeedsNewOrdering to False
95686>>>>>        
95686>>>>>        Get pbAutoSeed to bAutoSeed
95687>>>>>        
95687>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
95689>>>>>            Get Value of hoInvokingObject to sValue
95690>>>>>            Set psSeedValue to sValue
95691>>>>>        End
95691>>>>>>
95691>>>>>        
95691>>>>>    End_Procedure
95692>>>>>    
95692>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
95692>>>>>    Procedure LoadData
95694>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
95694>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
95694>>>>>        Integer eUpdateMode
95694>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
95694>>>>>        
95694>>>>>        Get phoDataSource to hoDataSource
95695>>>>>        Get peUpdateMode to eUpdateMode
95696>>>>>        Get phoInvokingObject to hoInvokingObject
95697>>>>>        Get pbAutoSeed to bAutoSeed
95698>>>>>        Get piInitialColumn to iInitialColumn
95699>>>>>        Get piUpdateColumn to iUpdateColumn
95700>>>>>        Get RowCount of hoDataSource to iRows
95701>>>>>        
95701>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
95701>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
95701>>>>>        If (iInitialColumn=-1) Begin
95703>>>>>            Move iUpdateColumn to iInitialColumn
95704>>>>>        End
95704>>>>>>
95704>>>>>        If (iInitialColumn>=0) Begin
95706>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
95707>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
95708>>>>>        End
95708>>>>>>
95708>>>>>        Send OnSeedData // find a good starting place for the row
95709>>>>>        Get pbFocusSubItems to bSubFocus
95710>>>>>        If bSubFocus Begin
95712>>>>>            // if column focus, which is normal, go to initialcolumn
95712>>>>>            If hoInitialColumn Begin
95714>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
95715>>>>>            End
95715>>>>>>
95715>>>>>            Else Begin
95716>>>>>                Send MoveToFirstEnterableColumn
95717>>>>>            End
95717>>>>>>
95717>>>>>        End
95717>>>>>>
95717>>>>>        
95717>>>>>    End_Procedure
95718>>>>>    
95718>>>>>    // This is only called in a successful close
95718>>>>>    Procedure ClosePromptList
95720>>>>>        Handle hoDataSource hoInvokingObject
95720>>>>>        Handle hmCallBack
95720>>>>>        Integer iRow eUpdateMode
95720>>>>>        Integer[] SelRowsIndexes
95721>>>>>        
95721>>>>>        Get phoDataSource to hoDataSource
95722>>>>>        Get phoInvokingObject to hoInvokingObject
95723>>>>>        
95723>>>>>        If (pbMultipleSelection(Self)) Begin
95725>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
95726>>>>>        End
95726>>>>>>
95726>>>>>        Else Begin
95727>>>>>            Get SelectedRow of hoDataSource to iRow
95728>>>>>            If (iRow<>-1) Begin
95730>>>>>                Move iRow to SelRowsIndexes[0]
95731>>>>>            End
95731>>>>>>
95731>>>>>        End
95731>>>>>>
95731>>>>>        
95731>>>>>        Set pbCanceled to False
95732>>>>>        Set pSelectedRows to SelRowsIndexes
95733>>>>>        
95733>>>>>        Get peUpdateMode to eUpdateMode
95734>>>>>        // if non-invoking there is by definition, no move value out
95734>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95736>>>>>            
95736>>>>>            If (eUpdateMode=umPromptValue) Begin
95738>>>>>                Send OnMoveValueOutByValue
95739>>>>>            End
95739>>>>>>
95739>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
95742>>>>>                Send OnMoveValueOutByCustom
95743>>>>>            End
95743>>>>>>
95743>>>>>            Get phmPromptUpdateCallback to hmCallBack
95744>>>>>            If hmCallBack Begin
95746>>>>>                Send hmCallBack of hoInvokingObject Self
95747>>>>>            End
95747>>>>>>
95747>>>>>        End
95747>>>>>>
95747>>>>>        
95747>>>>>        Send Close_Panel
95748>>>>>    End_Procedure
95749>>>>>    
95749>>>>>    // augment to send OnRestoreDefaults.
95749>>>>>    Procedure Release_Focus
95751>>>>>        Integer eUpdateMode
95751>>>>>        Get peUpdateMode to eUpdateMode
95752>>>>>        Forward Send Release_Focus
95754>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95756>>>>>            Send OnRestoreDefaults
95757>>>>>        End
95757>>>>>>
95757>>>>>    End_Procedure
95758>>>>>    
95758>>>>>    Function SelectedRowIds Returns RowID[]
95760>>>>>        RowID[] SelectedRowids
95761>>>>>        Integer[] SelectedRows
95762>>>>>        Integer i iRows
95762>>>>>        Handle hoDataSource
95762>>>>>        Get phoDataSource to hoDataSource
95763>>>>>        Get pSelectedRows to SelectedRows
95764>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95765>>>>>        For i from 0 to (iRows-1)
95771>>>>>>
95771>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
95772>>>>>        Loop
95773>>>>>>
95773>>>>>        Function_Return SelectedRowids
95774>>>>>    End_Function
95775>>>>>    
95775>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
95777>>>>>        String[] SelectedValues
95778>>>>>        Integer[] SelectedRows
95779>>>>>        Integer i iRows
95779>>>>>        Handle hoCol
95779>>>>>        Get ColumnObject iCol to hoCol
95780>>>>>        Get pSelectedRows to SelectedRows
95781>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95782>>>>>        For i from 0 to (iRows-1)
95788>>>>>>
95788>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
95789>>>>>        Loop
95790>>>>>>
95790>>>>>        Function_Return SelectedValues
95791>>>>>    End_Function
95792>>>>>    
95792>>>>>    Procedure Ok Returns Integer
95794>>>>>        Send ClosePromptList
95795>>>>>    End_Procedure
95796>>>>>    
95796>>>>>    Procedure Cancel Returns Integer
95798>>>>>        Send Close_Panel
95799>>>>>    End_Procedure
95800>>>>>    
95800>>>>>    Procedure Search
95802>>>>>        Send Activate // give focus back to list so focus things are correct
95803>>>>>        Send Request_Search 0 0
95804>>>>>    End_Procedure
95805>>>>>    
95805>>>>>    // do a search using the current keys in the search key buffer for the sort column.
95805>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
95805>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
95805>>>>>    Procedure Request_SearchEx
95807>>>>>        tGridKeyPair[] Keys
95807>>>>>        tGridKeyPair[] Keys
95808>>>>>        Integer iCol
95808>>>>>        Handle hoCol hoSearchDialog
95808>>>>>        Boolean bOk
95808>>>>>        String sValue
95808>>>>>        
95808>>>>>        Get piSortColumn to iCol
95809>>>>>        If (iCol<>-1) Begin
95811>>>>>            Get ColumnObject iCol to hoCol
95812>>>>>            Get pSearchKeys to Keys
95813>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
95814>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
95815>>>>>            If bOk Begin
95817>>>>>                Send RequestFindColumnValue iCol sValue True 0
95818>>>>>            End
95818>>>>>>
95818>>>>>            Send Destroy of hoSearchDialog
95819>>>>>        End
95819>>>>>>
95819>>>>>        Send ClearSearchRequest // clear the search keys
95820>>>>>    End_Procedure
95821>>>>>    
95821>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
95821>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
95823>>>>>        tGridKeyPair[] Keys
95823>>>>>        tGridKeyPair[] Keys
95824>>>>>        tGridKeyPair KeyPair
95824>>>>>        tGridKeyPair KeyPair
95824>>>>>        Set pbRequestSearch to True
95825>>>>>        Move iKeyCode to KeyPair.KeyCode
95826>>>>>        Move iShiftCode to KeyPair.ShiftCode
95827>>>>>        Get pSearchKeys to Keys
95828>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
95829>>>>>        Set pSearchKeys to Keys
95830>>>>>    End_Procedure
95831>>>>>    
95831>>>>>    Procedure ClearSearchRequest
95833>>>>>        tGridKeyPair[] SearchKeys
95833>>>>>        tGridKeyPair[] SearchKeys
95834>>>>>        Set pSearchKeys to SearchKeys
95835>>>>>        Set pbRequestSearch to False
95836>>>>>    End_Procedure
95837>>>>>    
95837>>>>>End_Class
95838>>>>>
95838>>>Use cDbUpdateFunctionLibrary.pkg
95838>>>Use MSSqldrv.pkg
95838>>>Use db2_drv.pkg
95838>>>Use odbc_drv.pkg
95838>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
95838>>>>>//****************************************************************************
95838>>>>>// $Module type: Class
95838>>>>>// $Module name: cRDCModalPanel
95838>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
95838>>>>>// Created     : 2014-03-17 @ 12:33
95838>>>>>//
95838>>>>>// Description :
95838>>>>>//
95838>>>>>// $Rev History:
95838>>>>>//    2014-03-17  Module header created
95838>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95838>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95838>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95838>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95838>>>>>// in the help folder for more details.
95838>>>>>//
95838>>>>>//****************************************************************************
95838>>>>>Use Windows.pkg
95838>>>>>Use cCJCommandBarSystem.pkg   
95838>>>>>Use cCJSkinFramework.pkg
95838>>>>>
95838>>>>>Class cRDCModalPanel is a ModalPanel
95839>>>>>
95839>>>>>    Procedure Construct_Object
95841>>>>>        Forward Send Construct_Object
95843>>>>>
95843>>>>>        Set Maximize_Icon to True
95844>>>>>        Set Minimize_Icon to False
95845>>>>>        Set Border_Style to Border_Thick
95846>>>>>        Set Locate_Mode to Center_On_Parent
95847>>>>>
95847>>>>>        Property String Private_Icon
95848>>>>>        Property Handle phoDialogCommandbar
95849>>>>>    End_Procedure
95850>>>>>
95850>>>>>    Procedure Set Icon String sIcon
95852>>>>>        Forward Set Icon to sIcon
95854>>>>>        Set Private_Icon to sIcon
95855>>>>>    End_Procedure
95856>>>>>
95856>>>>>    Function Icon Returns String
95858>>>>>        String sIcon
95858>>>>>        Get Private_Icon to sIcon
95859>>>>>        Function_Return sIcon
95860>>>>>    End_Function
95861>>>>>
95861>>>>>    Procedure Page Integer iPageObject
95863>>>>>        String sIcon
95863>>>>>        Integer hWnd
95863>>>>>        
95863>>>>>        Forward Send Page iPageObject
95865>>>>>        Get Private_Icon to sIcon
95866>>>>>        If (sIcon <> "") Begin
95868>>>>>            Set Icon to sIcon
95869>>>>>        End
95869>>>>>>
95869>>>>>
95869>>>>>        Get Window_Handle to hWnd
95870>>>>>
95870>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
95872>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
95873>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
95874>>>>>        End
95874>>>>>>
95874>>>>>    End_Procedure
95875>>>>>
95875>>>>>    // Put a status bar at the bottom of the panel, which makes
95875>>>>>    // status_help work and puts a gripper in the lower right corner.
95875>>>>>    Procedure End_Construct_Object
95877>>>>>        Integer iStyle iSize iOffset
95877>>>>>
95877>>>>>        Forward Send End_Construct_Object
95879>>>>>
95879>>>>>        Get Border_Style to iStyle
95880>>>>>        Move 8 to iOffset
95881>>>>>        If (iStyle = Border_Thick) Begin
95883>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
95885>>>>>                Object oStatusBar is a cCJStatusBar
95887>>>>>                    Set phoDialogCommandbar to Self
95888>>>>>                    Object oStatusIdle is a cCJStatusBarPane
95890>>>>>                        Set piId to sbpIDIdlePane
95891>>>>>                        Set pbStyleStretch to True
95892>>>>>                    End_Object
95893>>>>>                End_Object
95894>>>>>            End_Object
95895>>>>>            Get Size to iSize
95896>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
95897>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
95898>>>>>        End
95898>>>>>>
95898>>>>>
95898>>>>>    End_Procedure
95899>>>>>
95899>>>>>    Procedure Popup
95901>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
95902>>>>>        Forward Send Popup
95904>>>>>    End_Procedure
95905>>>>>
95905>>>>>End_Class
95906>>>
95906>>>Object oDatabaseSelection_sl is a cRDCModalPanel
95908>>>    Set Label to "SQL Database Selection"
95909>>>    Set Size to 119 183
95910>>>    Set piMinSize to 89 170
95911>>>    Set Location to 2 2
95912>>>    Set Border_Style to Border_Thick
95913>>>    Set Icon to "DatabaseLookup1.ico"
95914>>>
95914>>>    Property String[] psTheData
95916>>>
95916>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
95918>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
95920>>>        End_Object
95921>>>    End
95921>>>>
95921>>>
95921>>>    Object oSelList is a cCJGridPromptList
95923>>>        Set Size to 89 167
95924>>>        Set Location to 6 6
95925>>>        Set peAnchors to anAll
95926>>>        Set pbAllowColumnRemove to False
95927>>>        Set pbUseAlternateRowBackgroundColor to True
95928>>>        Set pbGrayIfDisable to False
95929>>>        Set pbHeaderReorders to False
95930>>>        Set pbHeaderSelectsColumn to False
95931>>>        Set pbHeaderTogglesDirection to False
95932>>>        Set pbShadeSortColumn to False
95933>>>        Set piFocusCellBackColor to clDkGray
95934>>>
95934>>>        Object oName is a cCJGridColumn
95936>>>            Set piWidth to 334
95937>>>            Set psCaption to "Database Name"
95938>>>        End_Object
95939>>>
95939>>>        Procedure Activating
95942>>>            tDataSourceRow[] MyData
95942>>>            tDataSourceRow[] MyData
95943>>>            Handle hoDataSource
95943>>>            String[] sTheData
95944>>>            Integer iCount iSize
95944>>>
95944>>>            Send Cursor_Wait of Cursor_Control
95945>>>            Forward Send Activating
95947>>>
95947>>>            Get psTheData to sTheData
95948>>>            Move (SizeOfArray(sTheData)) to iSize
95949>>>            Decrement iSize
95950>>>            For iCount from 0 to iSize
95956>>>>
95956>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
95957>>>            Loop
95958>>>>
95958>>>
95958>>>            Get phoDataSource to hoDataSource
95959>>>            Send InitializeData of hoDataSource MyData
95960>>>            Send Cursor_Ready of Cursor_Control
95961>>>        End_Procedure
95962>>>
95962>>>    End_Object
95963>>>
95963>>>    Object oOK_Btn is a Button
95965>>>        Set Size to 14 50
95966>>>        Set Label    to "&OK"
95967>>>        Set Location to 98 68
95968>>>        Set peAnchors To anBottomRight
95969>>>
95969>>>        Procedure OnClick
95972>>>            Send Ok of oSelList
95973>>>        End_Procedure
95974>>>
95974>>>    End_Object
95975>>>
95975>>>    Object oCancel_Btn is a Button
95977>>>        Set Size to 14 50
95978>>>        Set Label    to "&Cancel"
95979>>>        Set Location to 98 123
95980>>>        Set peAnchors to anBottomRight
95981>>>
95981>>>        Procedure OnClick
95984>>>            Send Close_Panel
95985>>>        End_Procedure
95986>>>
95986>>>    End_Object
95987>>>
95987>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95988>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95989>>>End_Object
95990>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
95990>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
95990>>>Use Windows.pkg
95990>>>Use vWin32fh.pkg
95990>>>
95990>>>Object oSQLDatabaseBackup_dg is a ModalPanel
95992>>>    Set Size to 104 298
95993>>>    Set Label to "SQL Database Backup"
95994>>>    Set piMinSize to 89 211
95995>>>    Set Location to 2 4
95996>>>    Set Border_Style To Border_Thick
95997>>>
95997>>>    Property Boolean pbOK False
95999>>>    Property String  psDatabase
96001>>>    Property String  psPath
96003>>>    Property String  psBackupName
96005>>>
96005>>>    Object oDatabase_fm is a Form
96007>>>        Set Size to 13 204
96008>>>        Set Location to 14 71
96009>>>        Set Label_Justification_Mode to JMode_Right
96010>>>        Set Label_Col_Offset to 2
96011>>>        Set Label to "Database Name"
96012>>>        Set Enabled_State to False
96013>>>        Set peAnchors to anTopLeftRight
96014>>>
96014>>>        Procedure Page Integer iPageObject
96017>>>            String sValue
96017>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96018>>>            Set Value to sValue
96019>>>            Set psDatabase to sValue
96020>>>            Forward Send Page iPageObject
96022>>>        End_Procedure
96023>>>
96023>>>    End_Object
96024>>>
96024>>>    Object oBackupName_fm is a Form
96026>>>        Set Size to 13 204
96027>>>        Set Location to 29 71
96028>>>        Set Label_Justification_Mode to JMode_Right
96029>>>        Set Label_Col_Offset to 2
96030>>>        Set Label to "Backup Name"
96031>>>        Set peAnchors to anTopLeftRight
96032>>>
96032>>>        Procedure Page Integer iPageObject
96035>>>            String sValue
96035>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96036>>>            Set Value to sValue
96037>>>            Forward Send Page iPageObject
96039>>>        End_Procedure
96040>>>
96040>>>        Procedure OnChange
96043>>>            String sValue
96043>>>            Get Value to sValue
96044>>>            Set psBackupName to sValue
96045>>>        End_Procedure
96046>>>
96046>>>    End_Object
96047>>>
96047>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96049>>>        Set Size to 10 50
96050>>>        Set Location to 50 71
96051>>>        Set Label to "Use Default SQL Backup Folder"
96052>>>        Set Checked_State to True
96053>>>
96053>>>        Procedure OnChange
96056>>>            Boolean bChecked
96056>>>            Get Checked_State to bChecked
96057>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96058>>>        End_Procedure
96059>>>
96059>>>    End_Object
96060>>>
96060>>>    Object oPath_fm is a Form
96062>>>        Set Size to 13 204
96063>>>        Set Location to 62 71
96064>>>        Set Label_Justification_Mode to JMode_Right
96065>>>        Set Label_Col_Offset to 2
96066>>>        Set Label to "Path"
96067>>>        Set Prompt_Button_Mode to PB_PromptOn
96068>>>        Set peAnchors to anTopLeftRight
96069>>>        Set Enabled_State to False
96070>>>
96070>>>        Procedure Page Integer iPageObject
96073>>>            String sValue
96073>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96074>>>            Get vFolderFormat sValue to sValue
96075>>>            Move (sValue + "Backup") to sValue
96076>>>            Set Value to sValue
96077>>>            Forward Send Page iPageObject
96079>>>        End_Procedure
96080>>>
96080>>>        Procedure Prompt
96083>>>            String sPath sFileMask sRetval
96083>>>
96083>>>            Get Value to sPath
96084>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96085>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96086>>>            If (sRetval <> "") Begin
96088>>>                Get ParseFolderName sRetval to sPath
96089>>>                If (Right(sPath, 1) ="\") Begin
96091>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96092>>>                End
96092>>>>
96092>>>                Set Value to sPath
96093>>>            End
96093>>>>
96093>>>        End_Procedure
96094>>>
96094>>>        Procedure OnChange
96097>>>            String sValue
96097>>>            Get Value to sValue
96098>>>            Set psPath to sValue
96099>>>        End_Procedure
96100>>>
96100>>>    End_Object
96101>>>
96101>>>    Object oOK_Btn is a Button
96103>>>        Set Label    to "&OK"
96104>>>        Set Location to 81 169
96105>>>        Set peAnchors to anBottomRight
96106>>>
96106>>>        Procedure OnClick
96109>>>            Set pbOK to True
96110>>>            Send Close_Panel
96111>>>        End_Procedure
96112>>>
96112>>>    End_Object
96113>>>
96113>>>    Object oCancel_Btn is a Button
96115>>>        Set Label    to "&Cancel"
96116>>>        Set Location to 81 224
96117>>>        Set peAnchors to anBottomRight
96118>>>
96118>>>        Procedure OnClick
96121>>>            Set pbOK to False
96122>>>            Send Close_Panel
96123>>>        End_Procedure
96124>>>
96124>>>    End_Object
96125>>>
96125>>>    Object oButton1 is a Button
96127>>>        Set Size to 14 96
96128>>>        Set Location to 80 32
96129>>>        Set Label to "Enum table types"
96130>>>
96130>>>        Procedure OnClick
96133>>>            String sDriverID
96133>>>            tSQLConnection SQLConnection
96133>>>            tSQLConnection SQLConnection
96133>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96134>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96135>>>        End_Procedure
96136>>>
96136>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96139>>>            Handle hoCLIHandler
96139>>>            Integer iNumTables iTableCount
96139>>>
96139>>>            Get Create U_cCLIHandler to hoCLIhandler
96140>>>            If (hoCLIHandler > 0) Begin
96142>>>                Set psDriverID of hoCLIHandler to sDriver
96143>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96144>>>                For iTableCount from 1 to iNumTables
96150>>>>
96150>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96152>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96154>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96156>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96158>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96158>>>//                    For iColumnCount from 1 to iNumColumns
96158>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96158>>>//                    Loop
96158>>>                    Showln
96159>>>                Loop
96160>>>>
96160>>>                Send Destroy of hoCLIHandler
96161>>>            End
96161>>>>
96161>>>        End_Procedure
96162>>>
96162>>>    End_Object
96163>>>
96163>>>    Procedure Page Integer iPageObject
96166>>>        Set Icon to "DbBackup1.ico"
96167>>>        Forward Send Page iPageObject
96169>>>    End_Procedure
96170>>>
96170>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96171>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96172>>>
96172>>>End_Object
96173>>>
96173>>>// *** General purpose access method for this dialog ***
96173>>>Function MakeSQLDatabaseBackup Returns Boolean
96176>>>    Handle ho
96176>>>    Boolean bOK bDefault
96176>>>    String sDatabase sPath sBackupName
96176>>>
96176>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96177>>>    Set pbOK of ho to False
96178>>>    Send Popup of ho
96179>>>
96179>>>    Get pbOk of ho to bOK
96180>>>    If (bOK = True) Begin
96182>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96183>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96184>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96185>>>        If (bDefault = False) Begin
96187>>>            Get Value of (oPath_fm(ho)) to sPath
96188>>>        End
96188>>>>
96188>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96189>>>    End
96189>>>>
96189>>>
96189>>>    Function_Return bOK
96190>>>End_Function
96191>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96191>>>Use Windows.pkg
96191>>>Use DFClient.pkg
96191>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96191>>>>>// Provides support for db aware scrolling containers.
96191>>>>>// Scrolling containers is provided by creating two objects,
96191>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96191>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96191>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96191>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96191>>>>>
96191>>>>>Use DFClient.pkg
96191>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96191>>>>>>>// Mixin classes for scrolling container support:
96191>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96191>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96191>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96191>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96191>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96191>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96191>>>>>>>
96191>>>>>>>Use Windows.pkg
96191>>>>>>>Use Winuser.pkg
96191>>>>>>>Use tWinStructs.pkg
96191>>>>>>>
96191>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96191>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96191>>>>>>>// support for the scrolling client area mixin object.
96191>>>>>>>
96191>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96192>>>>>>>    
96192>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96194>>>>>>>        
96194>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96195>>>>>>>        Set Border_Style to Border_None
96196>>>>>>>        
96196>>>>>>>        Property Boolean pbAutoScroll True
96197>>>>>>>        Property Boolean pbAutoScrollFocus True
96198>>>>>>>        Property Integer piAutoScrollMarginX 5
96199>>>>>>>        Property Integer piAutoScrollMarginY 5
96200>>>>>>>        Property Integer piAutoScrollMinX 0
96201>>>>>>>        Property Integer piAutoScrollMinY 0
96202>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96203>>>>>>>        
96203>>>>>>>        
96203>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96204>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96205>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96206>>>>>>>        // keeps track of scrolling
96206>>>>>>>        Property Integer piCurrentVertScrolled 0
96207>>>>>>>        Property Integer piCurrentHorzScrolled 0
96208>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96209>>>>>>>        Delegate Set phoScrollingClientArea to Self
96211>>>>>>>        
96211>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96211>>>>>>>        Property Boolean pbTabWorkspaceView False
96212>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96212>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96213>>>>>>>    End_Procedure
96214>>>>>>>    
96214>>>>>>>    // low level event sent from windows.
96214>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96216>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96216>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96217>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96218>>>>>>>        If (wParam<0) Begin
96220>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96221>>>>>>>        End
96221>>>>>>>>
96221>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96222>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96223>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96223>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96224>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96225>>>>>>>        // If we have enough Clicks send OnMouseWheel
96225>>>>>>>        If (iClicks<>0) Begin
96227>>>>>>>            Send OnMouseWheel iClicks iKeys
96228>>>>>>>        End
96228>>>>>>>>
96228>>>>>>>        // tell windows that we've handled the event.
96228>>>>>>>        Set Windows_Override_State to True
96229>>>>>>>    End_Procedure
96230>>>>>>>    
96230>>>>>>>    
96230>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96230>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96232>>>>>>>        Integer iLineScrollUnit
96232>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96233>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96234>>>>>>>    End_Procedure
96235>>>>>>>    
96235>>>>>>>    // should be sent by WM_VSCROLL
96235>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96237>>>>>>>        Boolean bOk
96237>>>>>>>        tWinScrollInfo ScrollInfo
96237>>>>>>>        tWinScrollInfo ScrollInfo
96237>>>>>>>        Integer iLineScrollUnit
96237>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96238>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96239>>>>>>>        If bOk Begin
96241>>>>>>>            
96241>>>>>>>            Case Begin
96241>>>>>>>                Case (iType=SB_PAGEDOWN)
96243>>>>>>>                    Send VScroll ScrollInfo.nPage
96244>>>>>>>                    Case Break
96245>>>>>>>                
96245>>>>>>>                Case (iType=SB_PAGEUP)
96248>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96249>>>>>>>                    Case Break
96250>>>>>>>                
96250>>>>>>>                Case (iType=SB_LINEDOWN)
96253>>>>>>>                    Send VScroll iLineScrollUnit
96254>>>>>>>                    Case Break
96255>>>>>>>                
96255>>>>>>>                Case (iType=SB_LINEUP)
96258>>>>>>>                    Send VScroll (-iLineScrollUnit)
96259>>>>>>>                    Case Break
96260>>>>>>>                
96260>>>>>>>                Case (iType=SB_BOTTOM)
96263>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96264>>>>>>>                    Case Break
96265>>>>>>>                
96265>>>>>>>                Case (iType=SB_Top)
96268>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96269>>>>>>>                    Case Break
96270>>>>>>>                
96270>>>>>>>                Case (iType=SB_THUMBPOSITION)
96273>>>>>>>                    Case Break
96274>>>>>>>                
96274>>>>>>>                Case (iType=SB_THUMBTRACK)
96277>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96278>>>>>>>                    Case Break
96279>>>>>>>            Case End
96279>>>>>>>        End
96279>>>>>>>>
96279>>>>>>>    End_Procedure
96280>>>>>>>    
96280>>>>>>>    // should be sent by WM_HSCROLL
96280>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96282>>>>>>>        Boolean bOk
96282>>>>>>>        tWinScrollInfo ScrollInfo
96282>>>>>>>        tWinScrollInfo ScrollInfo
96282>>>>>>>        Integer iLineScrollUnit
96282>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96283>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96284>>>>>>>        If bOk Begin
96286>>>>>>>            
96286>>>>>>>            Case Begin
96286>>>>>>>                Case (iType=SB_PAGEDOWN)
96288>>>>>>>                    Send hScroll ScrollInfo.nPage
96289>>>>>>>                    Case Break
96290>>>>>>>                
96290>>>>>>>                Case (iType=SB_PAGEUP)
96293>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96294>>>>>>>                    Case Break
96295>>>>>>>                
96295>>>>>>>                Case (iType=SB_LINEDOWN)
96298>>>>>>>                    Send hScroll iLineScrollUnit
96299>>>>>>>                    Case Break
96300>>>>>>>                
96300>>>>>>>                Case (iType=SB_LINEUP)
96303>>>>>>>                    Send hScroll (-iLineScrollUnit)
96304>>>>>>>                    Case Break
96305>>>>>>>                
96305>>>>>>>                Case (iType=SB_BOTTOM)
96308>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96309>>>>>>>                    Case Break
96310>>>>>>>                
96310>>>>>>>                Case (iType=SB_Top)
96313>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96314>>>>>>>                    Case Break
96315>>>>>>>                
96315>>>>>>>                Case (iType=SB_THUMBPOSITION)
96318>>>>>>>                    Case Break
96319>>>>>>>                
96319>>>>>>>                Case (iType=SB_THUMBTRACK)
96322>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96323>>>>>>>                    Case Break
96324>>>>>>>            Case End
96324>>>>>>>        End
96324>>>>>>>>
96324>>>>>>>    End_Procedure
96325>>>>>>>    
96325>>>>>>>    
96325>>>>>>>    // this calls SetScrollInfo with proper info
96325>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96327>>>>>>>        tWinScrollInfo ScrollInfo
96327>>>>>>>        tWinScrollInfo ScrollInfo
96327>>>>>>>        Integer iVoid
96327>>>>>>>        Handle hWnd
96327>>>>>>>        Boolean bShow
96327>>>>>>>        
96327>>>>>>>        Delegate Get Window_Handle to hWnd
96329>>>>>>>        If (hWnd <> 0) Begin
96331>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96332>>>>>>>            
96332>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96333>>>>>>>            Get pbShowDisabledScrollBar to bShow
96334>>>>>>>            If bShow Begin
96336>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96337>>>>>>>            End
96337>>>>>>>>
96337>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96338>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96339>>>>>>>            Move iPageSize to ScrollInfo.nPage
96340>>>>>>>            Move 0 to ScrollInfo.nPos
96341>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96342>>>>>>>            
96342>>>>>>>        End
96342>>>>>>>>
96342>>>>>>>    End_Procedure
96343>>>>>>>    
96343>>>>>>>    // this wraps GetScrollInfo
96343>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96345>>>>>>>        Boolean bOk
96345>>>>>>>        Handle hWnd
96345>>>>>>>        
96345>>>>>>>        Delegate Get Window_Handle to hWnd
96347>>>>>>>        If (hWnd <> 0) Begin
96349>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96350>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96351>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96352>>>>>>>        End
96352>>>>>>>>
96352>>>>>>>        Function_Return bOk
96353>>>>>>>    End_Function
96354>>>>>>>    
96354>>>>>>>    // this wraps SetScrollPos
96354>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96356>>>>>>>        Integer iVoid
96356>>>>>>>        Handle hWnd
96356>>>>>>>        
96356>>>>>>>        Delegate Get Window_Handle to hWnd
96358>>>>>>>        If (hWnd <> 0) Begin
96360>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96361>>>>>>>        End
96361>>>>>>>>
96361>>>>>>>    End_Procedure
96362>>>>>>>    
96362>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96362>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96362>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96364>>>>>>>        Send ScrollClientArea
96365>>>>>>>    End_Procedure
96366>>>>>>>    
96366>>>>>>>    // augment to handle the scrolling area initialization.
96366>>>>>>>    Procedure Add_Focus Handle hoParent
96368>>>>>>>        Forward Send Add_Focus hoParent
96370>>>>>>>        // at this the scrolling container and client area should both be paged.
96370>>>>>>>        // child objects ae also paged with initial anchors applied
96370>>>>>>>        Send CalculateAutoScrollMinimums
96371>>>>>>>    End_Procedure
96372>>>>>>>    
96372>>>>>>>    Procedure Page Integer iPage
96374>>>>>>>        Forward Send Page iPage
96376>>>>>>>        If iPage Begin
96378>>>>>>>            // at this the scrolling container and client area should both be paged
96378>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96378>>>>>>>            // the child items are paged (else they may get anchored oddly)
96378>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96378>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96378>>>>>>>            // before they were really needed. This should be more accurate
96378>>>>>>>            Send SetScrollBarInfo True 0 0 0
96379>>>>>>>            Send SetScrollBarInfo False 0 0 0
96380>>>>>>>        End
96380>>>>>>>>
96380>>>>>>>    End_Procedure
96381>>>>>>>    
96381>>>>>>>    // determine scrolling minimums and set the client area as required.
96381>>>>>>>    
96381>>>>>>>    Procedure CalculateAutoScrollMinimums
96383>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96383>>>>>>>        Integer iAutoMinX iAutoMinY
96383>>>>>>>        Boolean bAutoScroll
96383>>>>>>>        Handle hoNext hoFirst
96383>>>>>>>        
96383>>>>>>>        Get pbAutoScroll to bAutoScroll
96384>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96385>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96386>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96387>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96388>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96389>>>>>>>        Set piMinimumHeight to iAutoMinY
96390>>>>>>>        Set piMinimumWidth to iAutoMinX
96391>>>>>>>        
96391>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96393>>>>>>>            
96393>>>>>>>            Get Next_Level to hoFirst
96394>>>>>>>            Move hoFirst to hoNext
96395>>>>>>>            If (hoFirst) Begin
96397>>>>>>>                Repeat
96397>>>>>>>>
96397>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96398>>>>>>>                    Get GuiLocation of hoNext to iLoc
96399>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96400>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96401>>>>>>>                    Get Next_Focus of hoNext to hoNext
96402>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96404>>>>>>>                
96404>>>>>>>                If (iAutoMinY=0) Begin
96406>>>>>>>                    Get piAutoScrollMarginY to iMargin
96407>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96408>>>>>>>                End
96408>>>>>>>>
96408>>>>>>>                
96408>>>>>>>                If (iAutoMinX=0) Begin
96410>>>>>>>                    Get piAutoScrollMarginX to iMargin
96411>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96412>>>>>>>                    
96412>>>>>>>                End
96412>>>>>>>>
96412>>>>>>>            End
96412>>>>>>>>
96412>>>>>>>        End
96412>>>>>>>>
96412>>>>>>>        
96412>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96412>>>>>>>        Broadcast Set pbAnchorCreated to False
96414>>>>>>>        Send ScrollClientArea
96415>>>>>>>        // after the scroll set up, reinitialize all anchors.
96415>>>>>>>        Broadcast Send DoCreateAnchors
96417>>>>>>>    End_Procedure
96418>>>>>>>    
96418>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96418>>>>>>>    // work of scrolling.
96418>>>>>>>    
96418>>>>>>>    Procedure ScrollClientArea
96420>>>>>>>        Integer iSiz
96420>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96420>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96420>>>>>>>        Integer iSzY iSzX iLocX iLocY
96420>>>>>>>        
96420>>>>>>>        Delegate Get GuiClientSize to iSiz
96422>>>>>>>        Move (Hi(iSiz)) to iHeight
96423>>>>>>>        Move (Low(iSiz)) to iWidth
96424>>>>>>>        
96424>>>>>>>        // Vertical scrolling
96424>>>>>>>        
96424>>>>>>>        Get piMinimumHeight to iOrig
96425>>>>>>>        Get piMinimumWidth to iWOrig
96426>>>>>>>        
96426>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96428>>>>>>>            
96428>>>>>>>            If (iOrig<>0) Begin
96430>>>>>>>                Get piCurrentVertScrolled to iHCur
96431>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96431>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96433>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96434>>>>>>>                    Set piCurrentVertScrolled to iHCur
96435>>>>>>>                End
96435>>>>>>>>
96435>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96437>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96438>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96439>>>>>>>                End
96439>>>>>>>>
96439>>>>>>>                Else Begin
96440>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96441>>>>>>>                End
96441>>>>>>>>
96441>>>>>>>            End
96441>>>>>>>>
96441>>>>>>>            
96441>>>>>>>            // Horiz scrolling
96441>>>>>>>            
96441>>>>>>>            Get piCurrentHorzScrolled to iWCur
96442>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96442>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96444>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96445>>>>>>>                Set piCurrentHorzScrolled to iWCur
96446>>>>>>>            End
96446>>>>>>>>
96446>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96448>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96449>>>>>>>                Send SetScrollBarPosInfo False iWCur
96450>>>>>>>            End
96450>>>>>>>>
96450>>>>>>>            Else Begin
96451>>>>>>>                Send SetScrollBarInfo False 0 0 0
96452>>>>>>>            End
96452>>>>>>>>
96452>>>>>>>        End
96452>>>>>>>>
96452>>>>>>>        
96452>>>>>>>        // this could change depending on scrollbars appearing or not
96452>>>>>>>        Delegate Get GuiClientSize to iSiz
96454>>>>>>>        
96454>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96454>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96454>>>>>>>        // This is required to make anchors work sensibly
96454>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96455>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96456>>>>>>>        Move (-iHCur) to iLocY
96457>>>>>>>        Move (-iWCur) to iLocX
96458>>>>>>>        
96458>>>>>>>        // Allow chance to make modifications
96458>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96459>>>>>>>        
96459>>>>>>>        Set GuiSize to iSzY iSzX
96460>>>>>>>        // if we've scrolled, we need to reposition the container
96460>>>>>>>        Set GuiLocation to iLocY iLocX
96461>>>>>>>    End_Procedure
96462>>>>>>>    
96462>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96462>>>>>>>    // this way, it does not interfere with anchors.
96462>>>>>>>    
96462>>>>>>>    Procedure VScroll Integer iDelta
96464>>>>>>>        Integer iHeight iCur iOrig iSiz
96464>>>>>>>        Delegate Get GuiClientSize to iSiz
96466>>>>>>>        Move (hi(iSiz)) to iHeight
96467>>>>>>>        Get piCurrentVertScrolled to iCur
96468>>>>>>>        Get piMinimumHeight to iOrig
96469>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96471>>>>>>>            Procedure_Return
96472>>>>>>>        End
96472>>>>>>>>
96472>>>>>>>        // make sure delta is within range
96472>>>>>>>        If (iDelta+iCur<0) Begin
96474>>>>>>>            Move (-iCur) to iDelta
96475>>>>>>>        End
96475>>>>>>>>
96475>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96478>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96479>>>>>>>        End
96479>>>>>>>>
96479>>>>>>>        If (iDelta=0) ;            Procedure_Return
96482>>>>>>>        
96482>>>>>>>        Move (iCur + iDelta) to iCur
96483>>>>>>>        Set piCurrentVertScrolled to iCur
96484>>>>>>>        Send SetScrollBarPosInfo True iCur
96485>>>>>>>        Get GuiLocation to iSiz
96486>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96487>>>>>>>        Send ScrollClientArea
96488>>>>>>>    End_Procedure
96489>>>>>>>    
96489>>>>>>>    
96489>>>>>>>    Procedure HScroll Integer iDelta
96491>>>>>>>        Integer iHeight iCur iOrig iSiz
96491>>>>>>>        Delegate Get GuiClientSize to iSiz
96493>>>>>>>        Move (low(iSiz)) to iHeight
96494>>>>>>>        Get piCurrentHorzScrolled to iCur
96495>>>>>>>        Get piMinimumWidth to iOrig
96496>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96498>>>>>>>            Procedure_Return
96499>>>>>>>        End
96499>>>>>>>>
96499>>>>>>>        If (iDelta+iCur<0) Begin
96501>>>>>>>            Move (-iCur) to iDelta
96502>>>>>>>        End
96502>>>>>>>>
96502>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96505>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96506>>>>>>>        End
96506>>>>>>>>
96506>>>>>>>        If (iDelta=0) ;            Procedure_Return
96509>>>>>>>        
96509>>>>>>>        Move (iCur + iDelta) to iCur
96510>>>>>>>        Set piCurrentHorzScrolled to iCur
96511>>>>>>>        Send SetScrollBarPosInfo False iCur
96512>>>>>>>        Get GuiLocation to iSiz
96513>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96514>>>>>>>        Send ScrollClientArea
96515>>>>>>>    End_Procedure
96516>>>>>>>    
96516>>>>>>>    // make sure client is a 0,0
96516>>>>>>>    Procedure ScrollHome
96518>>>>>>>        Send SetVScrollbox SB_TOP 0
96519>>>>>>>        Send SetHScrollbox SB_TOP 0
96520>>>>>>>    End_Procedure
96521>>>>>>>    
96521>>>>>>>    // get relative GUI location of this object to the parent one passed.
96521>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96523>>>>>>>        Integer ivoid
96523>>>>>>>        tWinRect Rect0 Rect1
96523>>>>>>>        tWinRect Rect0 Rect1
96523>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96524>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96525>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96526>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96527>>>>>>>    End_Procedure
96528>>>>>>>    
96528>>>>>>>    // This scrolls this object into visual range.
96528>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96530>>>>>>>        Handle hoScrollingContainer
96530>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96530>>>>>>>        Integer iViewHeight iViewWidth
96530>>>>>>>        Integer iRelLocHeight iRelLocWidth
96530>>>>>>>        Integer iSize iControlHeight iControlWidth
96530>>>>>>>        Integer iScroll
96530>>>>>>>        Integer iMarginX iMarginY
96530>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96530>>>>>>>        
96530>>>>>>>        Get piAutoScrollMarginX to iMarginX
96531>>>>>>>        Get piAutoScrollMarginY to iMarginY
96532>>>>>>>        
96532>>>>>>>        // the scrolling container
96532>>>>>>>        Move Self to hoScrollingContainer
96533>>>>>>>        // the amount the SC is currently scrolled
96533>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96534>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96535>>>>>>>        
96535>>>>>>>        // size of view's client area (this is the viewport area)
96535>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96536>>>>>>>        Move (hi(iSize)) to iViewHeight
96537>>>>>>>        Move (low(iSize)) to iViewWidth
96538>>>>>>>        
96538>>>>>>>        // get this object's location relative to the scrolling container
96538>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96539>>>>>>>        
96539>>>>>>>        // we expect that the client size is the window size but just in case
96539>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96540>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96541>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96542>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96543>>>>>>>        
96543>>>>>>>        // the outer size of the control object
96543>>>>>>>        Get GUIWindowSize of hoControl to iSize
96544>>>>>>>        Move (hi(iSize)) to iControlHeight
96545>>>>>>>        Move (low(iSize)) to iControlWidth
96546>>>>>>>        
96546>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96546>>>>>>>        
96546>>>>>>>        // Vertical Scroll
96546>>>>>>>        
96546>>>>>>>        // Vertical Scroll down
96546>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96546>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96548>>>>>>>            
96548>>>>>>>            // set scroll amount so that the bottom of the control is visible
96548>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96549>>>>>>>            
96549>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96549>>>>>>>            // top of the object appears at the bottom
96549>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96551>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96552>>>>>>>            End
96552>>>>>>>>
96552>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96552>>>>>>>            If (iScroll>0) Begin
96554>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96555>>>>>>>            End
96555>>>>>>>>
96555>>>>>>>        End
96555>>>>>>>>
96555>>>>>>>        // else vertical scroll up
96555>>>>>>>        // We scroll if the top of the object is not visible.
96555>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96558>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96558>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96559>>>>>>>            If (iScroll<0) Begin
96561>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96562>>>>>>>            End
96562>>>>>>>>
96562>>>>>>>        End
96562>>>>>>>>
96562>>>>>>>        
96562>>>>>>>        // Horizonal Scroll
96562>>>>>>>        
96562>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96562>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96564>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96565>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96567>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96568>>>>>>>            End
96568>>>>>>>>
96568>>>>>>>            If (iScroll>0) Begin
96570>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96571>>>>>>>            End
96571>>>>>>>>
96571>>>>>>>        End
96571>>>>>>>>
96571>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96573>>>>>>>            // if this can fit by moving all the way to left, do so.
96573>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96575>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96576>>>>>>>            End
96576>>>>>>>>
96576>>>>>>>            Else Begin
96577>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96578>>>>>>>            End
96578>>>>>>>>
96578>>>>>>>            If (iScroll<0) Begin
96580>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96581>>>>>>>            End
96581>>>>>>>>
96581>>>>>>>        End
96581>>>>>>>>
96581>>>>>>>        
96581>>>>>>>        
96581>>>>>>>    End_Procedure
96582>>>>>>>    
96582>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96582>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96584>>>>>>>        Boolean bScrollOnFocus
96584>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96585>>>>>>>        If bScrollOnFocus Begin
96587>>>>>>>            Send ScrollObjectInRange hoControl
96588>>>>>>>        End
96588>>>>>>>>
96588>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96590>>>>>>>    End_Procedure
96591>>>>>>>    
96591>>>>>>>    
96591>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96593>>>>>>>        Boolean bCenter
96593>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96594>>>>>>>        Function_Return bCenter
96595>>>>>>>    End_Function
96596>>>>>>>    
96596>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96598>>>>>>>        Boolean bTabWorkspaceView
96598>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96599>>>>>>>        If bTabWorkspaceView Begin
96601>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96602>>>>>>>        End
96602>>>>>>>>
96602>>>>>>>    End_Procedure
96603>>>>>>>    
96603>>>>>>>    Function ParentView Returns Handle
96605>>>>>>>        Function_Return (Parent(Parent(Self)))
96606>>>>>>>    End_Function
96607>>>>>>>    
96607>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96609>>>>>>>        Integer iSize iMax iDiff
96609>>>>>>>        Handle hoView
96609>>>>>>>        Boolean bCenter bModal
96609>>>>>>>        Get ParentView to hoView
96610>>>>>>>        Get Block_Mouse_State of hoView to bModal
96611>>>>>>>        If not bModal Begin
96613>>>>>>>            Get CenterTabWorkspaceView to bCenter
96614>>>>>>>            Get GuiSize of hoView to iSize
96615>>>>>>>            Get piMaxSize of hoView to iMax
96616>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
96617>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
96619>>>>>>>                If bCenter Begin
96621>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
96622>>>>>>>                End
96622>>>>>>>>
96622>>>>>>>                Move (Low(iMax)) to iWidth
96623>>>>>>>            End
96623>>>>>>>>
96623>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
96625>>>>>>>                If bCenter Begin
96627>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
96628>>>>>>>                    Move (iLocy min 25) to  iLocY
96629>>>>>>>                End
96629>>>>>>>>
96629>>>>>>>                Move (Hi(imax)) to iHeight
96630>>>>>>>            End
96630>>>>>>>>
96630>>>>>>>        End
96630>>>>>>>>
96630>>>>>>>    End_Procedure
96631>>>>>>>    
96631>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
96631>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
96631>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
96631>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
96631>>>>>>>    // This should almost always yield the right answer.
96631>>>>>>>    // This is called by the scrolling container's end_constructor
96631>>>>>>>    Procedure AutoSetTabWorkspaceView
96633>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
96633>>>>>>>        Handle hoParent
96633>>>>>>>        Integer iSize
96633>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
96634>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
96636>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
96637>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
96637>>>>>>>            // change this after the commandbar is paged.
96637>>>>>>>            If (bTabView) Begin
96639>>>>>>>                Get ParentView to hoParent
96640>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
96641>>>>>>>                If (bIsView) Begin
96643>>>>>>>                    // set this as a tab workspace view
96643>>>>>>>                    Set pbTabWorkspaceView to True
96644>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
96644>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
96644>>>>>>>                    Set pbAutoScroll to True
96645>>>>>>>                    
96645>>>>>>>                End
96645>>>>>>>>
96645>>>>>>>            End
96645>>>>>>>>
96645>>>>>>>        End
96645>>>>>>>>
96645>>>>>>>    End_Procedure
96646>>>>>>>    
96646>>>>>>>End_Class
96647>>>>>>>
96647>>>>>>>// Container scrolling class support. Nothing in here is public
96647>>>>>>>Class cScrollingContainerMixin is a Mixin
96648>>>>>>>    
96648>>>>>>>    Procedure Define_cScrollingContainerMixin
96650>>>>>>>        Forward Set Border_Style to Border_None
96652>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
96653>>>>>>>        Forward Set peAnchors to anAll
96655>>>>>>>        
96655>>>>>>>        // forcing scrollbars right away seems to make painting better
96655>>>>>>>        Set Window_Style WS_HSCROLL to True
96656>>>>>>>        Set Window_Style WS_VSCROLL to True
96657>>>>>>>        
96657>>>>>>>        Property Handle phoScrollingClientArea 0
96658>>>>>>>    End_Procedure
96659>>>>>>>    
96659>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
96659>>>>>>>    Procedure Set peAnchors Integer eAnchors
96661>>>>>>>    End_Procedure
96662>>>>>>>    
96662>>>>>>>    // if a border style is set, it will not work. We won't let that happen
96662>>>>>>>    Procedure Set Border_Style Integer eStyle
96664>>>>>>>    End_Procedure
96665>>>>>>>    
96665>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
96665>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96667>>>>>>>        Handle hoClient
96667>>>>>>>        Get phoScrollingClientArea to hoClient
96668>>>>>>>        If hoClient Begin
96670>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
96671>>>>>>>        End
96671>>>>>>>>
96671>>>>>>>    End_Procedure
96672>>>>>>>    
96672>>>>>>>    // should be sent by WM_VSCROLL
96672>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96674>>>>>>>        Handle hoClient
96674>>>>>>>        Get phoScrollingClientArea to hoClient
96675>>>>>>>        If hoClient Begin
96677>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
96678>>>>>>>        End
96678>>>>>>>>
96678>>>>>>>    End_Procedure
96679>>>>>>>    
96679>>>>>>>    // should be sent by WM_HSCROLL
96679>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96681>>>>>>>        Handle hoClient
96681>>>>>>>        Get phoScrollingClientArea to hoClient
96682>>>>>>>        If hoClient Begin
96684>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
96685>>>>>>>        End
96685>>>>>>>>
96685>>>>>>>    End_Procedure
96686>>>>>>>    
96686>>>>>>>    // augmented to adjust its size to the size of the parent client area.
96686>>>>>>>    // After this is set, anchors will handle any further resizing.
96686>>>>>>>    Procedure Page Integer iState
96688>>>>>>>        Integer iSiz iHeight iWidth
96688>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
96688>>>>>>>        Boolean bGroup
96688>>>>>>>        Handle hoClient
96688>>>>>>>        If (iState =1) Begin
96690>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
96692>>>>>>>            // We have special code to support groups because they
96692>>>>>>>            // draw a border inside of the client rectangle
96692>>>>>>>            If bGroup Begin
96694>>>>>>>                Get Physical_FontSize to iFontSize
96695>>>>>>>                Move (Hi(iFontSize)) to iTop
96696>>>>>>>                Move 2 to iLeft
96697>>>>>>>                Move 2 to iRight
96698>>>>>>>                Move 2 to iBottom
96699>>>>>>>            End
96699>>>>>>>>
96699>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
96699>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
96699>>>>>>>            // makes anchors work properly with unpaged tab-pages
96699>>>>>>>            Delegate Get GetContainerClientSize to iSiz
96701>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
96702>>>>>>>            Set GuiLocation to iTop iLeft
96703>>>>>>>            Send Adjust_Logicals
96704>>>>>>>        End
96704>>>>>>>>
96704>>>>>>>        Forward Send Page iState
96706>>>>>>>    End_Procedure
96707>>>>>>>    
96707>>>>>>>    Procedure End_Construct_Object
96709>>>>>>>        Handle hoClient
96709>>>>>>>        Forward Send End_Construct_Object
96711>>>>>>>        Get phoScrollingClientArea to hoClient
96712>>>>>>>        If (hoClient) Begin
96714>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
96715>>>>>>>        End
96715>>>>>>>>
96715>>>>>>>    End_Procedure
96716>>>>>>>    
96716>>>>>>>End_Class
96717>>>>>
96717>>>>>Class cDbScrollingClientArea is a dbContainer3d
96718>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
96719>>>>>    Procedure Construct_Object
96721>>>>>        Forward Send Construct_Object
96723>>>>>        Send Define_cScrollingClientAreaMixin
96724>>>>>    End_Procedure
96725>>>>>End_Class
96726>>>>>
96726>>>>>
96726>>>>>
96726>>>>>Class cDbScrollingContainer is a dbContainer3d
96727>>>>>    Import_Class_Protocol cScrollingContainerMixin
96728>>>>>    Procedure Construct_Object
96730>>>>>        Forward Send Construct_Object
96732>>>>>        Send Define_cScrollingContainerMixin
96733>>>>>    End_Procedure
96734>>>>>End_Class
96735>>>Use cDbUpdateFunctionLibrary.pkg
96735>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
96735>>>>>//****************************************************************************
96735>>>>>// $Module type: Package
96735>>>>>// $Module name: cRDCButtonDPI.pkg
96735>>>>>//
96735>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96735>>>>>// Copyright (c) 2013 RDC Tools International
96735>>>>>// E-mail      : support@rdctools.com
96735>>>>>// Web-site    : http://www.rdctools.com
96735>>>>>//
96735>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96735>>>>>//
96735>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96735>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96735>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96735>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96735>>>>>// in the help folder for more details.
96735>>>>>//
96735>>>>>//****************************************************************************
96735>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
96735>>>>>>>//****************************************************************************
96735>>>>>>>// $Module type: Package
96735>>>>>>>// $Module name: cRDCButton.pkg
96735>>>>>>>//
96735>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96735>>>>>>>// Copyright (c) 2013 RDC Tools International
96735>>>>>>>// E-mail      : support@rdctools.com
96735>>>>>>>// Web-site    : http://www.rdctools.com
96735>>>>>>>//
96735>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96735>>>>>>>//
96735>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96735>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96735>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96735>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96735>>>>>>>// in the help folder for more details.
96735>>>>>>>//
96735>>>>>>>//****************************************************************************
96735>>>>>>>Use Windows.pkg
96735>>>>>>>Use Enclient.pkg
96735>>>>>>>Use errornum.inc
96735>>>>>>>
96735>>>>>>>Class cButtonIdleHandler is a cIdleHandler
96736>>>>>>>    Procedure Construct_Object
96738>>>>>>>        Forward Send Construct_Object
96740>>>>>>>
96740>>>>>>>    End_Procedure
96741>>>>>>>
96741>>>>>>>    Procedure OnIdle
96743>>>>>>>        Delegate Send DoUpdate
96745>>>>>>>    End_Procedure
96746>>>>>>>
96746>>>>>>>End_Class
96747>>>>>>>
96747>>>>>>>Class cRDCButton is a Button
96748>>>>>>>
96748>>>>>>>    Procedure Construct_Object
96750>>>>>>>        Forward Send Construct_Object
96752>>>>>>>
96752>>>>>>>        Property Boolean pbAutoEnable True
96753>>>>>>>
96753>>>>>>>        Property Boolean pbEnabled True
96754>>>>>>>
96754>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
96755>>>>>>>
96755>>>>>>>        On_Key kCancel Send CancelIfPopupObject
96756>>>>>>>    End_Procedure
96757>>>>>>>
96757>>>>>>>    Procedure CancelIfPopupObject
96759>>>>>>>        Boolean bIsInPopupObject
96759>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
96761>>>>>>>        If (bIsInPopupObject = True) Begin
96763>>>>>>>            Send Close_Panel
96764>>>>>>>        End
96764>>>>>>>>
96764>>>>>>>    End_Procedure
96765>>>>>>>
96765>>>>>>>    Procedure End_Construct_Object
96767>>>>>>>        String sTooltip sStatus_Help
96767>>>>>>>
96767>>>>>>>        Forward Send End_Construct_Object
96769>>>>>>>
96769>>>>>>>        Get psToolTip   to sTooltip
96770>>>>>>>        Get Status_Help to sStatus_Help
96771>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96773>>>>>>>            Set psToolTip to sStatus_Help
96774>>>>>>>        End
96774>>>>>>>>
96774>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
96776>>>>>>>            Set Status_Help to sToolTip
96777>>>>>>>        End
96777>>>>>>>>
96777>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96778>>>>>>>    End_Procedure
96779>>>>>>>
96779>>>>>>>    Procedure DoUpdate
96781>>>>>>>        If (pbAutoEnable(Self) = False) Begin
96783>>>>>>>            Procedure_Return
96784>>>>>>>        End
96784>>>>>>>>
96784>>>>>>>        Set Enabled_State to (IsEnabled(Self))
96785>>>>>>>    End_Procedure
96786>>>>>>>
96786>>>>>>>    Function IsEnabled Returns Boolean
96788>>>>>>>        Boolean bEnabled
96788>>>>>>>        Get pbEnabled to bEnabled
96789>>>>>>>        Function_Return bEnabled
96790>>>>>>>    End_Function
96791>>>>>>>
96791>>>>>>>    // Enable the idle handler timer when the button is activated
96791>>>>>>>    Procedure Activating
96793>>>>>>>        Forward Send Activating
96795>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96796>>>>>>>    End_Procedure
96797>>>>>>>
96797>>>>>>>    // Disable the idle handler when the button is deactivated
96797>>>>>>>    Procedure Deactivating
96799>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96800>>>>>>>        Forward Send Deactivating
96802>>>>>>>    End_Procedure
96803>>>>>>>
96803>>>>>>>End_Class
96804>>>>>
96804>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
96804>>>>>Class cRDCButtonDPI is a cRDCButton
96805>>>>>    Procedure Construct_Object
96807>>>>>        Integer iIconSize
96807>>>>>        Forward Send Construct_Object
96809>>>>>        Set piImageMarginLeft to 10
96810>>>>>    End_Procedure
96811>>>>>
96811>>>>>    // Returns: DPI setting as an integer.
96811>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
96811>>>>>    //                      iDPI=120 is "Medium setting" 125%
96811>>>>>    //                      iDPI= 144 is "Large setting" 150%
96811>>>>>    Function GetCurrentDPI Returns Integer
96813>>>>>        Handle hDC
96813>>>>>        Integer iPixelsX
96813>>>>>        Move (GetDC(0)) to hDC
96814>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
96815>>>>>        Move (ReleaseDC(0, hDC)) to hDC
96816>>>>>        Function_Return iPixelsX
96817>>>>>    End_Function
96818>>>>>
96818>>>>>    Function GetCorrectIconSize Returns Integer
96820>>>>>        Integer iPixelsX iIndex iSize
96820>>>>>        Integer[] iaSizes
96821>>>>>
96821>>>>>        Move 16 to iaSizes[0]
96822>>>>>        Move 24 to iaSizes[1]
96823>>>>>        Move 32 to iaSizes[2]
96824>>>>>        Move 48 to iaSizes[3]
96825>>>>>        Move 64 to iaSizes[4]
96826>>>>>
96826>>>>>        Get piImageSize to iSize  // the "100%" size
96827>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
96828>>>>>        Move (0 max iIndex) to iIndex
96829>>>>>        Get GetCurrentDPI to iPixelsX
96830>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
96830>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
96830>>>>>        // will increment iIndex as many times as we need here.
96830>>>>>        Case Begin
96830>>>>>            Case (iPixelsX > 144)
96832>>>>>                Increment iIndex
96833>>>>>            Case (iPixelsX = 144)
96836>>>>>                Increment iIndex
96837>>>>>            Case (iPixelsX = 120)
96840>>>>>                Increment iIndex
96841>>>>>        Case End
96841>>>>>        Move (iIndex min 4) to iIndex
96842>>>>>        Function_Return iaSizes[iIndex]
96843>>>>>    End_Function
96844>>>>>
96844>>>>>    Procedure Set psToolTip String sToolTip
96846>>>>>        String sStatusHelp
96846>>>>>
96846>>>>>        Get Status_Help to sStatusHelp
96847>>>>>        If (sStatusHelp = "") Begin
96849>>>>>            Set Status_Help to sToolTip
96850>>>>>        End
96850>>>>>>
96850>>>>>
96850>>>>>        Forward Set psToolTip to sToolTip
96852>>>>>    End_Procedure
96853>>>>>
96853>>>>>End_Class
96854>>>Use DatabaseSelection.dg
96854>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
96854>>>>>Use Windows.pkg
96854>>>>>Use cCJGridPromptList.pkg
96854>>>>>Use MSSqldrv.pkg
96854>>>>>Use db2_drv.pkg
96854>>>>>Use odbc_drv.pkg    
96854>>>>>Use cRDCModalPanel.pkg
96854>>>>>Use cDbUpdateFunctionLibrary.pkg
96854>>>>>
96854>>>>>Object oServerSelection_sl is a cRDCModalPanel
96856>>>>>    Set Size to 105 225
96857>>>>>    Set Label to "Database Server/DSN Selection"
96858>>>>>    Set piMinSize to 89 211
96859>>>>>    Set Location to 2 2
96860>>>>>    Set Icon to "ServerLookup1.ico"
96861>>>>>
96861>>>>>    Property String[] psTheData
96863>>>>>
96863>>>>>    Object oSelList is a cCJGridPromptList
96865>>>>>        Set Size to 72 215
96866>>>>>        Set Location to 6 6
96867>>>>>        Set peAnchors to anAll
96868>>>>>        Set pbAllowColumnRemove to False
96869>>>>>        Set pbUseAlternateRowBackgroundColor to True
96870>>>>>        Set pbGrayIfDisable to False
96871>>>>>        Set pbHeaderReorders to False
96872>>>>>        Set pbHeaderSelectsColumn to False
96873>>>>>        Set pbHeaderTogglesDirection to False
96874>>>>>        Set pbShadeSortColumn to False
96875>>>>>        Set piFocusCellBackColor to clDkGray
96876>>>>>
96876>>>>>        Object oName is a cCJGridColumn
96878>>>>>            Set piWidth to 358
96879>>>>>            Set psCaption to "Name"
96880>>>>>        End_Object
96881>>>>>
96881>>>>>        Procedure Activating
96884>>>>>            tDataSourceRow[] MyData
96884>>>>>            tDataSourceRow[] MyData
96885>>>>>            Handle hoDataSource
96885>>>>>            String[] sTheData
96886>>>>>            Integer iCount iSize
96886>>>>>
96886>>>>>            Send Cursor_Wait of Cursor_Control
96887>>>>>            Get psTheData to sTheData
96888>>>>>            Move (SizeOfArray(sTheData)) to iSize
96889>>>>>            Decrement iSize
96890>>>>>            For iCount from 0 to iSize
96896>>>>>>
96896>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96897>>>>>            Loop
96898>>>>>>
96898>>>>>
96898>>>>>            Forward Send Activating
96900>>>>>
96900>>>>>            Get phoDataSource to hoDataSource
96901>>>>>            Send InitializeData of hoDataSource MyData
96902>>>>>            Send Cursor_Ready of Cursor_Control
96903>>>>>        End_Procedure
96904>>>>>
96904>>>>>    End_Object
96905>>>>>
96905>>>>>    Object oOK_Btn is a Button
96907>>>>>        Set Size to 14 50
96908>>>>>        Set Label    to "&OK"
96909>>>>>        Set Location to 85 116
96910>>>>>        Set peAnchors To anBottomRight
96911>>>>>
96911>>>>>        Procedure OnClick
96914>>>>>            Send Ok of oSelList
96915>>>>>        End_Procedure
96916>>>>>
96916>>>>>    End_Object
96917>>>>>
96917>>>>>    Object oCancel_Btn is a Button
96919>>>>>        Set Size to 14 50
96920>>>>>        Set Label    to "&Cancel"
96921>>>>>        Set Location to 85 171
96922>>>>>        Set peAnchors to anBottomRight
96923>>>>>
96923>>>>>        Procedure OnClick
96926>>>>>            Send Close_Panel
96927>>>>>        End_Procedure
96928>>>>>
96928>>>>>    End_Object
96929>>>>>
96929>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96930>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96931>>>>>End_Object
96932>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
96932>>>>>Use Windows.pkg
96932>>>>>Use cCJGridPromptList.pkg
96932>>>>>Use cDbUpdateFunctionLibrary.pkg
96932>>>>>Use MSSqldrv.pkg
96932>>>>>Use db2_drv.pkg
96932>>>>>Use odbc_drv.pkg
96932>>>>>Use cCJGridColumn.pkg
96932>>>>>
96932>>>>>Object oSQLConnections is a ModalPanel
96934>>>>>    Set Label to "SQL Connections"
96935>>>>>    Set Size to 121 397
96936>>>>>    Set piMinSize to 89 185
96937>>>>>    Set Location to 2 2
96938>>>>>    Set Border_Style to Border_Thick
96939>>>>>
96939>>>>>    Property tSQLConnection[] psTheData
96941>>>>>
96941>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
96941>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96941>>>>>//        End_Object
96941>>>>>//    End
96941>>>>>
96941>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
96943>>>>>        Set Size to 90 377
96944>>>>>        Set Location to 6 6
96945>>>>>        Set peAnchors to anAll
96946>>>>>        Set pbAllowColumnRemove to False
96947>>>>>        Set pbUseAlternateRowBackgroundColor to True
96948>>>>>        Set pbGrayIfDisable to False
96949>>>>>        Set pbHeaderReorders to False
96950>>>>>        Set pbHeaderSelectsColumn to False
96951>>>>>        Set pbHeaderTogglesDirection to False
96952>>>>>        Set pbShadeSortColumn to False
96953>>>>>        Set piFocusCellBackColor to clDkGray  
96954>>>>>        Set pbRestoreLayout to True
96955>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
96956>>>>>
96956>>>>>        Object oID_Col is a cCJGridColumn
96958>>>>>            Set piWidth to 132
96959>>>>>            Set psCaption to "ID"
96960>>>>>        End_Object
96961>>>>>
96961>>>>>        Object oDbType_Col is a cCJGridColumn
96963>>>>>            Set piWidth to 182
96964>>>>>            Set psCaption to "Database Type"
96965>>>>>        End_Object
96966>>>>>
96966>>>>>        Object oServer_Col is a cCJGridColumn
96968>>>>>            Set piWidth to 296
96969>>>>>            Set psCaption to "Server/DSN"
96970>>>>>        End_Object
96971>>>>>
96971>>>>>        Object oDatabase_Col is a cCJGridColumn
96973>>>>>            Set piWidth to 211
96974>>>>>            Set psCaption to "Database"
96975>>>>>        End_Object
96976>>>>>
96976>>>>>        Object oDriverID_Col is a cCJGridColumn
96978>>>>>            Set piWidth to 121
96979>>>>>            Set psCaption to "Driver ID"
96980>>>>>        End_Object
96981>>>>>
96981>>>>>        Procedure Activating
96984>>>>>            tDataSourceRow[] MyData
96984>>>>>            tDataSourceRow[] MyData
96985>>>>>            Handle hoDataSource
96985>>>>>            Integer iCount iSize iPos
96985>>>>>            String sDriverID sConnectionID sValue
96985>>>>>            tSQLConnection[] sTheData
96985>>>>>            tSQLConnection[] sTheData
96986>>>>>
96986>>>>>            Send Cursor_Wait of Cursor_Control
96987>>>>>            Forward Send Activating
96989>>>>>
96989>>>>>            Get psTheData to sTheData
96990>>>>>            Move (SizeOfArray(sTheData)) to iSize
96991>>>>>            Decrement iSize
96992>>>>>            For iCount from 0 to iSize
96998>>>>>>
96998>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
96999>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97000>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97001>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97002>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97003>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97004>>>>>            Loop
97005>>>>>>
97005>>>>>
97005>>>>>            Get phoDataSource to hoDataSource
97006>>>>>            Send InitializeData of hoDataSource MyData
97007>>>>>            Send Cursor_Ready of Cursor_Control
97008>>>>>        End_Procedure
97009>>>>>
97009>>>>>    End_Object
97010>>>>>
97010>>>>>    Object oOK_Btn is a Button
97012>>>>>        Set Label    to "&OK"
97013>>>>>        Set Location to 101 280
97014>>>>>        Set peAnchors to anBottomRight
97015>>>>>
97015>>>>>        Procedure OnClick
97018>>>>>            Send Ok of oSelListSQLConnections
97019>>>>>        End_Procedure
97020>>>>>
97020>>>>>    End_Object
97021>>>>>
97021>>>>>    Object oCancel_Btn is a Button
97023>>>>>        Set Label    to "&Cancel"
97024>>>>>        Set Location to 101 335
97025>>>>>        Set peAnchors to anBottomRight
97026>>>>>
97026>>>>>        Procedure OnClick
97029>>>>>            Send Close_Panel
97030>>>>>        End_Procedure
97031>>>>>
97031>>>>>    End_Object
97032>>>>>
97032>>>>>    Procedure Page Integer iPageObject
97035>>>>>        Set Icon to "SQLConnections1.ico"
97036>>>>>        Forward Send Page iPageObject
97038>>>>>    End_Procedure
97039>>>>>
97039>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97040>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97041>>>>>End_Object
97042>>>
97042>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97052>>>>
97052>>>Object oSQLConnections_vw is a dbView
97054>>>    Set Border_Style to Border_Thick
97055>>>    Set Size to 251 427
97056>>>    Set Location to 2 2
97057>>>    Set Label to "SQL Connections"
97058>>>    Set pbAutoActivate to True
97059>>>    Set Icon to "SQLConnections1.ico"
97060>>>
97060>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97062>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97064>>>
97064>>>            Object oCurrentSettings_grp is a Group
97066>>>                Set Size to 232 402
97067>>>                Set Location to 6 12
97068>>>                Set Label to "Current Connection Settings"
97069>>>                Set peAnchors to anAll
97070>>>
97070>>>                Object oConnectionID_fm is a Form
97072>>>                    Set Size to 12 100
97073>>>                    Set Location to 12 68
97074>>>                    Set Label to "Connection ID"
97075>>>                    Set Label_Col_Offset to 2
97076>>>                    Set Label_Justification_Mode to JMode_Right
97077>>>                    Set Prompt_Button_Mode to PB_PromptOn
97078>>>                    Set Prompt_Object to (oSQLConnections(Self))
97079>>>
97079>>>                    Procedure Prompt
97082>>>                        String[] sTheData
97083>>>                        String sCurrentVal sNewVal
97083>>>                        Handle hoIniFile ho
97083>>>                        Integer iSize iCount
97083>>>                        tSQLConnection[] SQLConnectionArray
97083>>>                        tSQLConnection[] SQLConnectionArray
97084>>>
97084>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97085>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97086>>>                        Get Value to sCurrentVal
97087>>>                        Get Prompt_Object to ho
97088>>>                        Set psTheData of ho to SQLConnectionArray
97089>>>
97089>>>                        Forward Send Prompt
97091>>>                        Get Value to sNewVal
97092>>>                        If (sCurrentVal <> sNewVal) Begin
97094>>>                            Send Cursor_Wait of Cursor_Control
97095>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97096>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97098>>>                            Send Cursor_Ready of Cursor_Control
97099>>>                            Send KeyAction of oTestLogin_btn
97100>>>                        End
97100>>>>
97100>>>                    End_Procedure   
97101>>>                    
97101>>>                    Procedure PromptUpdate Handle hoPrompt
97104>>>                        String[] sSelectedNames                    
97105>>>                
97105>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97106>>>                        If (SizeOfArray(sSelectedNames)) Begin
97108>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97109>>>                            Delegate Send Page True // Broadcast sends refresh
97111>>>                        End
97111>>>>
97111>>>                    End_Procedure   
97112>>>
97112>>>                    Procedure Prompt_Callback Handle hoPrompt
97115>>>                        String sServer
97115>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97116>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97117>>>                        Get Value of oServer_fm to sServer
97118>>>                        Set psSeedValue of hoPrompt to sServer
97119>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97120>>>                    End_Procedure
97121>>>
97121>>>                    Procedure Refresh
97124>>>                        String sValue
97124>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97125>>>                        Set Value to sValue
97126>>>                    End_Procedure
97127>>>
97127>>>                End_Object
97128>>>
97128>>>                Object oDriverID_cf is a ComboForm
97130>>>                    Set Size to 12 91
97131>>>                    Set Location to 12 222
97132>>>                    Set Label_Col_Offset to 2
97133>>>                    Set Label_Justification_Mode to JMode_Right
97134>>>                    Set Label to "Driver ID"
97135>>>                    Set Entry_State to False
97136>>>                    Set Enabled_State to False
97137>>>
97137>>>                    Procedure Combo_Fill_List
97140>>>                        Send Combo_Add_Item MSSQLDRV_ID
97141>>>                        Send Combo_Add_Item DB2_DRV_ID
97142>>>                        Send Combo_Add_Item ODBC_DRV_ID
97143>>>                    End_Procedure
97144>>>
97144>>>                    Procedure OnChange
97147>>>                        String sValue sOrgValue
97147>>>                        Boolean bEnabled bChecked
97147>>>
97147>>>                        Get Value to sValue
97148>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97149>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97151>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97152>>>                        End
97152>>>>
97152>>>                        Move (sValue <> "None") to bEnabled
97153>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97155>>>                        Set Enabled_State to False
97156>>>                        Set Enabled_State of oConnectionString_fm to False
97157>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97158>>>
97158>>>                        Get Checked_State of oTrusted_cb  to bChecked
97159>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97160>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97161>>>                    End_Procedure
97162>>>
97162>>>                    Procedure Refresh
97165>>>                        String sValue
97165>>>
97165>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97166>>>                        Set Value to sValue
97167>>>                    End_Procedure
97168>>>
97168>>>                End_Object
97169>>>
97169>>>                Object oServer_fm is a Form
97171>>>                    Set Size to 12 100
97172>>>                    Set Location to 26 68
97173>>>                    Set Label to "Server"
97174>>>                    Set Label_Col_Offset to 2
97175>>>                    Set Label_Justification_Mode to JMode_Right
97176>>>                    Set Prompt_Button_Mode to PB_PromptOn
97177>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97178>>>
97178>>>                    Procedure Refresh
97181>>>                        String sValue
97181>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97182>>>                        Set Value to sValue
97183>>>                    End_Procedure
97184>>>
97184>>>                    Procedure Prompt
97187>>>                        String[] sTheData
97188>>>                        String sDriverID
97188>>>                        Handle ho
97188>>>
97188>>>                        Send Cursor_Wait of Cursor_Control
97189>>>                        Get Prompt_Object to ho
97190>>>                        Get Value of oDriverID_cf to sDriverID
97191>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97192>>>                        Set psTheData of ho to sTheData
97193>>>                        Send Cursor_Ready of Cursor_Control
97194>>>
97194>>>                        Forward Send Prompt
97196>>>                    End_Procedure
97197>>>
97197>>>                End_Object
97198>>>
97198>>>                Object oDatabase_fm is a Form
97200>>>                    Set Size to 12 91
97201>>>                    Set Location to 26 222
97202>>>                    Set Label to "Database"
97203>>>                    Set Label_Col_Offset to 2
97204>>>                    Set Label_Justification_Mode to JMode_Right
97205>>>                    Set Prompt_Button_Mode to PB_PromptOn
97206>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97207>>>                    Set peAnchors to anNone
97208>>>                    Set Entry_State to False
97209>>>
97209>>>                    Procedure Refresh
97212>>>                        String sDatabase
97212>>>
97212>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97213>>>                        Set Value to sDatabase
97214>>>                    End_Procedure
97215>>>
97215>>>                    Procedure Prompt
97218>>>                        String[] sTheData
97219>>>                        Handle ho
97219>>>                        String sDriverID
97219>>>
97219>>>                        Get Value of oDriverID_cf to sDriverID
97220>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97221>>>
97221>>>                        Get Prompt_Object to ho
97222>>>                        Set psTheData of ho to sTheData
97223>>>
97223>>>                        Forward Send Prompt
97225>>>                    End_Procedure
97226>>>
97226>>>                    Procedure OnChange
97229>>>                        String sValue sOrgValue
97229>>>                        Get Value to sValue
97230>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97231>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97233>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97234>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97235>>>                            Set Value of oConnectionString_fm to sValue
97236>>>                        End
97236>>>>
97236>>>                    End_Procedure
97237>>>
97237>>>                End_Object
97238>>>
97238>>>                Object oTrusted_cb is a CheckBox
97240>>>                    Set Size to 10 50
97241>>>                    Set Location to 45 68
97242>>>                    Set Label to "Use Trusted Connection"
97243>>>
97243>>>                    Procedure Refresh
97246>>>                        Boolean bValue
97246>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97247>>>                        Set Checked_State to bValue
97248>>>                    End_Procedure
97249>>>
97249>>>                    Procedure OnChange
97252>>>                        Boolean bChecked
97252>>>
97252>>>                        Get Checked_State to bChecked
97253>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97254>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97255>>>                    End_Procedure
97256>>>
97256>>>                End_Object
97257>>>
97257>>>                Object oUserID_fm is a Form
97259>>>                    Set Size to 12 100
97260>>>                    Set Location to 57 68
97261>>>                    Set Label to "UserID"
97262>>>                    Set Label_Col_Offset to 2
97263>>>                    Set Label_Justification_Mode to JMode_Right
97264>>>
97264>>>                    Procedure Refresh
97267>>>                        String sValue
97267>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97268>>>                        Set Value to sValue
97269>>>                    End_Procedure
97270>>>
97270>>>                End_Object
97271>>>
97271>>>                Object oPassword_fm is a Form
97273>>>                    Set Size to 12 91
97274>>>                    Set Location to 57 222
97275>>>                    Set Label to "Password"
97276>>>                    Set Label_Col_Offset to 2
97277>>>                    Set Label_Justification_Mode to JMode_Right
97278>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97278>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97279>>>                    Set Password_State to True
97280>>>
97280>>>                    Procedure Refresh
97283>>>                        String sValue
97283>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97284>>>                        Set Value to sValue
97285>>>                    End_Procedure
97286>>>
97286>>>                End_Object
97287>>>
97287>>>                Object oViewPassword_btn is a cRDCButtonDPI
97289>>>                    Set Size to 12 19
97290>>>                    Set Location to 57 317
97291>>>                    Set psToolTip to "Toggle password"
97292>>>                    Set psImage to "ViewPassword1.ico"
97293>>>                    Set piImageMarginLeft to 0
97294>>>
97294>>>                    Procedure OnClick
97297>>>                        Boolean bState
97297>>>                        Get Password_State of oPassword_fm to bState
97298>>>                        Send Page_Object   of oPassword_fm False
97299>>>                        Set Password_State of oPassword_fm to (not(bState))
97300>>>                        Send Page_Object   of oPassword_fm True
97301>>>                    End_Procedure
97302>>>
97302>>>                End_Object
97303>>>
97303>>>                Object oTestLogin_btn is a cRDCButtonDPI
97305>>>                    Set Size to 12 56
97306>>>                    Set Location to 57 340
97307>>>                    Set Label to "Test Login"
97308>>>                    Set peAnchors to anNone
97309>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97310>>>                    Set FontWeight to fw_Bold
97311>>>                    Set psImage to "ActionLogin1.ico"
97312>>>                    Set piImageMarginLeft to 0
97313>>>
97313>>>                    Procedure OnClick
97316>>>                        tSQLConnection SQLConnection
97316>>>                        tSQLConnection SQLConnection
97316>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97316>>>                        Boolean bTrusted bLoginSuccessful
97316>>>                        Integer iDriverID
97316>>>                        Handle hoDriver
97316>>>
97316>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97317>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97318>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97319>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97320>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97321>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97322>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97323>>>
97323>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97324>>>
97324>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97325>>>                        If (iDriverID = 0) Begin
97327>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97328>>>                            Procedure_Return
97329>>>                        End
97329>>>>
97329>>>
97329>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97332>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97333>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97334>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97335>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97336>>>                        Send Destroy   of hoDriver
97337>>>
97337>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97338>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97340>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97341>>>                            Set Value of oConnectionString_fm to sConnectionString
97342>>>                            Send Info_Box "Login Successful!"
97343>>>                        End
97343>>>>
97343>>>                        Else Begin
97344>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97345>>>                        End
97345>>>>
97345>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97347>>>                        Move 0 to LastErr
97348>>>                    End_Procedure
97349>>>
97349>>>                End_Object
97350>>>
97350>>>                Object oConnectionString_fm is a Form
97352>>>                    Set Size to 12 328
97353>>>                    Set Location to 82 68
97354>>>                    Set Label to "Connection String"    
97355>>>                    Set Label_Col_Offset to 2
97356>>>                    Set Label_Justification_Mode to JMode_Right
97357>>>                    Set peAnchors to anTopLeftRight
97358>>>                    Set Enabled_State to False
97359>>>
97359>>>                    Procedure Refresh
97362>>>                        String sValue
97362>>>                        tSQLConnection SQLConnection
97362>>>                        tSQLConnection SQLConnection
97362>>>
97362>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97363>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97364>>>                        Set Value to sValue
97365>>>                    End_Procedure
97366>>>
97366>>>                End_Object
97367>>>
97367>>>                Object oInfo_tb is a TextBox
97369>>>                    Set Auto_Size_State to False
97370>>>                    Set Size to 18 303
97371>>>                    Set Location to 106 8
97372>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97373>>>                    Set Justification_Mode to JMode_Left
97374>>>                    Set FontItalics to True
97375>>>                End_Object
97376>>>
97376>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97378>>>                    Set Size to 21 83
97379>>>                    Set Location to 106 315
97380>>>                    Set Label to "SQL Connections"
97381>>>                    Set peAnchors to anNone
97382>>>                    Set psImage to "SQLConnections1.ico"
97383>>>
97383>>>                    Procedure OnClick 
97386>>>                        Runprogram Background "DUFSQLConnections.exe"
97387>>>                    End_Procedure
97388>>>
97388>>>                End_Object
97389>>>
97389>>>                Object oGetCollation_btn is a Button
97391>>>                    Set Size to 27 91
97392>>>                    Set Location to 154 38
97393>>>                    Set Label to 'Get Database Collation'
97394>>>                
97394>>>                    Procedure OnClick
97397>>>                        String sCollation sDatabase
97397>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97398>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97399>>>                        Set Value of oGetCollation_fm to sCollation
97400>>>                    End_Procedure
97401>>>                
97401>>>                End_Object
97402>>>
97402>>>                Object oGetCollation_fm is a Form
97404>>>                    Set Size to 12 148
97405>>>                    Set Location to 162 143
97406>>>                    Set Label to "Current SQL Collation Name"
97407>>>                    Set Label_Col_Offset to 0
97408>>>                    Set Label_Row_Offset to 1
97409>>>                    Set Label_Justification_Mode to JMode_Top
97410>>>                End_Object
97411>>>        
97411>>>                Object oSetCollation_btn is a Button
97413>>>                    Set Size to 27 91
97414>>>                    Set Location to 188 38
97415>>>                    Set Label to "Set Database Collation"
97416>>>                
97416>>>                    Procedure OnClick
97419>>>                        String sCollation sDatabase sErrorText
97419>>>                        Boolean bOK
97419>>>                        Integer iRetval  
97419>>>                        tSqlErrorArray aSqlErrorArray
97419>>>                        tSqlErrorArray aSqlErrorArray
97419>>>                        
97419>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97420>>>                        Get Value of oSetCollation_fm to sCollation
97421>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97422>>>                        If (iRetval <> MBR_Yes) Begin
97424>>>                            Procedure_Return
97425>>>                        End
97425>>>>
97425>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97426>>>                        If (bOK = True) Begin
97428>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97429>>>                        End
97429>>>>
97429>>>                        Else Begin                   
97430>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97431>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97432>>>                            Move (sErrorText + "\n")                  to sErrorText
97433>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97434>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97435>>>                        End
97435>>>>
97435>>>
97435>>>                    End_Procedure
97436>>>                
97436>>>                End_Object
97437>>>
97437>>>                Object oSetCollation_fm is a Form
97439>>>                    Set Size to 12 148
97440>>>                    Set Location to 197 143
97441>>>                    Set Label to "New SQL Collation Name"
97442>>>                    Set Label_Col_Offset to 0
97443>>>                    Set Label_Row_Offset to 1
97444>>>                    Set Label_Justification_Mode to JMode_Top
97445>>>                End_Object
97446>>>
97446>>>                Procedure Page Integer iPageObject
97449>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97451>>>                    Forward Send Page iPageObject
97453>>>                End_Procedure
97454>>>
97454>>>            End_Object
97455>>>
97455>>>        End_Object
97456>>>        
97456>>>    End_Object
97457>>>
97457>>>End_Object
97458>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97458>>>Use Windows.pkg
97458>>>Use DFClient.pkg
97458>>>Use Dfspnfrm.pkg
97458>>>Use cDbScrollingContainer.pkg
97458>>>Use cRDCButtonDPI.pkg
97458>>>Use cDbUpdateFunctionLibrary.pkg
97458>>>Use SQLDatabaseBackup.dg
97458>>>
97458>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97468>>>>
97468>>>Object oSQLFunctions_vw is a dbView
97470>>>    Set Border_Style to Border_Thick
97471>>>    Set Size to 260 426
97472>>>    Set Location to -4 2
97473>>>    Set Label to "Functions"
97474>>>    Set pbAutoActivate to True
97475>>>    Set Icon to "Sql1.ico"
97476>>>
97476>>>    Procedure OnSetFocus
97479>>>        String sValue
97479>>>        tSQLConnection SQLConnection
97479>>>        tSQLConnection SQLConnection
97479>>>
97479>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97480>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97481>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97482>>>        Set Value of oSQLConnectionString_fm to sValue
97483>>>    End_Procedure
97484>>>
97484>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97486>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97488>>>
97488>>>            Object oSQLFunctionTests_grp is a Group
97490>>>                Set Size to 243 402
97491>>>                Set Location to 7 12
97492>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97493>>>                Set peAnchors to anAll
97494>>>
97494>>>                Object oSQLConnectionString_fm is a Form
97496>>>                    Set Size to 12 375
97497>>>                    Set Location to 23 14
97498>>>                    Set Label to "Current Connection String Settings:"
97499>>>                    Set Label_Col_Offset to 0
97500>>>                    Set Label_Justification_Mode to JMode_Top
97501>>>                    Set peAnchors to anTopLeftRight
97502>>>                    Set Enabled_State to False
97503>>>                    Set Label_Row_Offset to 1
97504>>>                End_Object
97505>>>
97505>>>                Object oSQLDatabase_fm is a Form
97507>>>                    Set Size to 12 86
97508>>>                    Set Location to 50 14
97509>>>                    Set Label to "Database:"
97510>>>                    Set Label_Col_Offset to 0
97511>>>                    Set Label_Justification_Mode to JMode_Top
97512>>>                    Set Label_Row_Offset to 1
97513>>>                    Set FontWeight to fw_Bold
97514>>>                    Set Enabled_State to False
97515>>>                End_Object
97516>>>
97516>>>                Object oDriverID2_cf is a ComboForm
97518>>>                    Set Size to 12 91
97519>>>                    Set Location to 50 121
97520>>>                    Set Label_Col_Offset to 0
97521>>>                    Set Label_Justification_Mode to JMode_Top
97522>>>                    Set Label to "Driver ID:"
97523>>>                    Set Entry_State to False
97524>>>                    Set Enabled_State to False
97525>>>                    Set Label_Row_Offset to 1
97526>>>
97526>>>                    Procedure Combo_Fill_List
97529>>>                        Send Combo_Add_Item MSSQLDRV_ID
97530>>>                        Send Combo_Add_Item DB2_DRV_ID
97531>>>                        Send Combo_Add_Item ODBC_DRV_ID
97532>>>                    End_Procedure
97533>>>
97533>>>                    Procedure Refresh
97536>>>                        String sValue
97536>>>
97536>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97537>>>                        Set Value to sValue
97538>>>                    End_Procedure
97539>>>
97539>>>                End_Object
97540>>>
97540>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97542>>>                    Set Size to 12 109
97543>>>                    Set Location to 50 220
97544>>>                    Set Label to "Backup MS-SQL Database"
97545>>>                    Set psImage to "DbBackup1.ico"
97546>>>
97546>>>                    Procedure OnClick
97549>>>                        Boolean bOK
97549>>>
97549>>>                        // SQLDatabaseBackup dialog:
97549>>>                        Get MakeSQLDatabaseBackup to bOK
97550>>>
97550>>>                        If (bOK = True) Begin
97552>>>                            Send Info_Box "The backup of the database was successful!"
97553>>>                        End
97553>>>>
97553>>>                        Else Begin
97554>>>                            Send Info_Box "The database was not backup up"
97555>>>                        End
97555>>>>
97555>>>                    End_Procedure
97556>>>
97556>>>                End_Object
97557>>>
97557>>>                Object oDatabaseInfo_tb is a TextBox
97559>>>                    Set Auto_Size_State to False
97560>>>                    Set Size to 25 96
97561>>>                    Set Location to 64 14
97562>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97563>>>                    Set Justification_Mode to JMode_Left
97564>>>                End_Object
97565>>>
97565>>>                Object oSQLInfo_tb is a TextBox
97567>>>                    Set Auto_Size_State to False
97568>>>                    Set Size to 37 270
97569>>>                    Set Location to 76 118
97570>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97571>>>                    Set Justification_Mode to JMode_Left
97572>>>                End_Object
97573>>>
97573>>>                Object oSQLTableName_cf is a ComboForm
97575>>>                    Set Size to 12 96
97576>>>                    Set Location to 106 14
97577>>>                    Set Label_Col_Offset to 0
97578>>>                    Set Label_Justification_Mode to JMode_Top
97579>>>                    Set Label to "Select Table:"
97580>>>                    Set Label_Row_Offset to 1
97581>>>                    Set Entry_State to False
97582>>>
97582>>>                    Procedure OnDropDown
97585>>>                        Send DoCombo_Fill_List
97586>>>                    End_Procedure
97587>>>
97587>>>                    Procedure OnCloseUp
97590>>>                        Send Delete_Data of oSQLColumnName_cf
97591>>>                    End_Procedure
97592>>>
97592>>>                    Procedure DoCombo_Fill_List
97595>>>                        String[] sTablesArray
97596>>>                        String sDriverID
97596>>>                        Integer iCount iSize
97596>>>
97596>>>                        Send Delete_Data
97597>>>                        Get Value of oDriverID2_cf to sDriverID
97598>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97599>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97600>>>                        Decrement iSize
97601>>>                        For iCount from 0 to iSize
97607>>>>
97607>>>                            Send Combo_Add_Item sTablesArray[iCount]
97608>>>                        Loop
97609>>>>
97609>>>                    End_Procedure
97610>>>
97610>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97610>>>                    // Augmented Value function.
97610>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97610>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97610>>>                    Function Value Integer iItem Returns String
97613>>>                        String sValue
97613>>>                        Get WinCombo_Current_Item to iItem
97614>>>                        Get WinCombo_Value iItem  to sValue
97615>>>                        Function_Return sValue
97616>>>                    End_Function
97617>>>
97617>>>                End_Object
97618>>>
97618>>>                Object oSQLColumnName_cf is a ComboForm
97620>>>                    Set Size to 12 96
97621>>>                    Set Location to 134 14
97622>>>                    Set Label_Col_Offset to 0
97623>>>                    Set Label_Justification_Mode to JMode_Top
97624>>>                    Set Label to "Select Column:"
97625>>>                    Set Label_Row_Offset to 1
97626>>>                    Set Entry_State to False
97627>>>
97627>>>                    Procedure DoCombo_Fill_List
97630>>>                        String[] sColumnsArray
97631>>>                        String sTableName sDriverID
97631>>>                        Integer iCount iSize
97631>>>
97631>>>                        Send Delete_Data
97632>>>                        Get Value of oDriverID2_cf    to sDriverID
97633>>>                        Get Value of oSQLTableName_cf to sTableName
97634>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
97635>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
97636>>>                        Decrement iSize
97637>>>                        For iCount from 0 to iSize
97643>>>>
97643>>>                            Send Combo_Add_Item sColumnsArray[iCount]
97644>>>                        Loop
97645>>>>
97645>>>                        If (iSize > 1) Begin
97647>>>                            Set Current_Item to 1
97648>>>                        End
97648>>>>
97648>>>                    End_Procedure
97649>>>
97649>>>                    Procedure OnDropDown
97652>>>                        Send DoCombo_Fill_List
97653>>>                    End_Procedure
97654>>>                End_Object
97655>>>
97655>>>                Object oSQLRenameColumnTo_fm is a Form
97657>>>                    Set Size to 12 96
97658>>>                    Set Location to 134 116
97659>>>                    Set Label_Col_Offset to 0
97660>>>                    Set Label_Justification_Mode to JMode_Top
97661>>>                    Set Label to "Rename Column To:"
97662>>>                    Set Label_Row_Offset to 1
97663>>>                    Set Value to "NewColumnName"
97664>>>                End_Object
97665>>>
97665>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
97667>>>                    Set Size to 12 69
97668>>>                    Set Location to 134 220
97669>>>                    Set Label to "Rename Column"
97670>>>                    Set psToolTip to "Test of SQLColumnRename function"
97671>>>                    Set MultiLineState to True
97672>>>
97672>>>                    Procedure OnClick
97675>>>                        Boolean bOk
97675>>>                        Handle hTable
97675>>>                        String sTableName sColumnName sNewColumnName sDriverID
97675>>>
97675>>>                        Get Value of oSQLTableName_cf to sTableName
97676>>>                        If (sTableName = "") Begin
97678>>>                            Send Info_Box "You need to select a table first..."
97679>>>                            Procedure_Return
97680>>>                        End
97680>>>>
97680>>>                        Get Value of oSQLColumnName_cf to sColumnName
97681>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
97683>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
97684>>>                            Procedure_Return
97685>>>                        End
97685>>>>
97685>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
97686>>>                        If (Trim(sNewColumnName) = "") Begin
97688>>>                            Send Info_Box "You need to enter a column name to rename to..."
97689>>>                            Procedure_Return
97690>>>                        End
97690>>>>
97690>>>
97690>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97691>>>                        If (hTable = 0) Begin
97693>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
97694>>>                            Procedure_Return
97695>>>                        End
97695>>>>
97695>>>
97695>>>                        Get Value of oDriverID2_cf to sDriverID
97696>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97697>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
97698>>>                        If (bOk = True) Begin
97700>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
97700>>>                            Send Delete_Data of oSQLColumnName_cf
97701>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
97702>>>                        End
97702>>>>
97702>>>                        Else Begin
97703>>>                            Send Info_Box "Nope, that didn't work..."
97704>>>                        End
97704>>>>
97704>>>
97704>>>                    End_Procedure
97705>>>
97705>>>                End_Object
97706>>>
97706>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
97708>>>                    Set Size to 12 91
97709>>>                    Set Location to 134 297
97710>>>                    Set Label to "Drop Column"
97711>>>                    Set psToolTip to "Test of SQLColumnRemove function"
97712>>>                    Set psImage to "DeleteColumn1.ico"
97713>>>
97713>>>                    Procedure OnClick
97716>>>                        Boolean bOk
97716>>>                        String sTableName sColumnName sDriverID
97716>>>                        Integer iRetval
97716>>>
97716>>>                        Get Value of oDriverID2_cf              to sDriverID
97717>>>                        Get Value of oSQLTableName_cf           to sTableName
97718>>>                        Get Value of oSQLColumnName_cf          to sColumnName
97719>>>
97719>>>                        If (sTableName = "" or sColumnName = "") Begin
97721>>>                            Send Info_Box "You first need to select a table and a column."
97722>>>                            Procedure_Return
97723>>>                        End
97723>>>>
97723>>>
97723>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
97724>>>                        If (iRetval <> MBR_Yes) Begin
97726>>>                            Procedure_Return
97727>>>                        End
97727>>>>
97727>>>
97727>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
97728>>>
97728>>>                        If (bOk = True) Begin
97730>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
97730>>>                            Send Delete_Data of oSQLColumnName_cf
97731>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
97732>>>                        End
97732>>>>
97732>>>                        Else Begin
97733>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
97734>>>                            Procedure_Return
97735>>>                        End
97735>>>>
97735>>>
97735>>>                    End_Procedure
97736>>>
97736>>>                End_Object
97737>>>
97737>>>                Object oSQLAddColumnName_fm is a Form
97739>>>                    Set Size to 12 96
97740>>>                    Set Location to 177 14
97741>>>                    Set Label_Col_Offset to 0
97742>>>                    Set Label_Justification_Mode to JMode_Top
97743>>>                    Set Label to "Column Name:"
97744>>>                    Set Label_Row_Offset to 1
97745>>>                    Set Value to "NewColumn"
97746>>>                End_Object
97747>>>
97747>>>                Object oSQLColumnType_cf is a ComboForm
97749>>>                    Set Size to 12 96
97750>>>                    Set Location to 177 116
97751>>>                    Set Label_Col_Offset to 0
97752>>>                    Set Label_Justification_Mode to JMode_Top
97753>>>                    Set Label_Row_Offset to 1
97754>>>                    Set Label to "Type:"
97755>>>                    Set Entry_State to False
97756>>>
97756>>>                    Procedure Combo_Fill_List
97759>>>                        tColumnType[] ColumnTypeArray
97759>>>                        tColumnType[] ColumnTypeArray
97760>>>                        Integer iSize iCount iDbType
97760>>>                        String sDriverID
97760>>>
97760>>>                        Send Delete_Data
97761>>>                        Get Value of oDriverID2_cf to sDriverID
97762>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
97763>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
97764>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
97765>>>                        Decrement iSize
97766>>>                        For iCount from 0 to iSize
97772>>>>
97772>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
97773>>>                        Loop
97774>>>>
97774>>>                        If (iSize > 0) Begin
97776>>>                            Set Value to ColumnTypeArray[0].sSQLType
97777>>>                        End
97777>>>>
97777>>>                    End_Procedure
97778>>>
97778>>>                    Procedure OnChange
97781>>>                        Integer iType iSize iDec
97781>>>                        tSQLConnection SQLConnection
97781>>>                        tSQLConnection SQLConnection
97781>>>                        Boolean bFixed
97781>>>
97781>>>                        Get SelectedType to iType
97782>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97783>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
97784>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
97785>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
97786>>>
97786>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
97787>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
97788>>>                        Set Value         of oSQLLength_sf   to iSize
97789>>>                        If (iDec = 0) Begin
97791>>>                            Set Value     of oSQLDecimals_sf to ""
97792>>>                        End
97792>>>>
97792>>>                        Else Begin
97793>>>                            Set Value     of oSQLDecimals_sf to iDec
97794>>>                        End
97794>>>>
97794>>>                        If (bFixed = False) Begin
97796>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
97797>>>                        End
97797>>>>
97797>>>                    End_Procedure
97798>>>
97798>>>                    Function SelectedType Returns Integer
97801>>>                        String sValue sDriverID
97801>>>                        Integer iType iDbType
97801>>>
97801>>>                        Get Value to sValue
97802>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
97803>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
97804>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
97805>>>
97805>>>                        Function_Return iType
97806>>>                    End_Function
97807>>>
97807>>>                End_Object
97808>>>
97808>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
97810>>>                    Set Size to 12 69
97811>>>                    Set Location to 177 220
97812>>>                    Set Label to "Add Column"
97813>>>                    Set psToolTip to "Test of SQLColumnAdd function"
97814>>>                    Set psImage to "AddColumn1.ico"
97815>>>
97815>>>                    Procedure OnClick
97818>>>                        Boolean bOk bInitialize
97818>>>                        Handle hTable
97818>>>                        String sTableName sColumnName sType sColumnValue sDriverID
97818>>>                        Integer iType iLength iDecimals
97818>>>
97818>>>                        Get Value of oDriverID2_cf              to sDriverID
97819>>>                        Get Value of oSQLTableName_cf           to sTableName
97820>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
97821>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
97822>>>                        Get Value         of oSQLColumnType_cf  to sType
97823>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
97824>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
97825>>>                        Get Value         of oSQLLength_sf      to iLength
97826>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
97827>>>
97827>>>                        If (sTableName <> "") Begin
97829>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97830>>>                            If (hTable = 0) Begin
97832>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97833>>>                            End
97833>>>>
97833>>>                        End
97833>>>>
97833>>>                        If (hTable = 0) Begin
97835>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
97836>>>                            Procedure_Return
97837>>>                        End
97837>>>>
97837>>>                        If (sColumnName = "") Begin
97839>>>                            Send Info_Box "You need to enter a column name"
97840>>>                            Procedure_Return
97841>>>                        End
97841>>>>
97841>>>
97841>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
97842>>>
97842>>>                        If (bOk = True) Begin
97844>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
97845>>>                        End
97845>>>>
97845>>>                        Else Begin
97846>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
97847>>>                            Procedure_Return
97848>>>                        End
97848>>>>
97848>>>
97848>>>                    End_Procedure
97849>>>
97849>>>                End_Object
97850>>>
97850>>>//                Object oTest_btn is a cRDCButtonDPI
97850>>>//                    Set Size to 13 92
97850>>>//                    Set Location to 177 298
97850>>>//                    Set Label to "Test SQL script button"
97850>>>//
97850>>>//                    Procedure OnClick
97850>>>//                        Boolean bOK
97850>>>//                        String sTableName sColumnName
97850>>>//
97850>>>//                        Get Value of oSQLTableName_cf      to sTableName
97850>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
97850>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
97850>>>//
97850>>>//                    End_Procedure
97850>>>//
97850>>>//                End_Object
97850>>>
97850>>>                Object oSQLLength_sf is a SpinForm
97852>>>                    Set Label to "Length:"
97853>>>                    Set Size to 12 40
97854>>>                    Set Location to 202 16
97855>>>                    Set Label_Col_Offset to 0
97856>>>                    Set Label_Justification_Mode to JMode_Top
97857>>>                    Set Label_Row_Offset to 1
97858>>>                    Set Value to "10"
97859>>>                    Set Maximum_Position to 500
97860>>>                    Set Minimum_Position to 1
97861>>>                End_Object
97862>>>
97862>>>                Object oSQLDecimals_sf is a SpinForm
97864>>>                    Set Label to "Decimals:"
97865>>>                    Set Size to 12 33
97866>>>                    Set Location to 202 60
97867>>>                    Set Label_Col_Offset to 0
97868>>>                    Set Label_Justification_Mode to JMode_Top
97869>>>                    Set Label_Row_Offset to 1
97870>>>                    Set Value to "0"
97871>>>                    Set Maximum_Position to 16
97872>>>                    Set Minimum_Position to 1
97873>>>                End_Object
97874>>>
97874>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
97876>>>                    Set Size to 12 85
97877>>>                    Set Location to 202 116
97878>>>                    Set Label to "Initialize Column Value"
97879>>>
97879>>>                    Procedure OnChange
97882>>>                        Boolean bChecked
97882>>>
97882>>>                        Get Checked_State to bChecked
97883>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
97884>>>                    End_Procedure
97885>>>
97885>>>                End_Object
97886>>>
97886>>>                Object oSQLColumnValue_fm is a Form
97888>>>                    Set Size to 12 96
97889>>>                    Set Location to 218 116
97890>>>                    Set Label_Col_Offset to 2
97891>>>                    Set Label_Justification_Mode to JMode_Right
97892>>>                    Set Label to "Column Value"
97893>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
97894>>>                    Set Enabled_State to False
97895>>>                End_Object
97896>>>
97896>>>                Object oEnumRelations_btn is a cRDCButtonDPI
97898>>>                    Set Size to 12 91
97899>>>                    Set Location to 116 297
97900>>>                    Set Label to "Test Enum SQL Relations"
97901>>>
97901>>>                    Procedure OnClick
97904>>>                        tSQLRelation[] SQLRelationArray
97904>>>                        tSQLRelation[] SQLRelationArray
97905>>>                        String sTableName sDriverID
97905>>>                        Integer iSize iCount
97905>>>
97905>>>                        Get Value of oDriverID2_cf to sDriverID
97906>>>                        Get Value of oSQLTableName_cf to sTableName
97907>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
97908>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
97909>>>                        Decrement iSize
97910>>>                        For iCount from 0 to iSize
97916>>>>
97916>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
97925>>>                        Loop
97926>>>>
97926>>>                        If (iSize < 1) Begin
97928>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
97929>>>                        End
97929>>>>
97929>>>
97929>>>                    End_Procedure
97930>>>
97930>>>                End_Object
97931>>>
97931>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
97933>>>                    Set Size to 12 101
97934>>>                    Set Location to 177 297
97935>>>                    Set Label to "Enumerate Logged In Users"
97936>>>
97936>>>                    Procedure OnClick
97939>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97939>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97940>>>                        String sDriverID sDatabase
97940>>>                        Integer iSize iCount
97940>>>
97940>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97941>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
97942>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
97943>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
97944>>>                        Decrement iSize
97945>>>
97945>>>                        Showln "SQL User Name" " and Program:"
97948>>>                        For iCount from 0 to iSize
97954>>>>
97954>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
97958>>>                        Loop
97959>>>>
97959>>>                    End_Procedure
97960>>>
97960>>>                End_Object
97961>>>
97961>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
97963>>>                    Set Size to 12 101
97964>>>                    Set Location to 193 297
97965>>>                    Set Label to "Is Table or View?"
97966>>>
97966>>>                    Procedure OnClick
97969>>>                        String sDriverID sTableName
97969>>>                        Handle hTable
97969>>>                        Boolean bViewTableType
97969>>>
97969>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97970>>>                        Get Value of oSQLTableName_cf to sTableName
97971>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97972>>>                        If (hTable = 0) Begin
97974>>>                            Procedure_Return
97975>>>                        End
97975>>>>
97975>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
97976>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
97977>>>                    End_Procedure
97978>>>
97978>>>                End_Object
97979>>>
97979>>>            End_Object
97980>>>
97980>>>        End_Object
97981>>>
97981>>>    End_Object
97982>>>
97982>>>End_Object
97983>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
97983>>>Use Windows.pkg
97983>>>Use DFClient.pkg
97983>>>Use Dfspnfrm.pkg
97983>>>Use Dfline.pkg
97983>>>Use cDbScrollingContainer.pkg
97983>>>Use cRDCButtonDPI.pkg
97983>>>Use cDbUpdateFunctionLibrary.pkg
97983>>>
97983>>>Define CI_Table1_FileNo for 401
97983>>>Define CI_View1_FileNo  for 402
97983>>>
97983>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
97993>>>>
97993>>>Object oAPIFunctions_vw is a dbView
97995>>>    Set Border_Style to Border_Thick
97996>>>    Set Size to 237 424
97997>>>    Set Location to 17 2
97998>>>    Set Label to "API Functions"
97999>>>    Set pbAutoActivate to True
98000>>>    Set Icon to "APIFunctions1.ico"
98001>>>
98001>>>    Property String psTableName ""
98003>>>
98003>>>    Procedure OnSetFocus
98006>>>        String sValue
98006>>>        tSQLConnection SQLConnection
98006>>>        tSQLConnection SQLConnection
98006>>>
98006>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98007>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98008>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98009>>>        Set Value of oApiConnectionString_fm to sValue
98010>>>    End_Procedure
98011>>>
98011>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98013>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98015>>>
98015>>>            Object oApiFunctions_grp is a Group
98017>>>                Set Size to 222 402
98018>>>                Set Location to 6 12
98019>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98020>>>                Set peAnchors to anAll
98021>>>
98021>>>                Object oApiConnectionString_fm is a Form
98023>>>                    Set Size to 12 368
98024>>>                    Set Location to 23 14
98025>>>                    Set Label to "Current Connection String Settings:"
98026>>>                    Set Label_Col_Offset to 0
98027>>>                    Set Label_Justification_Mode to JMode_Top
98028>>>                    Set peAnchors to anTopLeftRight
98029>>>                    Set Enabled_State to False
98030>>>                    Set Label_Row_Offset to 1
98031>>>                End_Object
98032>>>
98032>>>                Object oApiDatabase_fm is a Form
98034>>>                    Set Size to 12 86
98035>>>                    Set Location to 50 14
98036>>>                    Set Label to "Database:"
98037>>>                    Set Label_Col_Offset to 0
98038>>>                    Set Label_Justification_Mode to JMode_Top
98039>>>                    Set Label_Row_Offset to 1
98040>>>                    Set Enabled_State to False
98041>>>                    Set FontWeight to fw_Bold
98042>>>//                    Set Label_FontWeight to fw_Bold
98042>>>
98042>>>                    Procedure Page Integer iPageObject
98045>>>                        String sValue
98045>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98046>>>                        Set Value to sValue
98047>>>
98047>>>                        Forward Send Page iPageObject
98049>>>                    End_Procedure
98050>>>
98050>>>                End_Object
98051>>>
98051>>>                Object oDriverID3_cf is a ComboForm
98053>>>                    Set Size to 12 91
98054>>>                    Set Location to 51 121
98055>>>                    Set Label_Col_Offset to 0
98056>>>                    Set Label_Justification_Mode to JMode_Top
98057>>>                    Set Label to "Driver ID:"
98058>>>                    Set Entry_State to False
98059>>>                    Set Enabled_State to False
98060>>>                    Set Label_Row_Offset to 1
98061>>>                    Set Enabled_State to False
98062>>>
98062>>>                    Procedure Combo_Fill_List
98065>>>                        Send Combo_Add_Item MSSQLDRV_ID
98066>>>                        Send Combo_Add_Item DB2_DRV_ID
98067>>>                        Send Combo_Add_Item ODBC_DRV_ID
98068>>>                    End_Procedure
98069>>>
98069>>>                    Procedure Refresh
98072>>>                        String sValue
98072>>>
98072>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98073>>>                        Set Value to sValue
98074>>>                    End_Procedure
98075>>>
98075>>>                End_Object
98076>>>
98076>>>                Object oDatabaseInfo_tb is a TextBox
98078>>>                    Set Auto_Size_State to False
98079>>>                    Set Size to 25 96
98080>>>                    Set Location to 64 14
98081>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98082>>>                    Set Justification_Mode to JMode_Left
98083>>>                End_Object
98084>>>
98084>>>                Object oApiTableName_fm is a Form
98086>>>                    Set Size to 12 77
98087>>>                    Set Location to 114 14
98088>>>                    Set Label_Col_Offset to 0
98089>>>                    Set Label_Justification_Mode to JMode_Top
98090>>>                    Set Label to "Table Name:"
98091>>>                    Set Label_Row_Offset to 1
98092>>>                    Set Value to "NewTable"
98093>>>                    Procedure OnChange
98096>>>                        String sValue
98096>>>                        Get Value to sValue
98097>>>                        Set psTableName to sValue
98098>>>                    End_Procedure
98099>>>                    Send OnChange
98100>>>                End_Object
98101>>>
98101>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98103>>>                    Set Size to 12 69
98104>>>                    Set Location to 114 271
98105>>>                    Set Label to "Add Table"
98106>>>                    Set psImage to "ActionAddTable1.ico"
98107>>>
98107>>>                    Procedure OnClick
98110>>>                        Boolean bOk
98110>>>                        Handle hTable
98110>>>                        String sTableName sDriverID
98110>>>
98110>>>                        Get Value of oDriverID3_cf to sDriverID
98111>>>                        Get Value of oApiTableName_fm to sTableName
98112>>>                        Move (Trim(sTableName)) to sTableName
98113>>>                        If (sTableName = "") Begin
98115>>>                            Send Info_Box "You first need to enter a table name."
98116>>>                            Procedure_Return
98117>>>                        End
98117>>>>
98117>>>
98117>>>                        Send Cursor_Wait of Cursor_Control
98118>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98119>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98120>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98121>>>                        If (bOk = True) Begin
98123>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98124>>>                        End
98124>>>>
98124>>>                        Else Begin
98125>>>                            Send Cursor_Ready of Cursor_Control
98126>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98127>>>                            Procedure_Return
98128>>>                        End
98128>>>>
98128>>>
98128>>>                    End_Procedure
98129>>>
98129>>>                End_Object
98130>>>
98130>>>                Object oApiAddColumn_fm is a Form
98132>>>                    Set Size to 12 77
98133>>>                    Set Location to 141 14
98134>>>                    Set Label_Col_Offset to 0
98135>>>                    Set Label_Justification_Mode to JMode_Top
98136>>>                    Set Label to "Column Name:"
98137>>>                    Set Label_Row_Offset to 1
98138>>>                    Set Value to "NewColumn"
98139>>>                End_Object
98140>>>
98140>>>                Object oApiColumnType_cf is a ComboForm
98142>>>                    Set Size to 12 85
98143>>>                    Set Location to 141 96
98144>>>                    Set Label_Col_Offset to 0
98145>>>                    Set Label_Justification_Mode to JMode_Top
98146>>>                    Set Label_Row_Offset to 1
98147>>>                    Set Label to "Type:"
98148>>>                    Set Entry_State to False
98149>>>
98149>>>                    Procedure Combo_Fill_List
98152>>>                        tColumnType[] ColumnTypeArray
98152>>>                        tColumnType[] ColumnTypeArray
98153>>>                        Integer iSize iCount
98153>>>
98153>>>                        Send Delete_Data
98154>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98155>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98156>>>                        Decrement iSize
98157>>>                        For iCount from 0 to iSize
98163>>>>
98163>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98164>>>                        Loop
98165>>>>
98165>>>                        Set Value to ColumnTypeArray[0].sSQLType
98166>>>                    End_Procedure
98167>>>
98167>>>                    Procedure OnChange
98170>>>                        Integer iType iSize iDec
98170>>>                        tSQLConnection SQLConnection
98170>>>                        tSQLConnection SQLConnection
98170>>>                        Boolean bFixed
98170>>>
98170>>>                        Get SelectedType to iType
98171>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98172>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98173>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98174>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98175>>>
98175>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98176>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98177>>>                        Set Value         of oApiLength_sf   to iSize
98178>>>                        If (iDec = 0) Begin
98180>>>                            Set Value     of oApiDecimals_sf to ""
98181>>>                        End
98181>>>>
98181>>>                        Else Begin
98182>>>                            Set Value     of oApiDecimals_sf to iDec
98183>>>                        End
98183>>>>
98183>>>                        If (bFixed = False) Begin
98185>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98186>>>                        End
98186>>>>
98186>>>                    End_Procedure
98187>>>
98187>>>                    Function SelectedType Returns Integer
98190>>>                        String sValue
98190>>>                        Integer iType
98190>>>
98190>>>                        Get Value to sValue
98191>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98192>>>
98192>>>                        Function_Return iType
98193>>>                    End_Function
98194>>>
98194>>>                End_Object
98195>>>
98195>>>                Object oApiLength_sf is a SpinForm
98197>>>                    Set Label to "Length:"
98198>>>                    Set Size to 12 35
98199>>>                    Set Location to 141 186
98200>>>                    Set Label_Col_Offset to 0
98201>>>                    Set Label_Justification_Mode to JMode_Top
98202>>>                    Set Label_Row_Offset to 1
98203>>>                    Set Value to "10"
98204>>>                    Set Maximum_Position to 500
98205>>>                    Set Minimum_Position to 1
98206>>>                End_Object
98207>>>
98207>>>                Object oApiDecimals_sf is a SpinForm
98209>>>                    Set Label to "Decimals:"
98210>>>                    Set Size to 12 33
98211>>>                    Set Location to 141 225
98212>>>                    Set Label_Col_Offset to 0
98213>>>                    Set Label_Justification_Mode to JMode_Top
98214>>>                    Set Label_Row_Offset to 1
98215>>>                    Set Value to "0"
98216>>>                    Set Maximum_Position to 16
98217>>>                    Set Minimum_Position to 1
98218>>>                End_Object
98219>>>
98219>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98221>>>                    Set Size to 12 69
98222>>>                    Set Location to 141 271
98223>>>                    Set Label to "Add Column"
98224>>>                    Set psToolTip to "ApiColumnAdd function"
98225>>>                    Set psImage to "ActionAddColumn1.ico"
98226>>>
98226>>>                    Procedure OnClick
98229>>>                        Boolean bOk
98229>>>                        Handle hTable
98229>>>                        String sTableName sColumnName sType sDriverID
98229>>>                        Integer iType iLength iDecimals
98229>>>
98229>>>                        Get Value of oDriverID3_cf            to sDriverID
98230>>>                        Get Value of oApiTableName_fm         to sTableName
98231>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98232>>>                        Get SelectedType of oApiColumnType_cf to iType
98233>>>                        Get Value        of oApiLength_sf     to iLength
98234>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98235>>>
98235>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98236>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98237>>>                        If (hTable = 0) Begin
98239>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98240>>>                            Procedure_Return
98241>>>                        End
98241>>>>
98241>>>                        If (sColumnName = "") Begin
98243>>>                            Send Info_Box "You need to enter a column name"
98244>>>                            Procedure_Return
98245>>>                        End
98245>>>>
98245>>>
98245>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98246>>>                        If (bOk = True) Begin
98248>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98249>>>                        End
98249>>>>
98249>>>                        Else Begin
98250>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98251>>>                            Procedure_Return
98252>>>                        End
98252>>>>
98252>>>
98252>>>                    End_Procedure
98253>>>
98253>>>                End_Object
98254>>>
98254>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98256>>>                    Set Size to 26 77
98257>>>                    Set Location to 184 14
98258>>>                    Set Label to "Create 'New' Table with Three Columns"
98259>>>                    Set MultiLineState to True
98260>>>                    Set psImage to "ActionAddTable1.ico"
98261>>>
98261>>>                    Procedure OnClick
98264>>>                        Boolean bOk
98264>>>                        Handle hTable
98264>>>                        String sTableName sDriverID
98264>>>
98264>>>                        Get Value of oDriverID3_cf to sDriverID
98265>>>                        Get Value of oApiTableName_fm to sTableName
98266>>>                        Move (Trim(sTableName)) to sTableName
98267>>>                        If (sTableName = "") Begin
98269>>>                            Send Info_Box "You first need to enter a table name."
98270>>>                            Procedure_Return
98271>>>                        End
98271>>>>
98271>>>
98271>>>                        Send Cursor_Wait of Cursor_Control
98272>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98273>>>
98273>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98274>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98275>>>                        If (bOk = True) Begin
98277>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98278>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98279>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98280>>>                        End
98280>>>>
98280>>>                        Send Cursor_Ready of Cursor_Control
98281>>>
98281>>>                        If (bOk = True) Begin
98283>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98284>>>                        End
98284>>>>
98284>>>                        Else Begin
98285>>>                            Send Cursor_Ready of Cursor_Control
98286>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98287>>>                            Procedure_Return
98288>>>                        End
98288>>>>
98288>>>
98288>>>                    End_Procedure
98289>>>
98289>>>                End_Object
98290>>>
98290>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98292>>>                    Set Size to 26 77
98293>>>                    Set Location to 184 96
98294>>>                    Set Label to "Remove 'New' Table"
98295>>>                    Set psImage to "ActionDeleteTable1.ico"
98296>>>                    Set MultiLineState to True
98297>>>
98297>>>                    Procedure OnClick
98300>>>                        Boolean bOk
98300>>>                        Integer iRetval
98300>>>                        Handle hTable
98300>>>                        String sTableName sDriverID
98300>>>
98300>>>                        Get Value of oDriverID3_cf to sDriverID
98301>>>                        Get Value of oApiTableName_fm to sTableName
98302>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98303>>>                        If (iRetval = MBR_Yes) Begin
98305>>>                            Send Cursor_Wait of Cursor_Control
98306>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98307>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98308>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98309>>>                            Send Cursor_Ready of Cursor_Control
98310>>>                            If (bOk = True) Begin
98312>>>                                Send Info_Box "Table removed"
98313>>>                            End
98313>>>>
98313>>>                            Else Begin
98314>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98315>>>                            End
98315>>>>
98315>>>                        End
98315>>>>
98315>>>                    End_Procedure
98316>>>
98316>>>                End_Object
98317>>>
98317>>>                Object oLineControl1 is a LineControl
98319>>>                    Set Size to 2 387
98320>>>                    Set Location to 96 6
98321>>>                    Set peAnchors to anTopLeftRight
98322>>>                End_Object
98323>>>
98323>>>                Object oLineControl2 is a LineControl
98325>>>                    Set Size to 3 248
98326>>>                    Set Location to 171 9
98327>>>                End_Object
98328>>>
98328>>>                Object oTestError_fm is a Form
98330>>>                    Set Size to 13 64
98331>>>                    Set Location to 186 180
98332>>>                    Set Form_Datatype to 0 
98333>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98334>>>                End_Object
98335>>>
98335>>>Register_Function FetchErrorDescription Integer iError Returns String
98335>>>                Object oFindErrorText_Btn is a Button
98337>>>                    Set Size to 13 70
98338>>>                    Set Location to 186 248
98339>>>                    Set Label to "Find Error Text"
98340>>>                
98340>>>                    Procedure OnClick
98343>>>                        String sRetval
98343>>>                        Integer iError 
98343>>>                        Handle hoLogFile
98343>>>                        
98343>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98344>>>                        Get Value of oTestError_fm to iError
98345>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98346>>>                        Set Value of oErrorText_fm to sRetval    
98347>>>                    End_Procedure
98348>>>                
98348>>>                End_Object
98349>>>
98349>>>                Object oErrorText_fm is a Form
98351>>>                    Set Size to 13 213
98352>>>                    Set Location to 202 180
98353>>>                End_Object
98354>>>
98354>>>            End_Object
98355>>>
98355>>>        End_Object
98356>>>
98356>>>    End_Object
98357>>>
98357>>>End_Object
98358>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98358>>>
98358>>>Use Windows.pkg
98358>>>Use DFClient.pkg
98358>>>Use Dfline.pkg
98358>>>Use cDbScrollingContainer.pkg
98358>>>Use cRDCButtonDPI.pkg
98358>>>Use cDbUpdateFunctionLibrary.pkg
98358>>>Use Dftreevw.pkg
98358>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98358>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98358>>>>>//
98358>>>>>// This program is free software; you can redistribute it and/or
98358>>>>>// modify it under the terms of the GNU General Public License
98358>>>>>// as published by the Free Software Foundation; version 2
98358>>>>>// of the License.
98358>>>>>
98358>>>>>// This program is distributed in the hope that it will be useful,
98358>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98358>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98358>>>>>// GNU General Public License for more details.
98358>>>>>
98358>>>>>// You should have received a copy of the GNU General Public License
98358>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98358>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98358>>>>>Use Windows.pkg
98358>>>>>
98358>>>>>Object oWorkingMessagePanel is a ToolPanel
98360>>>>>    Set Label    to "Working"
98361>>>>>    Set Size to 48 150
98362>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98363>>>>>    Set Popup_State to True
98364>>>>>
98364>>>>>    Object oWorkingMessage is a Textbox
98366>>>>>        Set Label to "Working message..."
98367>>>>>        Set Location to 15 5
98368>>>>>        Set Size to 27 123
98369>>>>>        Set Auto_Size_State to False
98370>>>>>        Set Justification_Mode to JMode_Center
98371>>>>>        Set FontWeight to fw_Bold
98372>>>>>    End_Object
98373>>>>>
98373>>>>>End_Object
98374>>>>>
98374>>>>>Procedure StartWorkingMessage Global String sText
98376>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98377>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98378>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98379>>>>>End_Procedure
98380>>>>>
98380>>>>>Procedure StopWorkingMessage Global
98382>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98383>>>>>End_Procedure
98384>>>Use DUFStatusPanel.pkg
98384>>>Use cCharTranslate.pkg
98384>>>
98384>>>Struct tFilelistDUF
98384>>>    Integer iFileNumber
98384>>>    String sLogicalName
98384>>>    String sRootName
98384>>>    String sDisplayName
98384>>>End_Struct
98384>>>
98384>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98394>>>>
98394>>>Object oUtilFunctions_vw is a dbView
98396>>>    Set Border_Style to Border_Thick
98397>>>    Set Size to 291 428
98398>>>    Set Location to 2 1
98399>>>    Set Label to "Utility Functions"
98400>>>    Set pbAutoActivate to True
98401>>>    Set Icon to "TestTools1.ico"
98402>>>    Set pbAcceptDropFiles to True
98403>>>
98403>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98405>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98407>>>
98407>>>            Object oSQL_grp is a Group
98409>>>                Set Size to 88 402
98410>>>                Set Location to 7 12
98411>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98412>>>                Set peAnchors to anTopLeftRight
98413>>>
98413>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98415>>>                    Set Size to 14 219
98416>>>                    Set Location to 13 13
98417>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98418>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98419>>>                    Set psImage to "ActionCreateDatabase1.ico"
98420>>>
98420>>>                    Procedure OnClick
98423>>>                        String sInfoText sDriverID
98423>>>                        Boolean bOK
98423>>>                        TimeSpan tsTotalQueryTime
98423>>>                        Integer iRetval
98423>>>
98423>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98423>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98423>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98423>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98424>>>                        If (iRetval <> MBR_Yes) Begin
98426>>>                            Procedure_Return
98427>>>                        End
98427>>>>
98427>>>
98427>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98428>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98430>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98431>>>                            Procedure_Return
98432>>>                        End
98432>>>>
98432>>>
98432>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98433>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98434>>>                        Send StopWorkingMessage
98435>>>
98435>>>                        If (bOK = True) Begin
98437>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98438>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98439>>>                        End
98439>>>>
98439>>>
98439>>>                        Else Begin
98440>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98441>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98442>>>                        End
98442>>>>
98442>>>
98442>>>                        Send Info_Box sInfoText
98443>>>                    End_Procedure
98444>>>
98444>>>                End_Object
98445>>>
98445>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98447>>>                    Set Size to 14 219
98448>>>                    Set Location to 33 13
98449>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98450>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98451>>>                    Set psImage to "ActionCreateDatabase1.ico"
98452>>>
98452>>>                    Procedure OnClick
98455>>>                        String sInfoText sDriverID
98455>>>                        Boolean bOK
98455>>>                        TimeSpan tsTotalQueryTime
98455>>>                        Integer iRetval
98455>>>
98455>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98455>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98455>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98455>>>
98455>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98456>>>                        If (iRetval <> MBR_Yes) Begin
98458>>>                            Procedure_Return
98459>>>                        End
98459>>>>
98459>>>
98459>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98460>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98462>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98463>>>                            Procedure_Return
98464>>>                        End
98464>>>>
98464>>>
98464>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98465>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98466>>>                        Send StopWorkingMessage
98467>>>
98467>>>                        If (bOK = True) Begin
98469>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98470>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98471>>>                        End
98471>>>>
98471>>>
98471>>>                        Else Begin
98472>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98473>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98474>>>                        End
98474>>>>
98474>>>
98474>>>                        Send Info_Box sInfoText
98475>>>                    End_Procedure
98476>>>
98476>>>                End_Object
98477>>>
98477>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98479>>>                    Set Size to 14 219
98480>>>                    Set Location to 53 13
98481>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98482>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98483>>>                    Set psImage to "ActionCreateDatabase1.ico"
98484>>>
98484>>>                    Procedure OnClick
98487>>>                        String sInfoText sDriverID
98487>>>                        Boolean bOK
98487>>>                        TimeSpan tsTotalQueryTime
98487>>>                        Integer iRetval
98487>>>
98487>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98487>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98487>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98487>>>
98487>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98488>>>                        If (iRetval <> MBR_Yes) Begin
98490>>>                            Procedure_Return
98491>>>                        End
98491>>>>
98491>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98492>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98494>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98495>>>                            Procedure_Return
98496>>>                        End
98496>>>>
98496>>>
98496>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98497>>>
98497>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98498>>>
98498>>>                        Send StopWorkingMessage
98499>>>                        If (bOK = True) Begin
98501>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98502>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98503>>>                        End
98503>>>>
98503>>>
98503>>>                        Else Begin
98504>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98505>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98506>>>                        End
98506>>>>
98506>>>
98506>>>                        Send Info_Box sInfoText
98507>>>                    End_Procedure
98508>>>
98508>>>                End_Object
98509>>>
98509>>>                Object oInfo_tb is a TextBox
98511>>>                    Set Auto_Size_State to False
98512>>>                    Set Size to 25 158
98513>>>                    Set Location to 53 238
98514>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98515>>>                    Set Justification_Mode to JMode_Left
98516>>>                    Set peAnchors to anTopLeftRight
98517>>>                End_Object
98518>>>
98518>>>        //  This will choke the computer so don't try it!
98518>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98518>>>        //            Set Size to 14 312
98518>>>        //            Set Location to 97 45
98518>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98518>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98518>>>        //
98518>>>        //            Procedure OnClick
98518>>>        //                String sInfoText
98518>>>        //                Boolean bOK
98518>>>        //                TimeSpan tsTotalQueryTime
98518>>>        //                Integer iRetval
98518>>>        //
98518>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98518>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98518>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98518>>>        //Procedure_Return
98518>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98518>>>        //                If (iRetval <> MBR_Yes) Begin
98518>>>        //                    Procedure_Return
98518>>>        //                End
98518>>>        //
98518>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98518>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98518>>>        //                Send StopWorkingMessage
98518>>>        //
98518>>>        //                If (bOK = True) Begin
98518>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98518>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98518>>>        //                End
98518>>>        //
98518>>>        //                Else Begin
98518>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98518>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98518>>>        //                End
98518>>>        //
98518>>>        //                Send Info_Box sInfoText
98518>>>        //            End_Procedure
98518>>>        //
98518>>>        //        End_Object
98518>>>
98518>>>            End_Object
98519>>>
98519>>>            Object oChangeIntFiles_grp is a Group
98521>>>                Set Size to 65 402
98522>>>                Set Location to 102 12
98523>>>                Set Label to "Change Old .int files to use Connection ID's"
98524>>>                Set peAnchors to anTopLeftRight
98525>>>
98525>>>                Object oSelectDataPath_fm is a Form
98527>>>                    Set Size to 12 300
98528>>>                    Set Location to 22 13
98529>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98530>>>                    Set Label_Col_Offset to 0
98531>>>                    Set Label_Row_Offset to 1
98532>>>                    Set Label_Justification_Mode to JMode_Top
98533>>>
98533>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98533>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98533>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98534>>>                    Set peAnchors to anTopLeftRight
98535>>>
98535>>>                    Procedure Prompt
98538>>>                        String sPath sFileMask sRetval
98538>>>
98538>>>                        Get psDataPathFirstPart to sPath
98539>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98540>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98541>>>                        If (sRetval <> "") Begin
98543>>>                            Get ParseFolderName sRetval to sPath
98544>>>                            If (Right(sPath, 1) ="\") Begin
98546>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98547>>>                            End
98547>>>>
98547>>>                            Set Value to sPath
98548>>>                        End
98548>>>>
98548>>>                    End_Procedure
98549>>>
98549>>>                    // Returns the first datapath found in the psDataPath property.
98549>>>                    // The returned path always ends with a "\"
98549>>>                    Function psDataPathFirstPart Returns String
98552>>>                        String sDataPath
98552>>>                        Integer iCount
98552>>>
98552>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98553>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98554>>>                        If (iCount > 1) Begin
98556>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98557>>>                        End
98557>>>>
98557>>>                        If (sDataPath <> "") Begin
98559>>>                            Get vFolderFormat sDataPath to sDataPath
98560>>>                        End
98560>>>>
98560>>>
98560>>>                        Function_Return sDataPath
98561>>>                    End_Function
98562>>>
98562>>>                End_Object
98563>>>
98563>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98565>>>                    Set Size to 13 73
98566>>>                    Set Location to 22 320
98567>>>                    Set Label to "Select Folder"
98568>>>                    Set psToolTip to "Please select an .int file from the data folder"
98569>>>                    Set peAnchors to anTopRight
98570>>>                    Set psImage to "ActionOpen1.ico"
98571>>>
98571>>>                    Procedure OnClick
98574>>>                        Send Prompt to oSelectDataPath_fm
98575>>>                    End_Procedure
98576>>>
98576>>>                End_Object
98577>>>
98577>>>                Object oConnectionID_fm is a Form
98579>>>                    Set Size to 13 111
98580>>>                    Set Location to 38 202
98581>>>                    Set Label_Col_Offset to 2
98582>>>                    Set Label_Justification_Mode to JMode_Right
98583>>>                    Set Label to "Change to DFConnID:"
98584>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98585>>>                    Set peAnchors to anTopRight
98586>>>                End_Object
98587>>>
98587>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98589>>>                    Set Size to 13 68
98590>>>                    Set Location to 38 320
98591>>>                    Set Label to "GO !"
98592>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98593>>>                    Set FontWeight to fw_Bold
98594>>>                    Set peAnchors to anTopRight
98595>>>
98595>>>                    Procedure OnClick
98598>>>                        String sDataPath sConnectionID
98598>>>                        Boolean bExists bActive
98598>>>                        Integer iRetval iChangedFiles
98598>>>
98598>>>                        Get Value of oSelectDataPath_fm to sDataPath
98599>>>                        Get vFolderExists sDataPath to bExists
98600>>>                        If (bExists = False) Begin
98602>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98603>>>                            Procedure_Return
98604>>>                        End
98604>>>>
98604>>>                        Get Value of oConnectionID_fm to sConnectionID
98605>>>                        Move (Trim(sConnectionID)) to sConnectionID
98606>>>                        If (sConnectionID = "") Begin
98608>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98609>>>                            Procedure_Return
98610>>>                        End
98610>>>>
98610>>>
98610>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98611>>>                        If (iRetval <> MBR_Yes) Begin
98613>>>                            Procedure_Return
98614>>>                        End
98614>>>>
98614>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98615>>>                        If (iRetval <> MBR_Yes) Begin
98617>>>                            Procedure_Return
98618>>>                        End
98618>>>>
98618>>>
98618>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
98619>>>                        If (iRetval <> 0) Begin
98621>>>                            Send Info_Box "Could not delete .cch files!"
98622>>>                            Procedure_Return
98623>>>                        End
98623>>>>
98623>>>
98623>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
98624>>>                        Send Start_StatusPanel of ghoStatusPanel
98625>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
98626>>>
98626>>>                        Get Active_State of ghoStatusPanel to bActive
98627>>>                        If (bActive = False) Begin
98629>>>                            Send Info_Box "Process interupted..."
98630>>>                        End
98630>>>>
98630>>>                        Else Begin
98631>>>                            Send Stop_StatusPanel of ghoStatusPanel
98632>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
98633>>>                        End
98633>>>>
98633>>>                    End_Procedure
98634>>>
98634>>>                End_Object
98635>>>
98635>>>            End_Object
98636>>>
98636>>>            Object oRemoveFilelistDriverIDs_grp is a Group
98638>>>                Set Size to 59 402
98639>>>                Set Location to 171 12
98640>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
98641>>>                Set peAnchors to anTopLeftRight
98642>>>//                Set TextColor to clGreen
98642>>>//
98642>>>//                Procedure Page Integer iPage
98642>>>//                    Integer ia iz
98642>>>//                    Forward Send Page iPage
98642>>>//                    Move 0 to iz
98642>>>//                    Move (AddressOf(iz)) to ia
98642>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
98642>>>//                End_Procedure
98642>>>
98642>>>                Object oFilelistPath_fm is a Form
98644>>>                    Set Size to 13 299
98645>>>                    Set Location to 22 13
98646>>>                    Set Label to "Path and Filelist.cfg Name:"
98647>>>                    Set Label_Col_Offset to 0
98648>>>                    Set Label_Row_Offset to 1
98649>>>                    Set Label_Justification_Mode to JMode_Top
98650>>>
98650>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98650>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98650>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
98651>>>                    Set peAnchors to anTopLeftRight
98652>>>
98652>>>                    Procedure Prompt
98655>>>                        String sFileName sPath sFileMask sRetval
98655>>>
98655>>>                        Get Value to sFileName
98656>>>                        Get ParseFolderName sFileName to sPath
98657>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
98658>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
98659>>>                        If (sRetval <> "") Begin
98661>>>                            Set Value to sRetval
98662>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
98665>>>                        End
98665>>>>
98665>>>                    End_Procedure
98666>>>
98666>>>                    Procedure OnCreate
98669>>>                        String sFilelist
98669>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
98672>>>                        Set Value to sFilelist
98673>>>                    End_Procedure
98674>>>                    Send OnCreate
98675>>>
98675>>>                End_Object
98676>>>
98676>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
98678>>>                    Set Size to 13 73
98679>>>                    Set Location to 22 319
98680>>>                    Set Label to "Select Filelist.cfg"
98681>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
98682>>>                    Set peAnchors to anTopRight
98683>>>
98683>>>                    Procedure OnClick
98686>>>                        Send Prompt to oFilelistPath_fm
98687>>>                    End_Procedure
98688>>>
98688>>>                End_Object
98689>>>
98689>>>                Object oInfo_tb is a TextBox
98691>>>                    Set Size to 9 207
98692>>>                    Set Location to 40 138
98693>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
98694>>>                    Set peAnchors to anTopRight
98695>>>                End_Object
98696>>>
98696>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
98698>>>                    Set Size to 13 68
98699>>>                    Set Location to 38 319
98700>>>                    Set Label to "GO !"
98701>>>                    Set FontWeight to fw_Bold
98702>>>                    Set peAnchors to anTopRight
98703>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
98704>>>
98704>>>                    Procedure OnClick
98707>>>                        String sFileList
98707>>>                        Integer iRetval iCount
98707>>>                        Boolean bExits
98707>>>
98707>>>                        Get Value of oFilelistPath_fm to sFileList
98708>>>                        Get vFilePathExists sFileList to bExits
98709>>>                        If (bExits = False) Begin
98711>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
98712>>>                            Procedure_Return
98713>>>                        End
98713>>>>
98713>>>
98713>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
98714>>>                        If (iRetval <> MBR_Yes) Begin
98716>>>                            Procedure_Return
98717>>>                        End
98717>>>>
98717>>>                        Send Cursor_Wait of Cursor_Control
98718>>>
98718>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
98719>>>
98719>>>                        Send Cursor_Ready of Cursor_Control
98720>>>                        If (iCount <> 0) Begin
98722>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
98723>>>                        End
98723>>>>
98723>>>                        Else Begin
98724>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
98725>>>                        End
98725>>>>
98725>>>
98725>>>                    End_Procedure
98726>>>
98726>>>                End_Object
98727>>>
98727>>>            End_Object
98728>>>
98728>>>            Object oOutput_grp is a Group
98730>>>                Set Size to 47 402
98731>>>                Set Location to 234 12
98732>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
98733>>>                Set peAnchors to anTopLeftRight
98734>>>
98734>>>                Object oOutput_rg is a RadioGroup
98736>>>                    Set Location to 18 13
98737>>>                    Set Size to 25 288
98738>>>                    Set Label to "Filelist Output Order"
98739>>>
98739>>>                    Object oRadio1 is a Radio
98741>>>                        Set Label to "Filelist Number"
98742>>>                        Set Size to 10 61
98743>>>                        Set Location to 10 7
98744>>>                    End_Object
98745>>>
98745>>>                    Object oRadio2 is a Radio
98747>>>                        Set Label to "Logical Name"
98748>>>                        Set Size to 10 61
98749>>>                        Set Location to 10 77
98750>>>                    End_Object
98751>>>
98751>>>                    Object oRadio3 is a Radio
98753>>>                        Set Label to "Root Name"
98754>>>                        Set Size to 10 61
98755>>>                        Set Location to 10 147
98756>>>                    End_Object
98757>>>
98757>>>                    Object oRadio4 is a Radio
98759>>>                        Set Label to "Display Name"
98760>>>                        Set Size to 10 62
98761>>>                        Set Location to 10 213
98762>>>                    End_Object
98763>>>
98763>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
98766>>>                        Forward Send Notify_Select_State iToItem iFromItem
98768>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
98769>>>                    End_Procedure
98770>>>
98770>>>                End_Object
98771>>>                
98771>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
98773>>>                    Set Size to 13 78
98774>>>                    Set Location to 26 315
98775>>>                    Set Label to "Print to Filelist.txt"
98776>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
98777>>>                    Set psImage to "ActionDocument1.ico"
98778>>>
98778>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
98780>>>
98780>>>                    // Custom array sort function.
98780>>>                    // iSortOrder = 0 -> Filelist number order
98780>>>                    // iSortOrder = 1 -> Logical name order
98780>>>                    // iSortOrder = 2 -> Root name order
98780>>>                    // iSortOrder = 3 -> Display name order
98780>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
98783>>>                        Integer iSortOrder
98783>>>
98783>>>                        Get piSortOrder to iSortOrder
98784>>>
98784>>>                        Case Begin
98784>>>                            Case (iSortOrder = 0)
98786>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
98788>>>                                    Function_Return (GT)
98789>>>                                End
98789>>>>
98789>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
98791>>>                                    Function_Return (LT)
98792>>>                                End
98792>>>>
98792>>>                                Function_Return (EQ)
98793>>>                            Case (iSortOrder = 1)
98796>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
98798>>>                                    Function_Return (GT)
98799>>>                                End
98799>>>>
98799>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
98801>>>                                    Function_Return (LT)
98802>>>                                End
98802>>>>
98802>>>                                Function_Return (EQ)
98803>>>                            Case (iSortOrder = 2)
98806>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
98808>>>                                    Function_Return (GT)
98809>>>                                End
98809>>>>
98809>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
98811>>>                                    Function_Return (LT)
98812>>>                                End
98812>>>>
98812>>>                                Function_Return (EQ)
98813>>>                            Case (iSortOrder = 3)
98816>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
98818>>>                                    Function_Return (GT)
98819>>>                                End
98819>>>>
98819>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
98821>>>                                    Function_Return (LT)
98822>>>                                End
98822>>>>
98822>>>                                Function_Return (EQ)
98823>>>                        Case End
98823>>>
98823>>>                    End_Function
98824>>>
98824>>>                    Procedure OnClick
98827>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
98827>>>                        Integer iCh iCount iSize
98827>>>                        Handle hTable
98827>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98827>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98829>>>
98829>>>                        Get Value of oFilelistPath_fm to sFileList
98830>>>                        Move (Trim(sFileList)) to sFileList
98831>>>                        If (sFileList = "") Begin
98833>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
98834>>>                            Procedure_Return
98835>>>                        End
98835>>>>
98835>>>
98835>>>                        Get ParseFolderName sFileList to sPath
98836>>>                        Get vFolderFormat sPath to sPath
98837>>>                        Get ParseFileName sFileList to sOutputName
98838>>>                        Get ParseFileExtension sFileList to sExt
98839>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
98840>>>                        Move (sOutputName + "txt")           to sOutputName
98841>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
98842>>>                        If (iCh < 0) Begin
98844>>>                            Procedure_Return
98845>>>                        End
98845>>>>
98845>>>
98845>>>                        Move 0 to hTable
98846>>>                        Writeln channel iCh sFileList
98849>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
98852>>>                        Writeln channel iCh "==================================================================================================="
98855>>>                        Writeln channel iCh
98857>>>
98857>>>                        Move 0 to iCount
98858>>>                        Repeat
98858>>>>
98858>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98861>>>                            If (hTable > 0) Begin
98863>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
98864>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
98867>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
98870>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
98873>>>                                Increment iCount
98874>>>                            End
98874>>>>
98874>>>                        Until (hTable = 0)
98876>>>
98876>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
98877>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
98878>>>                        Decrement iSize
98879>>>
98879>>>                        For iCount from 0 to iSize
98885>>>>
98885>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
98886>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
98887>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
98888>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
98889>>>
98889>>>                            Get PadLeft (String(hTable))        09 to sTable
98890>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
98891>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
98892>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
98893>>>
98893>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
98899>>>                        Loop
98900>>>>
98900>>>
98900>>>                        Writeln channel iCh "==================================================================================================="
98903>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
98907>>>                        Close_Output
98908>>>
98908>>>                        Send vShellExecute "open" sOutputName "" sPath
98909>>>                    End_Procedure
98910>>>
98910>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
98913>>>                        String sChar
98913>>>
98913>>>                        If (Num_Arguments >= 3) Begin
98915>>>                            Move sOptChar to sChar
98916>>>                        End
98916>>>>
98916>>>                        Else Begin
98917>>>                            Move " " to sChar
98918>>>                        End
98918>>>>
98918>>>
98918>>>                        While (Length(sString) < iLength)
98922>>>                            Move (sChar + sString) to sString
98923>>>                        Loop
98924>>>>
98924>>>
98924>>>                        Function_Return sString
98925>>>                    End_Function
98926>>>
98926>>>                End_Object
98927>>>            End_Object
98928>>>
98928>>>        End_Object
98929>>>
98929>>>    End_Object
98930>>>
98930>>>    Procedure OnFileDropped String sFilename Boolean bLast
98933>>>        String sTest
98933>>>        Forward Send OnFileDropped sFilename bLast
98935>>>        If (bLast = True) Begin
98937>>>            Get ParseFileName sFilename to sTest
98938>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
98940>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
98941>>>                Procedure_Return
98942>>>            End
98942>>>>
98942>>>            Set Value of oFilelistPath_fm to sFilename
98943>>>        End
98943>>>>
98943>>>    End_Procedure
98944>>>
98944>>>End_Object
98945>
98945>        Procedure Activate_About
98948>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
98949>        End_Procedure
98950>
98950>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
98951>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
98952>        On_Key Key_Ctrl+Key_W             Send Close_Panel
98953>    End_Object
98954>
98954>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
98954>    // in the oHtmlHelp object, so we need to explitetly send the message
98954>    // to that object.
98954>    Procedure ShowProgramHelp
98957>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
98958>    End_Procedure
98959>
98959>    On_Key Key_F1 Send ShowProgramHelp
98960>End_Object
98961>
98961>// We do this to activate the first view:
98961>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
98961>Start_UI
98962>
Including Resources...
Summary
Memory Available: 47395471360
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52671
Total Resources: 10
Total Commands : 98961
Total Windows  : 0
Total Pages    : 0
Static Data    : 844663
Message area   : 637446
Total Blocks   : 80625
