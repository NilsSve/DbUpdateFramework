Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 23.0\Pkg\dfallent.pkd)
73414>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardCommandBarSystem.pkg)
73414>>>// these are all the packages used in a standard MDI menubar/toolbar system
73414>>>
73414>>>Use cCJCommandBarSystem.pkg
73414>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardMenuItemClasses.pkg)
73414>>>>>Use Dfpanel.pkg
73414>>>>>Use cCJCommandBarSystem.pkg
73414>>>>>Use LanguageText.pkg
73414>>>>>
73414>>>>>
73414>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73415>>>>>    
73415>>>>>    Procedure Construct_Object
73417>>>>>        Forward Send Construct_Object
73419>>>>>        Set psCaption   to C_$CaptionUndo
73420>>>>>        Set psToolTip to C_$ToolTipUndo
73421>>>>>        Set psDescription to C_$DescUndo
73422>>>>>        Set psImage to "ActionUndo.ico"
73423>>>>>        Set pbActiveUpdate to True
73424>>>>>        Set psCategory to C_$CategoryEdit
73425>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73426>>>>>    End_Procedure
73427>>>>>    
73427>>>>>    Procedure OnExecute Variant vCommandBarControl
73429>>>>>        Send Undo of (focus(Self))
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Function IsEnabled Returns Boolean
73433>>>>>        Boolean bEnabled
73433>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73434>>>>>        Function_Return bEnabled
73435>>>>>    End_Function
73436>>>>>    
73436>>>>>End_Class
73437>>>>>
73437>>>>>
73437>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73438>>>>>    
73438>>>>>    Procedure Construct_Object
73440>>>>>        Forward Send Construct_Object
73442>>>>>        Set psCaption   to C_$CaptionDelete
73443>>>>>        Set psToolTip to C_$ToolTipDelete
73444>>>>>        Set psDescription to C_$DescDelete
73445>>>>>        Set psImage to "actionDelete.ico"
73446>>>>>        Set psShortcut to C_$Key_Delete
73447>>>>>        Set pbActiveUpdate to True
73448>>>>>        Set psCategory to C_$CategoryEdit
73449>>>>>    End_Procedure
73450>>>>>    
73450>>>>>    
73450>>>>>    Procedure OnExecute Variant vCommandBarControl
73452>>>>>        Send Delete of (focus(Self))
73453>>>>>    End_Procedure
73454>>>>>    
73454>>>>>    Function IsEnabled Returns Boolean
73456>>>>>        Boolean bEnabled
73456>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73457>>>>>        Function_Return bEnabled
73458>>>>>    End_Function
73459>>>>>    
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>>>Class cCJCutMenuItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Set psCaption   to C_$CaptionCut
73466>>>>>        Set psToolTip to C_$TooltipCut
73467>>>>>        Set psDescription to C_$DescCut
73468>>>>>        Set psImage to "actionCut.ico"
73469>>>>>        Set psShortcut to C_$Key_Ctrl_X
73470>>>>>        Set pbActiveUpdate to True
73471>>>>>        Set psCategory to C_$CategoryEdit
73472>>>>>    End_Procedure
73473>>>>>    
73473>>>>>    
73473>>>>>    Procedure OnExecute Variant vCommandBarControl
73475>>>>>        Send Cut of (focus(Self))
73476>>>>>    End_Procedure
73477>>>>>    
73477>>>>>    Function IsEnabled Returns Boolean
73479>>>>>        Boolean bEnabled
73479>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73480>>>>>        Function_Return bEnabled
73481>>>>>    End_Function
73482>>>>>    
73482>>>>>End_Class
73483>>>>>
73483>>>>>
73483>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73484>>>>>    
73484>>>>>    Procedure Construct_Object
73486>>>>>        Forward Send Construct_Object
73488>>>>>        Set psCaption   to C_$CaptionCopy
73489>>>>>        Set psToolTip to C_$ToolTipCopy
73490>>>>>        Set psDescription to C_$DescCopy
73491>>>>>        Set psImage to "actionCopy.ico"
73492>>>>>        Set psShortcut to C_$Key_Ctrl_C
73493>>>>>        Set pbActiveUpdate to True
73494>>>>>        Set psCategory to C_$CategoryEdit
73495>>>>>    End_Procedure
73496>>>>>    
73496>>>>>    
73496>>>>>    Procedure OnExecute Variant vCommandBarControl
73498>>>>>        Send Copy of (focus(Self))
73499>>>>>    End_Procedure
73500>>>>>    
73500>>>>>    Function IsEnabled Returns Boolean
73502>>>>>        Boolean bEnabled
73502>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73503>>>>>        Function_Return bEnabled
73504>>>>>    End_Function
73505>>>>>    
73505>>>>>End_Class
73506>>>>>
73506>>>>>
73506>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73507>>>>>    
73507>>>>>    Procedure Construct_Object
73509>>>>>        Forward Send Construct_Object
73511>>>>>        Set psCaption   to C_$CaptionPaste
73512>>>>>        Set psToolTip to C_$ToolTipPaste
73513>>>>>        Set psDescription to C_$DescPaste
73514>>>>>        Set psImage to "actionPaste.ico"
73515>>>>>        Set pbActiveUpdate to True
73516>>>>>        Set psShortcut to C_$Key_Ctrl_V
73517>>>>>        Set psCategory to C_$CategoryEdit
73518>>>>>    End_Procedure
73519>>>>>    
73519>>>>>    
73519>>>>>    Procedure OnExecute Variant vCommandBarControl
73521>>>>>        Send Paste of (focus(Self))
73522>>>>>    End_Procedure
73523>>>>>    
73523>>>>>    Function IsEnabled Returns Boolean
73525>>>>>        Boolean bEnabled
73525>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73526>>>>>        Function_Return bEnabled
73527>>>>>    End_Function
73528>>>>>    
73528>>>>>End_Class
73529>>>>>
73529>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73530>>>>>    
73530>>>>>    Procedure Construct_Object
73532>>>>>        Forward Send Construct_Object
73534>>>>>        Set psCaption   to C_$CaptionSelectAll
73535>>>>>        Set psToolTip to C_$ToolTipSelectAll
73536>>>>>        Set psDescription to C_$DescSelectAll
73537>>>>>        Set pbActiveUpdate to True
73538>>>>>        Set psShortcut to C_$Key_Ctrl_A
73539>>>>>        Set psCategory to C_$CategoryEdit
73540>>>>>    End_Procedure
73541>>>>>    
73541>>>>>    
73541>>>>>    Procedure OnExecute Variant vCommandBarControl
73543>>>>>        Send Select_All of (focus(Self))
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    Function IsEnabled Returns Boolean
73547>>>>>        Boolean bEnabled
73547>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73548>>>>>        Function_Return bEnabled
73549>>>>>    End_Function
73550>>>>>    
73550>>>>>End_Class
73551>>>>>
73551>>>>>
73551>>>>>Class cCJExitMenuItem is a cCJMenuItem
73552>>>>>    
73552>>>>>    Procedure Construct_Object
73554>>>>>        Forward Send Construct_Object
73556>>>>>        Set psCaption to C_$CaptionExit
73557>>>>>        Set psToolTip to C_$ToolTipExit
73558>>>>>        Set psDescription to C_$ToolTipExit
73559>>>>>        Set psShortcut to C_$Key_Alt_F4
73560>>>>>        Set psCategory to C_$CategoryFile
73561>>>>>    End_Procedure
73562>>>>>    
73562>>>>>    Procedure OnExecute Variant vCommandBarControl
73564>>>>>        Send Exit_Application of Desktop
73565>>>>>    End_Procedure
73566>>>>>    
73566>>>>>End_Class
73567>>>>>
73567>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73568>>>>>    
73568>>>>>    Procedure Construct_Object
73570>>>>>        Forward Send Construct_Object
73572>>>>>        Set psCaption to C_$CaptionHelp
73573>>>>>        Set psDescription to C_$ToolTipHelp
73574>>>>>        Set psToolTip to C_$DescHelp
73575>>>>>        Set psImage to "ActionHelp.ico"
73576>>>>>        Set psShortcut to "F1"
73577>>>>>        Set psCategory to C_$CategoryHelp
73578>>>>>    End_Procedure
73579>>>>>    
73579>>>>>    Procedure OnExecute Variant vCommandBarControl
73581>>>>>        Send Help of (Focus(Self))
73582>>>>>    End_Procedure
73583>>>>>    
73583>>>>>End_Class
73584>>>>>
73584>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73585>>>>>    
73585>>>>>    Procedure Construct_Object
73587>>>>>        Forward Send Construct_Object
73589>>>>>        Set psCaption to C_$CaptionAddStatusbar
73590>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73591>>>>>        Set psDescription to  C_$DescAddStatusbar
73592>>>>>        Set psCategory to C_$CategoryWindow
73593>>>>>    End_Procedure
73594>>>>>    
73594>>>>>    Procedure OnExecute Variant vCommandBarControl
73596>>>>>        Handle hoCommandBars hoClientArea
73596>>>>>        Get CommandBarSystemObject to hoCommandBars
73597>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73598>>>>>        If hoClientArea Begin
73600>>>>>            // the clientarea's parent panel has message
73600>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73601>>>>>        End
73601>>>>>>
73601>>>>>    End_Procedure
73602>>>>>    
73602>>>>>    Function IsChecked Returns Boolean
73604>>>>>        Boolean bOn
73604>>>>>        Handle hoCommandBars hoClientArea
73604>>>>>        Get CommandBarSystemObject to hoCommandBars
73605>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73606>>>>>        If hoClientArea Begin
73608>>>>>            // the clientarea's parent panel has message
73608>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73609>>>>>        End
73609>>>>>>
73609>>>>>        Function_Return bOn
73610>>>>>    End_Function
73611>>>>>End_Class
73612>>>>>
73612>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73613>>>>>    
73613>>>>>    Procedure Construct_Object
73615>>>>>        Forward Send Construct_Object
73617>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73618>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73619>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73620>>>>>        Set psCategory to C_$CategoryWindow
73621>>>>>    End_Procedure
73622>>>>>    
73622>>>>>    Procedure OnExecute Variant vCommandBarControl
73624>>>>>        Handle hoCommandBars hoClientArea
73624>>>>>        Get CommandBarSystemObject to hoCommandBars
73625>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73626>>>>>        If hoClientArea Begin
73628>>>>>            // the clientarea's parent panel has message
73628>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73629>>>>>        End
73629>>>>>>
73629>>>>>    End_Procedure
73630>>>>>    
73630>>>>>    Function IsChecked Returns Boolean
73632>>>>>        Boolean bOn
73632>>>>>        Handle hoCommandBars hoClientArea
73632>>>>>        Get CommandBarSystemObject to hoCommandBars
73633>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73634>>>>>        If hoClientArea Begin
73636>>>>>            // the clientarea's parent panel has message
73636>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73637>>>>>        End
73637>>>>>>
73637>>>>>        Function_Return bOn
73638>>>>>    End_Function
73639>>>>>End_Class
73640>>>>>
73640>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73641>>>>>    
73641>>>>>    Procedure Construct_Object
73643>>>>>        Forward Send Construct_Object
73645>>>>>        Set psCaption to C_$CaptionRestoreMenus
73646>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73647>>>>>        Set psDescription to C_$DescRestoreMenus
73648>>>>>        Set psCategory to C_$CategoryWindow
73649>>>>>    End_Procedure
73650>>>>>    
73650>>>>>    Procedure OnExecute Variant vCommandBarControl
73652>>>>>        Handle hoCommandBars
73652>>>>>        Get CommandBarSystemObject to hoCommandBars
73653>>>>>        Send RestoreLayout of hoCommandBars
73654>>>>>    End_Procedure
73655>>>>>    
73655>>>>>End_Class
73656>>>>>
73656>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73657>>>>>    
73657>>>>>    Procedure Construct_Object
73659>>>>>        Forward Send Construct_Object
73661>>>>>        Set psCaption to C_$CaptionCascade
73662>>>>>        Set psToolTip to C_$ToolTipCascade
73663>>>>>        Set psDescription to  C_$DescCascade
73664>>>>>        Set psImage to "ActionCascade.ico"
73665>>>>>        Set psCategory to C_$CategoryWindow
73666>>>>>    End_Procedure
73667>>>>>    
73667>>>>>    Procedure OnExecute Variant vCommandBarControl
73669>>>>>        Handle hoCommandBars hoClientArea
73669>>>>>        Get CommandBarSystemObject to hoCommandBars
73670>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73671>>>>>        If hoClientArea Begin
73673>>>>>            Send Cascade_Windows of hoClientArea
73674>>>>>        End
73674>>>>>>
73674>>>>>    End_Procedure
73675>>>>>End_Class
73676>>>>>
73676>>>>>Class cCJTileHorizontally is a cCJMenuItem
73677>>>>>    
73677>>>>>    Procedure Construct_Object
73679>>>>>        Forward Send Construct_Object
73681>>>>>        Set psCaption to C_$CaptionTileHorizontally
73682>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73683>>>>>        Set psDescription to  C_$DescTileHorizontally
73684>>>>>        Set psImage to "ActionTileHorizontally.ico"
73685>>>>>        Set psCategory to C_$CategoryWindow
73686>>>>>    End_Procedure
73687>>>>>    
73687>>>>>    Procedure OnExecute Variant vCommandBarControl
73689>>>>>        Handle hoCommandBars hoClientArea
73689>>>>>        Get CommandBarSystemObject to hoCommandBars
73690>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73691>>>>>        If hoClientArea Begin
73693>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73694>>>>>        End
73694>>>>>>
73694>>>>>    End_Procedure
73695>>>>>End_Class
73696>>>>>
73696>>>>>Class cCJTileVertically is a cCJMenuItem
73697>>>>>    
73697>>>>>    Procedure Construct_Object
73699>>>>>        Forward Send Construct_Object
73701>>>>>        Set psCaption to C_$CaptionTileVertically
73702>>>>>        Set psToolTip to C_$ToolTipTileVertically
73703>>>>>        Set psDescription to  C_$DescTileVertically
73704>>>>>        Set psImage to "ActionTileVertically.ico"
73705>>>>>        Set psCategory to C_$CategoryWindow
73706>>>>>    End_Procedure
73707>>>>>    
73707>>>>>    Procedure OnExecute Variant vCommandBarControl
73709>>>>>        Handle hoCommandBars hoClientArea
73709>>>>>        Get CommandBarSystemObject to hoCommandBars
73710>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73711>>>>>        If hoClientArea Begin
73713>>>>>            Send Tile_Windows_Vertical of hoClientArea
73714>>>>>        End
73714>>>>>>
73714>>>>>    End_Procedure
73715>>>>>End_Class
73716>>>>>
73716>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73717>>>>>    
73717>>>>>    Procedure Construct_Object
73719>>>>>        Forward Send Construct_Object
73721>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73722>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73723>>>>>        Set psDescription to  C_$DescMinimizeWindows
73724>>>>>        Set psCategory to C_$CategoryWindow
73725>>>>>    End_Procedure
73726>>>>>    
73726>>>>>    Procedure OnExecute Variant vCommandBarControl
73728>>>>>        Handle hoCommandBars hoClientArea
73728>>>>>        Get CommandBarSystemObject to hoCommandBars
73729>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73730>>>>>        If hoClientArea Begin
73732>>>>>            // the clientarea's parent panel has message
73732>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73733>>>>>        End
73733>>>>>>
73733>>>>>    End_Procedure
73734>>>>>End_Class
73735>>>>>
73735>>>>>
73735>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73736>>>>>    
73736>>>>>    Procedure Construct_Object
73738>>>>>        Forward Send Construct_Object
73740>>>>>        Set psCaption to C_$CaptionRestoreWindows
73741>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73742>>>>>        Set psDescription to  C_$DescRestoreWindows
73743>>>>>        Set psCategory to C_$CategoryWindow
73744>>>>>    End_Procedure
73745>>>>>    
73745>>>>>    Procedure OnExecute Variant vCommandBarControl
73747>>>>>        Handle hoCommandBars hoClientArea
73747>>>>>        Get CommandBarSystemObject to hoCommandBars
73748>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73749>>>>>        If hoClientArea Begin
73751>>>>>            // the clientarea's parent panel has message
73751>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73752>>>>>        End
73752>>>>>>
73752>>>>>    End_Procedure
73753>>>>>End_Class
73754>>>>>
73754>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73755>>>>>    
73755>>>>>    Procedure Construct_Object
73757>>>>>        Forward Send Construct_Object
73759>>>>>        Set psCaption to C_$CaptionArrangeIcons
73760>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73761>>>>>        Set psDescription to  C_$DescArrangeIcons
73762>>>>>        Set psCategory to C_$CategoryWindow
73763>>>>>    End_Procedure
73764>>>>>    
73764>>>>>    Procedure OnExecute Variant vCommandBarControl
73766>>>>>        Handle hoCommandBars hoClientArea
73766>>>>>        Get CommandBarSystemObject to hoCommandBars
73767>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73768>>>>>        If hoClientArea Begin
73770>>>>>            Send Arrange_Icons of hoClientArea
73771>>>>>        End
73771>>>>>>
73771>>>>>    End_Procedure
73772>>>>>    
73772>>>>>End_Class
73773>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJAboutMenuItem.pkg)
73773>>>>>Use cCJCommandBarSystem.pkg
73773>>>>>Use LanguageText.pkg
73773>>>>>
73773>>>>>// It is expected that if you use this class that you provide an about object that is
73773>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73773>>>>>// because you may wish to create your own custom about package.
73773>>>>>
73773>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73774>>>>>
73774>>>>>    Procedure Construct_Object
73776>>>>>        Forward Send Construct_Object
73778>>>>>        Set psCaption to C_$CaptionAbout
73779>>>>>        Set psDescription to C_$ToolTipAbout
73780>>>>>        Set psToolTip to C_$DescAbout
73781>>>>>        Set psImage to "ActionAbout.ico"
73782>>>>>        Set psCategory to C_$CategoryHelp
73783>>>>>    End_Procedure
73784>>>>>    
73784>>>>>    Procedure OnExecute Variant vCommandBarControl
73786>>>>>        Handle hoCommandBars hoClientArea
73786>>>>>        Get CommandBarSystemObject to hoCommandBars
73787>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73788>>>>>        If hoClientArea Begin
73790>>>>>            Send Activate_About of hoClientArea
73791>>>>>        End
73791>>>>>>
73791>>>>>    End_Procedure
73792>>>>>
73792>>>>>End_Class
73793>>>>>
73793>>>>>
73793>>>Use cCJDeoMenuItemClasses.pkg
73793>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73793>>>>>Use cCJCommandBarSystem.pkg
73793>>>>>
73793>>>>>Register_Function Client_ID Returns Integer
73793>>>>>
73793>>>>>// only used by cCJMDIWIndowsMenuItem
73793>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73794>>>>>    
73794>>>>>    Procedure Construct_Object
73796>>>>>        Forward Send Construct_Object
73798>>>>>        Property Handle phWindow 0 // object id of view
73799>>>>>        Set pbControlFlagNoMovable to True
73800>>>>>        Set pbActiveUpdate to True
73801>>>>>    End_Procedure
73802>>>>>    
73802>>>>>    Procedure OnExecute Variant vCommandBarControl
73804>>>>>        Handle hWindow
73804>>>>>        Get phWindow to hWindow
73805>>>>>        Send Activate_View of hWindow
73806>>>>>    End_Procedure
73807>>>>>    
73807>>>>>End_Class
73808>>>>>
73808>>>>>
73808>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73809>>>>>    
73809>>>>>    Procedure Construct_Object
73811>>>>>        Forward Send Construct_Object
73813>>>>>        Property Handle[] phArrayOfWindows
73814>>>>>        Set peControlType to xtpControlPopup
73815>>>>>        Set psCategory to C_$CategoryWindow
73816>>>>>    End_Procedure
73817>>>>>    
73817>>>>>    // This adds MDI windows to the existing menu items.
73817>>>>>    // This removes any existing windows menus and always adds a new set to the end
73817>>>>>    
73817>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73819>>>>>        Handle  hClientArea hView
73819>>>>>        String  sLabel
73819>>>>>        Integer i iWindows
73819>>>>>        Handle[] hArrayOfWindows
73820>>>>>        Variant vItem
73820>>>>>        
73820>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73820>>>>>        // also assume that destroying an action removes all menu instances of that action
73820>>>>>        Get phArrayOfWindows to hArrayOfWindows
73821>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73822>>>>>        For i from 0 to (iWindows-1)
73828>>>>>>
73828>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73829>>>>>        Loop
73830>>>>>>
73830>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73831>>>>>        
73831>>>>>        // Add all views to this menu. Create the action and add the item
73831>>>>>        Move 0 to i
73832>>>>>        Get Client_Id to hClientArea // object id of client area
73833>>>>>        If (hClientArea > 0) Begin
73835>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73836>>>>>            While (hView <> 0)
73840>>>>>                If (Active_State(hView)) Begin
73842>>>>>                    // create the action
73842>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73843>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73844>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73845>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73846>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73848>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73849>>>>>                    End
73849>>>>>>
73849>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73850>>>>>                    If (i=0) Begin
73852>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73853>>>>>                    End
73853>>>>>>
73853>>>>>                    // Create a menu item for this action
73853>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73854>>>>>                    Increment i
73855>>>>>                End
73855>>>>>>
73855>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73856>>>>>            Loop
73857>>>>>>
73857>>>>>        End
73857>>>>>>
73857>>>>>        
73857>>>>>        Set phArrayOfWindows to hArrayOfWindows
73858>>>>>        
73858>>>>>    End_Procedure
73859>>>>>    
73859>>>>>End_Class
73860>Use cCJCommandBarSystem.pkg
73860>Use Dferror.pkg
73860>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Colr_dlg.pkg)
73860>>>Use VDFBase.pkg
73860>>>Use DLL.pkg
73860>>>Use RGB.pkg
73860>>>Use GlobalFunctionsProcedures.pkg
73860>>>
73860>>>Define CC_RGBINIT         for 1
73860>>>Define CC_FULLOPEN        for 2
73860>>>Define CC_PREVENTFULLOPEN for 4
73860>>>
73860>>>// When called directly, lpTemplateName of lpCC must refer to a WString type.
73860>>>External_Function ChooseColorW 'ChooseColorW' COMDLG32.dll Pointer lpCC Returns Integer
73861>>>
73861>>>// Wrapper Function ChooseColor
73861>>>Function ChooseColor Global ;    Pointer lpCC ;    Returns Integer
73863>>>    
73863>>>    // lpCC is a pointer to a ChooseColor struct, which contains a pointer to a string.
73863>>>    // The string must be converted to UTF-16 and afterwards back to UTF-8.
73863>>>    Integer iResult iVoid
73863>>>    Pointer pCC pOrigTemplateName
73863>>>    tWinChooseColor tCC
73863>>>    tWinChooseColor tCC
73863>>>    UWide uwTemplateName
73863>>>    UWide uwTemplateName
73863>>>
73863>>>    // Copy the struct to a local struct that can be modified to UTF-16.
73863>>>    Move (AddressOf(tCC)) to pCC
73864>>>    Move (CopyMemory(pCC, lpCC, SizeOfType(tWinChooseColor))) to iVoid
73865>>>
73865>>>    // Change lpTemplateName to UTF-16. This address is pointing to the original string.
73865>>>    Move tCC.lpTemplateName to pOrigTemplateName
73866>>>    Move (StringToWide(pOrigTemplateName, (&uwTemplateName))) to tCC.lpTemplateName
73867>>>
73867>>>    // Call the function using the local struct
73867>>>    Move (ChooseColorW(pCC)) to iResult
73868>>>    
73868>>>    // The struct is now filled with data. Revert strings back to UTF-8 and then copy the struct back to the original memory location.
73868>>>    
73868>>>    // Copy the string to the original location
73868>>>    Move pOrigTemplateName to tCC.lpTemplateName
73869>>>    Send WideToString (&uwTemplateName) tCC.lpTemplateName 
73870>>>    
73870>>>    // Copy the struct back to the incoming one
73870>>>    Move (CopyMemory(lpCC, pCC, SizeOfType(tWinChooseColor))) to iVoid
73871>>>    
73871>>>    Function_Return iResult
73872>>>End_Function
73873>>>
73873>>>
73873>>>Class ColorDialog is a cObject
73874>>>    Procedure Construct_Object
73876>>>        Integer iLoop
73876>>>        Handle hoCustomColors
73876>>>        
73876>>>        Forward Send Construct_Object
73878>>>        
73878>>>        Property Boolean FullOpen_State        True
73879>>>        Property Boolean PreventFullOpen_State False
73880>>>        Property Boolean SelectedColor_State   True
73881>>>        Property Integer SelectedColor         0
73882>>>        
73882>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
73883>>>        
73883>>>        // Set all custom colors to white...
73883>>>        Get phoCustomColors to hoCustomColors
73884>>>        For iLoop from 0 to 15
73890>>>>
73890>>>            Set Value of hoCustomColors iLoop to clWhite
73891>>>        Loop
73892>>>>
73892>>>        
73892>>>    End_Procedure
73893>>>    
73893>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
73895>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
73896>>>    End_Procedure
73897>>>    
73897>>>    Function Custom_Color Integer iItem Returns Integer
73899>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
73900>>>    End_Function
73901>>>    
73901>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
73903>>>        // Copies the custom colors from another ColorDialog instance
73903>>>        Integer iColor
73903>>>        
73903>>>        For iColor from 0 to 15
73909>>>>
73909>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
73910>>>        Loop
73911>>>>
73911>>>    End_Procedure
73912>>>    
73912>>>    Function Value Integer iItem Returns String
73914>>>        // Provides support for the AssignCustomColors procedure, which requires
73914>>>        // that a "Get Value" interface is supported
73914>>>        Function_Return (Custom_Color(Self, iItem))
73915>>>    End_Function
73916>>>    
73916>>>    Function OwnerHandle Returns Handle
73918>>>        Handle hWnd
73918>>>        Handle hoObj
73918>>>        Get Focus of desktop to hoObj // start with the focus
73919>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
73920>>>        Function_Return hWnd
73921>>>    End_Function
73922>>>    
73922>>>    Function Show_Dialog Returns Boolean
73924>>>        //Shows the dialog. Returns True if the OK button was clicked.
73924>>>        Handle  hContainer hoCustomColors
73924>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
73924>>>        Integer rgbColor iFlags iLoop
73924>>>        String sCC sColors
73924>>>        tWinChooseColor ChseColor
73924>>>        tWinChooseColor ChseColor
73924>>>        
73924>>>        Get OwnerHandle to hContainer
73925>>>        
73925>>>        Get phoCustomColors to hoCustomColors
73926>>>        
73926>>>        Move '' to sColors
73927>>>        For iLoop from 0 to 15
73933>>>>
73933>>>            Get Value of hoCustomColors iLoop to rgbColor
73934>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
73935>>>        Loop
73936>>>>
73936>>>        
73936>>>        Get FullOpen_State        to bFullOpen
73937>>>        Get PreventFullOpen_State to bNoOpen
73938>>>        Get SelectedColor_State   to bSelColor
73939>>>        Get SelectedColor         to rgbColor
73940>>>        
73940>>>        Move 0 to iFlags
73941>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
73944>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
73947>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
73950>>>        
73950>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
73951>>>        Move hContainer           to ChseColor.hWndOWner
73952>>>        Move rgbColor             to ChseColor.rgbResult
73953>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
73954>>>        Move iFlags               to ChseColor.flags
73955>>>        
73955>>>        Move (ChooseColorW(AddressOf(ChseColor))) to bSelected
73956>>>        
73956>>>        If bSelected Begin
73958>>>            For iLoop from 0 to 15
73964>>>>
73964>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
73965>>>                Set Value of hoCustomColors iLoop to rgbColor
73966>>>            Loop
73967>>>>
73967>>>            Move ChseColor.rgbResult to rgbColor
73968>>>            Set SelectedColor to rgbColor
73969>>>        End
73969>>>>
73969>>>        Function_Return bSelected
73970>>>    End_Function
73971>>>    
73971>>>End_Class
73972>Use Cursor.pkg
73972>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73972>>>//****************************************************************************
73972>>>// $Module type: Class
73972>>>// $Module name: cDbUpdateHandler
73972>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73972>>>// Web-site    : http://www.rdctools.com
73972>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73972>>>//
73972>>>// Purpose     : A framework for doing automated code based updates of a database from within
73972>>>//               a program, when it is started.
73972>>>//
73972>>>// Description : Place _one_ object of this class right after the cApplication object.
73972>>>//               Then inside this object place a series of cDbUpdateVersion objects
73972>>>//               as childs. One child object for each new database update.
73972>>>//
73972>>>//               - OnPreUpdate is a pre-processing event called
73972>>>//               before any database changes are started.
73972>>>//               - OnPostUpdate is a post-processing event called after all
73972>>>//               database changes have taken place.
73972>>>//
73972>>>// Note        : If tables have been opened prior to an object of this class
73972>>>//               (e.g. in the cApplication object), those tables will be closed.
73972>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73972>>>//               tables after the last update has finished.
73972>>>//
73972>>>// Security    : Before an update is attempted; three things are checked to ensure the
73972>>>//               database is not in use. Aka nobody else is running the application.
73972>>>//               - All tables are tested for "Open in Exclusive_Mode"
73972>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73972>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73972>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73972>>>//                 folder and a bit-lock is performed for each start of the application and this
73972>>>//                 user counter is checked before an update is attempted.
73972>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73972>>>//                            against the database being "in use", there is no such guarantee! The
73972>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73972>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73972>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73972>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73972>>>//                 automatically be released after the update is completed.
73972>>>//
73972>>>//
73972>>>// Usage       :  Use cDbUpdateHandler.pkg
73972>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73972>>>//                    // Declare the table that contains a "database version" field.
73972>>>//                    Declare_Datafile Sys
73972>>>//                    // Either one of these syntaxes is fine:
73972>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73972>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73972>>>//
73972>>>//                    // Don't forget to increase the pnVersionNumber property for each
73972>>>//                    // cDbUpdateVersion object!
73972>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73972>>>//                    // with the value of pnVersionNumber after each update has been finished.
73972>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73972>>>//                        Set pnVersionNumber to 1.1
73972>>>//                        Use VersionUpdate1_1.pkg
73972>>>//                    End_Object
73972>>>//
73972>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73972>>>//                        Set pnVersionNumber to 1.2
73972>>>//                        Use VersionUpdate1_2.pkg
73972>>>//                    End_Object
73972>>>//
73972>>>//                End_Object
73972>>>//
73972>>>//
73972>>>// $Rev History:
73972>>>//    2016-09-27  Module header created
73972>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73972>>>//                take place before any tables have been opened, or errors
73972>>>//                could occur if the client database is out of sync with the
73972>>>//                compiled program.
73972>>>//                Added user counting checks + lockout while database is being
73972>>>//                updated.
73972>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73972>>>//                as it is more in line with the child class cDbUpdateVersion name.
73972>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73972>>>//****************************************************************************
73972>>>Use VdfBase.pkg
73972>>>Use Dferror.pkg
73972>>>Use seq_chnl.pkg
73972>>>Use Datadict.pkg
73972>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73972>>>>>// *** The Database Update Framework Include file for Languages ***
73972>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73972>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73972>>>>>//
73972>>>>>Use LanguageText.Pkg
73972>>>>>
73972>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73972>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73972>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73972>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73972>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73972>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73972>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73972>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73972>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73972>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73972>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73972>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73972>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73972>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73972>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73972>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73972>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73972>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73972>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73972>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73972>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73972>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73972>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73972>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73972>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73972>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73972>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73972>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73972>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73972>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73972>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73972>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73972>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73972>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73972>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73972>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73972>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>>>
73972>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73972>>>>>// StatPnl.pkg - creates the standard status_panel object.
73972>>>>>//
73972>>>>>//
73972>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73972>>>>>// invoke the standard status panel. The standard has always been that the package name
73972>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73972>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73972>>>>>// prior revisions has been replace with status panel that is part of the application.
73972>>>>>// This should work much better and faster than the old sentinel based solution.
73972>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73972>>>>>// with most applications.
73972>>>>>//
73972>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73972>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73972>>>>>// a cleaner more robust interface.
73972>>>>>//
73972>>>>>//
73972>>>>>// Compatibility Note:
73972>>>>>//
73972>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73972>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73972>>>>>//
73972>>>>>// If for some reason you application will not work using this as a replacement for the old status
73972>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73972>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73972>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73972>>>>>//
73972>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73972>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73972>>>>>//
73972>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73972>>>>>// can still access the new object via the ghoStatusPanel handle.
73972>>>>>//
73972>>>>>//
73972>>>>>// Creating your own Status Panel objects
73972>>>>>//
73972>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73972>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73972>>>>>// with a different file and object name and direct your status panel request to the new object.
73972>>>>>//
73972>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73972>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73972>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73972>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73972>>>>>// e.g.
73972>>>>>//       Procedure UpdateStatusBar
73972>>>>>//           Send DoAdvance of oProgressBar
73972>>>>>//           Send ProcessEvents
73972>>>>>//       End_Procedure
73972>>>>>//
73972>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73972>>>>>// messages this will be done for you.
73972>>>>>//
73972>>>>>// the standard Interface for status panels are:
73972>>>>>//
73972>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73972>>>>>// Send Start_StatusPanel      - start the status panel
73972>>>>>// Send Stop_StatusPanel       - stop the status panel
73972>>>>>// Send Update_StatusPanel     - update the status panel's action area
73972>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73972>>>>>//
73972>>>>>// Get/Set Caption_Text - updates the caption bar
73972>>>>>// Get/Set Title_Text   - updates the title area
73972>>>>>// Get/Set Message_Text - updates the Message area
73972>>>>>// Get/Set Action_Text  - updates the action area
73972>>>>>// Get/Set Button_Text  - updates the button area
73972>>>>>//
73972>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73972>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73972>>>>>//
73972>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73972>>>>>Use cProcessStatusPanel.pkg
73972>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJSkinFramework.pkg)
73972>>>>>>>Use windows.pkg
73972>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJComSkinFramework.pkg)
73972>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73972>>>>>>>>>Use FlexCom20.pkg
73972>>>>>>>>>
73972>>>>>>>>>// Changes to Imported package
73972>>>>>>>>>//     OLEXTPxx to XTPxx
73972>>>>>>>>>//     OLExtpxx to xtpxx
73972>>>>>>>>>//     OLESkinFramework to SkinFramework
73972>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73972>>>>>>>>>//     cCom classes to cCJ
73972>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73972>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73972>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73972>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73972>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73972>>>>>>>>>
73972>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73972>>>>>>>>>// because other Codejock classes use these.
73972>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73972>>>>>>>>>
73972>>>>>>>>>
73972>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73972>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73972>>>>>>>>>    Define xtpSkinApplyFrame for 2
73972>>>>>>>>>    Define xtpSkinApplyColors for 4
73972>>>>>>>>>    Define xtpSkinApplyMenus for 8
73972>>>>>>>>>
73972>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73972>>>>>>>>>// Dispatch interface for SkinFramework Control
73972>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73973>>>>>>>>>
73973>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73975>>>>>>>>>        SkinFrameworkApplyOptions retVal
73975>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73976>>>>>>>>>        Function_Return retVal
73977>>>>>>>>>    End_Function
73978>>>>>>>>>
73978>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73980>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73981>>>>>>>>>    End_Procedure
73982>>>>>>>>>
73982>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73984>>>>>>>>>        Boolean retVal
73984>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73985>>>>>>>>>        Function_Return retVal
73986>>>>>>>>>    End_Function
73987>>>>>>>>>
73987>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73989>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73990>>>>>>>>>    End_Procedure
73991>>>>>>>>>
73991>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73993>>>>>>>>>        Boolean retVal
73993>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73994>>>>>>>>>        Function_Return retVal
73995>>>>>>>>>    End_Function
73996>>>>>>>>>
73996>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73998>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73999>>>>>>>>>    End_Procedure
74000>>>>>>>>>
74000>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74002>>>>>>>>>        Handle hDispatchDriver
74002>>>>>>>>>        Boolean retVal
74002>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74003>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74004>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74005>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74006>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74007>>>>>>>>>        Function_Return retVal
74008>>>>>>>>>    End_Function
74009>>>>>>>>>
74009>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74011>>>>>>>>>        Handle hDispatchDriver
74011>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74012>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74013>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74014>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74015>>>>>>>>>    End_Procedure
74016>>>>>>>>>
74016>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74018>>>>>>>>>        Handle hDispatchDriver
74018>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74019>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74020>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74021>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74022>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>
74024>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74026>>>>>>>>>        Handle hDispatchDriver
74026>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74027>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74028>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74029>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74030>>>>>>>>>    End_Procedure
74031>>>>>>>>>
74031>>>>>>>>>    Procedure ComRemoveAllWindows
74033>>>>>>>>>        Handle hDispatchDriver
74033>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74034>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74035>>>>>>>>>    End_Procedure
74036>>>>>>>>>
74036>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74038>>>>>>>>>        Handle hDispatchDriver
74038>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74039>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74040>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74041>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74042>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74043>>>>>>>>>    End_Procedure
74044>>>>>>>>>
74044>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
74046>>>>>>>>>        Handle hDispatchDriver
74046>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74047>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74048>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74049>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74050>>>>>>>>>    End_Procedure
74051>>>>>>>>>
74051>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74053>>>>>>>>>        Handle hDispatchDriver
74053>>>>>>>>>        Variant retVal
74053>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74054>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74055>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74056>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74057>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74058>>>>>>>>>        Function_Return retVal
74059>>>>>>>>>    End_Function
74060>>>>>>>>>
74060>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74062>>>>>>>>>        Handle hDispatchDriver
74062>>>>>>>>>        Variant retVal
74062>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74063>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74064>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74065>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74066>>>>>>>>>        Function_Return retVal
74067>>>>>>>>>    End_Function
74068>>>>>>>>>
74068>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74070>>>>>>>>>        Handle hDispatchDriver
74070>>>>>>>>>        OLE_COLOR retVal
74070>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74071>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74072>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74073>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74074>>>>>>>>>        Function_Return retVal
74075>>>>>>>>>    End_Function
74076>>>>>>>>>
74076>>>>>>>>>    Procedure ComExcludeModule String llModuleName
74078>>>>>>>>>        Handle hDispatchDriver
74078>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74079>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74080>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74081>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74082>>>>>>>>>    End_Procedure
74083>>>>>>>>>
74083>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74085>>>>>>>>>        Handle hDispatchDriver
74085>>>>>>>>>        Variant retVal
74085>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74086>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74087>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74088>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74089>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74090>>>>>>>>>        Function_Return retVal
74091>>>>>>>>>    End_Function
74092>>>>>>>>>
74092>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74094>>>>>>>>>        Handle hDispatchDriver
74094>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74095>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74096>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74097>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74098>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74099>>>>>>>>>    End_Procedure
74100>>>>>>>>>
74100>>>>>>>>>    Procedure ComAboutBox
74102>>>>>>>>>        Handle hDispatchDriver
74102>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74103>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>End_Class
74106>>>>>>>>>
74106>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74106>>>>>>>>>// Event interface for SkinFramework Control
74106>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74107>>>>>>>>>
74107>>>>>>>>>    Procedure RegisterComEvents
74109>>>>>>>>>    End_Procedure
74110>>>>>>>>>End_Class
74111>>>>>>>>>
74111>>>>>>>>>// CoClass
74111>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74111>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74111>>>>>>>>>// SkinFramework Control
74111>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74112>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74113>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74114>>>>>>>>>
74114>>>>>>>>>    Procedure Construct_Object
74116>>>>>>>>>        Forward Send Construct_Object
74118>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74119>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74120>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74121>>>>>>>>>        Set peAutoCreate to acAutoCreate
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74124>>>>>>>>>// SkinFramework Global Settings
74124>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74125>>>>>>>>>
74125>>>>>>>>>    Function ComLicense Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComLicense String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComTitle Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComTitle String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74143>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74145>>>>>>>>>        Boolean retVal
74145>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74146>>>>>>>>>        Function_Return retVal
74147>>>>>>>>>    End_Function
74148>>>>>>>>>
74148>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74148>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74150>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74151>>>>>>>>>    End_Procedure
74152>>>>>>>>>
74152>>>>>>>>>    Function ComVersion Returns String
74154>>>>>>>>>        Handle hDispatchDriver
74154>>>>>>>>>        String retVal
74154>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74155>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74156>>>>>>>>>        Function_Return retVal
74157>>>>>>>>>    End_Function
74158>>>>>>>>>
74158>>>>>>>>>    Function ComUnicode Returns Boolean
74160>>>>>>>>>        Handle hDispatchDriver
74160>>>>>>>>>        Boolean retVal
74160>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74161>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74162>>>>>>>>>        Function_Return retVal
74163>>>>>>>>>    End_Function
74164>>>>>>>>>
74164>>>>>>>>>    Function ComOcxPath Returns String
74166>>>>>>>>>        Handle hDispatchDriver
74166>>>>>>>>>        String retVal
74166>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74167>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74168>>>>>>>>>        Function_Return retVal
74169>>>>>>>>>    End_Function
74170>>>>>>>>>End_Class
74171>>>>>>>>>
74171>>>>>>>>>// CoClass
74171>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74171>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74171>>>>>>>>>// SkinFramework Global Settings
74171>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74172>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74173>>>>>>>>>
74173>>>>>>>>>    Procedure Construct_Object
74175>>>>>>>>>        Forward Send Construct_Object
74177>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74178>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74179>>>>>>>>>    End_Procedure
74180>>>>>>>>>End_Class
74181>>>>>>>>>
74181>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74181>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74182>>>>>>>>>
74182>>>>>>>>>    Function ComColorScheme Returns String
74184>>>>>>>>>        String retVal
74184>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74185>>>>>>>>>        Function_Return retVal
74186>>>>>>>>>    End_Function
74187>>>>>>>>>
74187>>>>>>>>>    Procedure Set ComColorScheme String value
74189>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74190>>>>>>>>>    End_Procedure
74191>>>>>>>>>
74191>>>>>>>>>    Function ComFontSize Returns String
74193>>>>>>>>>        String retVal
74193>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74194>>>>>>>>>        Function_Return retVal
74195>>>>>>>>>    End_Function
74196>>>>>>>>>
74196>>>>>>>>>    Procedure Set ComFontSize String value
74198>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74199>>>>>>>>>    End_Procedure
74200>>>>>>>>>
74200>>>>>>>>>    Function ComIniFileName Returns String
74202>>>>>>>>>        String retVal
74202>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74203>>>>>>>>>        Function_Return retVal
74204>>>>>>>>>    End_Function
74205>>>>>>>>>
74205>>>>>>>>>    Procedure Set ComIniFileName String value
74207>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74208>>>>>>>>>    End_Procedure
74209>>>>>>>>>End_Class
74210>>>>>>>>>
74210>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74210>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74211>>>>>>>>>
74211>>>>>>>>>    Function ComName Returns String
74213>>>>>>>>>        String retVal
74213>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74214>>>>>>>>>        Function_Return retVal
74215>>>>>>>>>    End_Function
74216>>>>>>>>>
74216>>>>>>>>>    Procedure Set ComName String value
74218>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74219>>>>>>>>>    End_Procedure
74220>>>>>>>>>
74220>>>>>>>>>    Function ComPath Returns String
74222>>>>>>>>>        String retVal
74222>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74223>>>>>>>>>        Function_Return retVal
74224>>>>>>>>>    End_Function
74225>>>>>>>>>
74225>>>>>>>>>    Procedure Set ComPath String value
74227>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74228>>>>>>>>>    End_Procedure
74229>>>>>>>>>
74229>>>>>>>>>    Function ComCount Returns Integer
74231>>>>>>>>>        Handle hDispatchDriver
74231>>>>>>>>>        Integer retVal
74231>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74232>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74233>>>>>>>>>        Function_Return retVal
74234>>>>>>>>>    End_Function
74235>>>>>>>>>
74235>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74237>>>>>>>>>        Handle hDispatchDriver
74237>>>>>>>>>        Variant retVal
74237>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74238>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74239>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74240>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74241>>>>>>>>>        Function_Return retVal
74242>>>>>>>>>    End_Function
74243>>>>>>>>>
74243>>>>>>>>>    Function Com_NewEnum Returns Variant
74245>>>>>>>>>        Handle hDispatchDriver
74245>>>>>>>>>        Variant retVal
74245>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74246>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74247>>>>>>>>>        Function_Return retVal
74248>>>>>>>>>    End_Function
74249>>>>>>>>>End_Class
74250>>>>>>>>>
74250>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74250>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74251>>>>>>>>>
74251>>>>>>>>>    Function ComCount Returns Integer
74253>>>>>>>>>        Handle hDispatchDriver
74253>>>>>>>>>        Integer retVal
74253>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74254>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74255>>>>>>>>>        Function_Return retVal
74256>>>>>>>>>    End_Function
74257>>>>>>>>>
74257>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74259>>>>>>>>>        Handle hDispatchDriver
74259>>>>>>>>>        Variant retVal
74259>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74260>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74261>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74262>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74263>>>>>>>>>        Function_Return retVal
74264>>>>>>>>>    End_Function
74265>>>>>>>>>
74265>>>>>>>>>    Function Com_NewEnum Returns Variant
74267>>>>>>>>>        Handle hDispatchDriver
74267>>>>>>>>>        Variant retVal
74267>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74268>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74269>>>>>>>>>        Function_Return retVal
74270>>>>>>>>>    End_Function
74271>>>>>>>>>End_Class
74272>>>>>>>>>
74272>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74272>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74273>>>>>>>>>
74273>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74275>>>>>>>>>        Handle hDispatchDriver
74275>>>>>>>>>        OLE_COLOR retVal
74275>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74276>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74277>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74278>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74279>>>>>>>>>        Function_Return retVal
74280>>>>>>>>>    End_Function
74281>>>>>>>>>End_Class
74282>>>>>>>Use cApplication.pkg
74282>>>>>>>
74282>>>>>>>Struct tSkinInformation
74282>>>>>>>    String sName     // description of the skin
74282>>>>>>>    String sSkinfile // file path. Can be relative or full
74282>>>>>>>    String sSkinIni  // section name
74282>>>>>>>End_Struct
74282>>>>>>>
74282>>>>>>>
74282>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74283>>>>>>>    
74283>>>>>>>    Procedure Construct_Object
74285>>>>>>>        Forward Send Construct_Object
74287>>>>>>>        
74287>>>>>>>        Property String psSkinFile ""
74288>>>>>>>        Property String psSkinIni ""
74289>>>>>>>        Property Boolean pbLoadPreference False
74290>>>>>>>        
74290>>>>>>>        Set peAutoCreate to acAutoCreate
74291>>>>>>>        
74291>>>>>>>        Move Self to ghoSkinFramework
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    // return the default skin path, which is the programs directory.
74293>>>>>>>    // This requires an application object.
74293>>>>>>>    // If you want to different skin path, override this.
74293>>>>>>>    Function SkinPath Returns String
74295>>>>>>>        String sPath sPaths
74295>>>>>>>        Handle hoWorkspace
74295>>>>>>>        If ghoApplication Begin
74297>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74298>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74299>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74300>>>>>>>        End
74300>>>>>>>>
74300>>>>>>>        Else Begin
74301>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74302>>>>>>>>
74302>>>>>>>        End
74302>>>>>>>>
74302>>>>>>>        Function_Return sPath
74303>>>>>>>    End_Function
74304>>>>>>>    
74304>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74304>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74304>>>>>>>    Function SkinQFile Returns String
74306>>>>>>>        String sFile sPath sSep
74306>>>>>>>        Boolean bQualified
74306>>>>>>>        Get psSkinFile to sFile
74307>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74309>>>>>>>            Get SkinPath to sPath
74310>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74311>>>>>>>            Move (sPath - sSep - sFile) to sFile
74312>>>>>>>        End
74312>>>>>>>>
74312>>>>>>>        Function_Return sFile
74313>>>>>>>    End_Function
74314>>>>>>>    
74314>>>>>>>    // defines the default VDF window class mapping.
74314>>>>>>>    Procedure OnAddVDFWindowClasses
74316>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74317>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74318>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74319>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74320>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74321>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74322>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74323>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74324>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74325>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74326>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74327>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74328>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74329>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74330>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74331>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74332>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74333>>>>>>>        // External class
74333>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74334>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74335>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74336>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74337>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74338>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74339>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74340>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74341>>>>>>>    End_Procedure
74342>>>>>>>    
74342>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74342>>>>>>>    Procedure OnAddCustomWindowClasses
74344>>>>>>>    End_Procedure
74345>>>>>>>    
74345>>>>>>>    // called when object is created during end_construct_object.
74345>>>>>>>    Procedure OnCreate
74347>>>>>>>        Integer iOpts
74347>>>>>>>        Boolean bUseWindowsFont
74347>>>>>>>        Forward Send OnCreate
74349>>>>>>>        
74349>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74349>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74349>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74350>>>>>>>        If bUseWindowsFont Begin
74352>>>>>>>            Get ComApplyOptions to iOpts
74353>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74354>>>>>>>        End
74354>>>>>>>>
74354>>>>>>>        
74354>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74354>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74354>>>>>>>        // and this was the suggested workaround.
74354>>>>>>>        Set ComAutoApplyNewThreads to False
74355>>>>>>>        
74355>>>>>>>        Send OnAddVDFWindowClasses
74356>>>>>>>        Send OnAddCustomWindowClasses
74357>>>>>>>        
74357>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74357>>>>>>>        If (pbLoadPreference(Self)) Begin
74359>>>>>>>            Send LoadSkinPreference
74360>>>>>>>        End
74360>>>>>>>>
74360>>>>>>>        // if a skin file name exists, we apply the skin.
74360>>>>>>>        If (psSkinFile(Self)<>"") Begin
74362>>>>>>>            Send ApplySkin
74363>>>>>>>        End
74363>>>>>>>>
74363>>>>>>>    End_Procedure
74364>>>>>>>    
74364>>>>>>>    // called by framework as part of application exit.
74364>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74366>>>>>>>        Send Notify_Exit_Application
74367>>>>>>>    End_Procedure
74368>>>>>>>    
74368>>>>>>>    Procedure Notify_Exit_Application
74370>>>>>>>        If (pbLoadPreference(Self)) Begin
74372>>>>>>>            Send SaveSkinPreference
74373>>>>>>>        End
74373>>>>>>>>
74373>>>>>>>    End_Procedure
74374>>>>>>>    
74374>>>>>>>    Procedure NotifyPreApplySkin
74376>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74378>>>>>>>    End_Procedure
74379>>>>>>>    
74379>>>>>>>    Procedure NotifyPostApplySkin
74381>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74383>>>>>>>    End_Procedure
74384>>>>>>>    
74384>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74384>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74384>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74386>>>>>>>        tSkinInformation[] Skins
74386>>>>>>>        tSkinInformation[] Skins
74387>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74387>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74387>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74387>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74387>>>>>>>        Integer iPos iDfltLen
74387>>>>>>>        Boolean bUseRelativePath
74387>>>>>>>        
74387>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74388>>>>>>>        
74388>>>>>>>        Get SkinPath to sDefaultPath
74389>>>>>>>        If (sPath="") Begin
74391>>>>>>>            Move sDefaultPath to sPath
74392>>>>>>>        End
74392>>>>>>>>
74392>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74393>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74394>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74395>>>>>>>        
74395>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74396>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74398>>>>>>>            
74398>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74399>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74400>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74401>>>>>>>            
74401>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74402>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74403>>>>>>>            
74403>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74409>>>>>>>>
74409>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74410>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74411>>>>>>>                
74411>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74412>>>>>>>                
74412>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74418>>>>>>>>
74418>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74419>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74420>>>>>>>                    
74420>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74421>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74422>>>>>>>                    If bUseRelativePath Begin
74424>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74425>>>>>>>                        If iPos Begin
74427>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74428>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74432>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74433>>>>>>>                            Loop
74434>>>>>>>>
74434>>>>>>>                        End
74434>>>>>>>>
74434>>>>>>>                    End
74434>>>>>>>>
74434>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74435>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74436>>>>>>>                    
74436>>>>>>>                    Increment iArrayItem
74437>>>>>>>                Loop
74438>>>>>>>>
74438>>>>>>>            Loop
74439>>>>>>>>
74439>>>>>>>            
74439>>>>>>>            Send Destroy of hSkinDescriptions
74440>>>>>>>            Send Destroy of hSkinDescription
74441>>>>>>>            Send Destroy of hSkinIniFile
74442>>>>>>>            
74442>>>>>>>        End
74442>>>>>>>>
74442>>>>>>>        Function_Return Skins
74443>>>>>>>    End_Function
74444>>>>>>>    
74444>>>>>>>    // Save the skin preference. This requires an application object.
74444>>>>>>>    // Only do this if the application object allows it.
74444>>>>>>>    // This is called during startup if pbLoadPreference is True
74444>>>>>>>    // Suitable for override
74444>>>>>>>    Procedure SaveSkinPreference
74446>>>>>>>        String sSkin sIni
74446>>>>>>>        If ghoApplication Begin
74448>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74450>>>>>>>                Get psSkinFile to sSkin
74451>>>>>>>                Get psSkinIni to sIni
74452>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74453>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74454>>>>>>>            End
74454>>>>>>>>
74454>>>>>>>        End
74454>>>>>>>>
74454>>>>>>>        Else Begin
74455>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74456>>>>>>>>
74456>>>>>>>        End
74456>>>>>>>>
74456>>>>>>>    End_Procedure
74457>>>>>>>    
74457>>>>>>>    // Load the skin preference. This requires an application object.
74457>>>>>>>    // Only do this if the application object allows it.
74457>>>>>>>    // This is called during startup if pbLoadPreference is True
74457>>>>>>>    // Suitable for override
74457>>>>>>>    Procedure LoadSkinPreference
74459>>>>>>>        String sSkin sIni
74459>>>>>>>        Boolean bExists
74459>>>>>>>        If ghoApplication Begin
74461>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74463>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74464>>>>>>>                If bExists Begin
74466>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74467>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74468>>>>>>>                    Set psSkinFile to sSkin
74469>>>>>>>                    Set psSkinIni to sIni
74470>>>>>>>                End
74470>>>>>>>>
74470>>>>>>>            End
74470>>>>>>>>
74470>>>>>>>        End
74470>>>>>>>>
74470>>>>>>>        Else Begin
74471>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74472>>>>>>>>
74472>>>>>>>        End
74472>>>>>>>>
74472>>>>>>>    End_Procedure
74473>>>>>>>    
74473>>>>>>>    // Can be called to apply the current skin.
74473>>>>>>>    Procedure ApplySkin
74475>>>>>>>        Boolean bOk
74475>>>>>>>        String sSkin sIni
74475>>>>>>>        If (IsComObjectCreated(Self)) Begin
74477>>>>>>>            Get SkinQFile to sSkin
74478>>>>>>>            Get psSkinIni to sIni
74479>>>>>>>            
74479>>>>>>>            Send NotifyPreApplySkin
74480>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74480>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74481>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74482>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74484>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74484>>>>>>>                Send EnableVisualStyles of Desktop True
74485>>>>>>>            End
74485>>>>>>>>
74485>>>>>>>            Send NotifyPostApplySkin
74486>>>>>>>        End
74486>>>>>>>>
74486>>>>>>>    End_Procedure
74487>>>>>>>    
74487>>>>>>>    
74487>>>>>>>End_Class
74488>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProgressBar.pkg)
74488>>>>>>>Use Windows.pkg
74488>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWinControl.pkg)
74488>>>>>>>>>Use Windows.pkg
74488>>>>>>>>>
74488>>>>>>>>>// Key State Masks for Mouse Messages
74488>>>>>>>>>
74488>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74488>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74488>>>>>>>>>Define MK_SHIFT    for |CI$0004
74488>>>>>>>>>Define MK_CONTROL  for |CI$0008
74488>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74488>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74488>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74488>>>>>>>>>
74488>>>>>>>>>Enum_List // Mouse Key Flags
74488>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74488>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74488>>>>>>>>>    Define mkRight   for MK_RBUTTON
74488>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74488>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74488>>>>>>>>>    Define mkShift   for MK_SHIFT
74488>>>>>>>>>    Define mkControl for MK_CONTROL
74488>>>>>>>>>End_Enum_List
74488>>>>>>>>>
74488>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74488>>>>>>>>>    Define mbLeft
74488>>>>>>>>>    Define mbMiddle
74488>>>>>>>>>    Define mbRight
74488>>>>>>>>>    Define mbX1
74488>>>>>>>>>    Define mbX2
74488>>>>>>>>>End_Enum_List
74488>>>>>>>>>
74488>>>>>>>>>Class cWinControl is a DfBaseControl
74489>>>>>>>>>    Procedure Construct_Object
74491>>>>>>>>>        Forward Send Construct_Object
74493>>>>>>>>>        Property Integer private_pbEnabled True
74494>>>>>>>>>        Property Integer private_pbVisible True
74495>>>>>>>>>    End_Procedure
74496>>>>>>>>>    
74496>>>>>>>>>    Procedure End_Construct_Object
74498>>>>>>>>>        Forward Send End_Construct_Object
74500>>>>>>>>>        
74500>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74501>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74502>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74503>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74504>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74505>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74506>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74507>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74508>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74509>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74510>>>>>>>>>    End_Procedure
74511>>>>>>>>>    
74511>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74513>>>>>>>>>        //Intentionally cancelled
74513>>>>>>>>>    End_Procedure
74514>>>>>>>>>    
74514>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74516>>>>>>>>>        //Intentionally cancelled
74516>>>>>>>>>    End_Procedure
74517>>>>>>>>>    
74517>>>>>>>>>    Procedure DoRecreateWindow
74519>>>>>>>>>        // Recreates the window
74519>>>>>>>>>        If (Window_Handle(Self)) Begin
74521>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74521>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74522>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74523>>>>>>>>>        End
74523>>>>>>>>>>
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure DoUpdateWindow
74526>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        Get Window_Handle to hWnd
74527>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74530>>>>>>>>>    End_Procedure
74531>>>>>>>>>    
74531>>>>>>>>>    Procedure Page Integer iState
74533>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74534>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74535>>>>>>>>>        Forward Send Page iState
74537>>>>>>>>>    End_Procedure
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74540>>>>>>>>>        Integer x y eButton
74540>>>>>>>>>        
74540>>>>>>>>>        Move (Hi(lParam))  to y
74541>>>>>>>>>        Move (Low(lParam)) to x
74542>>>>>>>>>        
74542>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74543>>>>>>>>>    End_Procedure
74544>>>>>>>>>    
74544>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74546>>>>>>>>>        Integer x y eButton
74546>>>>>>>>>        
74546>>>>>>>>>        Move (Hi(lParam))  to y
74547>>>>>>>>>        Move (Low(lParam)) to x
74548>>>>>>>>>        
74548>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74549>>>>>>>>>    End_Procedure
74550>>>>>>>>>    
74550>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74552>>>>>>>>>        Integer x y eButton
74552>>>>>>>>>        
74552>>>>>>>>>        Move (Hi(lParam))  to y
74553>>>>>>>>>        Move (Low(lParam)) to x
74554>>>>>>>>>        
74554>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74555>>>>>>>>>    End_Procedure
74556>>>>>>>>>    
74556>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74558>>>>>>>>>        Integer x y eButton fKeys
74558>>>>>>>>>        
74558>>>>>>>>>        Move (Hi(lParam))  to y
74559>>>>>>>>>        Move (Low(lParam)) to x
74560>>>>>>>>>        
74560>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74561>>>>>>>>>    End_Procedure
74562>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74564>>>>>>>>>        Integer x y eButton
74564>>>>>>>>>        
74564>>>>>>>>>        Move (Hi(lParam))  to y
74565>>>>>>>>>        Move (Low(lParam)) to x
74566>>>>>>>>>        
74566>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74567>>>>>>>>>    End_Procedure
74568>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74570>>>>>>>>>        Integer x y eButton
74570>>>>>>>>>        
74570>>>>>>>>>        Move (Hi(lParam))  to y
74571>>>>>>>>>        Move (Low(lParam)) to x
74572>>>>>>>>>        
74572>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74573>>>>>>>>>    End_Procedure
74574>>>>>>>>>    
74574>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74576>>>>>>>>>        Integer x y eButton
74576>>>>>>>>>        
74576>>>>>>>>>        Move (Hi(lParam))  to y
74577>>>>>>>>>        Move (Low(lParam)) to x
74578>>>>>>>>>        
74578>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74579>>>>>>>>>    End_Procedure
74580>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74582>>>>>>>>>        Integer x y eButton
74582>>>>>>>>>        
74582>>>>>>>>>        Move (Hi(lParam))  to y
74583>>>>>>>>>        Move (Low(lParam)) to x
74584>>>>>>>>>        
74584>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74585>>>>>>>>>    End_Procedure
74586>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74588>>>>>>>>>        Integer x y eButton
74588>>>>>>>>>        
74588>>>>>>>>>        Move (Hi(lParam))  to y
74589>>>>>>>>>        Move (Low(lParam)) to x
74590>>>>>>>>>        
74590>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74591>>>>>>>>>    End_Procedure
74592>>>>>>>>>    
74592>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74594>>>>>>>>>        Integer x y eButton
74594>>>>>>>>>        
74594>>>>>>>>>        Move (Hi(lParam))  to y
74595>>>>>>>>>        Move (Low(lParam)) to x
74596>>>>>>>>>        
74596>>>>>>>>>        Send OnMouseMove x y wParam
74597>>>>>>>>>    End_Procedure
74598>>>>>>>>>    
74598>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74600>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74600>>>>>>>>>        //String sButton
74600>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74600>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74600>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74600>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74600>>>>>>>>>        
74600>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74600>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74600>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74600>>>>>>>>>    End_Procedure
74601>>>>>>>>>    
74601>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74603>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74603>>>>>>>>>        //String sButton
74603>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74603>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74603>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74603>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74603>>>>>>>>>        
74603>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74603>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74603>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74603>>>>>>>>>    End_Procedure
74604>>>>>>>>>    
74604>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74606>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74606>>>>>>>>>        //String sButton
74606>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74606>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74606>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74606>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74606>>>>>>>>>        
74606>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74606>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74606>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74606>>>>>>>>>    End_Procedure
74607>>>>>>>>>    
74607>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74609>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74609>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74609>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74609>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74609>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74609>>>>>>>>>        
74609>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74609>>>>>>>>>    End_Procedure
74610>>>>>>>>>    
74610>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74612>>>>>>>>>        Handle hWnd
74612>>>>>>>>>        
74612>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74614>>>>>>>>>            Set private_pbEnabled to bEnabled
74615>>>>>>>>>            Get Window_Handle to hWnd
74616>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74619>>>>>>>>>        End
74619>>>>>>>>>>
74619>>>>>>>>>    End_Procedure
74620>>>>>>>>>    Function pbEnabled Returns Boolean
74622>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74623>>>>>>>>>    End_Function
74624>>>>>>>>>    
74624>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74626>>>>>>>>>        Handle  hWnd
74626>>>>>>>>>        Integer iVoid
74626>>>>>>>>>        
74626>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74628>>>>>>>>>            Set private_pbVisible to bVisible
74629>>>>>>>>>            Get Window_Handle to hWnd
74630>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74633>>>>>>>>>        End
74633>>>>>>>>>>
74633>>>>>>>>>    End_Procedure
74634>>>>>>>>>    Function pbVisible Returns Boolean
74636>>>>>>>>>        Function_Return (private_pbVisible(Self))
74637>>>>>>>>>    End_Function
74638>>>>>>>>>    
74638>>>>>>>>>End_Class
74639>>>>>>>Use CommCtrl.pkg
74639>>>>>>>
74639>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74639>>>>>>>Class cProgressBar is a cWinControl
74640>>>>>>>    
74640>>>>>>>    Procedure Construct_Object
74642>>>>>>>        Forward Send Construct_Object
74644>>>>>>>        Property Integer private_piMinimum
74645>>>>>>>        Property Integer private_piMaximum   100
74646>>>>>>>        Property Integer private_piAdvanceBy 10
74647>>>>>>>        Property Integer private_piPosition
74648>>>>>>>        Property Integer private_pbVertical  False
74649>>>>>>>        Property Integer private_pbSmooth    False
74650>>>>>>>        Property Integer private_piBackColor clDefault
74651>>>>>>>        Property Integer private_piBarColor  clDefault
74652>>>>>>>        
74652>>>>>>>        Send Define_ToolTip_Support_Mixin
74653>>>>>>>        
74653>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74654>>>>>>>        Set Focus_Mode to NonFocusable
74655>>>>>>>        Set Skip_State to True
74656>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74657>>>>>>>    End_Procedure
74658>>>>>>>    
74658>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74659>>>>>>>    
74659>>>>>>>    Procedure Set piMinimum Integer iMin
74661>>>>>>>        Integer iMax
74661>>>>>>>        
74661>>>>>>>        Set private_piMinimum to iMin
74662>>>>>>>        Get private_piMaximum to iMax
74663>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74664>>>>>>>    End_Procedure
74665>>>>>>>    Function piMinimum Returns Integer
74667>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74670>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74672>>>>>>>    End_Function
74673>>>>>>>    
74673>>>>>>>    Procedure Set piMaximum Integer iMax
74675>>>>>>>        Integer iMin
74675>>>>>>>        
74675>>>>>>>        Set private_piMaximum to iMax
74676>>>>>>>        Get private_piMinimum to iMin
74677>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74678>>>>>>>    End_Procedure
74679>>>>>>>    Function piMaximum Returns Integer
74681>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74684>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74686>>>>>>>    End_Function
74687>>>>>>>    
74687>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74689>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74690>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74691>>>>>>>    End_Procedure
74692>>>>>>>    Function piAdvanceBy Returns Integer
74694>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74695>>>>>>>    End_Function
74696>>>>>>>    
74696>>>>>>>    Procedure Set piPosition Integer iPos
74698>>>>>>>        Set private_piPosition to iPos
74699>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74700>>>>>>>    End_Procedure
74701>>>>>>>    
74701>>>>>>>    Function piPosition Returns Integer
74703>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74706>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74708>>>>>>>    End_Function
74709>>>>>>>    
74709>>>>>>>    Procedure Set pbVertical Boolean bVertical
74711>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74713>>>>>>>            Set private_pbVertical to bVertical
74714>>>>>>>            Send DoRecreateWindow
74715>>>>>>>        End
74715>>>>>>>>
74715>>>>>>>    End_Procedure
74716>>>>>>>    
74716>>>>>>>    Function pbVertical Returns Boolean
74718>>>>>>>        Function_Return (private_pbVertical(Self))
74719>>>>>>>    End_Function
74720>>>>>>>    
74720>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74722>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74724>>>>>>>            Set private_pbSmooth to bSmooth
74725>>>>>>>            Send DoRecreateWindow
74726>>>>>>>        End
74726>>>>>>>>
74726>>>>>>>    End_Procedure
74727>>>>>>>    Function pbSmooth Returns Boolean
74729>>>>>>>        Function_Return (private_pbSmooth(Self))
74730>>>>>>>    End_Function
74731>>>>>>>    
74731>>>>>>>    Procedure Set piBackColor Integer rgbColor
74733>>>>>>>        Set private_piBackColor to rgbColor
74734>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74735>>>>>>>    End_Procedure
74736>>>>>>>    Function piBackColor Returns Integer
74738>>>>>>>        Function_Return (private_piBackColor(Self))
74739>>>>>>>    End_Function
74740>>>>>>>    
74740>>>>>>>    Procedure Set piBarColor Integer rgbColor
74742>>>>>>>        Set private_piBarColor to rgbColor
74743>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74744>>>>>>>    End_Procedure
74745>>>>>>>    Function piBarColor Returns Integer
74747>>>>>>>        Function_Return (private_piBarColor(Self))
74748>>>>>>>    End_Function
74749>>>>>>>    
74749>>>>>>>    Procedure DoAdvance
74751>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74752>>>>>>>    End_Procedure
74753>>>>>>>    
74753>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74755>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74756>>>>>>>    End_Procedure
74757>>>>>>>    
74757>>>>>>>    Procedure private_DoInitWindow
74759>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74760>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74761>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74762>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74763>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74764>>>>>>>        Set piPosition  to (private_piPosition(Self))
74765>>>>>>>    End_Procedure
74766>>>>>>>    
74766>>>>>>>    Procedure Page_Object Integer iState
74768>>>>>>>        Handle hWnd
74768>>>>>>>        
74768>>>>>>>        Get Window_Handle to hWnd
74769>>>>>>>        If (hWnd=0 and iState) Begin
74771>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74772>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74773>>>>>>>            Forward Send Page_Object True
74775>>>>>>>        End
74775>>>>>>>>
74775>>>>>>>        Else ;            Forward Send Page_Object iState
74778>>>>>>>        
74778>>>>>>>        // Handle tooltip support....
74778>>>>>>>        If (iState = 0) Begin
74780>>>>>>>            Send RequestDeleteToolTip
74781>>>>>>>        End
74781>>>>>>>>
74781>>>>>>>        Else Begin
74782>>>>>>>            Send RequestAddToolTip
74783>>>>>>>        End
74783>>>>>>>>
74783>>>>>>>    End_Procedure
74784>>>>>>>    
74784>>>>>>>    Procedure Page Integer iState
74786>>>>>>>        Forward Send Page iState
74788>>>>>>>        If (iState =1);            Send private_DoInitWindow
74791>>>>>>>    End_Procedure
74792>>>>>>>    
74792>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74792>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74792>>>>>>>    // is implemented in a mixin class.
74792>>>>>>>    Procedure RequestAddToolTip
74794>>>>>>>        Send AddToolTip
74795>>>>>>>    End_Procedure
74796>>>>>>>    
74796>>>>>>>    
74796>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74796>>>>>>>    Procedure RequestDeleteToolTip
74798>>>>>>>        Send DeleteToolTip
74799>>>>>>>    End_Procedure
74800>>>>>>>End_Class
74801>>>>>Use Windows.pkg
74801>>>>>Use DUFLanguageConstants.inc
74801>>>>>Use Statpnl.pkg
74801>>>>>
74801>>>>>
74801>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74801>>>>>
74801>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74801>>>>>
74801>>>>>Object Status_Panel is a cProcessStatusPanel
74803>>>>>    Set Size to 152 222
74804>>>>>    Set Border_Style to Border_Dialog
74805>>>>>    Set Icon to "Default.ico"
74806>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74807>>>>>
74807>>>>>    Property Boolean Cancel_Button_Visible_State True
74809>>>>>
74809>>>>>    Procedure Activate
74812>>>>>        Integer iSizeBefore
74812>>>>>        Get GuiSize to iSizeBefore
74813>>>>>        Forward Send Activate
74815>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74816>>>>>    End_Procedure
74817>>>>>
74817>>>>>    Procedure End_Construct_Object
74820>>>>>        Forward Send End_Construct_Object
74822>>>>>        Set Label of oTitleTxt      to ""
74823>>>>>        Set Label of oTableNameTxt  to ""
74824>>>>>        Set Label of oMessageTxt    to ""
74825>>>>>        Set Label of oActionTxt     to ""
74826>>>>>    End_Procedure
74827>>>>>
74827>>>>>    Object oTitleTxt is a TextBox
74829>>>>>        Set Location to 5 21
74830>>>>>        Set Size to 8 179
74831>>>>>        Set Auto_Size_State to False
74832>>>>>        Set Justification_Mode  to jMode_Center
74833>>>>>        Set Label to "This is the Title Text"
74834>>>>>    End_Object
74835>>>>>
74835>>>>>    Object oTableNameTxt is a TextBox
74837>>>>>        Set Size to 19 204
74838>>>>>        Set Location to 18 9
74839>>>>>        Set Auto_Size_State to False
74840>>>>>        Set Justification_Mode to JMode_Left
74841>>>>>        Set Label to "This is the TableName Text"
74842>>>>>    End_Object
74843>>>>>
74843>>>>>    Object oMessageTxt is a TextBox
74845>>>>>        Set Location to 39 9
74846>>>>>        Set Size to 19 204
74847>>>>>        Set Auto_Size_State to False
74848>>>>>        Set Justification_Mode to JMode_Left
74849>>>>>        Set Label to "This is the Message text"
74850>>>>>    End_Object
74851>>>>>
74851>>>>>    Object oActionTxt is a TextBox
74853>>>>>        Set Size to 16 204
74854>>>>>        Set Location to 60 9
74855>>>>>        Set Auto_Size_State to False
74856>>>>>        Set Justification_Mode to JMode_Left
74857>>>>>        Set Label to "This is the Action Text"
74858>>>>>    End_Object
74859>>>>>
74859>>>>>    Object oStopButton is a Button
74861>>>>>        Set Location to 123 82
74862>>>>>        Set Label to C_$Cancel
74863>>>>>
74863>>>>>        Procedure OnClick 
74866>>>>>            Integer iRetval
74866>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74867>>>>>            If (iRetval = MBR_Yes) Begin
74869>>>>>                Send Exit_Application
74870>>>>>            End
74870>>>>>>
74870>>>>>        End_Procedure
74871>>>>>
74871>>>>>    End_Object
74872>>>>>
74872>>>>>    Object oPercentage_tb is a TextBox
74874>>>>>        Set Location to 74 196
74875>>>>>        Set Size to 10 25
74876>>>>>//        Set Label to "% Done"
74876>>>>>    End_Object
74877>>>>>
74877>>>>>    Object oCopyRight is a TextBox
74879>>>>>        Set Location to 140 21
74880>>>>>        Set Size to 9 197
74881>>>>>        Set FontPointHeight to 8
74882>>>>>        Set Auto_Size_State to False
74883>>>>>        Set Justification_Mode  to jMode_Center
74884>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
74885>>>>>    End_Object
74886>>>>>
74886>>>>>    Object oProgressBar is a cProgressBar
74888>>>>>        Set Size to 10 179
74889>>>>>        Set Location to 83 22
74890>>>>>        Set pbVisible to True // default
74891>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74892>>>>>    End_Object
74893>>>>>
74893>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74896>>>>>        Set pbVisible of ghoProgressBar to bVisible
74897>>>>>    End_Procedure
74898>>>>>
74898>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74901>>>>>        Boolean bVisible
74901>>>>>        Get pbVisible of ghoProgressBar to bVisible
74902>>>>>        Function_Return (bVisible)
74903>>>>>    End_Function
74904>>>>>
74904>>>>>    Object oProgressBarOverall is a cProgressBar
74906>>>>>        Set Size to 10 179
74907>>>>>        Set Location to 107 22
74908>>>>>        Set pbVisible to True // default
74909>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74910>>>>>    End_Object
74911>>>>>
74911>>>>>    Object oOverallProgress_tb is a TextBox
74913>>>>>        Set Size to 10 65
74914>>>>>        Set Location to 95 24
74915>>>>>        Set Label to "Overall Progress"
74916>>>>>    End_Object
74917>>>>>
74917>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74920>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74921>>>>>    End_Procedure
74922>>>>>
74922>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74925>>>>>        Boolean bVisible
74925>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74926>>>>>        Function_Return (bVisible)
74927>>>>>    End_Function
74928>>>>>
74928>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74928>>>>>    // objects defined within this instance of the status panel.
74928>>>>>
74928>>>>>    // note: all of the messages that change text should be forwarded
74928>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74928>>>>>
74928>>>>>    Procedure Set Message_Text String sText
74931>>>>>        Set Label of oMessageTxt to sText
74932>>>>>        Forward Set Message_Text to sText
74934>>>>>    End_Procedure
74935>>>>>
74935>>>>>    Function Message_Text Returns String
74938>>>>>        Function_Return (Label(oMessageTxt))
74939>>>>>    End_Function
74940>>>>>
74940>>>>>    Procedure Set Action_Text String sText
74943>>>>>        Set Label of oActionTxt to sText
74944>>>>>        Forward Set Action_Text to sText
74946>>>>>    End_Procedure
74947>>>>>
74947>>>>>    Function Action_Text Returns String
74950>>>>>        Function_Return (Label(oActionTxt))
74951>>>>>    End_Function
74952>>>>>
74952>>>>>    Procedure Set Button_Text String sText
74955>>>>>        Set Label of oStopButton to sText
74956>>>>>        Forward Set Button_Text to sText
74958>>>>>    End_Procedure
74959>>>>>
74959>>>>>    Function Button_Text Returns String
74962>>>>>        Function_Return (Label(oStopButton))
74963>>>>>    End_Function
74964>>>>>
74964>>>>>    Procedure Set Title_Text String sText
74967>>>>>        Set Label of oTitleTxt to sText
74968>>>>>        Forward Set Title_Text to sText
74970>>>>>    End_Procedure
74971>>>>>
74971>>>>>    Function Title_Text Returns String
74974>>>>>        Function_Return (Label(oTitleTxt))
74975>>>>>    End_Function
74976>>>>>
74976>>>>>    Procedure Set TableName_Text String sText
74979>>>>>        Set Label of oTableNameTxt to sText
74980>>>>>    End_Procedure
74981>>>>>
74981>>>>>    Function TableName_Text Returns String
74984>>>>>        Function_Return (Label(oTableNameTxt))
74985>>>>>    End_Function
74986>>>>>
74986>>>>>    Procedure Set License_Text String sText
74989>>>>>//        Set Label of oLicense_txt to sText
74989>>>>>    End_Procedure
74990>>>>>
74990>>>>>    // gets called when status panel is activated passing whether a button
74990>>>>>    // should appear
74990>>>>>    Procedure EnableCancelButton Boolean bEnable
74993>>>>>        Boolean bVisible
74993>>>>>        Get Cancel_Button_Visible_State to bVisible
74994>>>>>        If (bEnable = False) Begin
74996>>>>>            Set Visible_State of oStopButton to bVisible
74997>>>>>        End
74997>>>>>>
74997>>>>>        Set Enabled_State of oStopButton to bEnable
74998>>>>>    End_Procedure
74999>>>>>
74999>>>>>    Procedure Reset_StatusPanel
75002>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
75003>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
75004>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
75005>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
75006>>>>>    End_Procedure
75007>>>>>
75007>>>>>//    Object oProgressBar is a cProgressBar
75007>>>>>//        Move Self to ghoProgressBar
75007>>>>>//        Set Location to 1 25
75007>>>>>//        Set Size to 9 173
75007>>>>>//        Set piMinimum        to 0
75007>>>>>//        Set piMaximum        to 2000
75007>>>>>//        Set piAdvanceBy      to 100
75007>>>>>//        Set pbSmooth to True
75007>>>>>//
75007>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
75007>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
75007>>>>>//        // color will show correctly.
75007>>>>>//        Procedure Page Integer iPageObject
75007>>>>>//            Handle hWin
75007>>>>>//            Forward Send Page iPageObject
75007>>>>>//            If (ghoSkinFramework <> 0) Begin
75007>>>>>//                Get Window_Handle to hWin
75007>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
75007>>>>>//            End
75007>>>>>//        End_Procedure
75007>>>>>//    End_Object
75007>>>>>
75007>>>>>End_Object
75008>>>>>
75008>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
75008>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
75008>>>>>//
75008>>>>>Use VdfBase.pkg
75008>>>>>Use cApplication.pkg
75008>>>>>Use seq_chnl.pkg
75008>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fh.pkg)
75008>>>>>>>// This code is part of VDF GUIdance
75008>>>>>>>// Visit us @ http://www.vdf-guidance.com
75008>>>>>>>// e-Mail us @ info@vdf-guidance.com
75008>>>>>>>// VDF GUIdance is a mutual project of
75008>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75008>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75008>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75008>>>>>>>//
75008>>>>>>>//
75008>>>>>>>// *** Windows 32bit file handling wrapper class ***
75008>>>>>>>//
75008>>>>>>>
75008>>>>>>>
75008>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
75008>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\cvFileDialogs.pkg)
75008>>>>>>>>>//***************************************************************************
75008>>>>>>>>>//*
75008>>>>>>>>>//* Class:        cvSaveAsDialog
75008>>>>>>>>>//* Package Name: cvFileDialogs.pkg
75008>>>>>>>>>//*
75008>>>>>>>>>//***************************************************************************
75008>>>>>>>>>
75008>>>>>>>>>Use File_dlg.pkg
75008>>>>>>>>>
75008>>>>>>>>>// *WvA: 13-01-1999 Created
75008>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
75008>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
75008>>>>>>>>>// file_name.
75008>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
75009>>>>>>>>>
75009>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
75011>>>>>>>>>        Forward Send Construct_Object iImage_Id
75013>>>>>>>>>        Set HideReadOnly_State to True
75014>>>>>>>>>    End_Procedure
75015>>>>>>>>>
75015>>>>>>>>>    Function SelectedFileName Returns String
75017>>>>>>>>>        String sFileName
75017>>>>>>>>>        Move "" to sFileName
75018>>>>>>>>>        If (Show_Dialog(Self)) Begin
75020>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
75021>>>>>>>>>        End
75021>>>>>>>>>>
75021>>>>>>>>>        Function_Return sFileName
75022>>>>>>>>>    End_Function
75023>>>>>>>>>End_Class
75024>>>>>>>>>
75024>>>>>>>>>// *WvA: 13-01-1999 Created
75024>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
75024>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
75024>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
75024>>>>>>>>>//                   file-open dialog
75024>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
75026>>>>>>>>>    String sSelectedFile
75026>>>>>>>>>    Integer hoOpenFileDialog
75026>>>>>>>>>
75026>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
75028>>>>>>>>>
75028>>>>>>>>>        Set Dialog_Caption    to sCaptionText
75029>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
75030>>>>>>>>>        Set Initial_Folder    to sInitialFolder
75031>>>>>>>>>
75031>>>>>>>>>        Move Self       to hoOpenFileDialog
75032>>>>>>>>>    End_Object
75033>>>>>>>>>
75033>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
75034>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
75035>>>>>>>>>    Function_Return sSelectedFile
75036>>>>>>>>>End_Function
75037>>>>>>>>>
75037>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
75038>>>>>>>>>
75038>>>>>>>>>    Procedure Construct_Object
75040>>>>>>>>>        Forward Send Construct_Object
75042>>>>>>>>>        Set HideReadOnly_State to True
75043>>>>>>>>>    End_Procedure
75044>>>>>>>>>
75044>>>>>>>>>    Function SelectedFileName Returns String
75046>>>>>>>>>        String sFileName
75046>>>>>>>>>        Move "" to sFileName
75047>>>>>>>>>        If (Show_Dialog(Self)) Begin
75049>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
75050>>>>>>>>>        End
75050>>>>>>>>>>
75050>>>>>>>>>        Function_Return sFileName
75051>>>>>>>>>    End_Function
75052>>>>>>>>>
75052>>>>>>>>>End_Class
75053>>>>>>>>>
75053>>>>>>>>>// Added optional default filename as suggested by Nils
75053>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
75055>>>>>>>>>    String sSelectedFile
75055>>>>>>>>>    Integer hoDialog
75055>>>>>>>>>
75055>>>>>>>>>    Move "" to sSelectedFile
75056>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
75057>>>>>>>>>    If (hoDialog) Begin
75059>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
75059>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
75060>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
75061>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
75062>>>>>>>>>        If (Num_Arguments = 4) Begin
75064>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
75065>>>>>>>>>        End
75065>>>>>>>>>>
75065>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
75066>>>>>>>>>        Send Destroy of hoDialog
75067>>>>>>>>>    End
75067>>>>>>>>>>
75067>>>>>>>>>    Function_Return sSelectedFile
75068>>>>>>>>>End_Function
75069>>>>>>>Use Seq_chnl.pkg
75069>>>>>>>
75069>>>>>>>Use windows.pkg
75069>>>>>>>Use Dll.pkg
75069>>>>>>>
75069>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.pkg)
75069>>>>>>>>>// This code is part of VDF GUIdance
75069>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
75069>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
75069>>>>>>>>>// VDF GUIdance is a mutual project of
75069>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75069>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75069>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75069>>>>>>>>>//
75069>>>>>>>>>//
75069>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
75069>>>>>>>>>// Unicode variant
75069>>>>>>>>>
75069>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.h)
75069>>>>>>>>>>>//TH-Header
75069>>>>>>>>>>>//*****************************************************************************************
75069>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
75069>>>>>>>>>>>// All rights reserved.
75069>>>>>>>>>>>//
75069>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
75069>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
75069>>>>>>>>>>>// $Authors     : Wil van Antwerpen
75069>>>>>>>>>>>// $Created     : 19.02.2004  19:25
75069>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
75069>>>>>>>>>>>//
75069>>>>>>>>>>>// Contents:
75069>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
75069>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
75069>>>>>>>>>>>//*****************************************************************************************
75069>>>>>>>>>>>//TH-RevisionStart
75069>>>>>>>>>>>//TH-RevisionEnd
75069>>>>>>>>>>>
75069>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
75069>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
75069>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
75069>>>>>>>>>>>
75069>>>>>>>>>>>
75069>>>>>>>>>>>Define vMax_Path     For |CI260
75069>>>>>>>>>>>Define vMinChar      For |CI$80
75069>>>>>>>>>>>Define vMaxChar      For |CI$7F
75069>>>>>>>>>>>Define vMinShort     For |CI$8000
75069>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
75069>>>>>>>>>>>Define vMinLong      For |CI$80000000
75069>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
75069>>>>>>>>>>>Define vMaxByte      For |CI$FF
75069>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
75069>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
75069>>>>>>>>>>>
75069>>>>>>>>>>>
75069>>>>>>>>>>>
75069>>>>>>>>>>>// For FindFirstFile
75069>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
75069>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
75069>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
75069>>>>>>>>>>>
75069>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
75069>>>>>>>>>>>// the API-call ShellExecute is used.
75069>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
75069>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
75069>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
75069>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
75069>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
75069>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
75069>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
75069>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
75069>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
75069>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
75069>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
75069>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
75069>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
75069>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
75069>>>>>>>>>>>
75069>>>>>>>>>>>
75069>>>>>>>>>>>// C-Structure
75069>>>>>>>>>>>//typedef struct _browseinfo {
75069>>>>>>>>>>>//    HWND hwndOwner;
75069>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
75069>>>>>>>>>>>//    LPSTR pszDisplayName;
75069>>>>>>>>>>>//    LPCSTR lpszTitle;
75069>>>>>>>>>>>//    UINT ulFlags;
75069>>>>>>>>>>>//    BFFCALLBACK lpfn;
75069>>>>>>>>>>>//    LPARAM lParam;
75069>>>>>>>>>>>//    int iImage;
75069>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
75069>>>>>>>>>>>
75069>>>>>>>>>>>//declare C structure struct_browseinfo
75069>>>>>>>>>>>//as documented in MSDN under Windows Shell API
75069>>>>>>>>>>>Struct tvBrowseInfo
75069>>>>>>>>>>>  Handle    hWndOwner
75069>>>>>>>>>>>  Pointer   pIDLRoot
75069>>>>>>>>>>>  Pointer   pszDisplayName
75069>>>>>>>>>>>  Pointer   lpszTitle
75069>>>>>>>>>>>  DWord     ulFlags
75069>>>>>>>>>>>  Pointer   lpfnCallback
75069>>>>>>>>>>>  LongPtr   lParam
75069>>>>>>>>>>>  DWord     iImage
75069>>>>>>>>>>>End_Struct // tvBrowseInfo
75069>>>>>>>>>>>
75069>>>>>>>>>>>// Browsing for directory.
75069>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
75069>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
75069>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
75069>>>>>>>>>>>                                            // The callback function can set the status text by
75069>>>>>>>>>>>                                            // sending messages to the dialog box.
75069>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
75069>>>>>>>>>>>
75069>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
75069>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
75069>>>>>>>>>>>
75069>>>>>>>>>>>// message from browser
75069>>>>>>>>>>>//Define BFFM_INITIALIZED        1
75069>>>>>>>>>>>//Define BFFM_SELCHANGED         2
75069>>>>>>>>>>>
75069>>>>>>>>>>>// messages to browser
75069>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
75069>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
75069>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
75069>>>>>>>>>>>
75069>>>>>>>>>>>
75069>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75070>>>>>>>>>>>
75070>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75071>>>>>>>>>>>
75071>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75072>>>>>>>>>>>
75072>>>>>>>>>>>
75072>>>>>>>>>>>
75072>>>>>>>>>>>
75072>>>>>>>>>>>Struct tvSecurity_attributes
75072>>>>>>>>>>>  DWord   nLength
75072>>>>>>>>>>>  Pointer lpDescriptor
75072>>>>>>>>>>>  Integer bInheritHandle
75072>>>>>>>>>>>End_Struct // tvSecurity_attributes
75072>>>>>>>>>>>
75072>>>>>>>>>>>//nLength:
75072>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75072>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75072>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75072>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75072>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75072>>>>>>>>>>>//
75072>>>>>>>>>>>//lpSecurityDescriptor:
75072>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75072>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75072>>>>>>>>>>>// descriptor of the calling process.
75072>>>>>>>>>>>//
75072>>>>>>>>>>>//bInheritHandle:
75072>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75072>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75072>>>>>>>>>>>
75072>>>>>>>>>>>
75072>>>>>>>>>>>// BOOL CreateDirectory(
75072>>>>>>>>>>>//    LPCTSTR lpPathName,
75072>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75072>>>>>>>>>>>//   );
75072>>>>>>>>>>>//
75072>>>>>>>>>>>// lpPathName
75072>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75072>>>>>>>>>>>//  to be created.
75072>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75072>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75072>>>>>>>>>>>// lpSecurityAttributes
75072>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75072>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75072>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75072>>>>>>>>>>>// Returns:
75072>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75072>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75072>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75073>>>>>>>>>>>
75073>>>>>>>>>>>
75073>>>>>>>>>>>// lpPathName
75073>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75073>>>>>>>>>>>//  to be removed.
75073>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75073>>>>>>>>>>>// Returns:
75073>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75073>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75073>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75074>>>>>>>>>>>
75074>>>>>>>>>>>
75074>>>>>>>>>>>
75074>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75074>>>>>>>>>>>// executable file or a document file.
75074>>>>>>>>>>>//
75074>>>>>>>>>>>// Operation can be one of the following:
75074>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75074>>>>>>>>>>>//            The file can be an executable file or a document file.
75074>>>>>>>>>>>//            The file can be a folder to open.
75074>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75074>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75074>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75074>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75074>>>>>>>>>>>//
75074>>>>>>>>>>>// Return Values:
75074>>>>>>>>>>>//
75074>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75074>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75074>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75074>>>>>>>>>>>//
75074>>>>>>>>>>>// The following table lists these error values:
75074>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75074>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75074>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75074>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75074>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75074>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75074>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75074>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75074>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75074>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75074>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75074>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75074>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75074>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75074>>>>>>>>>>>
75074>>>>>>>>>>>
75074>>>>>>>>>>>
75074>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75074>>>>>>>>>>>//
75074>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75074>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75075>>>>>>>>>>>
75075>>>>>>>>>>>
75075>>>>>>>>>>>
75075>>>>>>>>>>>
75075>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75075>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75075>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75075>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75075>>>>>>>>>>>
75075>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75075>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75075>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75075>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75075>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75075>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75075>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75075>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75075>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75075>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75075>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75075>>>>>>>>>>>
75075>>>>>>>>>>>Struct tvShFileOpStruct
75075>>>>>>>>>>>  Handle   hWnd
75075>>>>>>>>>>>  UInteger wFunc
75075>>>>>>>>>>>  Pointer  pFrom
75075>>>>>>>>>>>  Pointer  pTo
75075>>>>>>>>>>>  Short    fFlags
75075>>>>>>>>>>>  Integer  fAnyOperationsAborted
75075>>>>>>>>>>>  Pointer  hNameMappings
75075>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75075>>>>>>>>>>>End_Struct // tvShFileOpStruct
75075>>>>>>>>>>>
75075>>>>>>>>>>>// hwnd
75075>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75075>>>>>>>>>>>
75075>>>>>>>>>>>// wFunc
75075>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75075>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75075>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75075>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75075>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75075>>>>>>>>>>>
75075>>>>>>>>>>>// pFrom
75075>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75075>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75075>>>>>>>>>>>
75075>>>>>>>>>>>// pTo
75075>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75075>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75075>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75075>>>>>>>>>>>//   double null-terminated.
75075>>>>>>>>>>>
75075>>>>>>>>>>>// fAnyOperationsAborted
75075>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75075>>>>>>>>>>>//   were completed or FALSE otherwise.
75075>>>>>>>>>>>
75075>>>>>>>>>>>
75075>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75075>>>>>>>>>>>// This can be a file or a folder.
75075>>>>>>>>>>>// With thanks to Andrew S Kaplan
75075>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75076>>>>>>>>>>>
75076>>>>>>>>>>>
75076>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75076>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75077>>>>>>>>>>>
75077>>>>>>>>>>>
75077>>>>>>>>>>>
75077>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75077>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75077>>>>>>>>>>>//   Pointer lpPathName ;
75077>>>>>>>>>>>//   Pointer lpPrefixString ;
75077>>>>>>>>>>>//   Integer uUnique ;
75077>>>>>>>>>>>//   Pointer lpTempFileName ;
75077>>>>>>>>>>>//   Returns Integer
75077>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75077>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75078>>>>>>>>>>>
75078>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75079>>>>>>>>>>>
75079>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75080>>>>>>>>>>>
75080>>>>>>>>>>>// from:
75080>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75080>>>>>>>>>>>//
75080>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75080>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75080>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75080>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75080>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75080>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75080>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75080>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75080>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75080>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75080>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75080>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75080>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75080>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75080>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75080>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75080>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75080>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75080>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75080>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75080>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75080>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75080>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75080>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75080>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75080>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75080>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75080>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75080>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75080>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75080>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75080>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75080>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75080>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75080>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75080>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75080>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75080>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75080>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75080>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75080>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75080>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75080>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75080>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75080>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75080>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75080>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75080>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75080>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75080>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75080>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75080>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75080>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75080>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75080>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75080>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75080>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75080>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75080>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75080>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75080>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75080>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75080>>>>>>>>>>>
75080>>>>>>>>>>>
75080>>>>>>>>>>>//HRESULT SHGetFolderPath(
75080>>>>>>>>>>>//    HWND hwndOwner,
75080>>>>>>>>>>>//    int nFolder,
75080>>>>>>>>>>>//    HANDLE hToken,
75080>>>>>>>>>>>//    DWORD dwFlags,
75080>>>>>>>>>>>//    LPTSTR pszPath
75080>>>>>>>>>>>//);
75080>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75080>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75080>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75080>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75080>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75080>>>>>>>>>>>//
75080>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75081>>>>>>>>>>>
75081>>>>>>>>>>>
75081>>>>>>>>>>>
75081>>>>>>>>>>>Struct tvWin32FindData
75081>>>>>>>>>>> Dword            dwFileAttributes
75081>>>>>>>>>>> Dword            ftCreationLowDateTime
75081>>>>>>>>>>> Dword            ftCreationHighDateTime
75081>>>>>>>>>>> dword            ftLastAccessLowDateTime
75081>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75081>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75081>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75081>>>>>>>>>>> Dword            nFileSizeHigh
75081>>>>>>>>>>> Dword            nFileSizeLow
75081>>>>>>>>>>> Dword            dwReserved0
75081>>>>>>>>>>> Dword            dwReserved1
75081>>>>>>>>>>> Short[vMax_Path] cFileName
75081>>>>>>>>>>> Short[14]        cAlternateFileName
75081>>>>>>>>>>>End_Struct
75081>>>>>>>>>>>
75081>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75081>>>>>>>>>>>// lpFileName      : address of name of file to search for
75081>>>>>>>>>>>// lpFindFileData  : address of returned information
75081>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75082>>>>>>>>>>>
75082>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75082>>>>>>>>>>>// hFindFile       : handle of search
75082>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75082>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75083>>>>>>>>>>>
75083>>>>>>>>>>>
75083>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75083>>>>>>>>>>>//  hFindFile      : file search handle
75083>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75084>>>>>>>>>>>
75084>>>>>>>>>>>
75084>>>>>>>>>>>
75084>>>>>>>>>>>Struct tvFileTime
75084>>>>>>>>>>>  DWord dwLowDateTime
75084>>>>>>>>>>>  DWord dwHighDateTime
75084>>>>>>>>>>>End_Struct
75084>>>>>>>>>>>
75084>>>>>>>>>>>
75084>>>>>>>>>>>Struct tvSystemTime
75084>>>>>>>>>>>  UShort wYear
75084>>>>>>>>>>>  UShort wMonth
75084>>>>>>>>>>>  UShort wDayOfWeek
75084>>>>>>>>>>>  UShort wDay
75084>>>>>>>>>>>  UShort wHour
75084>>>>>>>>>>>  UShort wMinute
75084>>>>>>>>>>>  UShort wSecond
75084>>>>>>>>>>>  UShort wMilliSeconds
75084>>>>>>>>>>>End_Struct
75084>>>>>>>>>>>
75084>>>>>>>>>>>
75084>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75084>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75084>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75084>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75085>>>>>>>>>>>
75085>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75085>>>>>>>>>>>// This function formats the time in a picture-string passed
75085>>>>>>>>>>>//
75085>>>>>>>>>>>// Picture      Meaning
75085>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75085>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75085>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75085>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75085>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75085>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75085>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75085>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75085>>>>>>>>>>>//    t         One character time marker string, such as A or P
75085>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75085>>>>>>>>>>>//
75085>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75085>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75085>>>>>>>>>>>
75085>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75086>>>>>>>>>>>
75086>>>>>>>>>>>
75086>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75086>>>>>>>>>>>// This function formats the date in a picture-string passed
75086>>>>>>>>>>>//
75086>>>>>>>>>>>// Picture      Meaning
75086>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75086>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75086>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75086>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75086>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75086>>>>>>>>>>>//              value associated with the specified locale.
75086>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75086>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75086>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75086>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75086>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75086>>>>>>>>>>>//              associated with the specified locale.
75086>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75086>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75086>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75086>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75086>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75086>>>>>>>>>>>//              does not have an associated era or period string.
75086>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75086>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75086>>>>>>>>>>>
75086>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75087>>>>>>>>>>>
75087>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75087>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75087>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75087>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75087>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75087>>>>>>>>>>>
75087>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75087>>>>>>>>>>>//
75087>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75087>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75087>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75087>>>>>>>>>>>
75087>>>>>>>>>>>
75087>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75088>>>>>>>>>>>
75088>>>>>>>>>>>
75088>>>>>>>>>>>// **WvA: 20-02-2004
75088>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75088>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75088>>>>>>>>>>>// incorrectly into an unsigned integer.
75088>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75088>>>>>>>>>>>// It does smell a bit fishy though
75088>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75088>>>>>>>>>>>
75088>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75088>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75088>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75088>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75088>>>>>>>>>>>
75088>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75088>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75088>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75088>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75088>>>>>>>>>>>
75088>>>>>>>>>>>
75088>>>>>>>>>>> // Courtesy Of Steve Walter,
75088>>>>>>>>>>> // USA Software, Inc
75088>>>>>>>>>>> // Format a disk
75088>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75088>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75089>>>>>>>>>>>
75089>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75089>>>>>>>>>>>
75089>>>>>>>>>>>// SHCreateDirectoryEx
75089>>>>>>>>>>>
75089>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75089>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75089>>>>>>>>>>>//
75089>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75089>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75089>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75089>>>>>>>>>>>//
75089>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75089>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75089>>>>>>>>>>>//        ERROR_CANCELLED.
75089>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75089>>>>>>>>>>>
75089>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75089>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75089>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75089>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75089>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75089>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75089>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75089>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75089>>>>>>>>>>>
75089>>>>>>>>>>>//        int SHCreateDirectoryEx(
75089>>>>>>>>>>>//            HWND hwnd,
75089>>>>>>>>>>>//            LPCTSTR pszPath,
75089>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75089>>>>>>>>>>>//        );
75089>>>>>>>>>>>
75089>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75090>>>>>>>>>>>
75090>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75091>>>>>>>>>
75091>>>>>>>>>
75091>>>>>>>>>
75091>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75091>>>>>>>>>// This also works with UNC path encoding and wildcards
75091>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75093>>>>>>>>>    Boolean bFolderExists
75093>>>>>>>>>    Boolean bStop
75093>>>>>>>>>    String  sFolder sTmp
75093>>>>>>>>>    Integer iCh
75093>>>>>>>>>
75093>>>>>>>>>    If (sFolderName = "") Begin
75095>>>>>>>>>        Function_Return False
75096>>>>>>>>>    End
75096>>>>>>>>>>
75096>>>>>>>>>
75096>>>>>>>>>    Move True  to bFolderExists
75097>>>>>>>>>    Move False to bStop
75098>>>>>>>>>    Move "dir:" to sFolder
75099>>>>>>>>>    Append sFolder sFolderName
75100>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75101>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75103>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75104>>>>>>>>>>
75104>>>>>>>>>        Function_Return False
75105>>>>>>>>>    End
75105>>>>>>>>>>
75105>>>>>>>>>    Direct_Input channel iCh sFolder
75107>>>>>>>>>    Repeat
75107>>>>>>>>>>
75107>>>>>>>>>        Readln channel iCh sTmp
75109>>>>>>>>>        Move (SeqEof) to bStop
75110>>>>>>>>>        If (Trim(sTmp)="") Begin
75112>>>>>>>>>            Move False to bFolderExists
75113>>>>>>>>>        End
75113>>>>>>>>>>
75113>>>>>>>>>        Else Begin
75114>>>>>>>>>            Move True to bFolderExists
75115>>>>>>>>>            Move True to bStop
75116>>>>>>>>>        End
75116>>>>>>>>>>
75116>>>>>>>>>    Until (bStop)
75118>>>>>>>>>    Close_Input channel iCh
75120>>>>>>>>>    Send Seq_Release_Channel iCh
75121>>>>>>>>>    Function_Return bFolderExists
75122>>>>>>>>>End_Function
75123>>>>>>>>>
75123>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75123>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75125>>>>>>>>>    String  sPath
75125>>>>>>>>>    WString sFolder sTitle
75125>>>>>>>>>    Pointer lpItemIdList
75125>>>>>>>>>    Integer iFolderSelected iRetval
75125>>>>>>>>>    tvBrowseInfo BrowseInfo
75125>>>>>>>>>    tvBrowseInfo BrowseInfo
75125>>>>>>>>>
75125>>>>>>>>>    Move "" to sPath
75126>>>>>>>>>    If (sDialogTitle<>"") Begin
75128>>>>>>>>>        Move sDialogTitle to sTitle
75129>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75129>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75129>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75129>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75129>>>>>>>>>        // selected it will always be valid.
75129>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75130>>>>>>>>>    End
75130>>>>>>>>>>
75130>>>>>>>>>
75130>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75131>>>>>>>>>
75131>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75131>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75131>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75132>>>>>>>>>
75132>>>>>>>>>    // null 128 chars into var (make space)
75132>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75133>>>>>>>>>
75133>>>>>>>>>    // select folder
75133>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75134>>>>>>>>>    // get selected folder name
75134>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75135>>>>>>>>>
75135>>>>>>>>>    // release memory resources that are used by the ItemIdList
75135>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75136>>>>>>>>>
75136>>>>>>>>>    If (iFolderSelected<>0) Begin
75138>>>>>>>>>        Move (CString(sFolder)) to sPath
75139>>>>>>>>>    End
75139>>>>>>>>>>
75139>>>>>>>>>    Function_Return  sPath
75140>>>>>>>>>End_Function
75141>>>>>>>>>
75141>>>>>>>>>// returns 0 if the folder is created.
75141>>>>>>>>>//         1 if the API-call returned an error.
75141>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75143>>>>>>>>>    Integer  iRetval bFolderCreated
75143>>>>>>>>>    WString  sFolder
75143>>>>>>>>>    tvSecurity_attributes SA
75143>>>>>>>>>    tvSecurity_attributes SA
75143>>>>>>>>>
75143>>>>>>>>>    Move False to bFolderCreated
75144>>>>>>>>>    If (sNewFolder <> "") Begin
75146>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75147>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75148>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75149>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75150>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75151>>>>>>>>>    End
75151>>>>>>>>>>
75151>>>>>>>>>
75151>>>>>>>>>    If (bFolderCreated=false) Begin
75153>>>>>>>>>        Move 1 to iRetVal
75154>>>>>>>>>    End
75154>>>>>>>>>>
75154>>>>>>>>>    Function_Return iRetVal
75155>>>>>>>>>End_Function
75156>>>>>>>>>
75156>>>>>>>>>// **WvA: 03-02-2002 Function created.
75156>>>>>>>>>// With this function one can remove a directory.
75156>>>>>>>>>// returns 0 if the folder is removed.
75156>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75156>>>>>>>>>//         2 if the folder did not exist
75156>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75156>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75158>>>>>>>>>    Boolean bRemoved
75158>>>>>>>>>    WString sPath
75158>>>>>>>>>    Integer iRetval
75158>>>>>>>>>
75158>>>>>>>>>    Move 0     to iRetVal
75159>>>>>>>>>    Move False to bRemoved
75160>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75161>>>>>>>>>    If (sFolder="") Begin
75163>>>>>>>>>        Move 3 to iRetVal
75164>>>>>>>>>    End
75164>>>>>>>>>>
75164>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75166>>>>>>>>>        Move 2 to iRetVal
75167>>>>>>>>>    End
75167>>>>>>>>>>
75167>>>>>>>>>    If (iRetVal=0) Begin
75169>>>>>>>>>        // null MAX_PATH chars into var (make space)
75169>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75170>>>>>>>>>        //
75170>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75171>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75172>>>>>>>>>    End
75172>>>>>>>>>>
75172>>>>>>>>>
75172>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75174>>>>>>>>>        Move 1 to iRetVal
75175>>>>>>>>>    End
75175>>>>>>>>>>
75175>>>>>>>>>    Function_Return iRetVal
75176>>>>>>>>>End_Function
75177>>>>>>>>>
75177>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75177>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75177>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75177>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75179>>>>>>>>>    Handle  hInstance hWnd
75179>>>>>>>>>    // remove any leading/trailing spaces in the string
75179>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75180>>>>>>>>>    Move (Trim(sPath))     to sPath
75181>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75181>>>>>>>>>    Append sOperation   (Character(0))
75182>>>>>>>>>    Append sDocument    (Character(0))
75183>>>>>>>>>    Append sParameters  (Character(0))
75184>>>>>>>>>    Append sPath        (Character(0))
75185>>>>>>>>>
75185>>>>>>>>>    Get Window_Handle to hWnd
75186>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75187>>>>>>>>>    If (hInstance <= 32) Begin
75189>>>>>>>>>        Send vDDE_Error_Handler hInstance
75190>>>>>>>>>    End
75190>>>>>>>>>>
75190>>>>>>>>>End_Procedure
75191>>>>>>>>>
75191>>>>>>>>>Class cShellFileOperations is a Array
75192>>>>>>>>>
75192>>>>>>>>>    Procedure Construct_Object
75194>>>>>>>>>        Forward Send Construct_Object
75196>>>>>>>>>        Property Integer piDeleteFlags        0
75197>>>>>>>>>        Property Integer piCopyFlags          0
75198>>>>>>>>>        Property Integer piMoveFlags          0
75199>>>>>>>>>        Property Integer piRenameFlags        0
75200>>>>>>>>>
75200>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75201>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75202>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75203>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75204>>>>>>>>>    End_Procedure
75205>>>>>>>>>
75205>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75205>>>>>>>>>    // files supplied.
75205>>>>>>>>>    //
75205>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75207>>>>>>>>>        Integer  iRetVal
75207>>>>>>>>>        Integer  iUserAbort
75207>>>>>>>>>        WString  wsSource wsDestination
75207>>>>>>>>>        tvShFileOpStruct FOS
75207>>>>>>>>>        tvShFileOpStruct FOS
75207>>>>>>>>>
75207>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75208>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75209>>>>>>>>>
75209>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75211>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75212>>>>>>>>>        End
75212>>>>>>>>>>
75212>>>>>>>>>
75212>>>>>>>>>        Move eOperation            to FOS.wFunc
75213>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75214>>>>>>>>>        Move iFlags                to FOS.fFlags
75215>>>>>>>>>
75215>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75216>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75217>>>>>>>>>        If (iUserAbort <> 0) Begin
75219>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75220>>>>>>>>>        End
75220>>>>>>>>>>
75220>>>>>>>>>        Function_Return (iRetVal)
75221>>>>>>>>>    End_Function
75222>>>>>>>>>
75222>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75224>>>>>>>>>        Integer  iRetVal
75224>>>>>>>>>        Integer  iFlags
75224>>>>>>>>>
75224>>>>>>>>>        Get piDeleteFlags to iFlags
75225>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75226>>>>>>>>>        Function_Return iRetVal
75227>>>>>>>>>    End_Function
75228>>>>>>>>>
75228>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75230>>>>>>>>>        Integer  iRetVal
75230>>>>>>>>>        Integer  iFlags
75230>>>>>>>>>
75230>>>>>>>>>        Get piCopyFlags to iFlags
75231>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75232>>>>>>>>>        Function_Return iRetVal
75233>>>>>>>>>    End_Function
75234>>>>>>>>>
75234>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75236>>>>>>>>>        Integer  iRetVal
75236>>>>>>>>>        Integer  iFlags
75236>>>>>>>>>
75236>>>>>>>>>        Get piMoveFlags to iFlags
75237>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75238>>>>>>>>>        Function_Return iRetVal
75239>>>>>>>>>    End_Function
75240>>>>>>>>>
75240>>>>>>>>>    // Rename a file or folder
75240>>>>>>>>>    // Returns a nonzero value if the operation failed.
75240>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75242>>>>>>>>>        Integer  iRetVal
75242>>>>>>>>>        Integer  iFlags
75242>>>>>>>>>
75242>>>>>>>>>        Get piRenameFlags to iFlags
75243>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75244>>>>>>>>>        Function_Return iRetVal
75245>>>>>>>>>    End_Function
75246>>>>>>>>>
75246>>>>>>>>>
75246>>>>>>>>>    //Example:
75246>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75246>>>>>>>>>    //                                          mode.
75246>>>>>>>>>
75246>>>>>>>>>End_Class
75247>>>>>>>>>
75247>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75249>>>>>>>>>End_Object
75250>>>>>>>>>
75250>>>>>>>>>// Restore to the old way of working with the shell file operations.
75250>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75250>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75250>>>>>>>>>Procedure vWin32fhCompatibilityMode
75252>>>>>>>>>    Integer hoSFO
75252>>>>>>>>>    Integer iFlags
75252>>>>>>>>>
75252>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75253>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75254>>>>>>>>>
75254>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75255>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75256>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75257>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75258>>>>>>>>>End_Procedure
75259>>>>>>>>>
75259>>>>>>>>>// Delete a file or folder
75259>>>>>>>>>// Returns a nonzero value if the operation failed.
75259>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75261>>>>>>>>>    Integer  iRetVal
75261>>>>>>>>>
75261>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75262>>>>>>>>>    Function_Return iRetVal
75263>>>>>>>>>End_Function
75264>>>>>>>>>
75264>>>>>>>>>// Copy a file or folder
75264>>>>>>>>>// Returns a nonzero value if the operation failed.
75264>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75266>>>>>>>>>    Integer  iRetVal
75266>>>>>>>>>
75266>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75267>>>>>>>>>    Function_Return iRetVal
75268>>>>>>>>>End_Function
75269>>>>>>>>>
75269>>>>>>>>>// Move a file or folder
75269>>>>>>>>>// Returns a nonzero value if the operation failed.
75269>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75271>>>>>>>>>    Integer  iRetVal
75271>>>>>>>>>
75271>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75272>>>>>>>>>    Function_Return iRetVal
75273>>>>>>>>>End_Function
75274>>>>>>>>>
75274>>>>>>>>>// Rename a file or folder
75274>>>>>>>>>// Returns a nonzero value if the operation failed.
75274>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75276>>>>>>>>>    Integer  iRetVal
75276>>>>>>>>>
75276>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75277>>>>>>>>>    Function_Return iRetVal
75278>>>>>>>>>End_Function
75279>>>>>>>>>
75279>>>>>>>>>Function vGetWindowsDirectory Returns String
75281>>>>>>>>>    WString wDirectory
75281>>>>>>>>>    Integer iRetVal
75281>>>>>>>>>
75281>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75282>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75283>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75285>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75286>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75287>>>>>>>>>    End
75287>>>>>>>>>>
75287>>>>>>>>>    Function_Return (CString(wDirectory))
75288>>>>>>>>>End_Function
75289>>>>>>>>>
75289>>>>>>>>>Function vGetTempPath Returns String
75291>>>>>>>>>    Integer iRetVal
75291>>>>>>>>>    WString wTempPath
75291>>>>>>>>>
75291>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75292>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75293>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75295>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75296>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75297>>>>>>>>>    End
75297>>>>>>>>>>
75297>>>>>>>>>    Function_Return (CString(wTempPath))
75298>>>>>>>>>End_Function
75299>>>>>>>>>
75299>>>>>>>>>// Courtesy of Marco Kuipers
75299>>>>>>>>>Function vMakeTempFile Returns String
75301>>>>>>>>>    Integer iRetval
75301>>>>>>>>>    String  sTempPath
75301>>>>>>>>>    String  sTempFileName
75301>>>>>>>>>    String  sPrefixString
75301>>>>>>>>>    WString wsTempFileName
75301>>>>>>>>>
75301>>>>>>>>>    Get vGetTempPath to sTempPath
75302>>>>>>>>>    If (sTempPath = "") Begin
75304>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75305>>>>>>>>>        If (sTempPath<>"") Begin
75307>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75308>>>>>>>>>        End
75308>>>>>>>>>>
75308>>>>>>>>>    End
75308>>>>>>>>>>
75308>>>>>>>>>
75308>>>>>>>>>    If (sTempPath = "") Begin
75310>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75310>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75310>>>>>>>>>        Get_Current_Directory to sTempPath
75311>>>>>>>>>    End
75311>>>>>>>>>>
75311>>>>>>>>>
75311>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75312>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75314>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75315>>>>>>>>>>
75315>>>>>>>>>    End
75315>>>>>>>>>>
75315>>>>>>>>>
75315>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75316>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75317>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75318>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75320>>>>>>>>>    //Get ShowLastError to iRetval
75320>>>>>>>>>        Move "" to sTempFileName
75321>>>>>>>>>    End
75321>>>>>>>>>>
75321>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75322>>>>>>>>>    Function_Return sTempFileName
75323>>>>>>>>>End_Function
75324>>>>>>>>>
75324>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75324>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75324>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75324>>>>>>>>>// does not take care of that.
75324>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75326>>>>>>>>>    Integer iRetVal
75326>>>>>>>>>    String  sTempFileName
75326>>>>>>>>>    WString wTempFileName
75326>>>>>>>>>
75326>>>>>>>>>    Move (sPath+Character(0))   to sPath
75327>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75328>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75329>>>>>>>>>
75329>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75330>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75331>>>>>>>>>    Function_Return sTempFileName
75332>>>>>>>>>End_Function
75333>>>>>>>>>
75333>>>>>>>>>//
75333>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75333>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75333>>>>>>>>>//
75333>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75335>>>>>>>>>    Integer iVoid
75335>>>>>>>>>    Handle  hWnd
75335>>>>>>>>>    String  sFolder
75335>>>>>>>>>    WString wFolder
75335>>>>>>>>>
75335>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75336>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75337>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75338>>>>>>>>>    Move (CString(wFolder)) to sFolder
75339>>>>>>>>>    Function_Return sFolder
75340>>>>>>>>>End_Function
75341>>>>>>>>>
75341>>>>>>>>>// Courtesy Of Vincent Oorsprong
75341>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75343>>>>>>>>>    String  sFileDateTime
75343>>>>>>>>>    WString wFormattedTime wFormattedDate
75343>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75343>>>>>>>>>    tvFileTime   FileTime
75343>>>>>>>>>    tvFileTime   FileTime
75343>>>>>>>>>    tvSystemTime SystemTime
75343>>>>>>>>>    tvSystemTime SystemTime
75343>>>>>>>>>
75343>>>>>>>>>    Move "" to sFileDateTime
75344>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75345>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75346>>>>>>>>>
75346>>>>>>>>>    Move 0 to SystemTime.wYear
75347>>>>>>>>>
75347>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75348>>>>>>>>>    If (iSuccess = 1) Begin
75350>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75351>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75352>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75353>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75354>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75355>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75356>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75357>>>>>>>>>    End
75357>>>>>>>>>>
75357>>>>>>>>>    Function_Return sFileDateTime
75358>>>>>>>>>End_Function
75359>>>>>>>>>
75359>>>>>>>>>// **WvA:
75359>>>>>>>>>// A windows replacement for the standard function FileExists.
75359>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75359>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75359>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75359>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75359>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75361>>>>>>>>>    String  sDirSep
75361>>>>>>>>>    Handle  hFindFile
75361>>>>>>>>>    Integer iVoid
75361>>>>>>>>>    tvWin32FindData FindData
75361>>>>>>>>>    tvWin32FindData FindData
75361>>>>>>>>>
75361>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75362>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75363>>>>>>>>>
75363>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75365>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75365>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75366>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75370>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75371>>>>>>>>>        Loop
75372>>>>>>>>>>
75372>>>>>>>>>
75372>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75373>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75374>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75375>>>>>>>>>    End
75375>>>>>>>>>>
75375>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75376>>>>>>>>>End_Function
75377>>>>>>>>>
75377>>>>>>>>>
75377>>>>>>>>>//
75377>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75377>>>>>>>>>// Returns -1 if folder doesn't exist.
75377>>>>>>>>>// The files "." and ".." are not counted.
75377>>>>>>>>>//
75377>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75379>>>>>>>>>    Boolean bFound
75379>>>>>>>>>    Handle  hFindFile
75379>>>>>>>>>    Integer iCount  iVoid
75379>>>>>>>>>    Integer iSuccess
75379>>>>>>>>>    String  sFileName
75379>>>>>>>>>    tvWin32FindData FindData
75379>>>>>>>>>    tvWin32FindData FindData
75379>>>>>>>>>
75379>>>>>>>>>    Move -1 to iCount
75380>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75381>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75382>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75383>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75384>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75385>>>>>>>>>    If (bFound) Begin
75387>>>>>>>>>        Move 0 to iCount
75388>>>>>>>>>    End
75388>>>>>>>>>>
75388>>>>>>>>>    While (bFound)
75392>>>>>>>>>        Increment iCount
75393>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75394>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75396>>>>>>>>>            Decrement iCount
75397>>>>>>>>>        End
75397>>>>>>>>>>
75397>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75398>>>>>>>>>        Move (iSuccess<>0) to bFound
75399>>>>>>>>>    Loop
75400>>>>>>>>>>
75400>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75401>>>>>>>>>    Function_Return iCount
75402>>>>>>>>>End_Function
75403>>>>>>>>>
75403>>>>>>>>>// Create the folder, including intermediate directories.
75403>>>>>>>>>// Don't panic if the folder already exists.
75403>>>>>>>>>// Michael Mullan June 2009.
75403>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75405>>>>>>>>>    String  sFolder
75405>>>>>>>>>    Integer iRetval iFolderCreated
75405>>>>>>>>>    tvSecurity_attributes SA
75405>>>>>>>>>    tvSecurity_attributes SA
75405>>>>>>>>>
75405>>>>>>>>>    Move 0 to iFolderCreated
75406>>>>>>>>>
75406>>>>>>>>>    // null MAX_PATH chars into var (make space)
75406>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75407>>>>>>>>>    If (sNewFolder <> "") Begin
75409>>>>>>>>>
75409>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75410>>>>>>>>>        Move  0  to SA.lpDescriptor
75411>>>>>>>>>        Move  1  to SA.bInheritHandle
75412>>>>>>>>>
75412>>>>>>>>>        //
75412>>>>>>>>>        Move (sNewFolder+"") to sFolder
75413>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75414>>>>>>>>>    End
75414>>>>>>>>>>
75414>>>>>>>>>
75414>>>>>>>>>    If (iFolderCreated <> 0) Begin
75416>>>>>>>>>        Move 1 to iRetVal
75417>>>>>>>>>        Case Begin
75417>>>>>>>>>            Case (iFolderCreated = 161)
75419>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75420>>>>>>>>>>
75420>>>>>>>>>                Case Break
75421>>>>>>>>>            Case (iFolderCreated = 206)
75424>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75425>>>>>>>>>>
75425>>>>>>>>>                Case Break
75426>>>>>>>>>            Case (iFolderCreated = 3)
75429>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75430>>>>>>>>>>
75430>>>>>>>>>                Case Break
75431>>>>>>>>>            Case (iFolderCreated = 80)
75434>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75435>>>>>>>>>                Case Break
75436>>>>>>>>>            Case (iFolderCreated = 183)
75439>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75440>>>>>>>>>                Case Break
75441>>>>>>>>>            Case (iFolderCreated = 1223)
75444>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75445>>>>>>>>>>
75445>>>>>>>>>                Case Break
75446>>>>>>>>>            Case Else
75446>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75447>>>>>>>>>>
75447>>>>>>>>>        Case End
75447>>>>>>>>>    End
75447>>>>>>>>>>
75447>>>>>>>>>    Function_Return iRetVal
75448>>>>>>>>>End_Function
75449>>>>>>>>>
75449>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75451>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75451>>>>>>>>>    Integer iFileSize iVoid
75451>>>>>>>>>    Handle  hFindFile
75451>>>>>>>>>    tvWin32FindData FindData
75451>>>>>>>>>    tvWin32FindData FindData
75451>>>>>>>>>
75451>>>>>>>>>    Move (sFileName+"") to sFileName
75452>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75453>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75454>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75456>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75457>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75458>>>>>>>>>    End
75458>>>>>>>>>>
75458>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75459>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75460>>>>>>>>>
75460>>>>>>>>>    Function_Return iFileSize
75461>>>>>>>>>End_Function
75462>>>>>>>>>
75462>>>>>>>>>//
75462>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75462>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75462>>>>>>>>>//
75462>>>>>>>>>//=============================================================================
75462>>>>>>>>>// Verifies that a path is a valid directory.
75462>>>>>>>>>//
75462>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75462>>>>>>>>>//
75462>>>>>>>>>// Parameters:
75462>>>>>>>>>//      sPath - Address of the path to verify.
75462>>>>>>>>>//=============================================================================
75462>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75464>>>>>>>>>    Integer iResult
75464>>>>>>>>>    Boolean bRetVal
75464>>>>>>>>>
75464>>>>>>>>>    Move false to bRetVal
75465>>>>>>>>>    Move (sPath - Character (0)) to sPath
75466>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75467>>>>>>>>>    If (iResult<>0) Begin
75469>>>>>>>>>        Move True to bRetVal
75470>>>>>>>>>    End
75470>>>>>>>>>>
75470>>>>>>>>>
75470>>>>>>>>>    Function_Return bRetVal
75471>>>>>>>>>End_Function
75472>>>>>>>>>
75472>>>>>>>
75472>>>>>>>//
75472>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75472>>>>>>>// If sStopChar has no occurences in the string an empty string is
75472>>>>>>>// returned.
75472>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75474>>>>>>>    String  sRetVal
75474>>>>>>>    String  sChar
75474>>>>>>>    Integer iLength
75474>>>>>>>    Integer iPos
75474>>>>>>>    Boolean bStopChar
75474>>>>>>>    Move "" to sRetval
75475>>>>>>>    Move (Length(sFrom)) to iLength
75476>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75478>>>>>>>        Move iLength   to iPos
75479>>>>>>>        Move (False)   to bStopChar
75480>>>>>>>        While Not bStopChar
75484>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75485>>>>>>>            Decrement iPos
75486>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75488>>>>>>>                Move (True) to bStopChar
75489>>>>>>>            End
75489>>>>>>>>
75489>>>>>>>            Else Begin
75490>>>>>>>                Move (sChar+sRetVal) to sRetVal
75491>>>>>>>            End
75491>>>>>>>>
75491>>>>>>>        Loop
75492>>>>>>>>
75492>>>>>>>    End
75492>>>>>>>>
75492>>>>>>>    Function_Return sRetVal
75493>>>>>>>End_Function
75494>>>>>>>
75494>>>>>>>// Pre:  sFileName contains the complete path of the file.
75494>>>>>>>// Post: returns the complete path of the file.
75494>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75494>>>>>>>Function ParseFolderName Global String sFileName Returns String
75496>>>>>>>    String sFile
75496>>>>>>>    String sFolderName
75496>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75496>>>>>>>
75496>>>>>>>    Move "" to sFolderName
75497>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75498>>>>>>>    If sDirSep In sFileName Begin
75500>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75501>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75502>>>>>>>    End
75502>>>>>>>>
75502>>>>>>>    Else If ":" In sFileName Begin
75505>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75506>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75507>>>>>>>    End
75507>>>>>>>>
75507>>>>>>>    Function_Return sFolderName
75508>>>>>>>End_Function
75509>>>>>>>
75509>>>>>>>// Pre:  sFileName contains the complete path of the file.
75509>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75509>>>>>>>Function ParseFileName Global String sFileName Returns String
75511>>>>>>>    String sFolderName
75511>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75511>>>>>>>
75511>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75512>>>>>>>    Get ParseFolderName sFileName to sFolderName
75513>>>>>>>    If (sFolderName <> "") Begin
75515>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75516>>>>>>>    End
75516>>>>>>>>
75516>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75517>>>>>>>    Function_Return sFilename
75518>>>>>>>End_Function
75519>>>>>>>
75519>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75519>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75519>>>>>>>//       return "bak" as the extension and not "gif"
75519>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75519>>>>>>>//       such as "html" or "java"
75519>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75521>>>>>>>    String  sFileExtension
75521>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75522>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75523>>>>>>>    Function_Return sFileExtension
75524>>>>>>>End_Function
75525>>>>>>>
75525>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75525>>>>>>>
75525>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75527>>>>>>>    String sMessage
75527>>>>>>>    Case Begin
75527>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75529>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75530>>>>>>>            Case Break
75531>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75534>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75535>>>>>>>            Case Break
75536>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75539>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75540>>>>>>>            Case Break
75541>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75544>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75545>>>>>>>            Case Break
75546>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75549>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75550>>>>>>>            Case Break
75551>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75554>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75555>>>>>>>            Case Break
75556>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75559>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75560>>>>>>>            Case Break
75561>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75564>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75565>>>>>>>            Case Break
75566>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75569>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75570>>>>>>>            Case Break
75571>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75574>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75575>>>>>>>            Case Break
75576>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75579>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75580>>>>>>>            Case Break
75581>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75584>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75585>>>>>>>            Case Break
75586>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75589>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75590>>>>>>>            Case Break
75591>>>>>>>        Case Else
75591>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75592>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75593>>>>>>>            Case Break
75594>>>>>>>    Case End
75594>>>>>>>    Function_Return sMessage
75595>>>>>>>End_Function
75596>>>>>>>
75596>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75598>>>>>>>    String sMessage
75598>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75599>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75600>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75601>>>>>>>End_Procedure
75602>>>>>>>
75602>>>>>>>
75602>>>>>>>// This function informs the user that he entered a yet unknown folder and
75602>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75602>>>>>>>// Choice: "Yes" - this creates the folder
75602>>>>>>>//                 if successful, the function returns false
75602>>>>>>>//                 else it will be true.
75602>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75602>>>>>>>//                 For example: to stop a save
75602>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75602>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75602>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75604>>>>>>>    Integer bIsNotValid
75604>>>>>>>    Integer iUsers_Choice
75604>>>>>>>    String  sMessage
75604>>>>>>>
75604>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75606>>>>>>>        Move "The folder '" to sMessage
75607>>>>>>>        Append sMessage sFolderName
75608>>>>>>>        Append sMessage "' does not yet exist,\n"
75609>>>>>>>        Append sMessage "Do you want to create it now?"
75610>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75611>>>>>>>        Case Begin
75611>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75613>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75614>>>>>>>                If bIsNotValid Begin
75616>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75617>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75619>>>>>>>                    Send Info_Box sMessage "Info"
75620>>>>>>>                End
75620>>>>>>>>
75620>>>>>>>                Case Break
75621>>>>>>>            Case (iUsers_Choice = MBR_No)
75624>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75625>>>>>>>                Case Break
75626>>>>>>>        Case End
75626>>>>>>>    End
75626>>>>>>>>
75626>>>>>>>    Function_Return bIsNotValid
75627>>>>>>>End_Function
75628>>>>>>>
75628>>>>>>>// **WvA
75628>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75628>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75628>>>>>>>// The folder may contain a drive letter or UNC encoding.
75628>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75630>>>>>>>    String sDirSep
75630>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75631>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75632>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75634>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75635>>>>>>>    End
75635>>>>>>>>
75635>>>>>>>    Function_Return sFolderName
75636>>>>>>>End_Function
75637>>>>>>>
75637>>>>>>>//
75637>>>>>>>// Gets the parent path of the currently supplied path
75637>>>>>>>// Returns "" when we are at the root folder.
75637>>>>>>>//
75637>>>>>>>Function vParentPath Global String sPath Returns String
75639>>>>>>>    String sStrip sDirSep
75639>>>>>>>
75639>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75640>>>>>>>    Move (Trim(sPath)) to sPath
75641>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75643>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75644>>>>>>>    End
75644>>>>>>>>
75644>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75646>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75647>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75648>>>>>>>    End
75648>>>>>>>>
75648>>>>>>>    Else Begin
75649>>>>>>>        Move "" to sPath
75650>>>>>>>    End
75650>>>>>>>>
75650>>>>>>>    Function_Return sPath
75651>>>>>>>End_Function
75652>>>>>Use DUFLanguageConstants.inc
75652>>>>>
75652>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75652>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75652>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75652>>>>>
75652>>>>>Struct tDUFIntFile
75652>>>>>    Integer iID
75652>>>>>    String sIntFileName
75652>>>>>    String sIntLineText
75652>>>>>End_Struct
75652>>>>>
75652>>>>>Struct tDbVersionInfo
75652>>>>>    Number nVersionNumber
75652>>>>>    Handle hObject
75652>>>>>End_Struct
75652>>>>>
75652>>>>>Struct tDbUpdateError
75652>>>>>    Number nUpdateVersion
75652>>>>>    Integer iError
75652>>>>>    String  sOrgErrorText
75652>>>>>    String  sErrorText
75652>>>>>    Integer iErrorLine
75652>>>>>    Boolean bError  
75652>>>>>    Handle  hTable 
75652>>>>>    String  sTableRootName
75652>>>>>    Integer iField
75652>>>>>    Boolean bShortFormat
75652>>>>>End_Struct
75652>>>>>
75652>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75652>>>>>//  DF_FILE_IS_MASTER if master
75652>>>>>//  DF_FILE_IS_ALIAS if alias
75652>>>>>Struct tDbUpdateHandlerMasterAlias
75652>>>>>    Handle hTable
75652>>>>>    Integer iMode
75652>>>>>End_Struct
75652>>>>>
75652>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75652>>>>>Enumeration_List
75652>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75652>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75652>>>>>End_Enumeration_List
75652>>>>>
75652>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75652>>>>>
75652>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75652>>>>>// communicate with the object from anywhere in a program.
75652>>>>>    Global_Variable Handle ghoDbUpdateHandler
75652>>>>>    Move 0 to ghoDbUpdateHandler
75653>>>>>
75653>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75653>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75653>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75653>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75653>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75653>>>>>//    Declare_Datafile DbVersion
75653>>>>>//#ENDIF
75653>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75653>>>>>//****************************************************************************
75653>>>>>// $Module type: Class
75653>>>>>// $Module name: cDbUpdateLogFile
75653>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75653>>>>>// Web-site    : http://www.rdctools.com
75653>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75653>>>>>//
75653>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75653>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75653>>>>>//               that this class is to change; each developer can decide if the errors instead
75653>>>>>//               should be saved to a database table, or something entirely different.
75653>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75653>>>>>//
75653>>>>>// $Rev History:
75653>>>>>//    2016-10-05  Module header created
75653>>>>>//****************************************************************************
75653>>>>>Use UI
75653>>>>>Use vWin32fh.pkg
75653>>>>>
75653>>>>>
75653>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75653>>>>>
75653>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75653>>>>>
75653>>>>>Class cDbUpdateLogFile is a cObject
75654>>>>>
75654>>>>>    Procedure Construct_Object
75656>>>>>        Forward Send Construct_Object
75658>>>>>
75658>>>>>        // Error handling:
75658>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75659>>>>>        Property Integer piChannel -1
75660>>>>>
75660>>>>>        // This property is set by the cDbUpdateHandler object,
75660>>>>>        // when the update process starts.
75660>>>>>        Property DateTime pdtUpdateStart
75661>>>>>
75661>>>>>        // Gets set to False if the log contains data
75661>>>>>        Property Boolean pbEmptyLogFile True
75662>>>>>
75662>>>>>        // Gets set to True after the error log header text
75662>>>>>        // has been written.
75662>>>>>        Property Boolean pbHeaderWritten False
75663>>>>>
75663>>>>>        // If all activities should be logged- not just errors.
75663>>>>>        Property Boolean pbVerboseState False
75664>>>>>
75664>>>>>        // File name for the error log where all errors
75664>>>>>        // after a run is written to (appended).
75664>>>>>        // It is saved in the Data folder.
75664>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75665>>>>>        // If this property is set to "" in object code, the
75665>>>>>        // "shell" command parameter will be used to let Windows decide
75665>>>>>        // with which program to open the logfile.
75665>>>>>        Property String psEditorProgram ""
75666>>>>>
75666>>>>>        Property Boolean pbUseDataTableLog False
75667>>>>>
75667>>>>>        // If true an error will be written to file immediately when
75667>>>>>        // it occurs. This can be handy if a large update generates a lots
75667>>>>>        // of errors and the application crasches before finished, thus
75667>>>>>        // the errors will not be written.
75667>>>>>        Property Boolean pbQuickWrite True
75668>>>>>    End_Procedure
75669>>>>>
75669>>>>>    Procedure End_Construct_Object
75671>>>>>        Forward Send End_Construct_Object
75673>>>>>
75673>>>>>    End_Procedure
75674>>>>>
75674>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75676>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75676>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75678>>>>>        Boolean bShortFormat
75678>>>>>        Integer iSize
75678>>>>>        Handle hCurrentTable
75678>>>>>        Integer iCurrentField           
75678>>>>>        String sOrgErrorText sTableRootName
75678>>>>>        
75678>>>>>        Move False to bShortFormat
75679>>>>>        If (num_arguments > 5) Begin
75681>>>>>            Move bShortFormatIn to bShortFormat
75682>>>>>        End
75682>>>>>>
75682>>>>>        // Only do once.
75682>>>>>        If (pbHeaderWritten(Self) = False) Begin
75684>>>>>            Send WriteHeaderData
75685>>>>>            Set pbHeaderWritten to True
75686>>>>>        End
75686>>>>>>
75686>>>>>
75686>>>>>        Get Private.phCurrentTable to hCurrentTable  
75687>>>>>        Get Private.piCurrentField to iCurrentField  
75688>>>>>        If (iError > 0) Begin
75690>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75693>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75694>>>>>        End
75694>>>>>>
75694>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75695>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75696>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75697>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75698>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75699>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75700>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75701>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75702>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75703>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75704>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75705>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75706>>>>>
75706>>>>>        If (bError = False) Begin
75708>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75709>>>>>        End
75709>>>>>>
75709>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75710>>>>>
75710>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75712>>>>>            If (pbQuickWrite(Self) = True) Begin
75714>>>>>                Send OnWriteRow_DataTable
75715>>>>>                // If we are writing error for error flush the
75715>>>>>                // error array when latest error has been written.
75715>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75716>>>>>            End
75716>>>>>>
75716>>>>>            Procedure_Return
75717>>>>>        End
75717>>>>>>
75717>>>>>        Else Begin
75718>>>>>            If (pbQuickWrite(Self) = True) Begin
75720>>>>>                Send WriteErrorLog
75721>>>>>                // Flush the error log array
75721>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75722>>>>>            End
75722>>>>>>
75722>>>>>        End
75722>>>>>>
75722>>>>>    End_Procedure   
75723>>>>>    
75723>>>>>    Function FetchErrorDescription Integer iError Returns String
75725>>>>>        String sErrorText         
75725>>>>>        Move "" to sErrorText
75726>>>>>        If (iError > 0) Begin
75728>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75729>>>>>        End
75729>>>>>>
75729>>>>>        Function_Return sErrorText
75730>>>>>    End_Function
75731>>>>>
75731>>>>>    // Hook procedure for writing header text prior starting the update work to
75731>>>>>    // a database table. This does nothing by default.
75731>>>>>    // Don't forget to Open your "error log table" first (!) as all
75731>>>>>    // tables have been closed at this stage. Put anything
75731>>>>>    // you want to indicate that the update process is just started.
75731>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75733>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75735>>>>>    End_Procedure
75736>>>>>
75736>>>>>    Procedure OnWriteRow_DataTable
75738>>>>>        tDbUpdateError[] DbUpdateErrorArray
75738>>>>>        tDbUpdateError[] DbUpdateErrorArray
75739>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75740>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75742>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75744>>>>>        End
75744>>>>>>
75744>>>>>    End_Procedure
75745>>>>>
75745>>>>>    Function psLogTextFileWithPath Returns String
75747>>>>>        String sPath sFileName sFullFileName
75747>>>>>        
75747>>>>>        Get psDataPathFirstPart to sPath
75748>>>>>        Get psLogTextFile to sFileName
75749>>>>>        Move (sPath + sFileName) to sFullFileName
75750>>>>>        Function_Return sFullFileName
75751>>>>>    End_Function                     
75752>>>>>    
75752>>>>>    Procedure WriteHeaderData
75754>>>>>        String sFileName
75754>>>>>        Integer iCh iSize
75754>>>>>        Boolean bQuickWrite
75754>>>>>        DateTime dtUpdateStart
75754>>>>>
75754>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75755>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75757>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75758>>>>>            Procedure_Return
75759>>>>>        End
75759>>>>>>
75759>>>>>
75759>>>>>        Get piChannel to iCh
75760>>>>>        If (iCh < 0) Begin
75762>>>>>            Get Seq_New_Channel to iCh
75763>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75765>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75766>>>>>>
75766>>>>>                Procedure_Return
75767>>>>>            End
75767>>>>>>
75767>>>>>            Set piChannel to iCh
75768>>>>>        End
75768>>>>>>
75768>>>>>
75768>>>>>        Get psLogTextFileWithPath to sFileName
75769>>>>>        Get vWin32_APIFileSize sFileName to iSize
75770>>>>>        Get pbQuickWrite to bQuickWrite
75771>>>>>        
75771>>>>>        If (bQuickWrite = True) Begin
75773>>>>>            Append_Output channel iCh sFileName
75775>>>>>                If (bQuickWrite = True) Begin
75777>>>>>                    If (iSize = 0) Begin
75779>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75782>>>>>                        Set pbEmptyLogFile to False
75783>>>>>                    End
75783>>>>>>
75783>>>>>                    Writeln channel iCh
75785>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75788>>>>>                End
75788>>>>>>
75788>>>>>            Close_Output channel iCh
75790>>>>>        End
75790>>>>>>
75790>>>>>    End_Procedure
75791>>>>>
75791>>>>>    // Returns the first datapath found in the psDataPath property.
75791>>>>>    // The returned path always ends with a "\"
75791>>>>>    Function psDataPathFirstPart Returns String
75793>>>>>        String sDataPath
75793>>>>>        Integer iCount
75793>>>>>
75793>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75794>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75795>>>>>        If (iCount > 1) Begin
75797>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75798>>>>>        End
75798>>>>>>
75798>>>>>        If (sDataPath <> "") Begin
75800>>>>>            Get vFolderFormat sDataPath to sDataPath
75801>>>>>        End
75801>>>>>>
75801>>>>>
75801>>>>>        Function_Return sDataPath
75802>>>>>    End_Function
75803>>>>>
75803>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75803>>>>>    Procedure WriteErrorLog
75805>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75805>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75806>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75806>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75806>>>>>        Boolean bUseDataTable bQuickWrite
75806>>>>>        DateTime dtUpdateStart dtUpdateEnd
75806>>>>>        TimeSpan tsElapsed
75806>>>>>        Number nVersion                                  
75806>>>>>        Handle hTable
75806>>>>>
75806>>>>>        If (pbHeaderWritten(Self) = False) Begin
75808>>>>>            Send WriteHeaderData
75809>>>>>            Set pbHeaderWritten to True
75810>>>>>        End
75810>>>>>>
75810>>>>>
75810>>>>>        Get pbUseDataTableLog to bUseDataTable
75811>>>>>        If (bUseDataTable = True) Begin
75813>>>>>            Send OnWriteRow_DataTable
75814>>>>>            Procedure_Return
75815>>>>>        End
75815>>>>>>
75815>>>>>
75815>>>>>        Get piChannel to iCh
75816>>>>>        If (iCh < 0) Begin
75818>>>>>            Get Seq_New_Channel to iCh
75819>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75821>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75822>>>>>>
75822>>>>>                Procedure_Return
75823>>>>>            End
75823>>>>>>
75823>>>>>            Set piChannel to iCh
75824>>>>>        End
75824>>>>>>
75824>>>>>
75824>>>>>        Get psLogTextFileWithPath to sFileName
75825>>>>>
75825>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75826>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75827>>>>>        Decrement iSize
75828>>>>>
75828>>>>>        Get pdtUpdateStart to dtUpdateStart
75829>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75831>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75832>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75833>>>>>        End
75833>>>>>>
75833>>>>>        Get pbQuickWrite to bQuickWrite
75834>>>>>
75834>>>>>        Append_Output channel iCh sFileName
75836>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75838>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75841>>>>>        End
75841>>>>>>
75841>>>>>        Else If (bQuickWrite = False) Begin
75844>>>>>            Writeln channel iCh
75846>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75849>>>>>        End   
75849>>>>>>
75849>>>>>        If (iSize >= 0) Begin
75851>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75853>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75856>>>>>            End
75856>>>>>>
75856>>>>>        End
75856>>>>>>
75856>>>>>
75856>>>>>        For iCount from 0 to iSize  
75862>>>>>>
75862>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75863>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75864>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75865>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75866>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75867>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75868>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75869>>>>>            
75869>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75870>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75872>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75873>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75874>>>>>            End
75874>>>>>>
75874>>>>>            Else Begin
75875>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75876>>>>>                Move (sVersion + "   " + sErrorText) to sText
75877>>>>>            End
75877>>>>>>
75877>>>>>            Writeln channel iCh sText
75880>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75882>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75883>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75884>>>>>                Writeln channel iCh sOrgErrorText
75887>>>>>            End
75887>>>>>>
75887>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75889>>>>>                Writeln channel iCh
75891>>>>>            End
75891>>>>>>
75891>>>>>        Loop
75892>>>>>>
75892>>>>>        Close_Output channel iCh
75894>>>>>
75894>>>>>        Send Seq_Release_Channel iCh
75895>>>>>        Set piChannel to -1
75896>>>>>
75896>>>>>    End_Procedure
75897>>>>>
75897>>>>>    // The character to pad is optional. If nothing, spaces are used.
75897>>>>>    // Example:
75897>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75897>>>>>    //  or:
75897>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75897>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75897>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75899>>>>>        String sChar
75899>>>>>
75899>>>>>        If (Num_Arguments >= 3) Begin
75901>>>>>            Move sOptChar to sChar
75902>>>>>        End
75902>>>>>>
75902>>>>>        Else Begin
75903>>>>>            Move " " to sChar
75904>>>>>        End
75904>>>>>>
75904>>>>>
75904>>>>>        While (Length(sString) < iLength)
75908>>>>>            Move (sChar + sString) to sString
75909>>>>>        Loop
75910>>>>>>
75910>>>>>
75910>>>>>        Function_Return sString
75911>>>>>    End_Function
75912>>>>>
75912>>>>>    Procedure ShowErrorLog
75914>>>>>        String sPath sFileName sEditorProgram
75914>>>>>        Boolean bExists
75914>>>>>
75914>>>>>        Get psLogTextFileWithPath to sFileName
75915>>>>>        Get vFilePathExists sFileName to bExists
75916>>>>>        If (bExists = True) Begin
75918>>>>>            Get psEditorProgram to sEditorProgram
75919>>>>>            If (sEditorProgram <> "") Begin
75921>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75922>>>>>            End
75922>>>>>>
75922>>>>>            Else Begin
75923>>>>>                Runprogram Shell Background sFileName
75924>>>>>            End
75924>>>>>>
75924>>>>>        End
75924>>>>>>
75924>>>>>        Else Begin
75925>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75926>>>>>        End
75926>>>>>>
75926>>>>>    End_Procedure
75927>>>>>
75927>>>>>End_Class
75928>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75928>>>>>//****************************************************************************
75928>>>>>// $Module type: Class
75928>>>>>// $Module name: cDbUpdateVersion
75928>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75928>>>>>// Web-site    : http://www.rdctools.com
75928>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75928>>>>>//
75928>>>>>// Description : Child class to cDbUpdateHandler.
75928>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75928>>>>>//               Set the pnVersionNumber to a version number.
75928>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75928>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75928>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75928>>>>>//
75928>>>>>// $Rev History:
75928>>>>>//    2016-09-27  Module header created
75928>>>>>//****************************************************************************
75928>>>>>Use UI
75928>>>>>Use DUFLanguageConstants.inc
75928>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75928>>>>>>>//****************************************************************************
75928>>>>>>>// $Module type: Class
75928>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75928>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75928>>>>>>>// Web-site    : http://www.rdctools.com
75928>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75928>>>>>>>//
75928>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75928>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75928>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75928>>>>>>>//               with the help of Sql-scripts.
75928>>>>>>>//
75928>>>>>>>// $Rev History:
75928>>>>>>>//    2014-09-05  Module header created
75928>>>>>>>//
75928>>>>>>>//****************************************************************************
75928>>>>>>>//
75928>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75928>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75928>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75928>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75928>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75928>>>>>>>//
75928>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75928>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75928>>>>>>>
75928>>>>>>>
75928>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75928>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
75928>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75928>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75928>>>>>>>//
75928>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75928>>>>>>>>>//****************************************************************************
75928>>>>>>>>>// $Module type: Class
75928>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75928>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75928>>>>>>>>>// Web-site    : http://www.rdctools.com
75928>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75928>>>>>>>>>//
75928>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75928>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75928>>>>>>>>>//
75928>>>>>>>>>// $Rev History:
75928>>>>>>>>>//    2023-11-06  Module header created
75928>>>>>>>>>//
75928>>>>>>>>>//****************************************************************************
75928>>>>>>>>>Use cApplication.pkg
75928>>>>>>>>>Use seq_chnl.pkg
75928>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75928>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75928>>>>>>>>>Use Dfcursor.pkg
75928>>>>>>>>>Use DUFStatusPanel.pkg
75928>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75928>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75928>>>>>>>>>>>//
75928>>>>>>>>>>>// We need to create a mixin class for the library.
75928>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75928>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75928>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75928>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75928>>>>>>>>>>>//
75928>>>>>>>>>>>Use VdfBase.pkg
75928>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
75928>>>>>>>>>>>>>Use Unicode.Pkg
75928>>>>>>>>>>>>>
75928>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75929>>>>>>>>>>>>>
75929>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75930>>>>>>>>>>>>>
75930>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75931>>>>>>>>>>>>>
75931>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75932>>>>>>>>>>>>>
75932>>>>>>>>>>>>>
75932>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75932>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75934>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75934>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75934>>>>>>>>>>>>>    String sUUID
75934>>>>>>>>>>>>>    
75934>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75935>>>>>>>>>>>>>    
75935>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    If (iRetval = 0) Begin
75938>>>>>>>>>>>>>        Move 0 to pUUIDStr
75939>>>>>>>>>>>>>        
75939>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75940>>>>>>>>>>>>>        If (iRetval = 0) Begin
75942>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75943>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75944>>>>>>>>>>>>>            
75944>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75945>>>>>>>>>>>>>        End
75945>>>>>>>>>>>>>>
75945>>>>>>>>>>>>>    End
75945>>>>>>>>>>>>>>
75945>>>>>>>>>>>>>    
75945>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75946>>>>>>>>>>>>>    
75946>>>>>>>>>>>>>    Function_Return sUUID
75947>>>>>>>>>>>>>End_Function
75948>>>>>>>>>>>>>
75948>>>>>>>>>>>>>
75948>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75948>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75950>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75950>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75950>>>>>>>>>>>>>    String sUUID
75950>>>>>>>>>>>>>    
75950>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75951>>>>>>>>>>>>>    
75951>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75952>>>>>>>>>>>>>    
75952>>>>>>>>>>>>>    If (iRetval = 0) Begin
75954>>>>>>>>>>>>>        Move 0 to pUUIDStr
75955>>>>>>>>>>>>>        
75955>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75956>>>>>>>>>>>>>        If (iRetval = 0) Begin
75958>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75959>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75960>>>>>>>>>>>>>            
75960>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75961>>>>>>>>>>>>>        End
75961>>>>>>>>>>>>>>
75961>>>>>>>>>>>>>    End
75961>>>>>>>>>>>>>>
75961>>>>>>>>>>>>>    
75961>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75962>>>>>>>>>>>>>    
75962>>>>>>>>>>>>>    Function_Return sUUID
75963>>>>>>>>>>>>>End_Function
75964>>>>>>>>>>>Use cli.pkg
75964>>>>>>>>>>>Use sql.pkg
75964>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
75964>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75964>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75964>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>Use Cli.pkg
75964>>>>>>>>>>>>>Use SQL.pkg
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>//   Driver Indentification
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>//   Error number constants
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>// SQL Server spcific types.
75964>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75964>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75964>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75964>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>// SQL Server spcific types.
75964>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75964>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75964>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75964>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75964>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75964>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75964>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75964>>>>>>>>>>>>>//
75964>>>>>>>>>>>>>//     Setup a constraint for a file.
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75965>>>>>>>>>>>>>    
75965>>>>>>>>>>>>>    Procedure Construct_Object
75967>>>>>>>>>>>>>        Forward Send Construct_Object
75969>>>>>>>>>>>>>        
75969>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75970>>>>>>>>>>>>>    End_Procedure
75971>>>>>>>>>>>>>    
75971>>>>>>>>>>>>>    
75971>>>>>>>>>>>>>    
75971>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75971>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75973>>>>>>>>>>>>>        String  sItem
75973>>>>>>>>>>>>>        Integer iStart
75973>>>>>>>>>>>>>        Integer iEnd
75973>>>>>>>>>>>>>        
75973>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75976>>>>>>>>>>>>>        
75976>>>>>>>>>>>>>        Send Delete_Data to hoStore
75977>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75978>>>>>>>>>>>>>        While (iStart > 0)
75982>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75983>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75986>>>>>>>>>>>>>            Else Begin
75987>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75988>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75989>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75992>>>>>>>>>>>>>                
75992>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75995>>>>>>>>>>>>>                
75995>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75998>>>>>>>>>>>>>            End
75998>>>>>>>>>>>>>>
75998>>>>>>>>>>>>>        Loop
75999>>>>>>>>>>>>>>
75999>>>>>>>>>>>>>        
75999>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
76000>>>>>>>>>>>>>    End_Procedure
76001>>>>>>>>>>>>>    
76001>>>>>>>>>>>>>    
76001>>>>>>>>>>>>>    
76001>>>>>>>>>>>>>    //   Call the driver's browse connect function
76001>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
76003>>>>>>>>>>>>>        String  sDriver
76003>>>>>>>>>>>>>        String  sOutConnStr
76003>>>>>>>>>>>>>        Integer iArg
76003>>>>>>>>>>>>>        Integer iRetval
76003>>>>>>>>>>>>>        
76003>>>>>>>>>>>>>        Get psDriverID to sDriver
76004>>>>>>>>>>>>>        If (sDriver <> "") Begin
76006>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
76007>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
76012>>>>>>>>>>>>>        End
76012>>>>>>>>>>>>>>
76012>>>>>>>>>>>>>        
76012>>>>>>>>>>>>>        Function_Return sOutConnStr
76013>>>>>>>>>>>>>    End_Function// BrowseConnect
76014>>>>>>>>>>>>>    
76014>>>>>>>>>>>>>    
76014>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
76016>>>>>>>>>>>>>        String  sDriver
76016>>>>>>>>>>>>>        String  sOutConnStr
76016>>>>>>>>>>>>>        Integer iArg
76016>>>>>>>>>>>>>        Integer iRetval
76016>>>>>>>>>>>>>        
76016>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
76017>>>>>>>>>>>>>        
76017>>>>>>>>>>>>>        Get psDriverID to sDriver
76018>>>>>>>>>>>>>        If (sDriver <> "") Begin
76020>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
76021>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
76026>>>>>>>>>>>>>        End
76026>>>>>>>>>>>>>>
76026>>>>>>>>>>>>>        
76026>>>>>>>>>>>>>        Function_Return sOutConnStr
76027>>>>>>>>>>>>>    End_Function// BrowseConnect
76028>>>>>>>>>>>>>    
76028>>>>>>>>>>>>>    
76028>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
76030>>>>>>>>>>>>>        
76030>>>>>>>>>>>>>        String  sServerList
76030>>>>>>>>>>>>>        Integer iNumServers
76030>>>>>>>>>>>>>        Integer iDriver
76030>>>>>>>>>>>>>        Integer iClientVersion
76030>>>>>>>>>>>>>        String  sDriver
76030>>>>>>>>>>>>>        
76030>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76031>>>>>>>>>>>>>        
76031>>>>>>>>>>>>>        If (iDriver) Begin
76033>>>>>>>>>>>>>            
76033>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76036>>>>>>>>>>>>>            
76036>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
76037>>>>>>>>>>>>>            
76037>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
76038>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
76040>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
76041>>>>>>>>>>>>>            End
76041>>>>>>>>>>>>>>
76041>>>>>>>>>>>>>            Else Begin
76042>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
76043>>>>>>>>>>>>>            End
76043>>>>>>>>>>>>>>
76043>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
76044>>>>>>>>>>>>>        End
76044>>>>>>>>>>>>>>
76044>>>>>>>>>>>>>        
76044>>>>>>>>>>>>>        Function_Return iNumServers
76045>>>>>>>>>>>>>        
76045>>>>>>>>>>>>>    End_Function
76046>>>>>>>>>>>>>    
76046>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
76046>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
76046>>>>>>>>>>>>>    //   This may take a long time.
76046>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
76046>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
76048>>>>>>>>>>>>>        
76048>>>>>>>>>>>>>        Integer iNumServers
76048>>>>>>>>>>>>>        Integer iNetworkLocal
76048>>>>>>>>>>>>>        
76048>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
76049>>>>>>>>>>>>>        
76049>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
76050>>>>>>>>>>>>>        
76050>>>>>>>>>>>>>        Function_Return iNumServers
76051>>>>>>>>>>>>>        
76051>>>>>>>>>>>>>    End_Function
76052>>>>>>>>>>>>>    
76052>>>>>>>>>>>>>    
76052>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
76052>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
76052>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
76052>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
76054>>>>>>>>>>>>>        
76054>>>>>>>>>>>>>        Integer iNumServers
76054>>>>>>>>>>>>>        Integer iNetworkLocal
76054>>>>>>>>>>>>>        
76054>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
76055>>>>>>>>>>>>>        
76055>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
76056>>>>>>>>>>>>>        
76056>>>>>>>>>>>>>        Function_Return iNumServers
76057>>>>>>>>>>>>>        
76057>>>>>>>>>>>>>    End_Function
76058>>>>>>>>>>>>>    
76058>>>>>>>>>>>>>    
76058>>>>>>>>>>>>>    
76058>>>>>>>>>>>>>    //   Enumerate database in a given server.
76058>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
76060>>>>>>>>>>>>>        Integer hoSQL
76060>>>>>>>>>>>>>        String  sConnect
76060>>>>>>>>>>>>>        String  sDatabase
76060>>>>>>>>>>>>>        Integer hdbc
76060>>>>>>>>>>>>>        Integer hstmt
76060>>>>>>>>>>>>>        Integer iFetchResult
76060>>>>>>>>>>>>>        
76060>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
76063>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76066>>>>>>>>>>>>>        
76066>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76069>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76071>>>>>>>>>>>>>        
76071>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76073>>>>>>>>>>>>>            Move Current_Object to hoSQL
76074>>>>>>>>>>>>>        End_Object
76075>>>>>>>>>>>>>        
76075>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76077>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76078>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76080>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76081>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76083>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76083>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76083>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76083>>>>>>>>>>>>>                    //   stay the same.
76083>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76084>>>>>>>>>>>>>                    Send SQLCall to hstmt
76085>>>>>>>>>>>>>                    Repeat
76085>>>>>>>>>>>>>>
76085>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76086>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76088>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76089>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76090>>>>>>>>>>>>>                        End
76090>>>>>>>>>>>>>>
76090>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76092>>>>>>>>>>>>>                    
76092>>>>>>>>>>>>>                    Send SQLClose to hstmt
76093>>>>>>>>>>>>>                End
76093>>>>>>>>>>>>>>
76093>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76094>>>>>>>>>>>>>            End
76094>>>>>>>>>>>>>>
76094>>>>>>>>>>>>>        End
76094>>>>>>>>>>>>>>
76094>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76095>>>>>>>>>>>>>        
76095>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76096>>>>>>>>>>>>>    End_Function
76097>>>>>>>>>>>>>    
76097>>>>>>>>>>>>>    
76097>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76099>>>>>>>>>>>>>        
76099>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76099>>>>>>>>>>>>>        
76099>>>>>>>>>>>>>        
76099>>>>>>>>>>>>>        Case Begin
76099>>>>>>>>>>>>>
76099>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76101>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76102>>>>>>>>>>>>>                Case Break
76103>>>>>>>>>>>>>            
76103>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76106>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76107>>>>>>>>>>>>>                Case Break
76108>>>>>>>>>>>>>                
76108>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76111>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76112>>>>>>>>>>>>>                Case Break
76113>>>>>>>>>>>>>            
76113>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76116>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76117>>>>>>>>>>>>>                Case Break
76118>>>>>>>>>>>>>            
76118>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76121>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76122>>>>>>>>>>>>>                Case Break
76123>>>>>>>>>>>>>            
76123>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76126>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76127>>>>>>>>>>>>>                Case Break
76128>>>>>>>>>>>>>            
76128>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76131>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76132>>>>>>>>>>>>>                Case Break
76133>>>>>>>>>>>>>            
76133>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76136>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76137>>>>>>>>>>>>>                Case Break
76138>>>>>>>>>>>>>            
76138>>>>>>>>>>>>>            Case Else
76138>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76139>>>>>>>>>>>>>                
76139>>>>>>>>>>>>>        Case End
76139>>>>>>>>>>>>>        
76139>>>>>>>>>>>>>        
76139>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76140>>>>>>>>>>>>>        
76140>>>>>>>>>>>>>    End_Function
76141>>>>>>>>>>>>>
76141>>>>>>>>>>>>>
76141>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76143>>>>>>>>>>>>>        
76143>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76143>>>>>>>>>>>>>        
76143>>>>>>>>>>>>>        Case Begin
76143>>>>>>>>>>>>>
76143>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76145>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76146>>>>>>>>>>>>>                Case Break
76147>>>>>>>>>>>>>
76147>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76150>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76151>>>>>>>>>>>>>                Case Break
76152>>>>>>>>>>>>>                
76152>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76155>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76156>>>>>>>>>>>>>                Case Break
76157>>>>>>>>>>>>>            
76157>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76160>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76161>>>>>>>>>>>>>                Case Break
76162>>>>>>>>>>>>>            
76162>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76165>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76166>>>>>>>>>>>>>                Case Break
76167>>>>>>>>>>>>>            
76167>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76170>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76171>>>>>>>>>>>>>                Case Break
76172>>>>>>>>>>>>>            
76172>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76175>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76176>>>>>>>>>>>>>                Case Break
76177>>>>>>>>>>>>>            
76177>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76180>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76181>>>>>>>>>>>>>                Case Break
76182>>>>>>>>>>>>>            
76182>>>>>>>>>>>>>            Case Else
76182>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76183>>>>>>>>>>>>>                
76183>>>>>>>>>>>>>        Case End
76183>>>>>>>>>>>>>        
76183>>>>>>>>>>>>>        
76183>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76184>>>>>>>>>>>>>        
76184>>>>>>>>>>>>>    End_Function
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>End_Class
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\db2_drv.pkg)
76186>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76186>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76186>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76186>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>Use Cli.pkg
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Driver attributes
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Driver Indentification
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Error number constants
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Call driver function identifiers
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// DB2 specific data types
76186>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76186>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76186>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76186>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76186>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76186>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76186>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76186>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// Extra DB2 commands
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76186>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>
76186>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76187>>>>>>>>>>>>>    
76187>>>>>>>>>>>>>    Procedure Construct_Object
76189>>>>>>>>>>>>>        Forward Send Construct_Object
76191>>>>>>>>>>>>>        
76191>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76192>>>>>>>>>>>>>    End_Procedure
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76193>>>>>>>>>>>>>    Procedure SeedDataSources
76195>>>>>>>>>>>>>        String  sDriver
76195>>>>>>>>>>>>>        String  sVoid
76195>>>>>>>>>>>>>        Integer iRetval
76195>>>>>>>>>>>>>        
76195>>>>>>>>>>>>>        Get psDriverID to sDriver
76196>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76203>>>>>>>>>>>>>    End_Procedure
76204>>>>>>>>>>>>>    
76204>>>>>>>>>>>>>    
76204>>>>>>>>>>>>>    
76204>>>>>>>>>>>>>    // Call the driver's data sources function
76204>>>>>>>>>>>>>    Function DataSources Returns String
76206>>>>>>>>>>>>>        String  sDriver
76206>>>>>>>>>>>>>        String  sDataSource
76206>>>>>>>>>>>>>        String  sDescription
76206>>>>>>>>>>>>>        Integer iLength
76206>>>>>>>>>>>>>        Integer iRetval
76206>>>>>>>>>>>>>        
76206>>>>>>>>>>>>>        Get psDriverID to sDriver
76207>>>>>>>>>>>>>        If (sDriver <> "") Begin
76209>>>>>>>>>>>>>            Move 8192 to iLength
76210>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76211>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76212>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76217>>>>>>>>>>>>>        End
76217>>>>>>>>>>>>>>
76217>>>>>>>>>>>>>        
76217>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76220>>>>>>>>>>>>>        Else ;            Function_Return ""
76222>>>>>>>>>>>>>    End_Function
76223>>>>>>>>>>>>>    
76223>>>>>>>>>>>>>End_Class
76224>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\odbc_drv.pkg)
76224>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76224>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76224>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76224>>>>>>>>>>>>>
76224>>>>>>>>>>>>>Use Cli.pkg
76224>>>>>>>>>>>>>
76224>>>>>>>>>>>>>// Driver Indentification
76224>>>>>>>>>>>>>
76224>>>>>>>>>>>>>// Error number constants
76224>>>>>>>>>>>>>
76224>>>>>>>>>>>>>// Call driver function identifiers
76224>>>>>>>>>>>>>
76224>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76225>>>>>>>>>>>>>    
76225>>>>>>>>>>>>>    Procedure Construct_Object
76227>>>>>>>>>>>>>        Forward Send Construct_Object
76229>>>>>>>>>>>>>        
76229>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76230>>>>>>>>>>>>>    End_Procedure
76231>>>>>>>>>>>>>    
76231>>>>>>>>>>>>>    
76231>>>>>>>>>>>>>    
76231>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76231>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76233>>>>>>>>>>>>>        String  sDriver
76233>>>>>>>>>>>>>        String  sVoid
76233>>>>>>>>>>>>>        Integer iRetval
76233>>>>>>>>>>>>>        
76233>>>>>>>>>>>>>        Get psDriverID to sDriver
76234>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76241>>>>>>>>>>>>>    End_Procedure
76242>>>>>>>>>>>>>    
76242>>>>>>>>>>>>>    
76242>>>>>>>>>>>>>    // Call the driver's data sources function
76242>>>>>>>>>>>>>    Function DataSources Returns String
76244>>>>>>>>>>>>>        String  sDriver
76244>>>>>>>>>>>>>        String  sDataSource
76244>>>>>>>>>>>>>        String  sDescription
76244>>>>>>>>>>>>>        Integer iLength
76244>>>>>>>>>>>>>        Integer iRetval
76244>>>>>>>>>>>>>        
76244>>>>>>>>>>>>>        Get psDriverID to sDriver
76245>>>>>>>>>>>>>        If (sDriver <> "") Begin
76247>>>>>>>>>>>>>            Move 8192 to iLength
76248>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76249>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76250>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76255>>>>>>>>>>>>>        End
76255>>>>>>>>>>>>>>
76255>>>>>>>>>>>>>        
76255>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76258>>>>>>>>>>>>>        Else ;            Function_Return ""
76260>>>>>>>>>>>>>    End_Function
76261>>>>>>>>>>>>>    
76261>>>>>>>>>>>>>End_Class
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
76262>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76262>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76262>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76262>>>>>>>>>>>>>Use Ui
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Driver Indentification
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>// Driver attributes
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Call_Driver functions ID's
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to create all vars which may be needed
76262>>>>>>>>>>>>>// in other commands.
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76262>>>>>>>>>>>>>// File must have been opened.
76262>>>>>>>>>>>>>// Filenumber needs to be passed.
76262>>>>>>>>>>>>>// To clear set the owner to "".
76262>>>>>>>>>>>>>// Examples:
76262>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76262>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76262>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76262>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76262>>>>>>>>>>>>>// To clear:
76262>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76262>>>>>>>>>>>>>// options.
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to parse for Callback
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76262>>>>>>>>>>>>>// File must have been opened.
76262>>>>>>>>>>>>>// Filenumber needs to be passed.
76262>>>>>>>>>>>>>// Examples:
76262>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76262>>>>>>>>>>>>>// which will be tries when opening files.
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76262>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76262>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76262>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to change the transaction type.
76262>>>>>>>>>>>>>// Valid types are:
76262>>>>>>>>>>>>>//     DFBTRTT_NONE
76262>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76262>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to get the current transaction type.
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to set explicit_locking
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to get explicit locking
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76262>>>>>>>>>>>>>//
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76262>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76262>>>>>>>>>>>>>
76262>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76263>>>>>>>>>>>>>    
76263>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76265>>>>>>>>>>>>>        Forward Send Construct_object iImage
76267>>>>>>>>>>>>>        
76267>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76268>>>>>>>>>>>>>    End_Procedure
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76269>>>>>>>>>>>>>    //
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    Function CKRevision Returns String
76271>>>>>>>>>>>>>        String  sDriverID
76271>>>>>>>>>>>>>        String  sRevision
76271>>>>>>>>>>>>>        String  sVoid
76271>>>>>>>>>>>>>        Integer iRetval
76271>>>>>>>>>>>>>        
76271>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76271>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76271>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76271>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76272>>>>>>>>>>>>>        Get psDriverID to sDriverID
76273>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76274>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76279>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76280>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76282>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76282>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76283>>>>>>>>>>>>>        End
76283>>>>>>>>>>>>>>
76283>>>>>>>>>>>>>        Function_Return sRevision
76284>>>>>>>>>>>>>    End_Function
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76287>>>>>>>>>>>>>        String  sDriverID
76287>>>>>>>>>>>>>        String  sVoid1
76287>>>>>>>>>>>>>        String  sVoid2
76287>>>>>>>>>>>>>        Integer iRetval
76287>>>>>>>>>>>>>        
76287>>>>>>>>>>>>>        Get psDriverID to sDriverID
76288>>>>>>>>>>>>>        
76288>>>>>>>>>>>>>        Move 0 to iRetval
76289>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76289>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76289>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76289>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76290>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76295>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76296>>>>>>>>>>>>>        
76296>>>>>>>>>>>>>        Function_Return iRetval
76297>>>>>>>>>>>>>    End_Function
76298>>>>>>>>>>>>>    
76298>>>>>>>>>>>>>    
76298>>>>>>>>>>>>>    
76298>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76298>>>>>>>>>>>>>    //
76298>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76298>>>>>>>>>>>>>    //
76298>>>>>>>>>>>>>    
76298>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76300>>>>>>>>>>>>>        Integer iPartRev
76300>>>>>>>>>>>>>        Integer iCurrentPart
76300>>>>>>>>>>>>>        Integer iSeparatorPos
76300>>>>>>>>>>>>>        
76300>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76303>>>>>>>>>>>>>        
76303>>>>>>>>>>>>>        Move 0 to iCurrentPart
76304>>>>>>>>>>>>>        Repeat
76304>>>>>>>>>>>>>>
76304>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76305>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76307>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76308>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76309>>>>>>>>>>>>>                Increment iCurrentPart
76310>>>>>>>>>>>>>            End
76310>>>>>>>>>>>>>>
76310>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76313>>>>>>>>>>>>>                Move sRevision to iPartRev
76314>>>>>>>>>>>>>                Move "" to sRevision
76315>>>>>>>>>>>>>                Increment iCurrentPart
76316>>>>>>>>>>>>>            End
76316>>>>>>>>>>>>>>
76316>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76318>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76320>>>>>>>>>>>>>        
76320>>>>>>>>>>>>>        Function_Return iPartRev
76321>>>>>>>>>>>>>    End_Function
76322>>>>>>>>>>>>>    
76322>>>>>>>>>>>>>    
76322>>>>>>>>>>>>>    
76322>>>>>>>>>>>>>    //
76322>>>>>>>>>>>>>    //  Returns the major revision of the CK
76322>>>>>>>>>>>>>    //
76322>>>>>>>>>>>>>    
76322>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76324>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76325>>>>>>>>>>>>>    End_Function
76326>>>>>>>>>>>>>    
76326>>>>>>>>>>>>>    
76326>>>>>>>>>>>>>    
76326>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76326>>>>>>>>>>>>>    //
76326>>>>>>>>>>>>>    
76326>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76328>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76329>>>>>>>>>>>>>    End_Function
76330>>>>>>>>>>>>>    
76330>>>>>>>>>>>>>    
76330>>>>>>>>>>>>>    //  Returns the release revision of the CK
76330>>>>>>>>>>>>>    //
76330>>>>>>>>>>>>>    
76330>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76332>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76333>>>>>>>>>>>>>    End_Function
76334>>>>>>>>>>>>>    
76334>>>>>>>>>>>>>    
76334>>>>>>>>>>>>>    //  Returns the major revision of the CK
76334>>>>>>>>>>>>>    //
76334>>>>>>>>>>>>>    
76334>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76336>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76337>>>>>>>>>>>>>    End_Function
76338>>>>>>>>>>>>>    
76338>>>>>>>>>>>>>    
76338>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76338>>>>>>>>>>>>>    //
76338>>>>>>>>>>>>>    
76338>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76340>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76343>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76346>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76349>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76352>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76355>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76359>>>>>>>>>>>>>            End
76359>>>>>>>>>>>>>>
76359>>>>>>>>>>>>>        End
76359>>>>>>>>>>>>>>
76359>>>>>>>>>>>>>        
76359>>>>>>>>>>>>>        Function_Return (False)
76360>>>>>>>>>>>>>    End_Function
76361>>>>>>>>>>>>>    
76361>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76361>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76361>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76361>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76361>>>>>>>>>>>>>    //
76361>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76361>>>>>>>>>>>>>    //   in the following format:
76361>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76361>>>>>>>>>>>>>    //   possible values for <type>:
76361>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76361>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76361>>>>>>>>>>>>>    //       C for client cache engine
76361>>>>>>>>>>>>>    //       D for DOS workstation
76361>>>>>>>>>>>>>    //       N for client Requester
76361>>>>>>>>>>>>>    //       S for NetWare server
76361>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76361>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76361>>>>>>>>>>>>>    //
76361>>>>>>>>>>>>>    //   example:
76361>>>>>>>>>>>>>    //       8.50.T
76361>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76361>>>>>>>>>>>>>    //   32-bits Windows server.
76361>>>>>>>>>>>>>    //
76361>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76361>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76361>>>>>>>>>>>>>    //
76361>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76361>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76361>>>>>>>>>>>>>    
76361>>>>>>>>>>>>>    //  Returns the version information of the
76361>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76361>>>>>>>>>>>>>    
76361>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76363>>>>>>>>>>>>>        
76363>>>>>>>>>>>>>        String  sDriverID
76363>>>>>>>>>>>>>        String  sVersion
76363>>>>>>>>>>>>>        String  sVoid
76363>>>>>>>>>>>>>        Integer iRetval
76363>>>>>>>>>>>>>        
76363>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76363>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76363>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76363>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76364>>>>>>>>>>>>>        Get psDriverID to sDriverID
76365>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76366>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76371>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76372>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76374>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76374>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76375>>>>>>>>>>>>>        End
76375>>>>>>>>>>>>>>
76375>>>>>>>>>>>>>        Function_Return sVersion
76376>>>>>>>>>>>>>    End_Function
76377>>>>>>>>>>>>>    
76377>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76377>>>>>>>>>>>>>    
76377>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76379>>>>>>>>>>>>>        
76379>>>>>>>>>>>>>        String  sDriverID
76379>>>>>>>>>>>>>        String  sVersion
76379>>>>>>>>>>>>>        String  sVoid
76379>>>>>>>>>>>>>        Integer iRetval
76379>>>>>>>>>>>>>        
76379>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76379>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76379>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76379>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76380>>>>>>>>>>>>>        Get psDriverID to sDriverID
76381>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76382>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76387>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76388>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76390>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76390>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76391>>>>>>>>>>>>>        End
76391>>>>>>>>>>>>>>
76391>>>>>>>>>>>>>        Function_Return sVersion
76392>>>>>>>>>>>>>    End_Function
76393>>>>>>>>>>>>>    
76393>>>>>>>>>>>>>    //  Returns the version information of the
76393>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76393>>>>>>>>>>>>>    
76393>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76395>>>>>>>>>>>>>        
76395>>>>>>>>>>>>>        String  sDriverID
76395>>>>>>>>>>>>>        String  sVersion
76395>>>>>>>>>>>>>        String  sVoid
76395>>>>>>>>>>>>>        Integer iRetval
76395>>>>>>>>>>>>>        
76395>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76395>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76395>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76395>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76396>>>>>>>>>>>>>        Get psDriverID to sDriverID
76397>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76398>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76403>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76404>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76406>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76406>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76407>>>>>>>>>>>>>        End
76407>>>>>>>>>>>>>>
76407>>>>>>>>>>>>>        Function_Return sVersion
76408>>>>>>>>>>>>>    End_Function
76409>>>>>>>>>>>>>    
76409>>>>>>>>>>>>>End_Class
76410>>>>>>>>>>>>>
76410>>>>>>>>>>>>>
76410>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76410>>>>>>>>>>>>>//****************************************************************************
76410>>>>>>>>>>>>>// $Module type: Include file
76410>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76410>>>>>>>>>>>>>//
76410>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76410>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76410>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76410>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76410>>>>>>>>>>>>>//
76410>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76410>>>>>>>>>>>>>//
76410>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76410>>>>>>>>>>>>>//
76410>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76410>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76410>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76410>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76410>>>>>>>>>>>>>// in the help folder for more details.
76410>>>>>>>>>>>>>//
76410>>>>>>>>>>>>>Use Winkern.pkg
76410>>>>>>>>>>>>>Use cIniFile.pkg
76410>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCryptographerEx.pkg)
76410>>>>>>>>>>>>>>>Use VdfBase.pkg
76410>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 23.0\Pkg\CryptographerConstants.pkg)
76410>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76410>>>>>>>>>>>>>>>>>// Algorithm classes
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76410>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Algorithm types
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76410>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Generic sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// RSA sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// DSS sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// DES sub_ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76410>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76410>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76410>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76410>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76410>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76410>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76410>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76410>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76410>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// RC2 sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76410>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76410>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Hash sub ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76410>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76410>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76410>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76410>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76410>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76410>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// secure channel sub ids
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76410>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76410>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76410>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76410>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76410>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76410>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76410>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76410>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76410>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76410>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76410>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76410>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76410>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76410>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76410>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76410>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76410>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76410>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76410>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76410>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76410>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76410>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76410>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76410>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76410>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76410>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76410>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76410>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76410>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76410>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76410>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76410>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76410>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76410>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76410>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76410>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76410>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76410>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76410>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76410>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76410>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76410>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76410>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76410>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76410>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76410>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76410>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Providers
76410>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76410>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76410>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76410>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76410>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76410>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76410>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76410>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76410>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76410>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76410>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76410>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76410>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76410>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76410>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76410>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76410>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76410>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76410>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76410>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76410>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76410>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76410>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76410>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76410>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Provider types
76410>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76410>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76410>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76410>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76410>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76410>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76410>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76410>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76410>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76410>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76410>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76410>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76410>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76410>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76410>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76410>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76410>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76410>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// KP_MODE
76410>>>>>>>>>>>>>>>>>// KP_MODE
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76410>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76410>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76410>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76410>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76410>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76410>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76410>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76410>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76410>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76410>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76410>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76410>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76410>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76410>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76410>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76410>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76410>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76410>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76410>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76410>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76410>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76410>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76410>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76410>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76410>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76410>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76410>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76410>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76410>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76410>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76410>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76410>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76410>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76410>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76410>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76410>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76410>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76410>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76410>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76410>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76410>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76410>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76410>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76410>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76410>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76410>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76410>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// key BLOB types
76410>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76410>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76410>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76410>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76410>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76410>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76410>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76410>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// KP_PADDING
76410>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76410>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76410>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76410>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76410>>>>>>>>>>>>>>>>>    UChar    bType
76410>>>>>>>>>>>>>>>>>    UChar    bVersion
76410>>>>>>>>>>>>>>>>>    UShort   reserved
76410>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76410>>>>>>>>>>>>>>>>>End_Struct
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76410>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76410>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76410>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76410>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76410>>>>>>>>>>>>>>>>>End_Struct
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76410>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76410>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76410>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76410>>>>>>>>>>>>>>>>>    DWord cbInnerString
76410>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76410>>>>>>>>>>>>>>>>>    DWord cbOuterString
76410>>>>>>>>>>>>>>>>>End_Struct
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76410>>>>>>>>>>>>>>>>>    UChar   bType
76410>>>>>>>>>>>>>>>>>    UChar   bVersion
76410>>>>>>>>>>>>>>>>>    Short   reserved
76410>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76410>>>>>>>>>>>>>>>>>End_Struct
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>Struct CryptoBlob
76410>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76410>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76410>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76410>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76410>>>>>>>>>>>>>>>>>End_Struct
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>
76410>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76410>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76411>>>>>>>>>>>>>>>>>
76411>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76411>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76413>>>>>>>>>>>>>>>>>    
76413>>>>>>>>>>>>>>>>>    Boolean bResult
76413>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76413>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76414>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76415>>>>>>>>>>>>>>>>>    
76415>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76416>>>>>>>>>>>>>>>>>
76416>>>>>>>>>>>>>>>>>    Function_Return bResult
76417>>>>>>>>>>>>>>>>>End_Function
76418>>>>>>>>>>>>>>>>>
76418>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76419>>>>>>>>>>>>>>>>>
76419>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76420>>>>>>>>>>>>>>>>>
76420>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76421>>>>>>>>>>>>>>>>>
76421>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76422>>>>>>>>>>>>>>>>>
76422>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76423>>>>>>>>>>>>>>>>>
76423>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76424>>>>>>>>>>>>>>>>>
76424>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76425>>>>>>>>>>>>>>>>>
76425>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76426>>>>>>>>>>>>>>>>>
76426>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76427>>>>>>>>>>>>>>>>>    
76427>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76428>>>>>>>>>>>>>>>>>
76428>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76429>>>>>>>>>>>>>>>>>
76429>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76430>>>>>>>>>>>>>>>>>
76430>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76431>>>>>>>>>>>>>>>>>    
76431>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76432>>>>>>>>>>>>>>>>>    
76432>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76433>>>>>>>>>>>>>>>>>    
76433>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76434>>>>>>>>>>>>>>>
76434>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76435>>>>>>>>>>>>>>>    
76435>>>>>>>>>>>>>>>    Procedure Construct_Object
76437>>>>>>>>>>>>>>>        Forward Send Construct_Object
76439>>>>>>>>>>>>>>>        
76439>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76440>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76441>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76442>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76443>>>>>>>>>>>>>>>        
76443>>>>>>>>>>>>>>>        // Private properties
76443>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76444>>>>>>>>>>>>>>>        
76444>>>>>>>>>>>>>>>        // Block cipher properties
76444>>>>>>>>>>>>>>>        Property UChar[]    paKey
76445>>>>>>>>>>>>>>>        Property UChar[]    paIV
76446>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76447>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76448>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76449>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76450>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76451>>>>>>>>>>>>>>>    End_Procedure
76452>>>>>>>>>>>>>>>    
76452>>>>>>>>>>>>>>>    
76452>>>>>>>>>>>>>>>    // Acquire key container handle
76452>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76454>>>>>>>>>>>>>>>        Integer iProvider
76454>>>>>>>>>>>>>>>        WString wProvider
76454>>>>>>>>>>>>>>>        Handle hProv
76454>>>>>>>>>>>>>>>        Boolean bOk
76454>>>>>>>>>>>>>>>        Pointer pProv
76454>>>>>>>>>>>>>>>        
76454>>>>>>>>>>>>>>>        Move 0 to hProv
76455>>>>>>>>>>>>>>>        Get piProvider to iProvider
76456>>>>>>>>>>>>>>>        Get psProvider to wProvider
76457>>>>>>>>>>>>>>>        
76457>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76457>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76459>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76460>>>>>>>>>>>>>>>        End
76460>>>>>>>>>>>>>>>>
76460>>>>>>>>>>>>>>>        Else Begin
76461>>>>>>>>>>>>>>>            Move 0 to pProv
76462>>>>>>>>>>>>>>>        End
76462>>>>>>>>>>>>>>>>
76462>>>>>>>>>>>>>>>        
76462>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76462>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76463>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76465>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76466>>>>>>>>>>>>>>>        End
76466>>>>>>>>>>>>>>>>
76466>>>>>>>>>>>>>>>        
76466>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76468>>>>>>>>>>>>>>>            // Fallback to original
76468>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76469>>>>>>>>>>>>>>>            
76469>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76471>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76472>>>>>>>>>>>>>>>            End
76472>>>>>>>>>>>>>>>>
76472>>>>>>>>>>>>>>>        End
76472>>>>>>>>>>>>>>>>
76472>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76473>>>>>>>>>>>>>>>        
76473>>>>>>>>>>>>>>>        Function_Return hProv
76474>>>>>>>>>>>>>>>    End_Function
76475>>>>>>>>>>>>>>>    
76475>>>>>>>>>>>>>>>    // Releases key container handle
76475>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76477>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76478>>>>>>>>>>>>>>>    End_Function
76479>>>>>>>>>>>>>>>    
76479>>>>>>>>>>>>>>>    // Creates hash object
76479>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76481>>>>>>>>>>>>>>>        Integer iAlgorithm
76481>>>>>>>>>>>>>>>        Handle hHash
76481>>>>>>>>>>>>>>>        Boolean bOk
76481>>>>>>>>>>>>>>>        
76481>>>>>>>>>>>>>>>        Move 0 to hHash
76482>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76483>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76484>>>>>>>>>>>>>>>        
76484>>>>>>>>>>>>>>>        Function_Return hHash
76485>>>>>>>>>>>>>>>    End_Function
76486>>>>>>>>>>>>>>>    
76486>>>>>>>>>>>>>>>    // Destroys the hash object
76486>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76488>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76489>>>>>>>>>>>>>>>    End_Function
76490>>>>>>>>>>>>>>>    
76490>>>>>>>>>>>>>>>    // Adds data to hash object
76490>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76492>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76493>>>>>>>>>>>>>>>    End_Function
76494>>>>>>>>>>>>>>>    
76494>>>>>>>>>>>>>>>    // Generates session key
76494>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76496>>>>>>>>>>>>>>>        Integer iAlgorithm
76496>>>>>>>>>>>>>>>        Handle hKey
76496>>>>>>>>>>>>>>>        Boolean bOk
76496>>>>>>>>>>>>>>>        
76496>>>>>>>>>>>>>>>        Move 0 to hKey
76497>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76498>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76499>>>>>>>>>>>>>>>        
76499>>>>>>>>>>>>>>>        Function_Return hKey
76500>>>>>>>>>>>>>>>    End_Function
76501>>>>>>>>>>>>>>>    
76501>>>>>>>>>>>>>>>    // Imports a plain text key
76501>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76503>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76503>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76503>>>>>>>>>>>>>>>        Boolean   bSuccess
76503>>>>>>>>>>>>>>>        Handle    hKey
76503>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76503>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76504>>>>>>>>>>>>>>>        Integer iVoid
76504>>>>>>>>>>>>>>>        
76504>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76505>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76506>>>>>>>>>>>>>>>        
76506>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76507>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76508>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76509>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76510>>>>>>>>>>>>>>>        
76510>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76511>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76512>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76513>>>>>>>>>>>>>>>        
76513>>>>>>>>>>>>>>>        Move 0 to hKey
76514>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76515>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76517>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76518>>>>>>>>>>>>>>>        End
76518>>>>>>>>>>>>>>>>
76518>>>>>>>>>>>>>>>        
76518>>>>>>>>>>>>>>>        Function_Return hKey
76519>>>>>>>>>>>>>>>    End_Function
76520>>>>>>>>>>>>>>>    
76520>>>>>>>>>>>>>>>    // Destroys the key
76520>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76522>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76523>>>>>>>>>>>>>>>    End_Function
76524>>>>>>>>>>>>>>>    
76524>>>>>>>>>>>>>>>    // Retrieves key data
76524>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76526>>>>>>>>>>>>>>>        Integer iBuffer iLen
76526>>>>>>>>>>>>>>>        Boolean bOk
76526>>>>>>>>>>>>>>>        
76526>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76527>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76528>>>>>>>>>>>>>>>        Function_Return iBuffer
76529>>>>>>>>>>>>>>>    End_Function
76530>>>>>>>>>>>>>>>    
76530>>>>>>>>>>>>>>>    // Retrieves a hash value
76530>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76532>>>>>>>>>>>>>>>        UChar[] ucHash
76533>>>>>>>>>>>>>>>        Integer liResult
76533>>>>>>>>>>>>>>>        DWord   dwDataLen
76533>>>>>>>>>>>>>>>        
76533>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76534>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76535>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76538>>>>>>>>>>>>>>>        
76538>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76539>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76540>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76543>>>>>>>>>>>>>>>        
76543>>>>>>>>>>>>>>>        Function_Return ucHash
76544>>>>>>>>>>>>>>>    End_Function
76545>>>>>>>>>>>>>>>
76545>>>>>>>>>>>>>>>    // Encrypts data
76545>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76547>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76547>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76547>>>>>>>>>>>>>>>        Boolean bOk
76547>>>>>>>>>>>>>>>        
76547>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76548>>>>>>>>>>>>>>>        If (hProv) Begin
76550>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76551>>>>>>>>>>>>>>>            If (hHash) Begin
76553>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76554>>>>>>>>>>>>>>>                If (bOk) Begin
76556>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76557>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76558>>>>>>>>>>>>>>>                End
76558>>>>>>>>>>>>>>>>
76558>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76559>>>>>>>>>>>>>>>            End
76559>>>>>>>>>>>>>>>>
76559>>>>>>>>>>>>>>>            
76559>>>>>>>>>>>>>>>            If (hKey) Begin
76561>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76561>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76562>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76563>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76564>>>>>>>>>>>>>>>                
76564>>>>>>>>>>>>>>>                //  Reserve space in string
76564>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76566>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76567>>>>>>>>>>>>>>>                End
76567>>>>>>>>>>>>>>>>
76567>>>>>>>>>>>>>>>                
76567>>>>>>>>>>>>>>>                //  Call to really decrypt
76567>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76568>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76568>>>>>>>>>>>>>>>                //Move "" to sData
76568>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76568>>>>>>>>>>>>>>>                //End
76568>>>>>>>>>>>>>>>                
76568>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76569>>>>>>>>>>>>>>>            End 
76569>>>>>>>>>>>>>>>>
76569>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76570>>>>>>>>>>>>>>>        End 
76570>>>>>>>>>>>>>>>>
76570>>>>>>>>>>>>>>>        Function_Return ucData
76571>>>>>>>>>>>>>>>    End_Function
76572>>>>>>>>>>>>>>>    
76572>>>>>>>>>>>>>>>    // Decrypts data
76572>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76574>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76574>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76574>>>>>>>>>>>>>>>        Boolean bOk
76574>>>>>>>>>>>>>>>        
76574>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76575>>>>>>>>>>>>>>>        If (hProv) Begin
76577>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76578>>>>>>>>>>>>>>>            If (hHash) Begin
76580>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76581>>>>>>>>>>>>>>>                If (bOk) Begin
76583>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76584>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76585>>>>>>>>>>>>>>>                End
76585>>>>>>>>>>>>>>>>
76585>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76586>>>>>>>>>>>>>>>            End
76586>>>>>>>>>>>>>>>>
76586>>>>>>>>>>>>>>>            
76586>>>>>>>>>>>>>>>            If (hKey) Begin
76588>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76589>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76590>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76590>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76592>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76593>>>>>>>>>>>>>>>                End
76593>>>>>>>>>>>>>>>>
76593>>>>>>>>>>>>>>>                
76593>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76594>>>>>>>>>>>>>>>            End
76594>>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76595>>>>>>>>>>>>>>>        End
76595>>>>>>>>>>>>>>>>
76595>>>>>>>>>>>>>>>        Function_Return ucData
76596>>>>>>>>>>>>>>>    End_Function
76597>>>>>>>>>>>>>>>    
76597>>>>>>>>>>>>>>>    // Creates a key
76597>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76599>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76599>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76599>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76599>>>>>>>>>>>>>>>        Boolean bOk
76599>>>>>>>>>>>>>>>        Handle hKey
76599>>>>>>>>>>>>>>>        UChar[] aKey
76600>>>>>>>>>>>>>>>
76600>>>>>>>>>>>>>>>        Get paKey to aKey
76601>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76602>>>>>>>>>>>>>>>        Get piKeyType to iType
76603>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76604>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76605>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76606>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76607>>>>>>>>>>>>>>>        
76607>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76608>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76614>>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76615>>>>>>>>>>>>>>>        Loop
76616>>>>>>>>>>>>>>>>
76616>>>>>>>>>>>>>>>        
76616>>>>>>>>>>>>>>>        Move 0 to hKey
76617>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76618>>>>>>>>>>>>>>>        Function_Return hKey
76619>>>>>>>>>>>>>>>    End_Function
76620>>>>>>>>>>>>>>>    
76620>>>>>>>>>>>>>>>    // Sets the key parameters
76620>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76622>>>>>>>>>>>>>>>        Integer iPadding iMode
76622>>>>>>>>>>>>>>>        Boolean bOk
76622>>>>>>>>>>>>>>>        UChar[] aIV
76623>>>>>>>>>>>>>>>        
76623>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76623>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76623>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76623>>>>>>>>>>>>>>>        //Loop
76623>>>>>>>>>>>>>>>
76623>>>>>>>>>>>>>>>        // Set initialization vector
76623>>>>>>>>>>>>>>>        Get paIV to aIV
76624>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76625>>>>>>>>>>>>>>>        If (bOk) Begin
76627>>>>>>>>>>>>>>>            // Set padding
76627>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76628>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76629>>>>>>>>>>>>>>>            If (bOk) Begin
76631>>>>>>>>>>>>>>>                // Set move
76631>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76632>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76633>>>>>>>>>>>>>>>            End
76633>>>>>>>>>>>>>>>>
76633>>>>>>>>>>>>>>>        End
76633>>>>>>>>>>>>>>>>
76633>>>>>>>>>>>>>>>        Function_Return bOk        
76634>>>>>>>>>>>>>>>    End_Function
76635>>>>>>>>>>>>>>>    
76635>>>>>>>>>>>>>>>    // Encrypts using block cipher
76635>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76637>>>>>>>>>>>>>>>        Handle hProv hKey
76637>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76637>>>>>>>>>>>>>>>        Boolean bOk
76637>>>>>>>>>>>>>>>        
76637>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76638>>>>>>>>>>>>>>>        If (hProv) Begin
76640>>>>>>>>>>>>>>>            // Create key
76640>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76641>>>>>>>>>>>>>>>            If (hKey) Begin
76643>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76644>>>>>>>>>>>>>>>                If (bOk) Begin
76646>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76646>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76647>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76648>>>>>>>>>>>>>>>                    
76648>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76649>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76650>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76651>>>>>>>>>>>>>>>                End
76651>>>>>>>>>>>>>>>>
76651>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76652>>>>>>>>>>>>>>>            End
76652>>>>>>>>>>>>>>>>
76652>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76653>>>>>>>>>>>>>>>        End
76653>>>>>>>>>>>>>>>>
76653>>>>>>>>>>>>>>>        Function_Return ucData
76654>>>>>>>>>>>>>>>    End_Function
76655>>>>>>>>>>>>>>>    
76655>>>>>>>>>>>>>>>    // Decrypts using block cipher
76655>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76657>>>>>>>>>>>>>>>        Handle hProv hKey
76657>>>>>>>>>>>>>>>        Integer iLen
76657>>>>>>>>>>>>>>>        Boolean bOk
76657>>>>>>>>>>>>>>>        
76657>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76658>>>>>>>>>>>>>>>        If (hProv) Begin
76660>>>>>>>>>>>>>>>            // Create key
76660>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76661>>>>>>>>>>>>>>>            If (hKey) Begin
76663>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76664>>>>>>>>>>>>>>>                If (bOk) Begin
76666>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76667>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76668>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76669>>>>>>>>>>>>>>>                End
76669>>>>>>>>>>>>>>>>
76669>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76670>>>>>>>>>>>>>>>            End
76670>>>>>>>>>>>>>>>>
76670>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76671>>>>>>>>>>>>>>>        End
76671>>>>>>>>>>>>>>>>
76671>>>>>>>>>>>>>>>        Function_Return ucData
76672>>>>>>>>>>>>>>>    End_Function
76673>>>>>>>>>>>>>>>    
76673>>>>>>>>>>>>>>>    
76673>>>>>>>>>>>>>>>    //  Generates random data.
76673>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76675>>>>>>>>>>>>>>>        Handle hProv
76675>>>>>>>>>>>>>>>        UChar[] uaResult
76676>>>>>>>>>>>>>>>        Boolean bRes
76676>>>>>>>>>>>>>>>        
76676>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76677>>>>>>>>>>>>>>>        
76677>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76678>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76679>>>>>>>>>>>>>>>        
76679>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76680>>>>>>>>>>>>>>>        
76680>>>>>>>>>>>>>>>        Function_Return uaResult
76681>>>>>>>>>>>>>>>    End_Function
76682>>>>>>>>>>>>>>>    
76682>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76682>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76684>>>>>>>>>>>>>>>        String sResult
76684>>>>>>>>>>>>>>>        UChar[] ucData
76685>>>>>>>>>>>>>>>        Pointer pBase64
76685>>>>>>>>>>>>>>>        Integer iVoid
76685>>>>>>>>>>>>>>>        
76685>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76686>>>>>>>>>>>>>>>        
76686>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76687>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76688>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76689>>>>>>>>>>>>>>>        
76689>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76690>>>>>>>>>>>>>>>    End_Function
76691>>>>>>>>>>>>>>>    
76691>>>>>>>>>>>>>>>End_Class
76692>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76692>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76692>>>>>>>>>>>>>>>//>
76692>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76692>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76692>>>>>>>>>>>>>>>//>
76692>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76692>>>>>>>>>>>>>>>//> strings.
76692>>>>>>>>>>>>>>>//>
76692>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76692>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76692>>>>>>>>>>>>>>>//>
76692>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76692>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76692>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76692>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76692>>>>>>>>>>>>>>>
76692>>>>>>>>>>>>>>>Use VdfBase.pkg
76692>>>>>>>>>>>>>>>
76692>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76692>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76693>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76694>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76695>>>>>>>>>>>>>>>
76695>>>>>>>>>>>>>>>// Structure
76695>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76695>>>>>>>>>>>>>>>    Pointer pData
76695>>>>>>>>>>>>>>>    Integer iLength
76695>>>>>>>>>>>>>>>End_Struct 
76695>>>>>>>>>>>>>>>
76695>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76695>>>>>>>>>>>>>>>
76695>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76697>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76698>>>>>>>>>>>>>>>
76698>>>>>>>>>>>>>>>
76698>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76701>>>>>>>>>>>>>>>        Address pBase64
76701>>>>>>>>>>>>>>>        String sResult
76701>>>>>>>>>>>>>>>        Integer iVoid
76701>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76702>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76703>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76704>>>>>>>>>>>>>>>        Function_Return sResult
76705>>>>>>>>>>>>>>>    End_Function
76706>>>>>>>>>>>>>>>
76706>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76709>>>>>>>>>>>>>>>        Address pBinary
76709>>>>>>>>>>>>>>>        String sBinary
76709>>>>>>>>>>>>>>>        Integer iVoid iLen
76709>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76710>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76711>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76712>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76713>>>>>>>>>>>>>>>        Function_Return sBinary
76714>>>>>>>>>>>>>>>    End_Function
76715>>>>>>>>>>>>>>>
76715>>>>>>>>>>>>>>>End_Object
76716>>>>>>>>>>>>>Use MSSqldrv.pkg
76716>>>>>>>>>>>>>Use db2_drv.pkg
76716>>>>>>>>>>>>>Use odbc_drv.pkg
76716>>>>>>>>>>>>>Use DFBtrDrv.pkg
76716>>>>>>>>>>>>>Use vWin32fh.pkg
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76716>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76716>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76716>>>>>>>>>>>>>// Note: If a new type is added to the list,
76716>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76716>>>>>>>>>>>>>//       so that it is filled with all SQL
76716>>>>>>>>>>>>>//       keywords for that new type.
76716>>>>>>>>>>>>>Enum_List  
76716>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76716>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76716>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76716>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76716>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76716>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76716>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76716>>>>>>>>>>>>>End_Enum_List
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76716>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76716>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76716>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76716>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76716>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76716>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76716>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76716>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76716>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// SQLConnection.ini constants:
76716>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76716>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76716>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76716>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// DF 19 ini-file settings:
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76716>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76716>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76716>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76716>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76716>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76716>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76716>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76716>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76716>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76716>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// Database Update Framework extended settings:
76716>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76716>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76716>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76716>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76716>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76716>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76716>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76716>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>Struct tSQLConnection
76716>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76716>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76716>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76716>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76716>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76716>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76716>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76716>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76716>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76716>>>>>>>>>>>>>    String sPassword                // 10. Password
76716>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76716>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76716>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76716>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76716>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76716>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76716>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76716>>>>>>>>>>>>>End_Struct
76716>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76716>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76716>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76716>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76716>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSQLScriptArray
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76717>>>>>>>>>>>>>    Integer iOrgArgumentSize
76717>>>>>>>>>>>>>    String[] sSQLScriptArray
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSqlErrorArray
76717>>>>>>>>>>>>>    String[]  sSqlErrorArray
76717>>>>>>>>>>>>>    String[]  sSqlStatementArray
76717>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSqlColumnNew
76717>>>>>>>>>>>>>    String  sBaseColumnName
76717>>>>>>>>>>>>>    String  sBaseTableName
76717>>>>>>>>>>>>>    String  sLabel
76717>>>>>>>>>>>>>    Integer iSqlType
76717>>>>>>>>>>>>>    Integer iSize
76717>>>>>>>>>>>>>    Integer iPrecision
76717>>>>>>>>>>>>>    Integer iDFType
76717>>>>>>>>>>>>>    Integer iDFNativeType
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tColumnType
76717>>>>>>>>>>>>>    String  sSQLType
76717>>>>>>>>>>>>>    Integer iSQLType
76717>>>>>>>>>>>>>    Boolean bCanEditSize
76717>>>>>>>>>>>>>    Integer iDefaultSize
76717>>>>>>>>>>>>>    Integer iMinSize
76717>>>>>>>>>>>>>    Number  nMaxSize
76717>>>>>>>>>>>>>    String  sDataFlexType
76717>>>>>>>>>>>>>    Integer iDataFlexType
76717>>>>>>>>>>>>>    Boolean bNativeDataType
76717>>>>>>>>>>>>>    String  sPrecision
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76717>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76717>>>>>>>>>>>>>// keywords.
76717>>>>>>>>>>>>>Struct tSQLKeyWords
76717>>>>>>>>>>>>>    Integer iSQLWord
76717>>>>>>>>>>>>>    Integer iSQLDbType
76717>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSQLRelation
76717>>>>>>>>>>>>>    Integer iFileNumber
76717>>>>>>>>>>>>>    Integer iFieldNumber
76717>>>>>>>>>>>>>    String  sFileName
76717>>>>>>>>>>>>>    String  sFieldName
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSQLLoggedInUser
76717>>>>>>>>>>>>>    String sUser
76717>>>>>>>>>>>>>    String sProgram
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76717>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76717>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76717>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76717>>>>>>>>>>>>>// Note: If a new type is added to the list,
76717>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76717>>>>>>>>>>>>>//       so that it is filled with all SQL
76717>>>>>>>>>>>>>//       keywords for that new type.
76717>>>>>>>>>>>>>Enum_List
76717>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76717>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76717>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76717>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76717>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76717>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76717>>>>>>>>>>>>>End_Enum_List
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76717>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76717>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76717>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76717>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76717>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76717>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76717>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76717>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76717>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76717>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76717>>>>>>>>>>>>>Enum_List
76717>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76717>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76717>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76717>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76717>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76717>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76717>>>>>>>>>>>>>End_Enum_List
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76717>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76717>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// These are not defined pre DF 18:
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSQLIntTableInfo
76717>>>>>>>>>>>>>    String sDriverName
76717>>>>>>>>>>>>>    String sServerName
76717>>>>>>>>>>>>>    String sDatabaseName
76717>>>>>>>>>>>>>    String sSchemaName
76717>>>>>>>>>>>>>    Boolean bRecnumTable
76717>>>>>>>>>>>>>    Integer iPrimaryIndex
76717>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76717>>>>>>>>>>>>>    String sTableCharacterFormat
76717>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76717>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76717>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76717>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76717>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76717>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76717>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76717>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76717>>>>>>>>>>>>>    String sFileIndexTablespace
76717>>>>>>>>>>>>>    String sFileLongTablespace
76717>>>>>>>>>>>>>    String sTableTablespace
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76717>>>>>>>>>>>>>    Integer iFieldNumber
76717>>>>>>>>>>>>>    Integer iFieldIndex
76717>>>>>>>>>>>>>    Integer iFieldRelatedFile
76717>>>>>>>>>>>>>    Integer iFieldRelatedField
76717>>>>>>>>>>>>>    Integer iIndexNumber
76717>>>>>>>>>>>>>    Integer iIndexNumberSegments
76717>>>>>>>>>>>>>    Integer iIndexSegmentField1
76717>>>>>>>>>>>>>    Integer iIndexSegmentField2
76717>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76717>>>>>>>>>>>>>    String  sIndexName
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIColumn
76717>>>>>>>>>>>>>    Integer iFieldNumber
76717>>>>>>>>>>>>>    String  sFieldName
76717>>>>>>>>>>>>>    Integer iType
76717>>>>>>>>>>>>>    String  sType
76717>>>>>>>>>>>>>    Integer iLength
76717>>>>>>>>>>>>>    Integer iPrecision
76717>>>>>>>>>>>>>    Integer iOptions
76717>>>>>>>>>>>>>    Boolean bIsSQLType
76717>>>>>>>>>>>>>    Boolean bAllowNULL
76717>>>>>>>>>>>>>    String  sDefaultValue
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIColumnCompare
76717>>>>>>>>>>>>>    Integer iFieldNumber
76717>>>>>>>>>>>>>    // FROM database:
76717>>>>>>>>>>>>>    Boolean bExistsFrom
76717>>>>>>>>>>>>>    String  sFieldNameFrom
76717>>>>>>>>>>>>>    Integer iTypeFrom
76717>>>>>>>>>>>>>    String  sTypeFrom
76717>>>>>>>>>>>>>    Integer iLengthFrom
76717>>>>>>>>>>>>>    Integer iPrecisionFrom
76717>>>>>>>>>>>>>    Integer iOptionsFrom
76717>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76717>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76717>>>>>>>>>>>>>    String  sDefaultValueFrom
76717>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76717>>>>>>>>>>>>>    Boolean bCancelFrom
76717>>>>>>>>>>>>>    Boolean bErrorFrom
76717>>>>>>>>>>>>>    // TO database:
76717>>>>>>>>>>>>>    Boolean bExistsTo
76717>>>>>>>>>>>>>    Integer iFieldNumberTo
76717>>>>>>>>>>>>>    String  sFieldNameTo
76717>>>>>>>>>>>>>    Integer iTypeTo
76717>>>>>>>>>>>>>    String  sTypeTo
76717>>>>>>>>>>>>>    Integer iLengthTo
76717>>>>>>>>>>>>>    Integer iPrecisionTo
76717>>>>>>>>>>>>>    Integer iOptionsTo
76717>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76717>>>>>>>>>>>>>    Boolean bAllowNULLTo
76717>>>>>>>>>>>>>    String  sDefaultValueTo
76717>>>>>>>>>>>>>    Boolean bShouldChangeTo
76717>>>>>>>>>>>>>    Boolean bCancelTo
76717>>>>>>>>>>>>>    Boolean bErrorTo
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIRelation
76717>>>>>>>>>>>>>    Handle  hTableFrom
76717>>>>>>>>>>>>>    Integer iColumnFrom
76717>>>>>>>>>>>>>    Handle  hTableTo
76717>>>>>>>>>>>>>    Integer iColumnTo
76717>>>>>>>>>>>>>    String  sLogicalNameFrom
76717>>>>>>>>>>>>>    String  sLogicalNameTo
76717>>>>>>>>>>>>>    String  sFieldNameFrom
76717>>>>>>>>>>>>>    String  sFieldNameTo
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIRelationCompare
76717>>>>>>>>>>>>>    // Common:
76717>>>>>>>>>>>>>    Handle  hTableFrom
76717>>>>>>>>>>>>>    Integer iColumnFrom
76717>>>>>>>>>>>>>    Handle  hTableTo
76717>>>>>>>>>>>>>    Integer iColumnTo
76717>>>>>>>>>>>>>    // FROM database:
76717>>>>>>>>>>>>>    Boolean bExistsFrom
76717>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76717>>>>>>>>>>>>>    String  sLogicalNameTo_From
76717>>>>>>>>>>>>>    String  sFieldNameFrom_From
76717>>>>>>>>>>>>>    String  sFieldNameTo_From
76717>>>>>>>>>>>>>    Boolean bShouldChange_From
76717>>>>>>>>>>>>>    Boolean bCancel_From
76717>>>>>>>>>>>>>    Boolean bError_From
76717>>>>>>>>>>>>>    // TO database:
76717>>>>>>>>>>>>>    Boolean bExistsTo
76717>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76717>>>>>>>>>>>>>    String  sLogicalNameTo_To
76717>>>>>>>>>>>>>    String  sFieldNameFrom_To
76717>>>>>>>>>>>>>    String  sFieldNameTo_To
76717>>>>>>>>>>>>>    Boolean bShouldChange_To
76717>>>>>>>>>>>>>    Boolean bCancel_To
76717>>>>>>>>>>>>>    Boolean bError_To
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIIndexSegment
76717>>>>>>>>>>>>>    Integer iFieldNumber
76717>>>>>>>>>>>>>    String  sFieldName
76717>>>>>>>>>>>>>    Boolean bUppercase
76717>>>>>>>>>>>>>    Boolean bAscending
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIIndex
76717>>>>>>>>>>>>>    Integer iIndexNumber
76717>>>>>>>>>>>>>    Integer iPrimaryIndex
76717>>>>>>>>>>>>>    String  sSQLIndexName
76717>>>>>>>>>>>>>    Integer iSQLIndexType
76717>>>>>>>>>>>>>    Boolean bIsSQLClustered
76717>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPIIndexCompare
76717>>>>>>>>>>>>>    // Common:
76717>>>>>>>>>>>>>    Integer iIndexNumber
76717>>>>>>>>>>>>>    // FROM database:
76717>>>>>>>>>>>>>    Boolean bExistsFrom
76717>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76717>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76717>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76717>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76717>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76717>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76717>>>>>>>>>>>>>    Boolean bCancelFrom
76717>>>>>>>>>>>>>    Boolean bErrorFrom
76717>>>>>>>>>>>>>    // TO database:
76717>>>>>>>>>>>>>    Boolean bExistsTo
76717>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76717>>>>>>>>>>>>>    String  sSQLIndexNameTo
76717>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76717>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76717>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76717>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76717>>>>>>>>>>>>>    Boolean bShouldChangeTo
76717>>>>>>>>>>>>>    Boolean bCancelTo
76717>>>>>>>>>>>>>    Boolean bErrorTo
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPITableNameInfo
76717>>>>>>>>>>>>>    Integer iTableNumber
76717>>>>>>>>>>>>>    String  sRootName
76717>>>>>>>>>>>>>    String  sLogicalName
76717>>>>>>>>>>>>>    String  sDisplayName
76717>>>>>>>>>>>>>    String  sDriverID
76717>>>>>>>>>>>>>    Boolean bIsAlias
76717>>>>>>>>>>>>>    Boolean bIsSQL
76717>>>>>>>>>>>>>    Boolean bIsSystemFile
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76717>>>>>>>>>>>>>    Integer iTableNumber
76717>>>>>>>>>>>>>    // FROM
76717>>>>>>>>>>>>>    Boolean bExistsFrom
76717>>>>>>>>>>>>>    String  sRootNameFrom
76717>>>>>>>>>>>>>    String  sLogicalNameFrom
76717>>>>>>>>>>>>>    String  sDisplayNameFrom
76717>>>>>>>>>>>>>    String  sDriverIDFrom
76717>>>>>>>>>>>>>    Boolean bIsAliasFrom
76717>>>>>>>>>>>>>    Boolean bIsSQLFrom
76717>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76717>>>>>>>>>>>>>    // TO database:
76717>>>>>>>>>>>>>    Boolean bExistsTo
76717>>>>>>>>>>>>>    String  sRootNameTo
76717>>>>>>>>>>>>>    String  sLogicalNameTo
76717>>>>>>>>>>>>>    String  sDisplayNameTo
76717>>>>>>>>>>>>>    String  sDriverIDTo
76717>>>>>>>>>>>>>    Boolean bIsAliasTo
76717>>>>>>>>>>>>>    Boolean bIsSQLTo
76717>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPITable
76717>>>>>>>>>>>>>    Handle hTable
76717>>>>>>>>>>>>>    Boolean bFromTable
76717>>>>>>>>>>>>>    Boolean bToTable
76717>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76717>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76717>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76717>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76717>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76717>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76717>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76717>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76717>>>>>>>>>>>>>    Boolean bShouldChange
76717>>>>>>>>>>>>>    Boolean bCancel
76717>>>>>>>>>>>>>    Boolean bError
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPITableCompare
76717>>>>>>>>>>>>>    Handle hTable
76717>>>>>>>>>>>>>    // FROM database:
76717>>>>>>>>>>>>>    Boolean bExistsFrom
76717>>>>>>>>>>>>>    // TO database:
76717>>>>>>>>>>>>>    Boolean bExistsTo
76717>>>>>>>>>>>>>    // Both:
76717>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76717>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76717>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76717>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76717>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76717>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76717>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76717>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76717>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76717>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76717>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Struct tAPITableBooleans
76717>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76717>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76717>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76717>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76717>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76717>>>>>>>>>>>>>End_Struct
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76717>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76717>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76717>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76717>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76717>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76717>>>>>>>>>>>>>Enum_List
76717>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76717>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76717>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76717>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76717>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76717>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76717>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76717>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76717>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76717>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76717>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76717>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76717>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76717>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76717>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76717>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76717>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76717>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76717>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76717>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76717>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76717>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76717>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76717>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76717>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76717>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76717>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76717>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76717>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76717>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76717>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76717>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76717>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76717>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76717>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76717>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76717>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76717>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76717>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76717>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76717>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76717>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76717>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76717>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76717>>>>>>>>>>>>>End_Enum_List
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>>>
76717>>>>>>>>>>>
76717>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76718>>>>>>>>>>>
76718>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76720>>>>>>>>>>>        Handle hoSQLManagerMT
76720>>>>>>>>>>>
76720>>>>>>>>>>>        Property String private.psUseDatabase ""
76721>>>>>>>>>>>
76721>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76721>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76722>>>>>>>>>>>        Property Integer private.piCurrentField 0
76723>>>>>>>>>>>
76723>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76724>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76725>>>>>>>>>>>
76725>>>>>>>>>>>        Property Handle phoSQLManagerMT
76726>>>>>>>>>>>
76726>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76727>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76728>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76729>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76730>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76731>>>>>>>>>>>
76731>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76732>>>>>>>>>>>
76732>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76733>>>>>>>>>>>        Property String[] paSQLFetchResults
76734>>>>>>>>>>>
76734>>>>>>>>>>>        // Error handling
76734>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76735>>>>>>>>>>>        Property Boolean pbSqlError False
76736>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76737>>>>>>>>>>>        Property Boolean pbProcessingError False
76738>>>>>>>>>>>
76738>>>>>>>>>>>        // Statistics on query
76738>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76739>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76740>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76741>>>>>>>>>>>        Property Integer piColumns 0
76742>>>>>>>>>>>        Property Integer piRows 0
76743>>>>>>>>>>>        Property Integer piRowType 0
76744>>>>>>>>>>>        Property String[] paQueryMessages
76745>>>>>>>>>>>        Property String psSQLStatementString
76746>>>>>>>>>>>
76746>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76747>>>>>>>>>>>
76747>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76748>>>>>>>>>>>
76748>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76748>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76748>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76748>>>>>>>>>>>        Property Integer piChunkMax 500
76749>>>>>>>>>>>
76749>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76749>>>>>>>>>>>        Send SetupSQLKeywordArray
76750>>>>>>>>>>>    End_Procedure
76751>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76751>>>>>>>>>>>>
76751>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76753>>>>>>>>>>>>    Integer iStart iEnd
76753>>>>>>>>>>>>    String sRetval
76753>>>>>>>>>>>>
76753>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76754>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76755>>>>>>>>>>>>    If (iStart = 0) Begin
76757>>>>>>>>>>>>        Function_Return ""
76758>>>>>>>>>>>>    End
76758>>>>>>>>>>>>>
76758>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76759>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76760>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76762>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76763>>>>>>>>>>>>    End
76763>>>>>>>>>>>>>
76763>>>>>>>>>>>>    Else Begin
76764>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76765>>>>>>>>>>>>    End
76765>>>>>>>>>>>>>
76765>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76767>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76768>>>>>>>>>>>>        Decrement iEnd
76769>>>>>>>>>>>>    End
76769>>>>>>>>>>>>>
76769>>>>>>>>>>>>    If (iEnd <> 0) Begin
76771>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76772>>>>>>>>>>>>    End
76772>>>>>>>>>>>>>
76772>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76773>>>>>>>>>>>>
76773>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76774>>>>>>>>>>>>End_Function
76775>>>>>>>>>>>>
76775>>>>>>>>>>>>
76775>>>>>>>>>>>
76775>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76775>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76777>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76779>>>>>>>>>>>            Function_Return (EQ)
76780>>>>>>>>>>>        End
76780>>>>>>>>>>>>
76780>>>>>>>>>>>        Function_Return (GT)
76781>>>>>>>>>>>    End_Function
76782>>>>>>>>>>>
76782>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76782>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76784>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76787>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76790>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76793>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76796>>>>>>>>>>>
76796>>>>>>>>>>>        Function_Return (EQ)
76797>>>>>>>>>>>    End_Function
76798>>>>>>>>>>>
76798>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76800>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76800>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76801>>>>>>>>>>>        Integer iSize
76801>>>>>>>>>>>
76801>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76802>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76803>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76804>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76805>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76806>>>>>>>>>>>
76806>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76807>>>>>>>>>>>    End_Procedure
76808>>>>>>>>>>>
76808>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76808>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76808>>>>>>>>>>>    // have slightly different wording.
76808>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76808>>>>>>>>>>>    // needs to be done for every keyword group below.
76808>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76810>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76810>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76812>>>>>>>>>>>
76812>>>>>>>>>>>        // This should only be called once; but in case it is
76812>>>>>>>>>>>        // we delete the array first.
76812>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76813>>>>>>>>>>>
76813>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76813>>>>>>>>>>>        //
76813>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76814>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76815>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76818>>>>>>>>>>>
76818>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76819>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76820>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76821>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76822>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76823>>>>>>>>>>>
76823>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76824>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76825>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76826>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76827>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76828>>>>>>>>>>>
76828>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76829>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76830>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76831>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76832>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76833>>>>>>>>>>>
76833>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76834>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76835>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76836>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76837>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76838>>>>>>>>>>>
76838>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76839>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76840>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76841>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76842>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76843>>>>>>>>>>>
76843>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76844>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76845>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76846>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76847>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76848>>>>>>>>>>>
76848>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76849>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76850>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76851>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76852>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76853>>>>>>>>>>>
76853>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76854>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76855>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76856>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76857>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76858>>>>>>>>>>>
76858>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76859>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76860>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76861>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76862>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76863>>>>>>>>>>>
76863>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76864>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76865>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76866>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76867>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76868>>>>>>>>>>>
76868>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76869>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76870>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76871>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76872>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76873>>>>>>>>>>>
76873>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76876>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76877>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76878>>>>>>>>>>>
76878>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76879>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76880>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76881>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76882>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76883>>>>>>>>>>>
76883>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76884>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76885>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76886>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76887>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76888>>>>>>>>>>>
76888>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76889>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76890>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76891>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76892>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76893>>>>>>>>>>>
76893>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76894>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76895>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76896>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76897>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76898>>>>>>>>>>>
76898>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76899>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76900>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76901>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76902>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76903>>>>>>>>>>>
76903>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76904>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76905>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76906>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76907>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76908>>>>>>>>>>>
76908>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76909>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76910>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76911>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76912>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76913>>>>>>>>>>>
76913>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76914>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76915>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76916>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76917>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76918>>>>>>>>>>>
76918>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76919>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76920>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76921>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76922>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76923>>>>>>>>>>>
76923>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76924>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76925>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76926>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76927>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76928>>>>>>>>>>>
76928>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76929>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76930>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76931>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76932>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76933>>>>>>>>>>>
76933>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76934>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76935>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76936>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76937>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76938>>>>>>>>>>>
76938>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76939>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76940>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76941>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76942>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76943>>>>>>>>>>>
76943>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76944>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76945>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76946>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76947>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76948>>>>>>>>>>>
76948>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76949>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76950>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76951>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76952>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76953>>>>>>>>>>>
76953>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76954>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76955>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76956>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76957>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76958>>>>>>>>>>>
76958>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76959>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76960>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76961>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76962>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76963>>>>>>>>>>>
76963>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76964>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76965>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76966>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76967>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76968>>>>>>>>>>>
76968>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76969>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76970>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76971>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76972>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76973>>>>>>>>>>>
76973>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76974>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76975>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76976>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76977>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76978>>>>>>>>>>>
76978>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76979>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76980>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76981>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76982>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76983>>>>>>>>>>>
76983>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76984>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76985>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76986>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76987>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76988>>>>>>>>>>>
76988>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76989>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76990>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76991>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76992>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76993>>>>>>>>>>>
76993>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76994>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76995>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76996>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76997>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76998>>>>>>>>>>>
76998>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76999>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
77000>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
77001>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
77002>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
77003>>>>>>>>>>>
77003>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
77004>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
77005>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
77006>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
77007>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
77008>>>>>>>>>>>
77008>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
77009>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
77010>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
77011>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
77012>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
77013>>>>>>>>>>>
77013>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
77014>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
77015>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
77016>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
77017>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
77018>>>>>>>>>>>
77018>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
77019>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
77020>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
77021>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
77022>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
77023>>>>>>>>>>>
77023>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
77024>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
77025>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
77026>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
77027>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
77028>>>>>>>>>>>
77028>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
77029>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
77030>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
77031>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
77032>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
77033>>>>>>>>>>>
77033>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
77033>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77034>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
77035>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
77036>>>>>>>>>>>
77036>>>>>>>>>>>    End_Procedure
77037>>>>>>>>>>>
77037>>>>>>>>>>>End_Class
77038>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
77038>>>>>>>>>>>//****************************************************************************
77038>>>>>>>>>>>// $Module type: Class
77038>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
77038>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
77038>>>>>>>>>>>// Web-site    : http://www.rdctools.com
77038>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
77038>>>>>>>>>>>//
77038>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
77038>>>>>>>>>>>//
77038>>>>>>>>>>>// $Rev History:
77038>>>>>>>>>>>//    2015-08-11  Module header created
77038>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
77038>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
77038>>>>>>>>>>>//                Added better error handling.
77038>>>>>>>>>>>//                Added a decompose message for the connection string.
77038>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
77038>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
77038>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
77038>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
77038>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
77038>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
77038>>>>>>>>>>>//****************************************************************************
77038>>>>>>>>>>>Use cli.pkg
77038>>>>>>>>>>>Use MSSqldrv.pkg
77038>>>>>>>>>>>Use db2_drv.pkg
77038>>>>>>>>>>>Use odbc_drv.pkg
77038>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
77038>>>>>>>>>>>>>//****************************************************************************
77038>>>>>>>>>>>>>// $Module type: Class
77038>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
77038>>>>>>>>>>>>>//
77038>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
77038>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
77038>>>>>>>>>>>>>// E-mail      : support@rdctools.com
77038>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
77038>>>>>>>>>>>>>//
77038>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
77038>>>>>>>>>>>>>//
77038>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
77038>>>>>>>>>>>>>//               properties of that object.
77038>>>>>>>>>>>>>//
77038>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
77038>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
77038>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
77038>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
77038>>>>>>>>>>>>>// in the help folder for more details.
77038>>>>>>>>>>>>>//
77038>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
77038>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
77038>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
77038>>>>>>>>>>>>>>>
77038>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
77039>>>>>>>>>>>>>>>    Procedure Construct_Object
77041>>>>>>>>>>>>>>>        Forward Send Construct_Object
77043>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77044>>>>>>>>>>>>>>>    End_Procedure
77045>>>>>>>>>>>>>>>
77045>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77047>>>>>>>>>>>>>>>        String sRetval
77047>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
77049>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
77050>>>>>>>>>>>>>>>        End                                        
77050>>>>>>>>>>>>>>>>
77050>>>>>>>>>>>>>>>        Else Begin
77051>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
77052>>>>>>>>>>>>>>>        End
77052>>>>>>>>>>>>>>>>
77052>>>>>>>>>>>>>>>            
77052>>>>>>>>>>>>>>>        Function_Return sRetval
77053>>>>>>>>>>>>>>>    End_Function
77054>>>>>>>>>>>>>>>
77054>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77056>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
77056>>>>>>>>>>>>>>>
77056>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77057>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
77058>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
77059>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
77061>>>>>>>>>>>>>>>            Move "" to sDatabase
77062>>>>>>>>>>>>>>>        End
77062>>>>>>>>>>>>>>>>
77062>>>>>>>>>>>>>>>        
77062>>>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
77062>>>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
77062>>>>>>>>>>>>>>>//            Function_Return sConnect
77062>>>>>>>>>>>>>>>//        End
77062>>>>>>>>>>>>>>>
77062>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77064>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77065>>>>>>>>>>>>>>>        End
77065>>>>>>>>>>>>>>>>
77065>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77067>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77068>>>>>>>>>>>>>>>        End
77068>>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>        Else Begin
77069>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77070>>>>>>>>>>>>>>>        End
77070>>>>>>>>>>>>>>>>
77070>>>>>>>>>>>>>>>        Function_Return sConnect
77071>>>>>>>>>>>>>>>    End_Function
77072>>>>>>>>>>>>>>>
77072>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77074>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77074>>>>>>>>>>>>>>>        String sDriverID
77074>>>>>>>>>>>>>>>
77074>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77075>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77077>>>>>>>>>>>>>>>            Function_Return True
77078>>>>>>>>>>>>>>>        End
77078>>>>>>>>>>>>>>>>
77078>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77079>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77081>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77082>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77084>>>>>>>>>>>>>>>        End
77084>>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>        Else Begin
77085>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77087>>>>>>>>>>>>>>>        End
77087>>>>>>>>>>>>>>>>
77087>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77088>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77089>>>>>>>>>>>>>>>    End_Function
77090>>>>>>>>>>>>>>>End_Class
77091>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77092>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77094>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77095>>>>>>>>>>>>>>>    End_Function
77096>>>>>>>>>>>>>>>End_Class
77097>>>>>>>>>>>>>>>
77097>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77098>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77100>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77100>>>>>>>>>>>>>>>        String sDriverID
77100>>>>>>>>>>>>>>>
77100>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77101>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77102>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77104>>>>>>>>>>>>>>>            Function_Return True
77105>>>>>>>>>>>>>>>        End
77105>>>>>>>>>>>>>>>>
77105>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77106>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77108>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77110>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77111>>>>>>>>>>>>>>>            End
77111>>>>>>>>>>>>>>>>
77111>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77114>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77115>>>>>>>>>>>>>>>            End
77115>>>>>>>>>>>>>>>>
77115>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77117>>>>>>>>>>>>>>>        End
77117>>>>>>>>>>>>>>>>
77117>>>>>>>>>>>>>>>        Else Begin
77118>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77120>>>>>>>>>>>>>>>        End
77120>>>>>>>>>>>>>>>>
77120>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77121>>>>>>>>>>>>>>>
77121>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77122>>>>>>>>>>>>>>>    End_Function
77123>>>>>>>>>>>>>>>End_Class
77124>>>>>>>>>>>>>>>
77124>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77125>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77127>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77127>>>>>>>>>>>>>>>        String sDriverID
77127>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>        Move False to Err
77128>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77129>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77131>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77132>>>>>>>>>>>>>>>        End
77132>>>>>>>>>>>>>>>>
77132>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77134>>>>>>>>>>>>>>>
77134>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77135>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77136>>>>>>>>>>>>>>>    End_Function
77137>>>>>>>>>>>>>>>End_Class
77138>>>>>>>>>>>>>>>
77138>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77139>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77141>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77141>>>>>>>>>>>>>>>        String sDriverID
77141>>>>>>>>>>>>>>>
77141>>>>>>>>>>>>>>>        Move False to Err
77142>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77143>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77143>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77143>>>>>>>>>>>>>>>//        End
77143>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77145>>>>>>>>>>>>>>>
77145>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77146>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77147>>>>>>>>>>>>>>>    End_Function
77148>>>>>>>>>>>>>>>End_Class
77149>>>>>>>>>>>>>>>
77149>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77150>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77152>>>>>>>>>>>>>>>        Function_Return ""
77153>>>>>>>>>>>>>>>    End_Function
77154>>>>>>>>>>>>>>>End_Class
77155>>>>>>>>>>>>>>>
77155>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77156>>>>>>>>>>>>>>>    Procedure Construct_Object
77158>>>>>>>>>>>>>>>        Forward Send Construct_Object
77160>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77161>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77162>>>>>>>>>>>>>>>    End_Procedure
77163>>>>>>>>>>>>>>>
77163>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77165>>>>>>>>>>>>>>>        String sDriverID
77165>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77166>>>>>>>>>>>>>>>        Case Begin
77166>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77168>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77169>>>>>>>>>>>>>>>                Case Break
77170>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77173>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77174>>>>>>>>>>>>>>>                Case Break
77175>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77178>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77179>>>>>>>>>>>>>>>                Case Break               
77180>>>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
77180>>>>>>>>>>>>>>>            Case Else
77180>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77181>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77182>>>>>>>>>>>>>>>        Case End
77182>>>>>>>>>>>>>>>
77182>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77183>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77184>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77185>>>>>>>>>>>>>>>
77185>>>>>>>>>>>>>>>        Function_Return hoDriver
77186>>>>>>>>>>>>>>>    End_Function
77187>>>>>>>>>>>>>>>
77187>>>>>>>>>>>>>>>    Procedure DestroyDriver
77189>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77191>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77192>>>>>>>>>>>>>>>        End
77192>>>>>>>>>>>>>>>>
77192>>>>>>>>>>>>>>>    End_Procedure
77193>>>>>>>>>>>>>>>
77193>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77195>>>>>>>>>>>>>>>        String sConnect
77195>>>>>>>>>>>>>>>        Handle hoDriver
77195>>>>>>>>>>>>>>>
77195>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
77196>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77197>>>>>>>>>>>>>>>        Send DestroyDriver
77198>>>>>>>>>>>>>>>        Function_Return sConnect
77199>>>>>>>>>>>>>>>    End_Function
77200>>>>>>>>>>>>>>>
77200>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77202>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77202>>>>>>>>>>>>>>>        Handle hoDriver
77202>>>>>>>>>>>>>>>
77202>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
77203>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77204>>>>>>>>>>>>>>>        Send DestroyDriver
77205>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77206>>>>>>>>>>>>>>>    End_Function
77207>>>>>>>>>>>>>>>
77207>>>>>>>>>>>>>>>End_Class
77208>>>>>>>>>>>>>
77208>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cLoginEncryption.pkg)
77208>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77208>>>>>>>>>>>>>>>
77208>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77209>>>>>>>>>>>>>>>    
77209>>>>>>>>>>>>>>>    Procedure Construct_Object
77211>>>>>>>>>>>>>>>        Forward Send Construct_Object
77213>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77213>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77214>>>>>>>>>>>>>>>        
77214>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77216>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77217>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77218>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77219>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77220>>>>>>>>>>>>>>>        End_Object
77221>>>>>>>>>>>>>>>    End_Procedure
77222>>>>>>>>>>>>>>>    
77222>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77222>>>>>>>>>>>>>>>    // hidden mechanism desired.
77222>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77224>>>>>>>>>>>>>>>        String sPassword
77224>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77225>>>>>>>>>>>>>>>        Function_Return sPassword
77226>>>>>>>>>>>>>>>    End_Function
77227>>>>>>>>>>>>>>>    
77227>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77227>>>>>>>>>>>>>>>    //
77227>>>>>>>>>>>>>>>    // Params:
77227>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77227>>>>>>>>>>>>>>>    // Returns:
77227>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77227>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77229>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77229>>>>>>>>>>>>>>>        UChar[] ucBinary
77230>>>>>>>>>>>>>>>        Pointer pBase64
77230>>>>>>>>>>>>>>>        Integer iVoid
77230>>>>>>>>>>>>>>>        
77230>>>>>>>>>>>>>>>        //  Encrypt Key
77230>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77231>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77233>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77234>>>>>>>>>>>>>>>>
77234>>>>>>>>>>>>>>>        End
77234>>>>>>>>>>>>>>>>
77234>>>>>>>>>>>>>>>        
77234>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77235>>>>>>>>>>>>>>>        
77235>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77237>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77238>>>>>>>>>>>>>>>>
77238>>>>>>>>>>>>>>>            Function_Return ""
77239>>>>>>>>>>>>>>>        End
77239>>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>        
77239>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77239>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77240>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77241>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77242>>>>>>>>>>>>>>>        
77242>>>>>>>>>>>>>>>        Function_Return sBase64
77243>>>>>>>>>>>>>>>    End_Function
77244>>>>>>>>>>>>>>>    
77244>>>>>>>>>>>>>>>    
77244>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77244>>>>>>>>>>>>>>>    //
77244>>>>>>>>>>>>>>>    // Params:
77244>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77244>>>>>>>>>>>>>>>    // Returns:
77244>>>>>>>>>>>>>>>    //   Readable plain text password
77244>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77246>>>>>>>>>>>>>>>        String sEncryptPassword
77246>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77248>>>>>>>>>>>>>>>        Boolean bIsHex
77248>>>>>>>>>>>>>>>        Integer iLen iVoid
77248>>>>>>>>>>>>>>>        Pointer pBinary
77248>>>>>>>>>>>>>>>        
77248>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77250>>>>>>>>>>>>>>>            //  Decode from Base64
77250>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77251>>>>>>>>>>>>>>>            
77251>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77252>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77253>>>>>>>>>>>>>>>                        
77253>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77254>>>>>>>>>>>>>>>            
77254>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77254>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77255>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77256>>>>>>>>>>>>>>>        End
77256>>>>>>>>>>>>>>>>
77256>>>>>>>>>>>>>>>        
77256>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77257>>>>>>>>>>>>>>>    End_Function
77258>>>>>>>>>>>>>>>End_Class
77259>>>>>>>>>>>>>
77259>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77260>>>>>>>>>>>>>    Procedure Construct_Object
77262>>>>>>>>>>>>>        Forward Send Construct_Object
77264>>>>>>>>>>>>>
77264>>>>>>>>>>>>>        Property String Private_psIniFilePath
77265>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77266>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77267>>>>>>>>>>>>>
77267>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77268>>>>>>>>>>>>>
77268>>>>>>>>>>>>>        // *** You really want to change this value! ***
77268>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77268>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77269>>>>>>>>>>>>>
77269>>>>>>>>>>>>>    End_Procedure
77270>>>>>>>>>>>>>
77270>>>>>>>>>>>>>    Procedure End_Construct_Object
77272>>>>>>>>>>>>>        Forward Send End_Construct_Object
77274>>>>>>>>>>>>>    End_Procedure
77275>>>>>>>>>>>>>
77275>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77277>>>>>>>>>>>>>        String sIniFile
77277>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77278>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77279>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77280>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77281>>>>>>>>>>>>>    End_Procedure
77282>>>>>>>>>>>>>
77282>>>>>>>>>>>>>    Function psIniFilePath Returns String
77284>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77285>>>>>>>>>>>>>    End_Function
77286>>>>>>>>>>>>>
77286>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77288>>>>>>>>>>>>>        String sPath
77288>>>>>>>>>>>>>        Get psIniFilePath to sPath
77289>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77290>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77291>>>>>>>>>>>>>    End_Procedure
77292>>>>>>>>>>>>>
77292>>>>>>>>>>>>>    Function psIniFileName Returns String
77294>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77295>>>>>>>>>>>>>    End_Function
77296>>>>>>>>>>>>>
77296>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77296>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77296>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77296>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77298>>>>>>>>>>>>>        String sIniFile sPath
77298>>>>>>>>>>>>>
77298>>>>>>>>>>>>>        Get psIniFilePath to sPath
77299>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77300>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77301>>>>>>>>>>>>>        Set psFileName to sIniFile
77302>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77303>>>>>>>>>>>>>    End_Procedure
77304>>>>>>>>>>>>>
77304>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77304>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77304>>>>>>>>>>>>>    // Returns the value
77304>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77306>>>>>>>>>>>>>        String sValue sIniFile sPath
77306>>>>>>>>>>>>>
77306>>>>>>>>>>>>>        Get psIniFilePath to sPath
77307>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77308>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77309>>>>>>>>>>>>>        Set psFileName to sIniFile
77310>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77311>>>>>>>>>>>>>
77311>>>>>>>>>>>>>        Function_Return sValue
77312>>>>>>>>>>>>>    End_Function
77313>>>>>>>>>>>>>
77313>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77313>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77315>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77318>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77321>>>>>>>>>>>>>
77321>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77324>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77327>>>>>>>>>>>>>
77327>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77330>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77333>>>>>>>>>>>>>
77333>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77336>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77339>>>>>>>>>>>>>
77339>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77342>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77345>>>>>>>>>>>>>
77345>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77348>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77351>>>>>>>>>>>>>
77351>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77354>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77357>>>>>>>>>>>>>
77357>>>>>>>>>>>>>        Function_Return (EQ)
77358>>>>>>>>>>>>>    End_Function
77359>>>>>>>>>>>>>
77359>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77361>>>>>>>>>>>>>        Handle hoSections
77361>>>>>>>>>>>>>        Integer iItems
77361>>>>>>>>>>>>>
77361>>>>>>>>>>>>>        Send ReadSections hoSections
77362>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77363>>>>>>>>>>>>>        Function_Return iItems
77364>>>>>>>>>>>>>    End_Function
77365>>>>>>>>>>>>>
77365>>>>>>>>>>>>>    // The normal connection string looks something like this;
77365>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77365>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77365>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77365>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77365>>>>>>>>>>>>>//        String sSection
77365>>>>>>>>>>>>>//        Integer iCount
77365>>>>>>>>>>>>>//
77365>>>>>>>>>>>>>//        Move False to Err
77365>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77365>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77365>>>>>>>>>>>>>//        Increment iCount
77365>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77365>>>>>>>>>>>>>//
77365>>>>>>>>>>>>>//        Function_Return (Err = False)
77365>>>>>>>>>>>>>//    End_Function
77365>>>>>>>>>>>>>
77365>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77367>>>>>>>>>>>>>        Integer iCount
77367>>>>>>>>>>>>>        Boolean bExists
77367>>>>>>>>>>>>>        String sSection
77367>>>>>>>>>>>>>
77367>>>>>>>>>>>>>        Move False to Err
77368>>>>>>>>>>>>>        Move 1 to iCount
77369>>>>>>>>>>>>>        Get psIniSectionName to sSection
77370>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77371>>>>>>>>>>>>>        While (bExists = True)
77375>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77376>>>>>>>>>>>>>            Increment iCount
77377>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77378>>>>>>>>>>>>>        Loop
77379>>>>>>>>>>>>>>
77379>>>>>>>>>>>>>        Function_Return (Err = False)
77380>>>>>>>>>>>>>    End_Function
77381>>>>>>>>>>>>>
77381>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77383>>>>>>>>>>>>>        Integer iCount
77383>>>>>>>>>>>>>        String sSection
77383>>>>>>>>>>>>>        Boolean bExists
77383>>>>>>>>>>>>>
77383>>>>>>>>>>>>>        Move False to Err
77384>>>>>>>>>>>>>        Move 1 to iCount
77385>>>>>>>>>>>>>        Get psIniSectionName to sSection
77386>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77387>>>>>>>>>>>>>        While (bExists = True)
77391>>>>>>>>>>>>>            If (iCount = iItem) Begin
77393>>>>>>>>>>>>>                Send DeleteSection sSection
77394>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77394>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77395>>>>>>>>>>>>>            End
77395>>>>>>>>>>>>>>
77395>>>>>>>>>>>>>            Increment iCount
77396>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77397>>>>>>>>>>>>>        Loop
77398>>>>>>>>>>>>>>
77398>>>>>>>>>>>>>
77398>>>>>>>>>>>>>        Function_Return (Err = False)
77399>>>>>>>>>>>>>    End_Function
77400>>>>>>>>>>>>>
77400>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77400>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77400>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77402>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77402>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77403>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77403>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77403>>>>>>>>>>>>>        Integer iIndex
77403>>>>>>>>>>>>>
77403>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77404>>>>>>>>>>>>>        If (iIndex = -1) Begin
77406>>>>>>>>>>>>>            Move True to SQLConnection.bError
77407>>>>>>>>>>>>>            Function_Return SQLConnection
77408>>>>>>>>>>>>>        End
77408>>>>>>>>>>>>>>
77408>>>>>>>>>>>>>
77408>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77409>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77410>>>>>>>>>>>>>
77410>>>>>>>>>>>>>        Function_Return SQLConnection
77411>>>>>>>>>>>>>    End_Function
77412>>>>>>>>>>>>>
77412>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77412>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77414>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77414>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77415>>>>>>>>>>>>>        Integer iRetval iCount iSize
77415>>>>>>>>>>>>>        String sValue
77415>>>>>>>>>>>>>        Boolean bExists
77415>>>>>>>>>>>>>
77415>>>>>>>>>>>>>        Move -1 to iRetval
77416>>>>>>>>>>>>>
77416>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77417>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77418>>>>>>>>>>>>>        Decrement iSize
77419>>>>>>>>>>>>>        For iCount from 0 to iSize
77425>>>>>>>>>>>>>>
77425>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77426>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77427>>>>>>>>>>>>>            If (bExists) Begin
77429>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77430>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77431>>>>>>>>>>>>>            End
77431>>>>>>>>>>>>>>
77431>>>>>>>>>>>>>        Loop
77432>>>>>>>>>>>>>>
77432>>>>>>>>>>>>>
77432>>>>>>>>>>>>>        Function_Return iRetval
77433>>>>>>>>>>>>>    End_Function
77434>>>>>>>>>>>>>
77434>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77434>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77434>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77436>>>>>>>>>>>>>        Integer iCount iSize iItems
77436>>>>>>>>>>>>>        String sValue
77436>>>>>>>>>>>>>        Boolean bExists
77436>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77436>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77437>>>>>>>>>>>>>
77437>>>>>>>>>>>>>        Move 0 to iItems
77438>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77439>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77440>>>>>>>>>>>>>        Decrement iSize
77441>>>>>>>>>>>>>        For iCount from 0 to iSize
77447>>>>>>>>>>>>>>
77447>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77448>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77449>>>>>>>>>>>>>            If (bExists) Begin
77451>>>>>>>>>>>>>                Increment iItems
77452>>>>>>>>>>>>>            End
77452>>>>>>>>>>>>>>
77452>>>>>>>>>>>>>        Loop
77453>>>>>>>>>>>>>>
77453>>>>>>>>>>>>>
77453>>>>>>>>>>>>>        Function_Return (iItems > 1)
77454>>>>>>>>>>>>>    End_Function
77455>>>>>>>>>>>>>
77455>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77455>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77457>>>>>>>>>>>>>        Boolean bOK
77457>>>>>>>>>>>>>        Integer iSize iCount
77457>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77457>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77458>>>>>>>>>>>>>        tSQLConnection SQLConnection
77458>>>>>>>>>>>>>        tSQLConnection SQLConnection
77458>>>>>>>>>>>>>        String sConnectionString
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Move False to Err
77459>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77460>>>>>>>>>>>>>
77460>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77461>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77462>>>>>>>>>>>>>        Decrement iSize
77463>>>>>>>>>>>>>        // Set all current connection to inactive.
77463>>>>>>>>>>>>>        For iCount from 0 to iSize
77469>>>>>>>>>>>>>>
77469>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77470>>>>>>>>>>>>>        Loop
77471>>>>>>>>>>>>>>
77471>>>>>>>>>>>>>
77471>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77472>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77473>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77474>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77475>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77476>>>>>>>>>>>>>
77476>>>>>>>>>>>>>        Function_Return (bOK = True)
77477>>>>>>>>>>>>>    End_Function
77478>>>>>>>>>>>>>
77478>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77478>>>>>>>>>>>>>    // Returns True if successful.
77478>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77480>>>>>>>>>>>>>        Boolean bOK
77480>>>>>>>>>>>>>        Integer iItem iSize iCount
77480>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77480>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77481>>>>>>>>>>>>>
77481>>>>>>>>>>>>>        Move False to Err
77482>>>>>>>>>>>>>        Move -1 to iItem
77483>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77484>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77485>>>>>>>>>>>>>        Decrement iSize
77486>>>>>>>>>>>>>        // Set all current connection to inactive.
77486>>>>>>>>>>>>>        For iCount from 0 to iSize
77492>>>>>>>>>>>>>>
77492>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77493>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77495>>>>>>>>>>>>>                Move iCount to iItem
77496>>>>>>>>>>>>>            End
77496>>>>>>>>>>>>>>
77496>>>>>>>>>>>>>        Loop
77497>>>>>>>>>>>>>>
77497>>>>>>>>>>>>>
77497>>>>>>>>>>>>>        If (iItem <> -1) Begin
77499>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77500>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77501>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77502>>>>>>>>>>>>>        End
77502>>>>>>>>>>>>>>
77502>>>>>>>>>>>>>
77502>>>>>>>>>>>>>        Function_Return (bOK = True)
77503>>>>>>>>>>>>>    End_Function
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77507>>>>>>>>>>>>>        String sSection sValue
77507>>>>>>>>>>>>>        Integer iCount
77507>>>>>>>>>>>>>        Boolean bExists
77507>>>>>>>>>>>>>
77507>>>>>>>>>>>>>        Get psIniSectionName to sSection
77508>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77509>>>>>>>>>>>>>        If (bExists = False) Begin
77511>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77512>>>>>>>>>>>>>        End
77512>>>>>>>>>>>>>>
77512>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77513>>>>>>>>>>>>>        If (bExists = True) Begin
77515>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77516>>>>>>>>>>>>>>
77516>>>>>>>>>>>>>        End
77516>>>>>>>>>>>>>>
77516>>>>>>>>>>>>>
77516>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77517>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77518>>>>>>>>>>>>>
77518>>>>>>>>>>>>>        While (bExists = True)                 
77522>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77522>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77522>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77522>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77522>>>>>>>>>>>>>
77522>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77523>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77524>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77525>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77526>>>>>>>>>>>>>
77526>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77526>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77527>>>>>>>>>>>>>            If (sValue = "99") Begin
77529>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77530>>>>>>>>>>>>>            End
77530>>>>>>>>>>>>>>
77530>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77531>>>>>>>>>>>>>
77531>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77532>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77533>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77535>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77536>>>>>>>>>>>>>            End
77536>>>>>>>>>>>>>>
77536>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77538>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77539>>>>>>>>>>>>>            End
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>
77539>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77540>>>>>>>>>>>>>
77540>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77541>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77542>>>>>>>>>>>>>
77542>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77543>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77544>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77546>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77547>>>>>>>>>>>>>            End
77547>>>>>>>>>>>>>>
77547>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77548>>>>>>>>>>>>>
77548>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77548>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77550>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77551>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77552>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77553>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77554>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77555>>>>>>>>>>>>>
77555>>>>>>>>>>>>>            Increment iCount
77556>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77557>>>>>>>>>>>>>        Loop
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77558>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77560>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77561>>>>>>>>>>>>>        End
77561>>>>>>>>>>>>>>
77561>>>>>>>>>>>>>
77561>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77562>>>>>>>>>>>>>    End_Function
77563>>>>>>>>>>>>>
77563>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77565>>>>>>>>>>>>>        Integer iCount iSize
77565>>>>>>>>>>>>>        Boolean bOK
77565>>>>>>>>>>>>>        String sSection sValue
77565>>>>>>>>>>>>>
77565>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77565>>>>>>>>>>>>>        Move 0 to iCount
77566>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77567>>>>>>>>>>>>>        If (bOK = False) Begin
77569>>>>>>>>>>>>>            Function_Return False
77570>>>>>>>>>>>>>        End
77570>>>>>>>>>>>>>>
77570>>>>>>>>>>>>>
77570>>>>>>>>>>>>>        Move False to Err
77571>>>>>>>>>>>>>        Get psIniSectionName to sSection
77572>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77572>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77573>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77574>>>>>>>>>>>>>        Decrement iSize
77575>>>>>>>>>>>>>
77575>>>>>>>>>>>>>        For iCount from 0 to iSize
77581>>>>>>>>>>>>>>
77581>>>>>>>>>>>>>            // DF 19 compatible settings:
77581>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77582>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77583>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77584>>>>>>>>>>>>>            
77584>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77585>>>>>>>>>>>>>
77585>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77586>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77588>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77589>>>>>>>>>>>>>            End
77589>>>>>>>>>>>>>>
77589>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77590>>>>>>>>>>>>>
77590>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77592>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77593>>>>>>>>>>>>>            End
77593>>>>>>>>>>>>>>
77593>>>>>>>>>>>>>
77593>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77594>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77595>>>>>>>>>>>>>
77595>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77595>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77596>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77597>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77598>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77599>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77600>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77601>>>>>>>>>>>>>        Loop
77602>>>>>>>>>>>>>>
77602>>>>>>>>>>>>>
77602>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77603>>>>>>>>>>>>>    End_Function
77604>>>>>>>>>>>>>
77604>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77604>>>>>>>>>>>>>    //
77604>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77604>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77604>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77606>>>>>>>>>>>>>        String sRetval
77606>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77608>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77609>>>>>>>>>>>>>        End
77609>>>>>>>>>>>>>>
77609>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77611>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77612>>>>>>>>>>>>>        End
77612>>>>>>>>>>>>>>
77612>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77614>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77615>>>>>>>>>>>>>        End
77615>>>>>>>>>>>>>>
77615>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77617>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77618>>>>>>>>>>>>>        End
77618>>>>>>>>>>>>>>
77618>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77620>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77621>>>>>>>>>>>>>        End
77621>>>>>>>>>>>>>>
77621>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77623>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77624>>>>>>>>>>>>>        End
77624>>>>>>>>>>>>>>
77624>>>>>>>>>>>>>        Function_Return sRetval
77625>>>>>>>>>>>>>    End_Function
77626>>>>>>>>>>>>>
77626>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77626>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77626>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77628>>>>>>>>>>>>>        Integer iRetval
77628>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77630>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77631>>>>>>>>>>>>>        End
77631>>>>>>>>>>>>>>
77631>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77633>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77634>>>>>>>>>>>>>        End
77634>>>>>>>>>>>>>>
77634>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77636>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77637>>>>>>>>>>>>>        End
77637>>>>>>>>>>>>>>
77637>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77639>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77640>>>>>>>>>>>>>        End
77640>>>>>>>>>>>>>>
77640>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77642>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77643>>>>>>>>>>>>>        End
77643>>>>>>>>>>>>>>
77643>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77645>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77646>>>>>>>>>>>>>        End
77646>>>>>>>>>>>>>>
77646>>>>>>>>>>>>>        Function_Return iRetval
77647>>>>>>>>>>>>>    End_Function
77648>>>>>>>>>>>>>
77648>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77648>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77648>>>>>>>>>>>>>    // the SQL Connection program's grid.
77648>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77650>>>>>>>>>>>>>        String sRetval
77650>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77652>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77653>>>>>>>>>>>>>        End
77653>>>>>>>>>>>>>>
77653>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77655>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77656>>>>>>>>>>>>>        End
77656>>>>>>>>>>>>>>
77656>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77658>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77659>>>>>>>>>>>>>        End
77659>>>>>>>>>>>>>>
77659>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77661>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77662>>>>>>>>>>>>>        End
77662>>>>>>>>>>>>>>
77662>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77664>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77665>>>>>>>>>>>>>        End
77665>>>>>>>>>>>>>>
77665>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77667>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77668>>>>>>>>>>>>>        End
77668>>>>>>>>>>>>>>
77668>>>>>>>>>>>>>        Function_Return sRetval
77669>>>>>>>>>>>>>    End_Function
77670>>>>>>>>>>>>>
77670>>>>>>>>>>>>>    // Pass a driver id and the function will return
77670>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77670>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77670>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77672>>>>>>>>>>>>>        Integer iRetval
77672>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77674>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77675>>>>>>>>>>>>>        End
77675>>>>>>>>>>>>>>
77675>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77677>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77678>>>>>>>>>>>>>        End
77678>>>>>>>>>>>>>>
77678>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77680>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77681>>>>>>>>>>>>>        End
77681>>>>>>>>>>>>>>
77681>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77683>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77684>>>>>>>>>>>>>        End
77684>>>>>>>>>>>>>>
77684>>>>>>>>>>>>>        Function_Return iRetval
77685>>>>>>>>>>>>>    End_Function
77686>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77686>>>>>>>>>>>>>>
77686>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77688>>>>>>>>>>>>>>    Integer iStart iEnd
77688>>>>>>>>>>>>>>    String sRetval
77688>>>>>>>>>>>>>>
77688>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77689>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77690>>>>>>>>>>>>>>    If (iStart = 0) Begin
77692>>>>>>>>>>>>>>        Function_Return ""
77693>>>>>>>>>>>>>>    End
77693>>>>>>>>>>>>>>>
77693>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77694>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77695>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77697>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77698>>>>>>>>>>>>>>    End
77698>>>>>>>>>>>>>>>
77698>>>>>>>>>>>>>>    Else Begin
77699>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77700>>>>>>>>>>>>>>    End
77700>>>>>>>>>>>>>>>
77700>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77702>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77703>>>>>>>>>>>>>>        Decrement iEnd
77704>>>>>>>>>>>>>>    End
77704>>>>>>>>>>>>>>>
77704>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77706>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77707>>>>>>>>>>>>>>    End
77707>>>>>>>>>>>>>>>
77707>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77708>>>>>>>>>>>>>>
77708>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77709>>>>>>>>>>>>>>End_Function
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>
77710>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77712>>>>>>>>>>>>>        String sConnect
77712>>>>>>>>>>>>>        Handle hoDriver
77712>>>>>>>>>>>>>
77712>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77713>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77714>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77715>>>>>>>>>>>>>        Send Destroy of hoDriver
77716>>>>>>>>>>>>>
77716>>>>>>>>>>>>>        Function_Return sConnect
77717>>>>>>>>>>>>>    End_Function
77718>>>>>>>>>>>>>
77718>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77718>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77720>>>>>>>>>>>>>        String sConnect
77720>>>>>>>>>>>>>
77720>>>>>>>>>>>>>        Case Begin
77720>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77722>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77723>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77725>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77726>>>>>>>>>>>>>                End
77726>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>                Case Break
77727>>>>>>>>>>>>>
77727>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77730>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77732>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77733>>>>>>>>>>>>>                End
77733>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77736>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77737>>>>>>>>>>>>>                End
77737>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>
77737>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77739>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77740>>>>>>>>>>>>>                End
77740>>>>>>>>>>>>>>
77740>>>>>>>>>>>>>                Case Break
77741>>>>>>>>>>>>>
77741>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77744>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77745>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77747>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77748>>>>>>>>>>>>>                End
77748>>>>>>>>>>>>>>
77748>>>>>>>>>>>>>                Case Break
77749>>>>>>>>>>>>>
77749>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77752>>>>>>>>>>>>>                Break
77753>>>>>>>>>>>>>
77753>>>>>>>>>>>>>            Case Else
77753>>>>>>>>>>>>>                Move "" to sConnect
77754>>>>>>>>>>>>>        Case End
77754>>>>>>>>>>>>>
77754>>>>>>>>>>>>>        Function_Return sConnect
77755>>>>>>>>>>>>>    End_Function
77756>>>>>>>>>>>>>
77756>>>>>>>>>>>>>    // Use Base64
77756>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77758>>>>>>>>>>>>>        String sRetval
77758>>>>>>>>>>>>>        Handle hoLoginEncryption
77758>>>>>>>>>>>>>
77758>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77759>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77760>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77761>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77762>>>>>>>>>>>>>          
77762>>>>>>>>>>>>>        Function_Return sRetval
77763>>>>>>>>>>>>>    End_Function
77764>>>>>>>>>>>>>
77764>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77766>>>>>>>>>>>>>        String sRetval
77766>>>>>>>>>>>>>        Handle hoLoginEncryption
77766>>>>>>>>>>>>>
77766>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77767>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77768>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77769>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77770>>>>>>>>>>>>>
77770>>>>>>>>>>>>>        Function_Return sRetval
77771>>>>>>>>>>>>>    End_Function
77772>>>>>>>>>>>>>
77772>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77772>>>>>>>>>>>>>    Function ApplicationPath Returns String
77774>>>>>>>>>>>>>        String sApplicationFileName sPath
77774>>>>>>>>>>>>>        Integer iNumChars iRetval
77774>>>>>>>>>>>>>
77774>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77775>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77776>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77777>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77778>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77779>>>>>>>>>>>>>
77779>>>>>>>>>>>>>        Function_Return sPath
77780>>>>>>>>>>>>>    End_Function
77781>>>>>>>>>>>>>
77781>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77781>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77781>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77781>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77783>>>>>>>>>>>>>        Boolean bExists
77783>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77783>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77784>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77784>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77784>>>>>>>>>>>>>        
77784>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77785>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77786>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77787>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77788>>>>>>>>>>>>>        If (bExists = True) Begin
77790>>>>>>>>>>>>>            Function_Return sProgramsPath
77791>>>>>>>>>>>>>        End                      
77791>>>>>>>>>>>>>>
77791>>>>>>>>>>>>>    
77791>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77792>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77794>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77795>>>>>>>>>>>>>        End                                              
77795>>>>>>>>>>>>>>
77795>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77796>>>>>>>>>>>>>        
77796>>>>>>>>>>>>>        Move False to bExists
77797>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77798>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77799>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77800>>>>>>>>>>>>>        Decrement iSize       
77801>>>>>>>>>>>>>        
77801>>>>>>>>>>>>>        For iCount from 0 to iSize
77807>>>>>>>>>>>>>>
77807>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77808>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77809>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77810>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77811>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77817>>>>>>>>>>>>>>
77817>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77818>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77819>>>>>>>>>>>>>                // Check if there are more than one path specified;
77819>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77820>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77822>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77823>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77829>>>>>>>>>>>>>>
77829>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77830>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77831>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77832>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77833>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77834>>>>>>>>>>>>>                        If (bExists = True) Begin
77836>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77837>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77838>>>>>>>>>>>>>                            Move iSize to iCount
77839>>>>>>>>>>>>>                        End                                                    
77839>>>>>>>>>>>>>>
77839>>>>>>>>>>>>>                    Loop
77840>>>>>>>>>>>>>>
77840>>>>>>>>>>>>>                End
77840>>>>>>>>>>>>>>
77840>>>>>>>>>>>>>                Else Begin
77841>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77842>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77843>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77844>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77845>>>>>>>>>>>>>                    If (bExists = True) Begin
77847>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77848>>>>>>>>>>>>>                        Move iSize to iCount
77849>>>>>>>>>>>>>                    End                                                    
77849>>>>>>>>>>>>>>
77849>>>>>>>>>>>>>                End
77849>>>>>>>>>>>>>>
77849>>>>>>>>>>>>>            Loop
77850>>>>>>>>>>>>>>
77850>>>>>>>>>>>>>            If (bExists = False) Begin
77852>>>>>>>>>>>>>                Move "" to sPath    
77853>>>>>>>>>>>>>            End
77853>>>>>>>>>>>>>>
77853>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77854>>>>>>>>>>>>>        Loop        
77855>>>>>>>>>>>>>>
77855>>>>>>>>>>>>>        Send Destroy of hoPaths
77856>>>>>>>>>>>>>        
77856>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77856>>>>>>>>>>>>>        If (sPath = "") Begin
77858>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77859>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77860>>>>>>>>>>>>>        End                  
77860>>>>>>>>>>>>>>
77860>>>>>>>>>>>>>        
77860>>>>>>>>>>>>>        Function_Return sPath    
77861>>>>>>>>>>>>>    End_Function
77862>>>>>>>>>>>>>    
77862>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77862>>>>>>>>>>>>>    // with one or more .ws file names.
77862>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77862>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77862>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77862>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77864>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77866>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77866>>>>>>>>>>>>>        Integer iCh iSize
77866>>>>>>>>>>>>>        Boolean bExists      
77866>>>>>>>>>>>>>        Handle hoIniFile 
77866>>>>>>>>>>>>>        
77866>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77867>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77868>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77870>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77871>>>>>>>>>>>>>        End                                              
77871>>>>>>>>>>>>>>
77871>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77872>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77873>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77874>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77875>>>>>>>>>>>>>        
77875>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77875>>>>>>>>>>>>>        // read the name of the .ws file name.
77875>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77876>>>>>>>>>>>>>        If (bExists = True) Begin
77878>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77879>>>>>>>>>>>>>            If (iCh < 0) Begin
77881>>>>>>>>>>>>>                Function_Return asSWSFiles
77882>>>>>>>>>>>>>            End                                 
77882>>>>>>>>>>>>>>
77882>>>>>>>>>>>>>            
77882>>>>>>>>>>>>>            Repeat
77882>>>>>>>>>>>>>>
77882>>>>>>>>>>>>>                Readln channel iCh sFile
77884>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77886>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77887>>>>>>>>>>>>>                End
77887>>>>>>>>>>>>>>
77887>>>>>>>>>>>>>            Until (SeqEof = True)
77889>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77890>>>>>>>>>>>>>            
77890>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77891>>>>>>>>>>>>>            If (iSize <> 0) Begin
77893>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77894>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77894>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77894>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77895>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77896>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77897>>>>>>>>>>>>>                If (sFile <> "") Begin
77899>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77900>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77901>>>>>>>>>>>>>                    File_Exist sFile bExists
77902>>>>>>>>>>>>>                    If (bExists = True) Begin
77904>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77905>>>>>>>>>>>>>                    End
77905>>>>>>>>>>>>>>
77905>>>>>>>>>>>>>                End
77905>>>>>>>>>>>>>>
77905>>>>>>>>>>>>>                Send Destroy of hoIniFile
77906>>>>>>>>>>>>>            End
77906>>>>>>>>>>>>>>
77906>>>>>>>>>>>>>        End
77906>>>>>>>>>>>>>>
77906>>>>>>>>>>>>>        
77906>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77906>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77908>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77909>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77910>>>>>>>>>>>>>            If (bExists = False) Begin
77912>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77913>>>>>>>>>>>>>            End
77913>>>>>>>>>>>>>>
77913>>>>>>>>>>>>>        
77913>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77914>>>>>>>>>>>>>            If (iCh < 0) Begin
77916>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77917>>>>>>>>>>>>>            End                                 
77917>>>>>>>>>>>>>>
77917>>>>>>>>>>>>>            
77917>>>>>>>>>>>>>            Repeat
77917>>>>>>>>>>>>>>
77917>>>>>>>>>>>>>                Readln channel iCh sFile
77919>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77921>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77922>>>>>>>>>>>>>                End
77922>>>>>>>>>>>>>>
77922>>>>>>>>>>>>>            Until (SeqEof = True)
77924>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77925>>>>>>>>>>>>>        End
77925>>>>>>>>>>>>>>
77925>>>>>>>>>>>>>        
77925>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77926>>>>>>>>>>>>>    End_Function
77927>>>>>>>>>>>>>
77927>>>>>>>>>>>>>End_Class
77928>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77928>>>>>>>>>>>Use vWin32fh.pkg
77928>>>>>>>>>>>
77928>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77928>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77928>>>>>>>>>>>
77928>>>>>>>>>>>// We're making references to this object handle so we need it defined
77928>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77928>>>>>>>>>>>
77928>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77928>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77929>>>>>>>>>>>
77929>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77930>>>>>>>>>>>
77930>>>>>>>>>>>    Procedure Construct_Object
77932>>>>>>>>>>>        Forward Send Construct_Object
77934>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77935>>>>>>>>>>>
77935>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77936>>>>>>>>>>>
77936>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77936>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77936>>>>>>>>>>>        // methods to this class.
77936>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77937>>>>>>>>>>>        Property Boolean pbToANSI          True
77938>>>>>>>>>>>        Property Boolean pbRecnum          True
77939>>>>>>>>>>>        Property Boolean pbCopyData        True
77940>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77941>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77942>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77943>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77944>>>>>>>>>>>
77944>>>>>>>>>>>        // Driver default value settings:
77944>>>>>>>>>>>        // Note: When the object is created the corresponding values
77944>>>>>>>>>>>        // from the driver .int files are read.
77944>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77944>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77945>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77946>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77947>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77948>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77949>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77950>>>>>>>>>>>
77950>>>>>>>>>>>        // Driver "nullability" settings:
77950>>>>>>>>>>>        // Note: When the object is created the corresponding values
77950>>>>>>>>>>>        // from the driver .int files are read.
77950>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77950>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77951>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77952>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77953>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77954>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77955>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77956>>>>>>>>>>>
77956>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77956>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
77956>>>>>>>>>>>        //     driver interfaces.
77956>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77956>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77956>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77957>>>>>>>>>>>
77957>>>>>>>>>>>    End_Procedure
77958>>>>>>>>>>>
77958>>>>>>>>>>>    Procedure End_Construct_Object
77960>>>>>>>>>>>        tSQLConnection SQLConnection
77960>>>>>>>>>>>        tSQLConnection SQLConnection
77960>>>>>>>>>>>
77960>>>>>>>>>>>        Forward Send End_Construct_Object
77962>>>>>>>>>>>
77962>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77962>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77963>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77964>>>>>>>>>>>    End_Procedure
77965>>>>>>>>>>>
77965>>>>>>>>>>>    // *** Properties ***
77965>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77965>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77965>>>>>>>>>>>    // merely here for conveniance.
77965>>>>>>>>>>>    //
77965>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77965>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77965>>>>>>>>>>>    // This struct property contains all the connection data.
77965>>>>>>>>>>>    //
77965>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77967>>>>>>>>>>>        Boolean bOK
77967>>>>>>>>>>>
77967>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77968>>>>>>>>>>>
77968>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
77968>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77970>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77970>>>>>>>>>>>            Procedure_Return
77971>>>>>>>>>>>        End
77971>>>>>>>>>>>>
77971>>>>>>>>>>>
77971>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77971>>>>>>>>>>>        // be logged in already and don't want to do it again.
77971>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77973>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
77973>>>>>>>>>>>            // driver interfaces about the change & make a new login.
77973>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
77974>>>>>>>>>>>            If (bOK = False) Begin
77976>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
77977>>>>>>>>>>>>
77977>>>>>>>>>>>            End
77977>>>>>>>>>>>>
77977>>>>>>>>>>>        End
77977>>>>>>>>>>>>
77977>>>>>>>>>>>
77977>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77977>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77978>>>>>>>>>>>
77978>>>>>>>>>>>    End_Procedure
77979>>>>>>>>>>>
77979>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77979>>>>>>>>>>>    // attempt to load the driver.
77979>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
77979>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77981>>>>>>>>>>>        Boolean bOK
77981>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77982>>>>>>>>>>>        Function_Return bOK
77983>>>>>>>>>>>    End_Function
77984>>>>>>>>>>>
77984>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77984>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
77986>>>>>>>>>>>        String sAttributeValue
77986>>>>>>>>>>>        Integer iDriverID
77986>>>>>>>>>>>        Boolean bNULL bSQLDriver
77986>>>>>>>>>>>
77986>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77987>>>>>>>>>>>        If (bSQLDriver = False) Begin
77989>>>>>>>>>>>            Procedure_Return
77990>>>>>>>>>>>        End                                      
77990>>>>>>>>>>>>
77990>>>>>>>>>>>        
77990>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
77991>>>>>>>>>>>
77991>>>>>>>>>>>        // Driver default values for various data types:
77991>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77994>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77995>>>>>>>>>>>
77995>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77998>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77999>>>>>>>>>>>
77999>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78002>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78003>>>>>>>>>>>
78003>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78006>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78007>>>>>>>>>>>
78007>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78010>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78011>>>>>>>>>>>
78011>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78014>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78015>>>>>>>>>>>
78015>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78015>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78018>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78019>>>>>>>>>>>
78019>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78022>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78023>>>>>>>>>>>
78023>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78026>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78027>>>>>>>>>>>
78027>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78030>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78031>>>>>>>>>>>
78031>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78034>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78035>>>>>>>>>>>
78035>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78038>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78039>>>>>>>>>>>
78039>>>>>>>>>>>    End_Procedure
78040>>>>>>>>>>>
78040>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78042>>>>>>>>>>>        Boolean bOK bIsDaw
78042>>>>>>>>>>>        String sConnectionString
78042>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78042>>>>>>>>>>>        Integer iDriverID
78042>>>>>>>>>>>
78042>>>>>>>>>>>        Move False to bOK
78043>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78044>>>>>>>>>>>
78044>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78045>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78046>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78047>>>>>>>>>>>        If (iDriverID = 0) Begin
78049>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78050>>>>>>>>>>>            Function_Return False
78051>>>>>>>>>>>        End
78051>>>>>>>>>>>>
78051>>>>>>>>>>>
78051>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78054>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78055>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78056>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78057>>>>>>>>>>>        Send Destroy   of hoDriver
78058>>>>>>>>>>>
78058>>>>>>>>>>>        Function_Return bOK
78059>>>>>>>>>>>    End_Function
78060>>>>>>>>>>>
78060>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78062>>>>>>>>>>>        tSQLConnection SQLConnection
78062>>>>>>>>>>>        tSQLConnection SQLConnection
78062>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78063>>>>>>>>>>>        Function_Return SQLConnection
78064>>>>>>>>>>>    End_Function
78065>>>>>>>>>>>
78065>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78067>>>>>>>>>>>        tSQLConnection SQLConnection
78067>>>>>>>>>>>        tSQLConnection SQLConnection
78067>>>>>>>>>>>
78067>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78068>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78070>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78071>>>>>>>>>>>        End
78071>>>>>>>>>>>>
78071>>>>>>>>>>>
78071>>>>>>>>>>>        // Else we might want to change the current connection ID
78071>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78074>>>>>>>>>>>            Move False to Err
78075>>>>>>>>>>>            Logout SQLConnection.sDriverID
78076>>>>>>>>>>>            // This will also make a login to the new server.
78076>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78077>>>>>>>>>>>        End
78077>>>>>>>>>>>>
78077>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78078>>>>>>>>>>>    End_Procedure
78079>>>>>>>>>>>
78079>>>>>>>>>>>    Function psConnectionID Returns String
78081>>>>>>>>>>>        tSQLConnection SQLConnection
78081>>>>>>>>>>>        tSQLConnection SQLConnection
78081>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78082>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78083>>>>>>>>>>>    End_Function
78084>>>>>>>>>>>
78084>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78084>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78084>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78084>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78084>>>>>>>>>>>    Procedure Set psDriverID String sValue
78086>>>>>>>>>>>        tSQLConnection SQLConnection
78086>>>>>>>>>>>        tSQLConnection SQLConnection
78086>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78087>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78088>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78089>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78091>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78092>>>>>>>>>>>        End
78092>>>>>>>>>>>>
78092>>>>>>>>>>>    End_Procedure
78093>>>>>>>>>>>
78093>>>>>>>>>>>    Function psDriverID Returns String
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78096>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78098>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78099>>>>>>>>>>>        End
78099>>>>>>>>>>>>
78099>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78100>>>>>>>>>>>    End_Function
78101>>>>>>>>>>>
78101>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78103>>>>>>>>>>>        tSQLConnection SQLConnection
78103>>>>>>>>>>>        tSQLConnection SQLConnection
78103>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78104>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78105>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78106>>>>>>>>>>>    End_Procedure
78107>>>>>>>>>>>
78107>>>>>>>>>>>    Function psConnectionString Returns String
78109>>>>>>>>>>>        tSQLConnection SQLConnection
78109>>>>>>>>>>>        tSQLConnection SQLConnection
78109>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78110>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78111>>>>>>>>>>>    End_Function
78112>>>>>>>>>>>
78112>>>>>>>>>>>    Procedure Set psServer String sValue
78114>>>>>>>>>>>        tSQLConnection SQLConnection
78114>>>>>>>>>>>        tSQLConnection SQLConnection
78114>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78115>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78116>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78117>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78118>>>>>>>>>>>    End_Procedure
78119>>>>>>>>>>>
78119>>>>>>>>>>>    Function psServer Returns String
78121>>>>>>>>>>>        tSQLConnection SQLConnection
78121>>>>>>>>>>>        tSQLConnection SQLConnection
78121>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78122>>>>>>>>>>>        Function_Return SQLConnection.sServer
78123>>>>>>>>>>>    End_Function
78124>>>>>>>>>>>
78124>>>>>>>>>>>    Procedure Set psDatabase String sValue
78126>>>>>>>>>>>        tSQLConnection SQLConnection
78126>>>>>>>>>>>        tSQLConnection SQLConnection
78126>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78127>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78128>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78129>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78130>>>>>>>>>>>    End_Procedure
78131>>>>>>>>>>>
78131>>>>>>>>>>>    Function psDatabase Returns String
78133>>>>>>>>>>>        tSQLConnection SQLConnection
78133>>>>>>>>>>>        tSQLConnection SQLConnection
78133>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78134>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78135>>>>>>>>>>>    End_Function
78136>>>>>>>>>>>
78136>>>>>>>>>>>    Procedure Set psUserID String sValue
78138>>>>>>>>>>>        tSQLConnection SQLConnection
78138>>>>>>>>>>>        tSQLConnection SQLConnection
78138>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78139>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78140>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78141>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78142>>>>>>>>>>>    End_Procedure
78143>>>>>>>>>>>
78143>>>>>>>>>>>    Function psUserID Returns String
78145>>>>>>>>>>>        tSQLConnection SQLConnection
78145>>>>>>>>>>>        tSQLConnection SQLConnection
78145>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78146>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78147>>>>>>>>>>>    End_Function
78148>>>>>>>>>>>
78148>>>>>>>>>>>    // This is the uncrypted password
78148>>>>>>>>>>>    Procedure Set psPassword String sValue
78150>>>>>>>>>>>        tSQLConnection SQLConnection
78150>>>>>>>>>>>        tSQLConnection SQLConnection
78150>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78151>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78152>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78153>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78154>>>>>>>>>>>    End_Procedure
78155>>>>>>>>>>>
78155>>>>>>>>>>>    Function psPassword Returns String
78157>>>>>>>>>>>        tSQLConnection SQLConnection
78157>>>>>>>>>>>        tSQLConnection SQLConnection
78157>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78158>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78159>>>>>>>>>>>    End_Function
78160>>>>>>>>>>>
78160>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78162>>>>>>>>>>>        tSQLConnection SQLConnection
78162>>>>>>>>>>>        tSQLConnection SQLConnection
78162>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78163>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78164>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78165>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78166>>>>>>>>>>>    End_Procedure
78167>>>>>>>>>>>
78167>>>>>>>>>>>    Function pbTrusted Returns Boolean
78169>>>>>>>>>>>        tSQLConnection SQLConnection
78169>>>>>>>>>>>        tSQLConnection SQLConnection
78169>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78170>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78171>>>>>>>>>>>    End_Function
78172>>>>>>>>>>>
78172>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78172>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78172>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78172>>>>>>>>>>>    //     the central pSQLConnection "hub".
78172>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78174>>>>>>>>>>>        tSQLConnection SQLConnection
78174>>>>>>>>>>>        tSQLConnection SQLConnection
78174>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78175>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78176>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78177>>>>>>>>>>>    End_Procedure
78178>>>>>>>>>>>
78178>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78180>>>>>>>>>>>        tSQLConnection SQLConnection
78180>>>>>>>>>>>        tSQLConnection SQLConnection
78180>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78181>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78182>>>>>>>>>>>    End_Function
78183>>>>>>>>>>>
78183>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78185>>>>>>>>>>>        tSQLConnection SQLConnection
78185>>>>>>>>>>>        tSQLConnection SQLConnection
78185>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78186>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78187>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78188>>>>>>>>>>>    End_Procedure
78189>>>>>>>>>>>
78189>>>>>>>>>>>    Function piDbType Returns Integer
78191>>>>>>>>>>>        tSQLConnection SQLConnection
78191>>>>>>>>>>>        tSQLConnection SQLConnection
78191>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78192>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78193>>>>>>>>>>>    End_Function
78194>>>>>>>>>>>
78194>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78196>>>>>>>>>>>        tSQLConnection SQLConnection
78196>>>>>>>>>>>        tSQLConnection SQLConnection
78196>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78197>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78198>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78199>>>>>>>>>>>    End_Procedure
78200>>>>>>>>>>>
78200>>>>>>>>>>>    Function psBaseTableSpace Returns String
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78203>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78204>>>>>>>>>>>    End_Function
78205>>>>>>>>>>>
78205>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78207>>>>>>>>>>>        tSQLConnection SQLConnection
78207>>>>>>>>>>>        tSQLConnection SQLConnection
78207>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78208>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78209>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78210>>>>>>>>>>>    End_Procedure
78211>>>>>>>>>>>
78211>>>>>>>>>>>    Function psIndexTableSpace Returns String
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78214>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78215>>>>>>>>>>>    End_Function
78216>>>>>>>>>>>
78216>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78219>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78220>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78221>>>>>>>>>>>    End_Procedure
78222>>>>>>>>>>>
78222>>>>>>>>>>>    Function psLongTableSpace Returns String
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78225>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78226>>>>>>>>>>>    End_Function
78227>>>>>>>>>>>
78227>>>>>>>>>>>    Procedure Set psSchema String sValue
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78230>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78231>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78232>>>>>>>>>>>    End_Procedure
78233>>>>>>>>>>>
78233>>>>>>>>>>>    Function psSchema Returns String
78235>>>>>>>>>>>        tSQLConnection SQLConnection
78235>>>>>>>>>>>        tSQLConnection SQLConnection
78235>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78236>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78237>>>>>>>>>>>    End_Function
78238>>>>>>>>>>>
78238>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78241>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78242>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78243>>>>>>>>>>>    End_Procedure
78244>>>>>>>>>>>
78244>>>>>>>>>>>    Function pbEnabled Returns Boolean
78246>>>>>>>>>>>        tSQLConnection SQLConnection
78246>>>>>>>>>>>        tSQLConnection SQLConnection
78246>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78247>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78248>>>>>>>>>>>    End_Function
78249>>>>>>>>>>>
78249>>>>>>>>>>>
78249>>>>>>>>>>>    // ************************************
78249>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>
78251>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78251>>>>>>>>>>>        // deferr reading SQL connection values until later.
78251>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78253>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78253>>>>>>>>>>>            If (ghoConnection > 0) Begin
78255>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78256>>>>>>>>>>>            End
78256>>>>>>>>>>>>
78256>>>>>>>>>>>
78256>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78256>>>>>>>>>>>            // object is used.
78256>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78258>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78259>>>>>>>>>>>            End
78259>>>>>>>>>>>>
78259>>>>>>>>>>>        End
78259>>>>>>>>>>>>
78259>>>>>>>>>>>
78259>>>>>>>>>>>        Function_Return SQLConnection
78260>>>>>>>>>>>    End_Function
78261>>>>>>>>>>>
78261>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78261>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78263>>>>>>>>>>>        tConnection Connection
78263>>>>>>>>>>>        tConnection Connection
78263>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78263>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78263>>>>>>>>>>>        Integer iRetval iDbType
78263>>>>>>>>>>>        Boolean bOK bConnected
78263>>>>>>>>>>>        String sConnectionID
78263>>>>>>>>>>>
78263>>>>>>>>>>>            tConnection[] Connections
78263>>>>>>>>>>>            tConnection[] Connections
78264>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78264>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78264>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78264>>>>>>>>>>>            //   we then generate an error and abort the program...
78264>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78265>>>>>>>>>>>            If (bOK = False) Begin
78267>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78268>>>>>>>>>>>>
78268>>>>>>>>>>>                Abort
78269>>>>>>>>>>>>
78269>>>>>>>>>>>            End
78269>>>>>>>>>>>>
78269>>>>>>>>>>>            If (sConnectionID = "") Begin
78271>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78272>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78274>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78275>>>>>>>>>>>                End
78275>>>>>>>>>>>>
78275>>>>>>>>>>>            End
78275>>>>>>>>>>>>
78275>>>>>>>>>>>
78275>>>>>>>>>>>            Move 0 to iRetval
78276>>>>>>>>>>>            // DAW DF19 connection info:
78276>>>>>>>>>>>            // We first check that the connection is OK:
78276>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78277>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78277>>>>>>>>>>>            If (iRetval = -1) Begin
78279>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78280>>>>>>>>>>>            End
78280>>>>>>>>>>>>
78280>>>>>>>>>>>
78280>>>>>>>>>>>            If (sConnectionID <> "") Begin
78282>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78283>>>>>>>>>>>            End
78283>>>>>>>>>>>>
78283>>>>>>>>>>>            If (Connection.sId = "") Begin
78285>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78286>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78287>>>>>>>>>>>            End
78287>>>>>>>>>>>>
78287>>>>>>>>>>>
78287>>>>>>>>>>>            // DUF connection info struct property:
78287>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78288>>>>>>>>>>>
78288>>>>>>>>>>>            Move Connection.sId to sConnectionID
78289>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78290>>>>>>>>>>>
78290>>>>>>>>>>>            If (bConnected = False) Begin
78292>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78293>>>>>>>>>>>                If (iRetval <> 0) Begin
78295>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78296>>>>>>>>>>>                    Send Exit_Application
78297>>>>>>>>>>>                End
78297>>>>>>>>>>>>
78297>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78298>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78298>>>>>>>>>>>                // been changed in the DAW db login dialog.
78298>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78299>>>>>>>>>>>            End
78299>>>>>>>>>>>>
78299>>>>>>>>>>>
78299>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78300>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78301>>>>>>>>>>>
78301>>>>>>>>>>>            // Not used in DUF:
78301>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78301>>>>>>>>>>>
78301>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78302>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78303>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78304>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78305>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78306>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78307>>>>>>>>>>>
78307>>>>>>>>>>>            // Not used in DUF:
78307>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78307>>>>>>>>>>>
78307>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78307>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78307>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78309>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78310>>>>>>>>>>>            End
78310>>>>>>>>>>>>
78310>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78312>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78313>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78315>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78316>>>>>>>>>>>                End
78316>>>>>>>>>>>>
78316>>>>>>>>>>>            End
78316>>>>>>>>>>>>
78316>>>>>>>>>>>
78316>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78317>>>>>>>>>>>
78317>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78317>>>>>>>>>>>            // the value from the driver id:
78317>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78318>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78318>>>>>>>>>>>            Get piDbType                                     to iDbType
78319>>>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78321>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78322>>>>>>>>>>>            End
78322>>>>>>>>>>>>
78322>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78323>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78324>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78325>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78326>>>>>>>>>>>
78326>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78326>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78327>>>>>>>>>>>
78327>>>>>>>>>>>        Function_Return SQLConnection
78328>>>>>>>>>>>    End_Function
78329>>>>>>>>>>>
78329>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78329>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78329>>>>>>>>>>>    // connection id for a particular driver.
78329>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78329>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78329>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78329>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78329>>>>>>>>>>>    // connections of the DAW cConnect class.
78329>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78331>>>>>>>>>>>        tConnection[] ConnIdArray
78331>>>>>>>>>>>        tConnection[] ConnIdArray
78332>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78332>>>>>>>>>>>        Boolean bEnabled bFound
78332>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78332>>>>>>>>>>>
78332>>>>>>>>>>>        Move False to bFound
78333>>>>>>>>>>>        If (ghoConnection > 0) Begin
78335>>>>>>>>>>>
78335>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78335>>>>>>>>>>>            Get psDriverID to sDriverID
78336>>>>>>>>>>>
78336>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78337>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78337>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78338>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78339>>>>>>>>>>>            Decrement iSize
78340>>>>>>>>>>>            For iCount from 0 to iSize
78346>>>>>>>>>>>>
78346>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78347>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78348>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78349>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78349>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78349>>>>>>>>>>>                If (sConnectionID = "") Begin
78351>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78352>>>>>>>>>>>                End
78352>>>>>>>>>>>>
78352>>>>>>>>>>>                Else Begin
78353>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78355>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78356>>>>>>>>>>>                    End
78356>>>>>>>>>>>>
78356>>>>>>>>>>>                End
78356>>>>>>>>>>>>
78356>>>>>>>>>>>
78356>>>>>>>>>>>                If (bFound = True) Begin
78358>>>>>>>>>>>                    Increment iConnectionIDCounter
78359>>>>>>>>>>>                End
78359>>>>>>>>>>>>
78359>>>>>>>>>>>            Loop
78360>>>>>>>>>>>>
78360>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78361>>>>>>>>>>>            If (bFound = True) Begin
78363>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78364>>>>>>>>>>>            End
78364>>>>>>>>>>>>
78364>>>>>>>>>>>        End
78364>>>>>>>>>>>>
78364>>>>>>>>>>>
78364>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78364>>>>>>>>>>>        // but no DFConn.ini record has been created.
78364>>>>>>>>>>>        If (iSize = -1) Begin
78366>>>>>>>>>>>            Move True to bFound
78367>>>>>>>>>>>        End
78367>>>>>>>>>>>>
78367>>>>>>>>>>>
78367>>>>>>>>>>>        Function_Return bFound
78368>>>>>>>>>>>    End_Function
78369>>>>>>>>>>>
78369>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78369>>>>>>>>>>>    // create a connection to the server.
78369>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78371>>>>>>>>>>>        String sPath sFileName
78371>>>>>>>>>>>        Boolean bExists bActive
78371>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78371>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78372>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78372>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78372>>>>>>>>>>>        Handle hoIniFile
78372>>>>>>>>>>>        Integer iSize iCount iRetval
78372>>>>>>>>>>>
78372>>>>>>>>>>>        Get psIniFilePath to sPath
78373>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78374>>>>>>>>>>>        If (sPath = "") Begin
78376>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78377>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78378>>>>>>>>>>>        End
78378>>>>>>>>>>>>
78378>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78379>>>>>>>>>>>        Get psIniFileName to sFileName
78380>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78381>>>>>>>>>>>
78381>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78382>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78383>>>>>>>>>>>        If (iSize = 0) Begin
78385>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78385>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78385>>>>>>>>>>>            // in the cApplication object.
78385>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78386>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78388>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78389>>>>>>>>>>>            End
78389>>>>>>>>>>>>
78389>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78390>>>>>>>>>>>            Move 1 to iSize
78391>>>>>>>>>>>        End
78391>>>>>>>>>>>>
78391>>>>>>>>>>>
78391>>>>>>>>>>>        Move False to bActive
78392>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78392>>>>>>>>>>>        Decrement iSize
78393>>>>>>>>>>>        For iCount from 0 to iSize
78399>>>>>>>>>>>>
78399>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78400>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78402>>>>>>>>>>>                Move True to bActive
78403>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78404>>>>>>>>>>>            End
78404>>>>>>>>>>>>
78404>>>>>>>>>>>        Loop
78405>>>>>>>>>>>>
78405>>>>>>>>>>>
78405>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78405>>>>>>>>>>>        If (bActive = False) Begin
78407>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78408>>>>>>>>>>>        End
78408>>>>>>>>>>>>
78408>>>>>>>>>>>
78408>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78409>>>>>>>>>>>
78409>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78410>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78411>>>>>>>>>>>
78411>>>>>>>>>>>        Function_Return SQLConnection
78412>>>>>>>>>>>    End_Function
78413>>>>>>>>>>>
78413>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78415>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78416>>>>>>>>>>>    End_Procedure
78417>>>>>>>>>>>
78417>>>>>>>>>>>    Function psIniFilePath Returns String
78419>>>>>>>>>>>        String sRetval
78419>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78420>>>>>>>>>>>        Function_Return sRetval
78421>>>>>>>>>>>    End_Function
78422>>>>>>>>>>>
78422>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78424>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78425>>>>>>>>>>>    End_Procedure
78426>>>>>>>>>>>
78426>>>>>>>>>>>    Function psIniFileName Returns String
78428>>>>>>>>>>>        String sRetval
78428>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78429>>>>>>>>>>>        Function_Return sRetval
78430>>>>>>>>>>>    End_Function
78431>>>>>>>>>>>
78431>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78433>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78434>>>>>>>>>>>    End_Procedure
78435>>>>>>>>>>>
78435>>>>>>>>>>>    Function psIniSectionName Returns String
78437>>>>>>>>>>>        String sRetval
78437>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78438>>>>>>>>>>>        Function_Return sRetval
78439>>>>>>>>>>>    End_Function
78440>>>>>>>>>>>
78440>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78442>>>>>>>>>>>        Handle ho
78442>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78443>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78444>>>>>>>>>>>    End_Procedure
78445>>>>>>>>>>>
78445>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78447>>>>>>>>>>>        Handle ho
78447>>>>>>>>>>>        String sRetval
78447>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78448>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78449>>>>>>>>>>>        Function_Return sRetval
78450>>>>>>>>>>>    End_Function
78451>>>>>>>>>>>
78451>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78453>>>>>>>>>>>        Handle ho
78453>>>>>>>>>>>        Boolean bRetval
78453>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78454>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78455>>>>>>>>>>>        Function_Return bRetval
78456>>>>>>>>>>>    End_Function
78457>>>>>>>>>>>
78457>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78459>>>>>>>>>>>        Handle ho
78459>>>>>>>>>>>        Boolean bRetval
78459>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78460>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78461>>>>>>>>>>>        Function_Return bRetval
78462>>>>>>>>>>>    End_Function
78463>>>>>>>>>>>
78463>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78465>>>>>>>>>>>        Handle ho
78465>>>>>>>>>>>        String sRetval
78465>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78466>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78467>>>>>>>>>>>        Function_Return sRetval
78468>>>>>>>>>>>    End_Function
78469>>>>>>>>>>>
78469>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78471>>>>>>>>>>>        Handle ho
78471>>>>>>>>>>>        String sRetval
78471>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78472>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78473>>>>>>>>>>>        Function_Return sRetval
78474>>>>>>>>>>>    End_Function
78475>>>>>>>>>>>
78475>>>>>>>>>>>    // *** Main Connection Message ***
78475>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78477>>>>>>>>>>>        Handle hoDriver
78477>>>>>>>>>>>        String sConnectionString sError
78477>>>>>>>>>>>        Boolean bLoginSuccessful
78477>>>>>>>>>>>
78477>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78478>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78479>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78480>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78481>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78483>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78484>>>>>>>>>>>>
78484>>>>>>>>>>>            If (bExitProgram = True) Begin
78486>>>>>>>>>>>                Send Exit_Application
78487>>>>>>>>>>>            End
78487>>>>>>>>>>>>
78487>>>>>>>>>>>        End
78487>>>>>>>>>>>>
78487>>>>>>>>>>>        Send Destroy of hoDriver
78488>>>>>>>>>>>    End_Procedure
78489>>>>>>>>>>>
78489>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78491>>>>>>>>>>>        Integer iRetval
78491>>>>>>>>>>>        Handle hoCLI
78491>>>>>>>>>>>        String sDriverID
78491>>>>>>>>>>>
78491>>>>>>>>>>>        Get psDriverID to sDriverID
78492>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78493>>>>>>>>>>>        If (hoCLI <> 0) Begin
78495>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78496>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78497>>>>>>>>>>>            Send Destroy of hoCLI
78498>>>>>>>>>>>        End
78498>>>>>>>>>>>>
78498>>>>>>>>>>>
78498>>>>>>>>>>>        Function_Return iRetval
78499>>>>>>>>>>>    End_Function
78500>>>>>>>>>>>
78500>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78502>>>>>>>>>>>        tSQLConnection SQLConnection
78502>>>>>>>>>>>        tSQLConnection SQLConnection
78502>>>>>>>>>>>
78502>>>>>>>>>>>        Set psDriverID to sDriverID
78503>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78504>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78505>>>>>>>>>>>    End_Procedure
78506>>>>>>>>>>>
78506>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78506>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78506>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78506>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78506>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78506>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78506>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78506>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78508>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78508>>>>>>>>>>>        Handle hoCLI
78508>>>>>>>>>>>        String sID
78508>>>>>>>>>>>
78508>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78510>>>>>>>>>>>            Procedure_Return
78511>>>>>>>>>>>        End
78511>>>>>>>>>>>>
78511>>>>>>>>>>>
78511>>>>>>>>>>>        Move 0 to iResult
78512>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78513>>>>>>>>>>>        If (hoCLI <> 0) Begin
78515>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78516>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78517>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78520>>>>>>>>>>>            Decrement iNumConn
78521>>>>>>>>>>>            For iConn from 0 to iNumConn
78527>>>>>>>>>>>>
78527>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78530>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78532>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78533>>>>>>>>>>>                End
78533>>>>>>>>>>>>
78533>>>>>>>>>>>            Loop
78534>>>>>>>>>>>>
78534>>>>>>>>>>>            Send Destroy of hoCLI
78535>>>>>>>>>>>        End
78535>>>>>>>>>>>>
78535>>>>>>>>>>>
78535>>>>>>>>>>>    End_Procedure
78536>>>>>>>>>>>
78536>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78538>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78538>>>>>>>>>>>        Handle hoCLI
78538>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78538>>>>>>>>>>>        tSQLConnection SQLConnection
78538>>>>>>>>>>>        tSQLConnection SQLConnection
78538>>>>>>>>>>>        Boolean bTrusted
78538>>>>>>>>>>>
78538>>>>>>>>>>>        Move 0 to iResult
78539>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78540>>>>>>>>>>>        If (hoCLI <> 0) Begin
78542>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78543>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78544>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78547>>>>>>>>>>>            Decrement iNumConn
78548>>>>>>>>>>>            For iConn from 0 to iNumConn
78554>>>>>>>>>>>>
78554>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78557>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78559>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78560>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78563>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78566>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78567>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78570>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78571>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78572>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78573>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78574>>>>>>>>>>>
78574>>>>>>>>>>>                    Case Begin
78574>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78576>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78577>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78578>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78579>>>>>>>>>>>                            Case Break
78580>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78583>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78584>>>>>>>>>>>                            Case Break
78585>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78588>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78589>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78591>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78592>>>>>>>>>>>                            End
78592>>>>>>>>>>>>
78592>>>>>>>>>>>                            Case Break
78593>>>>>>>>>>>                        Case Else
78593>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78594>>>>>>>>>>>>
78594>>>>>>>>>>>                            Case Break
78595>>>>>>>>>>>                    Case End
78595>>>>>>>>>>>                End
78595>>>>>>>>>>>>
78595>>>>>>>>>>>            Loop
78596>>>>>>>>>>>>
78596>>>>>>>>>>>            Send Destroy of hoCLI
78597>>>>>>>>>>>        End
78597>>>>>>>>>>>>
78597>>>>>>>>>>>
78597>>>>>>>>>>>        Function_Return SQLConnection
78598>>>>>>>>>>>    End_Function
78599>>>>>>>>>>>
78599>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78601>>>>>>>>>>>        String  sCurrentDriver
78601>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78601>>>>>>>>>>>
78601>>>>>>>>>>>        Move 0 to iDriver
78602>>>>>>>>>>>        Move 0 to iCount
78603>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78606>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78612>>>>>>>>>>>>
78612>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78615>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78617>>>>>>>>>>>                Function_Return iCount
78618>>>>>>>>>>>            End
78618>>>>>>>>>>>>
78618>>>>>>>>>>>        Loop
78619>>>>>>>>>>>>
78619>>>>>>>>>>>
78619>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78619>>>>>>>>>>>        If (iDriver = 0) Begin
78621>>>>>>>>>>>            Move 0 to LastErr
78622>>>>>>>>>>>            Load_Driver sDriverID
78623>>>>>>>>>>>            // If driver could not be loaded.
78623>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78625>>>>>>>>>>>                Move -1 to iCount
78626>>>>>>>>>>>            End
78626>>>>>>>>>>>>
78626>>>>>>>>>>>        End
78626>>>>>>>>>>>>
78626>>>>>>>>>>>        Function_Return iCount
78627>>>>>>>>>>>    End_Function
78628>>>>>>>>>>>
78628>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78628>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78630>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78630>>>>>>>>>>>        Boolean bTrusted bSilent
78630>>>>>>>>>>>        Integer iRetval
78630>>>>>>>>>>>
78630>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78631>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78632>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78633>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78634>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78635>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78636>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78637>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78638>>>>>>>>>>>
78638>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78639>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78639>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78640>>>>>>>>>>>    End_Procedure
78641>>>>>>>>>>>
78641>>>>>>>>>>>    // Called when the object is constructed.
78641>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78641>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78641>>>>>>>>>>>    // the database is needed.
78641>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78643>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78643>>>>>>>>>>>        Integer iDriver iRetval
78643>>>>>>>>>>>        Handle hoCLI
78643>>>>>>>>>>>        Boolean bOK bSilent
78643>>>>>>>>>>>
78643>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78644>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78645>>>>>>>>>>>        Get psConnectionString to sConnectionString
78646>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78646>>>>>>>>>>>        Get psDriverID to sDriverID
78647>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78648>>>>>>>>>>>        If (bOK = False) Begin
78650>>>>>>>>>>>            Function_Return False
78651>>>>>>>>>>>        End
78651>>>>>>>>>>>>
78651>>>>>>>>>>>
78651>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78652>>>>>>>>>>>        // If driver not loaded; load it.
78652>>>>>>>>>>>        If (iDriver = 0) Begin
78654>>>>>>>>>>>            Load_Driver sDriverID
78655>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78656>>>>>>>>>>>        End
78656>>>>>>>>>>>>
78656>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78656>>>>>>>>>>>        If (iDriver = 0) Begin
78658>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78659>>>>>>>>>>>>
78659>>>>>>>>>>>            Function_Return False
78660>>>>>>>>>>>        End           
78660>>>>>>>>>>>>
78660>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78663>>>>>>>>>>>        
78663>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78664>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78665>>>>>>>>>>>        // Delete the connection first; in case it exists
78665>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78666>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78667>>>>>>>>>>>        Send Destroy of hoCLI
78668>>>>>>>>>>>
78668>>>>>>>>>>>        Function_Return (iRetval = 0)
78669>>>>>>>>>>>    End_Function
78670>>>>>>>>>>>
78670>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78672>>>>>>>>>>>        Boolean bOK
78672>>>>>>>>>>>
78672>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78673>>>>>>>>>>>
78673>>>>>>>>>>>        If (bOK = False) Begin
78675>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78676>>>>>>>>>>>>
78676>>>>>>>>>>>            Function_Return False
78677>>>>>>>>>>>        End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>
78677>>>>>>>>>>>        Function_Return True
78678>>>>>>>>>>>    End_Function
78679>>>>>>>>>>>
78679>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78681>>>>>>>>>>>        Boolean bOK
78681>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78682>>>>>>>>>>>        Function_Return bOK
78683>>>>>>>>>>>    End_Function
78684>>>>>>>>>>>
78684>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78686>>>>>>>>>>>        Handle hoIniFile
78686>>>>>>>>>>>        String sConnect
78686>>>>>>>>>>>
78686>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78687>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78688>>>>>>>>>>>
78688>>>>>>>>>>>        Function_Return sConnect
78689>>>>>>>>>>>    End_Function
78690>>>>>>>>>>>
78690>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78690>>>>>>>>>>>    // Pass a complete driver connection string
78690>>>>>>>>>>>    // Returns the following as a struct:
78690>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78690>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78690>>>>>>>>>>>    //
78690>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78692>>>>>>>>>>>        tSQLConnection SQLConnection
78692>>>>>>>>>>>        tSQLConnection SQLConnection
78692>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78692>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78692>>>>>>>>>>>        Integer iPos
78692>>>>>>>>>>>
78692>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78693>>>>>>>>>>>        If (bOK = False) Begin
78695>>>>>>>>>>>            Function_Return SQLConnection
78696>>>>>>>>>>>        End
78696>>>>>>>>>>>>
78696>>>>>>>>>>>
78696>>>>>>>>>>>        Move False to bTrusted
78697>>>>>>>>>>>        Move False to bSilent
78698>>>>>>>>>>>
78698>>>>>>>>>>>        Case Begin
78698>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78700>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78701>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78702>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78703>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78704>>>>>>>>>>>                If (bTrusted = False) Begin
78706>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78707>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78708>>>>>>>>>>>                End
78708>>>>>>>>>>>>
78708>>>>>>>>>>>                Case Break
78709>>>>>>>>>>>
78709>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78712>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78714>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78715>>>>>>>>>>>                End
78715>>>>>>>>>>>>
78715>>>>>>>>>>>                Else Begin
78716>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78717>>>>>>>>>>>                End
78717>>>>>>>>>>>>
78717>>>>>>>>>>>
78717>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78718>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78719>>>>>>>>>>>                If (bTrusted = False) Begin
78721>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78722>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78723>>>>>>>>>>>                End
78723>>>>>>>>>>>>
78723>>>>>>>>>>>                Case Break
78724>>>>>>>>>>>
78724>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78727>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78728>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78729>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78730>>>>>>>>>>>                Case Break
78731>>>>>>>>>>>
78731>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78734>>>>>>>>>>>                Break
78735>>>>>>>>>>>        Case End
78735>>>>>>>>>>>
78735>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78736>>>>>>>>>>>
78736>>>>>>>>>>>        // bSilent?
78736>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78737>>>>>>>>>>>        If (iPos = 0) Begin
78739>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78740>>>>>>>>>>>        End
78740>>>>>>>>>>>>
78740>>>>>>>>>>>        If (iPos = 0) Begin
78742>>>>>>>>>>>            Move "0"                                                            to sValue
78743>>>>>>>>>>>        End
78743>>>>>>>>>>>>
78743>>>>>>>>>>>        Else Begin
78744>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78745>>>>>>>>>>>        End
78745>>>>>>>>>>>>
78745>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78746>>>>>>>>>>>
78746>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78747>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78748>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78749>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78750>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78751>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78752>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78753>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78754>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78755>>>>>>>>>>>
78755>>>>>>>>>>>        Function_Return SQLConnection
78756>>>>>>>>>>>    End_Function
78757>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78757>>>>>>>>>>>>
78757>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78759>>>>>>>>>>>>    Integer iStart iEnd
78759>>>>>>>>>>>>    String sRetval
78759>>>>>>>>>>>>
78759>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78760>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78761>>>>>>>>>>>>    If (iStart = 0) Begin
78763>>>>>>>>>>>>        Function_Return ""
78764>>>>>>>>>>>>    End
78764>>>>>>>>>>>>>
78764>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78765>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78766>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78768>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78769>>>>>>>>>>>>    End
78769>>>>>>>>>>>>>
78769>>>>>>>>>>>>    Else Begin
78770>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78771>>>>>>>>>>>>    End
78771>>>>>>>>>>>>>
78771>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78773>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78774>>>>>>>>>>>>        Decrement iEnd
78775>>>>>>>>>>>>    End
78775>>>>>>>>>>>>>
78775>>>>>>>>>>>>    If (iEnd <> 0) Begin
78777>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78778>>>>>>>>>>>>    End
78778>>>>>>>>>>>>>
78778>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78779>>>>>>>>>>>>
78779>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78780>>>>>>>>>>>>End_Function
78781>>>>>>>>>>>>
78781>>>>>>>>>>>>
78781>>>>>>>>>>>
78781>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78781>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78783>>>>>>>>>>>        Handle ho
78783>>>>>>>>>>>        Integer iIndex
78783>>>>>>>>>>>        Boolean bRetval bOK
78783>>>>>>>>>>>        tSQLConnection SQLConnection
78783>>>>>>>>>>>        tSQLConnection SQLConnection
78783>>>>>>>>>>>
78783>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78784>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78785>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78786>>>>>>>>>>>        If (iIndex = -1) Begin
78788>>>>>>>>>>>            Function_Return False
78789>>>>>>>>>>>        End
78789>>>>>>>>>>>>
78789>>>>>>>>>>>
78789>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78790>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78791>>>>>>>>>>>        If (ghoConnection > 0) Begin
78793>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78794>>>>>>>>>>>            If (iIndex <> -1) Begin
78796>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78797>>>>>>>>>>>            End
78797>>>>>>>>>>>>
78797>>>>>>>>>>>        End
78797>>>>>>>>>>>>
78797>>>>>>>>>>>
78797>>>>>>>>>>>        Function_Return bRetval
78798>>>>>>>>>>>    End_Function
78799>>>>>>>>>>>
78799>>>>>>>>>>>End_Class
78800>>>>>>>>>Use vWin32fh.pkg
78800>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\DfAbout.pkg)
78800>>>>>>>>>>>Use LanguageText.pkg
78800>>>>>>>>>>>Use Windows.pkg
78800>>>>>>>>>>>Use Dfclient.pkg
78800>>>>>>>>>>>Use DFbitmap.pkg
78800>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78800>>>>>>>>>>>Use cRichEdit.pkg
78800>>>>>>>>>>>Use cTextEdit.pkg
78800>>>>>>>>>>>Use cRichEdit.pkg
78800>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 23.0\Pkg\gFormatNumbers.pkg)
78800>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cFormatter.pkg)
78800>>>>>>>>>>>>>>>Use VDFBase.pkg
78800>>>>>>>>>>>>>>>
78800>>>>>>>>>>>>>>>Class cFormatter is an cObject
78801>>>>>>>>>>>>>>>    
78801>>>>>>>>>>>>>>>    Procedure Construct_object
78803>>>>>>>>>>>>>>>        Integer iCh
78803>>>>>>>>>>>>>>>        Forward Send construct_object
78805>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78806>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78807>>>>>>>>>>>>>>>        
78807>>>>>>>>>>>>>>>        Property String  psLeft
78808>>>>>>>>>>>>>>>        Property String  psright
78809>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78810>>>>>>>>>>>>>>>        Property Integer piPoints
78811>>>>>>>>>>>>>>>        
78811>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78812>>>>>>>>>>>>>>>        Property String  psCurPosright
78813>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78814>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78815>>>>>>>>>>>>>>>        
78815>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78816>>>>>>>>>>>>>>>        Property String  psCurNegright
78817>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78818>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78819>>>>>>>>>>>>>>>        
78819>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78820>>>>>>>>>>>>>>>        Property String  psNumPosright
78821>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78822>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78823>>>>>>>>>>>>>>>        
78823>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78824>>>>>>>>>>>>>>>        Property String  psNumNegright
78825>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78826>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78827>>>>>>>>>>>>>>>        
78827>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78828>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78829>>>>>>>>>>>>>>>        
78829>>>>>>>>>>>>>>>    End_Procedure
78830>>>>>>>>>>>>>>>    
78830>>>>>>>>>>>>>>>    // internal
78830>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78830>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78832>>>>>>>>>>>>>>>        
78832>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78832>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78832>>>>>>>>>>>>>>>        
78832>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78832>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78832>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78833>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78834>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78835>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78836>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78837>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78838>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78839>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78840>>>>>>>>>>>>>>>        
78840>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78841>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78844>>>>>>>>>>>>>>>        
78844>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78845>>>>>>>>>>>>>>>        
78845>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78846>>>>>>>>>>>>>>>        
78846>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78846>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78847>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78848>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78849>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78850>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78851>>>>>>>>>>>>>>>        
78851>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78853>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78854>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78856>>>>>>>>>>>>>>>                Move -2 to iDigits
78857>>>>>>>>>>>>>>>                Increment i
78858>>>>>>>>>>>>>>>            End
78858>>>>>>>>>>>>>>>>
78858>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78862>>>>>>>>>>>>>>>                Increment i
78863>>>>>>>>>>>>>>>            Loop
78864>>>>>>>>>>>>>>>>
78864>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78865>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78868>>>>>>>>>>>>>>>            //
78868>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78869>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78873>>>>>>>>>>>>>>>                Increment i
78874>>>>>>>>>>>>>>>            Loop
78875>>>>>>>>>>>>>>>>
78875>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78876>>>>>>>>>>>>>>>        End
78876>>>>>>>>>>>>>>>>
78876>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78877>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78878>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78879>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78881>>>>>>>>>>>>>>>                Move sFmt to sLeft
78882>>>>>>>>>>>>>>>                Move ""   to sRight
78883>>>>>>>>>>>>>>>            End
78883>>>>>>>>>>>>>>>>
78883>>>>>>>>>>>>>>>            Else Begin
78884>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78885>>>>>>>>>>>>>>>                Move 1 to i
78886>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78890>>>>>>>>>>>>>>>                    Increment i
78891>>>>>>>>>>>>>>>                Loop
78892>>>>>>>>>>>>>>>>
78892>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78893>>>>>>>>>>>>>>>            End
78893>>>>>>>>>>>>>>>>
78893>>>>>>>>>>>>>>>        End
78893>>>>>>>>>>>>>>>>
78893>>>>>>>>>>>>>>>        // set temporary format properties and exit
78893>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78894>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78895>>>>>>>>>>>>>>>        Set psRight        to sRight
78896>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78897>>>>>>>>>>>>>>>    End_Procedure
78898>>>>>>>>>>>>>>>    
78898>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78898>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78898>>>>>>>>>>>>>>>    //
78898>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78898>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78900>>>>>>>>>>>>>>>        String sPos sNeg
78900>>>>>>>>>>>>>>>        Integer iPos
78900>>>>>>>>>>>>>>>        
78900>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78901>>>>>>>>>>>>>>>        If iPos Begin
78903>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78904>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78905>>>>>>>>>>>>>>>        End
78905>>>>>>>>>>>>>>>>
78905>>>>>>>>>>>>>>>        Else Begin
78906>>>>>>>>>>>>>>>            Move sFmt         to sPos
78907>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78908>>>>>>>>>>>>>>>        End
78908>>>>>>>>>>>>>>>>
78908>>>>>>>>>>>>>>>        Send ParseFormat sPos
78909>>>>>>>>>>>>>>>        If bCurrency Begin
78911>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78912>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78913>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78914>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78915>>>>>>>>>>>>>>>        End
78915>>>>>>>>>>>>>>>>
78915>>>>>>>>>>>>>>>        Else Begin
78916>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78917>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78918>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78919>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78920>>>>>>>>>>>>>>>        End
78920>>>>>>>>>>>>>>>>
78920>>>>>>>>>>>>>>>        
78920>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78921>>>>>>>>>>>>>>>        If bCurrency Begin
78923>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78924>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78925>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78926>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78927>>>>>>>>>>>>>>>        End
78927>>>>>>>>>>>>>>>>
78927>>>>>>>>>>>>>>>        Else Begin
78928>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78929>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78930>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78931>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78932>>>>>>>>>>>>>>>        End
78932>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>    End_Procedure
78933>>>>>>>>>>>>>>>    
78933>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78933>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78935>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78935>>>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78935>>>>>>>>>>>>>>>        
78935>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78938>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78939>>>>>>>>>>>>>>>        
78939>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78940>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78941>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78942>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78943>>>>>>>>>>>>>>>        // format for decimal separator
78943>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78946>>>>>>>>>>>>>>>        
78946>>>>>>>>>>>>>>>        // format for thousand sep.
78946>>>>>>>>>>>>>>>        If bSep Begin
78948>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78951>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78952>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78953>>>>>>>>>>>>>>>            While (iLen>3)
78957>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78958>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
78959>>>>>>>>>>>>>>>            Loop
78960>>>>>>>>>>>>>>>>
78960>>>>>>>>>>>>>>>        End
78960>>>>>>>>>>>>>>>>
78960>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78960>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78963>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78964>>>>>>>>>>>>>>>    End_Function
78965>>>>>>>>>>>>>>>    
78965>>>>>>>>>>>>>>>    // Public: Format for currency
78965>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78967>>>>>>>>>>>>>>>        String  sLeft sRight
78967>>>>>>>>>>>>>>>        Integer bSep
78967>>>>>>>>>>>>>>>        If (nNumber<0) Begin
78969>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78970>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
78971>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
78972>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78975>>>>>>>>>>>>>>>        End
78975>>>>>>>>>>>>>>>>
78975>>>>>>>>>>>>>>>        Else Begin
78976>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78977>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
78978>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
78979>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78982>>>>>>>>>>>>>>>        End
78982>>>>>>>>>>>>>>>>
78982>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78983>>>>>>>>>>>>>>>    End_Function
78984>>>>>>>>>>>>>>>    
78984>>>>>>>>>>>>>>>    // Public: Format for numeric
78984>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78986>>>>>>>>>>>>>>>        String  sLeft sRight
78986>>>>>>>>>>>>>>>        Integer bSep
78986>>>>>>>>>>>>>>>        If (nNumber<0) Begin
78988>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78989>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
78990>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
78991>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78994>>>>>>>>>>>>>>>        End
78994>>>>>>>>>>>>>>>>
78994>>>>>>>>>>>>>>>        Else Begin
78995>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78996>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
78997>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
78998>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79001>>>>>>>>>>>>>>>        End
79001>>>>>>>>>>>>>>>>
79001>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79002>>>>>>>>>>>>>>>    End_Function
79003>>>>>>>>>>>>>>>    
79003>>>>>>>>>>>>>>>    
79003>>>>>>>>>>>>>>>    // Public: Format passing format string
79003>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79005>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79005>>>>>>>>>>>>>>>        String  sLeft sRight
79005>>>>>>>>>>>>>>>        Integer iPoints bSep
79005>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79006>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79007>>>>>>>>>>>>>>>        Case Begin
79007>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79010>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79014>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79018>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79020>>>>>>>>>>>>>>>        Case End
79020>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79021>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79022>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79023>>>>>>>>>>>>>>>        Get psRight        to sRight
79024>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79025>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79026>>>>>>>>>>>>>>>    End_Function
79027>>>>>>>>>>>>>>>    
79027>>>>>>>>>>>>>>>End_Class
79028>>>>>>>>>>>>>
79028>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79028>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79029>>>>>>>>>>>>>
79029>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79031>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79032>>>>>>>>>>>>>End_Function
79033>>>>>>>>>>>>>
79033>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79035>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79036>>>>>>>>>>>>>End_Function
79037>>>>>>>>>>>>>
79037>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79039>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79040>>>>>>>>>>>>>End_Function
79041>>>>>>>>>>>>>
79041>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79043>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79044>>>>>>>>>>>>>End_Procedure
79045>>>>>>>>>>>>>
79045>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79047>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79048>>>>>>>>>>>>>End_Procedure
79049>>>>>>>>>>>>>
79049>>>>>>>>>>>>>
79049>>>>>>>>>>>Use tWinStructs.pkg
79049>>>>>>>>>>>
79049>>>>>>>>>>>Use cli.pkg
79049>>>>>>>>>>>Use DFBTRDRV.PKG
79049>>>>>>>>>>>Use MSSqldrv.pkg
79049>>>>>>>>>>>Use db2_drv.pkg
79049>>>>>>>>>>>Use odbc_drv.pkg
79049>>>>>>>>>>>Use seq_chnl.pkg
79049>>>>>>>>>>>
79049>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79049>>>>>>>>>>>Register_Function Help_filename Returns String
79049>>>>>>>>>>>Register_Function GetHelpFile Returns String
79049>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79049>>>>>>>>>>>
79049>>>>>>>>>>>// *** Constant Declarations: ***
79049>>>>>>>>>>>//
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>// System icon menu constants. If the upper left hand
79049>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79049>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79049>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79049>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79049>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79049>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79049>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79049>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79049>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79049>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79049>>>>>>>>>>>
79049>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79049>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79049>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79049>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79049>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79049>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79049>>>>>>>>>>>
79049>>>>>>>>>>>// *** Struct Declarations: ***
79049>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79049>>>>>>>>>>>    DWord   cbSize
79049>>>>>>>>>>>    Integer fMask
79049>>>>>>>>>>>    Handle  hwnd
79049>>>>>>>>>>>    Pointer lpVerb
79049>>>>>>>>>>>    Pointer lpFile
79049>>>>>>>>>>>    Pointer lpParameters
79049>>>>>>>>>>>    Pointer lpDirectory
79049>>>>>>>>>>>    Integer nShow
79049>>>>>>>>>>>    Pointer hInstApp
79049>>>>>>>>>>>    Pointer lpIDList
79049>>>>>>>>>>>    Pointer lpClass
79049>>>>>>>>>>>    Handle  hkeyClass
79049>>>>>>>>>>>    DWord   dwHotKey
79049>>>>>>>>>>>    Handle  hIconMonitor // Union
79049>>>>>>>>>>>    //Handle  hMonitor     // Union
79049>>>>>>>>>>>    Handle  hProcess
79049>>>>>>>>>>>End_Struct
79049>>>>>>>>>>>
79049>>>>>>>>>>>
79049>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79049>>>>>>>>>>>//Type MEMORYSTATUS
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79049>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79049>>>>>>>>>>>//End_Type
79049>>>>>>>>>>>
79049>>>>>>>>>>>// *** External Function calls: ***
79049>>>>>>>>>>>//
79049>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79050>>>>>>>>>>>
79050>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79051>>>>>>>>>>>
79051>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79051>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79052>>>>>>>>>>>
79052>>>>>>>>>>>    // Wrapper Function WNetGetUser
79052>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79054>>>>>>>>>>>
79054>>>>>>>>>>>        DWord   dwResult
79054>>>>>>>>>>>        UWide   uwName uwUserName
79054>>>>>>>>>>>        UWide   uwName uwUserName
79054>>>>>>>>>>>
79054>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79055>>>>>>>>>>>
79055>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79056>>>>>>>>>>>
79056>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79057>>>>>>>>>>>
79057>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79058>>>>>>>>>>>
79058>>>>>>>>>>>        Function_Return dwResult
79059>>>>>>>>>>>    End_Function
79060>>>>>>>>>>>
79060>>>>>>>>>>>
79060>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79061>>>>>>>>>>>
79061>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79062>>>>>>>>>>>
79062>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79063>>>>>>>>>>>
79063>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79064>>>>>>>>>>>
79064>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79065>>>>>>>>>>>
79065>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79065>>>>>>>>>>>
79065>>>>>>>>>>>Function ComputerName Desktop Returns String
79067>>>>>>>>>>>    String sName
79067>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79068>>>>>>>>>>>>
79068>>>>>>>>>>>    Function_Return sName
79069>>>>>>>>>>>End_Function
79070>>>>>>>>>>>
79070>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79072>>>>>>>>>>>    WString wName
79072>>>>>>>>>>>    Integer iRetval iLength
79072>>>>>>>>>>>
79072>>>>>>>>>>>    Move 0 to iLength
79073>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79074>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79075>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79076>>>>>>>>>>>
79076>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79078>>>>>>>>>>>        Function_Return (CString (wName))
79079>>>>>>>>>>>    End
79079>>>>>>>>>>>>
79079>>>>>>>>>>>
79079>>>>>>>>>>>    Function_Return "User Unknown"
79080>>>>>>>>>>>End_Function
79081>>>>>>>>>>>
79081>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79083>>>>>>>>>>>    String sClient sDriver sClientDriver
79083>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79083>>>>>>>>>>>    Handle hoMsqlDrv
79083>>>>>>>>>>>
79083>>>>>>>>>>>    Move 0 to iDriver
79084>>>>>>>>>>>    Move "" to sClient
79085>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79088>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79094>>>>>>>>>>>>
79094>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79097>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79099>>>>>>>>>>>            Move iCount to iDriver
79100>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79101>>>>>>>>>>>        End
79101>>>>>>>>>>>>
79101>>>>>>>>>>>    Loop
79102>>>>>>>>>>>>
79102>>>>>>>>>>>
79102>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79102>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79104>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79107>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79108>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79109>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79110>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79111>>>>>>>>>>>    End
79111>>>>>>>>>>>>
79111>>>>>>>>>>>
79111>>>>>>>>>>>    Function_Return sClient
79112>>>>>>>>>>>End_Function
79113>>>>>>>>>>>
79113>>>>>>>>>>>// *** Class Declarations: ***
79113>>>>>>>>>>>//
79113>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79114>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79116>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79117>>>>>>>>>>>    End_Procedure
79118>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79120>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79122>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79123>>>>>>>>>>>    End_Procedure
79124>>>>>>>>>>>End_Class
79125>>>>>>>>>>>
79125>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79126>>>>>>>>>>>    Procedure Construct_Object
79128>>>>>>>>>>>        Forward Send Construct_Object
79130>>>>>>>>>>>        Property Handle phoEditorHandle
79131>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79132>>>>>>>>>>>    End_Procedure
79133>>>>>>>>>>>
79133>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79135>>>>>>>>>>>        Handle hoEditor
79135>>>>>>>>>>>        Boolean bCanCopy
79135>>>>>>>>>>>        Address aEditorAddress
79135>>>>>>>>>>>
79135>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79136>>>>>>>>>>>        Send Select_All of hoEditor
79137>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79138>>>>>>>>>>>        If (bCanCopy = True) Begin
79140>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79141>>>>>>>>>>>            Send Copy   of hoEditor
79142>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79142>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79143>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79144>>>>>>>>>>>        End
79144>>>>>>>>>>>>
79144>>>>>>>>>>>    End_Procedure
79145>>>>>>>>>>>End_Class
79146>>>>>>>>>>>
79146>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79147>>>>>>>>>>>    Procedure Construct_Object
79149>>>>>>>>>>>        Forward Send Construct_Object
79151>>>>>>>>>>>
79151>>>>>>>>>>>        Set Size to 100 245
79152>>>>>>>>>>>        Set Location to 6 6
79153>>>>>>>>>>>        Set Border_Style to Border_None
79154>>>>>>>>>>>        Set Read_Only_State to True
79155>>>>>>>>>>>        Set pbWrap to True
79156>>>>>>>>>>>        Set peAnchors to anAll
79157>>>>>>>>>>>    End_Procedure
79158>>>>>>>>>>>
79158>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79158>>>>>>>>>>>
79158>>>>>>>>>>>    Procedure AppendTextLn String sText
79160>>>>>>>>>>>        String sWorkspaceWSFile
79160>>>>>>>>>>>
79160>>>>>>>>>>>        // Only works for English:
79160>>>>>>>>>>>        If (ghoApplication > 0) Begin
79162>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79164>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79165>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79166>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79167>>>>>>>>>>>            End
79167>>>>>>>>>>>>
79167>>>>>>>>>>>        End
79167>>>>>>>>>>>>
79167>>>>>>>>>>>        Send AppendText sText
79168>>>>>>>>>>>        Send AppendText (character(10))
79169>>>>>>>>>>>    End_Procedure
79170>>>>>>>>>>>
79170>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79170>>>>>>>>>>>    //    information box
79170>>>>>>>>>>>    Procedure Show_Current_Directory
79172>>>>>>>>>>>        String sDir
79172>>>>>>>>>>>
79172>>>>>>>>>>>        Get_Current_Directory To sDir
79173>>>>>>>>>>>
79173>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79174>>>>>>>>>>>    End_Procedure
79175>>>>>>>>>>>
79175>>>>>>>>>>>    Procedure Show_Windows_Directory
79177>>>>>>>>>>>        String sWindir
79177>>>>>>>>>>>
79177>>>>>>>>>>>        Get_Windows_Directory To sWindir
79178>>>>>>>>>>>
79178>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79179>>>>>>>>>>>    End_Procedure
79180>>>>>>>>>>>
79180>>>>>>>>>>>    Procedure Show_Current_User
79182>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79183>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79184>>>>>>>>>>>    End_Procedure
79185>>>>>>>>>>>
79185>>>>>>>>>>>    Procedure Show_Number_Format
79187>>>>>>>>>>>        Integer iFormat
79187>>>>>>>>>>>        String sFormatText
79187>>>>>>>>>>>
79187>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79190>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79191>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79192>>>>>>>>>>>
79192>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79195>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79196>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79197>>>>>>>>>>>    End_Procedure
79198>>>>>>>>>>>
79198>>>>>>>>>>>    Procedure Show_Filelist_Name
79200>>>>>>>>>>>        String sFilename
79200>>>>>>>>>>>
79200>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79203>>>>>>>>>>>
79203>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79204>>>>>>>>>>>    End_Procedure
79205>>>>>>>>>>>
79205>>>>>>>>>>>    Procedure Show_Lock_Delay
79207>>>>>>>>>>>        Integer iLockdelay
79207>>>>>>>>>>>
79207>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79210>>>>>>>>>>>
79210>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79211>>>>>>>>>>>    End_Procedure
79212>>>>>>>>>>>
79212>>>>>>>>>>>    Procedure Show_Lock_Timeout
79214>>>>>>>>>>>        Integer iLockTimeout
79214>>>>>>>>>>>
79214>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79217>>>>>>>>>>>
79217>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79218>>>>>>>>>>>    End_Procedure
79219>>>>>>>>>>>
79219>>>>>>>>>>>    Procedure Show_Screen_Size
79221>>>>>>>>>>>        Integer iYscreensize iXscreensize
79221>>>>>>>>>>>
79221>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79222>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79223>>>>>>>>>>>
79223>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79224>>>>>>>>>>>    End_Procedure
79225>>>>>>>>>>>
79225>>>>>>>>>>>    Procedure Show_Page_Size
79227>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79228>>>>>>>>>>>    End_procedure
79229>>>>>>>>>>>
79229>>>>>>>>>>>    Procedure Show_Date
79231>>>>>>>>>>>        Date dToday
79231>>>>>>>>>>>
79231>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79232>>>>>>>>>>>
79232>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79233>>>>>>>>>>>    End_procedure
79234>>>>>>>>>>>
79234>>>>>>>>>>>    Procedure Show_Date_Format
79236>>>>>>>>>>>        Integer iDateFormat
79236>>>>>>>>>>>        String sDateFormat
79236>>>>>>>>>>>
79236>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79239>>>>>>>>>>>        Case Begin
79239>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79241>>>>>>>>>>>                Move C_$USA To sDateFormat
79242>>>>>>>>>>>                Case Break
79243>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79246>>>>>>>>>>>                Move C_$European To sDateFormat
79247>>>>>>>>>>>                Case Break
79248>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79251>>>>>>>>>>>                Move C_$Military To sDateFormat
79252>>>>>>>>>>>                Case Break
79253>>>>>>>>>>>            Case Else
79253>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79254>>>>>>>>>>>                Case Break
79255>>>>>>>>>>>        Case End
79255>>>>>>>>>>>
79255>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79256>>>>>>>>>>>    End_Procedure
79257>>>>>>>>>>>
79257>>>>>>>>>>>    // 2013-08-14 NGS
79257>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79257>>>>>>>>>>>    Procedure Show_Systemresources
79259>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79259>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79259>>>>>>>>>>>        Integer iRetval
79259>>>>>>>>>>>        Number nValue
79259>>>>>>>>>>>        String sValue
79259>>>>>>>>>>>
79259>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79260>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79261>>>>>>>>>>>        If (iRetval = 0) Begin
79263>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79264>>>>>>>>>>>            Procedure_Return
79265>>>>>>>>>>>        End
79265>>>>>>>>>>>>
79265>>>>>>>>>>>
79265>>>>>>>>>>>        Send AppendTextLn ""
79266>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79267>>>>>>>>>>>
79267>>>>>>>>>>>        // Show memory in Gigabytes:
79267>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79268>>>>>>>>>>>        Move (Round(nValue)) to nValue
79269>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79270>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79271>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79272>>>>>>>>>>>
79272>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79272>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79273>>>>>>>>>>>        Move (Round(nValue)) to nValue
79274>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79275>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79276>>>>>>>>>>>
79276>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79276>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79277>>>>>>>>>>>        Move (Round(nValue)) to nValue
79278>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79279>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79280>>>>>>>>>>>
79280>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79280>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79281>>>>>>>>>>>        Move (Round(nValue)) to nValue
79282>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79283>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79284>>>>>>>>>>>
79284>>>>>>>>>>>        // Add an empty row after the memory information:
79284>>>>>>>>>>>        Send AppendTextLn ""
79285>>>>>>>>>>>    End_Procedure
79286>>>>>>>>>>>
79286>>>>>>>>>>>    Procedure Show_Registration
79288>>>>>>>>>>>        String sRegName
79288>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79288>>>>>>>>>>>
79288>>>>>>>>>>>        Registration sRegName iSN
79289>>>>>>>>>>>>
79289>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79290>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79291>>>>>>>>>>>
79291>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79292>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79293>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79294>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79295>>>>>>>>>>>    End_Procedure
79296>>>>>>>>>>>
79296>>>>>>>>>>>    //****************************************************************************
79296>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79296>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79296>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79296>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79296>>>>>>>>>>>    // information To be displayed
79296>>>>>>>>>>>    //****************************************************************************
79296>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79296>>>>>>>>>>>
79296>>>>>>>>>>>    Procedure Show_ServicePack
79298>>>>>>>>>>>        String sKey sVersion sDataFlex
79298>>>>>>>>>>>        Handle hoRegistry
79298>>>>>>>>>>>        Boolean bExists bOpened
79298>>>>>>>>>>>
79298>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79299>>>>>>>>>>>
79299>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79300>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79301>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79302>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79303>>>>>>>>>>>
79303>>>>>>>>>>>        If (bExists) Begin
79305>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79306>>>>>>>>>>>        End
79306>>>>>>>>>>>>
79306>>>>>>>>>>>        Else Begin
79307>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79308>>>>>>>>>>>        End
79308>>>>>>>>>>>>
79308>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79309>>>>>>>>>>>        If (bExists) Begin
79311>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79312>>>>>>>>>>>            If (bOpened) Begin
79314>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79315>>>>>>>>>>>                If (bExists) Begin
79317>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79318>>>>>>>>>>>                End
79318>>>>>>>>>>>>
79318>>>>>>>>>>>                Send CloseKey of hoRegistry
79319>>>>>>>>>>>            End
79319>>>>>>>>>>>>
79319>>>>>>>>>>>        End
79319>>>>>>>>>>>>
79319>>>>>>>>>>>        Send Destroy of hoRegistry
79320>>>>>>>>>>>
79320>>>>>>>>>>>        If (sVersion <> "") Begin
79322>>>>>>>>>>>           Send AppendTextLn sVersion
79323>>>>>>>>>>>           Send AppendTextLn ""
79324>>>>>>>>>>>        End
79324>>>>>>>>>>>>
79324>>>>>>>>>>>    End_Procedure
79325>>>>>>>>>>>
79325>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79327>>>>>>>>>>>        Integer hoWorkspace
79327>>>>>>>>>>>
79327>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79329>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79330>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79332>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79333>>>>>>>>>>>            End
79333>>>>>>>>>>>>
79333>>>>>>>>>>>        End
79333>>>>>>>>>>>>
79333>>>>>>>>>>>    End_Procedure
79334>>>>>>>>>>>
79334>>>>>>>>>>>    //****************************************************************************
79334>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79334>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79334>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79334>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79334>>>>>>>>>>>    // the information To be displayed
79334>>>>>>>>>>>    //****************************************************************************
79334>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79334>>>>>>>>>>>
79334>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79336>>>>>>>>>>>        If (ghoConnection > 0) Begin
79338>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79339>>>>>>>>>>>            Send AppendTextLn ""
79340>>>>>>>>>>>        End
79340>>>>>>>>>>>>
79340>>>>>>>>>>>    End_Procedure
79341>>>>>>>>>>>
79341>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79343>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79344>>>>>>>>>>>    End_Function
79345>>>>>>>>>>>
79345>>>>>>>>>>>    Procedure Show_Versions
79347>>>>>>>>>>>        Integer iVersion iRevision iBuild
79347>>>>>>>>>>>
79347>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79349>>>>>>>>>>>
79349>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79350>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79351>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79352>>>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79353>>>>>>>>>>>    End_Procedure
79354>>>>>>>>>>>
79354>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79356>>>>>>>>>>>        Boolean bOK
79356>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79357>>>>>>>>>>>        Function_Return bOK
79358>>>>>>>>>>>    End_Function
79359>>>>>>>>>>>
79359>>>>>>>>>>>    //***
79359>>>>>>>>>>>    //*** BW
79359>>>>>>>>>>>    //*** Procedure: Show_Drivers
79359>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79359>>>>>>>>>>>    //***
79359>>>>>>>>>>>
79359>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79359>>>>>>>>>>>//    #Warning -3
79359>>>>>>>>>>>//#ENDIF
79359>>>>>>>>>>>    Procedure Show_Drivers
79361>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79361>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79361>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79361>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79361>>>>>>>>>>>
79361>>>>>>>>>>>        Move False to bStudioLicense
79362>>>>>>>>>>>
79362>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79363>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79364>>>>>>>>>>>
79364>>>>>>>>>>>        // For testing purposes:
79364>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79364>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79364>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79364>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79364>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79364>>>>>>>>>>>//
79364>>>>>>>>>>>        Move False to Err
79365>>>>>>>>>>>
79365>>>>>>>>>>>        // Loop through all loaded drivers.
79365>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79368>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79370>>>>>>>>>>>            Send AppendTextLn ""
79371>>>>>>>>>>>        End
79371>>>>>>>>>>>>
79371>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79377>>>>>>>>>>>>
79377>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79378>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79381>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79382>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79383>>>>>>>>>>>
79383>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79385>>>>>>>>>>>
79385>>>>>>>>>>>                // Pervasive/Btrieve database
79385>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79387>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79388>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79389>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79391>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79392>>>>>>>>>>>                    End
79392>>>>>>>>>>>>
79392>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79393>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79395>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79396>>>>>>>>>>>                    End
79396>>>>>>>>>>>>
79396>>>>>>>>>>>                End
79396>>>>>>>>>>>>
79396>>>>>>>>>>>
79396>>>>>>>>>>>                Else Begin
79397>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79398>>>>>>>>>>>                    Move 0 to iNumServers
79399>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79401>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79404>>>>>>>>>>>                    End
79404>>>>>>>>>>>>
79404>>>>>>>>>>>
79404>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79406>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79408>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79409>>>>>>>>>>>                        End
79409>>>>>>>>>>>>
79409>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79410>>>>>>>>>>>                    End
79410>>>>>>>>>>>>
79410>>>>>>>>>>>
79410>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79410>>>>>>>>>>>                    // Studio licens is in use and there is no
79410>>>>>>>>>>>                    // number of max users defined because the driver is
79410>>>>>>>>>>>                    // relying on the info from the VDF license.
79410>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79412>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79413>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79414>>>>>>>>>>>                    End
79414>>>>>>>>>>>>
79414>>>>>>>>>>>                End
79414>>>>>>>>>>>>
79414>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79415>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79417>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79418>>>>>>>>>>>                End
79418>>>>>>>>>>>>
79418>>>>>>>>>>>                If (iNumServers <> 0) Begin
79420>>>>>>>>>>>                    For iCount from 1 to iNumServers
79426>>>>>>>>>>>>
79426>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79429>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79431>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79432>>>>>>>>>>>                        End
79432>>>>>>>>>>>>
79432>>>>>>>>>>>                    Loop
79433>>>>>>>>>>>>
79433>>>>>>>>>>>                End
79433>>>>>>>>>>>>
79433>>>>>>>>>>>            End
79433>>>>>>>>>>>>
79433>>>>>>>>>>>        Loop
79434>>>>>>>>>>>>
79434>>>>>>>>>>>
79434>>>>>>>>>>>        Send AppendTextLn ""
79435>>>>>>>>>>>        If (bStudioLicense = False) Begin
79437>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79438>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79439>>>>>>>>>>>        End
79439>>>>>>>>>>>>
79439>>>>>>>>>>>        Else Begin
79440>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79441>>>>>>>>>>>        End
79441>>>>>>>>>>>>
79441>>>>>>>>>>>        Send Destroy of hoCLIHandler
79442>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79443>>>>>>>>>>>    End_Procedure
79444>>>>>>>>>>>
79444>>>>>>>>>>>    Procedure Show_HelpFile
79446>>>>>>>>>>>        String sHelpFile
79446>>>>>>>>>>>        Integer eHelpType
79446>>>>>>>>>>>
79446>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79448>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79449>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79451>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79452>>>>>>>>>>>            End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79455>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79456>>>>>>>>>>>            End
79456>>>>>>>>>>>>
79456>>>>>>>>>>>            Else Begin
79457>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79458>>>>>>>>>>>            End
79458>>>>>>>>>>>>
79458>>>>>>>>>>>
79458>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79459>>>>>>>>>>>        End
79459>>>>>>>>>>>>
79459>>>>>>>>>>>    End_Procedure
79460>>>>>>>>>>>
79460>>>>>>>>>>>    Procedure Show_EnterAsTab
79462>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79462>>>>>>>>>>>        String sText
79462>>>>>>>>>>>
79462>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79464>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79465>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79467>>>>>>>>>>>                Move "True" To sText
79468>>>>>>>>>>>            End
79468>>>>>>>>>>>>
79468>>>>>>>>>>>            Else Begin
79469>>>>>>>>>>>                Move "False" To sText
79470>>>>>>>>>>>            End
79470>>>>>>>>>>>>
79470>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79471>>>>>>>>>>>        End
79471>>>>>>>>>>>>
79471>>>>>>>>>>>    End_Procedure
79472>>>>>>>>>>>
79472>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79472>>>>>>>>>>>    //    found systeminformation
79472>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79474>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79476>>>>>>>>>>>
79476>>>>>>>>>>>        Send Delete_Data
79477>>>>>>>>>>>
79477>>>>>>>>>>>        Set Changed_State To False
79478>>>>>>>>>>>        Set Read_Only_State To True
79479>>>>>>>>>>>
79479>>>>>>>>>>>        Send Show_Registration
79480>>>>>>>>>>>        Send Show_Drivers
79481>>>>>>>>>>>        Send Show_ServicePack
79482>>>>>>>>>>>        Send Show_Versions
79483>>>>>>>>>>>        Send AppendTextLn ""
79484>>>>>>>>>>>
79484>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79486>>>>>>>>>>>            Send Show_WorkSpaceInformation
79487>>>>>>>>>>>            Send Show_HelpFile
79488>>>>>>>>>>>            Send AppendTextLn ""
79489>>>>>>>>>>>        End
79489>>>>>>>>>>>>
79489>>>>>>>>>>>        Else Begin
79490>>>>>>>>>>>            Send AppendTextLn ""
79491>>>>>>>>>>>        End
79491>>>>>>>>>>>>
79491>>>>>>>>>>>
79491>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79493>>>>>>>>>>>            Send Show_ConnectionIdInformation
79494>>>>>>>>>>>        End
79494>>>>>>>>>>>>
79494>>>>>>>>>>>
79494>>>>>>>>>>>        Send Show_Current_User
79495>>>>>>>>>>>        Send Show_Windows_Directory
79496>>>>>>>>>>>        Send Show_Current_Directory
79497>>>>>>>>>>>
79497>>>>>>>>>>>        // This is already shown in the workspace details,
79497>>>>>>>>>>>        // unless no workspace object is present:
79497>>>>>>>>>>>        If (ghoApplication = 0) Begin
79499>>>>>>>>>>>            Send Show_Filelist_Name
79500>>>>>>>>>>>        End
79500>>>>>>>>>>>>
79500>>>>>>>>>>>
79500>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79502>>>>>>>>>>>            Send AppendTextLn ""
79503>>>>>>>>>>>            Send Show_EnterAsTab
79504>>>>>>>>>>>        End
79504>>>>>>>>>>>>
79504>>>>>>>>>>>
79504>>>>>>>>>>>        Send Show_Screen_Size
79505>>>>>>>>>>>        Send Show_Page_Size
79506>>>>>>>>>>>        Send Show_Number_Format
79507>>>>>>>>>>>        Send Show_Date_Format
79508>>>>>>>>>>>        Send Show_Lock_Delay
79509>>>>>>>>>>>        Send Show_Lock_Timeout
79510>>>>>>>>>>>        Send Show_Date
79511>>>>>>>>>>>        Send Show_Systemresources
79512>>>>>>>>>>>        Send Beginning_of_Data
79513>>>>>>>>>>>
79513>>>>>>>>>>>        Set Icon to 'default.ico'
79514>>>>>>>>>>>    End_Procedure
79515>>>>>>>>>>>End_Class
79516>>>>>>>>>>>
79516>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79517>>>>>>>>>>>    Procedure Construct_Object
79519>>>>>>>>>>>        Forward Send Construct_Object
79521>>>>>>>>>>>
79521>>>>>>>>>>>        Set Label to C_$SystemInformation
79522>>>>>>>>>>>        Set Size to 140 267
79523>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79524>>>>>>>>>>>        Set Border_Style to Border_Thick
79525>>>>>>>>>>>        Set Sysmenu_Icon to False
79526>>>>>>>>>>>
79526>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79526>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79527>>>>>>>>>>>
79527>>>>>>>>>>>        // 2014-09-14 NGS
79527>>>>>>>>>>>        // Added a container object around the cTexteditor
79527>>>>>>>>>>>        // object to get a border around the text.
79527>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79529>>>>>>>>>>>            Set Location to 2 4
79530>>>>>>>>>>>            Set Size to 110 255
79531>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79532>>>>>>>>>>>            Set Color to clWhite
79533>>>>>>>>>>>            Set peAnchors to anAll
79534>>>>>>>>>>>
79534>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79536>>>>>>>>>>>            End_Object
79537>>>>>>>>>>>
79537>>>>>>>>>>>        End_Object
79538>>>>>>>>>>>
79538>>>>>>>>>>>        Object oCloseButton is a Button
79540>>>>>>>>>>>            Set Label to C_$Close
79541>>>>>>>>>>>            Set Location to 120 210
79542>>>>>>>>>>>            CompilerWarnings Off
79542>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79543>>>>>>>>>>>            CompilerWarnings On
79543>>>>>>>>>>>            Set Default_State To True
79544>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79544>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79544>>>>>>>>>>>            // for that situation.
79544>>>>>>>>>>>            Set peAnchors to anBottomRight
79545>>>>>>>>>>>        End_Object
79546>>>>>>>>>>>
79546>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79548>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79549>>>>>>>>>>>            Set Size to 14 50
79550>>>>>>>>>>>            Set Location to 120 158
79551>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79551>>>>>>>>>>>            // we might as well prepare the object for it.
79551>>>>>>>>>>>            Set peAnchors to anBottomRight
79552>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79553>>>>>>>>>>>        End_Object
79554>>>>>>>>>>>
79554>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79555>>>>>>>>>>>    End_Procedure
79556>>>>>>>>>>>
79556>>>>>>>>>>>    Procedure Page Integer iPageObject
79558>>>>>>>>>>>        Handle hMenu
79558>>>>>>>>>>>        Integer iPrevState
79558>>>>>>>>>>>
79558>>>>>>>>>>>        Forward Send Page iPageObject
79560>>>>>>>>>>>
79560>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79560>>>>>>>>>>>        //
79560>>>>>>>>>>>    End_Procedure
79561>>>>>>>>>>>
79561>>>>>>>>>>>End_Class
79562>>>>>>>>>>>
79562>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79563>>>>>>>>>>>    Procedure Construct_Object
79565>>>>>>>>>>>        Forward Send Construct_Object
79567>>>>>>>>>>>
79567>>>>>>>>>>>        Property String psContentText
79568>>>>>>>>>>>
79568>>>>>>>>>>>        Set Size to 77 153
79569>>>>>>>>>>>        Set Location to 8 60
79570>>>>>>>>>>>        Set Read_Only_State to True
79571>>>>>>>>>>>        Set Skip_State to True
79572>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79572>>>>>>>>>>>        // or 1/20 of a printer's point.
79572>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79573>>>>>>>>>>>        Set Border_Style  to Border_None
79574>>>>>>>>>>>    End_Procedure
79575>>>>>>>>>>>
79575>>>>>>>>>>>    // Adds a line of text to the edit object
79575>>>>>>>>>>>    Procedure Add_Line String sText
79577>>>>>>>>>>>        String sContentText
79577>>>>>>>>>>>        Get psContentText to sContentText
79578>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79579>>>>>>>>>>>        Set psContentText to sContentText
79580>>>>>>>>>>>    End_Procedure
79581>>>>>>>>>>>
79581>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79581>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79581>>>>>>>>>>>    // because the object isn't paged yet when we add these
79581>>>>>>>>>>>    // values and the COM edit object needs to be paged
79581>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79581>>>>>>>>>>>    Procedure Add_LineLn String sText
79583>>>>>>>>>>>        String sContentText sCR
79583>>>>>>>>>>>
79583>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79584>>>>>>>>>>>        Get psContentText to sContentText
79585>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79586>>>>>>>>>>>        Set psContentText to sContentText
79587>>>>>>>>>>>    End_Procedure
79588>>>>>>>>>>>
79588>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79590>>>>>>>>>>>        String sLinkText
79590>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79591>>>>>>>>>>>        Send Show_HomePage sLinkText
79592>>>>>>>>>>>    End_Procedure
79593>>>>>>>>>>>
79593>>>>>>>>>>>    Procedure Page Integer iPageObject
79595>>>>>>>>>>>        String sContentText
79595>>>>>>>>>>>
79595>>>>>>>>>>>        Forward Send Page iPageObject
79597>>>>>>>>>>>        Get psContentText to sContentText
79598>>>>>>>>>>>        Send AppendText sContentText
79599>>>>>>>>>>>        send Beginning_of_Data
79600>>>>>>>>>>>    End_Procedure
79601>>>>>>>>>>>
79601>>>>>>>>>>>End_Class
79602>>>>>>>>>>>
79602>>>>>>>>>>>Class AboutDialog is a ModalPanel
79603>>>>>>>>>>>    Procedure Construct_Object
79605>>>>>>>>>>>
79605>>>>>>>>>>>        Forward Send Construct_Object
79607>>>>>>>>>>>
79607>>>>>>>>>>>        Set Label to C_$About
79608>>>>>>>>>>>        Set Size to 118 230
79609>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79610>>>>>>>>>>>        Set Border_Style to Border_Thick
79611>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79612>>>>>>>>>>>
79612>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79614>>>>>>>>>>>        End_Object
79615>>>>>>>>>>>
79615>>>>>>>>>>>        Object oBox is a Container3d
79617>>>>>>>>>>>            Set Border_Style to Border_Normal
79618>>>>>>>>>>>            Set Size to 90 220
79619>>>>>>>>>>>            Set Location to 4 5
79620>>>>>>>>>>>            Set Color to clWhite
79621>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79621>>>>>>>>>>>            // we might as well prepare the object for it.
79621>>>>>>>>>>>            Set peAnchors to anAll
79622>>>>>>>>>>>
79622>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79624>>>>>>>>>>>                Set Border_Style To Border_None
79625>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79626>>>>>>>>>>>                Set Color to clWhite
79627>>>>>>>>>>>                Set Size to 45 50
79628>>>>>>>>>>>                Set Location to 0 3
79629>>>>>>>>>>>            End_Object
79630>>>>>>>>>>>
79630>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79632>>>>>>>>>>>                Set Border_Style to Border_None
79633>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79634>>>>>>>>>>>                Set Color to clWhite
79635>>>>>>>>>>>                Set Size to 30 55
79636>>>>>>>>>>>                Set Location to 50 3
79637>>>>>>>>>>>            End_Object
79638>>>>>>>>>>>
79638>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79640>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79640>>>>>>>>>>>                // we might as well prepare the object for it.
79640>>>>>>>>>>>                Set peAnchors to anAll
79641>>>>>>>>>>>            End_Object
79642>>>>>>>>>>>
79642>>>>>>>>>>>            // These objects are here for backwards compatability only.
79642>>>>>>>>>>>            // They are not used.
79642>>>>>>>>>>>            Object oProductName is a TextBox
79644>>>>>>>>>>>                Set Label To C_$ProductName
79645>>>>>>>>>>>                Set Size To 10 45
79646>>>>>>>>>>>                Set Location To 8 53
79647>>>>>>>>>>>                Set Visible_State to False
79648>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79649>>>>>>>>>>>            End_Object
79650>>>>>>>>>>>
79650>>>>>>>>>>>            Object oVersion is a TextBox
79652>>>>>>>>>>>                Set Label To C_$Version
79653>>>>>>>>>>>                Set Size To 10 25
79654>>>>>>>>>>>                Set Location To 21 53
79655>>>>>>>>>>>                Set Visible_State to False
79656>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79657>>>>>>>>>>>            End_Object
79658>>>>>>>>>>>
79658>>>>>>>>>>>            Object oCopyright is a TextBox
79660>>>>>>>>>>>                Set Label To C_$Copyright
79661>>>>>>>>>>>                Set Size To 10 31
79662>>>>>>>>>>>                Set Location To 34 53
79663>>>>>>>>>>>                Set Visible_State to False
79664>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79665>>>>>>>>>>>            End_Object
79666>>>>>>>>>>>
79666>>>>>>>>>>>            Object oAuthor is a TextBox
79668>>>>>>>>>>>                Set Label To C_$Author
79669>>>>>>>>>>>                Set Size To 10 22
79670>>>>>>>>>>>                Set Location To 46 53
79671>>>>>>>>>>>                Set Visible_State to False
79672>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79673>>>>>>>>>>>            End_Object
79674>>>>>>>>>>>
79674>>>>>>>>>>>        End_Object
79675>>>>>>>>>>>
79675>>>>>>>>>>>        Object oOKButton is a Button
79677>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79678>>>>>>>>>>>            Set Location to 98 176
79679>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79679>>>>>>>>>>>            // we might as well prepare the object for it.
79679>>>>>>>>>>>            Set peAnchors to anBottomRight
79680>>>>>>>>>>>        End_Object
79681>>>>>>>>>>>
79681>>>>>>>>>>>        Object oSysInfoButton is a Button
79683>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79684>>>>>>>>>>>            Set Location to 98 123
79685>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79685>>>>>>>>>>>            // we might as well prepare the object for it.
79685>>>>>>>>>>>            Set peAnchors to anBottomRight
79686>>>>>>>>>>>        End_Object
79687>>>>>>>>>>>
79687>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79689>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79690>>>>>>>>>>>            Set Size to 14 50
79691>>>>>>>>>>>            Set Location to 98 70
79692>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79692>>>>>>>>>>>            // we might as well prepare the object for it.
79692>>>>>>>>>>>            Set peAnchors to anBottomRight
79693>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79694>>>>>>>>>>>        End_Object
79695>>>>>>>>>>>
79695>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79696>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79697>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79698>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79698>>>>>>>>>>>    End_Procedure
79699>>>>>>>>>>>
79699>>>>>>>>>>>    Procedure Page Integer iPageObject
79701>>>>>>>>>>>        Handle hMenu
79701>>>>>>>>>>>        Integer iPrevState
79701>>>>>>>>>>>
79701>>>>>>>>>>>        Forward Send Page iPageObject
79703>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79703>>>>>>>>>>>        Set Icon to "Default.ico"
79704>>>>>>>>>>>
79704>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79704>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79705>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79706>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79706>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79706>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79707>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79708>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79709>>>>>>>>>>>        // The "Close" menu command may be good to have.
79709>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79709>>>>>>>>>>>    End_Procedure
79710>>>>>>>>>>>
79710>>>>>>>>>>>    Procedure Set ProductName String sText
79712>>>>>>>>>>>        Set Value of oProductName to sText
79713>>>>>>>>>>>    End_Procedure
79714>>>>>>>>>>>
79714>>>>>>>>>>>    Procedure Set Copyright String sText
79716>>>>>>>>>>>        Set Value of oCopyright to sText
79717>>>>>>>>>>>    End_Procedure
79718>>>>>>>>>>>
79718>>>>>>>>>>>    Procedure Set Author String sText
79720>>>>>>>>>>>        Set Value of oAuthor to sText
79721>>>>>>>>>>>    End_Procedure
79722>>>>>>>>>>>
79722>>>>>>>>>>>    Procedure Set Version String sVersion
79724>>>>>>>>>>>        Handle hoVersionInfo
79724>>>>>>>>>>>        Boolean bIncluded
79724>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
79724>>>>>>>>>>>//        Date dCompileDate
79724>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79724>>>>>>>>>>>
79724>>>>>>>>>>>        If (sVersion = "") Begin
79726>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79726>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79726>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79728>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79729>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79731>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79732>>>>>>>>>>>                    If (bIncluded) Begin
79734>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79735>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79736>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79737>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79738>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79739>>>>>>>>>>>                    End
79739>>>>>>>>>>>>
79739>>>>>>>>>>>                End
79739>>>>>>>>>>>>
79739>>>>>>>>>>>            End
79739>>>>>>>>>>>>
79739>>>>>>>>>>>        End
79739>>>>>>>>>>>>
79739>>>>>>>>>>>
79739>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79739>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79740>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79742>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79743>>>>>>>>>>>        End
79743>>>>>>>>>>>>
79743>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
79743>>>>>>>>>>>//        If (sVersion <> "") Begin
79743>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79743>>>>>>>>>>>//        End
79743>>>>>>>>>>>
79743>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79744>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79746>>>>>>>>>>>            If (sCertInfo <> "") Begin
79748>>>>>>>>>>>                Send Add_LineLn sCertInfo
79749>>>>>>>>>>>            End
79749>>>>>>>>>>>>
79749>>>>>>>>>>>            Else Begin
79750>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79751>>>>>>>>>>>            End
79751>>>>>>>>>>>>
79751>>>>>>>>>>>        End
79751>>>>>>>>>>>>
79751>>>>>>>>>>>    End_Procedure
79752>>>>>>>>>>>
79752>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79754>>>>>>>>>>>        Boolean bIsDate
79754>>>>>>>>>>>        String sGoodCharacters sChar
79754>>>>>>>>>>>        Integer iCount iLength
79754>>>>>>>>>>>
79754>>>>>>>>>>>        Move True to bIsDate
79755>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79756>>>>>>>>>>>        Move (Length(sDate)) to iLength
79757>>>>>>>>>>>        For iCount from 1 to iLength
79763>>>>>>>>>>>>
79763>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79764>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79765>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79766>>>>>>>>>>>            If (bIsDate = False) Begin
79768>>>>>>>>>>>                Move iLength to iCount
79769>>>>>>>>>>>            End
79769>>>>>>>>>>>>
79769>>>>>>>>>>>        Loop
79770>>>>>>>>>>>>
79770>>>>>>>>>>>        Function_Return bIsDate
79771>>>>>>>>>>>    End_Function
79772>>>>>>>>>>>
79772>>>>>>>>>>>    Function GetCompileDate Returns Date
79774>>>>>>>>>>>        Date dCompileDate
79774>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79774>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79774>>>>>>>>>>>        Boolean bIsValid   
79774>>>>>>>>>>>        
79774>>>>>>>>>>>        Move 0 to dCompileDate
79775>>>>>>>>>>>        // Get full path to the current running executable
79775>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79776>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79777>>>>>>>>>>>
79777>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79777>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79778>>>>>>>>>>>
79778>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79780>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79781>>>>>>>>>>>        If (iPos > 0) Begin
79783>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79783>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79784>>>>>>>>>>>
79784>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79784>>>>>>>>>>>            // change the format and then move the string to the date variable.
79784>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79787>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79790>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79791>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79793>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79794>>>>>>>>>>>            End
79794>>>>>>>>>>>>
79794>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79795>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79796>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79799>>>>>>>>>>>        End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>        Else Begin
79800>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79801>>>>>>>>>>>>
79801>>>>>>>>>>>        End
79801>>>>>>>>>>>>
79801>>>>>>>>>>>
79801>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79802>>>>>>>>>>>
79802>>>>>>>>>>>        Function_Return dCompileDate
79803>>>>>>>>>>>    End_Function
79804>>>>>>>>>>>
79804>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79804>>>>>>>>>>>    // (the passed program), has been finished
79804>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79804>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79806>>>>>>>>>>>        Handle hProcess
79806>>>>>>>>>>>        Integer iVoid
79806>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79806>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79806>>>>>>>>>>>
79806>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79807>>>>>>>>>>>
79807>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79808>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79809>>>>>>>>>>>
79809>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79810>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79811>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79811>>>>>>>>>>>        Move 0                       to sInfo.nShow
79812>>>>>>>>>>>
79812>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79813>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79814>>>>>>>>>>>        If (hProcess) Begin
79816>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79817>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79818>>>>>>>>>>>        End
79818>>>>>>>>>>>>
79818>>>>>>>>>>>    End_Procedure
79819>>>>>>>>>>>
79819>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79821>>>>>>>>>>>        String sDirSep
79821>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79822>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79823>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79825>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79826>>>>>>>>>>>        End
79826>>>>>>>>>>>>
79826>>>>>>>>>>>        Function_Return sPath
79827>>>>>>>>>>>    End_Function
79828>>>>>>>>>>>
79828>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79828>>>>>>>>>>>    // or there is a problem with the certificate.
79828>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79828>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79828>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79830>>>>>>>>>>>        Boolean bExists
79830>>>>>>>>>>>        String sPath sProgram sParams sRetval
79830>>>>>>>>>>>        Integer iCh
79830>>>>>>>>>>>
79830>>>>>>>>>>>        Move "" to sRetval
79831>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79832>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79833>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79834>>>>>>>>>>>        If (bExists = False) Begin
79836>>>>>>>>>>>            Function_Return "-1"
79837>>>>>>>>>>>        End
79837>>>>>>>>>>>>
79837>>>>>>>>>>>
79837>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79838>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79839>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79840>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79841>>>>>>>>>>>        Get Seq_New_Channel to iCh
79842>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79844>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79847>>>>>>>>>>>        Close_Output channel iCh
79849>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79849>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79850>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79852>>>>>>>>>>>            Readln channel iCh sRetval
79854>>>>>>>>>>>            Readln channel iCh sRetval
79856>>>>>>>>>>>            Readln channel iCh sRetval
79858>>>>>>>>>>>            Readln channel iCh sRetval
79860>>>>>>>>>>>        Close_Input channel iCh
79862>>>>>>>>>>>        Send Seq_Release_Channel iCh
79863>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79865>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79866>>>>>>>>>>>        End
79866>>>>>>>>>>>>
79866>>>>>>>>>>>        Else Begin
79867>>>>>>>>>>>            Move "" to sRetval
79868>>>>>>>>>>>        End
79868>>>>>>>>>>>>
79868>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79868>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79869>>>>>>>>>>>>
79869>>>>>>>>>>>        Function_Return sRetval
79870>>>>>>>>>>>    End_Function
79871>>>>>>>>>>>
79871>>>>>>>>>>>    Procedure Add_LineLn String sValue
79873>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79874>>>>>>>>>>>    End_Procedure
79875>>>>>>>>>>>
79875>>>>>>>>>>>    Procedure Add_Line String sValue
79877>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79878>>>>>>>>>>>    End_Procedure
79879>>>>>>>>>>>
79879>>>>>>>>>>>    Procedure Set Logo string sLogo
79881>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79881>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79882>>>>>>>>>>>    End_Procedure
79883>>>>>>>>>>>
79883>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79885>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79886>>>>>>>>>>>    End_Procedure
79887>>>>>>>>>>>
79887>>>>>>>>>>>    Procedure Show_Sysinfo
79889>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79890>>>>>>>>>>>    End_Procedure
79891>>>>>>>>>>>
79891>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79893>>>>>>>>>>>        Handle hWnd
79893>>>>>>>>>>>        Get Window_Handle to hWnd
79894>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79895>>>>>>>>>>>    End_Procedure
79896>>>>>>>>>>>
79896>>>>>>>>>>>End_Class
79897>>>>>>>>>
79897>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79899>>>>>>>>>    End_Function
79900>>>>>>>>>
79900>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79901>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79902>>>>>>>>>>
79902>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79904>>>>>>>>>>    Integer iStart iEnd
79904>>>>>>>>>>    String sRetval
79904>>>>>>>>>>
79904>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79905>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79906>>>>>>>>>>    If (iStart = 0) Begin
79908>>>>>>>>>>        Function_Return ""
79909>>>>>>>>>>    End
79909>>>>>>>>>>>
79909>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79910>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79911>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79913>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79914>>>>>>>>>>    End
79914>>>>>>>>>>>
79914>>>>>>>>>>    Else Begin
79915>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79916>>>>>>>>>>    End
79916>>>>>>>>>>>
79916>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79918>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79919>>>>>>>>>>        Decrement iEnd
79920>>>>>>>>>>    End
79920>>>>>>>>>>>
79920>>>>>>>>>>    If (iEnd <> 0) Begin
79922>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79923>>>>>>>>>>    End
79923>>>>>>>>>>>
79923>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79924>>>>>>>>>>
79924>>>>>>>>>>    Function_Return (Trim(sRetval))
79925>>>>>>>>>>End_Function
79926>>>>>>>>>>
79926>>>>>>>>>>
79926>>>>>>>>>    
79926>>>>>>>>>    Procedure Construct_Object
79928>>>>>>>>>        Handle ho
79928>>>>>>>>>        Forward Send Construct_Object
79930>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79931>>>>>>>>>        
79931>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79932>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79933>>>>>>>>>
79933>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79933>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79933>>>>>>>>>        // etc settings.
79933>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79935>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79936>>>>>>>>>            Set phoSQLConnectionHandler to ho
79937>>>>>>>>>        End
79937>>>>>>>>>>
79937>>>>>>>>>
79937>>>>>>>>>    End_Procedure
79938>>>>>>>>>
79938>>>>>>>>>    Procedure End_Construct_Object
79940>>>>>>>>>        Forward Send End_Construct_Object
79942>>>>>>>>>
79942>>>>>>>>>    End_Procedure
79943>>>>>>>>>
79943>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79943>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79943>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79943>>>>>>>>>    // Good read about which collation to select:
79943>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79943>>>>>>>>>    Procedure Set psCollation String sCollation
79945>>>>>>>>>        Set private.psCollation to sCollation
79946>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79948>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79949>>>>>>>>>        End
79949>>>>>>>>>>
79949>>>>>>>>>    End_Procedure
79950>>>>>>>>>
79950>>>>>>>>>    Function psCollation Returns String
79952>>>>>>>>>        String sCollation
79952>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79954>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79955>>>>>>>>>        End   
79955>>>>>>>>>>
79955>>>>>>>>>        Else Begin
79956>>>>>>>>>            Get private.psCollation to sCollation
79957>>>>>>>>>        End
79957>>>>>>>>>>
79957>>>>>>>>>        Function_Return sCollation
79958>>>>>>>>>    End_Function
79959>>>>>>>>>
79959>>>>>>>>>    // Array sorting helper functions:
79959>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
79961>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
79963>>>>>>>>>            Function_Return (EQ)
79964>>>>>>>>>        End
79964>>>>>>>>>>
79964>>>>>>>>>
79964>>>>>>>>>        Function_Return (GT)
79965>>>>>>>>>    End_Function
79966>>>>>>>>>
79966>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
79968>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
79971>>>>>>>>>
79971>>>>>>>>>        Function_Return (GT)
79972>>>>>>>>>    End_Function
79973>>>>>>>>>
79973>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
79973>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
79973>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
79975>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
79975>>>>>>>>>        Handle hTable
79975>>>>>>>>>        Boolean bIsSame
79975>>>>>>>>>
79975>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
79976>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
79977>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
79980>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
79981>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
79984>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
79987>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
79988>>>>>>>>>
79988>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
79990>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
79991>>>>>>>>>        End
79991>>>>>>>>>>
79991>>>>>>>>>        Else Begin
79992>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
79993>>>>>>>>>        End
79993>>>>>>>>>>
79993>>>>>>>>>
79993>>>>>>>>>        Function_Return bIsSame
79994>>>>>>>>>    End_Function
79995>>>>>>>>>
79995>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
79997>>>>>>>>>        Integer iRetval
79997>>>>>>>>>        Move 1 to iRetval
79998>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80000>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80001>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80002>>>>>>>>>        End
80002>>>>>>>>>>
80002>>>>>>>>>        Function_Return (iRetval = 0)
80003>>>>>>>>>    End_Function
80004>>>>>>>>>
80004>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80006>>>>>>>>>        String sDirSep
80006>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80007>>>>>>>>>        Move (Trim(sPath)) to sPath
80008>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80010>>>>>>>>>            Move (sPath + sDirSep) to sPath
80011>>>>>>>>>        End
80011>>>>>>>>>>
80011>>>>>>>>>        Function_Return sPath
80012>>>>>>>>>    End_Function
80013>>>>>>>>>
80013>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80015>>>>>>>>>        Integer i iCols iItem
80015>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80015>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80016>>>>>>>>>
80016>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80017>>>>>>>>>        For i from 1 to iCols
80023>>>>>>>>>>
80023>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80024>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80025>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80026>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80027>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80028>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80029>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80030>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80031>>>>>>>>>        Loop
80032>>>>>>>>>>
80032>>>>>>>>>        Set piColumns to iCols
80033>>>>>>>>>        Set paQueryColumns to aQueryColumns
80034>>>>>>>>>    End_Procedure
80035>>>>>>>>>
80035>>>>>>>>>    // *** Property Messages ***
80035>>>>>>>>>    //
80035>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80035>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80035>>>>>>>>>    //
80035>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80037>>>>>>>>>        tSQLConnection SQLConnection
80037>>>>>>>>>        tSQLConnection SQLConnection
80037>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80039>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80039>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80040>>>>>>>>>>
80040>>>>>>>>>            Function_Return
80041>>>>>>>>>        End
80041>>>>>>>>>>
80041>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80042>>>>>>>>>        Function_Return SQLConnection
80043>>>>>>>>>    End_Function
80044>>>>>>>>>
80044>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80044>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80046>>>>>>>>>        Function_Return False
80047>>>>>>>>>    End_Function
80048>>>>>>>>>
80048>>>>>>>>>    Procedure Set psServer String sValue
80050>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80052>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80052>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80053>>>>>>>>>>
80053>>>>>>>>>            Procedure_Return
80054>>>>>>>>>        End
80054>>>>>>>>>>
80054>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80055>>>>>>>>>    End_Procedure
80056>>>>>>>>>
80056>>>>>>>>>    Function psServer Returns String
80058>>>>>>>>>        String sValue
80058>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80060>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80061>>>>>>>>>>
80061>>>>>>>>>            Function_Return
80062>>>>>>>>>        End
80062>>>>>>>>>>
80062>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80063>>>>>>>>>        Function_Return sValue
80064>>>>>>>>>    End_Function
80065>>>>>>>>>
80065>>>>>>>>>    Procedure Set psDatabase String sValue
80067>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80069>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80070>>>>>>>>>>
80070>>>>>>>>>            Procedure_Return
80071>>>>>>>>>        End
80071>>>>>>>>>>
80071>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80072>>>>>>>>>    End_Procedure
80073>>>>>>>>>
80073>>>>>>>>>    Function psDatabase Returns String
80075>>>>>>>>>        String sValue
80075>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80077>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80078>>>>>>>>>>
80078>>>>>>>>>            Function_Return
80079>>>>>>>>>        End
80079>>>>>>>>>>
80079>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80080>>>>>>>>>        Function_Return sValue
80081>>>>>>>>>    End_Function
80082>>>>>>>>>
80082>>>>>>>>>    Procedure Set psUserID String sValue
80084>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80086>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80087>>>>>>>>>>
80087>>>>>>>>>            Procedure_Return
80088>>>>>>>>>        End
80088>>>>>>>>>>
80088>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80089>>>>>>>>>    End_Procedure
80090>>>>>>>>>
80090>>>>>>>>>    Function psUserID Returns String
80092>>>>>>>>>        String sValue
80092>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80094>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80095>>>>>>>>>>
80095>>>>>>>>>            Function_Return
80096>>>>>>>>>        End
80096>>>>>>>>>>
80096>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80097>>>>>>>>>        Function_Return sValue
80098>>>>>>>>>    End_Function
80099>>>>>>>>>
80099>>>>>>>>>    Procedure Set psPassword String sValue
80101>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80103>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80104>>>>>>>>>>
80104>>>>>>>>>            Procedure_Return
80105>>>>>>>>>        End
80105>>>>>>>>>>
80105>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80106>>>>>>>>>    End_Procedure
80107>>>>>>>>>
80107>>>>>>>>>    Function psPassword Returns String
80109>>>>>>>>>        String sValue
80109>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80111>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80112>>>>>>>>>>
80112>>>>>>>>>            Function_Return
80113>>>>>>>>>        End
80113>>>>>>>>>>
80113>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80114>>>>>>>>>        Function_Return sValue
80115>>>>>>>>>    End_Function
80116>>>>>>>>>
80116>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80118>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80120>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80121>>>>>>>>>>
80121>>>>>>>>>            Procedure_Return
80122>>>>>>>>>        End
80122>>>>>>>>>>
80122>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80123>>>>>>>>>    End_Procedure
80124>>>>>>>>>
80124>>>>>>>>>    Function pbTrusted Returns Boolean
80126>>>>>>>>>        Boolean bValue
80126>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80128>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80129>>>>>>>>>>
80129>>>>>>>>>            Function_Return
80130>>>>>>>>>        End
80130>>>>>>>>>>
80130>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80131>>>>>>>>>        Function_Return bValue
80132>>>>>>>>>    End_Function
80133>>>>>>>>>
80133>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80135>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80137>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80138>>>>>>>>>>
80138>>>>>>>>>            Procedure_Return
80139>>>>>>>>>        End
80139>>>>>>>>>>
80139>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80140>>>>>>>>>    End_Procedure
80141>>>>>>>>>
80141>>>>>>>>>    Function pbSilentLogin Returns Boolean
80143>>>>>>>>>        Boolean bValue
80143>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80145>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80146>>>>>>>>>>
80146>>>>>>>>>            Function_Return
80147>>>>>>>>>        End
80147>>>>>>>>>>
80147>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80148>>>>>>>>>        Function_Return bValue
80149>>>>>>>>>    End_Function
80150>>>>>>>>>
80150>>>>>>>>>    Procedure Set psConnectionID String sValue
80152>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80154>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80155>>>>>>>>>>
80155>>>>>>>>>            Procedure_Return
80156>>>>>>>>>        End
80156>>>>>>>>>>
80156>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80157>>>>>>>>>    End_Procedure
80158>>>>>>>>>
80158>>>>>>>>>    Function psConnectionID Returns String
80160>>>>>>>>>        String sValue
80160>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80162>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80163>>>>>>>>>>
80163>>>>>>>>>            Function_Return
80164>>>>>>>>>        End
80164>>>>>>>>>>
80164>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80165>>>>>>>>>        Function_Return sValue
80166>>>>>>>>>    End_Function
80167>>>>>>>>>
80167>>>>>>>>>    Procedure Set psConnectionString String sValue
80169>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80171>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80172>>>>>>>>>>
80172>>>>>>>>>            Procedure_Return
80173>>>>>>>>>        End
80173>>>>>>>>>>
80173>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80174>>>>>>>>>    End_Procedure
80175>>>>>>>>>
80175>>>>>>>>>    Function psConnectionString Returns String
80177>>>>>>>>>        String sValue
80177>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80179>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80180>>>>>>>>>>
80180>>>>>>>>>            Function_Return
80181>>>>>>>>>        End
80181>>>>>>>>>>
80181>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80182>>>>>>>>>        Function_Return sValue
80183>>>>>>>>>    End_Function
80184>>>>>>>>>
80184>>>>>>>>>    // The normal connection string looks something like this;
80184>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80184>>>>>>>>>    // ...and the full connection string looks like this;
80184>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80184>>>>>>>>>    Function psFullConnectionString Returns String
80186>>>>>>>>>        String sConnectionID sConnectionString
80186>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80188>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80189>>>>>>>>>>
80189>>>>>>>>>            Function_Return
80190>>>>>>>>>        End
80190>>>>>>>>>>
80190>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80191>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80192>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80193>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80194>>>>>>>>>    End_Function
80195>>>>>>>>>
80195>>>>>>>>>    Function piConnectionOptions Returns Integer
80197>>>>>>>>>        Integer iValue
80197>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80199>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80200>>>>>>>>>>
80200>>>>>>>>>            Function_Return
80201>>>>>>>>>        End
80201>>>>>>>>>>
80201>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80202>>>>>>>>>        Function_Return iValue
80203>>>>>>>>>    End_Function
80204>>>>>>>>>
80204>>>>>>>>>    Procedure Set psSchema String sValue
80206>>>>>>>>>        tSQLConnection SQLConnection
80206>>>>>>>>>        tSQLConnection SQLConnection
80206>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80208>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80209>>>>>>>>>>
80209>>>>>>>>>            Procedure_Return
80210>>>>>>>>>        End
80210>>>>>>>>>>
80210>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80211>>>>>>>>>    End_Procedure
80212>>>>>>>>>
80212>>>>>>>>>    Function psSchema Returns String
80214>>>>>>>>>        String sRetval
80214>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80216>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80217>>>>>>>>>>
80217>>>>>>>>>            Function_Return
80218>>>>>>>>>        End
80218>>>>>>>>>>
80218>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80219>>>>>>>>>        Function_Return sRetval
80220>>>>>>>>>    End_Function
80221>>>>>>>>>
80221>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80223>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80225>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80226>>>>>>>>>>
80226>>>>>>>>>            Procedure_Return
80227>>>>>>>>>        End
80227>>>>>>>>>>
80227>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80228>>>>>>>>>    End_Procedure
80229>>>>>>>>>
80229>>>>>>>>>    Function psBaseTableSpace Returns String
80231>>>>>>>>>        String sRetval
80231>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80233>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80234>>>>>>>>>>
80234>>>>>>>>>            Function_Return
80235>>>>>>>>>        End
80235>>>>>>>>>>
80235>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80236>>>>>>>>>        Function_Return sRetval
80237>>>>>>>>>    End_Function
80238>>>>>>>>>
80238>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80240>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80242>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80243>>>>>>>>>>
80243>>>>>>>>>            Procedure_Return
80244>>>>>>>>>        End
80244>>>>>>>>>>
80244>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80245>>>>>>>>>    End_Procedure
80246>>>>>>>>>
80246>>>>>>>>>    Function psLongTableSpace Returns String
80248>>>>>>>>>        String sRetval
80248>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80250>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80251>>>>>>>>>>
80251>>>>>>>>>            Function_Return
80252>>>>>>>>>        End
80252>>>>>>>>>>
80252>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80253>>>>>>>>>        Function_Return sRetval
80254>>>>>>>>>    End_Function
80255>>>>>>>>>
80255>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80257>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80259>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80260>>>>>>>>>>
80260>>>>>>>>>            Procedure_Return
80261>>>>>>>>>        End
80261>>>>>>>>>>
80261>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80262>>>>>>>>>    End_Procedure
80263>>>>>>>>>
80263>>>>>>>>>    Function psIndexTableSpace Returns String
80265>>>>>>>>>        String sRetval
80265>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80267>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80268>>>>>>>>>>
80268>>>>>>>>>            Function_Return
80269>>>>>>>>>        End
80269>>>>>>>>>>
80269>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80270>>>>>>>>>        Function_Return sRetval
80271>>>>>>>>>    End_Function
80272>>>>>>>>>
80272>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80274>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80276>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80277>>>>>>>>>>
80277>>>>>>>>>            Procedure_Return
80278>>>>>>>>>        End
80278>>>>>>>>>>
80278>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80279>>>>>>>>>    End_Procedure
80280>>>>>>>>>
80280>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80282>>>>>>>>>        Boolean bState
80282>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80284>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80285>>>>>>>>>>
80285>>>>>>>>>            Function_Return
80286>>>>>>>>>        End
80286>>>>>>>>>>
80286>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80287>>>>>>>>>        Function_Return bState
80288>>>>>>>>>    End_Function
80289>>>>>>>>>
80289>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80291>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80293>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80294>>>>>>>>>>
80294>>>>>>>>>            Procedure_Return
80295>>>>>>>>>        End
80295>>>>>>>>>>
80295>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80296>>>>>>>>>    End_Procedure
80297>>>>>>>>>
80297>>>>>>>>>    Function pbToANSI Returns Boolean
80299>>>>>>>>>        Boolean bState
80299>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80301>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80302>>>>>>>>>>
80302>>>>>>>>>            Function_Return
80303>>>>>>>>>        End
80303>>>>>>>>>>
80303>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80304>>>>>>>>>        Function_Return bState
80305>>>>>>>>>    End_Function
80306>>>>>>>>>
80306>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80308>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80310>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80311>>>>>>>>>>
80311>>>>>>>>>            Procedure_Return
80312>>>>>>>>>        End
80312>>>>>>>>>>
80312>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80313>>>>>>>>>    End_Procedure
80314>>>>>>>>>
80314>>>>>>>>>    Function pbRecnum Returns Boolean
80316>>>>>>>>>        Boolean bState
80316>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80318>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80319>>>>>>>>>>
80319>>>>>>>>>            Function_Return
80320>>>>>>>>>        End
80320>>>>>>>>>>
80320>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80321>>>>>>>>>        Function_Return bState
80322>>>>>>>>>    End_Function
80323>>>>>>>>>
80323>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80325>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80327>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80328>>>>>>>>>>
80328>>>>>>>>>            Procedure_Return
80329>>>>>>>>>        End
80329>>>>>>>>>>
80329>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80330>>>>>>>>>    End_Procedure
80331>>>>>>>>>
80331>>>>>>>>>    Function pbCopyData Returns Boolean
80333>>>>>>>>>        Boolean bState
80333>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80335>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80336>>>>>>>>>>
80336>>>>>>>>>            Function_Return
80337>>>>>>>>>        End
80337>>>>>>>>>>
80337>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80338>>>>>>>>>        Function_Return bState
80339>>>>>>>>>    End_Function
80340>>>>>>>>>
80340>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80342>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80344>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80345>>>>>>>>>>
80345>>>>>>>>>            Procedure_Return
80346>>>>>>>>>        End
80346>>>>>>>>>>
80346>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80347>>>>>>>>>    End_Procedure
80348>>>>>>>>>
80348>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80350>>>>>>>>>        Boolean bState
80350>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80352>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80353>>>>>>>>>>
80353>>>>>>>>>            Function_Return
80354>>>>>>>>>        End
80354>>>>>>>>>>
80354>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80355>>>>>>>>>        Function_Return bState
80356>>>>>>>>>    End_Function
80357>>>>>>>>>
80357>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80359>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80361>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80362>>>>>>>>>>
80362>>>>>>>>>            Procedure_Return
80363>>>>>>>>>        End
80363>>>>>>>>>>
80363>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80364>>>>>>>>>    End_Procedure
80365>>>>>>>>>
80365>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80367>>>>>>>>>        Boolean bState
80367>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80369>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80370>>>>>>>>>>
80370>>>>>>>>>            Function_Return
80371>>>>>>>>>        End
80371>>>>>>>>>>
80371>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80372>>>>>>>>>        Function_Return bState
80373>>>>>>>>>    End_Function
80374>>>>>>>>>
80374>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80376>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80378>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80379>>>>>>>>>>
80379>>>>>>>>>            Procedure_Return
80380>>>>>>>>>        End
80380>>>>>>>>>>
80380>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80381>>>>>>>>>    End_Procedure
80382>>>>>>>>>
80382>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80384>>>>>>>>>        Boolean bState
80384>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80386>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80387>>>>>>>>>>
80387>>>>>>>>>            Function_Return
80388>>>>>>>>>        End
80388>>>>>>>>>>
80388>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80389>>>>>>>>>        Function_Return bState
80390>>>>>>>>>    End_Function
80391>>>>>>>>>
80391>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80393>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80395>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80396>>>>>>>>>>
80396>>>>>>>>>            Procedure_Return
80397>>>>>>>>>        End
80397>>>>>>>>>>
80397>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80398>>>>>>>>>    End_Procedure
80399>>>>>>>>>
80399>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80401>>>>>>>>>        Boolean bState
80401>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80403>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80404>>>>>>>>>>
80404>>>>>>>>>            Function_Return
80405>>>>>>>>>        End
80405>>>>>>>>>>
80405>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80406>>>>>>>>>        Function_Return bState
80407>>>>>>>>>    End_Function
80408>>>>>>>>>
80408>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80410>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80412>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80413>>>>>>>>>>
80413>>>>>>>>>            Procedure_Return
80414>>>>>>>>>        End
80414>>>>>>>>>>
80414>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80415>>>>>>>>>    End_Procedure
80416>>>>>>>>>
80416>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80418>>>>>>>>>        String sRetval
80418>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80420>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80421>>>>>>>>>>
80421>>>>>>>>>            Function_Return
80422>>>>>>>>>        End
80422>>>>>>>>>>
80422>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80423>>>>>>>>>        Function_Return sRetval
80424>>>>>>>>>    End_Function
80425>>>>>>>>>
80425>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80427>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80429>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80430>>>>>>>>>>
80430>>>>>>>>>            Procedure_Return
80431>>>>>>>>>        End
80431>>>>>>>>>>
80431>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80432>>>>>>>>>    End_Procedure
80433>>>>>>>>>
80433>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80435>>>>>>>>>        String sRetval
80435>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80437>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80438>>>>>>>>>>
80438>>>>>>>>>            Function_Return
80439>>>>>>>>>        End
80439>>>>>>>>>>
80439>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80440>>>>>>>>>        Function_Return sRetval
80441>>>>>>>>>    End_Function
80442>>>>>>>>>
80442>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80444>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80446>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80447>>>>>>>>>>
80447>>>>>>>>>            Procedure_Return
80448>>>>>>>>>        End
80448>>>>>>>>>>
80448>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80449>>>>>>>>>    End_Procedure
80450>>>>>>>>>
80450>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80452>>>>>>>>>        String sRetval
80452>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80454>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80455>>>>>>>>>>
80455>>>>>>>>>            Function_Return
80456>>>>>>>>>        End
80456>>>>>>>>>>
80456>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80457>>>>>>>>>        Function_Return sRetval
80458>>>>>>>>>    End_Function
80459>>>>>>>>>
80459>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80461>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80463>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80464>>>>>>>>>>
80464>>>>>>>>>            Procedure_Return
80465>>>>>>>>>        End
80465>>>>>>>>>>
80465>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80466>>>>>>>>>    End_Procedure
80467>>>>>>>>>
80467>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80469>>>>>>>>>        String sRetval
80469>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80471>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80472>>>>>>>>>>
80472>>>>>>>>>            Function_Return
80473>>>>>>>>>        End
80473>>>>>>>>>>
80473>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80474>>>>>>>>>        Function_Return sRetval
80475>>>>>>>>>    End_Function
80476>>>>>>>>>
80476>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80478>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80480>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80481>>>>>>>>>>
80481>>>>>>>>>            Procedure_Return
80482>>>>>>>>>        End
80482>>>>>>>>>>
80482>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80483>>>>>>>>>    End_Procedure
80484>>>>>>>>>
80484>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80486>>>>>>>>>        String sRetval
80486>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80488>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80489>>>>>>>>>>
80489>>>>>>>>>            Function_Return
80490>>>>>>>>>        End
80490>>>>>>>>>>
80490>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80491>>>>>>>>>        Function_Return sRetval
80492>>>>>>>>>    End_Function
80493>>>>>>>>>
80493>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80495>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80497>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80498>>>>>>>>>>
80498>>>>>>>>>            Procedure_Return
80499>>>>>>>>>        End
80499>>>>>>>>>>
80499>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80500>>>>>>>>>    End_Procedure
80501>>>>>>>>>
80501>>>>>>>>>    Function psDriverDefaultValueText Returns String
80503>>>>>>>>>        String sRetval
80503>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80505>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80506>>>>>>>>>>
80506>>>>>>>>>            Function_Return
80507>>>>>>>>>        End
80507>>>>>>>>>>
80507>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80508>>>>>>>>>        Function_Return sRetval
80509>>>>>>>>>    End_Function
80510>>>>>>>>>
80510>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80512>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80514>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80515>>>>>>>>>>
80515>>>>>>>>>            Procedure_Return
80516>>>>>>>>>        End
80516>>>>>>>>>>
80516>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80517>>>>>>>>>    End_Procedure
80518>>>>>>>>>
80518>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80520>>>>>>>>>        Boolean bState
80520>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80522>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80523>>>>>>>>>>
80523>>>>>>>>>            Function_Return
80524>>>>>>>>>        End
80524>>>>>>>>>>
80524>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80525>>>>>>>>>        Function_Return bState
80526>>>>>>>>>    End_Function
80527>>>>>>>>>
80527>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80529>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80531>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80532>>>>>>>>>>
80532>>>>>>>>>            Procedure_Return
80533>>>>>>>>>        End
80533>>>>>>>>>>
80533>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80534>>>>>>>>>    End_Procedure
80535>>>>>>>>>
80535>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80537>>>>>>>>>        Boolean bState
80537>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80539>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80540>>>>>>>>>>
80540>>>>>>>>>            Function_Return
80541>>>>>>>>>        End
80541>>>>>>>>>>
80541>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80542>>>>>>>>>        Function_Return bState
80543>>>>>>>>>    End_Function
80544>>>>>>>>>
80544>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80546>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80548>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80549>>>>>>>>>>
80549>>>>>>>>>            Procedure_Return
80550>>>>>>>>>        End
80550>>>>>>>>>>
80550>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80551>>>>>>>>>    End_Procedure
80552>>>>>>>>>
80552>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80554>>>>>>>>>        Boolean bState
80554>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80556>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80557>>>>>>>>>>
80557>>>>>>>>>            Function_Return
80558>>>>>>>>>        End
80558>>>>>>>>>>
80558>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80559>>>>>>>>>        Function_Return bState
80560>>>>>>>>>    End_Function
80561>>>>>>>>>
80561>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80563>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80565>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80566>>>>>>>>>>
80566>>>>>>>>>            Procedure_Return
80567>>>>>>>>>        End
80567>>>>>>>>>>
80567>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80568>>>>>>>>>    End_Procedure
80569>>>>>>>>>
80569>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80571>>>>>>>>>        Boolean bState
80571>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80573>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80574>>>>>>>>>>
80574>>>>>>>>>            Function_Return
80575>>>>>>>>>        End
80575>>>>>>>>>>
80575>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80576>>>>>>>>>        Function_Return bState
80577>>>>>>>>>    End_Function
80578>>>>>>>>>
80578>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80580>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80582>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80583>>>>>>>>>>
80583>>>>>>>>>            Procedure_Return
80584>>>>>>>>>        End
80584>>>>>>>>>>
80584>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80585>>>>>>>>>    End_Procedure
80586>>>>>>>>>
80586>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80588>>>>>>>>>        Boolean bState
80588>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80590>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80591>>>>>>>>>>
80591>>>>>>>>>            Function_Return
80592>>>>>>>>>        End
80592>>>>>>>>>>
80592>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80593>>>>>>>>>        Function_Return bState
80594>>>>>>>>>    End_Function
80595>>>>>>>>>
80595>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80597>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80599>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80600>>>>>>>>>>
80600>>>>>>>>>            Procedure_Return
80601>>>>>>>>>        End
80601>>>>>>>>>>
80601>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80602>>>>>>>>>    End_Procedure
80603>>>>>>>>>
80603>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80605>>>>>>>>>        Boolean bState
80605>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80607>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80608>>>>>>>>>>
80608>>>>>>>>>            Function_Return
80609>>>>>>>>>        End
80609>>>>>>>>>>
80609>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80610>>>>>>>>>        Function_Return bState
80611>>>>>>>>>    End_Function
80612>>>>>>>>>
80612>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80612>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80612>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80612>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80612>>>>>>>>>    Procedure Set psDriverID String sValue
80614>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80615>>>>>>>>>        Delegate Set psDriverID to sValue
80617>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80618>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80619>>>>>>>>>    End_Procedure
80620>>>>>>>>>
80620>>>>>>>>>    Function psDriverID Returns String
80622>>>>>>>>>        String sDriverID
80622>>>>>>>>>
80622>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80623>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80623>>>>>>>>>        Delegate Get psDriverID to sDriverID
80625>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80626>>>>>>>>>        Move False to Err
80627>>>>>>>>>
80627>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80627>>>>>>>>>        // probably used as "utilites" from a special made program and
80627>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80627>>>>>>>>>        If (sDriverID = "") Begin
80629>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80630>>>>>>>>>        End
80630>>>>>>>>>>
80630>>>>>>>>>        Function_Return sDriverID
80631>>>>>>>>>    End_Function
80632>>>>>>>>>
80632>>>>>>>>>    Procedure Set piDbType Integer iValue
80634>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80635>>>>>>>>>        Delegate Set piDbType to iValue
80637>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80638>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80639>>>>>>>>>    End_Procedure
80640>>>>>>>>>
80640>>>>>>>>>    Function piDbType Returns Integer
80642>>>>>>>>>        Integer iRetval
80642>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80643>>>>>>>>>        Function_Return iRetval
80644>>>>>>>>>    End_Function
80645>>>>>>>>>
80645>>>>>>>>>    // Returns the index for the passed sTableName
80645>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80645>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80647>>>>>>>>>        Integer iIndex iSize iCount
80647>>>>>>>>>        String[] sTablesArray
80648>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80648>>>>>>>>>
80648>>>>>>>>>        Move -1 to iIndex
80649>>>>>>>>>        Get psConnectionString to sConnectionString
80650>>>>>>>>>        Get psDatabase to sDatabase
80651>>>>>>>>>        Get psSchema   to sSchema
80652>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80653>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80654>>>>>>>>>        Decrement iSize
80655>>>>>>>>>        For iCount from 0 to iSize
80661>>>>>>>>>>
80661>>>>>>>>>            Move sTablesArray[iCount] to sVal
80662>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80664>>>>>>>>>                Move iCount to iIndex // We found it!
80665>>>>>>>>>                Move iSize to iCount  // End the loop
80666>>>>>>>>>            End
80666>>>>>>>>>>
80666>>>>>>>>>        Loop
80667>>>>>>>>>>
80667>>>>>>>>>
80667>>>>>>>>>        Function_Return iIndex
80668>>>>>>>>>    End_Function
80669>>>>>>>>>
80669>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80669>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80671>>>>>>>>>        String[] sReturnArray
80672>>>>>>>>>        Boolean bOK
80672>>>>>>>>>
80672>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80673>>>>>>>>>        If (bOK = False) Begin
80675>>>>>>>>>            Function_Return sReturnArray
80676>>>>>>>>>        End
80676>>>>>>>>>>
80676>>>>>>>>>
80676>>>>>>>>>        Case Begin
80676>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80678>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80679>>>>>>>>>                Case Break
80680>>>>>>>>>
80680>>>>>>>>>            Case Else
80680>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80681>>>>>>>>>>
80681>>>>>>>>>                Case Break
80682>>>>>>>>>        Case End
80682>>>>>>>>>
80682>>>>>>>>>        Function_Return sReturnArray
80683>>>>>>>>>    End_Function
80684>>>>>>>>>
80684>>>>>>>>>    // Returns a string array with all tables for the current database.
80684>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80686>>>>>>>>>        String[] sReturnArray sArray
80688>>>>>>>>>        String sConnectionString sSelect
80688>>>>>>>>>        Integer iSize iCount iDbType
80688>>>>>>>>>        Boolean bOK
80688>>>>>>>>>
80688>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80690>>>>>>>>>            Function_Return sArray
80691>>>>>>>>>        End
80691>>>>>>>>>>
80691>>>>>>>>>
80691>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80692>>>>>>>>>        If (bOK = False) Begin
80694>>>>>>>>>            Function_Return sReturnArray
80695>>>>>>>>>        End
80695>>>>>>>>>>
80695>>>>>>>>>        If (sSchema = "") Begin
80697>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80698>>>>>>>>>        End
80698>>>>>>>>>>
80698>>>>>>>>>
80698>>>>>>>>>        Get psConnectionString to sConnectionString
80699>>>>>>>>>
80699>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80699>>>>>>>>>        // the dbType.
80699>>>>>>>>>        Get piDbType to iDbType
80700>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80702>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80704>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80705>>>>>>>>>            End
80705>>>>>>>>>>
80705>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80707>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80708>>>>>>>>>            End
80708>>>>>>>>>>
80708>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80710>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80711>>>>>>>>>            End
80711>>>>>>>>>>
80711>>>>>>>>>        End
80711>>>>>>>>>>
80711>>>>>>>>>
80711>>>>>>>>>        Case Begin
80711>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80713>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80714>>>>>>>>>                Case Break
80715>>>>>>>>>
80715>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80718>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80719>>>>>>>>>                Case Break
80720>>>>>>>>>
80720>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80723>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80724>>>>>>>>>                Case Break
80725>>>>>>>>>
80725>>>>>>>>>            Case Else
80725>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80726>>>>>>>>>>
80726>>>>>>>>>                Case Break
80727>>>>>>>>>        Case End
80727>>>>>>>>>
80727>>>>>>>>>        Function_Return sReturnArray
80728>>>>>>>>>    End_Function
80729>>>>>>>>>
80729>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80729>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80731>>>>>>>>>        String[] sReturnArray
80732>>>>>>>>>        Boolean bOK
80732>>>>>>>>>
80732>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80733>>>>>>>>>        If (bOK = False) Begin
80735>>>>>>>>>            Function_Return sReturnArray
80736>>>>>>>>>        End
80736>>>>>>>>>>
80736>>>>>>>>>
80736>>>>>>>>>        Case Begin
80736>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80738>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80739>>>>>>>>>                Case Break
80740>>>>>>>>>
80740>>>>>>>>>            Case Else
80740>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80741>>>>>>>>>>
80741>>>>>>>>>                Case Break
80742>>>>>>>>>        Case End
80742>>>>>>>>>
80742>>>>>>>>>        Function_Return sReturnArray
80743>>>>>>>>>    End_Function
80744>>>>>>>>>
80744>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80744>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80746>>>>>>>>>        String[] sReturnArray
80747>>>>>>>>>        String sConnectionString sSelect sSchema
80747>>>>>>>>>        Boolean bOK
80747>>>>>>>>>        Integer iDbType
80747>>>>>>>>>
80747>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80748>>>>>>>>>        If (bOK = False) Begin
80750>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80751>>>>>>>>>>
80751>>>>>>>>>            Function_Return sReturnArray
80752>>>>>>>>>        End
80752>>>>>>>>>>
80752>>>>>>>>>
80752>>>>>>>>>        Get psConnectionString to sConnectionString
80753>>>>>>>>>        Get psSchema to sSchema
80754>>>>>>>>>
80754>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80754>>>>>>>>>        // the dbType.
80754>>>>>>>>>        Get piDbType to iDbType
80755>>>>>>>>>
80755>>>>>>>>>        Case Begin
80755>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80757>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80759>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80760>>>>>>>>>                End
80760>>>>>>>>>>
80760>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80762>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80763>>>>>>>>>                End
80763>>>>>>>>>>
80763>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80765>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80766>>>>>>>>>                End
80766>>>>>>>>>>
80766>>>>>>>>>
80766>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80767>>>>>>>>>                Case Break
80768>>>>>>>>>
80768>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80771>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80772>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80773>>>>>>>>>                Case Break
80774>>>>>>>>>
80774>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80777>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80778>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80779>>>>>>>>>                Case Break
80780>>>>>>>>>
80780>>>>>>>>>            Case Else
80780>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80781>>>>>>>>>>
80781>>>>>>>>>                Case Break
80782>>>>>>>>>        Case End
80782>>>>>>>>>
80782>>>>>>>>>        Function_Return sReturnArray
80783>>>>>>>>>    End_Function
80784>>>>>>>>>
80784>>>>>>>>>
80784>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80784>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80786>>>>>>>>>        String[] sReturnArray sReturnArray2
80788>>>>>>>>>        String sConnectionString sSelect sSchema
80788>>>>>>>>>        Boolean bOK
80788>>>>>>>>>        Integer iCount iSize
80788>>>>>>>>>
80788>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80789>>>>>>>>>        If (bOK = False) Begin
80791>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80792>>>>>>>>>>
80792>>>>>>>>>            Function_Return sReturnArray
80793>>>>>>>>>        End
80793>>>>>>>>>>
80793>>>>>>>>>
80793>>>>>>>>>        Get psConnectionString to sConnectionString
80794>>>>>>>>>        Get psSchema to sSchema
80795>>>>>>>>>
80795>>>>>>>>>        Case Begin
80795>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80797>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80798>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80799>>>>>>>>>                Case Break
80800>>>>>>>>>
80800>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80803>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80804>>>>>>>>>>
80804>>>>>>>>>//                Move () to sSelect
80804>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80804>>>>>>>>>                Case Break
80805>>>>>>>>>
80805>>>>>>>>>            Case Else
80805>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80806>>>>>>>>>>
80806>>>>>>>>>                Case Break
80807>>>>>>>>>        Case End
80807>>>>>>>>>
80807>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80808>>>>>>>>>        Decrement iSize
80809>>>>>>>>>        For iCount from 0 to iSize
80815>>>>>>>>>>
80815>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80817>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80818>>>>>>>>>            End
80818>>>>>>>>>>
80818>>>>>>>>>        Loop
80819>>>>>>>>>>
80819>>>>>>>>>
80819>>>>>>>>>        Function_Return sReturnArray2
80820>>>>>>>>>    End_Function
80821>>>>>>>>>
80821>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80821>>>>>>>>>    // The format of the array is "TableName.FieldName"
80821>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80823>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80825>>>>>>>>>        tSQLRelation[] sRelationsArray
80825>>>>>>>>>        tSQLRelation[] sRelationsArray
80826>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80826>>>>>>>>>        Boolean bOK
80826>>>>>>>>>        Integer iCount iSize iLength
80826>>>>>>>>>
80826>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80827>>>>>>>>>        If (bOK = False) Begin
80829>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80830>>>>>>>>>>
80830>>>>>>>>>            Function_Return sRelationsArray
80831>>>>>>>>>        End
80831>>>>>>>>>>
80831>>>>>>>>>
80831>>>>>>>>>        Get psConnectionString to sConnectionString
80832>>>>>>>>>        Get psSchema to sSchema
80833>>>>>>>>>
80833>>>>>>>>>        Case Begin
80833>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80835>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80836>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80837>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80838>>>>>>>>>                Case Break
80839>>>>>>>>>
80839>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80842>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80843>>>>>>>>>>
80843>>>>>>>>>//                Move () to sSelect
80843>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80843>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80843>>>>>>>>>                Case Break
80844>>>>>>>>>
80844>>>>>>>>>            Case Else
80844>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80845>>>>>>>>>>
80845>>>>>>>>>                Case Break
80846>>>>>>>>>        Case End
80846>>>>>>>>>
80846>>>>>>>>>        Move (Length(sTableName)) to iLength
80847>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80848>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80849>>>>>>>>>        Decrement iSize
80850>>>>>>>>>        For iCount from 0 to iSize
80856>>>>>>>>>>
80856>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80858>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80859>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80860>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80861>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80862>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80863>>>>>>>>>            End
80863>>>>>>>>>>
80863>>>>>>>>>        Loop
80864>>>>>>>>>>
80864>>>>>>>>>
80864>>>>>>>>>        Function_Return sRelationsArray
80865>>>>>>>>>    End_Function
80866>>>>>>>>>
80866>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80868>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80868>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80869>>>>>>>>>        String[] sUsers sPrograms
80871>>>>>>>>>        String sSelect
80871>>>>>>>>>        Integer iSize iCount
80871>>>>>>>>>
80871>>>>>>>>>        Case Begin
80871>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80873>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80874>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80875>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80876>>>>>>>>>                Case Break
80877>>>>>>>>>            Case Else
80877>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80878>>>>>>>>>>
80878>>>>>>>>>        Case End
80878>>>>>>>>>
80878>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80879>>>>>>>>>        Decrement iSize
80880>>>>>>>>>        For iCount from 0 to iSize
80886>>>>>>>>>>
80886>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80887>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80888>>>>>>>>>        Loop
80889>>>>>>>>>>
80889>>>>>>>>>
80889>>>>>>>>>        Function_Return SQLLoggedInUser
80890>>>>>>>>>    End_Function
80891>>>>>>>>>
80891>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80891>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80891>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80893>>>>>>>>>        String[] sFilesData
80894>>>>>>>>>        Boolean bExists
80894>>>>>>>>>        Integer iCh
80894>>>>>>>>>        String sFileName sExt
80894>>>>>>>>>
80894>>>>>>>>>        Get vFolderExists sDataPath to bExists
80895>>>>>>>>>        If (bExists = True) Begin
80897>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80898>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80899>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80900>>>>>>>>>            Direct_Input channel iCh sDataPath
80902>>>>>>>>>                Repeat
80902>>>>>>>>>>
80902>>>>>>>>>                    Readln channel iCh sFileName
80904>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80905>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80907>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80909>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80910>>>>>>>>>                        End
80910>>>>>>>>>>
80910>>>>>>>>>                    End
80910>>>>>>>>>>
80910>>>>>>>>>                Until (SeqEof = True)
80912>>>>>>>>>            Close_Input channel iCh
80914>>>>>>>>>            Send Seq_Release_Channel iCh
80915>>>>>>>>>        End
80915>>>>>>>>>>
80915>>>>>>>>>        Function_Return sFilesData
80916>>>>>>>>>    End_Function
80917>>>>>>>>>
80917>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80917>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80919>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80919>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80919>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80919>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80919>>>>>>>>>        tSQLConnection SQLConnection
80919>>>>>>>>>        tSQLConnection SQLConnection
80919>>>>>>>>>        String[] asCollations
80920>>>>>>>>>        
80920>>>>>>>>>        If (sDriverID = "") Begin
80922>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80923>>>>>>>>>>
80923>>>>>>>>>            Function_Return asCollations
80924>>>>>>>>>        End
80924>>>>>>>>>>
80924>>>>>>>>>
80924>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80924>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80926>>>>>>>>>            Function_Return asCollations
80927>>>>>>>>>        End                 
80927>>>>>>>>>>
80927>>>>>>>>>
80927>>>>>>>>>        Get phoSQLManager to hoSQLManager
80928>>>>>>>>>        Get psConnectionID     to sConnectionID
80929>>>>>>>>>        Get psConnectionString to sConnectionString
80930>>>>>>>>>        Move 0 to LastErr
80931>>>>>>>>>
80931>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80932>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80933>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80934>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80936>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80937>>>>>>>>>>
80937>>>>>>>>>            Function_Return asCollations
80938>>>>>>>>>        End
80938>>>>>>>>>>
80938>>>>>>>>>
80938>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80939>>>>>>>>>
80939>>>>>>>>>        If (hStmt = 0) Begin
80941>>>>>>>>>            Send SqlDisconnect of hoSQLManager
80942>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80943>>>>>>>>>>
80943>>>>>>>>>            Function_Return asCollations
80944>>>>>>>>>        End
80944>>>>>>>>>>
80944>>>>>>>>>
80944>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80945>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80946>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80947>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80948>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80949>>>>>>>>>
80949>>>>>>>>>        // MS-SQL Syntax:  
80949>>>>>>>>>        // SELECT name, description
80949>>>>>>>>>        //   from sys.fn_helpcollations();
80949>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80950>>>>>>>>>
80950>>>>>>>>>        Move 1 to iColumn
80951>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
80952>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80953>>>>>>>>>        Repeat
80953>>>>>>>>>>
80953>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
80954>>>>>>>>>            If (iFetchResult <> 0) Begin
80956>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80957>>>>>>>>>                If (sValue <> sPrevious) Begin         
80959>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
80959>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
80959>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80960>>>>>>>>>                    If (iPos <> 1) Begin
80962>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
80963>>>>>>>>>                    End
80963>>>>>>>>>>
80963>>>>>>>>>                End
80963>>>>>>>>>>
80963>>>>>>>>>                Move sValue to sPrevious
80964>>>>>>>>>            End
80964>>>>>>>>>>
80964>>>>>>>>>        Until (iFetchResult = 0)
80966>>>>>>>>>        Send SQLClose of hStmt
80967>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
80968>>>>>>>>>
80968>>>>>>>>>        Function_Return asCollations
80969>>>>>>>>>    End_Function
80970>>>>>>>>>
80970>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
80970>>>>>>>>>    // for DAW drivers.
80970>>>>>>>>>    // Returns: A string array.
80970>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
80972>>>>>>>>>        String[] sReturnArray
80973>>>>>>>>>        String sValue sPrevious
80973>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
80973>>>>>>>>>        Integer iFetchResult iRows
80973>>>>>>>>>        tSQLConnection SQLConnection
80973>>>>>>>>>        tSQLConnection SQLConnection
80973>>>>>>>>>
80973>>>>>>>>>        Get phoSQLManager to hoSQLHandler
80974>>>>>>>>>
80974>>>>>>>>>        If (hoSQLHandler <> 0) Begin
80976>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80977>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
80978>>>>>>>>>
80978>>>>>>>>>            If (hoSQLConnect <> 0) Begin
80980>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
80981>>>>>>>>>                If (hstmt <> 0) Begin
80983>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
80984>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
80985>>>>>>>>>                    Repeat
80985>>>>>>>>>>
80985>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
80986>>>>>>>>>                        If (iFetchResult <> 0) Begin
80988>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
80989>>>>>>>>>                            If (sValue <> sPrevious) Begin
80991>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
80992>>>>>>>>>                            End
80992>>>>>>>>>>
80992>>>>>>>>>                            Move sValue to sPrevious
80993>>>>>>>>>                        End
80993>>>>>>>>>>
80993>>>>>>>>>                    Until (iFetchResult = 0)
80995>>>>>>>>>                    Send SQLClose of hstmt
80996>>>>>>>>>                End
80996>>>>>>>>>>
80996>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
80997>>>>>>>>>            End
80997>>>>>>>>>>
80997>>>>>>>>>        End
80997>>>>>>>>>>
80997>>>>>>>>>
80997>>>>>>>>>        Function_Return sReturnArray
80998>>>>>>>>>    End_Function
80999>>>>>>>>>
80999>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81001>>>>>>>>>        String[] sReturnArray
81002>>>>>>>>>        String sDataSource
81002>>>>>>>>>        Handle hoSQLHandler
81002>>>>>>>>>        Integer iItem
81002>>>>>>>>>
81002>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81003>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81004>>>>>>>>>
81004>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81005>>>>>>>>>
81005>>>>>>>>>        Repeat
81005>>>>>>>>>>
81005>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81006>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81007>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81008>>>>>>>>>            Increment iItem
81009>>>>>>>>>        Until (sDataSource = "")
81011>>>>>>>>>
81011>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81012>>>>>>>>>
81012>>>>>>>>>        Function_Return sReturnArray
81013>>>>>>>>>    End_Function
81014>>>>>>>>>
81014>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81016>>>>>>>>>        String[] sReturnArray
81017>>>>>>>>>        String sDataSource
81017>>>>>>>>>        Handle hoSQLHandler
81017>>>>>>>>>        Integer iItem
81017>>>>>>>>>
81017>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81018>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81019>>>>>>>>>
81019>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81020>>>>>>>>>
81020>>>>>>>>>        Repeat
81020>>>>>>>>>>
81020>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81021>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81023>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81024>>>>>>>>>                Increment iItem
81025>>>>>>>>>            End
81025>>>>>>>>>>
81025>>>>>>>>>        Until (sDataSource = "")
81027>>>>>>>>>
81027>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81028>>>>>>>>>
81028>>>>>>>>>        Function_Return sReturnArray
81029>>>>>>>>>    End_Function
81030>>>>>>>>>
81030>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81032>>>>>>>>>        String[] sDataSources
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81033>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81034>>>>>>>>>        Integer iDataSources iCount iItem
81034>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81034>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81034>>>>>>>>>        Boolean bExists bKeyOpened
81034>>>>>>>>>
81034>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81035>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81036>>>>>>>>>        Move SQLConnection.sServer           to sServer
81037>>>>>>>>>
81037>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81037>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81039>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81040>>>>>>>>>            Set psFileName of hoIniFile to sServer
81041>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81042>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81043>>>>>>>>>            Send Destroy of hoIniFile
81044>>>>>>>>>        End
81044>>>>>>>>>>
81044>>>>>>>>>
81044>>>>>>>>>        // DSN - read DATABASE name from the registry
81044>>>>>>>>>        Else Begin
81045>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81046>>>>>>>>>
81046>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81046>>>>>>>>>            // most probably place the info is kept that we're after.
81046>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81047>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81048>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81049>>>>>>>>>            If (bExists = True) Begin
81051>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81052>>>>>>>>>            End
81052>>>>>>>>>>
81052>>>>>>>>>            Else Begin
81053>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81054>>>>>>>>>            End
81054>>>>>>>>>>
81054>>>>>>>>>
81054>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81055>>>>>>>>>            If (bExists) Begin
81057>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81058>>>>>>>>>                If (bKeyOpened) Begin
81060>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81061>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81062>>>>>>>>>                    If (iDataSources > 0) Begin
81064>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81065>>>>>>>>>                        Decrement iDataSources
81066>>>>>>>>>                        for iCount from 0 to iDataSources
81072>>>>>>>>>>
81072>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81073>>>>>>>>>                        Loop
81074>>>>>>>>>>
81074>>>>>>>>>                        Move 0 to iItem
81075>>>>>>>>>                        for iCount from 0 to iDataSources
81081>>>>>>>>>>
81081>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81082>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81083>>>>>>>>>                            If (bKeyOpened = True) Begin
81085>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81086>>>>>>>>>                                If (bExists = True) Begin
81088>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81089>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81090>>>>>>>>>                                    Increment iItem
81091>>>>>>>>>                                End
81091>>>>>>>>>>
81091>>>>>>>>>                            End
81091>>>>>>>>>>
81091>>>>>>>>>                        Loop
81092>>>>>>>>>>
81092>>>>>>>>>                    End
81092>>>>>>>>>>
81092>>>>>>>>>                    Send CloseKey of hoRegistry
81093>>>>>>>>>                    Send Destroy of hoODBCDataSources
81094>>>>>>>>>                End
81094>>>>>>>>>>
81094>>>>>>>>>            End
81094>>>>>>>>>>
81094>>>>>>>>>
81094>>>>>>>>>            // We then check the "User DNS" area in the registry.
81094>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81095>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81096>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81097>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81098>>>>>>>>>
81098>>>>>>>>>            If (bExists) Begin
81100>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81101>>>>>>>>>                If (bKeyOpened) Begin
81103>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81104>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81105>>>>>>>>>                    If (iDataSources > 0) Begin
81107>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81108>>>>>>>>>                        Decrement iDataSources
81109>>>>>>>>>                        for iCount from 0 to iDataSources
81115>>>>>>>>>>
81115>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81116>>>>>>>>>                        Loop
81117>>>>>>>>>>
81117>>>>>>>>>                        for iCount from 0 to iDataSources
81123>>>>>>>>>>
81123>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81124>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81125>>>>>>>>>                            If (bKeyOpened = True) Begin
81127>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81128>>>>>>>>>                                If (bExists = True) Begin
81130>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81131>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81132>>>>>>>>>                                    Increment iItem
81133>>>>>>>>>                                End
81133>>>>>>>>>>
81133>>>>>>>>>                            End
81133>>>>>>>>>>
81133>>>>>>>>>                        Loop
81134>>>>>>>>>>
81134>>>>>>>>>                    End
81134>>>>>>>>>>
81134>>>>>>>>>                    Send CloseKey of hoRegistry
81135>>>>>>>>>                    Send Destroy of hoODBCDataSources
81136>>>>>>>>>                End
81136>>>>>>>>>>
81136>>>>>>>>>            End
81136>>>>>>>>>>
81136>>>>>>>>>
81136>>>>>>>>>            Send Destroy of hoRegistry
81137>>>>>>>>>        End
81137>>>>>>>>>>
81137>>>>>>>>>
81137>>>>>>>>>        Function_Return sReturnArray
81138>>>>>>>>>    End_Function
81139>>>>>>>>>
81139>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81139>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81139>>>>>>>>>    // insert it for scriplets to come after the first one.
81139>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81141>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81141>>>>>>>>>        Integer iStart iEnd iDbType
81141>>>>>>>>>        Boolean bOK
81141>>>>>>>>>
81141>>>>>>>>>        Get piDbType to iDbType
81142>>>>>>>>>        Get psDriverID to sDriverID
81143>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81144>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81145>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81146>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81147>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81148>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81150>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81151>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81152>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81153>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81154>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81155>>>>>>>>>        End
81155>>>>>>>>>>
81155>>>>>>>>>        Else Begin
81156>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81157>>>>>>>>>
81157>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81157>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81159>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81160>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81161>>>>>>>>>            End
81161>>>>>>>>>>
81161>>>>>>>>>
81161>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81161>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81161>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81161>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81164>>>>>>>>>                // Make sure we only have one space between statements/words.
81164>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81165>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81166>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81167>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81168>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81169>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81171>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81172>>>>>>>>>                End
81172>>>>>>>>>>
81172>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81173>>>>>>>>>                // Remove data view as it already exists!
81173>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81174>>>>>>>>>            End
81174>>>>>>>>>>
81174>>>>>>>>>        End
81174>>>>>>>>>>
81174>>>>>>>>>
81174>>>>>>>>>        Function_Return sStmt
81175>>>>>>>>>    End_Function
81176>>>>>>>>>
81176>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81176>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81178>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81178>>>>>>>>>        Integer iRetval
81178>>>>>>>>>        Boolean bOK
81178>>>>>>>>>
81178>>>>>>>>>        Get psDriverID to sDriverID
81179>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81180>>>>>>>>>
81180>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81181>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81182>>>>>>>>>        Set psSQLStatementString to sSQLString
81183>>>>>>>>>
81183>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81183>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81183>>>>>>>>>        Move False to Err
81184>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81185>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81186>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81187>>>>>>>>>        Move 0 to LastErr
81188>>>>>>>>>
81188>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81188>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81189>>>>>>>>>
81189>>>>>>>>>        Function_Return (Err = False)
81190>>>>>>>>>    End_Function
81191>>>>>>>>>
81191>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81191>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81193>>>>>>>>>        String sRetval
81193>>>>>>>>>        Integer iDbType iIndex
81193>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81193>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81194>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81194>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81194>>>>>>>>>
81194>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81194>>>>>>>>>        Move "" to sRetval
81195>>>>>>>>>        Get piDbType to iDbType
81196>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81197>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81198>>>>>>>>>
81198>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81199>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81200>>>>>>>>>        If (iIndex >= 0) Begin
81202>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81203>>>>>>>>>        End
81203>>>>>>>>>>
81203>>>>>>>>>
81203>>>>>>>>>        Function_Return sRetval
81204>>>>>>>>>    End_Function
81205>>>>>>>>>
81205>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81205>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81207>>>>>>>>>        String[] sSQLScriptArray
81208>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81208>>>>>>>>>        Integer iSize iCount
81208>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81208>>>>>>>>>
81208>>>>>>>>>        Move False to bCommentStart
81209>>>>>>>>>        Move False to bCommentEnd
81210>>>>>>>>>        Move False to bDashComment
81211>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81212>>>>>>>>>        Move "*/"  to sCommentEnd
81213>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81214>>>>>>>>>
81214>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81215>>>>>>>>>        Decrement iSize
81216>>>>>>>>>        Move "" to sText
81217>>>>>>>>>
81217>>>>>>>>>        for iCount from 0 to iSize
81223>>>>>>>>>>
81223>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81224>>>>>>>>>            Move (Trim(sLine)) to sTmp
81225>>>>>>>>>            If (sTmp <> "") Begin
81227>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81228>>>>>>>>>                If (bCommentStart = False) Begin
81230>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81231>>>>>>>>>                    If (bCommentStart = False) Begin
81233>>>>>>>>>                    End
81233>>>>>>>>>>
81233>>>>>>>>>                End
81233>>>>>>>>>>
81233>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81234>>>>>>>>>                If (bCommentEnd = True) Begin
81236>>>>>>>>>                    Move False to bCommentStart
81237>>>>>>>>>                End
81237>>>>>>>>>>
81237>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81239>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81240>>>>>>>>>                End
81240>>>>>>>>>>
81240>>>>>>>>>            End
81240>>>>>>>>>>
81240>>>>>>>>>        Loop
81241>>>>>>>>>>
81241>>>>>>>>>
81241>>>>>>>>>        // Update the retval struct array:
81241>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81242>>>>>>>>>        Function_Return SqlScriptArray
81243>>>>>>>>>    End_Function
81244>>>>>>>>>
81244>>>>>>>>>    // Helper function that builds a string like;
81244>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81244>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81246>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81246>>>>>>>>>
81246>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81247>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81248>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81249>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81250>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81251>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81252>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81253>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81254>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81255>>>>>>>>>        Function_Return sRetval
81256>>>>>>>>>    End_Function
81257>>>>>>>>>
81257>>>>>>>>>    // Helper function to create a SQL statement like;
81257>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81257>>>>>>>>>    // Used for checking if an index exists.
81257>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81259>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81259>>>>>>>>>
81259>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81260>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81261>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81262>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81263>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81264>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81265>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81266>>>>>>>>>
81266>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81267>>>>>>>>>
81267>>>>>>>>>        Function_Return sRetval
81268>>>>>>>>>    End_Function
81269>>>>>>>>>
81269>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81269>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81269>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81271>>>>>>>>>        String sRetval
81271>>>>>>>>>        If (iLength <> 0) Begin
81273>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81274>>>>>>>>>            If (iDecimals <> 0) Begin
81276>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81277>>>>>>>>>            End
81277>>>>>>>>>>
81277>>>>>>>>>            Move (sRetval + ")") to sRetval
81278>>>>>>>>>        End
81278>>>>>>>>>>
81278>>>>>>>>>        Function_Return sRetval
81279>>>>>>>>>    End_Function
81280>>>>>>>>>
81280>>>>>>>>>    // Checks that the passed sDriverID is defined.
81280>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81280>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81282>>>>>>>>>        Boolean bOK
81282>>>>>>>>>        Integer iDriver
81282>>>>>>>>>
81282>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81284>>>>>>>>>            Function_Return False
81285>>>>>>>>>        End
81285>>>>>>>>>>
81285>>>>>>>>>
81285>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81286>>>>>>>>>
81286>>>>>>>>>        If (bOK = False) Begin
81288>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81289>>>>>>>>>>
81289>>>>>>>>>            Function_Return False
81290>>>>>>>>>        End
81290>>>>>>>>>>
81290>>>>>>>>>
81290>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81291>>>>>>>>>        If (iDriver = 0) Begin
81293>>>>>>>>>            Load_Driver sDriverID
81294>>>>>>>>>        End
81294>>>>>>>>>>
81294>>>>>>>>>
81294>>>>>>>>>        Function_Return True
81295>>>>>>>>>    End_Function
81296>>>>>>>>>
81296>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81296>>>>>>>>>    // This is only of concern for certain SQL data types.
81296>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81298>>>>>>>>>        Integer iLength
81298>>>>>>>>>        Boolean bOK bCheckTypeLength
81298>>>>>>>>>
81298>>>>>>>>>        If (num_arguments > 1) Begin
81300>>>>>>>>>            Move iLen to iLength
81301>>>>>>>>>        End
81301>>>>>>>>>>
81301>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81302>>>>>>>>>
81302>>>>>>>>>        If (bCheckTypeLength = True) Begin
81304>>>>>>>>>            Move (iLength > 0) to bOK
81305>>>>>>>>>        End
81305>>>>>>>>>>
81305>>>>>>>>>
81305>>>>>>>>>        Function_Return (bOK = True)
81306>>>>>>>>>    End_Function
81307>>>>>>>>>
81307>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81309>>>>>>>>>        String sVal sSchema sDriverID
81309>>>>>>>>>        Integer iDbType
81309>>>>>>>>>
81309>>>>>>>>>        If (Trim(sTableName) = "") Begin
81311>>>>>>>>>            Function_Return ""
81312>>>>>>>>>        End
81312>>>>>>>>>>
81312>>>>>>>>>
81312>>>>>>>>>        Get psDriverID to sDriverID
81313>>>>>>>>>        Get piDbType   to iDbType
81314>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81316>>>>>>>>>            Get psUserID to sSchema
81317>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81317>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81318>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81319>>>>>>>>>            Function_Return sTableName
81320>>>>>>>>>        End
81320>>>>>>>>>>
81320>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81322>>>>>>>>>            Get psDatabase to sVal
81323>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81324>>>>>>>>>            Function_Return sTableName
81325>>>>>>>>>        End
81325>>>>>>>>>>
81325>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81327>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81328>>>>>>>>>            Function_Return sTableName
81329>>>>>>>>>        End
81329>>>>>>>>>>
81329>>>>>>>>>
81329>>>>>>>>>        Get psSchema to sSchema
81330>>>>>>>>>        If (sSchema = "") Begin
81332>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81333>>>>>>>>>        End
81333>>>>>>>>>>
81333>>>>>>>>>
81333>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81334>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81336>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81338>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81339>>>>>>>>>            End
81339>>>>>>>>>>
81339>>>>>>>>>            Else Begin
81340>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81341>>>>>>>>>            End
81341>>>>>>>>>>
81341>>>>>>>>>        End
81341>>>>>>>>>>
81341>>>>>>>>>
81341>>>>>>>>>        Function_Return sTableName
81342>>>>>>>>>    End_Function
81343>>>>>>>>>
81343>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81343>>>>>>>>>    // the passed sFieldName has the correct spelling.
81343>>>>>>>>>    // Used with Embedded SQL statement calls.
81343>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81343>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81345>>>>>>>>>        String sRetval sValue sDriverID
81345>>>>>>>>>        String[] sColumnNamesArray
81346>>>>>>>>>        Integer iCount iColumns
81346>>>>>>>>>
81346>>>>>>>>>        Move "" to sRetval
81347>>>>>>>>>        Get psDriverID to sDriverID
81348>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81349>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81350>>>>>>>>>        Decrement iColumns
81351>>>>>>>>>
81351>>>>>>>>>        For iCount from 0 to iColumns
81357>>>>>>>>>>
81357>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81358>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81360>>>>>>>>>                Move sValue to sRetval
81361>>>>>>>>>                Move iColumns to iCount // We're done.
81362>>>>>>>>>            End
81362>>>>>>>>>>
81362>>>>>>>>>        Loop
81363>>>>>>>>>>
81363>>>>>>>>>
81363>>>>>>>>>        Function_Return sRetval
81364>>>>>>>>>    End_Function
81365>>>>>>>>>
81365>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81367>>>>>>>>>        String[] sReturnArray
81368>>>>>>>>>        Handle hoSQLHandler
81368>>>>>>>>>        Integer iCount iSize iItem
81368>>>>>>>>>        String sServer
81368>>>>>>>>>        tSQLConnection SQLConnection
81368>>>>>>>>>        tSQLConnection SQLConnection
81368>>>>>>>>>
81368>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81369>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81370>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81371>>>>>>>>>
81371>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81372>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81373>>>>>>>>>        Decrement iSize
81374>>>>>>>>>
81374>>>>>>>>>        For iCount from 0 to iSize
81380>>>>>>>>>>
81380>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81381>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81382>>>>>>>>>            Increment iItem
81383>>>>>>>>>        Loop
81384>>>>>>>>>>
81384>>>>>>>>>
81384>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81385>>>>>>>>>
81385>>>>>>>>>        Function_Return sReturnArray
81386>>>>>>>>>    End_Function
81387>>>>>>>>>
81387>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81389>>>>>>>>>        String[] sReturnArray
81390>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81390>>>>>>>>>        Handle hoSQLHandler
81390>>>>>>>>>        Integer iCount iSize iItem iPos
81390>>>>>>>>>        Boolean bOK
81390>>>>>>>>>        tSQLConnection SQLConnection
81390>>>>>>>>>        tSQLConnection SQLConnection
81390>>>>>>>>>
81390>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81391>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81393>>>>>>>>>            Function_Return sReturnArray
81394>>>>>>>>>        End
81394>>>>>>>>>>
81394>>>>>>>>>
81394>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81395>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81396>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81397>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81398>>>>>>>>>
81398>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81399>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81400>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81401>>>>>>>>>
81401>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81402>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81403>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81403>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81403>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81403>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81403>>>>>>>>>//                If (iPos > 0) Begin
81403>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81403>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81403>>>>>>>>>//                End
81403>>>>>>>>>//            End
81403>>>>>>>>>//        End
81403>>>>>>>>>
81403>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81404>>>>>>>>>        Move False to Err
81405>>>>>>>>>        Move 0 to iItem
81406>>>>>>>>>
81406>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81406>>>>>>>>>        For iCount from 1 to iSize
81412>>>>>>>>>>
81412>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81413>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81414>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81415>>>>>>>>>            If (sSchema = "") Begin
81417>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81418>>>>>>>>>            End
81418>>>>>>>>>>
81418>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81419>>>>>>>>>            Move (Trim(sTable)) to sTable
81420>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81422>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81423>>>>>>>>>            End
81423>>>>>>>>>>
81423>>>>>>>>>            Else Begin
81424>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81425>>>>>>>>>            End
81425>>>>>>>>>>
81425>>>>>>>>>            If (bOK = True) Begin
81427>>>>>>>>>                Move sTable to sReturnArray[iItem]
81428>>>>>>>>>                Increment iItem
81429>>>>>>>>>            End
81429>>>>>>>>>>
81429>>>>>>>>>        Loop
81430>>>>>>>>>>
81430>>>>>>>>>
81430>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81431>>>>>>>>>
81431>>>>>>>>>        Function_Return sReturnArray
81432>>>>>>>>>    End_Function
81433>>>>>>>>>
81433>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81435>>>>>>>>>        String[] sReturnArray
81436>>>>>>>>>        String sValue
81436>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81436>>>>>>>>>        Integer iRetval iCols iFetchResult
81436>>>>>>>>>        tSQLConnection SQLConnection
81436>>>>>>>>>        tSQLConnection SQLConnection
81436>>>>>>>>>
81436>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81437>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81438>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81439>>>>>>>>>
81439>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81441>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81442>>>>>>>>>            If (hStmt <> 0) Begin
81444>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81445>>>>>>>>>                If (sArgument <> "") Begin
81447>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81448>>>>>>>>>                End
81448>>>>>>>>>>
81448>>>>>>>>>
81448>>>>>>>>>                Send SqlCall             of hStmt
81449>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81450>>>>>>>>>                If (iRetval = 0) Begin
81452>>>>>>>>>                    Repeat
81452>>>>>>>>>>
81452>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81453>>>>>>>>>                        If (iCols > 0) Begin
81455>>>>>>>>>                            Repeat
81455>>>>>>>>>>
81455>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81456>>>>>>>>>                                If (iFetchResult <> 0) Begin
81458>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81459>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81460>>>>>>>>>                                End
81460>>>>>>>>>>
81460>>>>>>>>>                            Until (iFetchResult = 0)
81462>>>>>>>>>                        End
81462>>>>>>>>>>
81462>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81463>>>>>>>>>                    Until (iRetval = 0)
81465>>>>>>>>>                    Send SqlClose of hStmt
81466>>>>>>>>>                End
81466>>>>>>>>>>
81466>>>>>>>>>            End
81466>>>>>>>>>>
81466>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81467>>>>>>>>>        End
81467>>>>>>>>>>
81467>>>>>>>>>        Function_Return sReturnArray
81468>>>>>>>>>    End_Function
81469>>>>>>>>>
81469>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81471>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81471>>>>>>>>>        Boolean bOpened bOK
81471>>>>>>>>>
81471>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81471>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81471>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81471>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81471>>>>>>>>>        // proper .int files for the two tables.
81471>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81473>>>>>>>>>            Function_Return True
81474>>>>>>>>>        End
81474>>>>>>>>>>
81474>>>>>>>>>
81474>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81477>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81478>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81479>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81480>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81481>>>>>>>>>
81481>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81481>>>>>>>>>        Sleep 1
81482>>>>>>>>>
81482>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81485>>>>>>>>>        If (bOpened = False) Begin
81487>>>>>>>>>            Open hTable
81489>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81492>>>>>>>>>        End
81492>>>>>>>>>>
81492>>>>>>>>>        If (bOpened = False) Begin
81494>>>>>>>>>            Function_Return False
81495>>>>>>>>>        End
81495>>>>>>>>>>
81495>>>>>>>>>
81495>>>>>>>>>        Get psDriverID to sDriverID
81496>>>>>>>>>
81496>>>>>>>>>        Move False to Err
81497>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81500>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81501>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81501>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81501>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81502>>>>>>>>>
81502>>>>>>>>>        Move False to Err
81503>>>>>>>>>
81503>>>>>>>>>        If (hTable > 0) Begin
81505>>>>>>>>>            Structure_Start hTable
81506>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81509>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81512>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81514>>>>>>>>>        End
81514>>>>>>>>>>
81514>>>>>>>>>        Else Begin
81515>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81518>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81521>>>>>>>>>        End
81521>>>>>>>>>>
81521>>>>>>>>>        Function_Return (Err = False)
81522>>>>>>>>>    End_Function
81523>>>>>>>>>
81523>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81523>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81525>>>>>>>>>        Handle hTable
81525>>>>>>>>>        String sConnectionID
81525>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81525>>>>>>>>>
81525>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81526>>>>>>>>>        If (bSameTableNames = True) Begin
81528>>>>>>>>>            Function_Return True
81529>>>>>>>>>        End
81529>>>>>>>>>>
81529>>>>>>>>>
81529>>>>>>>>>        Move True to bOK
81530>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81531>>>>>>>>>        Set Private.phCurrentTable              to hTable
81532>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81535>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81538>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81541>>>>>>>>>
81541>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81543>>>>>>>>>            Get psConnectionID to sConnectionID
81544>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81545>>>>>>>>>            If (bTableExists = True) Begin
81547>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81548>>>>>>>>>            End
81548>>>>>>>>>>
81548>>>>>>>>>            Else Begin
81549>>>>>>>>>                Get pbToANSI to bANSI
81550>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81551>>>>>>>>>            End
81551>>>>>>>>>>
81551>>>>>>>>>        End
81551>>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>        Function_Return bOK
81552>>>>>>>>>    End_Function
81553>>>>>>>>>
81553>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81553>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81553>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81555>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81555>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81555>>>>>>>>>        String[] sIndexArray
81556>>>>>>>>>        Integer iCount iCh iSize
81556>>>>>>>>>
81556>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81557>>>>>>>>>        Get psConnectionString to sConnectionString
81558>>>>>>>>>
81558>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81559>>>>>>>>>        If (bANSI = False) Begin
81561>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81562>>>>>>>>>        End
81562>>>>>>>>>>
81562>>>>>>>>>
81562>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81563>>>>>>>>>        Get vFolderExists sDataPath to bOK
81564>>>>>>>>>        If (bOK = False) Begin
81566>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81567>>>>>>>>>>
81567>>>>>>>>>            Function_Return False
81568>>>>>>>>>        End
81568>>>>>>>>>>
81568>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81569>>>>>>>>>
81569>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81572>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81575>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81576>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81577>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81578>>>>>>>>>
81578>>>>>>>>>        Get psSchema hTable to sSchemaName
81579>>>>>>>>>        If (sSchemaName = "") Begin
81581>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81582>>>>>>>>>        End
81582>>>>>>>>>>
81582>>>>>>>>>
81582>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81582>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81583>>>>>>>>>        If (bExists = True) Begin
81585>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81586>>>>>>>>>        End
81586>>>>>>>>>>
81586>>>>>>>>>
81586>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81587>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81588>>>>>>>>>
81588>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81589>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81594>>>>>>>>>            If (bUseConnectionID = True) Begin
81596>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81603>>>>>>>>>            End
81603>>>>>>>>>>
81603>>>>>>>>>            Else Begin
81604>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81611>>>>>>>>>            End
81611>>>>>>>>>>
81611>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81616>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81621>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81621>>>>>>>>>            If (bSysFile = True) Begin
81623>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81628>>>>>>>>>            End
81628>>>>>>>>>>
81628>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81633>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81638>>>>>>>>>            If (bSysFile = True) Begin
81640>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81645>>>>>>>>>            End
81645>>>>>>>>>>
81645>>>>>>>>>
81645>>>>>>>>>            If (bSysFile = False) Begin
81647>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81648>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81649>>>>>>>>>                If (iSize > 0) Begin
81651>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81654>>>>>>>>>                    Writeln channel iCh // Just an empty line
81656>>>>>>>>>                End
81656>>>>>>>>>>
81656>>>>>>>>>                Decrement iSize
81657>>>>>>>>>                for iCount from 0 to iSize
81663>>>>>>>>>>
81663>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81666>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81669>>>>>>>>>                    Writeln channel iCh
81671>>>>>>>>>                Loop
81672>>>>>>>>>>
81672>>>>>>>>>            End
81672>>>>>>>>>>
81672>>>>>>>>>        Send Seq_Close_Channel iCh
81673>>>>>>>>>
81673>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81673>>>>>>>>>        Sleep 1
81674>>>>>>>>>
81674>>>>>>>>>        Function_Return (bOK = True)
81675>>>>>>>>>    End_Function
81676>>>>>>>>>
81676>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81678>>>>>>>>>        String sDataPath sDriverID
81678>>>>>>>>>        Boolean bOK
81678>>>>>>>>>        Integer iPos
81678>>>>>>>>>
81678>>>>>>>>>        If (sTableName contains ".") Begin
81680>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81681>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81682>>>>>>>>>        End
81682>>>>>>>>>>
81682>>>>>>>>>
81682>>>>>>>>>        Get psDriverID to sDriverID
81683>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81684>>>>>>>>>        // First delete the cache file:
81684>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81685>>>>>>>>>
81685>>>>>>>>>        Function_Return bOK
81686>>>>>>>>>    End_Function
81687>>>>>>>>>
81687>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81687>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81687>>>>>>>>>    // if it is an SQL table
81687>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81689>>>>>>>>>        Boolean bExists bIsSQLTable
81689>>>>>>>>>        String sDataPath sRootName
81689>>>>>>>>>
81689>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81690>>>>>>>>>        If (bExists = False) Begin
81692>>>>>>>>>            Function_Return False
81693>>>>>>>>>        End
81693>>>>>>>>>>
81693>>>>>>>>>
81693>>>>>>>>>        Move False to bIsSQLTable
81694>>>>>>>>>        If (hTable > 0) Begin
81696>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81699>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81700>>>>>>>>>        End
81700>>>>>>>>>>
81700>>>>>>>>>        If (bIsSQLTable = True) Begin
81702>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81703>>>>>>>>>            Function_Return bExists
81704>>>>>>>>>        End
81704>>>>>>>>>>
81704>>>>>>>>>        Else Begin
81705>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81706>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81707>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81708>>>>>>>>>        End
81708>>>>>>>>>>
81708>>>>>>>>>
81708>>>>>>>>>        Function_Return bExists
81709>>>>>>>>>    End_Function
81710>>>>>>>>>
81710>>>>>>>>>    // Pass a table handle
81710>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81710>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81712>>>>>>>>>        Handle hTable
81712>>>>>>>>>        Boolean bFound
81712>>>>>>>>>
81712>>>>>>>>>        Move False to bFound
81713>>>>>>>>>        Move 0 to hTable
81714>>>>>>>>>        Repeat
81714>>>>>>>>>>
81714>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81717>>>>>>>>>            If (hTable > 0) Begin
81719>>>>>>>>>                If (hTable = hCheckTable) Begin
81721>>>>>>>>>                    Move True to bFound
81722>>>>>>>>>                End
81722>>>>>>>>>>
81722>>>>>>>>>            End
81722>>>>>>>>>>
81722>>>>>>>>>            If (bFound = True) ;                Break
81725>>>>>>>>>        Until (hTable = 0)
81727>>>>>>>>>
81727>>>>>>>>>        Function_Return (bFound = True)
81728>>>>>>>>>    End_Function
81729>>>>>>>>>
81729>>>>>>>>>    // DataFlex Embedded Database Data Types:
81729>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81729>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81731>>>>>>>>>        tColumnType[] ColumnType
81731>>>>>>>>>        tColumnType[] ColumnType
81732>>>>>>>>>        Integer i
81732>>>>>>>>>
81732>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81733>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81734>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81735>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81736>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81737>>>>>>>>>        Increment i
81738>>>>>>>>>
81738>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81739>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81740>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81741>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81742>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81743>>>>>>>>>        Increment i
81744>>>>>>>>>
81744>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81745>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81746>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81747>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81748>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81749>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81750>>>>>>>>>        Increment i
81751>>>>>>>>>
81751>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81752>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81753>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81754>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81755>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81756>>>>>>>>>        Increment i
81757>>>>>>>>>
81757>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81758>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81759>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81760>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81761>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81762>>>>>>>>>        Increment i
81763>>>>>>>>>
81763>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81764>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81765>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81766>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81767>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81768>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81769>>>>>>>>>        Increment i
81770>>>>>>>>>
81770>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81771>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81772>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81773>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81774>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81775>>>>>>>>>
81775>>>>>>>>>        Function_Return ColumnType
81776>>>>>>>>>    End_Function
81777>>>>>>>>>
81777>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81779>>>>>>>>>        tColumnType[] aColumnType
81779>>>>>>>>>        tColumnType[] aColumnType
81780>>>>>>>>>        Integer i
81780>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81780>>>>>>>>>>// Generated By The Database Update Framework
81780>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81780>>>>>>>>>>// Driver COLUMN DATA TYPES
81780>>>>>>>>>>//
81780>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
81780>>>>>>>>>>
81780>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81781>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81782>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81783>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81784>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81785>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81786>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81787>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81788>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81789>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81790>>>>>>>>>>            Increment i
81791>>>>>>>>>>
81791>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81792>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81793>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81794>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81795>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81796>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81797>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81798>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81799>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81800>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81801>>>>>>>>>>            Increment i
81802>>>>>>>>>>
81802>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81803>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81804>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81805>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81806>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81807>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81808>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81809>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81810>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81811>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81812>>>>>>>>>>            Increment i
81813>>>>>>>>>>
81813>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81814>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81815>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81816>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81817>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81818>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81819>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81820>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81821>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81822>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81823>>>>>>>>>>            Increment i
81824>>>>>>>>>>
81824>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81825>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81826>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81827>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81828>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81829>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81830>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81831>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81832>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81833>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81834>>>>>>>>>>            Increment i
81835>>>>>>>>>>
81835>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81836>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81837>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81838>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81839>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81840>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81841>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81842>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81843>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81844>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81845>>>>>>>>>>            Increment i
81846>>>>>>>>>>
81846>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81847>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81848>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81849>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81850>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81851>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81852>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81853>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81854>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81855>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81856>>>>>>>>>>            Increment i
81857>>>>>>>>>>
81857>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81858>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81859>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81860>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81861>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81862>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81863>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81864>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81865>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81866>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81867>>>>>>>>>>            Increment i
81868>>>>>>>>>>
81868>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81869>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81870>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81871>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81872>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81873>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81874>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81875>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81876>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81877>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81878>>>>>>>>>>            Increment i
81879>>>>>>>>>>
81879>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81880>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81881>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81882>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81883>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81884>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81885>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81886>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81887>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81888>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81889>>>>>>>>>>            Increment i
81890>>>>>>>>>>
81890>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81891>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81892>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81893>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81894>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81895>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81896>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81897>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81898>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81899>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81900>>>>>>>>>>            Increment i
81901>>>>>>>>>>
81901>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81902>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81903>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81904>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81905>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81906>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81907>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81908>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81909>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81910>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81911>>>>>>>>>>            Increment i
81912>>>>>>>>>>
81912>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81913>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81914>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81915>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81916>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81917>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81918>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81919>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81920>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81921>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81922>>>>>>>>>>            Increment i
81923>>>>>>>>>>
81923>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81924>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81925>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81926>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81927>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81928>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81929>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81930>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81931>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81932>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81933>>>>>>>>>>            Increment i
81934>>>>>>>>>>
81934>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81935>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81936>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81937>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81938>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81939>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81940>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81941>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81942>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81943>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81944>>>>>>>>>>            Increment i
81945>>>>>>>>>>
81945>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81946>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81947>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81948>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81949>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81950>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81951>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81952>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81953>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81954>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81955>>>>>>>>>>            Increment i
81956>>>>>>>>>>
81956>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
81957>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
81958>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81959>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81960>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81961>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81962>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81963>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81964>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81965>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81966>>>>>>>>>>            Increment i
81967>>>>>>>>>>
81967>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
81968>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
81969>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81970>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81971>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81972>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81973>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81974>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81975>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81976>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81977>>>>>>>>>>            Increment i
81978>>>>>>>>>>
81978>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
81979>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
81980>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81981>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81982>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81983>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81984>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81985>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81986>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81987>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81988>>>>>>>>>>            Increment i
81989>>>>>>>>>>
81989>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
81990>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
81991>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81992>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81993>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81994>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81995>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81996>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81997>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81998>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81999>>>>>>>>>>            Increment i
82000>>>>>>>>>>
82000>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82001>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82002>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82003>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82004>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82005>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82006>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82007>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82008>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82009>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82010>>>>>>>>>>            Increment i
82011>>>>>>>>>>
82011>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82012>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82013>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82014>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82015>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82016>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82017>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82018>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82019>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82020>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82021>>>>>>>>>>            Increment i
82022>>>>>>>>>>
82022>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82023>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82024>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82025>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82026>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82027>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82028>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82029>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82030>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82031>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82032>>>>>>>>>>            Increment i
82033>>>>>>>>>>
82033>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82034>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82035>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82036>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82037>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82038>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82039>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82040>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82041>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82042>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82043>>>>>>>>>>            Increment i
82044>>>>>>>>>>
82044>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82045>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82048>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82050>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82051>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82052>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82053>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82054>>>>>>>>>>            Increment i
82055>>>>>>>>>>
82055>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82056>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82057>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82059>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82060>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82061>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82062>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82063>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82064>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82065>>>>>>>>>>            Increment i
82066>>>>>>>>>>
82066>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82067>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82068>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82070>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82071>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82072>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82073>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82074>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82075>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82076>>>>>>>>>>            Increment i
82077>>>>>>>>>>
82077>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82078>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82079>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82081>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82082>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82083>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82084>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82085>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82086>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82087>>>>>>>>>>            Increment i
82088>>>>>>>>>>
82088>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82089>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82090>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82092>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82093>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82094>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82095>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82096>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82097>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82098>>>>>>>>>>            Increment i
82099>>>>>>>>>>
82099>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82100>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82101>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82103>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82104>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82105>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82106>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82107>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82108>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82109>>>>>>>>>>            Increment i
82110>>>>>>>>>>
82110>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82111>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82112>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82114>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82115>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82116>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82117>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82118>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82119>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82120>>>>>>>>>>            Increment i
82121>>>>>>>>>>
82121>>>>>>>>>>
82121>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82121>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82121>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82121>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82121>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82121>>>>>>>>>//        Increment i
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>//
82121>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82121>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82121>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82121>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82121>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82121>>>>>>>>>
82121>>>>>>>>>        Function_Return aColumnType
82122>>>>>>>>>    End_Function
82123>>>>>>>>>
82123>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82123>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82123>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82125>>>>>>>>>        tColumnType[] aColumnType
82125>>>>>>>>>        tColumnType[] aColumnType
82126>>>>>>>>>        Integer i
82126>>>>>>>>>
82126>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82128>>>>>>>>>>// Generated By The Database Update Framework
82128>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82128>>>>>>>>>>// Driver COLUMN DATA TYPES
82128>>>>>>>>>>//
82128>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82128>>>>>>>>>>
82128>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82129>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82130>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82131>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82132>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82133>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82134>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82135>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82136>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82137>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82138>>>>>>>>>>            Increment i
82139>>>>>>>>>>
82139>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82140>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82141>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82142>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82143>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82144>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82145>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82146>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82147>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82148>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82149>>>>>>>>>>            Increment i
82150>>>>>>>>>>
82150>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82151>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82152>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82153>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82154>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82155>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82156>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82157>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82158>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82159>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82160>>>>>>>>>>            Increment i
82161>>>>>>>>>>
82161>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82162>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82163>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82164>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82165>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82166>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82167>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82168>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82169>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82170>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82171>>>>>>>>>>            Increment i
82172>>>>>>>>>>
82172>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82173>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82174>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82175>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82176>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82177>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82178>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82179>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82180>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82181>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82182>>>>>>>>>>            Increment i
82183>>>>>>>>>>
82183>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82184>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82185>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82186>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82187>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82188>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82189>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82190>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82191>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82192>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82193>>>>>>>>>>            Increment i
82194>>>>>>>>>>
82194>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82195>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82196>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82197>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82198>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82199>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82200>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82201>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82202>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82203>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82204>>>>>>>>>>            Increment i
82205>>>>>>>>>>
82205>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82206>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82207>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82208>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82209>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82210>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82211>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82212>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82213>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82214>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82215>>>>>>>>>>            Increment i
82216>>>>>>>>>>
82216>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82217>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82218>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82219>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82220>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82221>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82222>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82223>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82224>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82225>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82226>>>>>>>>>>            Increment i
82227>>>>>>>>>>
82227>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82228>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82229>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82230>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82231>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82232>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82233>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82234>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82235>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82236>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82237>>>>>>>>>>            Increment i
82238>>>>>>>>>>
82238>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82239>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82240>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82241>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82242>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82243>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82244>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82245>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82246>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82247>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82248>>>>>>>>>>            Increment i
82249>>>>>>>>>>
82249>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82250>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82251>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82252>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82253>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82254>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82255>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82256>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82257>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82258>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82259>>>>>>>>>>            Increment i
82260>>>>>>>>>>
82260>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82261>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82262>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82263>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82264>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82265>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82266>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82267>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82268>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82269>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82270>>>>>>>>>>            Increment i
82271>>>>>>>>>>
82271>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82272>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82273>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82274>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82275>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82276>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82277>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82278>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82279>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82280>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82281>>>>>>>>>>            Increment i
82282>>>>>>>>>>
82282>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82283>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82284>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82285>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82286>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82287>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82288>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82289>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82290>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82291>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82292>>>>>>>>>>            Increment i
82293>>>>>>>>>>
82293>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82294>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82295>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82296>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82297>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82298>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82299>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82300>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82301>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82302>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82303>>>>>>>>>>            Increment i
82304>>>>>>>>>>
82304>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82305>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82306>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82307>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82308>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82309>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82310>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82311>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82312>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82313>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82314>>>>>>>>>>            Increment i
82315>>>>>>>>>>
82315>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82316>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82317>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82318>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82319>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82320>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82321>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82322>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82323>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82324>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82325>>>>>>>>>>            Increment i
82326>>>>>>>>>>
82326>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82327>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82328>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82329>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82330>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82331>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82332>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82333>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82334>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82335>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82336>>>>>>>>>>            Increment i
82337>>>>>>>>>>
82337>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82338>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82339>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82340>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82341>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82342>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82343>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82344>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82345>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82346>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82347>>>>>>>>>>            Increment i
82348>>>>>>>>>>
82348>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82349>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82350>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82351>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82352>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82353>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82354>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82355>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82356>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82357>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82358>>>>>>>>>>            Increment i
82359>>>>>>>>>>
82359>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82360>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82361>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82362>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82363>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82364>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82365>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82366>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82367>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82368>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82369>>>>>>>>>>            Increment i
82370>>>>>>>>>>
82370>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82371>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82372>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82373>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82374>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82375>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82376>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82377>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82378>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82379>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82380>>>>>>>>>>            Increment i
82381>>>>>>>>>>
82381>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82382>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82383>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82384>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82385>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82386>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82387>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82388>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82389>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82390>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82391>>>>>>>>>>            Increment i
82392>>>>>>>>>>
82392>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82393>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82394>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82395>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82396>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82397>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82398>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82399>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82400>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82401>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82402>>>>>>>>>>            Increment i
82403>>>>>>>>>>
82403>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82404>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82405>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82406>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82407>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82408>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82409>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82410>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82411>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82412>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82413>>>>>>>>>>            Increment i
82414>>>>>>>>>>
82414>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82415>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82416>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82417>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82418>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82419>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82420>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82421>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82422>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82423>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82424>>>>>>>>>>            Increment i
82425>>>>>>>>>>
82425>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82426>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82427>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82428>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82429>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82430>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82431>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82432>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82433>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82434>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82435>>>>>>>>>>            Increment i
82436>>>>>>>>>>
82436>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82437>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82438>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82439>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82440>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82441>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82442>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82443>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82444>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82445>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82446>>>>>>>>>>            Increment i
82447>>>>>>>>>>
82447>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82448>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82449>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82450>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82451>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82452>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82453>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82454>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82455>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82456>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82457>>>>>>>>>>            Increment i
82458>>>>>>>>>>
82458>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82459>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82460>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82461>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82462>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82463>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82464>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82465>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82466>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82467>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82468>>>>>>>>>>            Increment i
82469>>>>>>>>>>
82469>>>>>>>>>>
82469>>>>>>>>>
82469>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>//
82469>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82469>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82469>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82469>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82469>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82469>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82469>>>>>>>>>//            Increment i
82469>>>>>>>>>
82469>>>>>>>>>        End
82469>>>>>>>>>>
82469>>>>>>>>>
82469>>>>>>>>>        Function_Return aColumnType
82470>>>>>>>>>    End_Function
82471>>>>>>>>>
82471>>>>>>>>>    // MySQL Data Types
82471>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82473>>>>>>>>>        tColumnType[] aColumnType
82473>>>>>>>>>        tColumnType[] aColumnType
82474>>>>>>>>>        Integer i
82474>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82474>>>>>>>>>>// Generated By The Database Update Framework
82474>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82474>>>>>>>>>>// Driver COLUMN DATA TYPES
82474>>>>>>>>>>//
82474>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82474>>>>>>>>>>
82474>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82475>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82476>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82477>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82478>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82479>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82480>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82481>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82482>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82483>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82484>>>>>>>>>>            Increment i
82485>>>>>>>>>>
82485>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82486>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82487>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82488>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82489>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82490>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82491>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82492>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82493>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82494>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82495>>>>>>>>>>            Increment i
82496>>>>>>>>>>
82496>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82497>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82498>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82499>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82500>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82501>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82502>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82503>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82504>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82505>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82506>>>>>>>>>>            Increment i
82507>>>>>>>>>>
82507>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82508>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82509>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82510>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82511>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82512>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82513>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82514>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82515>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82516>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82517>>>>>>>>>>            Increment i
82518>>>>>>>>>>
82518>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82519>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82520>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82521>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82522>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82523>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82524>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82525>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82526>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82527>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82528>>>>>>>>>>            Increment i
82529>>>>>>>>>>
82529>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82530>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82532>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82533>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82534>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82535>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82536>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82537>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82538>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82539>>>>>>>>>>            Increment i
82540>>>>>>>>>>
82540>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82541>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82543>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82544>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82545>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82546>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82547>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82548>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82549>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82550>>>>>>>>>>            Increment i
82551>>>>>>>>>>
82551>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82552>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82554>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82555>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82556>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82557>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82558>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82559>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82560>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82561>>>>>>>>>>            Increment i
82562>>>>>>>>>>
82562>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82563>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82565>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82566>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82567>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82568>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82569>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82570>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82571>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82572>>>>>>>>>>            Increment i
82573>>>>>>>>>>
82573>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82574>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82576>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82577>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82578>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82579>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82580>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82581>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82582>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82583>>>>>>>>>>            Increment i
82584>>>>>>>>>>
82584>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82585>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82587>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82588>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82589>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82590>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82591>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82592>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82593>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82594>>>>>>>>>>            Increment i
82595>>>>>>>>>>
82595>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82596>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82598>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82599>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82600>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82601>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82602>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82603>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82604>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82605>>>>>>>>>>            Increment i
82606>>>>>>>>>>
82606>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82607>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82609>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82610>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82611>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82612>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82613>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82614>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82615>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82616>>>>>>>>>>            Increment i
82617>>>>>>>>>>
82617>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82618>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82619>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82620>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82621>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82622>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82623>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82624>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82625>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82626>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82627>>>>>>>>>>            Increment i
82628>>>>>>>>>>
82628>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82629>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82630>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82631>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82632>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82633>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82634>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82635>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82636>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82637>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82638>>>>>>>>>>            Increment i
82639>>>>>>>>>>
82639>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82640>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82641>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82642>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82643>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82644>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82645>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82646>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82647>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82648>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82649>>>>>>>>>>            Increment i
82650>>>>>>>>>>
82650>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82651>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82652>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82653>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82654>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82655>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82656>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82657>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82658>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82659>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82660>>>>>>>>>>            Increment i
82661>>>>>>>>>>
82661>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82662>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82663>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82664>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82665>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82666>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82667>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82668>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82669>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82670>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82671>>>>>>>>>>            Increment i
82672>>>>>>>>>>
82672>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82673>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82674>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82675>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82676>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82677>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82678>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82679>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82680>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82681>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82682>>>>>>>>>>            Increment i
82683>>>>>>>>>>
82683>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82684>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82685>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82686>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82687>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82688>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82689>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82690>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82691>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82692>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82693>>>>>>>>>>            Increment i
82694>>>>>>>>>>
82694>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82695>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82696>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82697>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82698>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82699>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82700>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82701>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82702>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82703>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82704>>>>>>>>>>            Increment i
82705>>>>>>>>>>
82705>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82706>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82707>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82708>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82709>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82710>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82711>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82712>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82713>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82714>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82715>>>>>>>>>>            Increment i
82716>>>>>>>>>>
82716>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82717>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82718>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82719>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82720>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82721>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82722>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82723>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82724>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82725>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82726>>>>>>>>>>            Increment i
82727>>>>>>>>>>
82727>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82728>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82729>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82730>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82731>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82732>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82733>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82734>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82735>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82736>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82737>>>>>>>>>>            Increment i
82738>>>>>>>>>>
82738>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82739>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82740>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82741>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82742>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82743>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82744>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82745>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82746>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82747>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82748>>>>>>>>>>            Increment i
82749>>>>>>>>>>
82749>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82750>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82751>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82752>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82753>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82754>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82755>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82756>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82757>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82758>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82759>>>>>>>>>>            Increment i
82760>>>>>>>>>>
82760>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82761>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82762>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82763>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82764>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82765>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82766>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82767>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82768>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82769>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82770>>>>>>>>>>            Increment i
82771>>>>>>>>>>
82771>>>>>>>>>>
82771>>>>>>>>>
82771>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>//
82771>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82771>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82771>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82771>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82771>>>>>>>>>//        Increment i
82771>>>>>>>>>
82771>>>>>>>>>        Function_Return aColumnType
82772>>>>>>>>>    End_Function
82773>>>>>>>>>
82773>>>>>>>>>    // Oracle Data Types
82773>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82775>>>>>>>>>        tColumnType[] aColumnType
82775>>>>>>>>>        tColumnType[] aColumnType
82776>>>>>>>>>        Integer i
82776>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82776>>>>>>>>>>// Generated By The Database Update Framework
82776>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82776>>>>>>>>>>// Driver COLUMN DATA TYPES
82776>>>>>>>>>>//
82776>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82776>>>>>>>>>>
82776>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82777>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82778>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82779>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82780>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82781>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82782>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82783>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82784>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82785>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82786>>>>>>>>>>            Increment i
82787>>>>>>>>>>
82787>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82788>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82789>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82790>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82791>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82792>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82793>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82794>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82795>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82796>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82797>>>>>>>>>>            Increment i
82798>>>>>>>>>>
82798>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82799>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82800>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82801>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82802>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82803>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82804>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82805>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82806>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82807>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82808>>>>>>>>>>            Increment i
82809>>>>>>>>>>
82809>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82810>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82811>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82812>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82813>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82814>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82815>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82816>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82817>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82818>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82819>>>>>>>>>>            Increment i
82820>>>>>>>>>>
82820>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82821>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82822>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82823>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82824>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82825>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82826>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82827>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82828>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82829>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82830>>>>>>>>>>            Increment i
82831>>>>>>>>>>
82831>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82832>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82834>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82835>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82836>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82837>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82838>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82839>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82840>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82841>>>>>>>>>>            Increment i
82842>>>>>>>>>>
82842>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82843>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82844>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82845>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82846>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82847>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82848>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82849>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82850>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82851>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82852>>>>>>>>>>            Increment i
82853>>>>>>>>>>
82853>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82854>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82855>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82856>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82857>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82858>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82859>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82860>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82861>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82862>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82863>>>>>>>>>>            Increment i
82864>>>>>>>>>>
82864>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82865>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82867>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82868>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82869>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82870>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82871>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82872>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82873>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82874>>>>>>>>>>            Increment i
82875>>>>>>>>>>
82875>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82876>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82878>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82879>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82880>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82881>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82882>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82883>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82884>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82885>>>>>>>>>>            Increment i
82886>>>>>>>>>>
82886>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82887>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82889>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82890>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82891>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82892>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82893>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82894>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82895>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82896>>>>>>>>>>            Increment i
82897>>>>>>>>>>
82897>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82898>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82900>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82901>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82902>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82903>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82904>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82905>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82906>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82907>>>>>>>>>>            Increment i
82908>>>>>>>>>>
82908>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82909>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82911>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82912>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82913>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82914>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82915>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82916>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82917>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82918>>>>>>>>>>            Increment i
82919>>>>>>>>>>
82919>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82920>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82921>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82922>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82923>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82924>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82925>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82926>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82927>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82928>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82929>>>>>>>>>>            Increment i
82930>>>>>>>>>>
82930>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82931>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82932>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82933>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82934>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82935>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82936>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82937>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82938>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82939>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82940>>>>>>>>>>            Increment i
82941>>>>>>>>>>
82941>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82942>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82943>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82944>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82945>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82946>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82947>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82948>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82949>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82950>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82951>>>>>>>>>>            Increment i
82952>>>>>>>>>>
82952>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
82953>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
82954>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82955>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82956>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82957>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82958>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82959>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82960>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82961>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82962>>>>>>>>>>            Increment i
82963>>>>>>>>>>
82963>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82964>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
82965>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82966>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82967>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82968>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82969>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82970>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82971>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82972>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82973>>>>>>>>>>            Increment i
82974>>>>>>>>>>
82974>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
82975>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82976>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82977>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82978>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82979>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82980>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82981>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82982>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82983>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82984>>>>>>>>>>            Increment i
82985>>>>>>>>>>
82985>>>>>>>>>>
82985>>>>>>>>>
82985>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
82985>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82985>>>>>>>>>//        Increment i
82985>>>>>>>>>//
82985>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
82985>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82985>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82985>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82985>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82985>>>>>>>>>
82985>>>>>>>>>        Function_Return aColumnType
82986>>>>>>>>>    End_Function
82987>>>>>>>>>
82987>>>>>>>>>    // PostgreSQL Data Types
82987>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
82989>>>>>>>>>        tColumnType[] aColumnType
82989>>>>>>>>>        tColumnType[] aColumnType
82990>>>>>>>>>        Integer i
82990>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
82990>>>>>>>>>>// Generated By The Database Update Framework
82990>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
82990>>>>>>>>>>// Driver COLUMN DATA TYPES
82990>>>>>>>>>>//
82990>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
82990>>>>>>>>>>
82990>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82991>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
82992>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82993>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82994>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82995>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82996>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82997>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82998>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82999>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83000>>>>>>>>>>            Increment i
83001>>>>>>>>>>
83001>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83002>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83003>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83004>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83005>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83006>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83007>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83008>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83009>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83010>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83011>>>>>>>>>>            Increment i
83012>>>>>>>>>>
83012>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83013>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83014>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83015>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83016>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83017>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83018>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83019>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83020>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83021>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83022>>>>>>>>>>            Increment i
83023>>>>>>>>>>
83023>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83024>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83025>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83026>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83027>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83028>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83029>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83030>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83031>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83032>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83033>>>>>>>>>>            Increment i
83034>>>>>>>>>>
83034>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83035>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83036>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83037>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83038>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83039>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83040>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83041>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83042>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83043>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83044>>>>>>>>>>            Increment i
83045>>>>>>>>>>
83045>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83046>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83048>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83050>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83051>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83052>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83053>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83054>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83055>>>>>>>>>>            Increment i
83056>>>>>>>>>>
83056>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83057>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83058>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83059>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83060>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83061>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83062>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83063>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83064>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83065>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83066>>>>>>>>>>            Increment i
83067>>>>>>>>>>
83067>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83068>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83070>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83071>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83072>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83073>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83074>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83075>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83076>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83077>>>>>>>>>>            Increment i
83078>>>>>>>>>>
83078>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83079>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83081>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83082>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83083>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83084>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83085>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83086>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83087>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83088>>>>>>>>>>            Increment i
83089>>>>>>>>>>
83089>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83090>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83092>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83093>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83094>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83095>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83096>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83097>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83098>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83099>>>>>>>>>>            Increment i
83100>>>>>>>>>>
83100>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83101>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83103>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83104>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83105>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83106>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83107>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83108>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83109>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83110>>>>>>>>>>            Increment i
83111>>>>>>>>>>
83111>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83112>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83113>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83114>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83115>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83116>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83117>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83118>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83119>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83120>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83121>>>>>>>>>>            Increment i
83122>>>>>>>>>>
83122>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83123>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83125>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83126>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83127>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83128>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83129>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83130>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83131>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83132>>>>>>>>>>            Increment i
83133>>>>>>>>>>
83133>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83134>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83135>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83136>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83137>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83138>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83139>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83140>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83141>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83142>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83143>>>>>>>>>>            Increment i
83144>>>>>>>>>>
83144>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83145>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83146>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83147>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83148>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83149>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83150>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83151>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83152>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83153>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83154>>>>>>>>>>            Increment i
83155>>>>>>>>>>
83155>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83156>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83157>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83158>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83159>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83160>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83161>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83162>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83163>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83164>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83165>>>>>>>>>>            Increment i
83166>>>>>>>>>>
83166>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83167>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83168>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83169>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83170>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83171>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83172>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83173>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83174>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83175>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83176>>>>>>>>>>            Increment i
83177>>>>>>>>>>
83177>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83178>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83179>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83180>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83181>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83182>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83183>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83184>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83185>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83186>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83187>>>>>>>>>>            Increment i
83188>>>>>>>>>>
83188>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83189>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83190>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83191>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83192>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83193>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83194>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83195>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83196>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83197>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83198>>>>>>>>>>            Increment i
83199>>>>>>>>>>
83199>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83200>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83201>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83202>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83203>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83204>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83205>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83206>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83207>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83208>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83209>>>>>>>>>>            Increment i
83210>>>>>>>>>>
83210>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83211>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83212>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83213>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83214>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83215>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83216>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83217>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83218>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83219>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83220>>>>>>>>>>            Increment i
83221>>>>>>>>>>
83221>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83222>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83223>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83224>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83225>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83226>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83227>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83228>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83229>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83230>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83231>>>>>>>>>>            Increment i
83232>>>>>>>>>>
83232>>>>>>>>>>
83232>>>>>>>>>
83232>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83232>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83232>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83232>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>//
83232>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83232>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83232>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83232>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83232>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83232>>>>>>>>>//        Increment i
83232>>>>>>>>>
83232>>>>>>>>>        Function_Return aColumnType
83233>>>>>>>>>    End_Function
83234>>>>>>>>>
83234>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83234>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83236>>>>>>>>>        Integer iValue iSize iCount iStart
83236>>>>>>>>>        tColumnType[] ColumnTypeArray
83236>>>>>>>>>        tColumnType[] ColumnTypeArray
83237>>>>>>>>>        tColumnType RetvalType
83237>>>>>>>>>        tColumnType RetvalType
83237>>>>>>>>>        String sValue
83237>>>>>>>>>        Boolean bFrameworkDataFlexType
83237>>>>>>>>>
83237>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83238>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83239>>>>>>>>>
83239>>>>>>>>>        Move 0 to iStart
83240>>>>>>>>>        Move (Uppercase(sType)) to sType
83241>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83242>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83244>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83245>>>>>>>>>            Function_Return RetvalType
83246>>>>>>>>>        End
83246>>>>>>>>>>
83246>>>>>>>>>
83246>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83247>>>>>>>>>
83247>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83248>>>>>>>>>        Decrement iSize
83249>>>>>>>>>
83249>>>>>>>>>        For iCount from iStart to iSize
83255>>>>>>>>>>
83255>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
83256>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
83257>>>>>>>>>            If (bIntegerInputType = True) Begin
83259>>>>>>>>>                If (iValue = iType) Begin
83261>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83262>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83263>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83264>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83265>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83266>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83267>>>>>>>>>                    Move iSize to iCount // We're done!
83268>>>>>>>>>                End
83268>>>>>>>>>>
83268>>>>>>>>>            End
83268>>>>>>>>>>
83268>>>>>>>>>            Else Begin
83269>>>>>>>>>                Move (Uppercase(sValue)) to sValue
83270>>>>>>>>>                If (sValue = sType) Begin
83272>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
83273>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
83274>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83275>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83276>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83277>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83278>>>>>>>>>                    Move iSize to iCount // We're done!
83279>>>>>>>>>                End
83279>>>>>>>>>>
83279>>>>>>>>>            End
83279>>>>>>>>>>
83279>>>>>>>>>        Loop
83280>>>>>>>>>>
83280>>>>>>>>>
83280>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
83280>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
83280>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
83282>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83283>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
83284>>>>>>>>>            Decrement iSize
83285>>>>>>>>>
83285>>>>>>>>>            For iCount from iStart to iSize
83291>>>>>>>>>>
83291>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
83292>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
83293>>>>>>>>>                If (iValue = iType) Begin
83295>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83296>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83297>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83298>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83299>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83300>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83301>>>>>>>>>                    Move iSize to iCount // We're done!
83302>>>>>>>>>                End
83302>>>>>>>>>>
83302>>>>>>>>>            Loop
83303>>>>>>>>>>
83303>>>>>>>>>        End
83303>>>>>>>>>>
83303>>>>>>>>>
83303>>>>>>>>>        Function_Return RetvalType
83304>>>>>>>>>    End_Function
83305>>>>>>>>>
83305>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83305>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83307>>>>>>>>>        tColumnType[] ColumnType
83307>>>>>>>>>        tColumnType[] ColumnType
83308>>>>>>>>>
83308>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83308>>>>>>>>>        // the dbType.
83308>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83310>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83312>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83313>>>>>>>>>            End
83313>>>>>>>>>>
83313>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83315>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83316>>>>>>>>>            End
83316>>>>>>>>>>
83316>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83318>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83319>>>>>>>>>            End
83319>>>>>>>>>>
83319>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83321>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83322>>>>>>>>>            End
83322>>>>>>>>>>
83322>>>>>>>>>        End
83322>>>>>>>>>>
83322>>>>>>>>>
83322>>>>>>>>>        Case Begin
83322>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83324>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83325>>>>>>>>>                Case Break
83326>>>>>>>>>
83326>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83329>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83330>>>>>>>>>                Case Break
83331>>>>>>>>>
83331>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83334>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83335>>>>>>>>>                Case Break
83336>>>>>>>>>        Case End
83336>>>>>>>>>
83336>>>>>>>>>        Function_Return ColumnType
83337>>>>>>>>>    End_Function
83338>>>>>>>>>
83338>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83338>>>>>>>>>    // are mapped to a DUF data type.
83338>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83340>>>>>>>>>        tColumnType ColumnType
83340>>>>>>>>>        tColumnType ColumnType
83340>>>>>>>>>        String sDataType
83340>>>>>>>>>        Integer iDriverID iCount
83340>>>>>>>>>
83340>>>>>>>>>        Move 0 to iCount
83341>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83342>>>>>>>>>
83342>>>>>>>>>        Case Begin
83342>>>>>>>>>            // DF_ASCII
83342>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83344>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83346>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83349>>>>>>>>>                End
83349>>>>>>>>>>
83349>>>>>>>>>                Else Begin
83350>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83353>>>>>>>>>                End
83353>>>>>>>>>>
83353>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83354>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83355>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83356>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83357>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83358>>>>>>>>>                Case Break
83359>>>>>>>>>
83359>>>>>>>>>            // DF_BINARY
83359>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83362>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83364>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83367>>>>>>>>>                End
83367>>>>>>>>>>
83367>>>>>>>>>                Else Begin
83368>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83371>>>>>>>>>                End
83371>>>>>>>>>>
83371>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83372>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83373>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83374>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83375>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83376>>>>>>>>>                Case Break
83377>>>>>>>>>
83377>>>>>>>>>            // DF_DATE
83377>>>>>>>>>            Case (iType = DF_DATE_DUF)
83380>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83382>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83385>>>>>>>>>                End
83385>>>>>>>>>>
83385>>>>>>>>>                Else Begin
83386>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83389>>>>>>>>>                End
83389>>>>>>>>>>
83389>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83390>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83391>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83392>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83393>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83394>>>>>>>>>                Case Break
83395>>>>>>>>>
83395>>>>>>>>>            // DF_DATETIME
83395>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83398>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83400>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83403>>>>>>>>>                End
83403>>>>>>>>>>
83403>>>>>>>>>                Else Begin
83404>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83407>>>>>>>>>                End
83407>>>>>>>>>>
83407>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83408>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83409>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83410>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83411>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83412>>>>>>>>>                Case Break
83413>>>>>>>>>
83413>>>>>>>>>            // DF_NUMERIC
83413>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83413>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83413>>>>>>>>>            // we make them here all "Numeric"...
83413>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83413>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83413>>>>>>>>>            // End
83413>>>>>>>>>            // Else Begin
83413>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83413>>>>>>>>>            // End
83413>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83413>>>>>>>>>            Case (iType = DF_BCD_DUF)
83416>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83417>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83418>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83419>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83420>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83421>>>>>>>>>                Case Break
83422>>>>>>>>>
83422>>>>>>>>>            // DF_TEXT
83422>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83425>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83427>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83430>>>>>>>>>                End
83430>>>>>>>>>>
83430>>>>>>>>>                Else Begin
83431>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83434>>>>>>>>>                End
83434>>>>>>>>>>
83434>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83435>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83436>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83437>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83438>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83439>>>>>>>>>                Case Break
83440>>>>>>>>>
83440>>>>>>>>>            Case Else
83440>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83441>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83442>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83443>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83444>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83445>>>>>>>>>
83445>>>>>>>>>        Case End
83445>>>>>>>>>
83445>>>>>>>>>        Function_Return ColumnType
83446>>>>>>>>>    End_Function
83447>>>>>>>>>
83447>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83449>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83451>>>>>>>>>        Handle hTable
83451>>>>>>>>>        Integer iIndex
83451>>>>>>>>>        String sTableName
83451>>>>>>>>>        Boolean bFlexErrs
83451>>>>>>>>>
83451>>>>>>>>>        // a) Get the exception table array the developer has specified
83451>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83452>>>>>>>>>
83452>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83452>>>>>>>>>        Repeat
83452>>>>>>>>>>
83452>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83455>>>>>>>>>            If (hTable <> 0) Begin
83457>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83460>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83461>>>>>>>>>                If (bFlexErrs = False) Begin
83463>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83465>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83466>>>>>>>>>                        If (iIndex = -1) Begin
83468>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83469>>>>>>>>>                        End
83469>>>>>>>>>>
83469>>>>>>>>>                    End
83469>>>>>>>>>>
83469>>>>>>>>>                End
83469>>>>>>>>>>
83469>>>>>>>>>            End
83469>>>>>>>>>>
83469>>>>>>>>>        Until (hTable = 0)
83471>>>>>>>>>
83471>>>>>>>>>        Move 0 to hTable
83472>>>>>>>>>
83472>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83472>>>>>>>>>        Repeat
83472>>>>>>>>>>
83472>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83475>>>>>>>>>            If (hTable > 0) Begin
83477>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83480>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83481>>>>>>>>>                If (bFlexErrs = False) Begin
83483>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83484>>>>>>>>>                    If (iIndex = -1) Begin
83486>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83487>>>>>>>>>                    End
83487>>>>>>>>>>
83487>>>>>>>>>                End
83487>>>>>>>>>>
83487>>>>>>>>>            End
83487>>>>>>>>>>
83487>>>>>>>>>        Until (hTable = 0)
83489>>>>>>>>>
83489>>>>>>>>>        Function_Return iTablesArray
83490>>>>>>>>>    End_Function
83491>>>>>>>>>
83491>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83493>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83495>>>>>>>>>        Handle hTable
83495>>>>>>>>>        Integer iIndex
83495>>>>>>>>>        String sTableName
83495>>>>>>>>>        Boolean bFlexErrs
83495>>>>>>>>>
83495>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83496>>>>>>>>>        Move 0 to hTable
83497>>>>>>>>>
83497>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83497>>>>>>>>>        Repeat
83497>>>>>>>>>>
83497>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83500>>>>>>>>>            If (hTable > 0) Begin
83502>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83505>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83506>>>>>>>>>                If (bFlexErrs = False) Begin
83508>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83509>>>>>>>>>                    If (iIndex = -1) Begin
83511>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83512>>>>>>>>>                    End
83512>>>>>>>>>>
83512>>>>>>>>>                End
83512>>>>>>>>>>
83512>>>>>>>>>            End
83512>>>>>>>>>>
83512>>>>>>>>>        Until (hTable = 0)
83514>>>>>>>>>
83514>>>>>>>>>        Function_Return iTablesArray
83515>>>>>>>>>    End_Function
83516>>>>>>>>>
83516>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83518>>>>>>>>>        tAPIColumn NewAPIColumn
83518>>>>>>>>>        tAPIColumn NewAPIColumn
83518>>>>>>>>>
83518>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83519>>>>>>>>>        Move iType      to NewAPIColumn.iType
83520>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83521>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83522>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83523>>>>>>>>>
83523>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83524>>>>>>>>>
83524>>>>>>>>>        Function_Return aCurrent
83525>>>>>>>>>    End_Function
83526>>>>>>>>>
83526>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83528>>>>>>>>>        String sRetval sFieldName
83528>>>>>>>>>        Integer iCount iSize
83528>>>>>>>>>
83528>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83529>>>>>>>>>        Decrement iSize
83530>>>>>>>>>        For iCount from 0 to iSize
83536>>>>>>>>>>
83536>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83537>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83538>>>>>>>>>        Loop
83539>>>>>>>>>>
83539>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83540>>>>>>>>>
83540>>>>>>>>>        Function_Return sRetval
83541>>>>>>>>>    End_Function
83542>>>>>>>>>
83542>>>>>>>>>    // *** Miscellaneous other functions ***
83542>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83542>>>>>>>>>    //
83542>>>>>>>>>
83542>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83542>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83544>>>>>>>>>        Integer iPerc
83544>>>>>>>>>        Number nReady nTotal
83544>>>>>>>>>
83544>>>>>>>>>        Send DoAdvance of ghoProgressBar
83545>>>>>>>>>
83545>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83547>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83548>>>>>>>>>        End
83548>>>>>>>>>>
83548>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83550>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83551>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83552>>>>>>>>>        End
83552>>>>>>>>>>
83552>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83554>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83555>>>>>>>>>        End
83555>>>>>>>>>>
83555>>>>>>>>>
83555>>>>>>>>>        Case Begin
83555>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83557>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83558>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83559>>>>>>>>>                Case Break
83560>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83563>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83564>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83565>>>>>>>>>                Case Break
83566>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83569>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83570>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83571>>>>>>>>>                Case Break
83572>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83575>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83576>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83577>>>>>>>>>                Case Break
83578>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83581>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83582>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83583>>>>>>>>>                Case Break
83584>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83587>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83588>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83589>>>>>>>>>                Case Break
83590>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83593>>>>>>>>>                Send None
83594>>>>>>>>>                Case Break
83595>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83598>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83599>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83600>>>>>>>>>                Case Break
83601>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83604>>>>>>>>>                //*** Interpret numbers
83604>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83605>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83606>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83607>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83608>>>>>>>>>                Case Break
83609>>>>>>>>>            Case Else
83609>>>>>>>>>                Set Message_Text to ""
83610>>>>>>>>>                Set Action_Text  to ""
83611>>>>>>>>>        Case End
83611>>>>>>>>>
83611>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83612>>>>>>>>>        Function_Return False
83613>>>>>>>>>    End_Function
83614>>>>>>>>>
83614>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83614>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83616>>>>>>>>>        Function_Return False
83617>>>>>>>>>    End_Function
83618>>>>>>>>>
83618>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83618>>>>>>>>>    //
83618>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83618>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83618>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83618>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83618>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83618>>>>>>>>>    //   ALTER TABLE MyTable
83618>>>>>>>>>    //       REBUILD
83618>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83620>>>>>>>>>        Boolean bOK
83620>>>>>>>>>
83620>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83622>>>>>>>>>            Function_Return False
83623>>>>>>>>>        End
83623>>>>>>>>>>
83623>>>>>>>>>
83623>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83623>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83624>>>>>>>>>
83624>>>>>>>>>        Function_Return (bOK = True)
83625>>>>>>>>>    End_Function
83626>>>>>>>>>
83626>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83626>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83626>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83626>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83626>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83626>>>>>>>>>    //   ALTER TABLE MyTable
83626>>>>>>>>>    //       REBUILD
83626>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83628>>>>>>>>>        tSQLScriptArray SQLScriptArray
83628>>>>>>>>>        tSQLScriptArray SQLScriptArray
83628>>>>>>>>>        String sDriverID
83628>>>>>>>>>        Boolean bOK
83628>>>>>>>>>        Integer iSize iCount
83628>>>>>>>>>
83628>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83630>>>>>>>>>            Function_Return False
83631>>>>>>>>>        End
83631>>>>>>>>>>
83631>>>>>>>>>
83631>>>>>>>>>        Get psDriverID to sDriverID
83632>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83633>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83635>>>>>>>>>            Function_Return False
83636>>>>>>>>>        End
83636>>>>>>>>>>
83636>>>>>>>>>
83636>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83637>>>>>>>>>        Decrement iSize
83638>>>>>>>>>
83638>>>>>>>>>        For iCount from 0 to iSize
83644>>>>>>>>>>
83644>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83646>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83647>>>>>>>>>            End
83647>>>>>>>>>>
83647>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83649>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83650>>>>>>>>>            End
83650>>>>>>>>>>
83650>>>>>>>>>        Loop
83651>>>>>>>>>>
83651>>>>>>>>>
83651>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83652>>>>>>>>>
83652>>>>>>>>>        Function_Return (bOK = True)
83653>>>>>>>>>    End_Function
83654>>>>>>>>>
83654>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83654>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83654>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83654>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83656>>>>>>>>>        Integer iChannel iArgumentSize iCount
83656>>>>>>>>>        Number nByteCount
83656>>>>>>>>>        String sSQLScript
83656>>>>>>>>>        tSQLScriptArray SqlScriptArray
83656>>>>>>>>>        tSQLScriptArray SqlScriptArray
83656>>>>>>>>>        UChar[] uCharData
83657>>>>>>>>>
83657>>>>>>>>>        Move False to Err
83658>>>>>>>>>        Get Seq_New_Channel to iChannel
83659>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83661>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83662>>>>>>>>>>
83662>>>>>>>>>            Move True to SqlScriptArray.bError
83663>>>>>>>>>            Function_Return SqlScriptArray
83664>>>>>>>>>        End
83664>>>>>>>>>>
83664>>>>>>>>>
83664>>>>>>>>>        // First decide the size of the script
83664>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83666>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83668>>>>>>>>>        Close_Input channel iChannel
83670>>>>>>>>>
83670>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83671>>>>>>>>>        If (nByteCount  < 1) Begin
83673>>>>>>>>>            Send Seq_Release_Channel iChannel
83674>>>>>>>>>            Move True to SqlScriptArray.bError
83675>>>>>>>>>            Function_Return SqlScriptArray
83676>>>>>>>>>        End
83676>>>>>>>>>>
83676>>>>>>>>>
83676>>>>>>>>>        // If necessary change the string argument_size
83676>>>>>>>>>        // Read the script file from memory line-by-line
83676>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83678>>>>>>>>>            Move 0 to iCount
83679>>>>>>>>>            Repeat
83679>>>>>>>>>>
83679>>>>>>>>>                Readln channel iChannel sSQLScript
83681>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83682>>>>>>>>>                Increment iCount
83683>>>>>>>>>            Until (SeqEof = True)
83685>>>>>>>>>        Close_Input channel iChannel
83687>>>>>>>>>        Send Seq_Release_Channel iChannel
83688>>>>>>>>>
83688>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83688>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83689>>>>>>>>>
83689>>>>>>>>>        Function_Return SqlScriptArray
83690>>>>>>>>>    End_Function
83691>>>>>>>>>
83691>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83693>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83693>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83693>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83693>>>>>>>>>        String[] sMsg aSQLQueryMessages
83695>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83695>>>>>>>>>        TimeSpan tsQuery
83695>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83695>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83695>>>>>>>>>        tSQLConnection SQLConnection
83695>>>>>>>>>        tSQLConnection SQLConnection
83695>>>>>>>>>        Boolean bShowProgress
83695>>>>>>>>>
83695>>>>>>>>>        If (num_arguments > 4) Begin
83697>>>>>>>>>            Move bShowProgr to bShowProgress
83698>>>>>>>>>        End
83698>>>>>>>>>>
83698>>>>>>>>>        Get phoSQLManager to hoSql
83699>>>>>>>>>
83699>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83700>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83700>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83700>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83700>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83700>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83700>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83700>>>>>>>>>        Get piChunkMax to iChunkMax
83701>>>>>>>>>        Move 0 to iChunkCounter
83702>>>>>>>>>        Move "" to sStmt
83703>>>>>>>>>
83703>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83704>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83705>>>>>>>>>
83705>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83706>>>>>>>>>
83706>>>>>>>>>        Get phoSQLManager  to hoSQL
83707>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83709>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83711>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83712>>>>>>>>>                If (iPos > 0) Begin
83714>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83715>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83716>>>>>>>>>                End
83716>>>>>>>>>>
83716>>>>>>>>>            End
83716>>>>>>>>>>
83716>>>>>>>>>        End
83716>>>>>>>>>>
83716>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83717>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83718>>>>>>>>>
83718>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83720>>>>>>>>>            Move False to Err
83721>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83722>>>>>>>>>            If (hoStmt <> 0) Begin
83724>>>>>>>>>
83724>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83724>>>>>>>>>                If (bCreateScriptFile = True) Begin
83726>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83727>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83728>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83729>>>>>>>>>                    Get Seq_New_Channel to iOut
83730>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83732>>>>>>>>>                        Direct_Output channel iOut sExportFile
83734>>>>>>>>>                    End
83734>>>>>>>>>>
83734>>>>>>>>>                End
83734>>>>>>>>>>
83734>>>>>>>>>
83734>>>>>>>>>                // Record starting date/time stamp
83734>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83735>>>>>>>>>                // Turn on error handling if enabled
83735>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83737>>>>>>>>>                    Set pbSqlError to False
83738>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83739>>>>>>>>>                    Move Error_Object_Id to hoError
83740>>>>>>>>>                    Move Self to Error_Object_Id
83741>>>>>>>>>                End
83741>>>>>>>>>>
83741>>>>>>>>>
83741>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83742>>>>>>>>>                Decrement iRows
83743>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83745>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83746>>>>>>>>>                End
83746>>>>>>>>>>
83746>>>>>>>>>
83746>>>>>>>>>                for iCount from 0 to iRows
83752>>>>>>>>>>
83752>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83753>>>>>>>>>
83753>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83755>>>>>>>>>                        If (sSQLVal <> "") Begin
83757>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83758>>>>>>>>>                        End
83758>>>>>>>>>>
83758>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83759>>>>>>>>>                    End
83759>>>>>>>>>>
83759>>>>>>>>>
83759>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83759>>>>>>>>>                    // or if at the very end of the script.
83759>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83761>>>>>>>>>
83761>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83761>>>>>>>>>                        // instead of all in one go.
83761>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83762>>>>>>>>>
83762>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83764>>>>>>>>>                            Write channel iOut sStmt
83766>>>>>>>>>                        End
83766>>>>>>>>>>
83766>>>>>>>>>                        Move "" to sStmt
83767>>>>>>>>>                        Move 0 to iChunkCounter
83768>>>>>>>>>                    End
83768>>>>>>>>>>
83768>>>>>>>>>                    Increment iChunkCounter
83769>>>>>>>>>                Loop
83770>>>>>>>>>>
83770>>>>>>>>>
83770>>>>>>>>>                Repeat
83770>>>>>>>>>>
83770>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83772>>>>>>>>>                        Move hoError to Error_Object_Id
83773>>>>>>>>>                    End
83773>>>>>>>>>>
83773>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83774>>>>>>>>>
83774>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83775>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83776>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83777>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83778>>>>>>>>>                    Set piRows    to iRows
83779>>>>>>>>>                    Set piRowType to iRowType
83780>>>>>>>>>
83780>>>>>>>>>                    If (iMsgs <> 0) Begin
83782>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83784>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83785>>>>>>>>>                        End
83785>>>>>>>>>>
83785>>>>>>>>>                        for i from 1 to iMsgs
83791>>>>>>>>>>
83791>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83792>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83793>>>>>>>>>                            If (bShowProgress = True) Begin
83795>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83797>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83798>>>>>>>>>                                End
83798>>>>>>>>>>
83798>>>>>>>>>                                Else Begin
83799>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83801>>>>>>>>>                                End
83801>>>>>>>>>>
83801>>>>>>>>>                            End
83801>>>>>>>>>>
83801>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83802>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83803>>>>>>>>>                        Loop
83804>>>>>>>>>>
83804>>>>>>>>>
83804>>>>>>>>>
83804>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83806>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83807>>>>>>>>>                        End
83807>>>>>>>>>>
83807>>>>>>>>>                        Set paQueryMessages to sMsg
83808>>>>>>>>>                    End
83808>>>>>>>>>>
83808>>>>>>>>>
83808>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83809>>>>>>>>>                Until (iNextSet = 0)
83811>>>>>>>>>
83811>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83812>>>>>>>>>            End
83812>>>>>>>>>>
83812>>>>>>>>>
83812>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83813>>>>>>>>>            Set ptsQueryExec to tsQuery
83814>>>>>>>>>            Send SqlClose of hoStmt
83815>>>>>>>>>
83815>>>>>>>>>            If (bCreateScriptFile = True) Begin
83817>>>>>>>>>                Close_Output channel iOut
83819>>>>>>>>>                Send Seq_Release_Channel iOut
83820>>>>>>>>>            End
83820>>>>>>>>>>
83820>>>>>>>>>        End
83820>>>>>>>>>>
83820>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83821>>>>>>>>>
83821>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83822>>>>>>>>>    End_Function
83823>>>>>>>>>
83823>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83825>>>>>>>>>        tSQLScriptArray SQLScriptArray
83825>>>>>>>>>        tSQLScriptArray SQLScriptArray
83825>>>>>>>>>        String sDriverID sCollation
83825>>>>>>>>>        Boolean bOK
83825>>>>>>>>>        Integer iSize iCount
83825>>>>>>>>>
83825>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83827>>>>>>>>>            Function_Return False
83828>>>>>>>>>        End
83828>>>>>>>>>>
83828>>>>>>>>>
83828>>>>>>>>>        Get psDriverID  to sDriverID
83829>>>>>>>>>        Get psCollation to sCollation
83830>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83831>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83833>>>>>>>>>            Function_Return False
83834>>>>>>>>>        End
83834>>>>>>>>>>
83834>>>>>>>>>
83834>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83835>>>>>>>>>        Decrement iSize
83836>>>>>>>>>
83836>>>>>>>>>        For iCount from 0 to iSize
83842>>>>>>>>>>
83842>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83844>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83845>>>>>>>>>            End
83845>>>>>>>>>>
83845>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83847>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83848>>>>>>>>>            End
83848>>>>>>>>>>
83848>>>>>>>>>        Loop
83849>>>>>>>>>>
83849>>>>>>>>>
83849>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83850>>>>>>>>>
83850>>>>>>>>>        Function_Return (bOK = True)
83851>>>>>>>>>    End_Function
83852>>>>>>>>>
83852>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83854>>>>>>>>>        tSQLScriptArray SQLScriptArray
83854>>>>>>>>>        tSQLScriptArray SQLScriptArray
83854>>>>>>>>>        String sDriverID sCollation
83854>>>>>>>>>        Boolean bOK
83854>>>>>>>>>        Integer iSize iCount
83854>>>>>>>>>
83854>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83856>>>>>>>>>            Function_Return False
83857>>>>>>>>>        End
83857>>>>>>>>>>
83857>>>>>>>>>
83857>>>>>>>>>        Get psDriverID  to sDriverID
83858>>>>>>>>>        Get psCollation to sCollation
83859>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83860>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83862>>>>>>>>>            Function_Return False
83863>>>>>>>>>        End
83863>>>>>>>>>>
83863>>>>>>>>>
83863>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83864>>>>>>>>>        Decrement iSize
83865>>>>>>>>>
83865>>>>>>>>>        For iCount from 0 to iSize
83871>>>>>>>>>>
83871>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83873>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83874>>>>>>>>>            End
83874>>>>>>>>>>
83874>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83876>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83877>>>>>>>>>            End
83877>>>>>>>>>>
83877>>>>>>>>>        Loop
83878>>>>>>>>>>
83878>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83878>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83879>>>>>>>>>
83879>>>>>>>>>        Function_Return (bOK = True)
83880>>>>>>>>>    End_Function
83881>>>>>>>>>
83881>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83883>>>>>>>>>        Integer iMax iPos
83883>>>>>>>>>        String sName
83883>>>>>>>>>
83883>>>>>>>>>        Move (Lowercase(sField)) to sField
83884>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83887>>>>>>>>>        For iPos from 0 to iMax
83893>>>>>>>>>>
83893>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83896>>>>>>>>>            Move (Lowercase(sName)) to sName
83897>>>>>>>>>            If (sName = sField) Begin
83899>>>>>>>>>                Function_Return iPos
83900>>>>>>>>>            End
83900>>>>>>>>>>
83900>>>>>>>>>        Loop
83901>>>>>>>>>>
83901>>>>>>>>>        Function_Return -1
83902>>>>>>>>>    End_Function
83903>>>>>>>>>
83903>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
83903>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
83903>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83903>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
83903>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83905>>>>>>>>>        String sID sConnString
83905>>>>>>>>>        Integer iDriver iNumConn iCount
83905>>>>>>>>>        Handle hoCLI
83905>>>>>>>>>        Boolean bOK
83905>>>>>>>>>
83905>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83906>>>>>>>>>        If (bOK = False) Begin
83908>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83909>>>>>>>>>>
83909>>>>>>>>>            Function_Return False
83910>>>>>>>>>        End
83910>>>>>>>>>>
83910>>>>>>>>>
83910>>>>>>>>>        Move False to bOK
83911>>>>>>>>>        Get phoCLIHandler to hoCLI
83912>>>>>>>>>        If (hoCLI <> 0) Begin
83914>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83915>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83916>>>>>>>>>
83916>>>>>>>>>            // If driver not loaded; load it.
83916>>>>>>>>>            If (iDriver = 0) Begin
83918>>>>>>>>>                Load_Driver sDriverID
83919>>>>>>>>>                Get DriverIndex sDriverID to iDriver
83920>>>>>>>>>            End
83920>>>>>>>>>>
83920>>>>>>>>>            If (iDriver <> 0) Begin
83922>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83925>>>>>>>>>                Decrement iNumConn
83926>>>>>>>>>                For iCount from 0 to iNumConn
83932>>>>>>>>>>
83932>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83935>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83938>>>>>>>>>                    If (sID = sConnectionID) Begin
83940>>>>>>>>>                        Move True to bOK
83941>>>>>>>>>                    End
83941>>>>>>>>>>
83941>>>>>>>>>                Loop
83942>>>>>>>>>>
83942>>>>>>>>>            End
83942>>>>>>>>>>
83942>>>>>>>>>        End
83942>>>>>>>>>>
83942>>>>>>>>>
83942>>>>>>>>>        Function_Return bOK
83943>>>>>>>>>    End_Function
83944>>>>>>>>>
83944>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83946>>>>>>>>>        Boolean bOK
83946>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
83947>>>>>>>>>        Function_Return bOK
83948>>>>>>>>>    End_Function
83949>>>>>>>>>
83949>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
83951>>>>>>>>>        Integer iDriverIndex
83951>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
83952>>>>>>>>>        Function_Return (iDriverIndex <> 0)
83953>>>>>>>>>    End_Function
83954>>>>>>>>>
83954>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83954>>>>>>>>>    // attempt to load the driver.
83954>>>>>>>>>    // Returns true if the passed driver is SQL based.
83954>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83956>>>>>>>>>        Boolean bOK
83956>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83957>>>>>>>>>        Function_Return bOK
83958>>>>>>>>>    End_Function
83959>>>>>>>>>
83959>>>>>>>>>    // *** Error Handler ***
83959>>>>>>>>>    //
83959>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
83959>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
83959>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
83961>>>>>>>>>        Integer iSize iErrorMode
83961>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83961>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83961>>>>>>>>>
83961>>>>>>>>>        If (pbProcessingError(Self)) Begin
83963>>>>>>>>>            Procedure_Return
83964>>>>>>>>>        End
83964>>>>>>>>>>
83964>>>>>>>>>
83964>>>>>>>>>        Get Error_Report_Mode to iErrorMode
83965>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
83967>>>>>>>>>            Procedure_Return
83968>>>>>>>>>        End
83968>>>>>>>>>>
83968>>>>>>>>>
83968>>>>>>>>>        Set pbProcessingError to True
83969>>>>>>>>>        Set pbSqlError to True
83970>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
83971>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
83972>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
83973>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
83974>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
83975>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
83976>>>>>>>>>        Set pbProcessingError to False
83977>>>>>>>>>    End_Procedure
83978>>>>>>>>>
83978>>>>>>>>>    // *** Miscellanous Helper Functions ***
83978>>>>>>>>>    //
83978>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
83978>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
83978>>>>>>>>>    Function _TableNameOnly String sName Returns String
83980>>>>>>>>>        String sPath sExt
83980>>>>>>>>>
83980>>>>>>>>>        Get ParseFolderName sName to sPath
83981>>>>>>>>>        If (sPath <> "") Begin
83983>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
83984>>>>>>>>>        End
83984>>>>>>>>>>
83984>>>>>>>>>        Get ParseFileExtension sName to sExt
83985>>>>>>>>>        If (sExt <> "") Begin
83987>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
83988>>>>>>>>>        End
83988>>>>>>>>>>
83988>>>>>>>>>
83988>>>>>>>>>        Function_Return sName
83989>>>>>>>>>    End_Function
83990>>>>>>>>>
83990>>>>>>>>>    // Removes any prefix to a table name.
83990>>>>>>>>>    // Example mssqldrv:mytable returns mytable
83990>>>>>>>>>    //         dbo.mytable returns mytable
83990>>>>>>>>>    Function _TableNoPrefix String sName Returns String
83992>>>>>>>>>        Integer iPos
83992>>>>>>>>>
83992>>>>>>>>>        Move (Pos(":", sName)) to iPos
83993>>>>>>>>>        If (iPos <> 0) Begin
83995>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83996>>>>>>>>>        End
83996>>>>>>>>>>
83996>>>>>>>>>        Move (Pos(".", sName)) to iPos
83997>>>>>>>>>        If (iPos <> 0) Begin
83999>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84000>>>>>>>>>        End
84000>>>>>>>>>>
84000>>>>>>>>>
84000>>>>>>>>>        Function_Return sName
84001>>>>>>>>>    End_Function
84002>>>>>>>>>
84002>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84002>>>>>>>>>    // The returned path always ends with a "\"
84002>>>>>>>>>    Function psDataPathFirstPart Returns String
84004>>>>>>>>>        String sDataPath
84004>>>>>>>>>        Integer iCount
84004>>>>>>>>>
84004>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84005>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84006>>>>>>>>>        If (iCount > 1) Begin
84008>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84009>>>>>>>>>        End
84009>>>>>>>>>>
84009>>>>>>>>>        If (sDataPath <> "") Begin
84011>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84012>>>>>>>>>        End
84012>>>>>>>>>>
84012>>>>>>>>>
84012>>>>>>>>>        Function_Return sDataPath
84013>>>>>>>>>    End_Function
84014>>>>>>>>>
84014>>>>>>>>>    Function psLogTextFileWithPath Returns String
84016>>>>>>>>>        String sFileName
84016>>>>>>>>>        Handle hoLogFile
84016>>>>>>>>>        Get phoLogFile to hoLogFile
84017>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84018>>>>>>>>>        Function_Return sFileName
84019>>>>>>>>>    End_Function
84020>>>>>>>>>
84020>>>>>>>>>    Function phoLogFile Returns Handle
84022>>>>>>>>>        Handle hoLogFile   
84022>>>>>>>>>        Boolean bErr
84022>>>>>>>>>        
84022>>>>>>>>>        Move Err to bErr
84023>>>>>>>>>        Move 0 to hoLogFile
84024>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84025>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84026>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84028>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84029>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84030>>>>>>>>>        Move bErr to Err
84031>>>>>>>>>        
84031>>>>>>>>>        Function_Return hoLogFile
84032>>>>>>>>>    End_Function
84033>>>>>>>>>
84033>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84035>>>>>>>>>        Number nCurrentVersionUpdate
84035>>>>>>>>>
84035>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84036>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84038>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84039>>>>>>>>>
84039>>>>>>>>>        Function_Return nCurrentVersionUpdate
84040>>>>>>>>>    End_Function
84041>>>>>>>>>
84041>>>>>>>>>    Procedure LogError String sText Boolean bError
84043>>>>>>>>>        Handle hoLogFile
84043>>>>>>>>>        Number nCurrentVersionUpdate
84043>>>>>>>>>
84043>>>>>>>>>        Get phoLogFile to hoLogFile
84044>>>>>>>>>        If (hoLogFile = 0) Begin
84046>>>>>>>>>            Procedure_Return
84047>>>>>>>>>        End
84047>>>>>>>>>>
84047>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84048>>>>>>>>>
84048>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84049>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84050>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84051>>>>>>>>>    End_Procedure
84052>>>>>>>>>
84052>>>>>>>>>    Function pbContinueOnError Returns Boolean
84054>>>>>>>>>        Boolean bContinueOnError
84054>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84056>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84057>>>>>>>>>        End
84057>>>>>>>>>>
84057>>>>>>>>>        Function_Return bContinueOnError
84058>>>>>>>>>    End_Function
84059>>>>>>>>>
84059>>>>>>>>>
84059>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84061>>>>>>>>>        Integer iChIn iChOut // iCount
84061>>>>>>>>>        Boolean bExists
84061>>>>>>>>>        String sExistingColumn
84061>>>>>>>>>
84061>>>>>>>>>        Move False to bExists
84062>>>>>>>>>        Get Seq_New_Channel to iChIn
84063>>>>>>>>>        Get Seq_New_Channel to iChOut
84064>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84066>>>>>>>>>            Function_Return True
84067>>>>>>>>>        End
84067>>>>>>>>>>
84067>>>>>>>>>
84067>>>>>>>>>        Move False to Err
84068>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84068>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84070>>>>>>>>>        While (not(SeqEof))
84074>>>>>>>>>            Readln channel iChIn sExistingColumn
84076>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84078>>>>>>>>>                Move True to bExists
84079>>>>>>>>>            End
84079>>>>>>>>>>
84079>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84081>>>>>>>>>                Move True to SeqEof
84082>>>>>>>>>            End
84082>>>>>>>>>>
84082>>>>>>>>>        Loop
84083>>>>>>>>>>
84083>>>>>>>>>        Close_Input channel iChIn
84085>>>>>>>>>        Send Seq_Release_Channel iChIn
84086>>>>>>>>>
84086>>>>>>>>>        If (bExists = False) Begin
84088>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84090>>>>>>>>>            Writeln channel iChOut sColumnName
84093>>>>>>>>>            Close_Output channel iChOut
84095>>>>>>>>>            Send Seq_Release_Channel iChOut
84096>>>>>>>>>        End
84096>>>>>>>>>>
84096>>>>>>>>>
84096>>>>>>>>>        Function_Return (Err = False)
84097>>>>>>>>>    End_Function
84098>>>>>>>>>
84098>>>>>>>>>    // Changes source code files.
84098>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84098>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84098>>>>>>>>>    // to use a Connection ID.
84098>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84098>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84098>>>>>>>>>    // Returns True if no errors occured.
84098>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84100>>>>>>>>>        Integer iCh iRow iItems iCount
84100>>>>>>>>>        String sValue sRow
84100>>>>>>>>>        String[] sFileArray
84101>>>>>>>>>        Boolean bExists bIsActive
84101>>>>>>>>>
84101>>>>>>>>>        Move False to Err
84102>>>>>>>>>        Move 0 to iRow
84103>>>>>>>>>
84103>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84105>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84106>>>>>>>>>        End
84106>>>>>>>>>>
84106>>>>>>>>>
84106>>>>>>>>>        Get vFilePathExists sFileName to bExists
84107>>>>>>>>>        If (bExists = False) Begin
84109>>>>>>>>>            If (bShowResult = True) Begin
84111>>>>>>>>>                If (bIsActive = True) Begin
84113>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84114>>>>>>>>>                End
84114>>>>>>>>>>
84114>>>>>>>>>                Else Begin
84115>>>>>>>>>                    Showln "File does not exist: " sFileName
84118>>>>>>>>>                End
84118>>>>>>>>>>
84118>>>>>>>>>            End
84118>>>>>>>>>>
84118>>>>>>>>>            Function_Return False
84119>>>>>>>>>        End
84119>>>>>>>>>>
84119>>>>>>>>>
84119>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84120>>>>>>>>>        If (iCh < 1) Begin
84122>>>>>>>>>            Function_Return False
84123>>>>>>>>>        End
84123>>>>>>>>>>
84123>>>>>>>>>
84123>>>>>>>>>        If (bShowResult = True) Begin
84125>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84127>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84128>>>>>>>>>                If (bIsActive = True) Begin
84130>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84131>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84132>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84133>>>>>>>>>                End
84133>>>>>>>>>>
84133>>>>>>>>>            End
84133>>>>>>>>>>
84133>>>>>>>>>            Else Begin
84134>>>>>>>>>                Showln ""
84136>>>>>>>>>                Showln "sFileName = " sFileName
84139>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84144>>>>>>>>>            End
84144>>>>>>>>>>
84144>>>>>>>>>        End
84144>>>>>>>>>>
84144>>>>>>>>>
84144>>>>>>>>>        While (not(SeqEof))
84148>>>>>>>>>            Readln channel iCh sRow
84150>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84152>>>>>>>>>//                If (bShowResult = True) Begin
84152>>>>>>>>>//                    If (bIsActive = True) Begin
84152>>>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
84152>>>>>>>>>//                    End
84152>>>>>>>>>//                    Else Begin
84152>>>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
84152>>>>>>>>>//                    End
84152>>>>>>>>>//                End
84152>>>>>>>>>                // Change the whole line to the new connection id:
84152>>>>>>>>>                Move sChangeTo to sRow
84153>>>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
84153>>>>>>>>>            End
84153>>>>>>>>>>
84153>>>>>>>>>            Move sRow to sFileArray[iRow]
84154>>>>>>>>>            Increment iRow
84155>>>>>>>>>        Loop
84156>>>>>>>>>>
84156>>>>>>>>>        Send Seq_Close_Channel iCh
84157>>>>>>>>>
84157>>>>>>>>>        Sleep 1 // Wait for Windows to close the file
84158>>>>>>>>>
84158>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84159>>>>>>>>>        If (iCh < 1) Begin
84161>>>>>>>>>            Function_Return False
84162>>>>>>>>>        End
84162>>>>>>>>>>
84162>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84163>>>>>>>>>        Decrement iItems
84164>>>>>>>>>
84164>>>>>>>>>        for iCount from 0 to iItems
84170>>>>>>>>>>
84170>>>>>>>>>            Move sFileArray[iCount] to sValue
84171>>>>>>>>>            Writeln channel iCh sValue
84174>>>>>>>>>        Loop
84175>>>>>>>>>>
84175>>>>>>>>>        Send Seq_Close_Channel iCh
84176>>>>>>>>>
84176>>>>>>>>>        Function_Return (Err = False)
84177>>>>>>>>>    End_Function
84178>>>>>>>>>
84178>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84178>>>>>>>>>    // and opens it in "notepad.exe".
84178>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84178>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84178>>>>>>>>>    Procedure _UtilShowErrorList
84180>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84180>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84180>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84180>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84180>>>>>>>>>
84180>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84181>>>>>>>>>        Get vFolderFormat sPath to sPath
84182>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84183>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84184>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84185>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84186>>>>>>>>>            If (iRows > 0) Begin
84188>>>>>>>>>                Decrement iRows
84189>>>>>>>>>                for iCount from 0 to iRows
84195>>>>>>>>>>
84195>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84196>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84197>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84198>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84204>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84208>>>>>>>>>                Loop
84209>>>>>>>>>>
84209>>>>>>>>>            End
84209>>>>>>>>>>
84209>>>>>>>>>        Send Seq_Close_Channel iCh
84210>>>>>>>>>
84210>>>>>>>>>        If (iRows > 0) Begin
84212>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84213>>>>>>>>>        End
84213>>>>>>>>>>
84213>>>>>>>>>    End_Procedure
84214>>>>>>>>>
84214>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84214>>>>>>>>>    // and the table needs to exist as an SQL table.
84214>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84216>>>>>>>>>        String sRootName sDriverID
84216>>>>>>>>>        Boolean bIsSQL
84216>>>>>>>>>
84216>>>>>>>>>        Move False to bIsSQL
84217>>>>>>>>>        If (hTable > 0) Begin
84219>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84222>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84223>>>>>>>>>            If (bIsSQL = True) Begin
84225>>>>>>>>>                Get psDriverID to sDriverID
84226>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84227>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84228>>>>>>>>>            End
84228>>>>>>>>>>
84228>>>>>>>>>        End
84228>>>>>>>>>>
84228>>>>>>>>>
84228>>>>>>>>>        Function_Return bIsSQL
84229>>>>>>>>>    End_Function
84230>>>>>>>>>
84230>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84232>>>>>>>>>        Boolean bIsSQL
84232>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84233>>>>>>>>>        Function_Return bIsSQL
84234>>>>>>>>>    End_Function
84235>>>>>>>>>
84235>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84235>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84237>>>>>>>>>        String sDatabase sSchema sVal
84237>>>>>>>>>        Boolean bExists
84237>>>>>>>>>        String[] sTablesArray
84238>>>>>>>>>        Integer iSize iCount
84238>>>>>>>>>
84238>>>>>>>>>        Move False to bExists
84239>>>>>>>>>        Get psDatabase to sDatabase
84240>>>>>>>>>        Get psSchema   to sSchema
84241>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84242>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
84243>>>>>>>>>        Decrement iSize
84244>>>>>>>>>        for iCount from 0 to iSize
84250>>>>>>>>>>
84250>>>>>>>>>            Move sTablesArray[iCount] to sVal
84251>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
84253>>>>>>>>>                Move True to bExists
84254>>>>>>>>>                Move iSize to iCount // We're done!
84255>>>>>>>>>            End
84255>>>>>>>>>>
84255>>>>>>>>>        Loop
84256>>>>>>>>>>
84256>>>>>>>>>
84256>>>>>>>>>        Function_Return bExists
84257>>>>>>>>>    End_Function
84258>>>>>>>>>
84258>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84258>>>>>>>>>    // that the embedded .dat file exists on disk.
84258>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84260>>>>>>>>>        Boolean bExists bIsEmbedded
84260>>>>>>>>>        String sDataPath sRootName
84260>>>>>>>>>
84260>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84261>>>>>>>>>        If (bExists = False) Begin
84263>>>>>>>>>            Function_Return False
84264>>>>>>>>>        End
84264>>>>>>>>>>
84264>>>>>>>>>
84264>>>>>>>>>        Move False to bIsEmbedded
84265>>>>>>>>>        If (hTable > 0) Begin
84267>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84270>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84271>>>>>>>>>        End
84271>>>>>>>>>>
84271>>>>>>>>>        If (bIsEmbedded = True) Begin
84273>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84274>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84275>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84276>>>>>>>>>        End
84276>>>>>>>>>>
84276>>>>>>>>>
84276>>>>>>>>>        Function_Return bIsEmbedded
84277>>>>>>>>>    End_Function
84278>>>>>>>>>
84278>>>>>>>>>End_Class
84279>>>>>>>
84279>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84280>>>>>>>
84280>>>>>>>    Procedure Construct_Object
84282>>>>>>>        Forward Send Construct_Object
84284>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84285>>>>>>>    End_Procedure
84286>>>>>>>
84286>>>>>>>    Procedure End_Construct_Object
84288>>>>>>>        Forward Send End_Construct_Object
84290>>>>>>>    End_Procedure
84291>>>>>>>
84291>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84291>>>>>>>    //
84291>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84291>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84293>>>>>>>        Function_Return False
84294>>>>>>>    End_Function
84295>>>>>>>
84295>>>>>>>    // Function for creating a new *Database*.
84295>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84295>>>>>>>    // Returns True if successful.
84295>>>>>>>    // ToDo: Currently only works for MS-SQL...
84295>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84297>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84297>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84297>>>>>>>        Handle hConnection hStmt hoSQLManager
84297>>>>>>>        Integer iFetchResult iDbType
84297>>>>>>>        Boolean bOK bExists
84297>>>>>>>
84297>>>>>>>        Get piDbType to iDbType
84298>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84300>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84301>>>>>>>>
84301>>>>>>>            Function_Return False
84302>>>>>>>        End
84302>>>>>>>>
84302>>>>>>>
84302>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84303>>>>>>>        If (bExists = True) Begin
84305>>>>>>>            Function_Return True
84306>>>>>>>        End
84306>>>>>>>>
84306>>>>>>>
84306>>>>>>>        Get phoSQLManager to hoSQLManager
84307>>>>>>>
84307>>>>>>>        Get psConnectionID     to sConnectionID
84308>>>>>>>        Get psConnectionString to sConnectionString
84309>>>>>>>        Move 0 to LastErr
84310>>>>>>>
84310>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84312>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84312>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84312>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84312>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84312>>>>>>>//                If (iPos > 0) Begin
84312>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84312>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84312>>>>>>>//                End
84312>>>>>>>//            End
84312>>>>>>>        End
84312>>>>>>>>
84312>>>>>>>
84312>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84313>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84314>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84315>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84317>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84318>>>>>>>>
84318>>>>>>>            Function_Return False
84319>>>>>>>        End
84319>>>>>>>>
84319>>>>>>>
84319>>>>>>>        Get SqlOpen of hConnection to hStmt
84320>>>>>>>
84320>>>>>>>        If (hStmt = 0) Begin
84322>>>>>>>            Send SqlDisconnect of hoSQLManager
84323>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84324>>>>>>>>
84324>>>>>>>            Function_Return False
84325>>>>>>>        End
84325>>>>>>>>
84325>>>>>>>
84325>>>>>>>        Get psCollation to sCollation
84326>>>>>>>
84326>>>>>>>        Case Begin
84326>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84328>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84329>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84330>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84331>>>>>>>
84331>>>>>>>                // Check if database exists
84331>>>>>>>                Send SqlExecDirect of hStmt sSQL
84332>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84333>>>>>>>                Send SqlClose of hStmt
84334>>>>>>>                Send SqlDisconnect of hConnection
84335>>>>>>>                // If database already exists we're out of here!
84335>>>>>>>                // Note that we return True as this is not an error.
84335>>>>>>>                If (iFetchResult > 0) Begin
84337>>>>>>>                    Function_Return True
84338>>>>>>>                End
84338>>>>>>>>
84338>>>>>>>                // Database doesn't exist, create it.
84338>>>>>>>                If (iFetchResult = 0) Begin
84340>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84341>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84342>>>>>>>                    If (sCollation <> "") Begin
84344>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84345>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84346>>>>>>>                    End
84346>>>>>>>>
84346>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84347>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84348>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84350>>>>>>>                        Function_Return False
84351>>>>>>>                    End
84351>>>>>>>>
84351>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84351>>>>>>>                    Sleep 1
84352>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84353>>>>>>>                End
84353>>>>>>>>
84353>>>>>>>                Case Break
84354>>>>>>>
84354>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84357>>>>>>>                // ToDo: How should this be set/checked?
84357>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84357>>>>>>>//                    Set psCollation to "utf8"
84357>>>>>>>//                End
84357>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84357>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84358>>>>>>>                Case Break
84359>>>>>>>
84359>>>>>>>            Case Else
84359>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84360>>>>>>>>
84360>>>>>>>        Case End
84360>>>>>>>
84360>>>>>>>        If (Err = False) Begin
84362>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84363>>>>>>>        End
84363>>>>>>>>
84363>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84363>>>>>>>        // the one we just created.
84363>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84365>>>>>>>            Set psDatabase to sDatabase
84366>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84366>>>>>>>            If (bPermanantly = True) Begin
84368>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84370>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84371>>>>>>>                End
84371>>>>>>>>
84371>>>>>>>            End
84371>>>>>>>>
84371>>>>>>>        End
84371>>>>>>>>
84371>>>>>>>
84371>>>>>>>        Function_Return (Err = False)
84372>>>>>>>    End_Function
84373>>>>>>>
84373>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84373>>>>>>>    // will be used.
84373>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84375>>>>>>>        Boolean bOK bExists bShowProgress bErr
84375>>>>>>>        String sStatement sDriverID
84375>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84375>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84375>>>>>>>        Integer iDbType
84375>>>>>>>
84375>>>>>>>        If (sDatabase = "") Begin
84377>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84378>>>>>>>>
84378>>>>>>>            Function_Return False
84379>>>>>>>        End
84379>>>>>>>>
84379>>>>>>>        If (sBackupName = "") Begin
84381>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84382>>>>>>>>
84382>>>>>>>            Function_Return False
84383>>>>>>>        End
84383>>>>>>>>
84383>>>>>>>
84383>>>>>>>        // Create backup-folder if it doesn't exist
84383>>>>>>>        Get vFolderExists sPath to bExists
84384>>>>>>>        If (bExists = False) Begin
84386>>>>>>>            Get vCreateDirectory sPath to bErr
84387>>>>>>>            If (bErr = True) Begin
84389>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84390>>>>>>>>
84390>>>>>>>                Function_Return False
84391>>>>>>>            End
84391>>>>>>>>
84391>>>>>>>        End
84391>>>>>>>>
84391>>>>>>>        // Make sure the path ends with a back-slash
84391>>>>>>>        If (sPath <> "") Begin
84393>>>>>>>            Get vFolderFormat sPath to sPath
84394>>>>>>>        End
84394>>>>>>>>
84394>>>>>>>
84394>>>>>>>        Get psDriverID to sDriverID
84395>>>>>>>        Get piDbType   to iDbType
84396>>>>>>>        If (num_arguments > 3) Begin
84398>>>>>>>            Move bShowProg to bShowProgress
84399>>>>>>>        End
84399>>>>>>>>
84399>>>>>>>
84399>>>>>>>        Case Begin
84399>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84401>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84401>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84401>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84402>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84403>>>>>>>
84403>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84404>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84405>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84406>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84407>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84408>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84409>>>>>>>                Case Break
84410>>>>>>>            Case Else
84410>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84411>>>>>>>        Case End
84411>>>>>>>
84411>>>>>>>        Function_Return bOK
84412>>>>>>>    End_Function
84413>>>>>>>
84413>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84415>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84415>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84415>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84415>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84415>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84415>>>>>>>        tSQLConnection SQLConnection
84415>>>>>>>        tSQLConnection SQLConnection
84415>>>>>>>
84415>>>>>>>        If (sDatabase = "") Begin
84417>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84418>>>>>>>>
84418>>>>>>>            Function_Return ""
84419>>>>>>>        End
84419>>>>>>>>
84419>>>>>>>
84419>>>>>>>        Move "" to sRetval
84420>>>>>>>        Get psDriverID to sDriverID
84421>>>>>>>        Get piDbType   to iDbType
84422>>>>>>>
84422>>>>>>>        Case Begin
84422>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84424>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84424>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84425>>>>>>>
84425>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84426>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84427>>>>>>>                Get phoSQLManager to hoSQLHandler
84428>>>>>>>
84428>>>>>>>                If (hoSQLHandler <> 0) Begin
84430>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84431>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84432>>>>>>>
84432>>>>>>>                    If (hoSQLConnect <> 0) Begin
84434>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84435>>>>>>>                        If (hstmt <> 0) Begin
84437>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84438>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84439>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84440>>>>>>>                            If (iFetchResult <> 0) Begin
84442>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84443>>>>>>>                            End
84443>>>>>>>>
84443>>>>>>>                            Send SQLClose of hstmt
84444>>>>>>>                        End
84444>>>>>>>>
84444>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84445>>>>>>>                    End
84445>>>>>>>>
84445>>>>>>>                End
84445>>>>>>>>
84445>>>>>>>                Case Break
84446>>>>>>>            Case Else
84446>>>>>>>                If (bSilent = False) Begin
84448>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84449>>>>>>>                End
84449>>>>>>>>
84449>>>>>>>        Case End
84449>>>>>>>
84449>>>>>>>        Function_Return sRetval
84450>>>>>>>    End_Function
84451>>>>>>>
84451>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84453>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84453>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84453>>>>>>>        Handle hConnection hStmt hoSQLManager
84453>>>>>>>        Integer iDbType // iFetchResult
84453>>>>>>>
84453>>>>>>>        If (sDatabase = "") Begin
84455>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84456>>>>>>>>
84456>>>>>>>            Function_Return False
84457>>>>>>>        End
84457>>>>>>>>
84457>>>>>>>
84457>>>>>>>        If (sSQLCollation = "") Begin
84459>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84460>>>>>>>>
84460>>>>>>>            Function_Return False
84461>>>>>>>        End
84461>>>>>>>>
84461>>>>>>>
84461>>>>>>>        Get psDriverID to sDriverID
84462>>>>>>>        Get piDbType   to iDbType
84463>>>>>>>
84463>>>>>>>        Get phoSQLManager to hoSQLManager
84464>>>>>>>        Get psConnectionID     to sConnectionID
84465>>>>>>>        Get psConnectionString to sConnectionString
84466>>>>>>>        Move 0 to LastErr
84467>>>>>>>
84467>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84468>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84469>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84470>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84472>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84473>>>>>>>>
84473>>>>>>>            Function_Return False
84474>>>>>>>        End
84474>>>>>>>>
84474>>>>>>>
84474>>>>>>>        Get SqlOpen of hConnection to hStmt
84475>>>>>>>
84475>>>>>>>        If (hStmt = 0) Begin
84477>>>>>>>            Send SqlDisconnect of hoSQLManager
84478>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84479>>>>>>>>
84479>>>>>>>            Function_Return False
84480>>>>>>>        End
84480>>>>>>>>
84480>>>>>>>
84480>>>>>>>        // Check if collation already exists
84480>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84481>>>>>>>        // If the current collate is the same as the new; do nothing.
84481>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84483>>>>>>>            Function_Return True
84484>>>>>>>        End
84484>>>>>>>>
84484>>>>>>>
84484>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84485>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84486>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84487>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84488>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84489>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84490>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84491>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84492>>>>>>>
84492>>>>>>>        // MS-SQL Syntax:
84492>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84492>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84492>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84492>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84493>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84494>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84495>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84495>>>>>>>
84495>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84496>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84497>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84498>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84500>>>>>>>           Function_Return False
84501>>>>>>>        End
84501>>>>>>>>
84501>>>>>>>
84501>>>>>>>        Function_Return (Err = False)
84502>>>>>>>    End_Function
84503>>>>>>>
84503>>>>>>>
84503>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84503>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84505>>>>>>>        Function_Return False
84506>>>>>>>    End_Function
84507>>>>>>>
84507>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84507>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84507>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84507>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84507>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84507>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84509>>>>>>>        Handle hToTable
84509>>>>>>>        Boolean bOK bExists bOpened bCopyData
84509>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84509>>>>>>>        tSQLConnection SQLConnection
84509>>>>>>>        tSQLConnection SQLConnection
84509>>>>>>>        Integer iPos iMaxRecords
84509>>>>>>>
84509>>>>>>>        Get psDriverID to sDriverID
84510>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84511>>>>>>>        If (bExists = False) Begin
84513>>>>>>>            Function_Return False
84514>>>>>>>        End
84514>>>>>>>>
84514>>>>>>>
84514>>>>>>>        If (num_arguments > 1) Begin
84516>>>>>>>            Move bCpyDat to bCopyData
84517>>>>>>>        End
84517>>>>>>>>
84517>>>>>>>        Else Begin
84518>>>>>>>            Move False to bCopyData
84519>>>>>>>        End
84519>>>>>>>>
84519>>>>>>>
84519>>>>>>>        Open hTable
84521>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84524>>>>>>>        If (bOpened = False) Begin
84526>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84527>>>>>>>>
84527>>>>>>>            Function_Return False
84528>>>>>>>        End
84528>>>>>>>>
84528>>>>>>>        Move 0 to hToTable
84529>>>>>>>
84529>>>>>>>        Move 16711679 to iMaxRecords
84530>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84533>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84534>>>>>>>        If (iPos > 0) Begin
84536>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84537>>>>>>>        End
84537>>>>>>>>
84537>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84540>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84541>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84542>>>>>>>
84542>>>>>>>        If (ghoProgressBar <> 0) Begin
84544>>>>>>>            Send DoAdvance of ghoProgressBar
84545>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84546>>>>>>>        End
84546>>>>>>>>
84546>>>>>>>
84546>>>>>>>        Move False to Err
84547>>>>>>>
84547>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84548>>>>>>>            Structure_Copy hTable to hToTable
84549>>>>>>>
84549>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84552>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84555>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84558>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84561>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84564>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84565>>>>>>>
84565>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84567>>>>>>>
84567>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84568>>>>>>>        Move (not(Err)) to bOK
84569>>>>>>>        If (bOK = True and bCopyData = True) Begin
84571>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84572>>>>>>>        End
84572>>>>>>>>
84572>>>>>>>
84572>>>>>>>        // This must be after copying data...
84572>>>>>>>        If (Err = False) Begin
84574>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84577>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84580>>>>>>>        End
84580>>>>>>>>
84580>>>>>>>        Move (not(Err)) to bOK
84581>>>>>>>
84581>>>>>>>        Function_Return (bOK = True)
84582>>>>>>>    End_Function
84583>>>>>>>
84583>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84583>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84583>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84585>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84585>>>>>>>        Integer iDbType
84585>>>>>>>        Boolean bExists
84585>>>>>>>
84585>>>>>>>        Get psDriverID to sDriverID
84586>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84587>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84588>>>>>>>        If (bExists = True) Begin
84590>>>>>>>            Function_Return False
84591>>>>>>>        End
84591>>>>>>>>
84591>>>>>>>
84591>>>>>>>        Get psDataPathFirstPart to sPath
84592>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84593>>>>>>>
84593>>>>>>>        Get piDbType to iDbType
84594>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84595>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84596>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84597>>>>>>>
84597>>>>>>>        Move False to Err
84598>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84599>>>>>>>
84599>>>>>>>        Function_Return (Err = False)
84600>>>>>>>    End_Function
84601>>>>>>>
84601>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84601>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84601>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84603>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84603>>>>>>>        Integer iDbType
84603>>>>>>>        Boolean bExists
84603>>>>>>>
84603>>>>>>>        Get psDriverID to sDriverID
84604>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84605>>>>>>>        If (bExists = True) Begin
84607>>>>>>>            Function_Return False
84608>>>>>>>        End
84608>>>>>>>>
84608>>>>>>>
84608>>>>>>>        Get psDataPathFirstPart to sPath
84609>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84610>>>>>>>        If (bExists = True) Begin
84612>>>>>>>            // ToDo: What should we do if an .int file already exists?
84612>>>>>>>        End
84612>>>>>>>>
84612>>>>>>>
84612>>>>>>>        Get piDbType to iDbType
84613>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84614>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84615>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84616>>>>>>>
84616>>>>>>>        Move False to Err
84617>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84618>>>>>>>
84618>>>>>>>        Function_Return (Err = False)
84619>>>>>>>    End_Function
84620>>>>>>>    
84620>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
84620>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
84620>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84622>>>>>>>        Boolean bOK                                                            
84622>>>>>>>        String sStatement
84622>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84623>>>>>>>        Function_Return bOK
84624>>>>>>>    End_Function
84625>>>>>>>    
84625>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84625>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84625>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84625>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
84627>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84627>>>>>>>        Integer iRetval iDbType
84627>>>>>>>        Boolean bExists bOK
84627>>>>>>>
84627>>>>>>>        Get psDriverID to sDriverID
84628>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84629>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84630>>>>>>>        If (bExists = False) Begin
84632>>>>>>>            Function_Return False
84633>>>>>>>        End
84633>>>>>>>>
84633>>>>>>>
84633>>>>>>>        Get psDataPathFirstPart to sPath
84634>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84635>>>>>>>
84635>>>>>>>        Get piDbType to iDbType
84636>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84637>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84638>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84639>>>>>>>
84639>>>>>>>        Move False to Err
84640>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84641>>>>>>>
84641>>>>>>>        // We also need to remove the cache-file since the table has been changed
84641>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84642>>>>>>>
84642>>>>>>>        Function_Return (Err = False)
84643>>>>>>>    End_Function
84644>>>>>>>
84644>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84644>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84646>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84646>>>>>>>        Integer iRetval iDbType
84646>>>>>>>        Boolean bOK
84646>>>>>>>
84646>>>>>>>        Get psDriverID to sDriverID
84647>>>>>>>        Get psDataPathFirstPart to sPath
84648>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84649>>>>>>>
84649>>>>>>>        Get piDbType to iDbType
84650>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84651>>>>>>>        Get psSchema to sSchema
84652>>>>>>>        If (sSchema = "") Begin
84654>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84655>>>>>>>        End
84655>>>>>>>>
84655>>>>>>>        Move (Uppercase(sTableName)) to sVal
84656>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84658>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84659>>>>>>>        End
84659>>>>>>>>
84659>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84660>>>>>>>
84660>>>>>>>        Move False to Err
84661>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84662>>>>>>>
84662>>>>>>>        // We also need to remove the cache-file since the table has been changed
84662>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84663>>>>>>>
84663>>>>>>>        Function_Return (Err = False)
84664>>>>>>>    End_Function
84665>>>>>>>
84665>>>>>>>    // *** Sql View Messages ***
84665>>>>>>>
84665>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84667>>>>>>>        Boolean bOK
84667>>>>>>>        Integer iDbType
84667>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84667>>>>>>>
84667>>>>>>>        Get psDriverID to sDriverID
84668>>>>>>>        Get piDbType   to iDbType
84669>>>>>>>
84669>>>>>>>        Case Begin
84669>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84671>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84672>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84673>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84674>>>>>>>            Break
84675>>>>>>>
84675>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84678>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84679>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84680>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84681>>>>>>>            Break
84682>>>>>>>
84682>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84685>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84686>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84687>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84688>>>>>>>            Break
84689>>>>>>>
84689>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84692>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84693>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84694>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84695>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84696>>>>>>>            Break
84697>>>>>>>
84697>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84700>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84701>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84702>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84703>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84704>>>>>>>            Break
84705>>>>>>>        Case End
84705>>>>>>>
84705>>>>>>>        Move False to Err
84706>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84707>>>>>>>        Move (Err = False) to bOK
84708>>>>>>>
84708>>>>>>>        Function_Return bOK
84709>>>>>>>    End_Function
84710>>>>>>>
84710>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84710>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84712>>>>>>>        Function_Return False
84713>>>>>>>    End_Function
84714>>>>>>>
84714>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84714>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84716>>>>>>>        Integer iLength iDecimals
84716>>>>>>>        String sColumnValue
84716>>>>>>>        String sTableName sDriverID
84716>>>>>>>        Boolean bOK bInitializeValue
84716>>>>>>>
84716>>>>>>>        Get psDriverID to sDriverID
84717>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84718>>>>>>>        If (bOK = False) Begin
84720>>>>>>>            Function_Return False
84721>>>>>>>        End
84721>>>>>>>>
84721>>>>>>>
84721>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84722>>>>>>>        If (sTableName = "") Begin
84724>>>>>>>            Function_Return False
84725>>>>>>>        End
84725>>>>>>>>
84725>>>>>>>
84725>>>>>>>        If (num_arguments > 3) Begin
84727>>>>>>>            Move iLen     to iLength
84728>>>>>>>            Move iDec     to iDecimals
84729>>>>>>>            Move bInitVal to bInitializeValue
84730>>>>>>>            Move sColVal  to sColumnValue
84731>>>>>>>        End
84731>>>>>>>>
84731>>>>>>>
84731>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84732>>>>>>>
84732>>>>>>>        Function_Return (bOK = True)
84733>>>>>>>    End_Function
84734>>>>>>>
84734>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84734>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84736>>>>>>>        Integer iDbType iLength iDecimals iDriver
84736>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84736>>>>>>>        String sDriverID sNotNull
84736>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84736>>>>>>>        Handle hTable
84736>>>>>>>
84736>>>>>>>        Get psDriverID to sDriverID
84737>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84738>>>>>>>        If (bOK = False) Begin
84740>>>>>>>            Function_Return True
84741>>>>>>>        End
84741>>>>>>>>
84741>>>>>>>
84741>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84742>>>>>>>        If (hTable = 0) Begin
84744>>>>>>>            Get NextFreeFilelistSlot to hTable
84745>>>>>>>        End
84745>>>>>>>>
84745>>>>>>>
84745>>>>>>>        Get piDbType to iDbType
84746>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84746>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84747>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84749>>>>>>>            Function_Return True
84750>>>>>>>        End
84750>>>>>>>>
84750>>>>>>>
84750>>>>>>>        Get DriverIndex sDriverID to iDriver
84751>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84754>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84757>>>>>>>
84757>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84758>>>>>>>        If (num_arguments > 3) Begin
84760>>>>>>>            Move iLen     to iLength
84761>>>>>>>            Move iDec     to iDecimals
84762>>>>>>>            Move bInitVal to bInitializeValue
84763>>>>>>>            Move sColVal  to sColumnValue
84764>>>>>>>        End
84764>>>>>>>>
84764>>>>>>>
84764>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84765>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84766>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84767>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84768>>>>>>>
84768>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84769>>>>>>>        If (bFixed = False) Begin
84771>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84772>>>>>>>        End
84772>>>>>>>>
84772>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84773>>>>>>>
84773>>>>>>>        Move False to Err
84774>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84775>>>>>>>
84775>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84777>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84778>>>>>>>        End
84778>>>>>>>>
84778>>>>>>>
84778>>>>>>>        If (Err = False) Begin
84780>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84781>>>>>>>        End
84781>>>>>>>>
84781>>>>>>>
84781>>>>>>>        Move (not(Err)) to bRetval
84782>>>>>>>
84782>>>>>>>        // We also need to remove the cache-file since the table has been changed
84782>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84783>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84786>>>>>>>
84786>>>>>>>        Function_Return bRetval
84787>>>>>>>    End_Function
84788>>>>>>>
84788>>>>>>>    // To update all current rows for a table column with a common value.
84788>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84790>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84790>>>>>>>        Boolean bRetval bSQLDriver
84790>>>>>>>        Integer iCurrErr iDbType
84790>>>>>>>
84790>>>>>>>        Move False to bRetval
84791>>>>>>>        Get piDbType to iDbType
84792>>>>>>>        Get psDriverID to sDriverID
84793>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84794>>>>>>>        If (bSQLDriver = False) Begin
84796>>>>>>>            Function_Return bRetval
84797>>>>>>>        End
84797>>>>>>>>
84797>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84798>>>>>>>
84798>>>>>>>        Move Err to iCurrErr
84799>>>>>>>        Move False to Err
84800>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84801>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84802>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84803>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84803>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
84805>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84806>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84807>>>>>>>        End
84807>>>>>>>>
84807>>>>>>>        Else Begin
84808>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84809>>>>>>>        End
84809>>>>>>>>
84809>>>>>>>
84809>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84810>>>>>>>        Move (Err = False) to bRetval
84811>>>>>>>        Move iCurrErr to Err
84812>>>>>>>
84812>>>>>>>        Function_Return bRetval
84813>>>>>>>    End_Function
84814>>>>>>>
84814>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84814>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84814>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84816>>>>>>>        String sDriverID sTableName
84816>>>>>>>        Boolean bOK
84816>>>>>>>
84816>>>>>>>        Get psDriverID to sDriverID
84817>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84818>>>>>>>        If (bOK = False) Begin
84820>>>>>>>            Function_Return False
84821>>>>>>>        End
84821>>>>>>>>
84821>>>>>>>
84821>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84822>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84823>>>>>>>
84823>>>>>>>        Function_Return (Err = False)
84824>>>>>>>    End_Function
84825>>>>>>>
84825>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84825>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84825>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84825>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84827>>>>>>>        Integer iDbType iLength iDecimals
84827>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84827>>>>>>>        Boolean bExists bOK bFixed
84827>>>>>>>        Handle hTable
84827>>>>>>>
84827>>>>>>>        Get psDriverID to sDriverID
84828>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84829>>>>>>>        If (bOK = False) Begin
84831>>>>>>>            Function_Return False
84832>>>>>>>        End
84832>>>>>>>>
84832>>>>>>>
84832>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84833>>>>>>>        If (hTable = 0) Begin
84835>>>>>>>            Get NextFreeFilelistSlot to hTable
84836>>>>>>>        End
84836>>>>>>>>
84836>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84837>>>>>>>        If (bExists = False) Begin
84839>>>>>>>            Function_Return False
84840>>>>>>>        End
84840>>>>>>>>
84840>>>>>>>
84840>>>>>>>        If (num_arguments > 3) Begin
84842>>>>>>>            Move iLen to iLength
84843>>>>>>>        End
84843>>>>>>>>
84843>>>>>>>        If (num_arguments > 4) Begin
84845>>>>>>>            Move iDec to iDecimals
84846>>>>>>>        End
84846>>>>>>>>
84846>>>>>>>
84846>>>>>>>        Get piDbType to iDbType
84847>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84848>>>>>>>
84848>>>>>>>        Move False to Err
84849>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84850>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84851>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84852>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84853>>>>>>>
84853>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84854>>>>>>>        If (bFixed = False) Begin
84856>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84857>>>>>>>        End
84857>>>>>>>>
84857>>>>>>>
84857>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84858>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84859>>>>>>>
84859>>>>>>>        // We also need to remove the cache-file since the table has been changed
84859>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84860>>>>>>>
84860>>>>>>>        Function_Return (Err = False)
84861>>>>>>>    End_Function
84862>>>>>>>
84862>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84864>>>>>>>        Boolean bOK bErr bIsSQLDriver
84864>>>>>>>        String sDriverID
84864>>>>>>>        Integer iDataType
84864>>>>>>>
84864>>>>>>>        Get psDriverID to sDriverID
84865>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84866>>>>>>>        If (bIsSQLDriver = False) Begin
84868>>>>>>>            Function_Return False
84869>>>>>>>        End
84869>>>>>>>>
84869>>>>>>>
84869>>>>>>>        Move Err to bErr
84870>>>>>>>        Move False to bErr
84871>>>>>>>
84871>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84871>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84871>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84872>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84875>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84877>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
84878>>>>>>>        End
84878>>>>>>>>
84878>>>>>>>
84878>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84881>>>>>>>        Move (not(Err)) to bOK
84882>>>>>>>        Move bErr to Err
84883>>>>>>>
84883>>>>>>>        Function_Return bOK
84884>>>>>>>    End_Function
84885>>>>>>>
84885>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84887>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84887>>>>>>>        String sDriverID
84887>>>>>>>
84887>>>>>>>        Get psDriverID to sDriverID
84888>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84889>>>>>>>        If (bIsSQLDriver = False) Begin
84891>>>>>>>            Function_Return False
84892>>>>>>>        End
84892>>>>>>>>
84892>>>>>>>
84892>>>>>>>        Move Err to bErr
84893>>>>>>>        Move False to bErr
84894>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84897>>>>>>>        If (bNullable = bCurrentState) Begin
84899>>>>>>>            Function_Return True
84900>>>>>>>        End
84900>>>>>>>>
84900>>>>>>>
84900>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84903>>>>>>>        If (bOpen = False) Begin
84905>>>>>>>            Get AutoConnectionIDLogin to bOK
84906>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84907>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84908>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84909>>>>>>>            Open hTable
84911>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84912>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84913>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84914>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84917>>>>>>>        End
84917>>>>>>>>
84917>>>>>>>        If (bOpen = True) Begin
84919>>>>>>>            Structure_Start hTable sDriverID
84920>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84923>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84924>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84926>>>>>>>            Set Action_Text of ghoStatusPanel to ""
84927>>>>>>>        End
84927>>>>>>>>
84927>>>>>>>
84927>>>>>>>        Move (not(Err)) to bOK
84928>>>>>>>        Move bErr to Err
84929>>>>>>>
84929>>>>>>>        Function_Return bOK
84930>>>>>>>    End_Function
84931>>>>>>>
84931>>>>>>>    // Drop column by its table handle
84931>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84933>>>>>>>        String sDriverID sTableName
84933>>>>>>>        Boolean bOK
84933>>>>>>>
84933>>>>>>>        Get psDriverID to sDriverID
84934>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84935>>>>>>>        If (bOK = False) Begin
84937>>>>>>>            Function_Return False
84938>>>>>>>        End
84938>>>>>>>>
84938>>>>>>>
84938>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84939>>>>>>>        If (sTableName = "") Begin
84941>>>>>>>            Function_Return False
84942>>>>>>>        End
84942>>>>>>>>
84942>>>>>>>
84942>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84943>>>>>>>
84943>>>>>>>        Function_Return (bOK = True)
84944>>>>>>>    End_Function
84945>>>>>>>
84945>>>>>>>    // Drop column by its table name as a string.
84945>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84947>>>>>>>        Integer iDbType iDriver
84947>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
84947>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84947>>>>>>>        Handle hTable
84947>>>>>>>
84947>>>>>>>        Get psDriverID to sDriverID
84948>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84949>>>>>>>        If (bOK = False) Begin
84951>>>>>>>            Function_Return False
84952>>>>>>>        End
84952>>>>>>>>
84952>>>>>>>
84952>>>>>>>        Get DriverIndex sDriverID to iDriver
84953>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84956>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84959>>>>>>>
84959>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84960>>>>>>>        If (hTable <> 0) Begin
84962>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84963>>>>>>>            If (bExists = False) Begin
84965>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84968>>>>>>>                Function_Return False
84969>>>>>>>            End
84969>>>>>>>>
84969>>>>>>>        End
84969>>>>>>>>
84969>>>>>>>
84969>>>>>>>        Get piDbType to iDbType
84970>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84972>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84973>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
84974>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84977>>>>>>>            Function_Return bOK
84978>>>>>>>        End
84978>>>>>>>>
84978>>>>>>>
84978>>>>>>>        Move False to Err
84979>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84980>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84981>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84982>>>>>>>
84982>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84983>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84984>>>>>>>        Move (not(Err)) to bRetval
84985>>>>>>>
84985>>>>>>>        // We also need to remove the cache-file since the table has been changed
84985>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84986>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84989>>>>>>>
84989>>>>>>>        Function_Return bRetval
84990>>>>>>>    End_Function
84991>>>>>>>
84991>>>>>>>    // Rename a field/column by table handle (filelist number)
84991>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84993>>>>>>>        String sDriverID sTableName
84993>>>>>>>        Boolean bOK
84993>>>>>>>
84993>>>>>>>        Get psDriverID to sDriverID
84994>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84995>>>>>>>        If (bOK = False) Begin
84997>>>>>>>            Function_Return False
84998>>>>>>>        End
84998>>>>>>>>
84998>>>>>>>
84998>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84999>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85000>>>>>>>
85000>>>>>>>        Function_Return (Err = False)
85001>>>>>>>    End_Function
85002>>>>>>>
85002>>>>>>>    // Rename a field/column by table name.
85002>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85004>>>>>>>        Integer iDbType iDataType
85004>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85004>>>>>>>        Boolean bOK bRetval
85004>>>>>>>        Handle hTable
85004>>>>>>>
85004>>>>>>>        Move sTableName to sOrgTableName
85005>>>>>>>        Get psDriverID to sDriverID
85006>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85007>>>>>>>        If (bOK = False) Begin
85009>>>>>>>            Function_Return False
85010>>>>>>>        End
85010>>>>>>>>
85010>>>>>>>
85010>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85011>>>>>>>        If (sVal = "") Begin
85013>>>>>>>            Function_Return False
85014>>>>>>>        End
85014>>>>>>>>
85014>>>>>>>
85014>>>>>>>        Get piDbType to iDbType
85015>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85016>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85017>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85018>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85019>>>>>>>
85019>>>>>>>        Case Begin
85019>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85021>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85022>>>>>>>                Case Break
85023>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85023>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85026>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85027>>>>>>>                Case Break
85028>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85028>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85031>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85032>>>>>>>                Case Break
85033>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85033>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85036>>>>>>>                Move sOrgTableName to sTableName
85037>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85038>>>>>>>                Case Break
85039>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85042>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85042>>>>>>>                Move sOrgTableName to sTableName
85043>>>>>>>                Get psDatabase to sDatabase
85044>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85045>>>>>>>                If (hTable = 0) Begin
85047>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85048>>>>>>>                    If (bOK = False) Begin
85050>>>>>>>                        Function_Return False
85051>>>>>>>                    End
85051>>>>>>>>
85051>>>>>>>                    Get NextFreeFilelistSlot to hTable
85052>>>>>>>                End
85052>>>>>>>>
85052>>>>>>>                Else Begin
85053>>>>>>>                    Open hTable
85055>>>>>>>                End
85055>>>>>>>>
85055>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85056>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85057>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85058>>>>>>>                Case Break
85059>>>>>>>            Case Else
85059>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85060>>>>>>>        Case End
85060>>>>>>>
85060>>>>>>>        Move False to Err
85061>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85062>>>>>>>        Move (Err = False) to bRetval
85063>>>>>>>        // We also need to remove the cache-file since the table has been changed
85063>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85064>>>>>>>
85064>>>>>>>        Function_Return bRetval
85065>>>>>>>    End_Function
85066>>>>>>>
85066>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85068>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85068>>>>>>>        Integer iNumCols iCount iDataType
85068>>>>>>>        String sValue
85068>>>>>>>
85068>>>>>>>        Get phoSQLManager to hoSQLHandler
85069>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85070>>>>>>>        If (hSQLConnect <> 0) Begin
85072>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85073>>>>>>>            If (hStmt <> 0) Begin
85075>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85076>>>>>>>
85076>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85077>>>>>>>                For iCount from 1 to iNumCols
85083>>>>>>>>
85083>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85084>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85086>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85087>>>>>>>                        Move iNumCols to iCount // We're out of here
85088>>>>>>>                    End
85088>>>>>>>>
85088>>>>>>>                Loop
85089>>>>>>>>
85089>>>>>>>
85089>>>>>>>                Send SQLClose of hStmt
85090>>>>>>>            End
85090>>>>>>>>
85090>>>>>>>            Send SQLDisconnect of hSQLConnect
85091>>>>>>>        End
85091>>>>>>>>
85091>>>>>>>
85091>>>>>>>        Function_Return iDataType
85092>>>>>>>    End_Function
85093>>>>>>>
85093>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85093>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85095>>>>>>>        Function_Return False
85096>>>>>>>    End_Function
85097>>>>>>>
85097>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85099>>>>>>>        String sMessage // sConnectionString
85099>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85099>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85099>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85102>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85102>>>>>>>        TimeSpan tsQuery tsFetch
85102>>>>>>>        tSqlErrorArray aSqlErrorArray
85102>>>>>>>        tSqlErrorArray aSqlErrorArray
85102>>>>>>>        Boolean bOK bShowProgress
85102>>>>>>>        tSQLConnection SQLConnection
85102>>>>>>>        tSQLConnection SQLConnection
85102>>>>>>>
85102>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85103>>>>>>>        If (bOK = False) Begin
85105>>>>>>>            Procedure_Return
85106>>>>>>>        End
85106>>>>>>>>
85106>>>>>>>
85106>>>>>>>        If (num_arguments > 2) Begin
85108>>>>>>>            Move bShowProgr to bShowProgress
85109>>>>>>>        End
85109>>>>>>>>
85109>>>>>>>
85109>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85110>>>>>>>        Get phoSQLManager to hoSqlHandler
85111>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85112>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85113>>>>>>>
85113>>>>>>>        If (hoSQLConnect <> 0) Begin
85115>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85116>>>>>>>            If (hoStmt <> 0) Begin
85118>>>>>>>                // record starting date/time stamp
85118>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85119>>>>>>>                // turn on error handling if enabled
85119>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85121>>>>>>>                    Set pbSqlError to False
85122>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85123>>>>>>>                    Move Error_Object_Id to hoError
85124>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85126>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85127>>>>>>>                    End
85127>>>>>>>>
85127>>>>>>>                    Else Begin
85128>>>>>>>                        Move Self to Error_Object_Id
85129>>>>>>>                    End
85129>>>>>>>>
85129>>>>>>>                End
85129>>>>>>>>
85129>>>>>>>
85129>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85129>>>>>>>                Set psSQLStatementString to sStmt
85130>>>>>>>                Send Cursor_Wait of Cursor_Control
85131>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85132>>>>>>>                Send Cursor_Ready of Cursor_Control
85133>>>>>>>
85133>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85135>>>>>>>                    Move hoError to Error_Object_Id
85136>>>>>>>                End
85136>>>>>>>>
85136>>>>>>>
85136>>>>>>>                Move 0 to iMsgs
85137>>>>>>>                Move Err to iErr
85138>>>>>>>                Move LastErr to iLastErr
85139>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85140>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85141>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85142>>>>>>>                Send _SqlColumnInfo hoStmt
85143>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85144>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85145>>>>>>>                Repeat
85145>>>>>>>>
85145>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85146>>>>>>>                    If (iFetchResult <> 0) Begin
85148>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85149>>>>>>>                    End
85149>>>>>>>>
85149>>>>>>>                Until (iFetchResult = 0)
85151>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85152>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85153>>>>>>>                Move iErr to Err
85154>>>>>>>                Move iLastErr to LastErr
85155>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85156>>>>>>>
85156>>>>>>>                Set piRows    to iRows
85157>>>>>>>                Set piRowType to iRowType
85158>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85159>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85160>>>>>>>
85160>>>>>>>                If (iMsgs <> 0) Begin
85162>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85164>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85165>>>>>>>                    End
85165>>>>>>>>
85165>>>>>>>                    For i from 1 to iMsgs
85171>>>>>>>>
85171>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85172>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85173>>>>>>>                        If (bShowProgress = True) Begin
85175>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85177>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85178>>>>>>>                            End
85178>>>>>>>>
85178>>>>>>>                            Else Begin
85179>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85181>>>>>>>                            End
85181>>>>>>>>
85181>>>>>>>                        End
85181>>>>>>>>
85181>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85182>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85183>>>>>>>                    Loop
85184>>>>>>>>
85184>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85186>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85187>>>>>>>                    End
85187>>>>>>>>
85187>>>>>>>                    Set paQueryMessages to sMsg
85188>>>>>>>                End
85188>>>>>>>>
85188>>>>>>>                Else Begin
85189>>>>>>>                    If (bShowProgress = True) Begin
85191>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85192>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85194>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85195>>>>>>>                            Decrement iMsgs
85196>>>>>>>                            For i from 0 to iMsgs
85202>>>>>>>>
85202>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85205>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85208>>>>>>>                            Loop
85209>>>>>>>>
85209>>>>>>>                        End
85209>>>>>>>>
85209>>>>>>>                    End
85209>>>>>>>>
85209>>>>>>>                End
85209>>>>>>>>
85209>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85210>>>>>>>            End
85210>>>>>>>>
85210>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85211>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85212>>>>>>>            Set ptsQueryExec to tsQuery
85213>>>>>>>            Set ptsFetchResults to tsFetch
85214>>>>>>>            Send SqlClose of hoStmt
85215>>>>>>>        End
85215>>>>>>>>
85215>>>>>>>
85215>>>>>>>        Send SqlDisconnect of hoSQLConnect
85216>>>>>>>    End_Procedure
85217>>>>>>>
85217>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85217>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85217>>>>>>>    // Returns False if no error occured.
85217>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85219>>>>>>>        Boolean bOK bShowProgress
85219>>>>>>>        tSQLScriptArray SQLScriptArray
85219>>>>>>>        tSQLScriptArray SQLScriptArray
85219>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85219>>>>>>>        TimeSpan tsTotalTime
85219>>>>>>>
85219>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85220>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85221>>>>>>>        If (SQLScriptArray.bError = True) Begin
85223>>>>>>>            Function_Return False
85224>>>>>>>        End
85224>>>>>>>>
85224>>>>>>>
85224>>>>>>>        If (num_arguments > 3) Begin
85226>>>>>>>            Move bShowProgr to bShowProgress
85227>>>>>>>        End
85227>>>>>>>>
85227>>>>>>>
85227>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85228>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85229>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85230>>>>>>>
85230>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85231>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85232>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85233>>>>>>>
85233>>>>>>>        Function_Return bOK
85234>>>>>>>    End_Function
85235>>>>>>>
85235>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85235>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85237>>>>>>>        Function_Return False
85238>>>>>>>    End_Function
85239>>>>>>>
85239>>>>>>>    // Does three things with auxilirary files;
85239>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85239>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85239>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85239>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85241>>>>>>>        String sDataPath sDDSrcPath sDriverID
85241>>>>>>>        Boolean bOK bExists
85241>>>>>>>        Integer iCount iCh iPos
85241>>>>>>>
85241>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85241>>>>>>>        If (sTableName contains ".") Begin
85243>>>>>>>            Move (Pos(".", sTableName)) to iPos
85244>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85245>>>>>>>        End
85245>>>>>>>>
85245>>>>>>>
85245>>>>>>>        Get psDriverID to sDriverID
85246>>>>>>>        Get psDataPathFirstPart to sDataPath
85247>>>>>>>        Get vFolderExists sDataPath to bOK
85248>>>>>>>        If (bOK = False) Begin
85250>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85251>>>>>>>>
85251>>>>>>>            Function_Return False
85252>>>>>>>        End
85252>>>>>>>>
85252>>>>>>>
85252>>>>>>>        // First delete the cache file:
85252>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85253>>>>>>>
85253>>>>>>>        Get Seq_New_Channel to iCh
85254>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85256>>>>>>>            Function_Return False
85257>>>>>>>        End
85257>>>>>>>>
85257>>>>>>>
85257>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85258>>>>>>>        If (bExists = False) Begin
85260>>>>>>>            Function_Return False
85261>>>>>>>        End
85261>>>>>>>>
85261>>>>>>>
85261>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85262>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85262>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85263>>>>>>>
85263>>>>>>>        // If in development environment; output new .fd file:
85263>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85264>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85265>>>>>>>        If (iCount > 1) Begin
85267>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85268>>>>>>>        End
85268>>>>>>>>
85268>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85269>>>>>>>        If (bExists = True) Begin
85271>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85272>>>>>>>            Move False to Err
85273>>>>>>>            Get AutoConnectionIDLogin to bOK
85274>>>>>>>            If (hTable <> 0) Begin
85276>>>>>>>                Open hTable
85278>>>>>>>            End
85278>>>>>>>>
85278>>>>>>>            Else Begin
85279>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85280>>>>>>>            End
85280>>>>>>>>
85280>>>>>>>
85280>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85283>>>>>>>            If (bOK = True) Begin
85285>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85287>>>>>>>            End
85287>>>>>>>>
85287>>>>>>>            If (Err = True) Begin
85289>>>>>>>                Move False to bOK
85290>>>>>>>            End
85290>>>>>>>>
85290>>>>>>>        End
85290>>>>>>>>
85290>>>>>>>
85290>>>>>>>        Function_Return (bOK = True)
85291>>>>>>>    End_Function
85292>>>>>>>
85292>>>>>>>    // Message for changing .int files to use connection ID's
85292>>>>>>>    //
85292>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85292>>>>>>>    // OR changes an existing connection id to a new id.
85292>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85292>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85292>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85294>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85294>>>>>>>        String[] sFilesData
85295>>>>>>>        Boolean bOK bCancel
85295>>>>>>>        Integer iSize iCount
85295>>>>>>>
85295>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85296>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85297>>>>>>>        If (iSize = 0) Begin
85299>>>>>>>            If (ghoStatusPanel <> 0) Begin
85301>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85303>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85304>>>>>>>                End
85304>>>>>>>>
85304>>>>>>>            End
85304>>>>>>>>
85304>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85305>>>>>>>            Procedure_Return
85306>>>>>>>        End
85306>>>>>>>>
85306>>>>>>>
85306>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85307>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85308>>>>>>>        Decrement iSize
85309>>>>>>>        For iCount from 0 to iSize
85315>>>>>>>>
85315>>>>>>>            Move sFilesData[iCount] to sFileName
85316>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85316>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85317>>>>>>>            If (ghoStatusPanel <> 0) Begin
85319>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85321>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85322>>>>>>>                    If (bCancel = True) Begin
85324>>>>>>>                        Send Deactivate of ghoStatusPanel
85325>>>>>>>                        Procedure_Return
85326>>>>>>>                    End
85326>>>>>>>>
85326>>>>>>>                End
85326>>>>>>>>
85326>>>>>>>            End
85326>>>>>>>>
85326>>>>>>>        Loop
85327>>>>>>>>
85327>>>>>>>
85327>>>>>>>        Get psDriverID to sDriverID
85328>>>>>>>
85328>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85328>>>>>>>        Move "" to sFileName
85329>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85331>>>>>>>            Move "MSSQLDrv.int" to sFileName
85332>>>>>>>        End
85332>>>>>>>>
85332>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85334>>>>>>>            Move "DB2_Drv.int" to sFileName
85335>>>>>>>        End
85335>>>>>>>>
85335>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85337>>>>>>>            Move "ODBC_Drv.int" to sFileName
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>        If (sFileName <> "") Begin
85340>>>>>>>            Move "" to sDriverFile
85341>>>>>>>            Get_File_Path sFileName to sDriverFile
85342>>>>>>>            If (sDriverFile <> "") Begin
85344>>>>>>>                Get psConnectionString to sConnectionString
85345>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85346>>>>>>>            End
85346>>>>>>>>
85346>>>>>>>        End
85346>>>>>>>>
85346>>>>>>>    End_Procedure
85347>>>>>>>
85347>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85347>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85349>>>>>>>        String[] sDatabaseArray
85350>>>>>>>        String sVal sServer sDriverID
85350>>>>>>>        Integer iCount iSize iPos
85350>>>>>>>        Boolean bExists
85350>>>>>>>        tSQLConnection SQLConnection
85350>>>>>>>        tSQLConnection SQLConnection
85350>>>>>>>
85350>>>>>>>        Move False to bExists
85351>>>>>>>        Get psDriverID to sDriverID
85352>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85352>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85354>>>>>>>            Function_Return bExists
85355>>>>>>>        End
85355>>>>>>>>
85355>>>>>>>
85355>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85356>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85358>>>>>>>            Function_Return False
85359>>>>>>>        End
85359>>>>>>>>
85359>>>>>>>
85359>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85360>>>>>>>        Move SQLConnection.sServer to sServer
85361>>>>>>>
85361>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85361>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85363>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85364>>>>>>>        End
85364>>>>>>>>
85364>>>>>>>        Else If (sServer contains "/") Begin
85367>>>>>>>            Move (Pos("/", sServer)) to iPos
85368>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85369>>>>>>>        End
85369>>>>>>>>
85369>>>>>>>
85369>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85370>>>>>>>        Decrement iSize
85371>>>>>>>        For iCount from 0 to iSize
85377>>>>>>>>
85377>>>>>>>            Move sDatabaseArray[iCount] to sVal
85378>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85380>>>>>>>                Move True to bExists
85381>>>>>>>                If (bExists = True) Begin
85383>>>>>>>                    Move iSize to iCount // We're done.
85384>>>>>>>                End
85384>>>>>>>>
85384>>>>>>>            End
85384>>>>>>>>
85384>>>>>>>        Loop
85385>>>>>>>>
85385>>>>>>>
85385>>>>>>>        Function_Return bExists
85386>>>>>>>    End_Function
85387>>>>>>>
85387>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85387>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85389>>>>>>>        String sDatabase sSchema sTableName sVal
85389>>>>>>>        Boolean bExists
85389>>>>>>>        String[] sTablesArray
85390>>>>>>>        Integer iSize iCount
85390>>>>>>>
85390>>>>>>>        Move False to bExists
85391>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85392>>>>>>>        Get psDatabase to sDatabase
85393>>>>>>>        Get psSchema   to sSchema
85394>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85395>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85396>>>>>>>        Decrement iSize
85397>>>>>>>        For iCount from 0 to iSize
85403>>>>>>>>
85403>>>>>>>            Move sTablesArray[iCount] to sVal
85404>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85406>>>>>>>                Move True to bExists
85407>>>>>>>                Move iSize to iCount // We're done!
85408>>>>>>>            End
85408>>>>>>>>
85408>>>>>>>        Loop
85409>>>>>>>>
85409>>>>>>>
85409>>>>>>>        Function_Return bExists
85410>>>>>>>    End_Function
85411>>>>>>>
85411>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85413>>>>>>>        String sVal sTableSpelledCorrectly
85413>>>>>>>        Boolean bExists
85413>>>>>>>        String[] sTablesArray
85414>>>>>>>        Integer iSize iCount
85414>>>>>>>
85414>>>>>>>        Move False to bExists
85415>>>>>>>        Move sTableName to sTableSpelledCorrectly
85416>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85417>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85418>>>>>>>        Decrement iSize
85419>>>>>>>        For iCount from 0 to iSize
85425>>>>>>>>
85425>>>>>>>            Move sTablesArray[iCount] to sVal
85426>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85428>>>>>>>                Move sVal to sTableSpelledCorrectly
85429>>>>>>>                Move iSize to iCount // We're done!
85430>>>>>>>            End
85430>>>>>>>>
85430>>>>>>>        Loop
85431>>>>>>>>
85431>>>>>>>
85431>>>>>>>        Function_Return sTableSpelledCorrectly
85432>>>>>>>    End_Function
85433>>>>>>>
85433>>>>>>>    // ToDo: This index name function needs to be finished...
85433>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85435>>>>>>>        String sSchema sTableName sDriverID
85435>>>>>>>        Boolean bExists
85435>>>>>>>
85435>>>>>>>        Get psDriverID to sDriverID
85436>>>>>>>        Get psSchema to sSchema
85437>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85438>>>>>>>
85438>>>>>>>        Function_Return bExists
85439>>>>>>>    End_Function
85440>>>>>>>
85440>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85440>>>>>>>    // Returns True if it does
85440>>>>>>>    // Sample:
85440>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85440>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85442>>>>>>>        Integer iNumColumns iColumn
85442>>>>>>>        String sColumn sDriverID
85442>>>>>>>        String[] sColumnsArray
85443>>>>>>>        Boolean bExists bOK
85443>>>>>>>
85443>>>>>>>        Move False to bExists
85444>>>>>>>        Get AutoConnectionIDLogin to bOK
85445>>>>>>>        Get psDriverID to sDriverID
85446>>>>>>>
85446>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85447>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85448>>>>>>>        Decrement iNumColumns
85449>>>>>>>        For iColumn from 0 to iNumColumns
85455>>>>>>>>
85455>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85456>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85458>>>>>>>                Move True to bExists
85459>>>>>>>                Move iNumColumns to iColumn // We're out of here
85460>>>>>>>            End
85460>>>>>>>>
85460>>>>>>>        Loop
85461>>>>>>>>
85461>>>>>>>
85461>>>>>>>        Function_Return bExists
85462>>>>>>>    End_Function
85463>>>>>>>
85463>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85465>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85465>>>>>>>        Boolean bOpened bOK
85465>>>>>>>        String sColumnName sNativeTypeName
85465>>>>>>>
85465>>>>>>>        Get AutoConnectionIDLogin to bOK
85466>>>>>>>        Get OpenTableExclusive hTable to bOK
85467>>>>>>>        If (bOK = False) Begin
85469>>>>>>>            Function_Return False
85470>>>>>>>        End
85470>>>>>>>>
85470>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85473>>>>>>>        If (bOpened = False) Begin
85475>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85476>>>>>>>>
85476>>>>>>>            Function_Return False
85477>>>>>>>        End
85477>>>>>>>>
85477>>>>>>>
85477>>>>>>>        Move False to Err
85478>>>>>>>
85478>>>>>>>        Structure_Start hTable
85479>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85482>>>>>>>
85482>>>>>>>            For iColumn from 1 to iNumColumns
85488>>>>>>>>
85488>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85491>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85494>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85497>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85500>>>>>>>
85500>>>>>>>                Case Begin
85500>>>>>>>                    Case (iDFType = DF_DATE)
85502>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85504>>>>>>>                            // Convert datetime to date
85504>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85507>>>>>>>                        End
85507>>>>>>>>
85507>>>>>>>                        Case Break
85508>>>>>>>                    Case (iDFType = DF_DATETIME)
85511>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85513>>>>>>>                            // Convert datetime to datetime2
85513>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85516>>>>>>>                        End
85516>>>>>>>>
85516>>>>>>>                        Case Break
85517>>>>>>>                    Case (iDFType = DF_ASCII)
85520>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85522>>>>>>>                            // Convert char to varchar
85522>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85525>>>>>>>                        End
85525>>>>>>>>
85525>>>>>>>                        Case Break
85526>>>>>>>                    Case (iDFType = DF_TEXT)
85529>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85531>>>>>>>                            // Convert text to varchar(max)
85531>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85534>>>>>>>                        End
85534>>>>>>>>
85534>>>>>>>                        Case Break
85535>>>>>>>                    Case (iDFType = DF_BINARY)
85538>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85540>>>>>>>                            // Convert image to varbinary(max)
85540>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85543>>>>>>>                        End
85543>>>>>>>>
85543>>>>>>>                        Case Break
85544>>>>>>>                Case End
85544>>>>>>>            Loop
85545>>>>>>>>
85545>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85546>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85548>>>>>>>
85548>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85549>>>>>>>        Function_Return (Err = False)
85550>>>>>>>    End_Function
85551>>>>>>>
85551>>>>>>>
85551>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85551>>>>>>>    // the DbUpdateVersion database revision in.
85551>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85551>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85551>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85553>>>>>>>        Boolean bOK bOpened
85553>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85553>>>>>>>
85553>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85556>>>>>>>        Get _TableNameOnly sTableName to sTableName
85557>>>>>>>        If (sTableName = "") Begin
85559>>>>>>>            Function_Return False
85560>>>>>>>        End
85560>>>>>>>>
85560>>>>>>>
85560>>>>>>>        // This just creates the table and a "dummy" column.
85560>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85561>>>>>>>        If (bOK = False) Begin
85563>>>>>>>            Function_Return False
85564>>>>>>>        End
85564>>>>>>>>
85564>>>>>>>
85564>>>>>>>        Close hTable
85565>>>>>>>        Move False to Err
85566>>>>>>>
85566>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85567>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85568>>>>>>>        Move "Decimal" to sDataType
85569>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85570>>>>>>>
85570>>>>>>>        // Adds the "sColumnName" passed to the function
85570>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85571>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85572>>>>>>>
85572>>>>>>>        // Now we can delete the dummy column:
85572>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85573>>>>>>>
85573>>>>>>>        // Finally, we attach to the newly created table.
85573>>>>>>>        If (Err = False) Begin
85575>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85576>>>>>>>        End
85576>>>>>>>>
85576>>>>>>>        Open hTable
85578>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85581>>>>>>>
85581>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85582>>>>>>>    End_Function
85583>>>>>>>
85583>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85583>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85583>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85583>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85583>>>>>>>    // column types.
85583>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85585>>>>>>>        Handle hDatabase
85585>>>>>>>        Integer iDriver iServers iCount
85585>>>>>>>        String sValue
85585>>>>>>>
85585>>>>>>>        If (sServer = "") Begin
85587>>>>>>>            Function_Return 0
85588>>>>>>>        End
85588>>>>>>>>
85588>>>>>>>
85588>>>>>>>        Get DriverIndex sDriverID to iDriver
85589>>>>>>>        If (iDriver = 0) Begin
85591>>>>>>>            Function_Return 0
85592>>>>>>>        End
85592>>>>>>>>
85592>>>>>>>
85592>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85595>>>>>>>        For iCount from 1 to iServers
85601>>>>>>>>
85601>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85604>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85606>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85609>>>>>>>            End
85609>>>>>>>>
85609>>>>>>>        Loop
85610>>>>>>>>
85610>>>>>>>
85610>>>>>>>        Function_Return hDatabase
85611>>>>>>>    End_Function
85612>>>>>>>
85612>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85612>>>>>>>//        String sRootName
85612>>>>>>>//        Boolean bOK
85612>>>>>>>//
85612>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85612>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85612>>>>>>>//
85612>>>>>>>//        Function_Return bOK
85612>>>>>>>//    End_Function
85612>>>>>>>
85612>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85612>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85612>>>>>>>//        Integer iDbType
85612>>>>>>>//        Boolean bOK
85612>>>>>>>//
85612>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85612>>>>>>>//        If (bOK = True) Begin
85612>>>>>>>//            Function_Return False
85612>>>>>>>//        End
85612>>>>>>>//
85612>>>>>>>//        Get psDriverID to sDriverID
85612>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85612>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85612>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85612>>>>>>>//
85612>>>>>>>//        Get psDriverID to sDriverID
85612>>>>>>>//        Get piDbType   to iDbType
85612>>>>>>>//        Get psSchema   to sSchema
85612>>>>>>>//        If (sSchema = "") Begin
85612>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85612>>>>>>>//        End
85612>>>>>>>//
85612>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85612>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85612>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85612>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85612>>>>>>>//            End
85612>>>>>>>//            Else Begin
85612>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85612>>>>>>>//            End
85612>>>>>>>//        End
85612>>>>>>>//
85612>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85612>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85612>>>>>>>//
85612>>>>>>>//        Function_Return True
85612>>>>>>>//    End_Function
85612>>>>>>>
85612>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85612>>>>>>>    // from the passed filelist.
85612>>>>>>>    // Returns the number of tables affected.
85612>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85614>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85614>>>>>>>        Integer iRetval
85614>>>>>>>        Handle hTable
85614>>>>>>>
85614>>>>>>>        // We first save the current filelist as the passed filelist name
85614>>>>>>>        // may come from another workspace, to restore it when we're ready.
85614>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85617>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85620>>>>>>>        Move 0 to hTable
85621>>>>>>>        Move 0 to iRetval
85622>>>>>>>
85622>>>>>>>        Repeat
85622>>>>>>>>
85622>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85625>>>>>>>            If (hTable <> 0) Begin
85627>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85630>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85633>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85636>>>>>>>                Move (Uppercase(sRootName)) to sVal
85637>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85639>>>>>>>                    // Prefixes:
85639>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85640>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85641>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85642>>>>>>>                    // Suffixes:
85642>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85643>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85644>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85645>>>>>>>
85645>>>>>>>                    // Change Filelist entry:
85645>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85648>>>>>>>
85648>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85649>>>>>>>                    If (sVal contains "dbo.") Begin
85651>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85652>>>>>>>
85652>>>>>>>                        // Change Filelist entry:
85652>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85655>>>>>>>                    End
85655>>>>>>>>
85655>>>>>>>                    Increment iRetval
85656>>>>>>>                End
85656>>>>>>>>
85656>>>>>>>            End
85656>>>>>>>>
85656>>>>>>>        Until (hTable = 0)
85658>>>>>>>
85658>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85661>>>>>>>
85661>>>>>>>        Function_Return iRetval
85662>>>>>>>    End_Function
85663>>>>>>>
85663>>>>>>>    // To open all Sql based tables in Filelist.cfg
85663>>>>>>>    Procedure SqlUtilOpenAllTables
85665>>>>>>>        Handle hTable
85665>>>>>>>        String sRoot sDriverID
85665>>>>>>>        Boolean bOK
85665>>>>>>>
85665>>>>>>>        Move 0 to hTable
85666>>>>>>>        Move "" to sDriverID
85667>>>>>>>        Get AutoConnectionIDLogin to bOK
85668>>>>>>>
85668>>>>>>>        Repeat
85668>>>>>>>>
85668>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85671>>>>>>>            If (hTable > 0) Begin
85673>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85676>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85678>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85681>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85683>>>>>>>                        Open hTable
85685>>>>>>>                    End
85685>>>>>>>>
85685>>>>>>>                End
85685>>>>>>>>
85685>>>>>>>            End
85685>>>>>>>>
85685>>>>>>>
85685>>>>>>>        Until (hTable = 0)
85687>>>>>>>    End_Procedure
85688>>>>>>>
85688>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85688>>>>>>>//        String sRetval sDriverID
85688>>>>>>>//        String sTableName
85688>>>>>>>//        Integer iDbType iIndex
85688>>>>>>>//        Boolean bOK
85688>>>>>>>//
85688>>>>>>>//        Get psDriverID to sDriverID
85688>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85688>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85688>>>>>>>//            Function_Return ""
85688>>>>>>>//        End
85688>>>>>>>//
85688>>>>>>>//        Move False to Err
85688>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85688>>>>>>>//        Get piDbType to iDbType
85688>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85688>>>>>>>//        If (iIndex = -1) Begin
85688>>>>>>>//            Function_Return ""
85688>>>>>>>//        End
85688>>>>>>>//
85688>>>>>>>//        Function_Return sRetval
85688>>>>>>>//    End_Function
85688>>>>>>>
85688>>>>>>>    // Checks if the passed Table;
85688>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
85688>>>>>>>    // 2) It has an .int file.
85688>>>>>>>    // If both is True it should already be connected to SQL
85688>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85690>>>>>>>        Boolean bExists bRootName
85690>>>>>>>        String sRootName sDataPath
85690>>>>>>>
85690>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85693>>>>>>>        Move (sRootName contains sDriverID) to bRootName
85694>>>>>>>
85694>>>>>>>        Get psDataPathFirstPart to sDataPath
85695>>>>>>>        Get vFolderExists sDataPath to bExists
85696>>>>>>>        If (bExists = False) Begin
85698>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85698>>>>>>>            Function_Return False
85699>>>>>>>        End
85699>>>>>>>>
85699>>>>>>>
85699>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85700>>>>>>>        Get _TableNameOnly sRootName to sRootName
85701>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85702>>>>>>>
85702>>>>>>>        Function_Return (bRootName = True and bExists = True)
85703>>>>>>>    End_Function
85704>>>>>>>
85704>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85706>>>>>>>        Boolean bViewTableType bOpen bOK
85706>>>>>>>        Integer iTableCount iNumTables
85706>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85706>>>>>>>        Handle hoCliHandler
85706>>>>>>>        tSQLConnection SQLConnection
85706>>>>>>>        tSQLConnection SQLConnection
85706>>>>>>>
85706>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85709>>>>>>>        If (bOpen = False) Begin
85711>>>>>>>            Get AutoConnectionIDLogin to bOK
85712>>>>>>>            Open hTable
85714>>>>>>>        End
85714>>>>>>>>
85714>>>>>>>
85714>>>>>>>        Get pSQLConnection to SQLConnection
85715>>>>>>>        Get phoCLIHandler to hoCliHandler
85716>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
85717>>>>>>>
85717>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85720>>>>>>>        Get _TableNameOnly sTableName to sTableName
85721>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85724>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85725>>>>>>>
85725>>>>>>>        For iTableCount from 1 to iNumTables
85731>>>>>>>>
85731>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85732>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85733>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85735>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
85736>>>>>>>                Move iNumTables to iTableCount // We're done.
85737>>>>>>>            End
85737>>>>>>>>
85737>>>>>>>        Loop
85738>>>>>>>>
85738>>>>>>>
85738>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
85739>>>>>>>        If (bOpen = False) Begin
85741>>>>>>>            Close hTable
85742>>>>>>>        End
85742>>>>>>>>
85742>>>>>>>
85742>>>>>>>        Function_Return bViewTableType
85743>>>>>>>    End_Function
85744>>>>>>>
85744>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85744>>>>>>>    //
85744>>>>>>>    // SQL utility function that returns a database type (string) constant
85744>>>>>>>    // corresponding to the passed iDbType.
85744>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85746>>>>>>>        String sRetval
85746>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85747>>>>>>>        Function_Return sRetval
85748>>>>>>>    End_Function
85749>>>>>>>
85749>>>>>>>    // SQL utility function that returns a database type constant (integer)
85749>>>>>>>    // corresponding to the passed sDbType string constant.
85749>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85751>>>>>>>        Integer iRetval
85751>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85752>>>>>>>        Function_Return iRetval
85753>>>>>>>    End_Function
85754>>>>>>>
85754>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85754>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85754>>>>>>>    // the SQL Connection program's grid.
85754>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85756>>>>>>>        String sRetval
85756>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85757>>>>>>>        Function_Return sRetval
85758>>>>>>>    End_Function
85759>>>>>>>
85759>>>>>>>    // Pass a driver name as a string and the function will return
85759>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85759>>>>>>>    // quite work and always returns "MS SQL Server"
85759>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85761>>>>>>>        Integer iRetval
85761>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85762>>>>>>>        Function_Return iRetval
85763>>>>>>>    End_Function
85764>>>>>>>
85764>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85764>>>>>>>    // that "fits" in the max allowed length for table names.
85764>>>>>>>    // Max number of characters allowed for table names;
85764>>>>>>>    // IBM DB2      = 128
85764>>>>>>>    // MS-SQL       = 128
85764>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85764>>>>>>>    // MySQL        = 64
85764>>>>>>>    // PostgreSQL   = 64
85764>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85766>>>>>>>        String sGUIDName
85766>>>>>>>        Integer iDbType iLength
85766>>>>>>>
85766>>>>>>>        Get piDbType to iDbType
85767>>>>>>>        Move (RandomHexUUID()) to sGUIDName
85768>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85769>>>>>>>        Move (Length(sGUIDName)) to iLength
85770>>>>>>>
85770>>>>>>>        Case Begin
85770>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85772>>>>>>>            If (iLength > 128) Begin
85774>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85775>>>>>>>            End
85775>>>>>>>>
85775>>>>>>>            Case Break
85776>>>>>>>
85776>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85779>>>>>>>            If (iLength > 128) Begin
85781>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85782>>>>>>>            End
85782>>>>>>>>
85782>>>>>>>            Case Break
85783>>>>>>>
85783>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85786>>>>>>>            If (iLength > 128) Begin
85788>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85789>>>>>>>            End
85789>>>>>>>>
85789>>>>>>>            Case Break
85790>>>>>>>
85790>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85793>>>>>>>            If (iLength > 64) Begin
85795>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85796>>>>>>>            End
85796>>>>>>>>
85796>>>>>>>            Case Break
85797>>>>>>>
85797>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85800>>>>>>>            If (iLength > 64) Begin
85802>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85803>>>>>>>            End
85803>>>>>>>>
85803>>>>>>>        Case End
85803>>>>>>>
85803>>>>>>>        Function_Return sGUIDName
85804>>>>>>>    End_Function
85805>>>>>>>
85805>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85805>>>>>>>    // Pass the memory resource file reference and the filename to be created,
85805>>>>>>>    // including full path.
85805>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85807>>>>>>>        String sText
85807>>>>>>>        Integer iCh iSize iArgSize
85807>>>>>>>
85807>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85808>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85809>>>>>>>        Get_Channel_Size iCh to iSize
85810>>>>>>>        Read_Block channel iCh sText iSize
85812>>>>>>>        Send Seq_Close_Channel iCh
85813>>>>>>>
85813>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
85814>>>>>>>            Write channel iCh sText
85816>>>>>>>        Send Seq_Close_Channel iCh
85817>>>>>>>
85817>>>>>>>        // Wait for file to be written to disk.
85817>>>>>>>        Sleep 2
85818>>>>>>>    End_Procedure
85819>>>>>>>
85819>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85821>>>>>>>        String sNotNull sRetval sDefaultValue
85821>>>>>>>        Boolean bOK
85821>>>>>>>
85821>>>>>>>        Get IsSQLDriver sDriverID to bOK
85822>>>>>>>        If (bOK = False) Begin
85824>>>>>>>            Function_Return ""
85825>>>>>>>        End
85825>>>>>>>>
85825>>>>>>>
85825>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85826>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85827>>>>>>>
85827>>>>>>>        Case Begin
85827>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85829>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85830>>>>>>>                Case Break
85831>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85834>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85835>>>>>>>                Case Break
85836>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85839>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85840>>>>>>>                Case Break
85841>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85844>>>>>>>                Move (String(sNotNull))                                     to sRetval
85845>>>>>>>                Case Break
85846>>>>>>>
85846>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85846>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85846>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85849>>>>>>>                Move  ""                                                    to sRetval
85850>>>>>>>                Case Break
85851>>>>>>>
85851>>>>>>>            Case Else
85851>>>>>>>                Move  ""                                                    to sRetval
85852>>>>>>>        Case End
85852>>>>>>>
85852>>>>>>>        Function_Return sRetval
85853>>>>>>>    End_Function
85854>>>>>>>
85854>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85854>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85856>>>>>>>        Function_Return False
85857>>>>>>>    End_Function
85858>>>>>>>
85858>>>>>>>    // Enumerate SQL Servers.
85858>>>>>>>    // Pass a driver id. Returns a string array.
85858>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85858>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85858>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85860>>>>>>>        String[] sReturnArray
85861>>>>>>>        Handle hoSQLHandler
85861>>>>>>>        String sServer
85861>>>>>>>        Integer iCount iNumItems iDataSourceType
85861>>>>>>>
85861>>>>>>>        If (num_arguments > 1) Begin
85863>>>>>>>            Move iDatSrcType to iDataSourceType
85864>>>>>>>        End
85864>>>>>>>>
85864>>>>>>>
85864>>>>>>>        Case Begin
85864>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85866>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
85867>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
85868>>>>>>>                For iCount from 0 to (iNumItems - 1)
85874>>>>>>>>
85874>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
85875>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85876>>>>>>>                Loop
85877>>>>>>>>
85877>>>>>>>                Case Break
85878>>>>>>>
85878>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85881>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
85882>>>>>>>                Send SeedDataSources of hoSQLHandler
85883>>>>>>>                Move 0 to iCount
85884>>>>>>>                Repeat
85884>>>>>>>>
85884>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85885>>>>>>>                    If (sServer <> "") Begin
85887>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
85888>>>>>>>                        Move sServer to sReturnArray[iCount]
85889>>>>>>>                    End
85889>>>>>>>>
85889>>>>>>>                    Increment iCount
85890>>>>>>>                Until (sServer = "")
85892>>>>>>>                Case Break
85893>>>>>>>
85893>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85896>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
85897>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85898>>>>>>>                Move 0 to iCount
85899>>>>>>>                Repeat
85899>>>>>>>>
85899>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85900>>>>>>>                    If (sServer <> "") Begin
85902>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
85903>>>>>>>                        Move sServer to sReturnArray[iCount]
85904>>>>>>>                    End
85904>>>>>>>>
85904>>>>>>>                    Increment iCount
85905>>>>>>>                Until (sServer = "")
85907>>>>>>>                Case Break
85908>>>>>>>
85908>>>>>>>            Case Else
85908>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85909>>>>>>>>
85909>>>>>>>        Case End
85909>>>>>>>
85909>>>>>>>        Function_Return sReturnArray
85910>>>>>>>    End_Function
85911>>>>>>>
85911>>>>>>>    // Returns all databases as a string array for the passed driver id.
85911>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85913>>>>>>>        String[] sReturnArray
85914>>>>>>>        String sServer sVal
85914>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85914>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85915>>>>>>>        tSQLConnection SQLConnection
85915>>>>>>>        tSQLConnection SQLConnection
85915>>>>>>>        Boolean bOK
85915>>>>>>>        Integer iCount iSize
85915>>>>>>>
85915>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85916>>>>>>>        If (bOK = False) Begin
85918>>>>>>>            Function_Return sReturnArray
85919>>>>>>>        End
85919>>>>>>>>
85919>>>>>>>
85919>>>>>>>        Case Begin
85919>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85921>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85922>>>>>>>                Case Break
85923>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85926>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85927>>>>>>>                Case Break
85928>>>>>>>
85928>>>>>>>            // This is needed to be able to check if a database exists or not.
85928>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85931>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
85932>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
85934>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
85936>>>>>>>                        // If a FILEDSN: (can only be one database name)
85936>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
85937>>>>>>>                    End
85937>>>>>>>>
85937>>>>>>>                    Else Begin
85938>>>>>>>                        // Else the DSN's were read from the registry.
85938>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85939>>>>>>>                        Move SQLConnection.sServer to sServer
85940>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
85941>>>>>>>                        Decrement iSize
85942>>>>>>>                        for iCount from 0 to iSize
85948>>>>>>>>
85948>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
85949>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
85951>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
85952>>>>>>>                                Move iSize to iCount // We're done.
85953>>>>>>>                            End
85953>>>>>>>>
85953>>>>>>>                        Loop
85954>>>>>>>>
85954>>>>>>>                    End
85954>>>>>>>>
85954>>>>>>>                End
85954>>>>>>>>
85954>>>>>>>                Case Break
85955>>>>>>>
85955>>>>>>>            Case Else
85955>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85955>>>>>>>        Case End
85955>>>>>>>
85955>>>>>>>        Function_Return sReturnArray
85956>>>>>>>    End_Function
85957>>>>>>>
85957>>>>>>>    
85957>>>>>>>    // *** Database API Functions: ***
85957>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85957>>>>>>>    // make changes/updates to the database.
85957>>>>>>>
85957>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85957>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85959>>>>>>>        Function_Return False
85960>>>>>>>    End_Function
85961>>>>>>>
85961>>>>>>>    // This might not do what you think - Here's what it does:
85961>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85961>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85961>>>>>>>    // to the SQL table.
85961>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85961>>>>>>>    // already exists in SQL.
85961>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85961>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85961>>>>>>>    // restructuring an existing table.
85961>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85963>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
85963>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85963>>>>>>>        Handle hToTable
85963>>>>>>>
85963>>>>>>>        Move True to bUseConnectionID
85964>>>>>>>        If (num_arguments > 1) Begin
85966>>>>>>>            Move bUseConnID to bUseConnectionID
85967>>>>>>>        End
85967>>>>>>>>
85967>>>>>>>
85967>>>>>>>        Get psDriverID to sDriverID
85968>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85968>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85969>>>>>>>        If (bExists = False) Begin
85971>>>>>>>            Function_Return False
85972>>>>>>>        End
85972>>>>>>>>
85972>>>>>>>
85972>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
85973>>>>>>>
85973>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85974>>>>>>>        If (bOK = False) Begin
85976>>>>>>>            Function_Return False
85977>>>>>>>        End
85977>>>>>>>>
85977>>>>>>>
85977>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
85977>>>>>>>        // we do nothing
85977>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85978>>>>>>>        If (bExists = True) Begin
85980>>>>>>>            Function_Return False
85981>>>>>>>        End
85981>>>>>>>>
85981>>>>>>>
85981>>>>>>>        Get psConnectionID     to sConnectionID
85982>>>>>>>        Get psConnectionString to sConnectionString
85983>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85985>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85986>>>>>>>>
85986>>>>>>>            Function_Return False
85987>>>>>>>        End
85987>>>>>>>>
85987>>>>>>>
85987>>>>>>>        Set Private.phCurrentTable to hTable
85988>>>>>>>        Get psSchema to sSchema
85989>>>>>>>        If (sSchema = "") Begin
85991>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85992>>>>>>>        End
85992>>>>>>>>
85992>>>>>>>
85992>>>>>>>        // If we should use a connection id we need to check it exists;
85992>>>>>>>        // else we create it before attempting creating the table
85992>>>>>>>        If (bUseConnectionID = True) Begin
85994>>>>>>>            Get AutoConnectionIDLogin to bOK
85995>>>>>>>            If (bOk = False) Begin
85997>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85998>>>>>>>>
85998>>>>>>>                Function_Return False
85999>>>>>>>            End
85999>>>>>>>>
85999>>>>>>>        End
85999>>>>>>>>
85999>>>>>>>
85999>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86002>>>>>>>        Get _TableNameOnly sRootName to sRootName
86003>>>>>>>        If (sRootName = "") Begin
86005>>>>>>>            Function_Return False
86006>>>>>>>        End
86006>>>>>>>>
86006>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86007>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86010>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86013>>>>>>>
86013>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86013>>>>>>>        //
86013>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86013>>>>>>>        // because then the table should not be visible to users.
86013>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86013>>>>>>>//        If (iPos <> 1) Begin
86013>>>>>>>//            If (sDisplayName contains ".") Begin
86013>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86013>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86013>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86013>>>>>>>//            End
86013>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86013>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86013>>>>>>>//            End
86013>>>>>>>//        End
86013>>>>>>>
86013>>>>>>>        If (bIsAlias = False) Begin
86015>>>>>>>            Get OpenTableExclusive hTable to bOpened
86016>>>>>>>            If (bOpened = False) Begin
86018>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86019>>>>>>>>
86019>>>>>>>                Function_Return False
86020>>>>>>>            End
86020>>>>>>>>
86020>>>>>>>        End
86020>>>>>>>>
86020>>>>>>>
86020>>>>>>>        If (ghoProgressBar <> 0) Begin
86022>>>>>>>            Send DoAdvance of ghoProgressBar
86023>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86024>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86025>>>>>>>        End
86025>>>>>>>>
86025>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86025>>>>>>>        Move hTable to hToTable
86026>>>>>>>        Move False to Err
86027>>>>>>>
86027>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86027>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86027>>>>>>>        // a proper and updated .int file.
86027>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86030>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86031>>>>>>>
86031>>>>>>>        If (bIsAlias = False) Begin
86033>>>>>>>            Structure_Start hToTable sDriverID
86034>>>>>>>                Set Private.phCurrentTable to hTable
86035>>>>>>>                If (bUseConnectionID = True) Begin
86037>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86040>>>>>>>                End
86040>>>>>>>>
86040>>>>>>>                Else Begin
86041>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86044>>>>>>>                End
86044>>>>>>>>
86044>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86047>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86047>>>>>>>                Move False to Err
86048>>>>>>>                Move 0 to LastErr
86049>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86050>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86052>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86053>>>>>>>        End
86053>>>>>>>>
86053>>>>>>>
86053>>>>>>>        Move (not(Err)) to bOK
86054>>>>>>>        If (bOK = True) Begin
86056>>>>>>>            // The attributes set above will always trigger an error
86056>>>>>>>            // We also adjust the Filelist entries
86056>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86059>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86062>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86065>>>>>>>
86065>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86065>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86066>>>>>>>        End
86066>>>>>>>>
86066>>>>>>>
86066>>>>>>>        Function_Return (bOK = True)
86067>>>>>>>    End_Function
86068>>>>>>>
86068>>>>>>>    // Sample usage:
86068>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86068>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86068>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86070>>>>>>>        Boolean bOK bIsSQLTable
86070>>>>>>>
86070>>>>>>>        Get AutoConnectionIDLogin to bOK
86071>>>>>>>        Move False to Err
86072>>>>>>>        Get OpenTableExclusive hTable to bOK
86073>>>>>>>        If (bOK = False) Begin
86075>>>>>>>            Function_Return False
86076>>>>>>>        End
86076>>>>>>>>
86076>>>>>>>
86076>>>>>>>        // ToDo: Add to all table change functions!
86076>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86077>>>>>>>            If (bIsSQLTable = True) Begin
86079>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86082>>>>>>>            End
86082>>>>>>>>
86082>>>>>>>
86082>>>>>>>        Set Private.phCurrentTable to hTable
86083>>>>>>>        Structure_Start hTable
86084>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86087>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86088>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86090>>>>>>>
86090>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86091>>>>>>>        Function_Return (Err = False)
86092>>>>>>>    End_Function
86093>>>>>>>
86093>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86095>>>>>>>        Boolean bOK
86095>>>>>>>        
86095>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86096>>>>>>>        If (bOK = True) Begin
86098>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86099>>>>>>>        End
86099>>>>>>>>
86099>>>>>>>        
86099>>>>>>>        Function_Return (bOK = True)
86100>>>>>>>    End_Function
86101>>>>>>>    
86101>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86101>>>>>>>    // or to change the filelist slot names.
86101>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86103>>>>>>>        String sFileListName
86103>>>>>>>        
86103>>>>>>>        Move False to Err
86104>>>>>>>
86104>>>>>>>        If (ghoProgressBar <> 0) Begin
86106>>>>>>>            Send DoAdvance of ghoProgressBar
86107>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86108>>>>>>>        End
86108>>>>>>>>
86108>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86108>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86110>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86113>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86116>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86119>>>>>>>            Function_Return (Err = False) // And we're done.
86120>>>>>>>        End
86120>>>>>>>>
86120>>>>>>>
86120>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86122>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86122>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86123>>>>>>>        End
86123>>>>>>>>
86123>>>>>>>//        Else Begin
86123>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86123>>>>>>>//        End
86123>>>>>>>//
86123>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86123>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86123>>>>>>>
86123>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86126>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86129>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86132>>>>>>>        
86132>>>>>>>        Function_Return (Err = False)
86133>>>>>>>    End_Function
86134>>>>>>>
86134>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86136>>>>>>>        Boolean bOK
86136>>>>>>>
86136>>>>>>>        Get AutoConnectionIDLogin to bOK
86137>>>>>>>        Move False to Err
86138>>>>>>>        Get OpenTableExclusive hTable to bOK
86139>>>>>>>        If (bOK = False) Begin
86141>>>>>>>            Function_Return False
86142>>>>>>>        End
86142>>>>>>>>
86142>>>>>>>
86142>>>>>>>        Set Private.phCurrentTable to hTable
86143>>>>>>>        Structure_Start hTable
86144>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86147>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86148>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86150>>>>>>>
86150>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86151>>>>>>>        Function_Return (Err = False)
86152>>>>>>>    End_Function
86153>>>>>>>
86153>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86155>>>>>>>        Boolean bOK bIsSQLTable
86155>>>>>>>
86155>>>>>>>        Move False to Err
86156>>>>>>>        Get AutoConnectionIDLogin to bOK
86157>>>>>>>        Open hToTable
86159>>>>>>>        Get OpenTableExclusive hTable to bOK
86160>>>>>>>        If (bOK = False) Begin
86162>>>>>>>            Function_Return False
86163>>>>>>>        End
86163>>>>>>>>
86163>>>>>>>
86163>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86164>>>>>>>            If (bIsSQLTable = True) Begin
86166>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86169>>>>>>>            End
86169>>>>>>>>
86169>>>>>>>
86169>>>>>>>        Set Private.phCurrentTable to hTable
86170>>>>>>>        Structure_Start hTable
86171>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86174>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86177>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86178>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86180>>>>>>>
86180>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86181>>>>>>>        Function_Return (Err = False)
86182>>>>>>>    End_Function
86183>>>>>>>
86183>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86185>>>>>>>        Integer[] aTableConvertExceptions
86186>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86187>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86188>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86189>>>>>>>    End_Procedure
86190>>>>>>>
86190>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86192>>>>>>>        Integer[] aTableDateCorrectionExceptions
86193>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86194>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86195>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86196>>>>>>>    End_Procedure
86197>>>>>>>
86197>>>>>>>    Procedure ApiTableConvertALLToSql
86199>>>>>>>        Integer[] iTablesArray
86200>>>>>>>        Integer iSize iCount
86200>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86200>>>>>>>        String sDriverID
86200>>>>>>>
86200>>>>>>>        Get psDriverID to sDriverID
86201>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86202>>>>>>>        Get pbToANSI          to bToANSI
86203>>>>>>>        Get pbRecnum          to bRecnum
86204>>>>>>>        Get pbCopyData        to bCopyData
86205>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86207>>>>>>>            Get pbContinueOnError to bContinueOnError
86208>>>>>>>        End
86208>>>>>>>>
86208>>>>>>>
86208>>>>>>>        Get _AllTablesToConvert to iTablesArray
86209>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86210>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86211>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86212>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86213>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86214>>>>>>>
86214>>>>>>>        Decrement iSize
86215>>>>>>>        For iCount from 0 to iSize
86221>>>>>>>>
86221>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86222>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86223>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86223>>>>>>>            // if there was an error converting one table...
86223>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86223>>>>>>>        Loop
86224>>>>>>>>
86224>>>>>>>
86224>>>>>>>    End_Procedure
86225>>>>>>>
86225>>>>>>>    Procedure ApiTableAttachALLToSql
86227>>>>>>>        Integer[] iTablesArray
86228>>>>>>>        Integer iSize iCount
86228>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86228>>>>>>>        String sDriverID
86228>>>>>>>
86228>>>>>>>        Get psDriverID to sDriverID
86229>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86230>>>>>>>        Get pbToANSI          to bToANSI
86231>>>>>>>        Get pbRecnum          to bRecnum
86232>>>>>>>        Get pbCopyData        to bCopyData
86233>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86235>>>>>>>            Get pbContinueOnError to bContinueOnError
86236>>>>>>>        End
86236>>>>>>>>
86236>>>>>>>
86236>>>>>>>        Get _AllTablesToConvert to iTablesArray
86237>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86238>>>>>>>        Decrement iSize
86239>>>>>>>        For iCount from 0 to iSize
86245>>>>>>>>
86245>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86246>>>>>>>        Loop
86247>>>>>>>>
86247>>>>>>>
86247>>>>>>>    End_Procedure
86248>>>>>>>
86248>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86250>>>>>>>        Handle hToTable hoLogFile
86250>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86250>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86250>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86250>>>>>>>        tSQLConnection SQLConnection
86250>>>>>>>        tSQLConnection SQLConnection
86250>>>>>>>
86250>>>>>>>        Get _UtilTableExists hTable to bExists
86251>>>>>>>        If (bExists = False) Begin
86253>>>>>>>            Set Private.phCurrentTable to hTable
86254>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86255>>>>>>>>
86255>>>>>>>            Function_Return False
86256>>>>>>>        End
86256>>>>>>>>
86256>>>>>>>
86256>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86257>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86257>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86257>>>>>>>        If (bIsAlias = True) Begin
86259>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86262>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86264>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86267>>>>>>>                Get psConnectionID to sConnectionID
86268>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86269>>>>>>>            End
86269>>>>>>>>
86269>>>>>>>            Function_Return True
86270>>>>>>>        End
86270>>>>>>>>
86270>>>>>>>
86270>>>>>>>        Set Private.phCurrentTable to hTable
86271>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86274>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86277>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86280>>>>>>>
86280>>>>>>>        If (ghoProgressBar <> 0) Begin
86282>>>>>>>            Send DoAdvance of ghoProgressBar
86283>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86284>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86285>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86286>>>>>>>        End
86286>>>>>>>>
86286>>>>>>>
86286>>>>>>>        // Marco Kuipers suggestion;
86286>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86286>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86286>>>>>>>        // SQL table.
86286>>>>>>>        Get _UtilTableIsSql hTable to bOK
86287>>>>>>>        If (bOK = False) Begin
86289>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86290>>>>>>>            If (bExists = True) Begin
86292>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86292>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86292>>>>>>>                Get phoLogFile to hoLogFile
86293>>>>>>>                If (hoLogFile <> 0) Begin          
86295>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86296>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86296>>>>>>>                    Send LogError sWarning False
86297>>>>>>>                End
86297>>>>>>>>
86297>>>>>>>                Else Begin
86298>>>>>>>                    Error DFERR_PROGRAM sWarning
86299>>>>>>>>
86299>>>>>>>                End                                                       
86299>>>>>>>>
86299>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86300>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86301>>>>>>>            End
86301>>>>>>>>
86301>>>>>>>        End
86301>>>>>>>>
86301>>>>>>>
86301>>>>>>>        // Does the rootname contain a driver?
86301>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86303>>>>>>>            // Does the table already exist as an SQL table?
86303>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86304>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86304>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86304>>>>>>>            If (bExists = False) Begin
86306>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86307>>>>>>>            End
86307>>>>>>>>
86307>>>>>>>            If (bExists = True) Begin
86309>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86310>>>>>>>                Function_Return False
86311>>>>>>>            End
86311>>>>>>>>
86311>>>>>>>        End
86311>>>>>>>>
86311>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86312>>>>>>>
86312>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86313>>>>>>>        If (bUseConnectionID = True) Begin
86315>>>>>>>            Move False to bUseConnectionID
86316>>>>>>>        End
86316>>>>>>>>
86316>>>>>>>
86316>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86317>>>>>>>        Move SQLConnection.sSchema           to sSchema
86318>>>>>>>        If (sSchema = "") Begin
86320>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86321>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86322>>>>>>>        End
86322>>>>>>>>
86322>>>>>>>
86322>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86323>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86324>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86325>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86327>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86328>>>>>>>>
86328>>>>>>>            Function_Return False
86329>>>>>>>        End
86329>>>>>>>>
86329>>>>>>>
86329>>>>>>>        Get AutoConnectionIDLogin to bOK
86330>>>>>>>        Open hTable
86332>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86335>>>>>>>        If (bOpened = False) Begin
86337>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86338>>>>>>>>
86338>>>>>>>            Function_Return False
86339>>>>>>>        End
86339>>>>>>>>
86339>>>>>>>
86339>>>>>>>        If (ghoProgressBar <> 0) Begin
86341>>>>>>>            Send DoAdvance of ghoProgressBar
86342>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86343>>>>>>>        End
86343>>>>>>>>
86343>>>>>>>
86343>>>>>>>        Move 0 to hToTable
86344>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86345>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86346>>>>>>>
86346>>>>>>>        Case Begin
86346>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86348>>>>>>>                Case Break
86349>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86352>>>>>>>                Case Break
86353>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86356>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86357>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86358>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86359>>>>>>>                Case Break
86360>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86363>>>>>>>                Case Break
86364>>>>>>>            Case Else
86364>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86365>>>>>>>>
86365>>>>>>>                Case Break
86366>>>>>>>        Case End
86366>>>>>>>
86366>>>>>>>        Move False to Err
86367>>>>>>>
86367>>>>>>>        Structure_Start hToTable sDriverID
86368>>>>>>>            Structure_Copy hTable to hToTable
86369>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86372>>>>>>>
86372>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86374>>>>>>>                If (bUseConnectionID = True) Begin
86376>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86379>>>>>>>                End
86379>>>>>>>>
86379>>>>>>>                Else Begin
86380>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86383>>>>>>>                End
86383>>>>>>>>
86383>>>>>>>
86383>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86386>>>>>>>
86386>>>>>>>                If (sSchema <> "") Begin
86388>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86391>>>>>>>                End
86391>>>>>>>>
86391>>>>>>>
86391>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86393>>>>>>>                    If (sLongTableSpace <> "") Begin
86395>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86398>>>>>>>                    End
86398>>>>>>>>
86398>>>>>>>                    If (sBaseTableSpace <> "") Begin
86400>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86403>>>>>>>                    End
86403>>>>>>>>
86403>>>>>>>                    If (sIndexTableSpace <> "") Begin
86405>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86408>>>>>>>                    End
86408>>>>>>>>
86408>>>>>>>                End
86408>>>>>>>>
86408>>>>>>>            End
86408>>>>>>>>
86408>>>>>>>
86408>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86409>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86411>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86412>>>>>>>
86412>>>>>>>        Move (not(Err)) to bOK
86413>>>>>>>
86413>>>>>>>        If (bOK = True and bCopyData = True) Begin
86415>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86416>>>>>>>
86416>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86418>>>>>>>                Get pbContinueOnError to bContinueOnError
86419>>>>>>>            End
86419>>>>>>>>
86419>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86419>>>>>>>            // rename it by adding a GUID to the end of the table name
86419>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86419>>>>>>>            // different rules how long a table name can be.
86419>>>>>>>            // The new table will probably contain data but something went
86419>>>>>>>            // wrong while converting the data from embedded to SQL.
86419>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86421>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86422>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86423>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86424>>>>>>>>
86424>>>>>>>            End
86424>>>>>>>>
86424>>>>>>>        End
86424>>>>>>>>
86424>>>>>>>
86424>>>>>>>        // This must be after copying data...
86424>>>>>>>        If (Err = False) Begin
86426>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86429>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86429>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86429>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86429>>>>>>>            //                // The max length for the display_name is 31 characters...
86429>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86429>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86429>>>>>>>            //                End
86429>>>>>>>            //            End
86429>>>>>>>        End
86429>>>>>>>>
86429>>>>>>>
86429>>>>>>>        Close hTable
86430>>>>>>>        Move (not(Err)) to bOK
86431>>>>>>>        Function_Return bOK
86432>>>>>>>    End_Function
86433>>>>>>>
86433>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86433>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86433>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86433>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86435>>>>>>>        Boolean bOpened bOK
86435>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86435>>>>>>>        String sErrorFile sEmpty sPath
86435>>>>>>>
86435>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86438>>>>>>>        Get AutoConnectionIDLogin to bOK
86439>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86441>>>>>>>            Send IncreaseSortBufferSize
86442>>>>>>>//            Send SetAllIndexesToBatch hToTable
86442>>>>>>>        End
86442>>>>>>>>
86442>>>>>>>
86442>>>>>>>        Move False to Err
86443>>>>>>>        Open sPhysicalName as hToTable
86445>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86448>>>>>>>        If (bOpened = False) Begin
86450>>>>>>>            Function_Return False
86451>>>>>>>        End
86451>>>>>>>>
86451>>>>>>>
86451>>>>>>>        If (ghoStatusPanel <> 0) Begin
86453>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86454>>>>>>>            Set piMinimum of ghoProgressBar to 0
86455>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86456>>>>>>>        End
86456>>>>>>>>
86456>>>>>>>
86456>>>>>>>        Move "" to sEmpty
86457>>>>>>>        Move False to Err
86458>>>>>>>        Move True to bOK
86459>>>>>>>        Set Private.phCurrentTable to hToTable
86460>>>>>>>
86460>>>>>>>        // No need to get the record identifier
86460>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86463>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86466>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86468>>>>>>>            // Remove all indices to speed up copying of data:
86468>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86473>>>>>>>            If (iRetval <> 0) Begin       
86475>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86476>>>>>>>>
86476>>>>>>>                Close hToTable
86477>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86480>>>>>>>                Function_Return False
86481>>>>>>>            End
86481>>>>>>>>
86481>>>>>>>        End
86481>>>>>>>>
86481>>>>>>>
86481>>>>>>>        Move (sRootName + ".err") to sErrorFile
86482>>>>>>>        Move 0 to iIndex
86483>>>>>>>        Move False to Err
86484>>>>>>>
86484>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86486>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86489>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86494>>>>>>>            If (iRetval <> 0) Begin
86496>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86497>>>>>>>>
86497>>>>>>>                Close hToTable
86498>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86501>>>>>>>                Function_Return False
86502>>>>>>>            End
86502>>>>>>>>
86502>>>>>>>        End
86502>>>>>>>>
86502>>>>>>>        Else Begin
86503>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86506>>>>>>>        End
86506>>>>>>>>
86506>>>>>>>
86506>>>>>>>        If (Err = False) Begin
86508>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86509>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86510>>>>>>>        End
86510>>>>>>>>
86510>>>>>>>
86510>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86512>>>>>>>            // Recreate indices:
86512>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86517>>>>>>>            If (iRetval <> 0) Begin
86519>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86520>>>>>>>>
86520>>>>>>>                Close hToTable
86521>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86524>>>>>>>                Function_Return False
86525>>>>>>>            End
86525>>>>>>>>
86525>>>>>>>        End
86525>>>>>>>>
86525>>>>>>>
86525>>>>>>>        Close hToTable
86526>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86529>>>>>>>
86529>>>>>>>        If (bOK = True) Begin
86531>>>>>>>            Move (not(Err)) to bOK
86532>>>>>>>        End
86532>>>>>>>>
86532>>>>>>>
86532>>>>>>>        If (ghoStatusPanel <> 0) Begin
86534>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86535>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86536>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86537>>>>>>>        End
86537>>>>>>>>
86537>>>>>>>
86537>>>>>>>        Function_Return (bOK = True)
86538>>>>>>>    End_Function
86539>>>>>>>
86539>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86539>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86539>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86541>>>>>>>        Handle hFile
86541>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86541>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86541>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86541>>>>>>>        tSQLConnection SQLConnection
86541>>>>>>>        tSQLConnection SQLConnection
86541>>>>>>>        tAPIColumn[] aColumns
86541>>>>>>>        tAPIColumn[] aColumns
86542>>>>>>>        tColumnType ColumnType
86542>>>>>>>        tColumnType ColumnType
86542>>>>>>>
86542>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86542>>>>>>>        Get _UtilTableExists hTable to bOk
86543>>>>>>>        If (bOk = True) Begin
86545>>>>>>>            Function_Return False
86546>>>>>>>        End
86546>>>>>>>>
86546>>>>>>>
86546>>>>>>>        Set Private.phCurrentTable to hTable
86547>>>>>>>        Move sLogicalName to sTableName
86548>>>>>>>        If (ghoProgressBar <> 0) Begin
86550>>>>>>>            Send DoAdvance of ghoProgressBar
86551>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86552>>>>>>>        End
86552>>>>>>>>
86552>>>>>>>
86552>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86553>>>>>>>        Get psDriverID to sDriverID
86554>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86555>>>>>>>        Get piDbType to iDbType
86556>>>>>>>
86556>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86556>>>>>>>        Move False to bDeleteDummy
86557>>>>>>>        If (Num_Arguments = 8) Begin
86559>>>>>>>            Move aColumnIn to aColumns
86560>>>>>>>        End
86560>>>>>>>>
86560>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86562>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86563>>>>>>>            Move ColumnType.iSQLType to iDataType
86564>>>>>>>            If (bRecnum = False) Begin
86566>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86567>>>>>>>            End
86567>>>>>>>>
86567>>>>>>>            Else Begin
86568>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86569>>>>>>>            End
86569>>>>>>>>
86569>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86570>>>>>>>            Move True to bDeleteDummy
86571>>>>>>>        End
86571>>>>>>>>
86571>>>>>>>
86571>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86571>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86571>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86571>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86571>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86573>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86574>>>>>>>            Decrement iSize
86575>>>>>>>            for iCount from 0 to iSize
86581>>>>>>>>
86581>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86583>>>>>>>                    Move False to bRecnum
86584>>>>>>>                    Move iSize to iCount
86585>>>>>>>                End
86585>>>>>>>>
86585>>>>>>>            Loop
86586>>>>>>>>
86586>>>>>>>        End
86586>>>>>>>>
86586>>>>>>>
86586>>>>>>>        // If this is a SQL based driver we also check if the table exists
86586>>>>>>>        // in the SQL back end; in case we do nothing.
86586>>>>>>>        If (bSqlDriver = True) Begin
86588>>>>>>>            // Get all connection properties
86588>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86589>>>>>>>            Move SQLConnection.sSchema to sSchema
86590>>>>>>>            If (sSchema = "") Begin
86592>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86593>>>>>>>            End
86593>>>>>>>>
86593>>>>>>>
86593>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86594>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86594>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86594>>>>>>>            If (bExists = False) Begin
86596>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86597>>>>>>>            End
86597>>>>>>>>
86597>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86597>>>>>>>            // we will just add it to Filelist.cfg
86597>>>>>>>            If (bExists = True) Begin
86599>>>>>>>                If (bExistsInFilelist = False) Begin
86601>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86603>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86604>>>>>>>                    End
86604>>>>>>>>
86604>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86607>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86610>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86613>>>>>>>                    Move False to bSysFile
86614>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86615>>>>>>>                End
86615>>>>>>>>
86615>>>>>>>                Function_Return False
86616>>>>>>>            End
86616>>>>>>>>
86616>>>>>>>        End
86616>>>>>>>>
86616>>>>>>>
86616>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86617>>>>>>>        If (num_arguments > 6) Begin
86619>>>>>>>            If (bANSI = False) Begin
86621>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86622>>>>>>>            End
86622>>>>>>>>
86622>>>>>>>        End
86622>>>>>>>>
86622>>>>>>>
86622>>>>>>>        Move False to Err
86623>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86625>>>>>>>            Move sRootName to sPhysicalFile
86626>>>>>>>        End
86626>>>>>>>>
86626>>>>>>>
86626>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86628>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86629>>>>>>>
86629>>>>>>>            // If DAW driver and we should use a connection id we need to
86629>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86629>>>>>>>            If (bUseConnectionID = True) Begin
86631>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86632>>>>>>>                If (bExists = False) Begin
86634>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86635>>>>>>>                    If (bOk = False) Begin
86637>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86638>>>>>>>>
86638>>>>>>>                        Function_Return False
86639>>>>>>>                    End
86639>>>>>>>>
86639>>>>>>>                End
86639>>>>>>>>
86639>>>>>>>            End
86639>>>>>>>>
86639>>>>>>>
86639>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86641>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86642>>>>>>>            End
86642>>>>>>>>
86642>>>>>>>            Else Begin
86643>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86644>>>>>>>            End
86644>>>>>>>>
86644>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86645>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86645>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86645>>>>>>>//            End
86645>>>>>>>        End
86645>>>>>>>>
86645>>>>>>>        Move False to Err
86646>>>>>>>        Move 0 to hFile
86647>>>>>>>
86647>>>>>>>        Structure_Start hFile sDriverID
86648>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86650>>>>>>>                If (bUseConnectionID = True) Begin
86652>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86655>>>>>>>                End
86655>>>>>>>>
86655>>>>>>>                Else Begin
86656>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86659>>>>>>>                End
86659>>>>>>>>
86659>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86662>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86665>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86668>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86671>>>>>>>
86671>>>>>>>                If (sSchema <> "") Begin
86673>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86676>>>>>>>                End
86676>>>>>>>>
86676>>>>>>>
86676>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86678>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86680>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86683>>>>>>>                    End
86683>>>>>>>>
86683>>>>>>>                End
86683>>>>>>>>
86683>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86685>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86687>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86690>>>>>>>                    End
86690>>>>>>>>
86690>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86692>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86695>>>>>>>                    End
86695>>>>>>>>
86695>>>>>>>                End
86695>>>>>>>>
86695>>>>>>>            End
86695>>>>>>>>
86695>>>>>>>
86695>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86698>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86699>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86700>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86702>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86703>>>>>>>
86703>>>>>>>        Move (not(Err)) to bOK
86704>>>>>>>        If (bOk = True) Begin
86706>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86708>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86709>>>>>>>            End
86709>>>>>>>>
86709>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86712>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86715>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86718>>>>>>>
86718>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86718>>>>>>>            If (bDeleteDummy) Begin
86720>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86721>>>>>>>            End
86721>>>>>>>>
86721>>>>>>>        End
86721>>>>>>>>
86721>>>>>>>
86721>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86722>>>>>>>        Close hTable
86723>>>>>>>        Function_Return (bOK = True)
86724>>>>>>>    End_Function
86725>>>>>>>
86725>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86727>>>>>>>        Move False to Err
86728>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86731>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86734>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86737>>>>>>>
86737>>>>>>>        Function_Return (Err = False)
86738>>>>>>>    End_Function
86739>>>>>>>
86739>>>>>>>    // ToDo: Needs to be revised
86739>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86741>>>>>>>        Handle hTable
86741>>>>>>>        String sDEFName sDataPath
86741>>>>>>>        Boolean bExists
86741>>>>>>>
86741>>>>>>>        // Do nothing if MSSQL Driver.
86741>>>>>>>//        Get IsMSSQLDriver to bExists
86741>>>>>>>//        If (bExists = True) Begin
86741>>>>>>>//            Procedure_Return
86741>>>>>>>//        End
86741>>>>>>>
86741>>>>>>>        Get psDataPathFirstPart to sDataPath
86742>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86743>>>>>>>        If (bExists = True) Begin
86745>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86745>>>>>>>            // still be missing from the filelist and needs to be added.
86745>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86746>>>>>>>            If (bExists = True) Begin
86748>>>>>>>                Procedure_Return
86749>>>>>>>            End
86749>>>>>>>>
86749>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86749>>>>>>>            Else Begin
86750>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86753>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86756>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86759>>>>>>>                Procedure_Return
86760>>>>>>>            End
86760>>>>>>>>
86760>>>>>>>        End
86760>>>>>>>>
86760>>>>>>>
86760>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86761>>>>>>>        Move 0 to hTable
86762>>>>>>>        Move False to Err
86763>>>>>>>
86763>>>>>>>        Structure_Start hTable DATAFLEX_ID
86764>>>>>>>            Load_Def sDEFName Onto hTable
86765>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86768>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86769>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86771>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86772>>>>>>>
86772>>>>>>>        Move iFilelistSlot to hTable
86773>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86776>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86779>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86782>>>>>>>
86782>>>>>>>    End_Procedure
86783>>>>>>>
86783>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86785>>>>>>>        Boolean bTmp bErr bOK
86785>>>>>>>        String sTableName sDisplayName sFileName
86785>>>>>>>
86785>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86785>>>>>>>        Move Err to bTmp
86786>>>>>>>        Move False to Err
86787>>>>>>>
86787>>>>>>>        Get AutoConnectionIDLogin to bOK
86788>>>>>>>        // First get the info for the current filelist slot:
86788>>>>>>>        Open iFromFileSlot
86790>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86793>>>>>>>        If (bOK = True) Begin
86795>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86798>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86801>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86804>>>>>>>
86804>>>>>>>            //...then move it.
86804>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86807>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86810>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86813>>>>>>>
86813>>>>>>>            //...and finally remove the old filelist values.
86813>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86816>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86819>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86822>>>>>>>        End
86822>>>>>>>>
86822>>>>>>>        Close iFromFileSlot
86823>>>>>>>
86823>>>>>>>        Move Err to bErr
86824>>>>>>>        Move bTmp to Err
86825>>>>>>>        Function_Return (bErr = False)
86826>>>>>>>    End_Function
86827>>>>>>>
86827>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86829>>>>>>>        Handle hTable
86829>>>>>>>        Boolean bOK
86829>>>>>>>        String sDriverID
86829>>>>>>>
86829>>>>>>>        Get _UtilTableExists hTableFrom to bOK
86830>>>>>>>        If (bOK = False) Begin
86832>>>>>>>            Set Private.phCurrentTable to hTableFrom
86833>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86834>>>>>>>>
86834>>>>>>>            Function_Return False
86835>>>>>>>        End
86835>>>>>>>>
86835>>>>>>>
86835>>>>>>>        Get _UtilTableExists hTableTo to bOK
86836>>>>>>>        If (bOK = False) Begin
86838>>>>>>>            Set Private.phCurrentTable to hTableTo
86839>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86840>>>>>>>>
86840>>>>>>>            Function_Return False
86841>>>>>>>        End
86841>>>>>>>>
86841>>>>>>>
86841>>>>>>>        Get AutoConnectionIDLogin to bOK
86842>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86843>>>>>>>        If (bOK = False) Begin
86845>>>>>>>            Function_Return False
86846>>>>>>>        End
86846>>>>>>>>
86846>>>>>>>
86846>>>>>>>        Move False to Err
86847>>>>>>>        Open hTableTo
86849>>>>>>>
86849>>>>>>>        Move hTableFrom to hTable
86850>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86853>>>>>>>        Set Private.phCurrentTable to hTable
86854>>>>>>>
86854>>>>>>>        Structure_Start hTable sDriverID
86855>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86858>>>>>>>            If (iColumnTo <> 0) Begin
86860>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86863>>>>>>>            End
86863>>>>>>>>
86863>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86864>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86866>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86867>>>>>>>
86867>>>>>>>        If (hTableTo > 0) Begin
86869>>>>>>>            Close hTableTo
86870>>>>>>>        End
86870>>>>>>>>
86870>>>>>>>
86870>>>>>>>        Function_Return (Err = False)
86871>>>>>>>    End_Function
86872>>>>>>>
86872>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86872>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
86874>>>>>>>        String sTableName sDriverID
86874>>>>>>>        Boolean bOk
86874>>>>>>>        String sDataPath
86874>>>>>>>
86874>>>>>>>        Get AutoConnectionIDLogin to bOK
86875>>>>>>>        Move False to Err
86876>>>>>>>        Get psDriverID to sDriverID
86877>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86878>>>>>>>        If (sTableName = "") Begin
86880>>>>>>>            Function_Return False
86881>>>>>>>        End
86881>>>>>>>>
86881>>>>>>>
86881>>>>>>>        Set Private.phCurrentTable to hTable
86882>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86883>>>>>>>        Delete_db sTableName
86884>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86885>>>>>>>
86885>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86887>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86887>>>>>>>            Get psDataPathFirstPart to sDataPath
86888>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86889>>>>>>>        End
86889>>>>>>>>
86889>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86889>>>>>>>        If (hTable <> 0) Begin
86891>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86894>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86897>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86900>>>>>>>        End
86900>>>>>>>>
86900>>>>>>>
86900>>>>>>>        Close hTable
86901>>>>>>>        Function_Return (hTable <> 0)
86902>>>>>>>    End_Function
86903>>>>>>>
86903>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86905>>>>>>>        Handle hTable
86905>>>>>>>        Boolean bOK
86905>>>>>>>
86905>>>>>>>        Get AutoConnectionIDLogin to bOK
86906>>>>>>>        Move False to Err
86907>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
86909>>>>>>>        Move hTableFrom to hTable
86910>>>>>>>
86910>>>>>>>        Structure_Start hTable
86911>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86914>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86915>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86917>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86918>>>>>>>
86918>>>>>>>        Close hTableFrom
86919>>>>>>>        Function_Return (Err = False)
86920>>>>>>>    End_Function
86921>>>>>>>
86921>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86923>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86923>>>>>>>        Boolean bOK bExists bOpened
86923>>>>>>>        tAPITableNameInfo APITableNameInfo
86923>>>>>>>        tAPITableNameInfo APITableNameInfo
86923>>>>>>>
86923>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86926>>>>>>>        If (bOpened = False) Begin
86928>>>>>>>            Get OpenTableExclusive hTable to bOpened
86929>>>>>>>            If (bOpened = False) Begin
86931>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86932>>>>>>>                Function_Return False
86933>>>>>>>            End
86933>>>>>>>>
86933>>>>>>>        End
86933>>>>>>>>
86933>>>>>>>
86933>>>>>>>        Set Private.phCurrentTable to hTable
86934>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
86935>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
86936>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86937>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86938>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86939>>>>>>>        If (bExists = True) Begin
86941>>>>>>>            Function_Return True
86942>>>>>>>        End
86942>>>>>>>>
86942>>>>>>>
86942>>>>>>>        Set Private.phCurrentTable to hTable
86943>>>>>>>        Move False to Err
86944>>>>>>>        Get psDataPathFirstPart to sDataPath
86945>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86948>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86951>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86954>>>>>>>
86954>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86957>>>>>>>        Close hTable
86958>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86960>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86961>>>>>>>            If (bExists = True) Begin
86963>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86965>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86968>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86968>>>>>>>                    // might report "File in use..." and the deletion will fail.
86968>>>>>>>                    Sleep 2
86969>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86970>>>>>>>                End
86970>>>>>>>>
86970>>>>>>>            End
86970>>>>>>>>
86970>>>>>>>        End
86970>>>>>>>>
86970>>>>>>>
86970>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86972>>>>>>>            If (not(sPhysicalName contains ".")) Begin
86974>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86975>>>>>>>            End
86975>>>>>>>>
86975>>>>>>>
86975>>>>>>>            // Change the table name in the .int file to the new table new:
86975>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86976>>>>>>>            If (bOK = False) Begin
86978>>>>>>>                Function_Return False
86979>>>>>>>            End
86979>>>>>>>>
86979>>>>>>>
86979>>>>>>>            // Change table name at the SQL side:
86979>>>>>>>            Get psSchema to sSchema
86980>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86981>>>>>>>
86981>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86982>>>>>>>            // Remove cache file and Rename the physical file names:
86982>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86983>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86984>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86985>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86986>>>>>>>
86986>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86986>>>>>>>//            If (not(sDisplayName contains ".")) Begin
86986>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86986>>>>>>>//            End
86986>>>>>>>        End
86986>>>>>>>>
86986>>>>>>>
86986>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86989>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86992>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86995>>>>>>>
86995>>>>>>>        Function_Return (Err = False)
86996>>>>>>>    End_Function
86997>>>>>>>
86997>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86999>>>>>>>        Move False to Err
87000>>>>>>>        Set Private.phCurrentTable to hTable
87001>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87004>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87007>>>>>>>
87007>>>>>>>        Function_Return (Err = False)
87008>>>>>>>    End_Function
87009>>>>>>>
87009>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
87009>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87011>>>>>>>        Handle hTable
87011>>>>>>>        String sTableName
87011>>>>>>>        String sDriverIDFrom sDriverIDTo
87011>>>>>>>        Integer iDbType
87011>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto
87011>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87011>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87011>>>>>>>        tSQLConnection SQLConnection
87011>>>>>>>        tSQLConnection SQLConnection
87011>>>>>>>        tAPITable      APITableFrom APITableTo
87011>>>>>>>        tAPITable      APITableFrom APITableTo
87011>>>>>>>        tColumnType    ColumnType
87011>>>>>>>        tColumnType    ColumnType
87011>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87011>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87012>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87012>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87013>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87013>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87014>>>>>>>
87014>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87014>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87016>>>>>>>            Function_Return False
87017>>>>>>>        End
87017>>>>>>>>
87017>>>>>>>
87017>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87018>>>>>>>        Get piDbType                            to iDbType
87019>>>>>>>        Get pbRecnum                            to bRecnum
87020>>>>>>>        Get pbToANSI                            to bToANSI
87021>>>>>>>        Get pbCopyData                          to bCopyData
87022>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87023>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87024>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87025>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87026>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87027>>>>>>>
87027>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87028>>>>>>>        Set Private.phCurrentTable              to hTable
87029>>>>>>>        Get _UtilTableExists  hTable             to bTableExists
87030>>>>>>>
87030>>>>>>>        If (ghoProgressBar <> 0) Begin
87032>>>>>>>            Send DoAdvance of ghoProgressBar
87033>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87034>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87035>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87036>>>>>>>        End
87036>>>>>>>>
87036>>>>>>>
87036>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87037>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87038>>>>>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
87039>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87040>>>>>>>        Move True                               to APITableFrom.bFromTable
87041>>>>>>>        Move hTable                             to APITableFrom.hTable
87042>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87043>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87044>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87045>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87046>>>>>>>
87046>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87048>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87049>>>>>>>            If (bOk = True) Begin
87051>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
87052>>>>>>>                Function_Return bOk
87053>>>>>>>            End 
87053>>>>>>>>
87053>>>>>>>        End
87053>>>>>>>>
87053>>>>>>>
87053>>>>>>>        If (bTableExists = True) Begin
87055>>>>>>>            If (bIsSQLTableTo = True) Begin
87057>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87058>>>>>>>            End
87058>>>>>>>>
87058>>>>>>>
87058>>>>>>>            Get OpenTableExclusive hTable to bOpened
87059>>>>>>>            If (bOpened = False) Begin
87061>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87062>>>>>>>                Function_Return False
87063>>>>>>>            End
87063>>>>>>>>
87063>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87064>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87065>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87066>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87067>>>>>>>        End
87067>>>>>>>>
87067>>>>>>>
87067>>>>>>>        Move False to Err
87068>>>>>>>        Case Begin
87068>>>>>>>            // Alias table:
87068>>>>>>>            Case (bIsAliasFrom = True)
87070>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87071>>>>>>>                Case Break
87072>>>>>>>
87072>>>>>>>            // New Table:
87072>>>>>>>            Case (bTableExists = False)
87075>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87076>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87076>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87078>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87079>>>>>>>                End                                                                 
87079>>>>>>>>
87079>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87080>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87081>>>>>>>                Case Break
87082>>>>>>>
87082>>>>>>>            // Update table:
87082>>>>>>>            Case (bTableExists = True)
87085>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87086>>>>>>>                If (bIsSame = True) Begin
87088>>>>>>>                    Case Break
87089>>>>>>>                End
87089>>>>>>>>
87089>>>>>>>                If (bFilelistError = True) Begin
87091>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87092>>>>>>>                    If (bOk = False) Begin
87094>>>>>>>                        Case Break
87095>>>>>>>                    End
87095>>>>>>>>
87095>>>>>>>                End
87095>>>>>>>>
87095>>>>>>>
87095>>>>>>>                If (ghoProgressBar <> 0) Begin
87097>>>>>>>                    Send DoAdvance of ghoProgressBar
87098>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87099>>>>>>>                End
87099>>>>>>>>
87099>>>>>>>
87099>>>>>>>                // Columns:
87099>>>>>>>                Move True to bOk
87100>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87101>>>>>>>                If (bIsSame = False) Begin
87103>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87104>>>>>>>                End
87104>>>>>>>>
87104>>>>>>>                If (bOk = False) Begin
87106>>>>>>>                    Case Break
87107>>>>>>>                End
87107>>>>>>>>
87107>>>>>>>
87107>>>>>>>                // Indexes:
87107>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87108>>>>>>>                If (bIsSame = False) Begin
87110>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87111>>>>>>>                End
87111>>>>>>>>
87111>>>>>>>
87111>>>>>>>                // Relations:
87111>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87112>>>>>>>                If (bIsSame = False) Begin
87114>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87115>>>>>>>                    If (bOk = False) Begin
87117>>>>>>>                        Case Break
87118>>>>>>>                    End
87118>>>>>>>>
87118>>>>>>>                End
87118>>>>>>>>
87118>>>>>>>
87118>>>>>>>                Case Break
87119>>>>>>>
87119>>>>>>>            Case Else
87119>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87120>>>>>>>>
87120>>>>>>>                Move False to bOk
87121>>>>>>>        Case End
87121>>>>>>>        
87121>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87121>>>>>>>        // or convert an embedded table to SQL
87121>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87123>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87124>>>>>>>            If (bOk = False) Begin
87126>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87127>>>>>>>            End
87127>>>>>>>>
87127>>>>>>>        End
87127>>>>>>>>
87127>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87130>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
87131>>>>>>>        End
87131>>>>>>>>
87131>>>>>>>        
87131>>>>>>>        // Filelist Names:
87131>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87132>>>>>>>        Close hTable
87133>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87134>>>>>>>
87134>>>>>>>        Function_Return (bOK = True)
87135>>>>>>>    End_Function
87136>>>>>>>
87136>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87136>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87138>>>>>>>        Function_Return False
87139>>>>>>>    End_Function
87140>>>>>>>
87140>>>>>>>    // Adds a column name to the passed table number.
87140>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87142>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87142>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87142>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87142>>>>>>>
87142>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87143>>>>>>>        If (bExists = True) Begin
87145>>>>>>>            Function_Return False
87146>>>>>>>        End
87146>>>>>>>>
87146>>>>>>>
87146>>>>>>>        Move False to Err
87147>>>>>>>        If (num_arguments > 4) Begin
87149>>>>>>>            Move iPrec to iPrecision
87150>>>>>>>        End
87150>>>>>>>>
87150>>>>>>>        If (num_arguments > 6) Begin
87152>>>>>>>            Move bInitVal to bInitializeValue
87153>>>>>>>            Move sColVal  to sColumnValue
87154>>>>>>>        End
87154>>>>>>>>
87154>>>>>>>        If (iType < -1490) Begin
87156>>>>>>>            Move (iType + 1500) to iType
87157>>>>>>>        End
87157>>>>>>>>
87157>>>>>>>
87157>>>>>>>        Move hTable to iFile
87158>>>>>>>        Get psDriverID to sDriverID
87159>>>>>>>        Get AutoConnectionIDLogin to bOK
87160>>>>>>>        Move False to Err
87161>>>>>>>        Move LastErr to iLastErr
87162>>>>>>>        Get OpenTableExclusive iFile to bOK
87163>>>>>>>        Set Private.phCurrentTable to hTable
87164>>>>>>>
87164>>>>>>>        Structure_Start iFile sDriverID
87165>>>>>>>            Move 0 to iColumn
87166>>>>>>>            Set Private.piCurrentField to iColumn
87167>>>>>>>            Create_Field hTable At iColumn
87168>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87171>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87174>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87177>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87180>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87181>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87183>>>>>>>
87183>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87184>>>>>>>
87184>>>>>>>        // If in development environment; create .fd file:
87184>>>>>>>        Open hTable
87186>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87187>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87188>>>>>>>        If (iCount > 1) Begin
87190>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87191>>>>>>>        End
87191>>>>>>>>
87191>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87192>>>>>>>        If (bExists = True) Begin
87194>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87195>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87198>>>>>>>            Get _TableNameOnly sTableName to sTableName
87199>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87201>>>>>>>        End
87201>>>>>>>>
87201>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87203>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87204>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87205>>>>>>>            If (iCount > 1) Begin
87207>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87208>>>>>>>            End
87208>>>>>>>>
87208>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87209>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87209>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87209>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87209>>>>>>>        End
87209>>>>>>>>
87209>>>>>>>        // Check for a default value
87209>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87211>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87212>>>>>>>        End
87212>>>>>>>>
87212>>>>>>>        Close hTable
87213>>>>>>>
87213>>>>>>>        Function_Return (Err = False)
87214>>>>>>>    End_Function
87215>>>>>>>
87215>>>>>>>    // Adds a column name to the passed table number.
87215>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87217>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87217>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87217>>>>>>>        String sDdSrcPath sTableName
87217>>>>>>>
87217>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87218>>>>>>>        Move False to Err
87219>>>>>>>        If (bExists = True) Begin
87221>>>>>>>            Function_Return False
87222>>>>>>>        End
87222>>>>>>>>
87222>>>>>>>        If (num_arguments > 4) Begin
87224>>>>>>>            Move iPrec to iPrecision
87225>>>>>>>        End
87225>>>>>>>>
87225>>>>>>>        If (iType < -1490) Begin
87227>>>>>>>            Move (iType + 1500) to iType
87228>>>>>>>        End
87228>>>>>>>>
87228>>>>>>>
87228>>>>>>>        Get AutoConnectionIDLogin to bOK
87229>>>>>>>        Move False to Err
87230>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87231>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87231>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87231>>>>>>>        Get piDbType to iDbType
87232>>>>>>>        If (bIsSQLTypeTo = False) Begin
87234>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87235>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87237>>>>>>>                Move DF_DATE to iType
87238>>>>>>>            End
87238>>>>>>>>
87238>>>>>>>        End
87238>>>>>>>>
87238>>>>>>>
87238>>>>>>>        // Structure_start will change the value of hTable...
87238>>>>>>>        Move hTable to iFile
87239>>>>>>>        Get OpenTableExclusive iFile to bOK
87240>>>>>>>        If (bOK = False) Begin
87242>>>>>>>            Function_Return False
87243>>>>>>>        End
87243>>>>>>>>
87243>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87246>>>>>>>
87246>>>>>>>        // If the passed column number is higher than the current number of fields
87246>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87246>>>>>>>        // a new field to the end:
87246>>>>>>>        If (iColumn > iNumberOfFields) Begin
87248>>>>>>>            Move 0 to iColumn
87249>>>>>>>        End
87249>>>>>>>>
87249>>>>>>>
87249>>>>>>>        Set Private.phCurrentTable to hTable
87250>>>>>>>        Set Private.piCurrentField to iColumn
87251>>>>>>>
87251>>>>>>>        Structure_Start iFile
87252>>>>>>>            Create_Field iFile At iColumn
87253>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87256>>>>>>>            If (bIsSQLTypeTo = False) Begin
87258>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87261>>>>>>>            End
87261>>>>>>>>
87261>>>>>>>            Else Begin
87262>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87265>>>>>>>            End
87265>>>>>>>>
87265>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87266>>>>>>>            If (bIsDateType = False) Begin
87268>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87271>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87274>>>>>>>            End
87274>>>>>>>>
87274>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87275>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87277>>>>>>>
87277>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87278>>>>>>>        // If in development environment; create .fd file:
87278>>>>>>>        Open hTable
87280>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87281>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87282>>>>>>>        If (iCount > 1) Begin
87284>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87285>>>>>>>        End
87285>>>>>>>>
87285>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87286>>>>>>>        If (bExists = True) Begin
87288>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87289>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87292>>>>>>>            Get _TableNameOnly sTableName to sTableName
87293>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87295>>>>>>>        End
87295>>>>>>>>
87295>>>>>>>
87295>>>>>>>        // Check for a default value
87295>>>>>>>        Close hTable
87296>>>>>>>
87296>>>>>>>        Function_Return (Err = False)
87297>>>>>>>    End_Function
87298>>>>>>>
87298>>>>>>>    // To update all records for a table column with a fixed value.
87298>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87300>>>>>>>        Integer iRecs iCurrErr iField iRecord
87300>>>>>>>        Boolean bRetval bOpen
87300>>>>>>>
87300>>>>>>>        Move 0 to iRecs
87301>>>>>>>        Move False to bRetval
87302>>>>>>>        Move Err to iCurrErr
87303>>>>>>>        Move False to Err
87304>>>>>>>
87304>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87307>>>>>>>        If (bOpen = False) Begin
87309>>>>>>>            Open hTable
87311>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87314>>>>>>>            If (bOpen = False) Begin
87316>>>>>>>                Function_Return bRetval
87317>>>>>>>            End
87317>>>>>>>>
87317>>>>>>>        End
87317>>>>>>>>
87317>>>>>>>
87317>>>>>>>        Field_Map hTable sFieldName to iField
87319>>>>>>>        If (iField <> 0) Begin
87321>>>>>>>            Set Private.phCurrentTable to hTable
87322>>>>>>>            Set Private.piCurrentField to iField
87323>>>>>>>            Clear hTable
87324>>>>>>>            Repeat
87324>>>>>>>>
87324>>>>>>>                Vfind hTable 0 GT
87326>>>>>>>                If (Found) Begin
87328>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87330>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87333>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87334>>>>>>>                    End
87334>>>>>>>>
87334>>>>>>>                    Reread hTable
87338>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87341>>>>>>>                        SaveRecord hTable
87342>>>>>>>                    Unlock
87343>>>>>>>>
87343>>>>>>>                End
87343>>>>>>>>
87343>>>>>>>           Until (not(Found))
87345>>>>>>>        End
87345>>>>>>>>
87345>>>>>>>
87345>>>>>>>        Move (Err = False) to bRetval
87346>>>>>>>        Move iCurrErr to Err
87347>>>>>>>
87347>>>>>>>        Function_Return bRetval
87348>>>>>>>    End_Function
87349>>>>>>>
87349>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87349>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87351>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87351>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87351>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87351>>>>>>>
87351>>>>>>>        Get psDriverID to sDriverID
87352>>>>>>>        Get piDbType to iDbType
87353>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87354>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87355>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87356>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87357>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87359>>>>>>>            Move True to bIsSqlTable
87360>>>>>>>        End
87360>>>>>>>>
87360>>>>>>>        Move False to bIsOpen
87361>>>>>>>        If (hTable > 0) Begin
87363>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87366>>>>>>>        End
87366>>>>>>>>
87366>>>>>>>        If (bIsOpen = True) Begin
87368>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87371>>>>>>>        End
87371>>>>>>>>
87371>>>>>>>        Else Begin
87372>>>>>>>            Get pbRecnum to bRecnumTable
87373>>>>>>>        End
87373>>>>>>>>
87373>>>>>>>
87373>>>>>>>        Move False to Err
87374>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87375>>>>>>>        Decrement iSize
87376>>>>>>>        for iCount from 0 to iSize
87382>>>>>>>>
87382>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87383>>>>>>>            If (hTable > 0) Begin
87385>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87386>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87387>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87390>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87391>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87392>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87393>>>>>>>            End
87393>>>>>>>>
87393>>>>>>>            Else Begin
87394>>>>>>>                Move False to bFieldExists
87395>>>>>>>            End
87395>>>>>>>>
87395>>>>>>>
87395>>>>>>>            If (bFieldExists = False) Begin
87397>>>>>>>                Move 0 to iColumn
87398>>>>>>>                Create_Field hTable At iColumn
87399>>>>>>>            End
87399>>>>>>>>
87399>>>>>>>            Else Begin
87400>>>>>>>                Move iCount to iColumn
87401>>>>>>>            End
87401>>>>>>>>
87401>>>>>>>
87401>>>>>>>            Set Private.piCurrentField to iColumn
87402>>>>>>>
87402>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87403>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87406>>>>>>>
87406>>>>>>>            Move aColumns[iCount].iType to iType
87407>>>>>>>            Move (not(iType < -1490)) to bNativeType
87408>>>>>>>            If (iType < -1490) Begin
87410>>>>>>>                Move (iType + 1500) to iType
87411>>>>>>>            End
87411>>>>>>>>
87411>>>>>>>
87411>>>>>>>            If (bIsSqlTable = True) Begin
87413>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87415>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87416>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87419>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87422>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87425>>>>>>>
87425>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87426>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87428>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87429>>>>>>>                    End
87429>>>>>>>>
87429>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87432>>>>>>>
87432>>>>>>>                End
87432>>>>>>>>
87432>>>>>>>                Else Begin
87433>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87436>>>>>>>                End
87436>>>>>>>>
87436>>>>>>>            End
87436>>>>>>>>
87436>>>>>>>            Else Begin
87437>>>>>>>                If (bCreating = False) Begin
87439>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87440>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87442>>>>>>>                        Move DF_DATE to iType
87443>>>>>>>                    End
87443>>>>>>>>
87443>>>>>>>                End
87443>>>>>>>>
87443>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87446>>>>>>>            End
87446>>>>>>>>
87446>>>>>>>
87446>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87447>>>>>>>            If (bIsDateType = False) Begin
87449>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87452>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87455>>>>>>>            End
87455>>>>>>>>
87455>>>>>>>
87455>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87457>>>>>>>                Move 0 to iIndex
87458>>>>>>>                Create_Index hTable at iIndex
87459>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87462>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87465>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87468>>>>>>>
87468>>>>>>>                // If we have an identity table - we must create a primary_key table.
87468>>>>>>>                If (bIsSqlTable = True) Begin
87470>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87473>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87476>>>>>>>                End
87476>>>>>>>>
87476>>>>>>>            End
87476>>>>>>>>
87476>>>>>>>        Loop
87477>>>>>>>>
87477>>>>>>>
87477>>>>>>>        Function_Return (Err = False)
87478>>>>>>>    End_Function
87479>>>>>>>
87479>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87479>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87481>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87481>>>>>>>        Boolean bOK bIsSqlTable
87481>>>>>>>        String sFieldNameTo
87481>>>>>>>
87481>>>>>>>        If (num_arguments > 4) Begin
87483>>>>>>>            Move iPrec to iPrecFrom
87484>>>>>>>        End
87484>>>>>>>>
87484>>>>>>>        If (iTypeFrom < -1490) Begin
87486>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87487>>>>>>>        End
87487>>>>>>>>
87487>>>>>>>
87487>>>>>>>        Get AutoConnectionIDLogin to bOK
87488>>>>>>>        Move False to Err
87489>>>>>>>        Get OpenTableExclusive hTable to bOK
87490>>>>>>>        If (bOK = False) Begin
87492>>>>>>>            Function_Return False
87493>>>>>>>        End
87493>>>>>>>>
87493>>>>>>>
87493>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87494>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87495>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87497>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87498>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87499>>>>>>>        If (Err = True) Begin
87501>>>>>>>            Function_Return False
87502>>>>>>>        End
87502>>>>>>>>
87502>>>>>>>
87502>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87505>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87506>>>>>>>        If (bIsSqlTable = False) Begin
87508>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87511>>>>>>>        End
87511>>>>>>>>
87511>>>>>>>        Else Begin
87512>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87515>>>>>>>        End
87515>>>>>>>>
87515>>>>>>>        // Let the driver decide the other values;
87515>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87518>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87521>>>>>>>
87521>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87523>>>>>>>            Function_Return False
87524>>>>>>>        End
87524>>>>>>>>
87524>>>>>>>
87524>>>>>>>        Set Private.phCurrentTable to hTable
87525>>>>>>>        Set Private.piCurrentField to iColumn
87526>>>>>>>
87526>>>>>>>        Structure_Start hTable
87527>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87530>>>>>>>//            If (bIsSqlTable = False) Begin
87530>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87533>>>>>>>//            End
87533>>>>>>>//            Else Begin
87533>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87533>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87533>>>>>>>//            End
87533>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87536>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87539>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87540>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87542>>>>>>>
87542>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87543>>>>>>>        Function_Return (Err = False)
87544>>>>>>>    End_Function
87545>>>>>>>
87545>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87545>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87547>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87547>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87547>>>>>>>        String sFieldNameTo sDriverIDTo
87547>>>>>>>        tColumnType ColumnType
87547>>>>>>>        tColumnType ColumnType
87547>>>>>>>
87547>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87548>>>>>>>        Get piDbType to iDbType
87549>>>>>>>        If (num_arguments > 4) Begin
87551>>>>>>>            Move iPrec to iPrecFrom
87552>>>>>>>            Move iOpt  to iOptionFrom
87553>>>>>>>        End
87553>>>>>>>>
87553>>>>>>>        If (iTypeFrom < -1490) Begin
87555>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87556>>>>>>>        End
87556>>>>>>>>
87556>>>>>>>
87556>>>>>>>        Get AutoConnectionIDLogin to bOK
87557>>>>>>>        Move False to Err
87558>>>>>>>        Close hTable
87559>>>>>>>        Get OpenTableExclusive hTable to bOK
87560>>>>>>>        If (bOK = False) Begin
87562>>>>>>>            Function_Return False
87563>>>>>>>        End
87563>>>>>>>>
87563>>>>>>>
87563>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87566>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87569>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87570>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87572>>>>>>>            Move DF_DATE to iDataFlexType
87573>>>>>>>        End
87573>>>>>>>>
87573>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87576>>>>>>>
87576>>>>>>>        If (bIsSQLTableTo = True) Begin
87578>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87581>>>>>>>        End
87581>>>>>>>>
87581>>>>>>>        Else Begin
87582>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87585>>>>>>>        End
87585>>>>>>>>
87585>>>>>>>
87585>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87588>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87591>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87594>>>>>>>
87594>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87594>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87594>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87596>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87597>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87599>>>>>>>                Move DF_DATE to iTypeTo  
87600>>>>>>>            End
87600>>>>>>>>
87600>>>>>>>        End
87600>>>>>>>>
87600>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87603>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87604>>>>>>>        End
87604>>>>>>>>
87604>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87605>>>>>>>
87605>>>>>>>        If (bCompareDate_DateTime = False) Begin
87607>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87608>>>>>>>            If (bSkip = True) Begin
87610>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87612>>>>>>>                    Function_Return True
87613>>>>>>>                End
87613>>>>>>>>
87613>>>>>>>            End
87613>>>>>>>>
87613>>>>>>>        End
87613>>>>>>>>
87613>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87616>>>>>>>            Function_Return True
87617>>>>>>>        End
87617>>>>>>>>
87617>>>>>>>
87617>>>>>>>        Set Private.phCurrentTable to hTable
87618>>>>>>>        Set Private.piCurrentField to iColumn
87619>>>>>>>
87619>>>>>>>        Structure_Start hTable
87620>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87622>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87625>>>>>>>            End
87625>>>>>>>>
87625>>>>>>>
87625>>>>>>>            If (bIsSameDataType = False) Begin
87627>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87630>>>>>>>                If (bIsSQLTableTo = True) Begin
87632>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87635>>>>>>>                End
87635>>>>>>>>
87635>>>>>>>            End
87635>>>>>>>>
87635>>>>>>>
87635>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87637>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87640>>>>>>>            End
87640>>>>>>>>
87640>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87642>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87645>>>>>>>            End
87645>>>>>>>>
87645>>>>>>>
87645>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87647>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87647>>>>>>>                If (bRecnumTable = True) Begin
87649>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87652>>>>>>>                End
87652>>>>>>>>
87652>>>>>>>
87652>>>>>>>                // We might need to create an index here.
87652>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87652>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87652>>>>>>>                // index update checking logic.
87652>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87655>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87657>>>>>>>                    Create_Index hTable At iIndex
87658>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87661>>>>>>>                End
87661>>>>>>>>
87661>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87664>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87667>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87670>>>>>>>                If (bIsSQLTableTo = True) Begin
87672>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87675>>>>>>>                End
87675>>>>>>>>
87675>>>>>>>            End
87675>>>>>>>>
87675>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87676>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87678>>>>>>>
87678>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87679>>>>>>>        Function_Return (Err = False)
87680>>>>>>>    End_Function
87681>>>>>>>
87681>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87683>>>>>>>        Boolean bOK
87683>>>>>>>
87683>>>>>>>        Get AutoConnectionIDLogin to bOK
87684>>>>>>>        Move False to Err
87685>>>>>>>        Get OpenTableExclusive hTable to bOK
87686>>>>>>>        If (bOK = False) Begin
87688>>>>>>>            Function_Return False
87689>>>>>>>        End
87689>>>>>>>>
87689>>>>>>>
87689>>>>>>>        Structure_Start hTable
87690>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87693>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87694>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87696>>>>>>>
87696>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87697>>>>>>>        Function_Return (Err = False)
87698>>>>>>>    End_Function
87699>>>>>>>
87699>>>>>>>    // To move an existing field to another position in a table.
87699>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87701>>>>>>>        String sColumn sDriverID
87701>>>>>>>        Integer iType
87701>>>>>>>        Boolean bOK bIsDate
87701>>>>>>>
87701>>>>>>>        Close hTable
87702>>>>>>>        Get AutoConnectionIDLogin to bOK
87703>>>>>>>        Get OpenTableExclusive hTable to bOK
87704>>>>>>>        If (bOK = False) Begin
87706>>>>>>>            Function_Return False
87707>>>>>>>        End
87707>>>>>>>>
87707>>>>>>>
87707>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87710>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87712>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87713>>>>>>>>
87713>>>>>>>            Function_Return False
87714>>>>>>>        End
87714>>>>>>>>
87714>>>>>>>
87714>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87717>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87720>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87721>>>>>>>
87721>>>>>>>        Set Private.phCurrentTable to hTable
87722>>>>>>>        Set Private.piCurrentField to iOld
87723>>>>>>>
87723>>>>>>>//        If (bIsDate = False) Begin
87723>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87723>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87723>>>>>>>//        End
87723>>>>>>>//        Else Begin
87723>>>>>>>//            Move 6 to iLength
87723>>>>>>>//            Move 0 to iPrecision
87723>>>>>>>//        End
87723>>>>>>>
87723>>>>>>>        Move False to Err
87724>>>>>>>
87724>>>>>>>        Structure_Start hTable
87725>>>>>>>            Delete_Field hTable iOld
87726>>>>>>>            Create_Field hTable At iNew
87727>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87730>>>>>>>
87730>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87733>>>>>>>            If (bIsSQLType = False) Begin
87735>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87738>>>>>>>            End
87738>>>>>>>>
87738>>>>>>>            Else Begin
87739>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87742>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87742>>>>>>>            End
87742>>>>>>>>
87742>>>>>>>
87742>>>>>>>            If (bIsDate = False) Begin
87744>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87747>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87750>>>>>>>            End
87750>>>>>>>>
87750>>>>>>>
87750>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87751>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87753>>>>>>>
87753>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87754>>>>>>>        Function_Return (Err = False)
87755>>>>>>>    End_Function
87756>>>>>>>
87756>>>>>>>    // Deletes a column name for the passed table number (and column number).
87756>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87758>>>>>>>        Integer iColumn
87758>>>>>>>        Boolean bOK
87758>>>>>>>
87758>>>>>>>        Get AutoConnectionIDLogin to bOK
87759>>>>>>>        Move False to Err
87760>>>>>>>        Close hTable
87761>>>>>>>        Get OpenTableExclusive hTable to bOK
87762>>>>>>>        If (bOK = False) Begin
87764>>>>>>>            Function_Return False
87765>>>>>>>        End
87765>>>>>>>>
87765>>>>>>>
87765>>>>>>>        If (not(Err)) Begin
87767>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87768>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87769>>>>>>>            Field_Map hTable sFieldName to iColumn
87771>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87772>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87773>>>>>>>            If (iColumn = 0) Begin
87775>>>>>>>                Move 0 to LastErr
87776>>>>>>>                Function_Return False
87777>>>>>>>            End
87777>>>>>>>>
87777>>>>>>>            Move False to Err
87778>>>>>>>
87778>>>>>>>            Set Private.phCurrentTable to hTable
87779>>>>>>>            Set Private.piCurrentField to iColumn
87780>>>>>>>
87780>>>>>>>            Structure_Start hTable
87781>>>>>>>                Delete_Field hTable iColumn
87782>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87783>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87785>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87786>>>>>>>        End
87786>>>>>>>>
87786>>>>>>>        Else Begin
87787>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87788>>>>>>>>
87788>>>>>>>        End
87788>>>>>>>>
87788>>>>>>>
87788>>>>>>>        Function_Return (Err = False)
87789>>>>>>>    End_Function
87790>>>>>>>
87790>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87790>>>>>>>    // Returns True if no errors occured.
87790>>>>>>>    // Sample usage:
87790>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87790>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87792>>>>>>>        Integer iField
87792>>>>>>>        Boolean bOK bExists bIsOpen
87792>>>>>>>
87792>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87793>>>>>>>        If (bExists = True) Begin
87795>>>>>>>            Function_Return False
87796>>>>>>>        End
87796>>>>>>>>
87796>>>>>>>
87796>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87796>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87796>>>>>>>        Close hTable
87797>>>>>>>        Open hTable
87799>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87802>>>>>>>        If (bIsOpen = False) Begin
87804>>>>>>>            Function_Return False
87805>>>>>>>        End
87805>>>>>>>>
87805>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87806>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87807>>>>>>>        Field_Map hTable sOldFieldName to iField
87809>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87810>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87811>>>>>>>
87811>>>>>>>        Get AutoConnectionIDLogin to bOK
87812>>>>>>>        Get OpenTableExclusive hTable to bOK
87813>>>>>>>        If (bOK = False) Begin
87815>>>>>>>            Function_Return False
87816>>>>>>>        End
87816>>>>>>>>
87816>>>>>>>
87816>>>>>>>        Move False to Err
87817>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87818>>>>>>>        Set Private.phCurrentTable to hTable
87819>>>>>>>        Set Private.piCurrentField to iField
87820>>>>>>>
87820>>>>>>>        If (iField > 0) Begin
87822>>>>>>>            Structure_Start hTable
87823>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87826>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87827>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87829>>>>>>>        End
87829>>>>>>>>
87829>>>>>>>        Else Begin
87830>>>>>>>            Move 0 to LastErr
87831>>>>>>>            Move False to Err
87832>>>>>>>        End
87832>>>>>>>>
87832>>>>>>>
87832>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87833>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87834>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87835>>>>>>>
87835>>>>>>>        Function_Return (Err = False)
87836>>>>>>>    End_Function
87837>>>>>>>
87837>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87839>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87839>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87840>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87840>>>>>>>        Boolean bRenameField
87840>>>>>>>
87840>>>>>>>        Open hTable
87842>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87843>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87844>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87845>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87848>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87849>>>>>>>        Decrement iSize
87850>>>>>>>        for iCount from 0 to iSize
87856>>>>>>>>
87856>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87858>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87859>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87860>>>>>>>
87860>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87862>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87864>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87865>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87866>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87868>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87869>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87870>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87871>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87872>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87873>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87874>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87875>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87876>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87877>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87878>>>>>>>                        Increment iItem
87879>>>>>>>                    End
87879>>>>>>>>
87879>>>>>>>                End
87879>>>>>>>>
87879>>>>>>>            End
87879>>>>>>>>
87879>>>>>>>        Loop
87880>>>>>>>>
87880>>>>>>>
87880>>>>>>>        Move False to Err
87881>>>>>>>        Move 0 to LastErr
87882>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87883>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87884>>>>>>>        Function_Return aAPIColumnsToInsert
87885>>>>>>>    End_Function
87886>>>>>>>
87886>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87888>>>>>>>        Integer iSize iCount
87888>>>>>>>        Boolean bOK
87888>>>>>>>        tAPIColumn[] aColumnsTo
87888>>>>>>>        tAPIColumn[] aColumnsTo
87889>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87889>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87890>>>>>>>
87890>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87891>>>>>>>        If (iSize = 0) Begin
87893>>>>>>>            Function_Return True
87894>>>>>>>        End
87894>>>>>>>>
87894>>>>>>>
87894>>>>>>>        Move False to Err
87895>>>>>>>        Decrement iSize
87896>>>>>>>        for iCount from 0 to iSize
87902>>>>>>>>
87902>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87903>>>>>>>        Loop
87904>>>>>>>>
87904>>>>>>>
87904>>>>>>>        Function_Return bOK
87905>>>>>>>    End_Function
87906>>>>>>>
87906>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
87906>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87908>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87908>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87909>>>>>>>        Integer iSize iCount iItem iShouldMove
87909>>>>>>>
87909>>>>>>>        Move 0 to iItem
87910>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87911>>>>>>>        Decrement iSize
87912>>>>>>>        for iCount from 0 to iSize
87918>>>>>>>>
87918>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87920>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87921>>>>>>>                If (iShouldMove <> -1) Begin
87923>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87924>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87925>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87926>>>>>>>                    Increment iItem
87927>>>>>>>                End
87927>>>>>>>>
87927>>>>>>>            End
87927>>>>>>>>
87927>>>>>>>        Loop
87928>>>>>>>>
87928>>>>>>>
87928>>>>>>>        Move False to Err
87929>>>>>>>        Move 0 to LastErr
87930>>>>>>>        Function_Return aAPIColumnsToMove
87931>>>>>>>    End_Function
87932>>>>>>>
87932>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87934>>>>>>>        Integer iSize iCount
87934>>>>>>>        Boolean bOK
87934>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87934>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87935>>>>>>>
87935>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87936>>>>>>>        If (iSize = 0) Begin
87938>>>>>>>            Function_Return True
87939>>>>>>>        End
87939>>>>>>>>
87939>>>>>>>
87939>>>>>>>        Move False to Err
87940>>>>>>>        Decrement iSize
87941>>>>>>>        for iCount from 0 to iSize
87947>>>>>>>>
87947>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87948>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87949>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87951>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87952>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87953>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87954>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87955>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87957>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87958>>>>>>>                    Decrement iSize
87959>>>>>>>                    Move 0 to iCount
87960>>>>>>>                End
87960>>>>>>>>
87960>>>>>>>            End
87960>>>>>>>>
87960>>>>>>>        Loop
87961>>>>>>>>
87961>>>>>>>
87961>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87962>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87963>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87965>>>>>>>            Move 0 to LastErr
87966>>>>>>>        End
87966>>>>>>>>
87966>>>>>>>        Function_Return bOK
87967>>>>>>>    End_Function
87968>>>>>>>
87968>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87968>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87968>>>>>>>    // - The "FROM" field name is <> "TO" field name
87968>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87968>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87968>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87970>>>>>>>        Boolean bShouldRename
87970>>>>>>>        String sFieldNameFrom sFieldNameTo
87970>>>>>>>
87970>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87971>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87972>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87974>>>>>>>            Function_Return False
87975>>>>>>>        End
87975>>>>>>>>
87975>>>>>>>
87975>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87976>>>>>>>//        If (bShouldRename = False) Begin
87976>>>>>>>//            Function_Return False
87976>>>>>>>//        End
87976>>>>>>>//
87976>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87976>>>>>>>//            Function_Return True
87976>>>>>>>//        End
87976>>>>>>>
87976>>>>>>>        Function_Return bShouldRename
87977>>>>>>>    End_Function
87978>>>>>>>
87978>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87978>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
87978>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87980>>>>>>>        Integer iCount iSize iRetval
87980>>>>>>>        String sFieldNameFrom
87980>>>>>>>
87980>>>>>>>        Move -1 to iRetval
87981>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87983>>>>>>>            Function_Return iRetval
87984>>>>>>>        End
87984>>>>>>>>
87984>>>>>>>
87984>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87985>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87986>>>>>>>        Decrement iSize
87987>>>>>>>        for iCount from 0 to iSize
87993>>>>>>>>
87993>>>>>>>            // We're only interested in fields other than the passed field/column number:
87993>>>>>>>            If (iCount <> iColumn) Begin
87995>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87997>>>>>>>                    Move (iCount + 1) to iRetval
87998>>>>>>>                End
87998>>>>>>>>
87998>>>>>>>            End
87998>>>>>>>>
87998>>>>>>>        Loop
87999>>>>>>>>
87999>>>>>>>
87999>>>>>>>        Move 0 to LastErr
88000>>>>>>>        Function_Return iRetval
88001>>>>>>>    End_Function
88002>>>>>>>
88002>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88004>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88004>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88005>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88005>>>>>>>        Boolean bRenameField
88005>>>>>>>
88005>>>>>>>        Open hTable
88007>>>>>>>        Move 0 to iItem
88008>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88009>>>>>>>        Decrement iSize
88010>>>>>>>        for iCount from 0 to iSize
88016>>>>>>>>
88016>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88018>>>>>>>                // Check if the field exists in another position (other field number)
88018>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88019>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88020>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88022>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88023>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88024>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88025>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88026>>>>>>>                    Increment iItem
88027>>>>>>>                End
88027>>>>>>>>
88027>>>>>>>            End
88027>>>>>>>>
88027>>>>>>>        Loop
88028>>>>>>>>
88028>>>>>>>
88028>>>>>>>        Move False to Err
88029>>>>>>>        Move 0 to LastErr
88030>>>>>>>        Function_Return aAPIColumnsToRename
88031>>>>>>>    End_Function
88032>>>>>>>
88032>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88034>>>>>>>        Integer iSize iCount
88034>>>>>>>        Boolean bOK
88034>>>>>>>        tAPIColumn[] aColumnsTo
88034>>>>>>>        tAPIColumn[] aColumnsTo
88035>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88035>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88036>>>>>>>
88036>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88037>>>>>>>        If (iSize = 0) Begin
88039>>>>>>>            Function_Return True
88040>>>>>>>        End
88040>>>>>>>>
88040>>>>>>>
88040>>>>>>>        Move False to Err
88041>>>>>>>        Decrement iSize
88042>>>>>>>        For iCount from 0 to iSize
88048>>>>>>>>
88048>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88049>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88050>>>>>>>        Loop
88051>>>>>>>>
88051>>>>>>>
88051>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88052>>>>>>>        Function_Return bOK
88053>>>>>>>    End_Function
88054>>>>>>>
88054>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88056>>>>>>>        Boolean bDateType
88056>>>>>>>
88056>>>>>>>        If (bIsSQLTableTo = True) Begin
88058>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88059>>>>>>>        End
88059>>>>>>>>
88059>>>>>>>        Else Begin
88060>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88061>>>>>>>        End
88061>>>>>>>>
88061>>>>>>>
88061>>>>>>>        Function_Return bDateType
88062>>>>>>>    End_Function
88063>>>>>>>
88063>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88065>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88065>>>>>>>        Integer iCount2 iColumn2
88065>>>>>>>        Handle hFile
88065>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88065>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88065>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88065>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88065>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88070>>>>>>>        tColumnType ColumnType
88070>>>>>>>        tColumnType ColumnType
88070>>>>>>>
88070>>>>>>>        Move False to Err
88071>>>>>>>        Close hTable
88072>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88073>>>>>>>        If (bIsOpen = False) Begin
88075>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88076>>>>>>>>
88076>>>>>>>            Function_Return False
88077>>>>>>>        End 
88077>>>>>>>>
88077>>>>>>>        
88077>>>>>>>        Get piDbType to iDbType
88078>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88081>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88082>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88083>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88086>>>>>>>
88086>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88087>>>>>>>
88087>>>>>>>        // Before we start to change the table we need to do three things;
88087>>>>>>>        // 1) Insert any new fields
88087>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88088>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88090>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88091>>>>>>>            If (bOK = False) Begin
88093>>>>>>>                Function_Return False
88094>>>>>>>            End
88094>>>>>>>>
88094>>>>>>>            // Update info with changes made.
88094>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88095>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88096>>>>>>>        End
88096>>>>>>>>
88096>>>>>>>
88096>>>>>>>        // 2) Move fields with same names
88096>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88097>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88099>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88100>>>>>>>            If (bOK = False) Begin
88102>>>>>>>                Function_Return False
88103>>>>>>>            End
88103>>>>>>>>
88103>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88104>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88105>>>>>>>        End
88105>>>>>>>>
88105>>>>>>>        
88105>>>>>>>        // 3) Rename fields
88105>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88106>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88108>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88109>>>>>>>            If (bOK = False) Begin
88111>>>>>>>                Function_Return False
88112>>>>>>>            End
88112>>>>>>>>
88112>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88113>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88114>>>>>>>        End
88114>>>>>>>>
88114>>>>>>>
88114>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88114>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88114>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88114>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88114>>>>>>>//            If (bOK = False) Begin
88114>>>>>>>//                Function_Return False
88114>>>>>>>//            End
88114>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88114>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88114>>>>>>>//        End
88114>>>>>>>
88114>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88114>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88116>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88117>>>>>>>            If (bIsSame = True) Begin
88119>>>>>>>                Function_Return True
88120>>>>>>>            End
88120>>>>>>>>
88120>>>>>>>        End
88120>>>>>>>>
88120>>>>>>>
88120>>>>>>>        // We can now continue to make standard field changes:
88120>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88121>>>>>>>        Set Private.phCurrentTable to hTable
88122>>>>>>>        Move hTable to hFile
88123>>>>>>>        Structure_Start hFile sDriverIDTo
88124>>>>>>>
88124>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88125>>>>>>>            Decrement iColumns
88126>>>>>>>            for iCount from 0 to iColumns
88132>>>>>>>>
88132>>>>>>>                Send DoAdvance of ghoProgressBar
88133>>>>>>>
88133>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88134>>>>>>>                Set Private.piCurrentField                  to iColumn
88135>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88136>>>>>>>                If (bIsSame = False) Begin
88138>>>>>>>
88138>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88139>>>>>>>                    If (bFieldExistsFrom = True) Begin
88141>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88142>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88143>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88144>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88145>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88146>>>>>>>
88146>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88147>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88148>>>>>>>                        If (iTypeFrom < -1490) Begin
88150>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88151>>>>>>>                        End
88151>>>>>>>>
88151>>>>>>>
88151>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88151>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88151>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88153>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88154>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88156>>>>>>>                                Move DF_DATE to iTypeFrom
88157>>>>>>>                            End
88157>>>>>>>>
88157>>>>>>>                        End
88157>>>>>>>>
88157>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88160>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88161>>>>>>>                        End
88161>>>>>>>>
88161>>>>>>>
88161>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88162>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88163>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88164>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88165>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88166>>>>>>>
88166>>>>>>>                        Move False to bSkipTypeChange
88167>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88169>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88170>>>>>>>                        End
88170>>>>>>>>
88170>>>>>>>
88170>>>>>>>                        If (bFieldExistsTo = False) Begin
88172>>>>>>>                            Move 0 to iColumn
88173>>>>>>>                            Create_Field hFile At iColumn
88174>>>>>>>                            Set Private.piCurrentField to iColumn
88175>>>>>>>                        End
88175>>>>>>>>
88175>>>>>>>
88175>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88177>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88180>>>>>>>                        End
88180>>>>>>>>
88180>>>>>>>
88180>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88182>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88185>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88186>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88188>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88189>>>>>>>                            End
88189>>>>>>>>
88189>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88192>>>>>>>                        End
88192>>>>>>>>
88192>>>>>>>
88192>>>>>>>                        If (bSkipTypeChange = False) Begin
88194>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88196>>>>>>>                                If (bIsSQLTableTo = True) Begin
88198>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88201>>>>>>>                                End
88201>>>>>>>>
88201>>>>>>>                                Else Begin                                                   
88202>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88204>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88205>>>>>>>                                    End
88205>>>>>>>>
88205>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88208>>>>>>>                                End
88208>>>>>>>>
88208>>>>>>>                            End
88208>>>>>>>>
88208>>>>>>>                        End
88208>>>>>>>>
88208>>>>>>>
88208>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88209>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88209>>>>>>>                        If (bIsDateType = False) Begin
88211>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88213>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88216>>>>>>>                            End
88216>>>>>>>>
88216>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88218>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88221>>>>>>>                            End
88221>>>>>>>>
88221>>>>>>>                        End
88221>>>>>>>>
88221>>>>>>>
88221>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88223>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88223>>>>>>>                            If (bRecnumTable = True) Begin
88225>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88228>>>>>>>                            End
88228>>>>>>>>
88228>>>>>>>
88228>>>>>>>                            // We might need to create an index here.
88228>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88228>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88228>>>>>>>                            // index update checking logic.
88228>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88231>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88233>>>>>>>                                Create_Index hFile at iIndex
88234>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88237>>>>>>>                            End
88237>>>>>>>>
88237>>>>>>>
88237>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88240>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88243>>>>>>>                                // Note: The order here is crucial!
88243>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88246>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88249>>>>>>>                        End
88249>>>>>>>>
88249>>>>>>>                    End
88249>>>>>>>>
88249>>>>>>>                    Else Begin
88250>>>>>>>                        Delete_Field hFile iColumn
88251>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88252>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88253>>>>>>>                        Decrement iCount2
88254>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88254>>>>>>>                        // starting with the array number we just deleted the field for.
88254>>>>>>>                        for iColumn2 from iCount to iCount2
88260>>>>>>>>
88260>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88261>>>>>>>                        Loop
88262>>>>>>>>
88262>>>>>>>                        Decrement iCount
88263>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88264>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88265>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88267>>>>>>>                            Move iColumns to iCount 
88268>>>>>>>                        End
88268>>>>>>>>
88268>>>>>>>                    End
88268>>>>>>>>
88268>>>>>>>                End
88268>>>>>>>>
88268>>>>>>>            Loop
88269>>>>>>>>
88269>>>>>>>
88269>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88270>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88272>>>>>>>
88272>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88273>>>>>>>        Function_Return (Err = False)
88274>>>>>>>    End_Function
88275>>>>>>>
88275>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88275>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88277>>>>>>>        Function_Return False
88278>>>>>>>    End_Function
88279>>>>>>>
88279>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88279>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88279>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88279>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88281>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88281>>>>>>>        String sDriverID
88281>>>>>>>        Boolean bOK bExists bIsSQLTable
88281>>>>>>>
88281>>>>>>>        Get AutoConnectionIDLogin to bOK
88282>>>>>>>        Get OpenTableExclusive hTable to bOK
88283>>>>>>>        If (bOK = False) Begin
88285>>>>>>>            Function_Return False
88286>>>>>>>        End
88286>>>>>>>>
88286>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88289>>>>>>>
88289>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88290>>>>>>>            If (bIsSQLTable = True) Begin
88292>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88295>>>>>>>            End
88295>>>>>>>>
88295>>>>>>>
88295>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88298>>>>>>>        Move (iIndexSegments > 0) to bExists
88299>>>>>>>        If (bExists = True) Begin
88301>>>>>>>            Function_Return True
88302>>>>>>>        End
88302>>>>>>>>
88302>>>>>>>
88302>>>>>>>        Move -1 to iSegment1
88303>>>>>>>        Move -1 to iSegment2
88304>>>>>>>        Move -1 to iSegment3
88305>>>>>>>        Move -1 to iSegment4
88306>>>>>>>        Move -1 to iSegment5
88307>>>>>>>        Move -1 to iSegment6
88308>>>>>>>        Move -1 to iSegment7
88309>>>>>>>        Move -1 to iSegment8
88310>>>>>>>        Move -1 to iSegment9
88311>>>>>>>        Move -1 to iSegment10
88312>>>>>>>
88312>>>>>>>        If (num_arguments > 3) Begin
88314>>>>>>>            Move iSgmnt1 to iSegment1
88315>>>>>>>        End
88315>>>>>>>>
88315>>>>>>>        If (num_arguments > 4) Begin
88317>>>>>>>            Move iSgmnt2 to iSegment2
88318>>>>>>>        End
88318>>>>>>>>
88318>>>>>>>        If (num_arguments > 5) Begin
88320>>>>>>>            Move iSgmnt3 to iSegment3
88321>>>>>>>        End
88321>>>>>>>>
88321>>>>>>>        If (num_arguments > 6) Begin
88323>>>>>>>            Move iSgmnt4 to iSegment4
88324>>>>>>>        End
88324>>>>>>>>
88324>>>>>>>        If (num_arguments > 7) Begin
88326>>>>>>>            Move iSgmnt5 to iSegment5
88327>>>>>>>        End
88327>>>>>>>>
88327>>>>>>>        If (num_arguments > 8) Begin
88329>>>>>>>            Move iSgmnt6 to iSegment6
88330>>>>>>>        End
88330>>>>>>>>
88330>>>>>>>        If (num_arguments > 9) Begin
88332>>>>>>>            Move iSgmnt7 to iSegment7
88333>>>>>>>        End
88333>>>>>>>>
88333>>>>>>>        If (num_arguments > 10) Begin
88335>>>>>>>            Move iSgmnt8 to iSegment8
88336>>>>>>>        End
88336>>>>>>>>
88336>>>>>>>        If (num_arguments > 11) Begin
88338>>>>>>>            Move iSgmnt9 to iSegment9
88339>>>>>>>        End
88339>>>>>>>>
88339>>>>>>>        If (num_arguments > 12) Begin
88341>>>>>>>            Move iSgmnt10 to iSegment10
88342>>>>>>>        End
88342>>>>>>>>
88342>>>>>>>
88342>>>>>>>        Move False to Err
88343>>>>>>>        Move hTable to iTableNo
88344>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88345>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88346>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88347>>>>>>>
88347>>>>>>>        // We start by deleting the index, if it exists.
88347>>>>>>>        If (bExists = True) Begin
88349>>>>>>>            Structure_Start hTable sDriverID
88350>>>>>>>                Delete_Index iTableNo iIndex
88351>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88352>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88354>>>>>>>        End
88354>>>>>>>>
88354>>>>>>>
88354>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88355>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88356>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88357>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88358>>>>>>>        Move False to Err
88359>>>>>>>        Move 0 to LastErr
88360>>>>>>>
88360>>>>>>>        // Need to re-open if index deleted.
88360>>>>>>>        Move iTableNo to hTable
88361>>>>>>>        Get OpenTableExclusive hTable to bOK
88362>>>>>>>        If (bOK = False) Begin
88364>>>>>>>            Function_Return False
88365>>>>>>>        End
88365>>>>>>>>
88365>>>>>>>
88365>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88366>>>>>>>        Structure_Start hTable sDriverID
88367>>>>>>>            Create_Index hTable At iIndex
88368>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88371>>>>>>>
88371>>>>>>>            If (iSgmnt1 <> -1) Begin
88373>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88376>>>>>>>            End
88376>>>>>>>>
88376>>>>>>>            If (iSegment2 <> -1) Begin
88378>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88381>>>>>>>            End
88381>>>>>>>>
88381>>>>>>>            If (iSegment3 <> -1) Begin
88383>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88386>>>>>>>            End
88386>>>>>>>>
88386>>>>>>>            If (iSegment4 <> -1) Begin
88388>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88391>>>>>>>            End
88391>>>>>>>>
88391>>>>>>>            If (iSegment5 <> -1) Begin
88393>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88396>>>>>>>            End
88396>>>>>>>>
88396>>>>>>>            If (iSegment6 <> -1) Begin
88398>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88401>>>>>>>            End
88401>>>>>>>>
88401>>>>>>>            If (iSegment7 <> -1) Begin
88403>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88406>>>>>>>            End
88406>>>>>>>>
88406>>>>>>>            If (iSegment8 <> -1) Begin
88408>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88411>>>>>>>            End
88411>>>>>>>>
88411>>>>>>>            If (iSegment9 <> -1) Begin
88413>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88416>>>>>>>            End
88416>>>>>>>>
88416>>>>>>>            If (iSegment10 <> -1) Begin
88418>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88421>>>>>>>            End
88421>>>>>>>>
88421>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88422>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88424>>>>>>>
88424>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88425>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88426>>>>>>>
88426>>>>>>>        Function_Return (Err = False)
88427>>>>>>>    End_Function
88428>>>>>>>
88428>>>>>>>    // Example:
88428>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88428>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88428>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88430>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88430>>>>>>>        String sDriverID
88430>>>>>>>        Boolean bOK bIsSQLTable
88430>>>>>>>
88430>>>>>>>        Get AutoConnectionIDLogin to bOK
88431>>>>>>>
88431>>>>>>>        Move False to Err
88432>>>>>>>        Move hTable to iTableNo
88433>>>>>>>        Get OpenTableExclusive hTable to bOK
88434>>>>>>>        If (bOK = False) Begin
88436>>>>>>>            Function_Return False
88437>>>>>>>        End
88437>>>>>>>>
88437>>>>>>>
88437>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88440>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88441>>>>>>>            If (bIsSQLTable = True) Begin
88443>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88446>>>>>>>            End
88446>>>>>>>>
88446>>>>>>>
88446>>>>>>>        // We start by deleting the index
88446>>>>>>>        Structure_Start hTable sDriverID
88447>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88448>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88449>>>>>>>            Delete_Index iTableNo iIndex
88450>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88451>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88452>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88454>>>>>>>
88454>>>>>>>        Move False to Err
88455>>>>>>>        Move iTableNo to hTable
88456>>>>>>>        Get OpenTableExclusive hTable to bOK
88457>>>>>>>        If (bOK = False) Begin
88459>>>>>>>            Function_Return False
88460>>>>>>>        End
88460>>>>>>>>
88460>>>>>>>
88460>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88461>>>>>>>        Structure_Start hTable sDriverID
88462>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88463>>>>>>>
88463>>>>>>>            Create_Index hTable at iIndex
88464>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88467>>>>>>>
88467>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88473>>>>>>>>
88473>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88476>>>>>>>            Loop
88477>>>>>>>>
88477>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88479>>>>>>>
88479>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88480>>>>>>>
88480>>>>>>>        Function_Return (Err = False)
88481>>>>>>>    End_Function
88482>>>>>>>
88482>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88484>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88484>>>>>>>        String sDriverID sSQLIndexName
88484>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88484>>>>>>>
88484>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88485>>>>>>>        If (iSegmentsFrom = 0) Begin
88487>>>>>>>            Function_Return False
88488>>>>>>>        End
88488>>>>>>>>
88488>>>>>>>
88488>>>>>>>        Get AutoConnectionIDLogin to bOK
88489>>>>>>>        Move False to Err
88490>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88491>>>>>>>        If (bIsOpen = False) Begin
88493>>>>>>>            Function_Return False
88494>>>>>>>        End
88494>>>>>>>>
88494>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88497>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88498>>>>>>>            If (bIsSQLTable = True) Begin
88500>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88503>>>>>>>            End
88503>>>>>>>>
88503>>>>>>>
88503>>>>>>>        Move 0     to iSegmentsTo
88504>>>>>>>        Move 0     to iSQLIndexType
88505>>>>>>>        Move ""    to sSQLIndexName
88506>>>>>>>        Move False to bIsSQLTemporaryIndex
88507>>>>>>>        Move False to bIsSQLPrimaryKey
88508>>>>>>>        Move False to bIsSQLClustered
88509>>>>>>>
88509>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88510>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88513>>>>>>>        Move (iSegmentsTo > 0) to bExists
88514>>>>>>>        If (bExists = True) Begin
88516>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88518>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88521>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88524>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88525>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88528>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88531>>>>>>>            End
88531>>>>>>>>
88531>>>>>>>        End
88531>>>>>>>>
88531>>>>>>>
88531>>>>>>>        Move hTable to iTableNo
88532>>>>>>>        Move False to Err
88533>>>>>>>        Move 0 to LastErr
88534>>>>>>>
88534>>>>>>>        Structure_Start hTable sDriverID
88535>>>>>>>            If (bExists = True) Begin
88537>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88538>>>>>>>            End
88538>>>>>>>>
88538>>>>>>>
88538>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88539>>>>>>>
88539>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88541>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88544>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88547>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88550>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88553>>>>>>>                End
88553>>>>>>>>
88553>>>>>>>
88553>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88556>>>>>>>
88556>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88562>>>>>>>>
88562>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88563>>>>>>>                If (iFieldFrom <> -1 ) Begin
88565>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88568>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88571>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88574>>>>>>>                End
88574>>>>>>>>
88574>>>>>>>            Loop
88575>>>>>>>>
88575>>>>>>>
88575>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88576>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88578>>>>>>>
88578>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88579>>>>>>>
88579>>>>>>>        Function_Return (Err = False)
88580>>>>>>>    End_Function
88581>>>>>>>
88581>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88581>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88581>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88583>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88583>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88583>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
88583>>>>>>>
88583>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88584>>>>>>>        
88584>>>>>>>        If (bIsSQLDriver = False) Begin
88586>>>>>>>            Function_Return False
88587>>>>>>>        End
88587>>>>>>>>
88587>>>>>>>
88587>>>>>>>        Move False to Err
88588>>>>>>>        Move hTable to iTableNo
88589>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88592>>>>>>>        for iCount from 0 to iLastIndex
88598>>>>>>>>
88598>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88601>>>>>>>            Move (iSegments > 0) to bExists
88602>>>>>>>            If (bExists = True) Begin
88604>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88607>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88609>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88610>>>>>>>                    Structure_Start iTableNo sDriverID
88611>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88614>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88616>>>>>>>                    Open hTable
88618>>>>>>>                End
88618>>>>>>>>
88618>>>>>>>            End
88618>>>>>>>>
88618>>>>>>>        Loop
88619>>>>>>>>
88619>>>>>>>
88619>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88622>>>>>>>        If (bIsOpen = False) Begin
88624>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88625>>>>>>>        End
88625>>>>>>>>
88625>>>>>>>        If (bIsOpen = False) Begin
88627>>>>>>>            Function_Return False
88628>>>>>>>        End
88628>>>>>>>>
88628>>>>>>>
88628>>>>>>>        Function_Return (Err = False)
88629>>>>>>>    End_Function
88630>>>>>>>
88630>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88630>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88630>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88632>>>>>>>        Integer iSize iCount
88632>>>>>>>        Integer iRetVal
88632>>>>>>>
88632>>>>>>>        Move 0 to iRetVal
88633>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88636>>>>>>>        If (iRetVal = 0) Begin
88638>>>>>>>            Function_Return 0
88639>>>>>>>        End
88639>>>>>>>>
88639>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88640>>>>>>>        Decrement iSize
88641>>>>>>>        for iCount from 0 to iSize
88647>>>>>>>>
88647>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88649>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88651>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88652>>>>>>>                End
88652>>>>>>>>
88652>>>>>>>            End
88652>>>>>>>>
88652>>>>>>>        Loop
88653>>>>>>>>
88653>>>>>>>
88653>>>>>>>        Function_Return iRetVal
88654>>>>>>>    End_Function
88655>>>>>>>
88655>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88657>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88657>>>>>>>        Boolean bIsSQLTable
88657>>>>>>>        
88657>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88658>>>>>>>            If (bIsSQLTable = True) Begin
88660>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88663>>>>>>>            End
88663>>>>>>>>
88663>>>>>>>
88663>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88666>>>>>>>        If (iSegment = iNumSegments) Begin
88668>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88668>>>>>>>        End
88668>>>>>>>>
88668>>>>>>>
88668>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88671>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88677>>>>>>>>
88677>>>>>>>                //*** Move index segment attributes
88677>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88680>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88683>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88686>>>>>>>
88686>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88689>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88692>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88695>>>>>>>            Loop
88696>>>>>>>>
88696>>>>>>>
88696>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88699>>>>>>>        End
88699>>>>>>>>
88699>>>>>>>
88699>>>>>>>        Function_Return (Err = False)
88700>>>>>>>    End_Function
88701>>>>>>>
88701>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88703>>>>>>>        Integer iCount iSize iIndex
88703>>>>>>>        String sDriverID
88703>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88703>>>>>>>
88703>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88704>>>>>>>        If (iSize = 0) Begin
88706>>>>>>>            Function_Return True
88707>>>>>>>        End
88707>>>>>>>>
88707>>>>>>>
88707>>>>>>>        Get AutoConnectionIDLogin to bOK
88708>>>>>>>        Move False to Err
88709>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88712>>>>>>>        If (bIsOpen = False) Begin
88714>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88715>>>>>>>            If (bIsOpen = False) Begin
88717>>>>>>>                Function_Return False
88718>>>>>>>            End
88718>>>>>>>>
88718>>>>>>>        End
88718>>>>>>>>
88718>>>>>>>
88718>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88721>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88722>>>>>>>            If (bIsSQLTable = True) Begin
88724>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88727>>>>>>>            End
88727>>>>>>>>
88727>>>>>>>
88727>>>>>>>        Move False to Err
88728>>>>>>>        Move 0 to LastErr
88729>>>>>>>        Decrement iSize
88730>>>>>>>
88730>>>>>>>        Structure_Start hTable sDriverID
88731>>>>>>>            for iCount from 0 to iSize
88737>>>>>>>>
88737>>>>>>>//                Move False to bIsSQLPrimaryKey
88737>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88737>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88737>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88737>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88737>>>>>>>//                #ENDIF
88737>>>>>>>                // We can't delete if this is a primary key index:
88737>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88737>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88738>>>>>>>                    Delete_Index hTable iIndex
88739>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88739>>>>>>>//                End
88739>>>>>>>            Loop
88740>>>>>>>>
88740>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88741>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88743>>>>>>>//        Move False to Err
88743>>>>>>>        Move 0 to LastErr
88744>>>>>>>
88744>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88745>>>>>>>        Function_Return (Err = False)
88746>>>>>>>    End_Function
88747>>>>>>>
88747>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88749>>>>>>>        Boolean bOK
88749>>>>>>>
88749>>>>>>>        Get AutoConnectionIDLogin to bOK
88750>>>>>>>        Move False to Err
88751>>>>>>>        Get OpenTableExclusive hTable to bOK
88752>>>>>>>        If (bOK = False) Begin
88754>>>>>>>            Function_Return False
88755>>>>>>>        End
88755>>>>>>>>
88755>>>>>>>        Structure_Start hTable
88756>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88759>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88760>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88762>>>>>>>
88762>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88763>>>>>>>        Function_Return (Err = False)
88764>>>>>>>    End_Function
88765>>>>>>>
88765>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88767>>>>>>>        Integer iCase
88767>>>>>>>        Boolean bOK
88767>>>>>>>
88767>>>>>>>        If (bUppercase = True) Begin
88769>>>>>>>            Move DF_CASE_IGNORED to iCase
88770>>>>>>>        End
88770>>>>>>>>
88770>>>>>>>        Else Begin
88771>>>>>>>            Move DF_CASE_USED to iCase
88772>>>>>>>        End
88772>>>>>>>>
88772>>>>>>>
88772>>>>>>>        Get AutoConnectionIDLogin to bOK
88773>>>>>>>        Move False to Err
88774>>>>>>>        Get OpenTableExclusive hTable to bOK
88775>>>>>>>        If (bOK = False) Begin
88777>>>>>>>            Function_Return False
88778>>>>>>>        End
88778>>>>>>>>
88778>>>>>>>        Structure_Start hTable
88779>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88782>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88783>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88785>>>>>>>
88785>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88786>>>>>>>        Function_Return (Err = False)
88787>>>>>>>    End_Function
88788>>>>>>>
88788>>>>>>>    // To delete an index
88788>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88790>>>>>>>        Integer iTableNo iNumSegments
88790>>>>>>>        String sDriverID
88790>>>>>>>        Boolean bOK bIsSQLTable
88790>>>>>>>
88790>>>>>>>        Get AutoConnectionIDLogin to bOK
88791>>>>>>>        Move False to Err
88792>>>>>>>        Move hTable to iTableNo
88793>>>>>>>        Get OpenTableExclusive hTable to bOK
88794>>>>>>>        If (bOK = False) Begin
88796>>>>>>>            Function_Return False
88797>>>>>>>        End
88797>>>>>>>>
88797>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88800>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88801>>>>>>>            If (bIsSQLTable = True) Begin
88803>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88806>>>>>>>            End
88806>>>>>>>>
88806>>>>>>>
88806>>>>>>>        // Check to see if the index exists or not...
88806>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88809>>>>>>>        If (iNumSegments = 0) Begin
88811>>>>>>>            Function_Return True // Then nothing to do.
88812>>>>>>>        End
88812>>>>>>>>
88812>>>>>>>
88812>>>>>>>        Structure_Start hTable sDriverID
88813>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88814>>>>>>>            Delete_Index iTableNo iIndex
88815>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88816>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88817>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88819>>>>>>>
88819>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88820>>>>>>>        Function_Return (Err = False)
88821>>>>>>>    End_Function
88822>>>>>>>
88822>>>>>>>    // Delete an Index Segment
88822>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88824>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88824>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88824>>>>>>>        Integer iIndexType
88824>>>>>>>        String sDriverID
88824>>>>>>>
88824>>>>>>>        Get AutoConnectionIDLogin to bOK
88825>>>>>>>        Move False to Err
88826>>>>>>>
88826>>>>>>>        Get OpenTableExclusive hTable to bOK
88827>>>>>>>        If (bOK = False) Begin
88829>>>>>>>            Function_Return False
88830>>>>>>>        End
88830>>>>>>>>
88830>>>>>>>
88830>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88831>>>>>>>            If (bIsSQLTable = True) Begin
88833>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88836>>>>>>>            End
88836>>>>>>>>
88836>>>>>>>
88836>>>>>>>        // Check to see if the index exists or not...
88836>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88839>>>>>>>        If (iNumSegments = 0) Begin
88841>>>>>>>            Function_Return False
88842>>>>>>>        End
88842>>>>>>>>
88842>>>>>>>
88842>>>>>>>        Move False to bIndexTemporary
88843>>>>>>>        Get psDriverID to sDriverID
88844>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88845>>>>>>>        If (bSQLDriver) Begin
88847>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88850>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88853>>>>>>>                Move True to bIndexTemporary
88854>>>>>>>        End
88854>>>>>>>>
88854>>>>>>>
88854>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88854>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88856>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88859>>>>>>>            If (iSegment = iNumSegments) Begin
88861>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88864>>>>>>>            End
88864>>>>>>>>
88864>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88867>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88873>>>>>>>>
88873>>>>>>>                    //*** Move index segment attributes
88873>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88876>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88879>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88882>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88885>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88888>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88891>>>>>>>                Loop
88892>>>>>>>>
88892>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88895>>>>>>>            End
88895>>>>>>>>
88895>>>>>>>        End
88895>>>>>>>>
88895>>>>>>>
88895>>>>>>>        Else Begin
88896>>>>>>>           Structure_Start hTable
88897>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88900>>>>>>>               If (iSegment = iNumSegments) Begin
88902>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88905>>>>>>>               End
88905>>>>>>>>
88905>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88908>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88914>>>>>>>>
88914>>>>>>>                       //*** Move index segment attributes
88914>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88917>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88920>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88923>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88926>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88929>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88932>>>>>>>                   Loop
88933>>>>>>>>
88933>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88936>>>>>>>               End
88936>>>>>>>>
88936>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88937>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88939>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88940>>>>>>>        End
88940>>>>>>>>
88940>>>>>>>
88940>>>>>>>        Function_Return (Err = False)
88941>>>>>>>    End_Function
88942>>>>>>>
88942>>>>>>>    // Add/Insert an Index Segment
88942>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88944>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88944>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88944>>>>>>>        Integer iIndexType
88944>>>>>>>        String sDriverId
88944>>>>>>>
88944>>>>>>>        Get AutoConnectionIDLogin to bOK
88945>>>>>>>        Move False to Err
88946>>>>>>>
88946>>>>>>>        Get OpenTableExclusive hTable to bOK
88947>>>>>>>        If (bOK = False) Begin
88949>>>>>>>            Function_Return False
88950>>>>>>>        End
88950>>>>>>>>
88950>>>>>>>
88950>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88951>>>>>>>            If (bIsSQLTable = True) Begin
88953>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88956>>>>>>>            End
88956>>>>>>>>
88956>>>>>>>
88956>>>>>>>        Move False to bIndexTemporary
88957>>>>>>>        // Check to see if the index exists or not...
88957>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88960>>>>>>>        If (iNumSegments = 0) Begin
88962>>>>>>>            Function_Return False
88963>>>>>>>        End
88963>>>>>>>>
88963>>>>>>>
88963>>>>>>>        Get psDriverID to sDriverID
88964>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88965>>>>>>>        If (bSQLDriver) Begin
88967>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88970>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88973>>>>>>>                Move True to bIndexTemporary
88974>>>>>>>        End
88974>>>>>>>>
88974>>>>>>>
88974>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88974>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88976>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88979>>>>>>>
88979>>>>>>>           If (iSegment > iNumSegments) Begin
88981>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88984>>>>>>>               Move (iNumSegments + 1) to iCurSegment
88985>>>>>>>           End
88985>>>>>>>>
88985>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88988>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88991>>>>>>>               Move iNumSegments to iCurSegment
88992>>>>>>>
88992>>>>>>>               While (iCurSegment > iSegment)
88996>>>>>>>                   //*** Move index segment attributes
88996>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88999>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89002>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89005>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89008>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89011>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89014>>>>>>>                   Decrement iCurSegment
89015>>>>>>>               Loop
89016>>>>>>>>
89016>>>>>>>
89016>>>>>>>               //*** Now set new segment attributes
89016>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89019>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89022>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89025>>>>>>>           End
89025>>>>>>>>
89025>>>>>>>        End
89025>>>>>>>>
89025>>>>>>>
89025>>>>>>>        Else Begin
89026>>>>>>>        Structure_Start hTable
89027>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89030>>>>>>>
89030>>>>>>>            If (iSegment > iNumSegments) Begin
89032>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89035>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89036>>>>>>>            End
89036>>>>>>>>
89036>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89039>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89042>>>>>>>                Move iNumSegments to iCurSegment
89043>>>>>>>
89043>>>>>>>                While (iCurSegment > iSegment)
89047>>>>>>>                    //*** Move index segment attributes
89047>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89050>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89053>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89056>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89059>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89062>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89065>>>>>>>                    Decrement iCurSegment
89066>>>>>>>                Loop
89067>>>>>>>>
89067>>>>>>>
89067>>>>>>>                //*** Now set new segment attributes
89067>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89070>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89073>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89076>>>>>>>            End
89076>>>>>>>>
89076>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89077>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89079>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89080>>>>>>>        End
89080>>>>>>>>
89080>>>>>>>
89080>>>>>>>        Function_Return (Err = False)
89081>>>>>>>    End_Function
89082>>>>>>>
89082>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89082>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89084>>>>>>>        Function_Return False
89085>>>>>>>    End_Function  
89086>>>>>>>    
89086>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89086>>>>>>>    // for an SQL conversion.
89086>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89088>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89088>>>>>>>        
89088>>>>>>>        Move True to bConvertTo30FormatbOK
89089>>>>>>>        Move True to bRepairAndReindexOK
89090>>>>>>>        Move True to bFixBogusDatesOK
89091>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89092>>>>>>>        
89092>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89094>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89095>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89096>>>>>>>        End                                                                                
89096>>>>>>>>
89096>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89098>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89099>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89100>>>>>>>        End
89100>>>>>>>>
89100>>>>>>>        If (bConvertTo30Format = True) Begin
89102>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89103>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89104>>>>>>>        End                                                 
89104>>>>>>>>
89104>>>>>>>        If (bRepairAndReindex = True) Begin
89106>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89107>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89108>>>>>>>        End  
89108>>>>>>>>
89108>>>>>>>        If (bFixBogusDates = True) Begin
89110>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89111>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89112>>>>>>>        End                                    
89112>>>>>>>>
89112>>>>>>>        
89112>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89113>>>>>>>    End_Function
89114>>>>>>>
89114>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89116>>>>>>>        Boolean bOK bFlexErrs bTemp
89116>>>>>>>        Handle hTable
89116>>>>>>>        String sTableName
89116>>>>>>>        Integer iCount iSize
89116>>>>>>>        
89116>>>>>>>        Move True to bOK
89117>>>>>>>        Move 0 to hTable    
89118>>>>>>>
89118>>>>>>>        Get UtilFilelistNoOfTables to iSize
89119>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89120>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89121>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89122>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89123>>>>>>>
89123>>>>>>>        Repeat
89123>>>>>>>>
89123>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89124>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89125>>>>>>>            Increment iCount
89126>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89129>>>>>>>            If (hTable > 0) Begin
89131>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89134>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89135>>>>>>>                If (bFlexErrs = False) Begin
89137>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89138>>>>>>>                    If (bTemp = False) Begin
89140>>>>>>>                        Move False to bOK
89141>>>>>>>                    End
89141>>>>>>>>
89141>>>>>>>                End
89141>>>>>>>>
89141>>>>>>>            End
89141>>>>>>>>
89141>>>>>>>        Until (hTable = 0)
89143>>>>>>>        
89143>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89144>>>>>>>        Function_Return bOK
89145>>>>>>>    End_Function
89146>>>>>>>    
89146>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89146>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89146>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89146>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89148>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89148>>>>>>>        String sRevision
89148>>>>>>>        
89148>>>>>>>        Get AutoConnectionIDLogin to bOK
89149>>>>>>>        If (bOK = False) Begin
89151>>>>>>>            Function_Return True
89152>>>>>>>        End
89152>>>>>>>>
89152>>>>>>>        Get OpenTableExclusive hTable to bOK
89153>>>>>>>        If (bOK = False) Begin
89155>>>>>>>            Function_Return True
89156>>>>>>>        End
89156>>>>>>>>
89156>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89157>>>>>>>        If (bIsEmbedded = False) Begin
89159>>>>>>>            Function_Return True
89160>>>>>>>        End                             
89160>>>>>>>>
89160>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89161>>>>>>>        If (bIsAlias = True) Begin
89163>>>>>>>            Function_Return True
89164>>>>>>>        End                     
89164>>>>>>>>
89164>>>>>>>        
89164>>>>>>>        Move False to Err
89165>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89168>>>>>>>        If (sRevision contains "2.3") Begin
89170>>>>>>>            Move False to Err
89171>>>>>>>            Set Private.phCurrentTable to hTable
89172>>>>>>>            Structure_Start hTable    
89173>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89176>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89177>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89179>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89180>>>>>>>        End
89180>>>>>>>>
89180>>>>>>>        
89180>>>>>>>        Function_Return (Err = False)
89181>>>>>>>    End_Function
89182>>>>>>>
89182>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89184>>>>>>>        Boolean bIgnore bExists bOK bResponse
89184>>>>>>>        Handle hTable   
89184>>>>>>>        String sTableName
89184>>>>>>>        
89184>>>>>>>        Move False to Err 
89185>>>>>>>        Move True to bOK
89186>>>>>>>        Move 0 to hTable
89187>>>>>>>        Repeat
89187>>>>>>>>
89187>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89190>>>>>>>            If (hTable > 0) Begin
89192>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89195>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89196>>>>>>>                If (bIgnore = False) Begin
89198>>>>>>>                    Get _UtilTableExists hTable to bExists
89199>>>>>>>                    If (bExists = False) Begin
89201>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89202>>>>>>>                        If (bResponse = False) Begin
89204>>>>>>>                            Move False to bOK
89205>>>>>>>                        End
89205>>>>>>>>
89205>>>>>>>                        
89205>>>>>>>                    End
89205>>>>>>>>
89205>>>>>>>                End
89205>>>>>>>>
89205>>>>>>>            End
89205>>>>>>>>
89205>>>>>>>        Until (hTable = 0)                     
89207>>>>>>>        
89207>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89208>>>>>>>        Function_Return bOK
89209>>>>>>>    End_Function
89210>>>>>>>    
89210>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89210>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89210>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89210>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89210>>>>>>>    //
89210>>>>>>>    // The root of the problem is the following:
89210>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89210>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89210>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89210>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89210>>>>>>>    // an SQL error will be thrown;
89210>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89210>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89212>>>>>>>        Boolean bOK bIsAlias bIsSQL
89212>>>>>>>        Integer iCount iSize iDateSize
89212>>>>>>>        Handle hTable
89212>>>>>>>        String sLogicalName
89212>>>>>>>        Integer[] aTablesToCheck aDateFields
89214>>>>>>>
89214>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89215>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89216>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89217>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89218>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89219>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89220>>>>>>>
89220>>>>>>>        Move True to bOK
89221>>>>>>>        Decrement iSize
89222>>>>>>>        for iCount from 0 to iSize
89228>>>>>>>>
89228>>>>>>>            Move aTablesToCheck[iCount] to hTable
89229>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89230>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89231>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89232>>>>>>>
89232>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89235>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89236>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89237>>>>>>>
89237>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89239>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89240>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89241>>>>>>>                If (iDateSize > 0) Begin
89243>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89244>>>>>>>                    Close hTable
89245>>>>>>>                End
89245>>>>>>>>
89245>>>>>>>            End
89245>>>>>>>>
89245>>>>>>>        Loop
89246>>>>>>>>
89246>>>>>>>
89246>>>>>>>        Close DF_ALL
89247>>>>>>>        Function_Return bOK
89248>>>>>>>    End_Function
89249>>>>>>>
89249>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89249>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89251>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89253>>>>>>>        Integer iSize iCount iType
89253>>>>>>>        Boolean bOpen bOK
89253>>>>>>>        
89253>>>>>>>        Get _UtilTableExists hTable to bOK
89254>>>>>>>        If (bOK = False) Begin
89256>>>>>>>            Set Private.phCurrentTable to hTable
89257>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89258>>>>>>>>
89258>>>>>>>            Function_Return aDateFieldsEmpty
89259>>>>>>>        End
89259>>>>>>>>
89259>>>>>>>        Set Private.phCurrentTable to hTable
89260>>>>>>>        Set Private.piCurrentField to 0
89261>>>>>>>
89261>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89261>>>>>>>        Open hTable
89263>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89266>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89266>>>>>>>        If (bOpen = False) Begin
89268>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
89268>>>>>>>            Function_Return aDateFieldsEmpty
89269>>>>>>>        End
89269>>>>>>>>
89269>>>>>>>
89269>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89272>>>>>>>        For iCount from 1 to iSize
89278>>>>>>>>
89278>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89281>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89283>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89284>>>>>>>            End
89284>>>>>>>>
89284>>>>>>>        Loop
89285>>>>>>>>
89285>>>>>>>
89285>>>>>>>        Function_Return aDateFields
89286>>>>>>>    End_Function
89287>>>>>>>
89287>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89287>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89287>>>>>>>    // and the record is saved
89287>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89287>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89287>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89289>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89289>>>>>>>        String sDriverID sDateMin
89289>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89289>>>>>>>        Date dDate dDateMin
89289>>>>>>>        Integer[] iaChangeField
89290>>>>>>>
89290>>>>>>>        Get _UtilTableExists hTable to bOK
89291>>>>>>>        // I believe we should just skip files not found and not report an error.
89291>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89291>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89291>>>>>>>        // Especially considering that this call is probably done at the very
89291>>>>>>>        // beginning of a DUF update.
89291>>>>>>>        If (bOK = False) Begin
89293>>>>>>>//            Set Private.phCurrentTable to hTable
89293>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89293>>>>>>>//            Function_Return False
89293>>>>>>>            Function_Return True
89294>>>>>>>        End
89294>>>>>>>>
89294>>>>>>>
89294>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89294>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89294>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89297>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89300>>>>>>>
89300>>>>>>>//        Send SetAllIndexesToBatch hTable True
89300>>>>>>>        Open hTable
89302>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89305>>>>>>>        If (bOpened = False) Begin
89307>>>>>>>            Function_Return False
89308>>>>>>>        End
89308>>>>>>>>
89308>>>>>>>        
89308>>>>>>>        Set Private.phCurrentTable to hTable
89309>>>>>>>        Move 0 to iRecord
89310>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89311>>>>>>>        Decrement iSize
89312>>>>>>>
89312>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89315>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89316>>>>>>>        If (iDriverIndex <> 0) Begin
89318>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89321>>>>>>>            If (sDateMin = "") Begin
89323>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89324>>>>>>>            End
89324>>>>>>>>
89324>>>>>>>            Else Begin
89325>>>>>>>                If (IsDate(sDateMin)) Begin
89327>>>>>>>                    Move sDateMin to dDateMin
89328>>>>>>>                End
89328>>>>>>>>
89328>>>>>>>                Else Begin
89329>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89330>>>>>>>                End
89330>>>>>>>>
89330>>>>>>>            End
89330>>>>>>>>
89330>>>>>>>        End
89330>>>>>>>>
89330>>>>>>>        Else Begin
89331>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89332>>>>>>>        End
89332>>>>>>>>
89332>>>>>>>
89332>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89335>>>>>>>        Set piPosition   of ghoProgressBar to 0
89336>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89337>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89338>>>>>>>        Move False to Err
89339>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89340>>>>>>>
89340>>>>>>>        Clear hTable
89341>>>>>>>        Repeat
89341>>>>>>>>
89341>>>>>>>            Vfind hTable 0 GT
89343>>>>>>>            Move Found to bFound
89344>>>>>>>            If (bFound = True) Begin
89346>>>>>>>                Move False to bSaveChanges
89347>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89348>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89349>>>>>>>                Decrement iSize
89350>>>>>>>                For iCount from 0 to iSize
89356>>>>>>>>
89356>>>>>>>                    Move aDateFields[iCount] to iField
89357>>>>>>>                    Get_Field_Value hTable iField to dDate
89360>>>>>>>                    If (bFixZeroDates = True) Begin
89362>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89363>>>>>>>                    End
89363>>>>>>>>
89363>>>>>>>                    Else Begin
89364>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89365>>>>>>>                    End
89365>>>>>>>>
89365>>>>>>>                    If (bChange = True) Begin
89367>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89368>>>>>>>                    End
89368>>>>>>>>
89368>>>>>>>                Loop
89369>>>>>>>>
89369>>>>>>>
89369>>>>>>>                // Only change Date fields that needs to be changed.
89369>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89371>>>>>>>                    Reread hTable
89375>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89376>>>>>>>                        Decrement iSize
89377>>>>>>>                        For iCount from 0 to iSize
89383>>>>>>>>
89383>>>>>>>                            Move iaChangeField[iCount] to iField
89384>>>>>>>                            Set Private.piCurrentField to iField
89385>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89388>>>>>>>                        Loop
89389>>>>>>>>
89389>>>>>>>                        Move False to Err
89390>>>>>>>                        SaveRecord hTable
89391>>>>>>>                    Unlock
89392>>>>>>>>
89392>>>>>>>                End
89392>>>>>>>>
89392>>>>>>>
89392>>>>>>>                Increment iRecord
89393>>>>>>>                // Increment the StatusPanel counter and check the
89393>>>>>>>                // cancel status every 100 records rather than every
89393>>>>>>>                // record, it's way faster.
89393>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89395>>>>>>>                    Send DoAdvance of ghoProgressBar
89396>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89397>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89398>>>>>>>                End
89398>>>>>>>>
89398>>>>>>>            End
89398>>>>>>>>
89398>>>>>>>        Until (bFound = False)
89400>>>>>>>
89400>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89403>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89405>>>>>>>            Send SetAllIndexesToBatch hTable False
89406>>>>>>>        End
89406>>>>>>>>
89406>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89407>>>>>>>
89407>>>>>>>        Function_Return (Err = False)
89408>>>>>>>    End_Function
89409>>>>>>>
89409>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89409>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89409>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89411>>>>>>>        Boolean bIsSame
89411>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89411>>>>>>>
89411>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89412>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89413>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89414>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89415>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89416>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89417>>>>>>>
89417>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89419>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89420>>>>>>>        End
89420>>>>>>>>
89420>>>>>>>        Else Begin
89421>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89422>>>>>>>        End
89422>>>>>>>>
89422>>>>>>>        If (bIsSame = False) Begin
89424>>>>>>>            Function_Return False
89425>>>>>>>        End
89425>>>>>>>>
89425>>>>>>>
89425>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89426>>>>>>>        If (bIsSame = False) Begin
89428>>>>>>>            Function_Return False
89429>>>>>>>        End
89429>>>>>>>>
89429>>>>>>>
89429>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89430>>>>>>>        If (bIsSame = False) Begin
89432>>>>>>>            Function_Return False
89433>>>>>>>        End
89433>>>>>>>>
89433>>>>>>>
89433>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89434>>>>>>>        If (bIsSame = False) Begin
89436>>>>>>>            Function_Return False
89437>>>>>>>        End
89437>>>>>>>>
89437>>>>>>>
89437>>>>>>>        Function_Return bIsSame
89438>>>>>>>    End_Function
89439>>>>>>>
89439>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89441>>>>>>>        Handle hTableFrom hTableTo
89441>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89441>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89441>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89441>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89441>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89442>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89442>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89443>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89443>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89444>>>>>>>
89444>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89445>>>>>>>        If (bIsSame = True) Begin
89447>>>>>>>            Function_Return True
89448>>>>>>>        End
89448>>>>>>>>
89448>>>>>>>
89448>>>>>>>        Move False to bFilelistError
89449>>>>>>>        Move True to bIsSame
89450>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89451>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89452>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89453>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89454>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89455>>>>>>>
89455>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89456>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89457>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89458>>>>>>>
89458>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89458>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89458>>>>>>>        If (bCodeGenerateMode = True) Begin
89460>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89460>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89462>>>>>>>                Function_Return False
89463>>>>>>>            End
89463>>>>>>>>
89463>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89464>>>>>>>            If (bIsSame = False) Begin
89466>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89467>>>>>>>                Move True to bFilelistError
89468>>>>>>>                Function_Return False
89469>>>>>>>            End
89469>>>>>>>>
89469>>>>>>>        End
89469>>>>>>>>
89469>>>>>>>
89469>>>>>>>        If (bCodeGenerateMode = False) Begin
89471>>>>>>>            // Then we want to create this table
89471>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89473>>>>>>>                Function_Return False
89474>>>>>>>            End
89474>>>>>>>>
89474>>>>>>>
89474>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89475>>>>>>>            If (bIsSame = False) Begin
89477>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89478>>>>>>>>
89478>>>>>>>                Move True to bFilelistError
89479>>>>>>>                Function_Return False
89480>>>>>>>            End
89480>>>>>>>>
89480>>>>>>>        End
89480>>>>>>>>
89480>>>>>>>
89480>>>>>>>        // Check columns:
89480>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89481>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89482>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89483>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89484>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89485>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89486>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89487>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89488>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89489>>>>>>>        If (bIsSame = False) Begin
89491>>>>>>>            Function_Return False
89492>>>>>>>        End
89492>>>>>>>>
89492>>>>>>>
89492>>>>>>>        // ...then check indexes:
89492>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89493>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89494>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89495>>>>>>>        If (bIsSame = False) Begin
89497>>>>>>>            Function_Return False
89498>>>>>>>        End
89498>>>>>>>>
89498>>>>>>>
89498>>>>>>>        // ...and finally relationships:
89498>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89499>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89500>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89501>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89502>>>>>>>
89502>>>>>>>        Function_Return (bIsSame = True)
89503>>>>>>>    End_Function
89504>>>>>>>
89504>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89504>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89506>>>>>>>        Handle hTable
89506>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89506>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89506>>>>>>>
89506>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89508>>>>>>>            Move True to bFilelistError
89509>>>>>>>            Function_Return False
89510>>>>>>>        End
89510>>>>>>>>
89510>>>>>>>
89510>>>>>>>        Move APITableCompare.hTable to hTable
89511>>>>>>>        Move True  to bIsSame
89512>>>>>>>        Move False to bFilelistError
89513>>>>>>>
89513>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89515>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89516>>>>>>>        End
89516>>>>>>>>
89516>>>>>>>        Else Begin
89517>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89518>>>>>>>        End
89518>>>>>>>>
89518>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89519>>>>>>>
89519>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89520>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89521>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89522>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89523>>>>>>>
89523>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89523>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89523>>>>>>>        If (bCodeGenerateMode = True) Begin
89525>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89525>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89527>>>>>>>                Function_Return False
89528>>>>>>>            End
89528>>>>>>>>
89528>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89529>>>>>>>            If (bIsSame = False) Begin
89531>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89532>>>>>>>                Move True to bFilelistError
89533>>>>>>>                Function_Return False
89534>>>>>>>            End
89534>>>>>>>>
89534>>>>>>>        End
89534>>>>>>>>
89534>>>>>>>
89534>>>>>>>        If (bCodeGenerateMode = False) Begin
89536>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89538>>>>>>>                // Then we might want to create this table
89538>>>>>>>                Function_Return False
89539>>>>>>>            End
89539>>>>>>>>
89539>>>>>>>
89539>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89540>>>>>>>            If (bIsSame = False) Begin
89542>>>>>>>                Function_Return False
89543>>>>>>>            End
89543>>>>>>>>
89543>>>>>>>
89543>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89544>>>>>>>            If (bIsSame = False) Begin
89546>>>>>>>                Function_Return False
89547>>>>>>>            End
89547>>>>>>>>
89547>>>>>>>
89547>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89548>>>>>>>            If (bIsSame = False) Begin
89550>>>>>>>                Function_Return False
89551>>>>>>>            End
89551>>>>>>>>
89551>>>>>>>
89551>>>>>>>            // Check table names et al.
89551>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89552>>>>>>>            If (bIsSame = False) Begin
89554>>>>>>>                Function_Return False
89555>>>>>>>            End
89555>>>>>>>>
89555>>>>>>>        End
89555>>>>>>>>
89555>>>>>>>
89555>>>>>>>        // Check Columns:
89555>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89556>>>>>>>        If (bIsSame = False) Begin
89558>>>>>>>            Function_Return False
89559>>>>>>>        End
89559>>>>>>>>
89559>>>>>>>
89559>>>>>>>        // ...then check Indexes:
89559>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89560>>>>>>>        If (bIsSame = False) Begin
89562>>>>>>>            Function_Return False
89563>>>>>>>        End
89563>>>>>>>>
89563>>>>>>>
89563>>>>>>>        // ...and finally Relationships:
89563>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89564>>>>>>>
89564>>>>>>>        Function_Return (bIsSame = True)
89565>>>>>>>    End_Function
89566>>>>>>>
89566>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89566>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89566>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89566>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89566>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89568>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89568>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89568>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89568>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89570>>>>>>>        tAPIColumn[]    aApiColumns
89570>>>>>>>        tAPIColumn[]    aApiColumns
89571>>>>>>>        tAPIIndex[]     aApiIndexes
89571>>>>>>>        tAPIIndex[]     aApiIndexes
89572>>>>>>>        tAPIRelation[]  aApiRelations
89572>>>>>>>        tAPIRelation[]  aApiRelations
89573>>>>>>>        Handle hTable
89573>>>>>>>        Integer iCount
89573>>>>>>>        Boolean bUserCancel bOK
89573>>>>>>>        String sLogicalName sMessageText
89573>>>>>>>
89573>>>>>>>        Get AutoConnectionIDLogin to bOK
89574>>>>>>>        Move 0 to hTable
89575>>>>>>>        If (bFromTables = True) Begin
89577>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89578>>>>>>>            If (bCompareUtil = True) Begin
89580>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89581>>>>>>>            End
89581>>>>>>>>
89581>>>>>>>        End
89581>>>>>>>>
89581>>>>>>>        Else Begin
89582>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89583>>>>>>>            If (bCompareUtil = True) Begin
89585>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89586>>>>>>>            End
89586>>>>>>>>
89586>>>>>>>        End
89586>>>>>>>>
89586>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89587>>>>>>>
89587>>>>>>>        Get UtilFilelistNoOfTables to iCount
89588>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89589>>>>>>>        Move 0 to iCount
89590>>>>>>>
89590>>>>>>>        Repeat
89590>>>>>>>>
89590>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89593>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89595>>>>>>>
89595>>>>>>>                Open hTable
89597>>>>>>>                // ToDo: Needs to be revised
89597>>>>>>>                // For some reason tables may be reported as "unopened", while in
89597>>>>>>>                // fact the open was successful (!)
89597>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89597>>>>>>>//                If (bIsOpen = False) Begin
89597>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89597>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89597>>>>>>>//                    Function_Return aApiTablesEmpty
89597>>>>>>>//                End
89597>>>>>>>
89597>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89600>>>>>>>                Set piPosition of ghoProgressBar to iCount
89601>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89602>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89603>>>>>>>
89603>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89604>>>>>>>//                Close hTable DF_PERMANENT
89604>>>>>>>                Increment iCount
89605>>>>>>>            End
89605>>>>>>>>
89605>>>>>>>
89605>>>>>>>            If (bStatusPanel = True) Begin
89607>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89608>>>>>>>                If (bUserCancel = True) Begin
89610>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89611>>>>>>>                    Function_Return aApiTablesEmpty
89612>>>>>>>                End
89612>>>>>>>>
89612>>>>>>>            End
89612>>>>>>>>
89612>>>>>>>
89612>>>>>>>        Until (hTable = 0)
89614>>>>>>>
89614>>>>>>>        Function_Return aApiTables
89615>>>>>>>    End_Function
89616>>>>>>>
89616>>>>>>>    // Returns a 'single' table APITable struct.
89616>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89618>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89618>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89618>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89618>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89618>>>>>>>        tAPIColumn[]     aApiColumns
89618>>>>>>>        tAPIColumn[]     aApiColumns
89619>>>>>>>        tAPIIndex[]      aApiIndexes
89619>>>>>>>        tAPIIndex[]      aApiIndexes
89620>>>>>>>        tAPIRelation[]   aApiRelations
89620>>>>>>>        tAPIRelation[]   aApiRelations
89621>>>>>>>        Boolean bIsOpen
89621>>>>>>>
89621>>>>>>>        Open hTable
89623>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89626>>>>>>>        If (bIsOpen = False) Begin
89628>>>>>>>            Move True to ApiTableEmpty.bError
89629>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89630>>>>>>>            Function_Return ApiTableEmpty
89631>>>>>>>        End
89631>>>>>>>>
89631>>>>>>>
89631>>>>>>>        // Fill Table Name Info
89631>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89632>>>>>>>
89632>>>>>>>        // Fill columns
89632>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89633>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89635>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89637>>>>>>>                Move True to ApiTableEmpty.bError
89638>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89639>>>>>>>                Function_Return ApiTableEmpty
89640>>>>>>>            End
89640>>>>>>>>
89640>>>>>>>        End
89640>>>>>>>>
89640>>>>>>>
89640>>>>>>>        // Fill indexes
89640>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89641>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89643>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89645>>>>>>>                Move True to ApiTableEmpty.bError
89646>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89647>>>>>>>                Function_Return ApiTableEmpty
89648>>>>>>>            End
89648>>>>>>>>
89648>>>>>>>        End
89648>>>>>>>>
89648>>>>>>>
89648>>>>>>>        // Fill relationships
89648>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89649>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89651>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89653>>>>>>>                Move True to ApiTableEmpty.bError
89654>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89655>>>>>>>                Function_Return ApiTableEmpty
89656>>>>>>>            End
89656>>>>>>>>
89656>>>>>>>        End
89656>>>>>>>>
89656>>>>>>>
89656>>>>>>>        Move hTable             to ApiTable.hTable
89657>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89658>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89659>>>>>>>
89659>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89660>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89661>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89662>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89663>>>>>>>
89663>>>>>>>        Function_Return ApiTable
89664>>>>>>>    End_Function
89665>>>>>>>
89665>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89667>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89667>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89667>>>>>>>        Boolean bIsOpen
89667>>>>>>>
89667>>>>>>>        Open hTable
89669>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89672>>>>>>>        If (bIsOpen = False) Begin
89674>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89675>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89676>>>>>>>            Function_Return APITableNameInfoEmpty
89677>>>>>>>        End
89677>>>>>>>>
89677>>>>>>>
89677>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89678>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89681>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89684>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89687>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89690>>>>>>>
89690>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89691>>>>>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89692>>>>>>>
89692>>>>>>>        Function_Return APITableNameInfo
89693>>>>>>>    End_Function
89694>>>>>>>
89694>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89696>>>>>>>        Integer iSize iCount iItem
89696>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89696>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89696>>>>>>>
89696>>>>>>>        Move -1 to iItem
89697>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89698>>>>>>>        Decrement iSize
89699>>>>>>>        for iCount from 0 to iSize
89705>>>>>>>>
89705>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89706>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89708>>>>>>>                Move iCount to iItem
89709>>>>>>>                Move iSize  to iCount // We're done.
89710>>>>>>>            End
89710>>>>>>>>
89710>>>>>>>        Loop
89711>>>>>>>>
89711>>>>>>>
89711>>>>>>>        Function_Return iItem
89712>>>>>>>    End_Function
89713>>>>>>>
89713>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89715>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89718>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89721>>>>>>>
89721>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89724>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89727>>>>>>>
89727>>>>>>>        Function_Return (EQ)
89728>>>>>>>    End_Function
89729>>>>>>>
89729>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89731>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89731>>>>>>>        Handle hTable
89731>>>>>>>        tAPITable[] aAPITableFromAndTo
89731>>>>>>>        tAPITable[] aAPITableFromAndTo
89732>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89732>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89732>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89732>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89732>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89732>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89733>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89733>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89734>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89734>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89735>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89735>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89736>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89736>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89736>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89736>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89739>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89739>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89742>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89742>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89745>>>>>>>
89745>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89746>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89747>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89749>>>>>>>            Function_Return aAPITableCompare
89750>>>>>>>        End
89750>>>>>>>>
89750>>>>>>>
89750>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89751>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89752>>>>>>>
89752>>>>>>>        Move 0 to iItem
89753>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89754>>>>>>>        Decrement iSize
89755>>>>>>>        for iCount from 0 to iSize
89761>>>>>>>>
89761>>>>>>>
89761>>>>>>>            Move iCount to iItemFrom
89762>>>>>>>            Move iCount to iItemTo
89763>>>>>>>            Move APITableEmpty to APITableFrom
89764>>>>>>>            Move APITableEmpty to APITableTo
89765>>>>>>>
89765>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89767>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89768>>>>>>>            End
89768>>>>>>>>
89768>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89770>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89771>>>>>>>            End
89771>>>>>>>>
89771>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89773>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89774>>>>>>>                Move (iCount + 1) to iItemTo
89775>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89776>>>>>>>            End
89776>>>>>>>>
89776>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89778>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89779>>>>>>>                If (iItemTo <> -1) Begin
89781>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89782>>>>>>>                End
89782>>>>>>>>
89782>>>>>>>                Else Begin
89783>>>>>>>                    Move APITableEmpty to APITableTo
89784>>>>>>>                End
89784>>>>>>>>
89784>>>>>>>            End
89784>>>>>>>>
89784>>>>>>>
89784>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89785>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89786>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89787>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89788>>>>>>>
89788>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89789>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89790>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89791>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89792>>>>>>>
89792>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89793>>>>>>>
89793>>>>>>>            If (hTable > 0) Begin
89795>>>>>>>
89795>>>>>>>                // Table info:
89795>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89796>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89797>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89798>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89799>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89800>>>>>>>
89800>>>>>>>                // Column info:
89800>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89801>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89802>>>>>>>
89802>>>>>>>                // Index info:
89802>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89803>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89804>>>>>>>
89804>>>>>>>                // Relation info:
89804>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89805>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89806>>>>>>>
89806>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89807>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89808>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89809>>>>>>>                If (iItemTo > iItemFrom) Begin
89811>>>>>>>                    Increment iCount
89812>>>>>>>                End
89812>>>>>>>>
89812>>>>>>>                Increment iItem
89813>>>>>>>            End
89813>>>>>>>>
89813>>>>>>>
89813>>>>>>>        Loop
89814>>>>>>>>
89814>>>>>>>
89814>>>>>>>        Function_Return aAPITableCompare
89815>>>>>>>    End_Function
89816>>>>>>>
89816>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89818>>>>>>>        Integer iSize iCount iItem
89818>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89818>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89818>>>>>>>
89818>>>>>>>        Move -1 to iItem
89819>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89820>>>>>>>        Decrement iSize
89821>>>>>>>        For iCount from 0 to iSize
89827>>>>>>>>
89827>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89828>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89830>>>>>>>                Move iCount to iItem
89831>>>>>>>                Move iSize  to iCount // We're done.
89832>>>>>>>            End
89832>>>>>>>>
89832>>>>>>>        Loop
89833>>>>>>>>
89833>>>>>>>
89833>>>>>>>        Function_Return iItem
89834>>>>>>>    End_Function
89835>>>>>>>
89835>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89837>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89837>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89837>>>>>>>
89837>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89839>>>>>>>            Function_Return APITableNameInfoCompare
89840>>>>>>>        End
89840>>>>>>>>
89840>>>>>>>
89840>>>>>>>        // FROM database info:
89840>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89842>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89843>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89844>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89845>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89846>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89847>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89848>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89849>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89850>>>>>>>        End
89850>>>>>>>>
89850>>>>>>>
89850>>>>>>>        // TO database info:
89850>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89852>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89853>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89854>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89855>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89856>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89857>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89858>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89859>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89860>>>>>>>        End
89860>>>>>>>>
89860>>>>>>>
89860>>>>>>>        Function_Return APITableNameInfoCompare
89861>>>>>>>    End_Function
89862>>>>>>>
89862>>>>>>>    // Note:
89862>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89862>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89862>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89862>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89862>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89862>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
89864>>>>>>>        String sTableName
89864>>>>>>>        Boolean bOpen bExists bOK
89864>>>>>>>
89864>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
89865>>>>>>>        If (bExists = False) Begin
89867>>>>>>>            Function_Return ""
89868>>>>>>>        End
89868>>>>>>>>
89868>>>>>>>
89868>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89869>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89872>>>>>>>        If (bOpen = False) Begin
89874>>>>>>>            Get AutoConnectionIDLogin to bOK
89875>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89876>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89877>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89878>>>>>>>            Open hTable
89880>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89881>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89882>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89883>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89886>>>>>>>        End
89886>>>>>>>>
89886>>>>>>>        If (bOpen = True) Begin
89888>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89889>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89892>>>>>>>            // If blank it is an embedded table:
89892>>>>>>>            If (sTableName = "") Begin
89894>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89897>>>>>>>                Move 0 to LastErr
89898>>>>>>>                Move False to Err
89899>>>>>>>            End
89899>>>>>>>>
89899>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89900>>>>>>>        End
89900>>>>>>>>
89900>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89901>>>>>>>        Move 0 to LastErr
89902>>>>>>>
89902>>>>>>>        Function_Return sTableName
89903>>>>>>>    End_Function
89904>>>>>>>
89904>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89904>>>>>>>    // Returns 0 if unsuccessful.
89904>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89904>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89906>>>>>>>        String sValue sPrefixTableName sDriverID
89906>>>>>>>        Handle hTable hRetval
89906>>>>>>>
89906>>>>>>>        Get psDriverID to sDriverID
89907>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89909>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89910>>>>>>>        End
89910>>>>>>>>
89910>>>>>>>        Move 0 to hTable
89911>>>>>>>        Move 0 to hRetval
89912>>>>>>>        Repeat
89912>>>>>>>>
89912>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89915>>>>>>>            If (hTable <> 0) Begin
89917>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89920>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89922>>>>>>>                    Move hTable to hRetval
89923>>>>>>>                    Move 0 to hTable
89924>>>>>>>                End
89924>>>>>>>>
89924>>>>>>>            End
89924>>>>>>>>
89924>>>>>>>        Until (hTable = 0)
89926>>>>>>>
89926>>>>>>>        Function_Return hRetval
89927>>>>>>>    End_Function
89928>>>>>>>
89928>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89928>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89928>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89930>>>>>>>        Boolean bOK bExists
89930>>>>>>>        String sDataPath sBackupFolder
89930>>>>>>>
89930>>>>>>>        Close DF_ALL DF_PERMANENT
89931>>>>>>>        Send DoAdvance of ghoProgressBar
89932>>>>>>>
89932>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89933>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89934>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89935>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89936>>>>>>>
89936>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89937>>>>>>>        If (bExists = False) Begin
89939>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89940>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89941>>>>>>>            If (bExists = False) Begin
89943>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89944>>>>>>>>
89944>>>>>>>                Function_Return False
89945>>>>>>>            End
89945>>>>>>>>
89945>>>>>>>        End
89945>>>>>>>>
89945>>>>>>>
89945>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89946>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89947>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89948>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89949>>>>>>>        // We need to wait for Windows before we can copy files back
89949>>>>>>>        Sleep 2  
89950>>>>>>>        
89950>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
89950>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89951>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89952>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89953>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89954>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89955>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89956>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89956>>>>>>>        
89956>>>>>>>
89956>>>>>>>        Set Message_Text of ghoStatusPanel to ""
89957>>>>>>>        Function_Return True
89958>>>>>>>    End_Function
89959>>>>>>>    
89959>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89961>>>>>>>        Boolean bOK bRetval
89961>>>>>>>        Handle hTable
89961>>>>>>>        Integer iSize iCount
89961>>>>>>>        
89961>>>>>>>        Move True to bOK
89962>>>>>>>        Get UtilFilelistNoOfTables to iSize
89963>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89964>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89965>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89966>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89967>>>>>>>
89967>>>>>>>        Repeat
89967>>>>>>>>
89967>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89968>>>>>>>            Increment iCount
89969>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89972>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89974>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
89975>>>>>>>                If (bRetval = False) Begin
89977>>>>>>>                    Move False to bOK
89978>>>>>>>                End
89978>>>>>>>>
89978>>>>>>>            End
89978>>>>>>>>
89978>>>>>>>        Until (hTable = 0)
89980>>>>>>>                
89980>>>>>>>        Function_Return bOK
89981>>>>>>>    End_Function           
89982>>>>>>>    
89982>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89982>>>>>>>    // After the header has been repaired - also makes a re-index.  
89982>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89982>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89984>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89984>>>>>>>        Integer iRetval
89984>>>>>>>        String sRootName sFileName sDataPath
89984>>>>>>>        
89984>>>>>>>        Move False to Err
89985>>>>>>>        Move 0 to LastErr 
89986>>>>>>>        Move True to bOK
89987>>>>>>>        
89987>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89988>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89990>>>>>>>            Function_Return True
89991>>>>>>>        End
89991>>>>>>>>
89991>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
89992>>>>>>>        If (bIsAlias = True) Begin
89994>>>>>>>            Function_Return True
89995>>>>>>>        End
89995>>>>>>>>
89995>>>>>>>        
89995>>>>>>>        // Check for bad file and remove if exists
89995>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89998>>>>>>>        Set private.phCurrentTable to hTable  
89999>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90000>>>>>>>        
90000>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90000>>>>>>>        // with a "4077 - File in use" error.
90000>>>>>>>        Close DF_ALL DF_PERMANENT    
90001>>>>>>>        Open hTable
90003>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90006>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90007>>>>>>>        If (bIsOpen = False) Begin
90009>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90010>>>>>>>>
90010>>>>>>>            Function_Return False        
90011>>>>>>>        End
90011>>>>>>>>
90011>>>>>>>
90011>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90012>>>>>>>        If (bBadExists = True) Begin
90014>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90015>>>>>>>            Get vDeleteFile sFileName to iRetval
90016>>>>>>>        End
90016>>>>>>>>
90016>>>>>>>        
90016>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90017>>>>>>>        
90017>>>>>>>        Move False to Err
90018>>>>>>>        // **** Repair and reindex the table. ****
90018>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90019>>>>>>>
90019>>>>>>>        // Check for bad file: if it exists, something went wrong
90019>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90020>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90021>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90022>>>>>>>        If (bBadExists = True) Begin
90024>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90025>>>>>>>>
90025>>>>>>>            Move False to bOK
90026>>>>>>>        End
90026>>>>>>>>
90026>>>>>>>        Close hTable
90027>>>>>>>
90027>>>>>>>        Function_Return bOK
90028>>>>>>>    End_Function
90029>>>>>>>
90029>>>>>>>    // Repair and reindex the named DataFlex data-table.
90029>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90029>>>>>>>    // so use with care (make sure you only pass embedded table names).
90029>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90031>>>>>>>        String sMode
90031>>>>>>>        Integer iVoid
90031>>>>>>>
90031>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90032>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90033>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90034>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90039>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90040>>>>>>>        Function_Return (iVoid = 0)
90041>>>>>>>    End_Function
90042>>>>>>>
90042>>>>>>>    // Returns _two_ arrays.
90042>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90042>>>>>>>    // Also returns all files that are Alias files in a second array.
90042>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90042>>>>>>>    //            the DoSetAllMasterAndAlias message.
90042>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90044>>>>>>>        Integer[] iaFileIsAlias
90045>>>>>>>        Integer hTable iFileAlias iSize
90045>>>>>>>        Boolean bOpen
90045>>>>>>>
90045>>>>>>>        Move 0 to hTable
90046>>>>>>>        Repeat
90046>>>>>>>>
90046>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90049>>>>>>>            If (hTable <> 0) Begin
90051>>>>>>>                Open hTable
90053>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90056>>>>>>>                If (bOpen = True) Begin
90058>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90061>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90063>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90064>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90065>>>>>>>                    End
90065>>>>>>>>
90065>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90068>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90069>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90070>>>>>>>                    End
90070>>>>>>>>
90070>>>>>>>                End
90070>>>>>>>>
90070>>>>>>>            End
90070>>>>>>>>
90070>>>>>>>        Until (hTable = 0)
90072>>>>>>>
90072>>>>>>>        Function_Return iaFileIsAlias
90073>>>>>>>    End_Function  
90074>>>>>>>    
90074>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90074>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90076>>>>>>>        String sMode
90076>>>>>>>        Integer iRepairNeeded bIsOpen
90076>>>>>>>
90076>>>>>>>        Move "0" to sMode
90077>>>>>>>        Set private.phCurrentTable to hTable 
90078>>>>>>>        Close hTable
90079>>>>>>>        Open hTable
90081>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90084>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90089>>>>>>>
90089>>>>>>>        Function_Return iRepairNeeded
90090>>>>>>>    End_Function
90091>>>>>>>
90091>>>>>>>    // Helper function
90091>>>>>>>    // Takes two params:
90091>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90091>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90091>>>>>>>    // Returns:
90091>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90091>>>>>>>    //  DF_FILE_IS_MASTER if master
90091>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90091>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90093>>>>>>>        Integer i iSize
90093>>>>>>>
90093>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90094>>>>>>>        Decrement iSize
90095>>>>>>>        for i from 0 to iSize
90101>>>>>>>>
90101>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90103>>>>>>>                Function_Return DF_FILE_IS_MASTER
90104>>>>>>>            End
90104>>>>>>>>
90104>>>>>>>        Loop
90105>>>>>>>>
90105>>>>>>>
90105>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90106>>>>>>>        Decrement iSize
90107>>>>>>>        for i from 0 to iSize
90113>>>>>>>>
90113>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90115>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90116>>>>>>>            End
90116>>>>>>>>
90116>>>>>>>        Loop
90117>>>>>>>>
90117>>>>>>>
90117>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90118>>>>>>>    End_Function
90119>>>>>>>
90119>>>>>>>    // Determine the available indexes of a table.
90119>>>>>>>    //
90119>>>>>>>    // Arguments:
90119>>>>>>>    //   Handle hTable - The number of the table
90119>>>>>>>    //
90119>>>>>>>    // Returns:
90119>>>>>>>    //   String - A string to be used with the sort command
90119>>>>>>>    //   to re-index all indexes of a table.
90119>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90121>>>>>>>        String  sSortString
90121>>>>>>>        Integer iLastIndex iNumSegments iCount
90121>>>>>>>
90121>>>>>>>        Move "" to sSortString
90122>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90125>>>>>>>
90125>>>>>>>        for iCount from 1 to iLastIndex
90131>>>>>>>>
90131>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90134>>>>>>>            If iNumSegments Begin
90136>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90139>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90140>>>>>>>            End
90140>>>>>>>>
90140>>>>>>>        Loop
90141>>>>>>>>
90141>>>>>>>
90141>>>>>>>        Function_Return sSortString
90142>>>>>>>    End_Function
90143>>>>>>>
90143>>>>>>>    
90143>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90143>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90145>>>>>>>        Function_Return False
90146>>>>>>>    End_Function
90147>>>>>>>
90147>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90147>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90149>>>>>>>        Boolean bIsSame
90149>>>>>>>        Integer iCount iColumns iColumn
90149>>>>>>>
90149>>>>>>>        Move True to bIsSame
90150>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90151>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90152>>>>>>>        Decrement iColumns
90153>>>>>>>
90153>>>>>>>        for iCount from 0 to iColumns
90159>>>>>>>>
90159>>>>>>>            Set piPosition of ghoProgressBar to iCount
90160>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90161>>>>>>>            If (bIsSame = False) Begin
90163>>>>>>>                Function_Return False
90164>>>>>>>            End
90164>>>>>>>>
90164>>>>>>>        Loop
90165>>>>>>>>
90165>>>>>>>
90165>>>>>>>        Function_Return (bIsSame = True)
90166>>>>>>>    End_Function
90167>>>>>>>
90167>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90167>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90169>>>>>>>        Integer iFromType iToType iDbType
90169>>>>>>>        tColumnType ColumnType
90169>>>>>>>        tColumnType ColumnType
90169>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90169>>>>>>>
90169>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90171>>>>>>>            Function_Return False
90172>>>>>>>        End
90172>>>>>>>>
90172>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90174>>>>>>>            Function_Return False
90175>>>>>>>        End
90175>>>>>>>>
90175>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90177>>>>>>>            Function_Return False
90178>>>>>>>        End                                                                
90178>>>>>>>>
90178>>>>>>>
90178>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90180>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90182>>>>>>>                Function_Return False
90183>>>>>>>            End
90183>>>>>>>>
90183>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90185>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90187>>>>>>>                    End
90187>>>>>>>>
90187>>>>>>>                Else Begin
90188>>>>>>>                    Function_Return False
90189>>>>>>>                End
90189>>>>>>>>
90189>>>>>>>            End
90189>>>>>>>>
90189>>>>>>>        End
90189>>>>>>>>
90189>>>>>>>
90189>>>>>>>        Get piDbType                       to iDbType
90190>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90191>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90192>>>>>>>
90192>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90192>>>>>>>        // data types between Embedded and SQL.
90192>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90194>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90195>>>>>>>        End
90195>>>>>>>>
90195>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90197>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90198>>>>>>>        End
90198>>>>>>>>
90198>>>>>>>
90198>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90199>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90200>>>>>>>
90200>>>>>>>        // Make Date and DateTime comparison?
90200>>>>>>>        If (bCompareDate_DataTime = True) Begin
90202>>>>>>>            If (iFromType <> iToType) Begin
90204>>>>>>>                Function_Return False
90205>>>>>>>            End
90205>>>>>>>>
90205>>>>>>>        End
90205>>>>>>>>
90205>>>>>>>
90205>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90205>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90207>>>>>>>            If (iFromType <> iToType) Begin
90209>>>>>>>                Function_Return False
90210>>>>>>>            End
90210>>>>>>>>
90210>>>>>>>        End
90210>>>>>>>>
90210>>>>>>>
90210>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90210>>>>>>>        If (bIsDateTypeFrom = False) Begin
90212>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90214>>>>>>>                Function_Return False
90215>>>>>>>            End
90215>>>>>>>>
90215>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90217>>>>>>>                Function_Return False
90218>>>>>>>            End
90218>>>>>>>>
90218>>>>>>>        End
90218>>>>>>>>
90218>>>>>>>
90218>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90220>>>>>>>            Function_Return False
90221>>>>>>>        End
90221>>>>>>>>
90221>>>>>>>
90221>>>>>>>        Function_Return True
90222>>>>>>>    End_Function
90223>>>>>>>
90223>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90225>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90225>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90225>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90225>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90227>>>>>>>        String sDriverID sRootName sLogicalName
90227>>>>>>>
90227>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90228>>>>>>>        Get piDbType to iDbType
90229>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90232>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90235>>>>>>>
90235>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90238>>>>>>>        If (bIsOpen = False) Begin
90240>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90241>>>>>>>            Open hTable
90243>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90244>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90247>>>>>>>            If (bIsOpen = False) Begin
90249>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90250>>>>>>>                Move True to APIColumnsEmpty[0].bError
90251>>>>>>>                Function_Return APIColumnsEmpty
90252>>>>>>>            End
90252>>>>>>>>
90252>>>>>>>        End
90252>>>>>>>>
90252>>>>>>>
90252>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90255>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90256>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90257>>>>>>>
90257>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90258>>>>>>>        If (bIsSqlTable = True) Begin
90260>>>>>>>            Get _UtilTableExists hTable to bExists
90261>>>>>>>            If (bExists = False) Begin
90263>>>>>>>                Move True to APIColumnsEmpty[0].bError
90264>>>>>>>                Function_Return APIColumnsEmpty
90265>>>>>>>            End
90265>>>>>>>>
90265>>>>>>>        End
90265>>>>>>>>
90265>>>>>>>
90265>>>>>>>        Move 0 to iCount
90266>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90269>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90270>>>>>>>
90270>>>>>>>        for iColumn from 1 to iNumColumns
90276>>>>>>>>
90276>>>>>>>            Move 0 to iOptions
90277>>>>>>>            Move False to bIdentityKey
90278>>>>>>>            Move False to Err
90279>>>>>>>            Move 0     to LastErr
90280>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90281>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90282>>>>>>>            If (bDawSqlDriver = True) Begin
90284>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90285>>>>>>>                If (bIsSqlTable = True) Begin
90287>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90290>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90291>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90294>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90297>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90300>>>>>>>                End
90300>>>>>>>>
90300>>>>>>>                Else Begin
90301>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90304>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90305>>>>>>>                End
90305>>>>>>>>
90305>>>>>>>
90305>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90305>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90308>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90309>>>>>>>                If (bExists = False) Begin
90311>>>>>>>                    Move 0 to APIColumns[iCount].iType
90312>>>>>>>                End
90312>>>>>>>>
90312>>>>>>>                If (bExists = True) Begin
90314>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90317>>>>>>>                End
90317>>>>>>>>
90317>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90318>>>>>>>                If (bIdentityKey = True) Begin
90320>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90321>>>>>>>                End
90321>>>>>>>>
90321>>>>>>>            End
90321>>>>>>>>
90321>>>>>>>            Else Begin
90322>>>>>>>                Move False to Err
90323>>>>>>>                Move 0     to LastErr
90324>>>>>>>                If (bIsSqlTable = True) Begin
90326>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90329>>>>>>>                End
90329>>>>>>>>
90329>>>>>>>                Else Begin
90330>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90333>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90334>>>>>>>                End
90334>>>>>>>>
90334>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90334>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90335>>>>>>>                If (bExists = False) Begin
90337>>>>>>>                    Move 0 to APIColumns[iCount].iType
90338>>>>>>>                End
90338>>>>>>>>
90338>>>>>>>            End
90338>>>>>>>>
90338>>>>>>>
90338>>>>>>>            If (bExists = True) Begin
90340>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90341>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90344>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90344>>>>>>>//                If (bIsSqlTable = True) Begin
90344>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90344>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90344>>>>>>>//                End
90344>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90347>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90350>>>>>>>
90350>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90350>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90350>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90352>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90355>>>>>>>                    If (iType = DF_OVERLAP) Begin
90357>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90358>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90359>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90360>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90361>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90362>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90363>>>>>>>                        Decrement iCount
90364>>>>>>>                    End
90364>>>>>>>>
90364>>>>>>>                End
90364>>>>>>>>
90364>>>>>>>            End
90364>>>>>>>>
90364>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90365>>>>>>>            If (bUserCancel = True) Begin
90367>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90368>>>>>>>                Function_Return APIColumnsEmpty
90369>>>>>>>            End
90369>>>>>>>>
90369>>>>>>>            Increment iCount
90370>>>>>>>        Loop
90371>>>>>>>>
90371>>>>>>>
90371>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90372>>>>>>>        Function_Return APIColumns
90373>>>>>>>    End_Function
90374>>>>>>>
90374>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90374>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90374>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90374>>>>>>>    // have "holes" in the series of index numbers.
90374>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90376>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90376>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90377>>>>>>>        tAPIColumnCompare   APIColumnCompare
90377>>>>>>>        tAPIColumnCompare   APIColumnCompare
90377>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90377>>>>>>>
90377>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90378>>>>>>>        Decrement iSizeFrom
90379>>>>>>>        for iCount from 0 to iSizeFrom
90385>>>>>>>>
90385>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90386>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90387>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90388>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90389>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90390>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90391>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90392>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90393>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90394>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90395>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90396>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90397>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90398>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90399>>>>>>>        Loop
90400>>>>>>>>
90400>>>>>>>
90400>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90401>>>>>>>        Decrement iSizeTo
90402>>>>>>>        for iCount from 0 to iSizeTo
90408>>>>>>>>
90408>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90409>>>>>>>            // Search if the field number already exists in the array; else add it.
90409>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90410>>>>>>>            If (iItem = -1) Begin
90412>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90413>>>>>>>            End
90413>>>>>>>>
90413>>>>>>>
90413>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90414>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90415>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90416>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90417>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90418>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90419>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90420>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90421>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90422>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90423>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90424>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90425>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90426>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90427>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90428>>>>>>>        Loop
90429>>>>>>>>
90429>>>>>>>
90429>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90430>>>>>>>
90430>>>>>>>        Function_Return aAPIColumnCompare
90431>>>>>>>    End_Function
90432>>>>>>>
90432>>>>>>>    // Checks if a field name exists in a table definition
90432>>>>>>>    // Returns True if it does
90432>>>>>>>    // Sample:
90432>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90432>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90434>>>>>>>        Integer iNumColumns iColumn
90434>>>>>>>        String sColumn
90434>>>>>>>        Boolean bExists bOK bOpen
90434>>>>>>>
90434>>>>>>>        Get AutoConnectionIDLogin to bOK
90435>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90436>>>>>>>        Open hTable
90438>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90439>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90442>>>>>>>        If (bOpen = False) Begin
90444>>>>>>>            Function_Return False
90445>>>>>>>        End
90445>>>>>>>>
90445>>>>>>>
90445>>>>>>>        Move False to bExists
90446>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90449>>>>>>>        for iColumn from 1 to iNumColumns
90455>>>>>>>>
90455>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90458>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90460>>>>>>>                Move iNumColumns to iColumn
90461>>>>>>>                Move True to bExists
90462>>>>>>>            End
90462>>>>>>>>
90462>>>>>>>        Loop
90463>>>>>>>>
90463>>>>>>>        Close hTable
90464>>>>>>>
90464>>>>>>>        Function_Return bExists
90465>>>>>>>    End_Function
90466>>>>>>>
90466>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90466>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90468>>>>>>>        Integer iNumColumns iColumn iRetval
90468>>>>>>>        String sColumn
90468>>>>>>>        Boolean bOK bOpen
90468>>>>>>>
90468>>>>>>>        Get AutoConnectionIDLogin to bOK
90469>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90470>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90471>>>>>>>        Open hTable
90473>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90474>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90477>>>>>>>        If (bOpen = False) Begin
90479>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90480>>>>>>>            Function_Return False
90481>>>>>>>        End
90481>>>>>>>>
90481>>>>>>>
90481>>>>>>>        Move 0 to iColumn
90482>>>>>>>        Move 0 to iRetval
90483>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90486>>>>>>>        for iColumn from 1 to iNumColumns
90492>>>>>>>>
90492>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90495>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90497>>>>>>>                Move iColumn to iRetval
90498>>>>>>>                Move iNumColumns to iColumn
90499>>>>>>>            End
90499>>>>>>>>
90499>>>>>>>        Loop
90500>>>>>>>>
90500>>>>>>>        Close hTable
90501>>>>>>>
90501>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90502>>>>>>>        Function_Return iRetval
90503>>>>>>>    End_Function
90504>>>>>>>
90504>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90504>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90504>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90506>>>>>>>        tColumnType RetvalType
90506>>>>>>>        tColumnType RetvalType
90506>>>>>>>
90506>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90507>>>>>>>        Function_Return RetvalType.iSQLType
90508>>>>>>>    End_Function
90509>>>>>>>
90509>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90509>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90509>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90511>>>>>>>        tColumnType RetvalType
90511>>>>>>>        tColumnType RetvalType
90511>>>>>>>
90511>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90512>>>>>>>        Function_Return RetvalType.sSQLType
90513>>>>>>>    End_Function
90514>>>>>>>
90514>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90516>>>>>>>        tColumnType RetvalType
90516>>>>>>>        tColumnType RetvalType
90516>>>>>>>
90516>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90517>>>>>>>        Function_Return RetvalType.sPrecision
90518>>>>>>>    End_Function
90519>>>>>>>
90519>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90521>>>>>>>        tColumnType RetvalType
90521>>>>>>>        tColumnType RetvalType
90521>>>>>>>
90521>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90522>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90522>>>>>>>        // if the column type length is _not_ fixed.
90522>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90523>>>>>>>    End_Function
90524>>>>>>>
90524>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90526>>>>>>>        tColumnType RetvalType
90526>>>>>>>        tColumnType RetvalType
90526>>>>>>>        String sValue
90526>>>>>>>        Integer iRetval iPos
90526>>>>>>>
90526>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90527>>>>>>>        Move RetvalType.sPrecision to sValue
90528>>>>>>>        Move (Pos(".", sValue)) to iPos
90529>>>>>>>        If (iPos <> 0) Begin
90531>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90532>>>>>>>        End
90532>>>>>>>>
90532>>>>>>>        Else Begin
90533>>>>>>>            Move sValue to iRetval
90534>>>>>>>        End
90534>>>>>>>>
90534>>>>>>>        Function_Return iRetval
90535>>>>>>>    End_Function
90536>>>>>>>
90536>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90538>>>>>>>        tColumnType RetvalType
90538>>>>>>>        tColumnType RetvalType
90538>>>>>>>        String sValue
90538>>>>>>>        Integer iRetval iPos
90538>>>>>>>
90538>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90539>>>>>>>        Move RetvalType.sPrecision to sValue
90540>>>>>>>        Move (Pos(".", sValue)) to iPos
90541>>>>>>>        If (iPos = 0) Begin
90543>>>>>>>            Function_Return 0
90544>>>>>>>        End
90544>>>>>>>>
90544>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90545>>>>>>>
90545>>>>>>>        Function_Return iRetval
90546>>>>>>>    End_Function
90547>>>>>>>
90547>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90547>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90549>>>>>>>        Function_Return False
90550>>>>>>>    End_Function
90551>>>>>>>
90551>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90551>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90553>>>>>>>        Boolean bIsSame
90553>>>>>>>        Integer iCount iSize
90553>>>>>>>
90553>>>>>>>        Move True to bIsSame
90554>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90555>>>>>>>        Decrement iSize
90556>>>>>>>        For iCount from 0 to iSize
90562>>>>>>>>
90562>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90563>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90564>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90565>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90566>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90567>>>>>>>            If (bIsSame = False) Begin
90569>>>>>>>                Function_Return False
90570>>>>>>>            End
90570>>>>>>>>
90570>>>>>>>        Loop
90571>>>>>>>>
90571>>>>>>>
90571>>>>>>>        Function_Return bIsSame
90572>>>>>>>    End_Function
90573>>>>>>>
90573>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90573>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90575>>>>>>>        Boolean bIsSame
90575>>>>>>>        Integer iSegment
90575>>>>>>>
90575>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90576>>>>>>>        If (bIsSame = False) Begin
90578>>>>>>>            Function_Return False
90579>>>>>>>        End
90579>>>>>>>>
90579>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90580>>>>>>>        If (bIsSame = False) Begin
90582>>>>>>>            Function_Return False
90583>>>>>>>        End
90583>>>>>>>>
90583>>>>>>>
90583>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90585>>>>>>>            // * We should probably not compare SQL index names?
90585>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90585>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90585>>>>>>>            //     Function_Return False
90585>>>>>>>            // End
90585>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90586>>>>>>>            If (bIsSame = False) Begin
90588>>>>>>>                Function_Return False
90589>>>>>>>            End
90589>>>>>>>>
90589>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90590>>>>>>>            If (bIsSame = False) Begin
90592>>>>>>>                Function_Return False
90593>>>>>>>            End
90593>>>>>>>>
90593>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90594>>>>>>>            If (bIsSame = False) Begin
90596>>>>>>>                Function_Return False
90597>>>>>>>            End
90597>>>>>>>>
90597>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90598>>>>>>>            If (bIsSame = False) Begin
90600>>>>>>>                Function_Return False
90601>>>>>>>            End
90601>>>>>>>>
90601>>>>>>>        End
90601>>>>>>>>
90601>>>>>>>
90601>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90602>>>>>>>        Move (iSegment = -1) to bIsSame
90603>>>>>>>
90603>>>>>>>        Function_Return (bIsSame = True)
90604>>>>>>>    End_Function
90605>>>>>>>
90605>>>>>>>    // Compares each segment for the passed index.
90605>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90605>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90607>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90607>>>>>>>        Boolean bIsSame
90607>>>>>>>
90607>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90608>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90609>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90610>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90611>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90612>>>>>>>
90612>>>>>>>        Decrement iNumSegments
90613>>>>>>>        for iSegment from 0 to iNumSegments
90619>>>>>>>>
90619>>>>>>>            Move False to bIsSame
90620>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90622>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90623>>>>>>>            End
90623>>>>>>>>
90623>>>>>>>            If (bIsSame = False) Begin
90625>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90626>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90627>>>>>>>                Function_Return iSegment
90628>>>>>>>            End
90628>>>>>>>>
90628>>>>>>>        Loop
90629>>>>>>>>
90629>>>>>>>
90629>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90630>>>>>>>        Function_Return -1 // This means bIsSame = True
90631>>>>>>>    End_Function
90632>>>>>>>
90632>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90634>>>>>>>        Boolean bIsSame
90634>>>>>>>
90634>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90635>>>>>>>        If (bIsSame = False) Begin
90637>>>>>>>            Function_Return False
90638>>>>>>>        End
90638>>>>>>>>
90638>>>>>>>        If (bCompareIndexUppercase = True) Begin
90640>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90641>>>>>>>            If (bIsSame = False) Begin
90643>>>>>>>                Function_Return False
90644>>>>>>>            End
90644>>>>>>>>
90644>>>>>>>        End
90644>>>>>>>>
90644>>>>>>>        If (bCompareIndexAscending = True) Begin
90646>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90647>>>>>>>            If (bIsSame = False) Begin
90649>>>>>>>                Function_Return False
90650>>>>>>>            End
90650>>>>>>>>
90650>>>>>>>        End
90650>>>>>>>>
90650>>>>>>>
90650>>>>>>>        Function_Return True
90651>>>>>>>    End_Function
90652>>>>>>>
90652>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90654>>>>>>>        Boolean bIsSame bOK
90654>>>>>>>        Integer iSize iSizeTo iCount
90654>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90654>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90655>>>>>>>
90655>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90656>>>>>>>        If (iSize = 0) Begin
90658>>>>>>>            Function_Return True
90659>>>>>>>        End
90659>>>>>>>>
90659>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90660>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90661>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90662>>>>>>>
90662>>>>>>>        for iCount from 0 to (iSize - 1)
90668>>>>>>>>
90668>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90669>>>>>>>            If (bIsSame = False) Begin
90671>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90672>>>>>>>            End
90672>>>>>>>>
90672>>>>>>>        Loop
90673>>>>>>>>
90673>>>>>>>
90673>>>>>>>        // We probably should delete other indexes if they exists.
90673>>>>>>>        for iCount from (iSize +1) to iSizeTo
90679>>>>>>>>
90679>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90680>>>>>>>        Loop
90681>>>>>>>>
90681>>>>>>>
90681>>>>>>>        Function_Return bOK
90682>>>>>>>    End_Function
90683>>>>>>>
90683>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90685>>>>>>>        tAPIIndex[] APIIndexes
90685>>>>>>>        tAPIIndex[] APIIndexes
90686>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90686>>>>>>>        String sDriverID
90686>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90686>>>>>>>
90686>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90687>>>>>>>        Get psDriverID to sDriverID
90688>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90689>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90690>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90693>>>>>>>        If (bIsOpen = False) Begin
90695>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90696>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90697>>>>>>>            Open hTable
90699>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90700>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90701>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90704>>>>>>>            If (bIsOpen = False) Begin
90706>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90707>>>>>>>                Move True to APIIndexes[0].bError
90708>>>>>>>                Function_Return APIIndexes
90709>>>>>>>            End
90709>>>>>>>>
90709>>>>>>>        End
90709>>>>>>>>
90709>>>>>>>
90709>>>>>>>        Move 0 to iCount
90710>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90713>>>>>>>        for iIndex from 1 to iIndexes
90719>>>>>>>>
90719>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90719>>>>>>>            // numbers doesn't not need to be consequitive:
90719>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90722>>>>>>>            If (iNumSegments > 0) Begin
90724>>>>>>>
90724>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90725>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90728>>>>>>>                If (bIsSQLTable = True) Begin
90730>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90733>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90736>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90739>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90742>>>>>>>                End
90742>>>>>>>>
90742>>>>>>>
90742>>>>>>>                Move 0 to iSegmentCount
90743>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90746>>>>>>>                For iSegment from 1 to iNumSegments
90752>>>>>>>>
90752>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90755>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90756>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90759>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90762>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90765>>>>>>>                    Increment iSegmentCount
90766>>>>>>>                Loop
90767>>>>>>>>
90767>>>>>>>                Increment iCount
90768>>>>>>>            End
90768>>>>>>>>
90768>>>>>>>        Loop
90769>>>>>>>>
90769>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90770>>>>>>>
90770>>>>>>>        Function_Return APIIndexes
90771>>>>>>>    End_Function
90772>>>>>>>
90772>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90772>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90772>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90772>>>>>>>    // have "holes" in the series of index numbers.
90772>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90774>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90774>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90775>>>>>>>        tAPIIndexCompare   APIIndexCompare
90775>>>>>>>        tAPIIndexCompare   APIIndexCompare
90775>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90775>>>>>>>
90775>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90776>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90777>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90779>>>>>>>            Function_Return aAPIIndexCompare
90780>>>>>>>        End
90780>>>>>>>>
90780>>>>>>>
90780>>>>>>>        Decrement iSizeFrom
90781>>>>>>>        for iCount from 0 to iSizeFrom
90787>>>>>>>>
90787>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90788>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90789>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90790>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90791>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90792>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90793>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90794>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90795>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90796>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90797>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90798>>>>>>>        Loop
90799>>>>>>>>
90799>>>>>>>
90799>>>>>>>        Decrement iSizeTo
90800>>>>>>>        for iCount from 0 to iSizeTo
90806>>>>>>>>
90806>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90807>>>>>>>            // Search if the Index number already exists in the array; else add it.
90807>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90808>>>>>>>            If (iItem = -1) Begin
90810>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90811>>>>>>>            End
90811>>>>>>>>
90811>>>>>>>
90811>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90812>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90813>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90814>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90815>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90816>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90817>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90818>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90819>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90820>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90821>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90822>>>>>>>        Loop
90823>>>>>>>>
90823>>>>>>>
90823>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90824>>>>>>>
90824>>>>>>>        Function_Return aAPIIndexCompare
90825>>>>>>>    End_Function
90826>>>>>>>
90826>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90826>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90828>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90828>>>>>>>        String sDriverID
90828>>>>>>>
90828>>>>>>>        Get psDriverID to sDriverID
90829>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90830>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90831>>>>>>>        If (bIsSqlTable = True) Begin
90833>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90834>>>>>>>        End
90834>>>>>>>>
90834>>>>>>>
90834>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90835>>>>>>>        If (bIsSame = False) Begin
90837>>>>>>>            Function_Return False
90838>>>>>>>        End
90838>>>>>>>>
90838>>>>>>>
90838>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90840>>>>>>>            // Don't think we should do this. Or should we?
90840>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90840>>>>>>>
90840>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90841>>>>>>>            If (bIsSame = False) Begin
90843>>>>>>>                Function_Return False
90844>>>>>>>            End
90844>>>>>>>>
90844>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90845>>>>>>>            If (bIsSame = False) Begin
90847>>>>>>>                Function_Return False
90848>>>>>>>            End
90848>>>>>>>>
90848>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90849>>>>>>>            If (bIsSame = False) Begin
90851>>>>>>>                Function_Return False
90852>>>>>>>            End
90852>>>>>>>>
90852>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90853>>>>>>>            If (bIsSame = False) Begin
90855>>>>>>>                Function_Return False
90856>>>>>>>            End
90856>>>>>>>>
90856>>>>>>>        End
90856>>>>>>>>
90856>>>>>>>
90856>>>>>>>        Function_Return bIsSame
90857>>>>>>>    End_Function
90858>>>>>>>
90858>>>>>>>    // DF_INDEX_SQL_TYPE values
90858>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90858>>>>>>>    // returns a string with the name.
90858>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90860>>>>>>>        String sRetval
90860>>>>>>>            Case Begin
90860>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
90862>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
90863>>>>>>>                    Case Break
90864>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
90867>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
90868>>>>>>>                    Case Break
90869>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
90872>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
90873>>>>>>>                    Case Break
90874>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
90877>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
90878>>>>>>>                    Case Break
90879>>>>>>>                Case Else
90879>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
90880>>>>>>>            Case End
90880>>>>>>>        Function_Return sRetval
90881>>>>>>>    End_Function
90882>>>>>>>
90882>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90882>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90884>>>>>>>        Function_Return False
90885>>>>>>>    End_Function
90886>>>>>>>
90886>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90886>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90888>>>>>>>        Boolean bIsSame
90888>>>>>>>        Integer iSize iCount
90888>>>>>>>
90888>>>>>>>        Move True to bIsSame
90889>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90890>>>>>>>        Decrement iSize
90891>>>>>>>        For iCount from 0 to iSize
90897>>>>>>>>
90897>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90898>>>>>>>            If (bIsSame = False) Begin
90900>>>>>>>                Function_Return False
90901>>>>>>>            End
90901>>>>>>>>
90901>>>>>>>        Loop
90902>>>>>>>>
90902>>>>>>>
90902>>>>>>>        Function_Return bIsSame
90903>>>>>>>    End_Function
90904>>>>>>>
90904>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90904>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90906>>>>>>>        Boolean bIsSame
90906>>>>>>>
90906>>>>>>>        Move True to bIsSame
90907>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90909>>>>>>>            Function_Return False
90910>>>>>>>        End
90910>>>>>>>>
90910>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90912>>>>>>>            Function_Return False
90913>>>>>>>        End
90913>>>>>>>>
90913>>>>>>>
90913>>>>>>>        // We could also compare field names, but I don't think that is necessary...
90913>>>>>>>
90913>>>>>>>        Function_Return bIsSame
90914>>>>>>>    End_Function
90915>>>>>>>
90915>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90915>>>>>>>    // already exists.
90915>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90917>>>>>>>        Boolean bOK
90917>>>>>>>        Integer iSizeTo iSize iCount iColumn
90917>>>>>>>        String sDriverID
90917>>>>>>>
90917>>>>>>>        Move True to bOK
90918>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90919>>>>>>>        If (iSizeTo > 0) Begin
90921>>>>>>>            Get AutoConnectionIDLogin to bOK
90922>>>>>>>            Move False to Err
90923>>>>>>>            Open hTable Mode DF_EXCLUSIVE
90925>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90928>>>>>>>            Decrement iSizeTo
90929>>>>>>>
90929>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90929>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90929>>>>>>>            Structure_Start hTable sDriverID
90930>>>>>>>                for iCount from 0 to iSizeTo
90936>>>>>>>>
90936>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90937>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90940>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90943>>>>>>>                Loop
90944>>>>>>>>
90944>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90945>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90947>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90948>>>>>>>        End
90948>>>>>>>>
90948>>>>>>>
90948>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90949>>>>>>>        Decrement iSize
90950>>>>>>>        for iCount from 0 to iSize
90956>>>>>>>>
90956>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90957>>>>>>>        Loop
90958>>>>>>>>
90958>>>>>>>
90958>>>>>>>        Function_Return bOK
90959>>>>>>>    End_Function
90960>>>>>>>
90960>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90962>>>>>>>        tAPIRelation[] APIRelations
90962>>>>>>>        tAPIRelation[] APIRelations
90963>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
90963>>>>>>>        Handle hParent
90963>>>>>>>        Boolean bIsOpen
90963>>>>>>>
90963>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90964>>>>>>>        Move 0 to iCount
90965>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90968>>>>>>>        If (bIsOpen = False) Begin
90970>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90971>>>>>>>            Open hTable
90973>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90974>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90977>>>>>>>            If (bIsOpen = False) Begin
90979>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90980>>>>>>>                Move True to APIRelations[0].bError
90981>>>>>>>                Function_Return APIRelations
90982>>>>>>>            End
90982>>>>>>>>
90982>>>>>>>        End
90982>>>>>>>>
90982>>>>>>>
90982>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90985>>>>>>>        For iColumn from 1 to iNumColumns
90991>>>>>>>>
90991>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90994>>>>>>>            If (hParent <> 0) Begin
90996>>>>>>>                Open hParent
90998>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
90999>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91002>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91003>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91006>>>>>>>
91006>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91007>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91010>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91013>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91014>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91017>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91018>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91019>>>>>>>                Move False                                              to APIRelations[iCount].bError
91020>>>>>>>                Close hParent
91021>>>>>>>                Increment iCount
91022>>>>>>>            End
91022>>>>>>>>
91022>>>>>>>        Loop
91023>>>>>>>>
91023>>>>>>>
91023>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91024>>>>>>>        Function_Return APIRelations
91025>>>>>>>    End_Function
91026>>>>>>>
91026>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91026>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91026>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91028>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91028>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91029>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91029>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91030>>>>>>>        tAPIRelationCompare   APIRelationCompare
91030>>>>>>>        tAPIRelationCompare   APIRelationCompare
91030>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91030>>>>>>>
91030>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91031>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91032>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91034>>>>>>>            Function_Return aAPIRelationCompare
91035>>>>>>>        End
91035>>>>>>>>
91035>>>>>>>
91035>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91036>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91037>>>>>>>
91037>>>>>>>        Decrement iSizeFrom
91038>>>>>>>        for iCount from 0 to iSizeFrom
91044>>>>>>>>
91044>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91045>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91046>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91047>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91048>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91049>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91050>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91051>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91052>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91053>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91054>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91055>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91056>>>>>>>        Loop
91057>>>>>>>>
91057>>>>>>>
91057>>>>>>>        Decrement iSizeTo
91058>>>>>>>        for iCount from 0 to iSizeTo
91064>>>>>>>>
91064>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91065>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91066>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91067>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91068>>>>>>>
91068>>>>>>>            // Search if the relation already exists in the array; else add it.
91068>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91069>>>>>>>            If (iItem = -1) Begin
91071>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91072>>>>>>>            End
91072>>>>>>>>
91072>>>>>>>
91072>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91073>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91074>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91075>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91076>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91077>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91078>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91079>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91080>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91081>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91082>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91083>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91084>>>>>>>        Loop
91085>>>>>>>>
91085>>>>>>>
91085>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91086>>>>>>>
91086>>>>>>>        Function_Return aAPIRelationCompare
91087>>>>>>>    End_Function
91088>>>>>>>
91088>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91088>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91090>>>>>>>        Function_Return False
91091>>>>>>>    End_Function
91092>>>>>>>
91092>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91092>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91092>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91092>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91094>>>>>>>        Boolean bFound
91094>>>>>>>
91094>>>>>>>        Move False to Err
91095>>>>>>>        Open CodeMast
91097>>>>>>>        Open CodeType
91099>>>>>>>
91099>>>>>>>        If (bCodeType = True) Begin
91101>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91102>>>>>>>            Clear CodeType
91103>>>>>>>            Move sTypeValue to CODETYPE.Type
91104>>>>>>>            Find eq CODETYPE by 1
91105>>>>>>>>
91105>>>>>>>            Move Found to bFound
91106>>>>>>>            If (bFound = True) Begin
91108>>>>>>>                Reread CodeType
91112>>>>>>>            End
91112>>>>>>>>
91112>>>>>>>            Else Begin
91113>>>>>>>                Clear CodeType
91114>>>>>>>            End
91114>>>>>>>>
91114>>>>>>>
91114>>>>>>>            Move sTypeValue to CODETYPE.Type
91115>>>>>>>            Move sValue2    to CODETYPE.Description
91116>>>>>>>            Move sValue3    to CODETYPE.Comment
91117>>>>>>>            SaveRecord CODETYPE
91118>>>>>>>
91118>>>>>>>            If (bFound = True) Begin
91120>>>>>>>                Unlock
91121>>>>>>>>
91121>>>>>>>            End
91121>>>>>>>>
91121>>>>>>>        End
91121>>>>>>>>
91121>>>>>>>
91121>>>>>>>        If (bCodeType = False) Begin
91123>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91124>>>>>>>            Clear CODEMAST
91125>>>>>>>            Move sTypeValue to CODEMAST.Type
91126>>>>>>>            Move sValue2    to CODEMAST.Code
91127>>>>>>>            Find eq CODEMAST by 1
91128>>>>>>>>
91128>>>>>>>            Move Found to bFound
91129>>>>>>>            If (bFound = True) Begin
91131>>>>>>>                Reread CODEMAST
91135>>>>>>>            End
91135>>>>>>>>
91135>>>>>>>            Else Begin
91136>>>>>>>                Clear CODEMAST
91137>>>>>>>            End
91137>>>>>>>>
91137>>>>>>>
91137>>>>>>>            Move sTypeValue to CODEMAST.Type
91138>>>>>>>            Move sValue2    to CODEMAST.Code
91139>>>>>>>            Move sValue3    to CODEMAST.Description
91140>>>>>>>            SaveRecord CODEMAST
91141>>>>>>>
91141>>>>>>>            If (bFound = True) Begin
91143>>>>>>>                Unlock
91144>>>>>>>>
91144>>>>>>>            End
91144>>>>>>>>
91144>>>>>>>        End
91144>>>>>>>>
91144>>>>>>>
91144>>>>>>>        Close CodeMast
91145>>>>>>>        Close CodeType
91146>>>>>>>
91146>>>>>>>        Function_Return (Err = False)
91147>>>>>>>    End_Function
91148>>>>>>>
91148>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91148>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91148>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91150>>>>>>>        Boolean bFound
91150>>>>>>>
91150>>>>>>>        Move False to Err
91151>>>>>>>        Open CodeMast
91153>>>>>>>        Open CodeType
91155>>>>>>>
91155>>>>>>>        Clear CodeType
91156>>>>>>>        Move sFromValue to CODETYPE.Type
91157>>>>>>>        Find eq CODETYPE.Type
91158>>>>>>>>
91158>>>>>>>        If (Found = True) Begin
91160>>>>>>>            Reread CODETYPE
91164>>>>>>>                Move sToValue to CODETYPE.Type
91165>>>>>>>                SaveRecord CODETYPE
91166>>>>>>>            Unlock
91167>>>>>>>>
91167>>>>>>>        End
91167>>>>>>>>
91167>>>>>>>
91167>>>>>>>        Clear CODEMAST
91168>>>>>>>        Find gt CODEMAST by Recnum
91169>>>>>>>>
91169>>>>>>>        While (Found = True)
91173>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91174>>>>>>>            If (bFound = True) Begin
91176>>>>>>>                Reread CODEMAST
91180>>>>>>>                    Move sToValue to CODEMAST.Type
91181>>>>>>>                    SaveRecord CODEMAST
91182>>>>>>>                Unlock
91183>>>>>>>>
91183>>>>>>>            End
91183>>>>>>>>
91183>>>>>>>            Find gt CODEMAST by Recnum
91184>>>>>>>>
91184>>>>>>>        Loop
91185>>>>>>>>
91185>>>>>>>
91185>>>>>>>        Close CodeMast
91186>>>>>>>        Close CodeType
91187>>>>>>>
91187>>>>>>>        Function_Return (Err = False)
91188>>>>>>>    End_Function
91189>>>>>>>
91189>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91189>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91191>>>>>>>        Boolean bFound
91191>>>>>>>
91191>>>>>>>        Move False to Err
91192>>>>>>>        Open CodeMast
91194>>>>>>>
91194>>>>>>>        Clear CODEMAST
91195>>>>>>>        Move sTypeValue to CODEMAST.Type
91196>>>>>>>        Move sValue2    to CODEMAST.Code
91197>>>>>>>        Find eq CODEMAST.Code
91198>>>>>>>>
91198>>>>>>>        Move Found to bFound
91199>>>>>>>        If (bFound = True) Begin
91201>>>>>>>            Delete CODEMAST
91202>>>>>>>        End
91202>>>>>>>>
91202>>>>>>>
91202>>>>>>>        Close CodeMast
91203>>>>>>>
91203>>>>>>>        Function_Return (Err = False)
91204>>>>>>>    End_Function
91205>>>>>>>
91205>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91207>>>>>>>        Boolean bRecnum bToAnsi
91207>>>>>>>        Integer iCh
91207>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91207>>>>>>>
91207>>>>>>>        If (Trim(sDataPath) = "") Begin
91209>>>>>>>            Function_Return False
91210>>>>>>>        End
91210>>>>>>>>
91210>>>>>>>
91210>>>>>>>        Move False to Err
91211>>>>>>>        Get psDriverID     to sDriverID
91212>>>>>>>        Get psConnectionID to sConnectionID
91213>>>>>>>        Get psSchema       to sSchemaName
91214>>>>>>>        Get True           to bRecnum
91215>>>>>>>        Get pbToANSI       to bToAnsi
91216>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91217>>>>>>>        If (bToAnsi = False) Begin
91219>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91220>>>>>>>        End
91220>>>>>>>>
91220>>>>>>>
91220>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91221>>>>>>>        Move "CodeMast.int"         to sFileName
91222>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91223>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91226>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91229>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91232>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91235>>>>>>>            Writeln channel iCh ("")
91238>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91241>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91244>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91247>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91250>>>>>>>            Writeln channel iCh ("")
91253>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91256>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91259>>>>>>>            Writeln channel iCh ("")
91262>>>>>>>        Send Seq_Close_Channel iCh
91263>>>>>>>
91263>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91264>>>>>>>        Move "CodeType.int"         to sFileName
91265>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91266>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91269>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91272>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91275>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91278>>>>>>>            Writeln channel iCh ("")
91281>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91284>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91287>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91290>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91293>>>>>>>            Writeln channel iCh ("")
91296>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91299>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91302>>>>>>>            Writeln channel iCh ("")
91305>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91308>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91311>>>>>>>            Writeln channel iCh ("")
91314>>>>>>>        Send Seq_Close_Channel iCh
91315>>>>>>>
91315>>>>>>>        Function_Return (Err = False)
91316>>>>>>>    End_Function
91317>>>>>>>
91317>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91317>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91319>>>>>>>        Function_Return False
91320>>>>>>>    End_Function
91321>>>>>>>
91321>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91321>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91321>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91323>>>>>>>        Boolean bOK bExists
91323>>>>>>>        String sDataPath sBackupFolder
91323>>>>>>>
91323>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91324>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91325>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91326>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91327>>>>>>>
91327>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91328>>>>>>>        If (bExists = False) Begin
91330>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91331>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91332>>>>>>>            If (bExists = False) Begin
91334>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91335>>>>>>>>
91335>>>>>>>                Function_Return False
91336>>>>>>>            End
91336>>>>>>>>
91336>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91337>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91338>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91339>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91340>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91341>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91342>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91343>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91344>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91345>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91346>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91347>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91348>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91349>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91350>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91351>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91352>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91353>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91354>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91355>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91356>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91357>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91358>>>>>>>        End
91358>>>>>>>>
91358>>>>>>>
91358>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91359>>>>>>>        Function_Return True
91360>>>>>>>    End_Function
91361>>>>>>>    
91361>>>>>>>    // Check if the file exists in the Data folder,
91361>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91361>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91363>>>>>>>        String sPath
91363>>>>>>>        Boolean bExists
91363>>>>>>>
91363>>>>>>>        Get psDataPathFirstPart to sPath
91364>>>>>>>        Move (sPath + sFileName) to sFileName
91365>>>>>>>        Get vFilePathExists sFileName to bExists
91366>>>>>>>
91366>>>>>>>        If (bExists = False) Begin
91368>>>>>>>            // Read from memory & create file on disk.
91368>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91369>>>>>>>            Get vFilePathExists sFileName to bExists
91370>>>>>>>        End
91370>>>>>>>>
91370>>>>>>>        Function_Return bExists
91371>>>>>>>    End_Function
91372>>>>>>>
91372>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91374>>>>>>>        tColumnType RetvalType
91374>>>>>>>        tColumnType RetvalType
91374>>>>>>>        Integer iRetval
91374>>>>>>>
91374>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91375>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91376>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91378>>>>>>>            If (iLength <= 255) Begin
91380>>>>>>>                Move DF_ASCII to iRetval
91381>>>>>>>            End
91381>>>>>>>>
91381>>>>>>>        End
91381>>>>>>>>
91381>>>>>>>        Function_Return iRetval
91382>>>>>>>    End_Function
91383>>>>>>>
91383>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91385>>>>>>>        String sRetval
91385>>>>>>>
91385>>>>>>>        Case Begin
91385>>>>>>>            Case (iDataType = DF_ASCII)
91387>>>>>>>                Move "DF_ASCII" to sRetval
91388>>>>>>>                Case Break
91389>>>>>>>            Case (iDataType = DF_BCD)
91392>>>>>>>                Move "DF_BCD" to sRetval
91393>>>>>>>                Case Break
91394>>>>>>>            Case (iDataType = DF_BINARY)
91397>>>>>>>                Move "DF_BINARY" to sRetval
91398>>>>>>>                Case Break
91399>>>>>>>            Case (iDataType = DF_DATE)
91402>>>>>>>                Move "DF_DATE" to sRetval
91403>>>>>>>                Case Break
91404>>>>>>>            Case (iDataType = DF_DATETIME)
91407>>>>>>>                Move "DF_DATETIME" to sRetval
91408>>>>>>>                Case Break
91409>>>>>>>            Case (iDataType = DF_TEXT)
91412>>>>>>>                Move "DF_TEXT" to sRetval
91413>>>>>>>                Case Break
91414>>>>>>>            Case Else
91414>>>>>>>                Move "" to sRetval
91415>>>>>>>        Case End
91415>>>>>>>
91415>>>>>>>        Function_Return sRetval
91416>>>>>>>    End_Function
91417>>>>>>>
91417>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91417>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91419>>>>>>>        String sRetval sServer
91419>>>>>>>        tColumnType RetvalType
91419>>>>>>>        tColumnType RetvalType
91419>>>>>>>        Integer iDriver iDataFlexType
91419>>>>>>>        Handle hDatabase
91419>>>>>>>
91419>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91420>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91421>>>>>>>        Get DriverIndex sDriverID to iDriver
91422>>>>>>>        Get psServer to sServer
91423>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91424>>>>>>>        If (hDatabase = 0) Begin
91426>>>>>>>            Function_Return ""
91427>>>>>>>        End
91427>>>>>>>>
91427>>>>>>>
91427>>>>>>>        Case Begin
91427>>>>>>>            Case (iDataFlexType = DF_ASCII)
91429>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91432>>>>>>>                Case Break
91433>>>>>>>            Case (iDataFlexType = DF_BCD)
91436>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91439>>>>>>>                Case Break
91440>>>>>>>            Case (iDataFlexType = DF_BINARY)
91443>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91446>>>>>>>                Case Break
91447>>>>>>>            Case (iDataFlexType = DF_DATE)
91450>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91453>>>>>>>                Case Break
91454>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91457>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91460>>>>>>>                Case Break
91461>>>>>>>            Case (iDataFlexType = DF_TEXT)
91464>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91467>>>>>>>                Case Break
91468>>>>>>>            Case Else
91468>>>>>>>                Move "" to sRetval
91469>>>>>>>        Case End
91469>>>>>>>
91469>>>>>>>        Function_Return sRetval
91470>>>>>>>    End_Function
91471>>>>>>>
91471>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91473>>>>>>>        String sDriverID sServer
91473>>>>>>>        tColumnType RetvalType
91473>>>>>>>        tColumnType RetvalType
91473>>>>>>>        Integer iDbType iDriver
91473>>>>>>>        Handle hDatabase
91473>>>>>>>
91473>>>>>>>        Get psDriverID to sDriverID
91474>>>>>>>        Get piDbType   to iDbType
91475>>>>>>>        Get DriverIndex sDriverID to iDriver
91476>>>>>>>        Get psServer to sServer
91477>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91478>>>>>>>        If (hDatabase = 0) Begin
91480>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91481>>>>>>>>
91481>>>>>>>            Procedure_Return
91482>>>>>>>        End
91482>>>>>>>>
91482>>>>>>>
91482>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91485>>>>>>>
91485>>>>>>>    End_Procedure
91486>>>>>>>
91486>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91488>>>>>>>        String sDriverID sServer
91488>>>>>>>        tColumnType RetvalType
91488>>>>>>>        tColumnType RetvalType
91488>>>>>>>        Integer iDbType iDriver
91488>>>>>>>        Handle hDatabase
91488>>>>>>>
91488>>>>>>>        Get psDriverID to sDriverID
91489>>>>>>>        Get piDbType   to iDbType
91490>>>>>>>        Get DriverIndex sDriverID to iDriver
91491>>>>>>>        Get psServer to sServer
91492>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91493>>>>>>>        If (hDatabase = 0) Begin
91495>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91496>>>>>>>>
91496>>>>>>>            Procedure_Return
91497>>>>>>>        End
91497>>>>>>>>
91497>>>>>>>
91497>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91500>>>>>>>
91500>>>>>>>    End_Procedure
91501>>>>>>>
91501>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91501>>>>>>>    // are mapped to the standard DataFlex data types.
91501>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91501>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91503>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91503>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91505>>>>>>>        String sDataType
91505>>>>>>>        Integer iDataType iDriverID iCount
91505>>>>>>>        Boolean bSQLDriver
91505>>>>>>>
91505>>>>>>>        Move 0 to iCount
91506>>>>>>>        Get DriverIndex sDriverID to iDriverID
91507>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91508>>>>>>>        If (bSQLDriver = False) Begin
91510>>>>>>>            Function_Return EmptyArray
91511>>>>>>>        End
91511>>>>>>>>
91511>>>>>>>
91511>>>>>>>        // DF_ASCII
91511>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91513>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91516>>>>>>>        End
91516>>>>>>>>
91516>>>>>>>        Else Begin
91517>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91520>>>>>>>        End
91520>>>>>>>>
91520>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91521>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91522>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91523>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91524>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91525>>>>>>>        Increment iCount
91526>>>>>>>
91526>>>>>>>        // DF_BINARY
91526>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91528>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91531>>>>>>>        End
91531>>>>>>>>
91531>>>>>>>        Else Begin
91532>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91535>>>>>>>        End
91535>>>>>>>>
91535>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91536>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91537>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91538>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91539>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91540>>>>>>>        Increment iCount
91541>>>>>>>
91541>>>>>>>        // DF_DATE
91541>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91543>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91546>>>>>>>        End
91546>>>>>>>>
91546>>>>>>>        Else Begin
91547>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91550>>>>>>>        End
91550>>>>>>>>
91550>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91551>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91552>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91553>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91554>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91555>>>>>>>        Increment iCount
91556>>>>>>>
91556>>>>>>>        // DF_DATETIME
91556>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91558>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91561>>>>>>>        End
91561>>>>>>>>
91561>>>>>>>        Else Begin
91562>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91565>>>>>>>        End
91565>>>>>>>>
91565>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91566>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91567>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91568>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91569>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91570>>>>>>>        Increment iCount
91571>>>>>>>
91571>>>>>>>        // DF_NUMERIC
91571>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91571>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91571>>>>>>>        // we make them here all "Numeric"...
91571>>>>>>>        Case Begin
91571>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91573>>>>>>>                Move SQL_NUMERIC to iDataType
91574>>>>>>>                Move "numeric"   to sDataType
91575>>>>>>>                Case Break
91576>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91579>>>>>>>                Move SQL_NUMERIC to iDataType
91580>>>>>>>                Move "NUMERIC"   to sDataType
91581>>>>>>>                Case Break
91582>>>>>>>            Case Else
91582>>>>>>>                Move DF_BCD      to iDataType
91583>>>>>>>                Move "Numeric"   to sDataType
91584>>>>>>>        Case End
91584>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91585>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91586>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91587>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91588>>>>>>>        Increment iCount
91589>>>>>>>
91589>>>>>>>        // DF_TEXT
91589>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91591>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91594>>>>>>>        End
91594>>>>>>>>
91594>>>>>>>        Else Begin
91595>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91598>>>>>>>        End
91598>>>>>>>>
91598>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91599>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91600>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91601>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91602>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91603>>>>>>>
91603>>>>>>>        Function_Return ColumnTypeArray
91604>>>>>>>    End_Function
91605>>>>>>>
91605>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91607>>>>>>>        tColumnType[] ColumnTypeArray
91607>>>>>>>        tColumnType[] ColumnTypeArray
91608>>>>>>>        tColumnType   ColumnType
91608>>>>>>>        tColumnType   ColumnType
91608>>>>>>>        Integer iCount iSize
91608>>>>>>>
91608>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91609>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91610>>>>>>>        Decrement iSize
91611>>>>>>>
91611>>>>>>>        for iCount from 0 to iSize
91617>>>>>>>>
91617>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91619>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91620>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91621>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91622>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91623>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91624>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91625>>>>>>>                Move iSize to iCount
91626>>>>>>>            End
91626>>>>>>>>
91626>>>>>>>        Loop
91627>>>>>>>>
91627>>>>>>>
91627>>>>>>>        Function_Return ColumnType
91628>>>>>>>    End_Function
91629>>>>>>>
91629>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91629>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91629>>>>>>>    // but the Logical name is different.
91629>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91629>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91631>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91631>>>>>>>        Handle hInTable hMasterTable 
91631>>>>>>>        Boolean bIsAlias
91631>>>>>>>        
91631>>>>>>>        Move hTable to hInTable
91632>>>>>>>        Move False to bIsAlias
91633>>>>>>>        Move 0 to hMasterTable
91634>>>>>>>        
91634>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91637>>>>>>>        // Remove any prefix with a driver name.
91637>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91638>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91641>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91642>>>>>>>        
91642>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91642>>>>>>>        // so we can safely return a "False".
91642>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91644>>>>>>>            Function_Return False
91645>>>>>>>        End
91645>>>>>>>>
91645>>>>>>>        
91645>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91645>>>>>>>        // as the passed hTable root name.
91645>>>>>>>        // A master table always has the same root and logical name.
91645>>>>>>>        Move 0 to hTable
91646>>>>>>>        Repeat
91646>>>>>>>>
91646>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91649>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
91651>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91654>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91655>>>>>>>                // If we found another table with the same root and logical name
91655>>>>>>>                // we have found a master table.
91655>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91657>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91660>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91661>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91663>>>>>>>                        Move hTable to hMasterTable   
91664>>>>>>>                        Move 0 to hTable // To end the loop.
91665>>>>>>>                    End
91665>>>>>>>>
91665>>>>>>>                End
91665>>>>>>>>
91665>>>>>>>            End
91665>>>>>>>>
91665>>>>>>>        Until (hTable = 0)
91667>>>>>>>        
91667>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91669>>>>>>>            Move True to bIsAlias
91670>>>>>>>        End
91670>>>>>>>>
91670>>>>>>>        
91670>>>>>>>        Function_Return bIsAlias
91671>>>>>>>    End_Function
91672>>>>>>>
91672>>>>>>>    // To Open a table with any driver.
91672>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91672>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91672>>>>>>>    //
91672>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91672>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
91672>>>>>>>    // returns a True if successful (table could be opened).
91672>>>>>>>    //
91672>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91672>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91672>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91672>>>>>>>    // set properly we can open the table.
91672>>>>>>>    //
91672>>>>>>>    // DAW Driver Syntax:
91672>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91672>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91672>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91672>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91672>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91672>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91672>>>>>>>    //
91672>>>>>>>    // DAW Driver Sample:
91672>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91672>>>>>>>    //
91672>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91674>>>>>>>        String sTableNameOrg
91674>>>>>>>        Boolean bOpen bOK
91674>>>>>>>        tSQLConnection SQLConnection
91674>>>>>>>        tSQLConnection SQLConnection
91674>>>>>>>        
91674>>>>>>>        Move False to bOpen
91675>>>>>>>        Move sTableName to sTableNameOrg
91676>>>>>>>        If (hTable > 0) Begin
91678>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
91679>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91680>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91681>>>>>>>            Send Ignore_Error of Error_Object_Id 10
91682>>>>>>>            Open hTable Mode iMode
91684>>>>>>>            Send Trap_Error of Error_Object_Id 20529
91685>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91686>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91687>>>>>>>            Send Trap_Error of Error_Object_Id 10
91688>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91691>>>>>>>            If (bOpen = True) Begin
91693>>>>>>>                Function_Return True
91694>>>>>>>            End
91694>>>>>>>>
91694>>>>>>>        End
91694>>>>>>>>
91694>>>>>>>
91694>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91695>>>>>>>        If (hTable > 0) Begin
91697>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91700>>>>>>>        End
91700>>>>>>>>
91700>>>>>>>
91700>>>>>>>        Function_Return bOpen
91701>>>>>>>    End_Function
91702>>>>>>>
91702>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91704>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91704>>>>>>>        Boolean bOpen bOK
91704>>>>>>>        tSQLConnection SQLConnection
91704>>>>>>>        tSQLConnection SQLConnection
91704>>>>>>>
91704>>>>>>>        If (hTable < 1) Begin
91706>>>>>>>            Function_Return False
91707>>>>>>>        End
91707>>>>>>>>
91707>>>>>>>
91707>>>>>>>        Move sTableName to sTableNameOrg
91708>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91709>>>>>>>        Move SQLConnection.sDriverID to sDriverID
91710>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91711>>>>>>>        Move SQLConnection.sSchema to sSchema
91712>>>>>>>        If (sSchema = "") Begin
91714>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91715>>>>>>>        End
91715>>>>>>>>
91715>>>>>>>
91715>>>>>>>        // We need to remove the ".int" part of the table name because
91715>>>>>>>        // the table name after the "#" in the connection syntax below wants the
91715>>>>>>>        // "bare" table name without any extension.
91715>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91717>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
91719>>>>>>>                Get ParseFileExtension sTableName to sExt
91720>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91721>>>>>>>            End
91721>>>>>>>>
91721>>>>>>>            Else Begin
91722>>>>>>>                Move sTableName to sTableNameShort
91723>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
91724>>>>>>>            End
91724>>>>>>>>
91724>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91725>>>>>>>            Move sConnection to sTableName
91726>>>>>>>        End
91726>>>>>>>>
91726>>>>>>>
91726>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91727>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91728>>>>>>>        If (hTable = 0) Begin
91730>>>>>>>            Get NextFreeFilelistSlot to hTable
91731>>>>>>>        End
91731>>>>>>>>
91731>>>>>>>
91731>>>>>>>        Case Begin
91731>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91733>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91733>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91735>>>>>>>                    Close hTable
91736>>>>>>>                    Open sTableName as hTable
91738>>>>>>>                End
91738>>>>>>>>
91738>>>>>>>                Else Begin
91739>>>>>>>                    Get OpenTableExclusive hTable to bOK
91740>>>>>>>                    If (bOK = False) Begin
91742>>>>>>>                        Function_Return False
91743>>>>>>>                    End
91743>>>>>>>>
91743>>>>>>>                End
91743>>>>>>>>
91743>>>>>>>                Case Break
91744>>>>>>>
91744>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91747>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91747>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91749>>>>>>>                    Close hTable
91750>>>>>>>                    Open sTableName as hTable
91752>>>>>>>                End
91752>>>>>>>>
91752>>>>>>>                Else Begin
91753>>>>>>>                    Get OpenTableExclusive hTable to bOK
91754>>>>>>>                    If (bOK = False) Begin
91756>>>>>>>                        Function_Return False
91757>>>>>>>                    End
91757>>>>>>>>
91757>>>>>>>                End
91757>>>>>>>>
91757>>>>>>>                Case Break
91758>>>>>>>
91758>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91761>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91761>>>>>>>                If (iMode = DF_SHARE) Begin
91763>>>>>>>                    Close hTable
91764>>>>>>>                    Open sTableName as hTable
91766>>>>>>>                End
91766>>>>>>>>
91766>>>>>>>                Else Begin
91767>>>>>>>                    Get OpenTableExclusive hTable to bOK
91768>>>>>>>                    If (bOK = False) Begin
91770>>>>>>>                        Function_Return False
91771>>>>>>>                    End
91771>>>>>>>>
91771>>>>>>>                End
91771>>>>>>>>
91771>>>>>>>                Case Break
91772>>>>>>>
91772>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91775>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91777>>>>>>>                    Close hTable
91778>>>>>>>                    Open sTableName as hTable
91780>>>>>>>                End
91780>>>>>>>>
91780>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91783>>>>>>>                    Get OpenTableExclusive hTable to bOK
91784>>>>>>>                    If (bOK = False) Begin
91786>>>>>>>                        Function_Return False
91787>>>>>>>                    End
91787>>>>>>>>
91787>>>>>>>                End
91787>>>>>>>>
91787>>>>>>>                Else Begin
91788>>>>>>>                    Open hTable
91790>>>>>>>                End
91790>>>>>>>>
91790>>>>>>>                Case Break
91791>>>>>>>
91791>>>>>>>            Case Else
91791>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91792>>>>>>>>
91792>>>>>>>        Case End
91792>>>>>>>
91792>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91793>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91794>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91796>>>>>>>            Move False to Found
91797>>>>>>>        End
91797>>>>>>>>
91797>>>>>>>        // If open failed, the Err is set to true,
91797>>>>>>>        // but we don't want that because it could end our loop.
91797>>>>>>>        Move False to Err
91798>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91801>>>>>>>
91801>>>>>>>        Function_Return bOpen
91802>>>>>>>    End_Function
91803>>>>>>>
91803>>>>>>>    // Pass a table's logical name
91803>>>>>>>    // Returns True if the table exists in filelist.cfg.
91803>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91805>>>>>>>        Handle hTable
91805>>>>>>>        Boolean bFound
91805>>>>>>>        String sCompareTable
91805>>>>>>>
91805>>>>>>>        Move False to bFound
91806>>>>>>>        Move 0 to hTable
91807>>>>>>>        Repeat
91807>>>>>>>>
91807>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91810>>>>>>>            If (hTable > 0) Begin
91812>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91815>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91817>>>>>>>                    Move True to bFound
91818>>>>>>>                End
91818>>>>>>>>
91818>>>>>>>            End
91818>>>>>>>>
91818>>>>>>>            If (bFound = True) ;                Break
91821>>>>>>>        Until (hTable = 0)
91823>>>>>>>
91823>>>>>>>        Function_Return (bFound = True)
91824>>>>>>>    End_Function
91825>>>>>>>
91825>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91825>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91827>>>>>>>        Boolean bOK bExists
91827>>>>>>>        String sDriverID
91827>>>>>>>
91827>>>>>>>        Get _UtilTableExists hTable to bExists
91828>>>>>>>        If (bExists = False) Begin
91830>>>>>>>            Function_Return DATAFLEX_ID
91831>>>>>>>        End
91831>>>>>>>>
91831>>>>>>>        Get OpenTableExclusive hTable to bOK
91832>>>>>>>        If (bOK = False) Begin
91834>>>>>>>            Function_Return DATAFLEX_ID
91835>>>>>>>        End
91835>>>>>>>>
91835>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91838>>>>>>>        Function_Return sDriverID
91839>>>>>>>    End_Function
91840>>>>>>>
91840>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
91840>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
91842>>>>>>>        Handle hTable
91842>>>>>>>        Integer iRetval
91842>>>>>>>
91842>>>>>>>        Move 0 to hTable
91843>>>>>>>        Move 0 to iRetval
91844>>>>>>>
91844>>>>>>>        Repeat
91844>>>>>>>>
91844>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91847>>>>>>>            If (hTable > 0) Begin
91849>>>>>>>                Increment iRetval
91850>>>>>>>            End
91850>>>>>>>>
91850>>>>>>>        Until (hTable = 0)
91852>>>>>>>
91852>>>>>>>        Function_Return iRetval
91853>>>>>>>    End_Function
91854>>>>>>>
91854>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91854>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91856>>>>>>>        Handle hTable
91856>>>>>>>        String sRoot sDriverID
91856>>>>>>>        Boolean bIsSQLTable
91856>>>>>>>        Integer iPos
91856>>>>>>>
91856>>>>>>>        Move 0 to hTable
91857>>>>>>>        Move "" to sDriverID
91858>>>>>>>        Move False to bIsSQLTable
91859>>>>>>>
91859>>>>>>>        Repeat
91859>>>>>>>>
91859>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91862>>>>>>>            If (hTable > 0) Begin
91864>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91867>>>>>>>                If (sRoot contains ":") Begin
91869>>>>>>>                    Move (Pos(":", sRoot)) to iPos
91870>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91871>>>>>>>                End
91871>>>>>>>>
91871>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91872>>>>>>>            End
91872>>>>>>>>
91872>>>>>>>
91872>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
91874>>>>>>>
91874>>>>>>>        Function_Return sDriverID
91875>>>>>>>    End_Function
91876>>>>>>>
91876>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91878>>>>>>>        String sRootName
91878>>>>>>>        Boolean bIsSQL
91878>>>>>>>        Handle hTable
91878>>>>>>>
91878>>>>>>>        Move False to bIsSQL
91879>>>>>>>        Move 0 to hTable
91880>>>>>>>        Repeat
91880>>>>>>>>
91880>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91883>>>>>>>            If (hTable > 0) Begin
91885>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91888>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
91889>>>>>>>                If (bIsSQL = True) Begin
91891>>>>>>>                    Move 0 to hTable
91892>>>>>>>                End
91892>>>>>>>>
91892>>>>>>>            End
91892>>>>>>>>
91892>>>>>>>        Until (hTable = 0)
91894>>>>>>>
91894>>>>>>>        Function_Return (bIsSQL = False)
91895>>>>>>>    End_Function
91896>>>>>>>
91896>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91896>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
91898>>>>>>>        Function_Return False
91899>>>>>>>    End_Function
91900>>>>>>>
91900>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91902>>>>>>>        String  sRetval
91902>>>>>>>        String[] sOverlapFieldsArray
91903>>>>>>>        Integer iType iColumn iColumns
91903>>>>>>>        Boolean bOpen bOverlap
91903>>>>>>>
91903>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91906>>>>>>>        If (bOpen = False) Begin
91908>>>>>>>            Open hTable
91910>>>>>>>        End
91910>>>>>>>>
91910>>>>>>>
91910>>>>>>>        Move "" to sRetval
91911>>>>>>>
91911>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91914>>>>>>>
91914>>>>>>>        for iColumn from 0 to iColumns
91920>>>>>>>>
91920>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91923>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91925>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91928>>>>>>>                If (bOverlap) Begin
91930>>>>>>>                    If (sRetval <> "") Begin
91932>>>>>>>                        Append sRetval ","
91933>>>>>>>                    End
91933>>>>>>>>
91933>>>>>>>                    Append sRetval iColumn
91934>>>>>>>                End
91934>>>>>>>>
91934>>>>>>>            End
91934>>>>>>>>
91934>>>>>>>        Loop
91935>>>>>>>>
91935>>>>>>>
91935>>>>>>>        If (bOpen = False) Begin
91937>>>>>>>            Close hTable
91938>>>>>>>        End
91938>>>>>>>>
91938>>>>>>>
91938>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91939>>>>>>>
91939>>>>>>>        Function_Return sOverlapFieldsArray
91940>>>>>>>    End_Function
91941>>>>>>>
91941>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
91943>>>>>>>        Handle hoRegistry hoODBCDriverNames
91943>>>>>>>        Boolean bExists bKeyOpened
91943>>>>>>>        String sKey
91943>>>>>>>        String[] sDrivers
91944>>>>>>>        Integer iDriverNames iDriverName
91944>>>>>>>
91944>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91945>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91946>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
91947>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91948>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
91949>>>>>>>        If (bExists) Begin
91951>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91952>>>>>>>            If (bKeyOpened) Begin
91954>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91955>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91956>>>>>>>                If (iDriverNames > 0) Begin
91958>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91959>>>>>>>                    Decrement iDriverNames
91960>>>>>>>                    for iDriverName from 0 to iDriverNames
91966>>>>>>>>
91966>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91967>>>>>>>                    Loop
91968>>>>>>>>
91968>>>>>>>                End
91968>>>>>>>>
91968>>>>>>>                Send CloseKey of hoRegistry
91969>>>>>>>            End
91969>>>>>>>>
91969>>>>>>>        End
91969>>>>>>>>
91969>>>>>>>        Send Destroy of hoRegistry
91970>>>>>>>
91970>>>>>>>        Function_Return sDrivers
91971>>>>>>>    End_Function
91972>>>>>>>
91972>>>>>>>    Procedure IncreaseSortBufferSize
91974>>>>>>>        String sNull
91974>>>>>>>        Integer iSortBufferSize
91974>>>>>>>        Boolean bBufferSet
91974>>>>>>>
91974>>>>>>>        Move "" to sNull
91975>>>>>>>        Move (1024 * 128) to iSortBufferSize
91976>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91981>>>>>>>
91981>>>>>>>    End_Procedure
91982>>>>>>>
91982>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91984>>>>>>>        Integer iLastIndex iIndex iNumSegments
91984>>>>>>>        Boolean bOK
91984>>>>>>>        String sDriverID
91984>>>>>>>
91984>>>>>>>        If (hTable > 0) Begin
91986>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91987>>>>>>>            Close hTable
91988>>>>>>>            Get OpenTableExclusive hTable to bOK
91989>>>>>>>            If (bOK = False) Begin
91991>>>>>>>                Procedure_Return
91992>>>>>>>            End
91992>>>>>>>>
91992>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91995>>>>>>>            Structure_Start hTable sDriverID
91996>>>>>>>                for iIndex from 1 to iLastIndex
92002>>>>>>>>
92002>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92005>>>>>>>                    If (iNumSegments > 0) Begin
92007>>>>>>>                        If (bSetToBatch = True) Begin
92009>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92012>>>>>>>                        End
92012>>>>>>>>
92012>>>>>>>                        Else Begin
92013>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92016>>>>>>>                        End
92016>>>>>>>>
92016>>>>>>>                    End
92016>>>>>>>>
92016>>>>>>>                Loop
92017>>>>>>>>
92017>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92019>>>>>>>        End
92019>>>>>>>>
92019>>>>>>>    End_Procedure
92020>>>>>>>
92020>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92022>>>>>>>        Handle hTable
92022>>>>>>>
92022>>>>>>>        Move 0 to hTable
92023>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92026>>>>>>>
92026>>>>>>>        Function_Return hTable
92027>>>>>>>    End_Function
92028>>>>>>>
92028>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92028>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92030>>>>>>>        Integer iCh
92030>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92031>>>>>>>            Write channel iCh sStmt
92033>>>>>>>        Send Seq_Close_Channel iCh
92034>>>>>>>    End_Procedure
92035>>>>>>>
92035>>>>>>>    // Returns the integer number for the passed Driver ID that is
92035>>>>>>>    // needed by some database API calls.
92035>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92037>>>>>>>        String  sCurrentDriver
92037>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92037>>>>>>>
92037>>>>>>>        Move 0 to iDriver
92038>>>>>>>
92038>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92041>>>>>>>        for iCount from 1 to iNumberOfDrivers
92047>>>>>>>>
92047>>>>>>>
92047>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92050>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92052>>>>>>>                Move iCount to iDriver
92053>>>>>>>            End
92053>>>>>>>>
92053>>>>>>>        Loop
92054>>>>>>>>
92054>>>>>>>
92054>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92054>>>>>>>        If (iDriver = 0) Begin
92056>>>>>>>            Move False to Err
92057>>>>>>>            Load_Driver sDriverID
92058>>>>>>>            If (Err = False) Begin
92060>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92063>>>>>>>            End
92063>>>>>>>>
92063>>>>>>>        End
92063>>>>>>>>
92063>>>>>>>
92063>>>>>>>        Function_Return iDriver
92064>>>>>>>    End_Function
92065>>>>>>>
92065>>>>>>>
92065>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92067>>>>>>>        String  sSqlServerClientVersionName
92067>>>>>>>        
92067>>>>>>>        Case Begin
92067>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92069>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92070>>>>>>>                Case Break
92071>>>>>>>                
92071>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92074>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92075>>>>>>>                Case Break
92076>>>>>>>            
92076>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92079>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92080>>>>>>>                Case Break
92081>>>>>>>            
92081>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92084>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92085>>>>>>>                Case Break
92086>>>>>>>            
92086>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92089>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92090>>>>>>>                Case Break
92091>>>>>>>            
92091>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92094>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92095>>>>>>>                Case Break
92096>>>>>>>            
92096>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92099>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92100>>>>>>>                Case Break
92101>>>>>>>            
92101>>>>>>>            Case Else
92101>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92102>>>>>>>        Case End
92102>>>>>>>        
92102>>>>>>>        Function_Return sSqlServerClientVersionName
92103>>>>>>>    End_Function
92104>>>>>>>
92104>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92106>>>>>>>        String  sSqlServerClientDriverName
92106>>>>>>>        
92106>>>>>>>        Case Begin
92106>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92108>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92109>>>>>>>                Case Break
92110>>>>>>>                
92110>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92113>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92114>>>>>>>                Case Break
92115>>>>>>>            
92115>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92118>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92119>>>>>>>                Case Break
92120>>>>>>>            
92120>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92123>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92124>>>>>>>                Case Break
92125>>>>>>>            
92125>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92128>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92129>>>>>>>                Case Break
92130>>>>>>>            
92130>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92133>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92134>>>>>>>                Case Break
92135>>>>>>>            
92135>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92138>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92139>>>>>>>                Case Break
92140>>>>>>>            
92140>>>>>>>            Case Else
92140>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92141>>>>>>>        Case End
92141>>>>>>>        
92141>>>>>>>        Function_Return sSqlServerClientDriverName
92142>>>>>>>    End_Function
92143>>>>>>>    
92143>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92145>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92145>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92145>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92145>>>>>>>        Boolean bOK
92145>>>>>>>        
92145>>>>>>>        Move "" to sRetval
92146>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92147>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92148>>>>>>>        Load_Driver MSSQLDRV_ID
92149>>>>>>>
92149>>>>>>>        // Loop through all loaded drivers.
92149>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92152>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92158>>>>>>>>
92158>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92161>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92163>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92164>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92167>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92168>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92169>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92170>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92171>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92173>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92174>>>>>>>                End                                
92174>>>>>>>>
92174>>>>>>>                Else Begin
92175>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92176>>>>>>>                End
92176>>>>>>>>
92176>>>>>>>            End
92176>>>>>>>>
92176>>>>>>>        Loop
92177>>>>>>>>
92177>>>>>>>        Send Destroy of hoCLIHandler  
92178>>>>>>>        Send Destroy of hoMSSQLHandler  
92179>>>>>>>        If (bShowErrorDialog = True) Begin
92181>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92182>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92184>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92185>>>>>>>                If (bExitProgram = True) Begin
92187>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92188>>>>>>>                End
92188>>>>>>>>
92188>>>>>>>                Send Stop_Box sRetval  
92189>>>>>>>                If (bExitProgram = True) Begin
92191>>>>>>>                    Send Exit_Application
92192>>>>>>>                End
92192>>>>>>>>
92192>>>>>>>            End
92192>>>>>>>>
92192>>>>>>>        End
92192>>>>>>>>
92192>>>>>>>        
92192>>>>>>>        Function_Return sRetval
92193>>>>>>>    End_Function  
92194>>>>>>>    
92194>>>>>>>    // Returns True if first "." separated string is greater than the second.
92194>>>>>>>    // It checks from left to right, one part of the string at a time.
92194>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92194>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92196>>>>>>>        String[] asVersion asSQLVersion          
92198>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92198>>>>>>>        
92198>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92199>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92200>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92201>>>>>>>        // Make sure the two arrays are of the same size:
92201>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92203>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92204>>>>>>>        End
92204>>>>>>>>
92204>>>>>>>        Decrement iSize
92205>>>>>>>        for iCount from 0 to iSize
92211>>>>>>>>
92211>>>>>>>            Move asVersion[iCount]    to iVersion
92212>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92213>>>>>>>            CompilerWarnings Off
92213>>>>>>>            If (iVersion > iSQLVersion) Break
92216>>>>>>>            CompilerWarnings On
92216>>>>>>>        Loop
92217>>>>>>>>
92217>>>>>>>        
92217>>>>>>>        Function_Return (iVersion > iSQLVersion)
92218>>>>>>>    End_Function
92219>>>>>>>
92219>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92219>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92219>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92219>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92221>>>>>>>        Integer iMode iErrorObject
92221>>>>>>>        Boolean bOpened
92221>>>>>>>        String sTableName 
92221>>>>>>>        Handle hoCurrentErrorHandler
92221>>>>>>>
92221>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92222>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92222>>>>>>>        // so we generate an error here:
92222>>>>>>>        If (IsDebuggerPresent()) Begin
92224>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92225>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92226>>>>>>>            If (iErrorObject <> 0) Begin
92228>>>>>>>                Move iErrorObject to Error_Object_Id
92229>>>>>>>            End
92229>>>>>>>>
92229>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92230>>>>>>>>
92230>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92231>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92232>>>>>>>            Function_Return False
92233>>>>>>>        End
92233>>>>>>>>
92233>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92236>>>>>>>        If (bOpened) Begin
92238>>>>>>>//            If (IsDebuggerPresent()) Begin
92238>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92238>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92238>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
92238>>>>>>>//                    Function_Return True
92238>>>>>>>//                End
92238>>>>>>>//            End
92238>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92241>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92243>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92244>>>>>>>                Function_Return True
92245>>>>>>>            End
92245>>>>>>>>
92245>>>>>>>            Close hTable
92246>>>>>>>        End
92246>>>>>>>>
92246>>>>>>>        Else Begin
92247>>>>>>>            Open hTable
92249>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92252>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92254>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92257>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92259>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92260>>>>>>>                    Function_Return True
92261>>>>>>>                End
92261>>>>>>>>
92261>>>>>>>            End
92261>>>>>>>>
92261>>>>>>>
92261>>>>>>>        End
92261>>>>>>>>
92261>>>>>>>
92261>>>>>>>        Close hTable
92262>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92264>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92267>>>>>>>
92267>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92268>>>>>>>        Function_Return bOpened
92269>>>>>>>    End_Function
92270>>>>>>>
92270>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92272>>>>>>>        String sConnectionID sConnectionString sDriverID
92272>>>>>>>        Boolean bExists bOK bSQLDriver
92272>>>>>>>        Handle hoCLI hoDriver
92272>>>>>>>        Integer iRetval
92272>>>>>>>        tSQLConnection SQLConnection
92272>>>>>>>        tSQLConnection SQLConnection
92272>>>>>>>
92272>>>>>>>        Get psDriverID to sDriverID
92273>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92274>>>>>>>        If (bSQLDriver = False) Begin
92276>>>>>>>            Function_Return True
92277>>>>>>>        End
92277>>>>>>>>
92277>>>>>>>
92277>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92278>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92279>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92280>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92281>>>>>>>
92281>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92282>>>>>>>        If (bExists = False) Begin
92284>>>>>>>            // We always start by deleting the current connection - if any - because the
92284>>>>>>>            // login details my have changed.
92284>>>>>>>            Get phoCLIHandler to hoCLI
92285>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92286>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92287>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92288>>>>>>>            If (bOk = False) Begin
92290>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92291>>>>>>>>
92291>>>>>>>                Function_Return False
92292>>>>>>>            End
92292>>>>>>>>
92292>>>>>>>            Move bOK to bExists
92293>>>>>>>        End
92293>>>>>>>>
92293>>>>>>>
92293>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92294>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92295>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92296>>>>>>>        Send Destroy of hoDriver
92297>>>>>>>
92297>>>>>>>        Function_Return (bExists = True)
92298>>>>>>>    End_Function
92299>>>>>>>
92299>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92299>>>>>>>    // Returns: False if nobody else is running
92299>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92299>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92299>>>>>>>    //      tables are not locked as DataFlex tables are.
92299>>>>>>>    Function IsDatabaseInUse Returns Boolean
92301>>>>>>>        Handle  hTable
92301>>>>>>>        String  sRootName
92301>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92301>>>>>>>        Integer iCount iTables
92301>>>>>>>
92301>>>>>>>        Move 0 to iTables
92302>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92303>>>>>>>        Get AutoConnectionIDLogin to bOK
92304>>>>>>>        Get UtilFilelistNoOfTables to iTables
92305>>>>>>>        Set piPosition   of ghoProgressBar to 0
92306>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92307>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92308>>>>>>>        Move 0 to hTable
92309>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92312>>>>>>>        Move False to bErr
92313>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92314>>>>>>>
92314>>>>>>>        Repeat
92314>>>>>>>>
92314>>>>>>>            Set piPosition of ghoProgressBar to iCount
92315>>>>>>>            Increment iCount
92316>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92319>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92320>>>>>>>
92320>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92320>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92321>>>>>>>            Move False to bOpen
92322>>>>>>>            Get _UtilTableExists hTable to bExists
92323>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92323>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92325>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92326>>>>>>>                Open hTable
92328>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92331>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92332>>>>>>>                If (bOpen = True) Begin
92334>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92334>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92335>>>>>>>                    If (bAlias = False) Begin
92337>>>>>>>                        Close hTable
92338>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92339>>>>>>>                        If (bOpen = False) Begin
92341>>>>>>>                            Move True to bErr
92342>>>>>>>                        End
92342>>>>>>>>
92342>>>>>>>                    End
92342>>>>>>>>
92342>>>>>>>                End
92342>>>>>>>>
92342>>>>>>>                Close hTable
92343>>>>>>>            End
92343>>>>>>>>
92343>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92346>>>>>>>            If (bErr = True ) ;                Break
92349>>>>>>>        Until (not(hTable))
92351>>>>>>>
92351>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92352>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92353>>>>>>>        Move False to Err
92354>>>>>>>
92354>>>>>>>        Function_Return bErr
92355>>>>>>>    End_Function
92356>>>>>>>
92356>>>>>>>End_Class
92357>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 23.0\Pkg\for_all.pkg)
92357>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92357>>>>>>>//
92357>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92357>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92357>>>>>>>// conjunction with constraint-clauses.
92357>>>>>>>//
92357>>>>>>>// SYNTAX:
92357>>>>>>>//
92357>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92357>>>>>>>//    <Constraints...>
92357>>>>>>>//    {DO}
92357>>>>>>>//      <loop body>
92357>>>>>>>//  End_For_All
92357>>>>>>>//
92357>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92357>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92357>>>>>>>//
92357>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92357>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92357>>>>>>>//   End_For_All
92357>>>>>>>//
92357>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92357>>>>>>>//
92357>>>>>>>//   For_All Customer BY Index.1
92357>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92357>>>>>>>//     DO
92357>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92357>>>>>>>//   End_For_All
92357>>>>>>>//
92357>>>>>>>// Constraint clauses are:
92357>>>>>>>//
92357>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92357>>>>>>>//   CONSTRAIN <File> AS <Expression>
92357>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92357>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92357>>>>>>>//
92357>>>>>>>// For example, to list all customers with a bad status whose names start
92357>>>>>>>// with "A" and which have not made a payment in thirty days:
92357>>>>>>>//
92357>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92357>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92357>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92357>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92357>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92357>>>>>>>//      DO
92357>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92357>>>>>>>//    End_For_All
92357>>>>>>>//
92357>>>>>>>
92357>>>>>>>
92357>>>>>>>//This command starts the loop process body when constraints are used;
92357>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92357>>>>>>>//command line, and not on a line by itself
92357>>>>>>>//
92357>>>>>>>
92357>>>>>>>//Ends a For_All loop
92357>>>>>>>//
92357>>>>>>>
92357>>>>>>>
92357>>>>>
92357>>>>>
92357>>>>>Class cDbUpdateVersion is a cObject
92358>>>>>
92358>>>>>    Procedure Construct_Object    
92360>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92360>>>>>        String[] aSQLQueryMessages
92361>>>>>        
92361>>>>>        Forward Send Construct_Object
92363>>>>>
92363>>>>>        // cDbUpdateHandler object event.
92363>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92365>>>>>        If (bOnCreateExecuted = False) Begin    
92367>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92369>>>>>            If (bUseCustomDbVersion = False) Begin
92371>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92373>>>>>            End
92373>>>>>>
92373>>>>>            Delegate Send CheckIntFilesIntegrity
92375>>>>>            Delegate Send OnCreate
92377>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92379>>>>>        End
92379>>>>>>
92379>>>>>
92379>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92379>>>>>        // event was triggered, thus an actual change of the database was made.
92379>>>>>        Property Boolean pbVersionUpdate False
92380>>>>>
92380>>>>>        // This property must be manually set within each cDbUpdateVersion object
92380>>>>>        // by the programmer, to a consecutive number.
92380>>>>>        Property Number pnVersionNumber
92381>>>>>
92381>>>>>        Property Boolean pbUseConnectionID True
92382>>>>>        Property Boolean private.pbToANSI   True
92383>>>>>        Property Boolean private.pbRecnum   True
92384>>>>>        Property Boolean private.pbCopyData True
92385>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92386>>>>>        Property Boolean private.pbCompareDate_DateTime False
92387>>>>>        Property Boolean private.pbCompareIndexAscending False
92388>>>>>        Property Boolean private.pbCompareIndexUppercase False
92389>>>>>        Property String private.psSchema
92390>>>>>        Property String private.psBaseTableSpace
92391>>>>>        Property String private.psLongTableSpace
92392>>>>>        Property String private.psIndexTableSpace
92393>>>>>
92393>>>>>        // Driver default value settings:
92393>>>>>        Property String private.psDriverDefaultValueASCII    ""
92394>>>>>        Property String private.psDriverDefaultValueBinary   ""
92395>>>>>        Property String private.psDriverDefaultValueDate     ""
92396>>>>>        Property String private.psDriverDefaultValueDateTime ""
92397>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92398>>>>>        Property String private.psDriverDefaultValueText     ""
92399>>>>>
92399>>>>>        // Driver "nullability" settings:
92399>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92400>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92401>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92402>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92403>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92404>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92405>>>>>
92405>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92405>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92405>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92405>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92405>>>>>        // We reset it here for each cDbUpdateVersion object
92405>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92407>>>>>    End_Procedure
92408>>>>>
92408>>>>>    // *** Main hook event message ***
92408>>>>>    // Place your database update logic here!
92408>>>>>    Procedure OnUpdate
92410>>>>>    End_Procedure
92411>>>>>
92411>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92411>>>>>    // imported to the cDbUpdateHandler container class which should be a
92411>>>>>    // parent object to this object. To have the Studio's Property Panel
92411>>>>>    // "behave" aka show these properties we need to duplicate them in this
92411>>>>>    // class and "relay" them to the parent object.
92411>>>>>    Procedure Set pbToANSI Boolean bState
92413>>>>>        Set private.pbToANSI  to bState
92414>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92415>>>>>        Delegate Set pbToANSI to bState
92417>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92418>>>>>    End_Procedure
92419>>>>>
92419>>>>>    Function pbToANSI Returns Boolean
92421>>>>>        Function_Return (private.pbToAnsi(Self))
92422>>>>>    End_Function
92423>>>>>
92423>>>>>    Procedure Set pbRecnum Boolean bState
92425>>>>>        Set private.pbRecnum  to bState
92426>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92427>>>>>        Delegate Set pbRecnum to bState
92429>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92430>>>>>    End_Procedure
92431>>>>>
92431>>>>>    Function pbRecnum Returns Boolean
92433>>>>>        Function_Return (private.pbRecnum(Self))
92434>>>>>    End_Function
92435>>>>>
92435>>>>>    Procedure Set pbCopyData Boolean bState
92437>>>>>        Set private.pbCopyData  to bState
92438>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92439>>>>>        Delegate Set pbCopyData to bState
92441>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92442>>>>>    End_Procedure
92443>>>>>
92443>>>>>    Function pbCopyData Returns Boolean
92445>>>>>        Function_Return (private.pbCopyData(Self))
92446>>>>>    End_Function
92447>>>>>
92447>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92447>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92449>>>>>        Set private.pbApiTableUpdateAuto  to bState
92450>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92451>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92452>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92453>>>>>    End_Procedure
92454>>>>>
92454>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92456>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92457>>>>>    End_Function
92458>>>>>
92458>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92460>>>>>        Set private.pbCompareDate_DateTime  to bState
92461>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92462>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92463>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92464>>>>>    End_Procedure
92465>>>>>
92465>>>>>    Function pbCompareDate_DateTime Returns Boolean
92467>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92468>>>>>    End_Function
92469>>>>>
92469>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92471>>>>>        Set private.pbCompareIndexAscending  to bState
92472>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92473>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92474>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92475>>>>>    End_Procedure
92476>>>>>
92476>>>>>    Function pbCompareIndexAscending Returns Boolean
92478>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92479>>>>>    End_Function
92480>>>>>
92480>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92482>>>>>        Set private.pbCompareIndexUppercase  to bState
92483>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92484>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92485>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92486>>>>>    End_Procedure
92487>>>>>
92487>>>>>    Function pbCompareIndexUppercase Returns Boolean
92489>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92490>>>>>    End_Function
92491>>>>>
92491>>>>>    Procedure Set psSchema String sValue
92493>>>>>        Set private.psSchema  to sValue
92494>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92495>>>>>        Delegate Set psSchema to sValue
92497>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92498>>>>>    End_Procedure
92499>>>>>
92499>>>>>    // First retrieve the private value that might have been set in the object.
92499>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92499>>>>>    // it might have been specified in the SQLConnections.ini file.
92499>>>>>    Function psSchema Returns String
92501>>>>>        String sValue
92501>>>>>        Get private.psSchema to sValue
92502>>>>>        If (sValue = "") Begin
92504>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92505>>>>>        End
92505>>>>>>
92505>>>>>        Function_Return sValue
92506>>>>>    End_Function
92507>>>>>
92507>>>>>    Procedure Set psBaseTableSpace String sValue
92509>>>>>        Set private.psBaseTableSpace  to sValue
92510>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92511>>>>>        Delegate Set psBaseTableSpace to sValue
92513>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92514>>>>>    End_Procedure
92515>>>>>
92515>>>>>    // First retrieve the private value that might have been set in the object.
92515>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92515>>>>>    // it might have been specified in the SQLConnections.ini file.
92515>>>>>    Function psBaseTableSpace Returns String
92517>>>>>        String sValue
92517>>>>>        Get private.psBaseTableSpace to sValue
92518>>>>>        If (sValue = "") Begin
92520>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92521>>>>>        End
92521>>>>>>
92521>>>>>        Function_Return sValue
92522>>>>>    End_Function
92523>>>>>
92523>>>>>    Procedure Set psLongTableSpace String sValue
92525>>>>>        Set private.psLongTableSpace  to sValue
92526>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92527>>>>>        Delegate Set psLongTableSpace to sValue
92529>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92530>>>>>    End_Procedure
92531>>>>>
92531>>>>>    // First retrieve the private value that might have been set in the object.
92531>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92531>>>>>    // it might have been specified in the SQLConnections.ini file.
92531>>>>>    Function psLongTableSpace Returns String
92533>>>>>        String sValue
92533>>>>>        Get private.psLongTableSpace to sValue
92534>>>>>        If (sValue = "") Begin
92536>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
92537>>>>>        End
92537>>>>>>
92537>>>>>        Function_Return sValue
92538>>>>>    End_Function
92539>>>>>
92539>>>>>    Procedure Set psIndexTableSpace String sValue
92541>>>>>        Set private.psIndexTableSpace  to sValue
92542>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92543>>>>>        Delegate Set psIndexTableSpace to sValue
92545>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92546>>>>>    End_Procedure
92547>>>>>
92547>>>>>    // First retrieve the private value that might have been set in the object.
92547>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92547>>>>>    // it might have been specified in the SQLConnections.ini file.
92547>>>>>    Function psIndexTableSpace Returns String
92549>>>>>        String sValue
92549>>>>>        Get private.psIndexTableSpace to sValue
92550>>>>>        If (sValue = "") Begin
92552>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
92553>>>>>        End
92553>>>>>>
92553>>>>>        Function_Return sValue
92554>>>>>    End_Function
92555>>>>>
92555>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92557>>>>>        Set private.psDriverDefaultValueASCII  to sValue
92558>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92559>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
92561>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92562>>>>>    End_Procedure
92563>>>>>
92563>>>>>    // First retrieve the private value that might have been set in the object.
92563>>>>>    // If blank; get it from the parent object
92563>>>>>    Function psDriverDefaultValueASCII Returns String
92565>>>>>        String sValue
92565>>>>>        Get private.psDriverDefaultValueASCII to sValue
92566>>>>>        If (sValue = "") Begin
92568>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
92570>>>>>        End
92570>>>>>>
92570>>>>>        Function_Return sValue
92571>>>>>    End_Function
92572>>>>>
92572>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92574>>>>>        Set private.psDriverDefaultValueBinary  to sValue
92575>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92576>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
92578>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92579>>>>>    End_Procedure
92580>>>>>
92580>>>>>    // First retrieve the private value that might have been set in the object.
92580>>>>>    // If blank; get it from the parent object
92580>>>>>    Function psDriverDefaultValueBinary Returns String
92582>>>>>        String sValue
92582>>>>>        Get private.psDriverDefaultValueBinary to sValue
92583>>>>>        If (sValue = "") Begin
92585>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
92587>>>>>        End
92587>>>>>>
92587>>>>>        Function_Return sValue
92588>>>>>    End_Function
92589>>>>>
92589>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92591>>>>>        Set private.psDriverDefaultValueDate  to sValue
92592>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92593>>>>>        Delegate Set psDriverDefaultValueDate to sValue
92595>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92596>>>>>    End_Procedure
92597>>>>>
92597>>>>>    // First retrieve the private value that might have been set in the object.
92597>>>>>    // If blank; get it from the parent object
92597>>>>>    Function psDriverDefaultValueDate Returns String
92599>>>>>        String sValue
92599>>>>>        Get private.psDriverDefaultValueDate to sValue
92600>>>>>        If (sValue = "") Begin
92602>>>>>            Delegate Get psDriverDefaultValueDate to sValue
92604>>>>>        End
92604>>>>>>
92604>>>>>        Function_Return sValue
92605>>>>>    End_Function
92606>>>>>
92606>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92608>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
92609>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92610>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
92612>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92613>>>>>    End_Procedure
92614>>>>>
92614>>>>>    // First retrieve the private value that might have been set in the object.
92614>>>>>    // If blank; get it from the parent object
92614>>>>>    Function psDriverDefaultValueDateTime Returns String
92616>>>>>        String sValue
92616>>>>>        Get private.psDriverDefaultValueDateTime to sValue
92617>>>>>        If (sValue = "") Begin
92619>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
92621>>>>>        End
92621>>>>>>
92621>>>>>        Function_Return sValue
92622>>>>>    End_Function
92623>>>>>
92623>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92625>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
92626>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92627>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
92629>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92630>>>>>    End_Procedure
92631>>>>>
92631>>>>>    // First retrieve the private value that might have been set in the object.
92631>>>>>    // If blank; get it from the parent object
92631>>>>>    Function psDriverDefaultValueNumeric Returns String
92633>>>>>        String sValue
92633>>>>>        Get private.psDriverDefaultValueNumeric to sValue
92634>>>>>        If (sValue = "") Begin
92636>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
92638>>>>>        End
92638>>>>>>
92638>>>>>        Function_Return sValue
92639>>>>>    End_Function
92640>>>>>
92640>>>>>    Procedure Set psDriverDefaultValueText String sValue
92642>>>>>        Set private.psDriverDefaultValueText  to sValue
92643>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92644>>>>>        Delegate Set psDriverDefaultValueText to sValue
92646>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92647>>>>>    End_Procedure
92648>>>>>
92648>>>>>    // First retrieve the private value that might have been set in the object.
92648>>>>>    // If blank; get it from the parent object
92648>>>>>    Function psDriverDefaultValueText Returns String
92650>>>>>        String sValue
92650>>>>>        Get private.psDriverDefaultValueText to sValue
92651>>>>>        If (sValue = "") Begin
92653>>>>>            Delegate Get psDriverDefaultValueText to sValue
92655>>>>>        End
92655>>>>>>
92655>>>>>        Function_Return sValue
92656>>>>>    End_Function
92657>>>>>
92657>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92659>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
92660>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92661>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
92663>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92664>>>>>    End_Procedure
92665>>>>>
92665>>>>>    // First retrieve the private value that might have been set in the object.
92665>>>>>    // If blank; get it from the parent object
92665>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92667>>>>>        Boolean bState
92667>>>>>        Get private.pbDriverDefaultNullableASCII to bState
92668>>>>>        If (bState = False) Begin
92670>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
92672>>>>>        End
92672>>>>>>
92672>>>>>        Function_Return bState
92673>>>>>    End_Function
92674>>>>>
92674>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92676>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
92677>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92678>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
92680>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92681>>>>>    End_Procedure
92682>>>>>
92682>>>>>    // First retrieve the private value that might have been set in the object.
92682>>>>>    // If blank; get it from the parent object
92682>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92684>>>>>        Boolean bState
92684>>>>>        Get private.pbDriverDefaultNullableBinary to bState
92685>>>>>        If (bState = False) Begin
92687>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
92689>>>>>        End
92689>>>>>>
92689>>>>>        Function_Return bState
92690>>>>>    End_Function
92691>>>>>
92691>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92693>>>>>        Set private.pbDriverDefaultNullableDate  to bState
92694>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92695>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
92697>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92698>>>>>    End_Procedure
92699>>>>>
92699>>>>>    // First retrieve the private value that might have been set in the object.
92699>>>>>    // If blank; get it from the parent object
92699>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92701>>>>>        Boolean bState
92701>>>>>        Get private.pbDriverDefaultNullableDate to bState
92702>>>>>        If (bState = False) Begin
92704>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
92706>>>>>        End
92706>>>>>>
92706>>>>>        Function_Return bState
92707>>>>>    End_Function
92708>>>>>
92708>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92710>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
92711>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92712>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
92714>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92715>>>>>    End_Procedure
92716>>>>>
92716>>>>>    // First retrieve the private value that might have been set in the object.
92716>>>>>    // If blank; get it from the parent object
92716>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92718>>>>>        Boolean bState
92718>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
92719>>>>>        If (bState = False) Begin
92721>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
92723>>>>>        End
92723>>>>>>
92723>>>>>        Function_Return bState
92724>>>>>    End_Function
92725>>>>>
92725>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92727>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
92728>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92729>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
92731>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92732>>>>>    End_Procedure
92733>>>>>
92733>>>>>    // First retrieve the private value that might have been set in the object.
92733>>>>>    // If blank; get it from the parent object
92733>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92735>>>>>        Boolean bState
92735>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
92736>>>>>        If (bState = False) Begin
92738>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
92740>>>>>        End
92740>>>>>>
92740>>>>>        Function_Return bState
92741>>>>>    End_Function
92742>>>>>
92742>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92744>>>>>        Set private.pbDriverDefaultNullableText  to bState
92745>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92746>>>>>        Delegate Set pbDriverDefaultNullableText to bState
92748>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92749>>>>>    End_Procedure
92750>>>>>
92750>>>>>    // First retrieve the private value that might have been set in the object.
92750>>>>>    // If blank; get it from the parent object
92750>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92752>>>>>        Boolean bState
92752>>>>>        Get private.pbDriverDefaultNullableText to bState
92753>>>>>        If (bState = False) Begin
92755>>>>>            Delegate Get pbDriverDefaultNullableText to bState
92757>>>>>        End
92757>>>>>>
92757>>>>>        Function_Return bState
92758>>>>>    End_Function
92759>>>>>
92759>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
92761>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
92761>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
92761>>>>>
92761>>>>>        Get psDriverID to sDriverID
92762>>>>>        Get psSchema to sSchema
92763>>>>>
92763>>>>>        Get psBaseTableSpace to sBaseTableSpace
92764>>>>>        If (sBaseTableSpace <> "") Begin
92766>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92767>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
92769>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92770>>>>>        End
92770>>>>>>
92770>>>>>
92770>>>>>        Get psLongTableSpace to sLongTableSpace
92771>>>>>        If (sLongTableSpace <> "") Begin
92773>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92774>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
92776>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92777>>>>>        End
92777>>>>>>
92777>>>>>
92777>>>>>        Get psIndexTableSpace to sIndexTableSpace
92778>>>>>        If (sIndexTableSpace <> "") Begin
92780>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92781>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
92783>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92784>>>>>        End
92784>>>>>>
92784>>>>>
92784>>>>>        Get pbUseConnectionID to bUseConnectionID
92785>>>>>        Get pbToANSI          to bToANSI
92786>>>>>        Get pbRecnum          to bRecnum
92787>>>>>        Get pbCopyData        to bCopyData
92788>>>>>
92788>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
92789>>>>>
92789>>>>>        Function_Return bOK
92790>>>>>    End_Function
92791>>>>>
92791>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
92791>>>>>//        Boolean bOK bExists
92791>>>>>//        String sDataPath sBackupFolder
92791>>>>>//        
92791>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
92791>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
92791>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92791>>>>>//        Get vFolderFormat sDataPath to sDataPath
92791>>>>>//        
92791>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92791>>>>>//        If (bExists = False) Begin
92791>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92791>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92791>>>>>//            If (bExists = False) Begin
92791>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
92791>>>>>//                Function_Return False
92791>>>>>//            End                                                                                                                                            
92791>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
92791>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
92791>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
92791>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
92791>>>>>//        End
92791>>>>>//        
92791>>>>>//        Set Message_Text of ghoStatusPanel to ""
92791>>>>>//        Function_Return bOK
92791>>>>>//    End_Function
92791>>>>>//
92791>>>>>    // This is automatically called after the OnUpdate
92791>>>>>    // event has been executed. It will automatically update the
92791>>>>>    // version database field/column with the "pnVersionNumber"
92791>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
92791>>>>>    Procedure UpdateVersionColumnValue
92793>>>>>        Number nVersion nCurrentValue
92793>>>>>        Integer hTable iColumn
92793>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
92793>>>>>
92793>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
92793>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
92793>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92795>>>>>        Get pbVersionUpdate to bVersionUpdate
92796>>>>>
92796>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
92798>>>>>            Get pnVersionNumber to nVersion
92799>>>>>            Delegate Get piDbVersionFileNumber  to hTable
92801>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
92803>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
92803>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
92803>>>>>            Close DF_ALL DF_PERMANENT
92804>>>>>
92804>>>>>            Open hTable
92806>>>>>
92806>>>>>            // It is then the developer responsibility to take care of finding
92806>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
92806>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92808>>>>>            If (bUseCustomDbVersion = True) Begin
92810>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
92812>>>>>            End
92812>>>>>>
92812>>>>>
92812>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92815>>>>>            If (nCurrentValue < nVersion) Begin
92817>>>>>                Lock
92818>>>>>>
92818>>>>>                    If (bUseCustomDbVersion = False) Begin
92820>>>>>                        Vfind hTable Recnum GE                            
92822>>>>>                    End
92822>>>>>>
92822>>>>>                    Set_Field_Value hTable iColumn to nVersion
92825>>>>>                    SaveRecord hTable
92826>>>>>                Unlock
92827>>>>>>
92827>>>>>            End
92827>>>>>>
92827>>>>>            Close hTable
92828>>>>>        End
92828>>>>>>
92828>>>>>    End_Procedure
92829>>>>>
92829>>>>>// Property of the container object (cDbUpdateHandler)
92829>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
92829>>>>>
92829>>>>>    Procedure End_Construct_Object
92831>>>>>        Forward Send End_Construct_Object
92833>>>>>        Send ProcessUpdate True
92834>>>>>    End_Procedure
92835>>>>>    
92835>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
92837>>>>>        Number nVersion nCurrentValue
92837>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
92837>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
92837>>>>>        String sObjectName
92837>>>>>        tDbVersionInfo[] dbVersionInfoArray
92837>>>>>        tDbVersionInfo[] dbVersionInfoArray
92838>>>>>
92838>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
92840>>>>>
92840>>>>>        // If the programmer forgot to set the version number we do not allow for the application
92840>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
92840>>>>>        // one database update is depended on an earlier update and that earlier version
92840>>>>>        // update was never executed it could lead to disastrous results.
92840>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
92840>>>>>        Get pnVersionNumber to nVersion
92841>>>>>        If (nVersion = 0) Begin
92843>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
92844>>>>>            Move (Name(Self)) to sObjectName
92845>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
92846>>>>>>
92846>>>>>            Send Exit_Application
92847>>>>>        End
92847>>>>>>
92847>>>>>
92847>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
92847>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
92847>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
92849>>>>>        If (bOnPreUpdateExecuted = False) Begin
92851>>>>>            Delegate Send OnPreUpdate
92853>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
92855>>>>>        End
92855>>>>>>
92855>>>>>        
92855>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
92857>>>>>        
92857>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92859>>>>>        If (bUseCustomDbVersion = False) Begin
92861>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
92861>>>>>        End
92861>>>>>>
92861>>>>>        Else Begin
92862>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
92863>>>>>            If (bTableExists = False) Begin
92865>>>>>                Delegate Send OnCreateCustomDbVersionTable
92867>>>>>            End
92867>>>>>>
92867>>>>>        End
92867>>>>>>
92867>>>>>        
92867>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
92867>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
92867>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
92869>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
92871>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
92872>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
92873>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
92874>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
92876>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
92878>>>>>        End
92878>>>>>>
92878>>>>>
92878>>>>>        Delegate Get piDbVersionFileNumber  to hTable
92880>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
92882>>>>>
92882>>>>>        Open hTable
92884>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92887>>>>>        If (bOpened = False) Begin
92889>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
92890>>>>>            Send Exit_Application
92891>>>>>        End
92891>>>>>>
92891>>>>>        
92891>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
92891>>>>>        // in case we take care of it here.
92891>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
92894>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
92896>>>>>            Vfind hTable 0 GT
92898>>>>>        End
92898>>>>>>
92898>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
92901>>>>>        If (bSystemTable = True) Begin
92903>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92906>>>>>        End
92906>>>>>>
92906>>>>>        Else Begin
92907>>>>>            If (bUseCustomDbVersion = True) Begin
92909>>>>>                Send OnFindVersionRecord
92910>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
92913>>>>>            End
92913>>>>>>
92913>>>>>        End
92913>>>>>>
92913>>>>>
92913>>>>>        Close hTable
92914>>>>>
92914>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
92914>>>>>        // If not set we do nothing.
92914>>>>>        If (nCurrentValue < nVersion) Begin
92916>>>>>
92916>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
92916>>>>>            // execution of database update code. So if true _and_ one error
92916>>>>>            // has already occured; we're out of here.
92916>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
92918>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92920>>>>>            If (bStopOnFirstError = True) Begin
92922>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
92924>>>>>                    Procedure_Return
92925>>>>>                End
92925>>>>>>
92925>>>>>            End
92925>>>>>>
92925>>>>>
92925>>>>>            // This is send to the parent container object (cDbUpdateHandler)
92925>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
92927>>>>>
92927>>>>>            // If the parent property pbContinueOnError = False, an update
92927>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
92927>>>>>            Delegate Get pbContinueOnError to bContinueOnError
92929>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
92931>>>>>                Procedure_Return
92932>>>>>            End
92932>>>>>>
92932>>>>>
92932>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
92934>>>>>
92934>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
92935>>>>>
92935>>>>>            // *** Programmer's main hook event for database update functions:
92935>>>>>            Send OnUpdate
92936>>>>>
92936>>>>>            Set pbVersionUpdate to True
92937>>>>>            Send UpdateVersionColumnValue
92938>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
92940>>>>>        End
92940>>>>>>
92940>>>>>
92940>>>>>    End_Procedure
92941>>>>>
92941>>>>>End_Class
92942>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
92942>>>>>//****************************************************************************
92942>>>>>// $Module type: Class
92942>>>>>// $Module name: cDbUpdateUserCount.pkg
92942>>>>>// $Author     : Emil Stojanov Quantaris B.V.
92942>>>>>//
92942>>>>>//               Collected from DAW's newsgroups.
92942>>>>>//
92942>>>>>// Description : It uses the windows API to lock bytes in a file.
92942>>>>>//               If the application or PC craches it will release the lock
92942>>>>>//               automatically.
92942>>>>>//
92942>>>>>// Note 1      : It will count the number of running app's, so if a
92942>>>>>//               user starts the app twice on one machine it will count as two users.
92942>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
92942>>>>>//               However, to not conflict with any other usage of this class it was
92942>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
92942>>>>>//               and cDbUpdateVersion classes)
92942>>>>>//
92942>>>>>// $Rev History:
92942>>>>>//    2008-10-17  Module header created (Militaty data format)
92942>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
92942>>>>>//                for easy translation to other languages.
92942>>>>>//                Added the tUserCount struct for easier passing of parameters.
92942>>>>>//                Added the ApplicationPath message.
92942>>>>>//****************************************************************************
92942>>>>>Use LanguageText.pkg
92942>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
92942>>>>>>>Use GlobalFunctionsProcedures.pkg
92942>>>>>>>// Sample:
92942>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
92942>>>>>>>
92942>>>>>>>
92942>>>>>>>// Symbols used by UserCounting
92942>>>>>>>    Define GENERIC_READ         for |CI$80000000
92942>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
92942>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
92942>>>>>>>    Define GENERIC_ALL          for |CI$10000000
92942>>>>>>>    Define CREATE_NEW           for 1
92942>>>>>>>    Define CREATE_ALWAYS        for 2
92942>>>>>>>    Define OPEN_EXISTING        for 3
92942>>>>>>>    Define OPEN_ALWAYS          for 4
92942>>>>>>>    Define TRUNCATE_EXISTING    for 5
92942>>>>>>>    Define FILE_BEGIN           for 0
92942>>>>>>>    Define FILE_CURRENT         for 1
92942>>>>>>>    Define FILE_END             for 2
92942>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
92942>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
92942>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
92942>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
92942>>>>>>>    Define _MAX_PATH  for 260
92942>>>>>>>    Define _MAX_DRIVE for 3
92942>>>>>>>    Define _MAX_DIR   for 256
92942>>>>>>>    Define _MAX_FNAME for 256
92942>>>>>>>    Define _MAX_EXT   for 256
92942>>>>>>>
92942>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
92943>>>>>>>
92943>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
92944>>>>>>>
92944>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
92945>>>>>>>
92945>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
92946>>>>>>>
92946>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
92947>>>>>>>
92947>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
92948>>>>>>>
92948>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
92949>>>>>>>
92949>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
92950>>>>>>>// Sample:
92950>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
92950>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
92952>>>>>>>    Boolean bReturn
92952>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
92953>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
92954>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
92955>>>>>>>    Function_Return bReturn
92956>>>>>>>End_Function
92957>>>>>Use vWin32fh.pkg
92957>>>>>Use seq_chnl.pkg
92957>>>>>
92957>>>>>// User interface constant strings:
92957>>>>>    Define CS_UserCountError            for "User count error:"
92957>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
92957>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
92957>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
92957>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>
92957>>>>>    Struct tUserCount
92957>>>>>        Integer iUserCount
92957>>>>>        Integer iError
92957>>>>>        String  sErrorTxt
92957>>>>>    End_Struct
92957>>>>>
92957>>>>>    Define CI_UserCountMaxUsers for 9999
92957>>>>>
92957>>>>>Class cDbUpdateUserCount is a cObject
92958>>>>>    Procedure Construct_Object
92960>>>>>        Forward Send Construct_Object
92962>>>>>
92962>>>>>        Property String  psLockFileName
92963>>>>>        Property Integer piMaxUsers
92964>>>>>        Property Boolean pbCheckDataFlexUserCount True
92965>>>>>
92965>>>>>        Property Handle  phUserCountFile
92966>>>>>        Property Integer pdwLockPosition
92967>>>>>    End_Procedure
92968>>>>>
92968>>>>>    Function IsProgramRunning Returns Boolean
92970>>>>>        tUserCount UserCount
92970>>>>>        tUserCount UserCount
92970>>>>>
92970>>>>>        Get CheckUserCount to UserCount
92971>>>>>
92971>>>>>        Function_Return (UserCount.iUserCount > 1)
92972>>>>>    End_Function
92973>>>>>
92973>>>>>    // Returns the full path of the Application (no trailing "\")
92973>>>>>    Function ApplicationPath Returns String
92975>>>>>        String sApplicationFileName sPath
92975>>>>>        Integer iNumChars iRetval
92975>>>>>
92975>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
92976>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
92977>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
92978>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
92979>>>>>        Move (CString(sApplicationFileName)) to sPath
92980>>>>>
92980>>>>>        Function_Return sPath
92981>>>>>    End_Function
92982>>>>>
92982>>>>>    Function OpenUserCountFile String sFileName Returns Handle
92984>>>>>        Handle  hFile
92984>>>>>        Pointer pFileName
92984>>>>>        String sPath sFile
92984>>>>>        Integer iCh
92984>>>>>
92984>>>>>        Move (Addressof(sFileName)) to pFileName
92985>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
92986>>>>>
92986>>>>>        // If lock file doesn't exist, create it.
92986>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
92988>>>>>            Get ApplicationPath to sPath
92989>>>>>            Get vFolderFormat sPath to sPath
92990>>>>>            Move (sPath + psLockFileName(Self)) to sFile
92991>>>>>            Get Seq_Open_Output_Channel sFile to iCh
92992>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
92994>>>>>                Function_Return 0
92995>>>>>            End
92995>>>>>>
92995>>>>>            Direct_Output channel iCh sFile
92997>>>>>                Write channel iCh ""
92999>>>>>            Send Seq_Close_Channel iCh
93000>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93001>>>>>        End
93001>>>>>>
93001>>>>>
93001>>>>>        Function_Return hFile
93002>>>>>    End_Function
93003>>>>>
93003>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93005>>>>>        Integer iReturnValue 
93005>>>>>        Boolean bOK
93005>>>>>
93005>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93006>>>>>        If (iReturnValue = 0) Begin
93008>>>>>            Move False to bOK
93009>>>>>        End
93009>>>>>>
93009>>>>>        Else Begin
93010>>>>>            Move True to bOK
93011>>>>>        End
93011>>>>>>
93011>>>>>        Function_Return bOK
93012>>>>>    End_Function
93013>>>>>
93013>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93015>>>>>        Integer iReturnValue
93015>>>>>        Boolean bOK
93015>>>>>
93015>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93016>>>>>        If (iReturnValue = 0) Begin
93018>>>>>            Move False to bOK
93019>>>>>        End
93019>>>>>>
93019>>>>>        Else Begin
93020>>>>>            Move True to bOK
93021>>>>>        End           
93021>>>>>>
93021>>>>>        Function_Return bOK
93022>>>>>    End_Function
93023>>>>>
93023>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93025>>>>>        dWord dwCurrPos
93025>>>>>
93025>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93026>>>>>        Function_Return dwCurrPos
93027>>>>>    End_Function
93028>>>>>
93028>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93030>>>>>        DWord dwCurrPos
93030>>>>>
93030>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93031>>>>>        Function_Return dwCurrPos
93032>>>>>    End_Function
93033>>>>>
93033>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93035>>>>>        Integer iReturnValue                               
93035>>>>>        Boolean bOK
93035>>>>>        String  sBuffer
93035>>>>>        Pointer pBuffer
93035>>>>>        String  sSize
93035>>>>>        Pointer pSize
93035>>>>>
93035>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93036>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93037>>>>>
93037>>>>>        Move (Repeat((Character(0)),4)) to sSize
93038>>>>>        Move (AddressOf(sSize)) to pSize
93039>>>>>
93039>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93040>>>>>        If (iReturnValue = 0) Begin
93042>>>>>            Move False to bOK
93043>>>>>        End
93043>>>>>>
93043>>>>>        Else Begin
93044>>>>>            Move True to bOK
93045>>>>>        End                 
93045>>>>>>
93045>>>>>        Function_Return bOK
93046>>>>>    End_Function
93047>>>>>
93047>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93049>>>>>        Integer iReturnValue
93049>>>>>
93049>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93050>>>>>        Function_Return iReturnValue
93051>>>>>    End_Function
93052>>>>>
93052>>>>>    Procedure DoCheckUserCount
93054>>>>>        tUserCount UserCount
93054>>>>>        tUserCount UserCount
93054>>>>>
93054>>>>>        Get CheckUserCount to UserCount
93055>>>>>        // If all is fine, we're done.
93055>>>>>        If (UserCount.iError = 0) Begin
93057>>>>>            Procedure_Return
93058>>>>>        End
93058>>>>>>
93058>>>>>
93058>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93059>>>>>
93059>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93061>>>>>            Abort
93062>>>>>>
93062>>>>>        End
93062>>>>>>
93062>>>>>    End_Procedure
93063>>>>>
93063>>>>>    Function CheckUserCount Returns tUserCount
93065>>>>>        Handle  hFile
93065>>>>>        String  sPath sFile
93065>>>>>        Integer iResult
93065>>>>>        DWord   dwFilePos
93065>>>>>        Integer bLocked
93065>>>>>        Integer iMaxUsers
93065>>>>>        Integer iCurUser
93065>>>>>        tUserCount UserCount
93065>>>>>        tUserCount UserCount
93065>>>>>
93065>>>>>        Move 0 to UserCount.iError
93066>>>>>
93066>>>>>        Get phUserCountFile to hFile
93067>>>>>        If (not(hFile)) Begin
93069>>>>>            Get ApplicationPath to sPath
93070>>>>>            Get vFolderFormat sPath to sPath
93071>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93072>>>>>            Get OpenUserCountFile sFile to hFile
93073>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93075>>>>>                Move 1 to UserCount.iUserCount
93076>>>>>                Move 1 to UserCount.iError
93077>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93078>>>>>                Function_Return UserCount
93079>>>>>            End
93079>>>>>>
93079>>>>>            Else Begin
93080>>>>>                Move False to bLocked
93081>>>>>                Set phUserCountFile to hFile
93082>>>>>                Get piMaxUsers to iMaxUsers
93083>>>>>
93083>>>>>                // Set Filepointer to beginning of the file
93083>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93084>>>>>                If (dwFilePos = -1) Begin
93086>>>>>                    Move 1 to UserCount.iUserCount
93087>>>>>                    Move 2 to UserCount.iError
93088>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93089>>>>>                    Function_Return UserCount
93090>>>>>                End
93090>>>>>>
93090>>>>>                For iCurUser from 1 to iMaxUsers
93096>>>>>>
93096>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93097>>>>>                    If (not(iResult)) Begin  // byte is locked
93099>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93100>>>>>                        If (dwFilePos = -1) Begin
93102>>>>>                            Move 1 to UserCount.iUserCount
93103>>>>>                            Move 3 to UserCount.iError
93104>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93105>>>>>                            Function_Return UserCount
93106>>>>>                        End
93106>>>>>>
93106>>>>>                    End
93106>>>>>>
93106>>>>>                    Else Begin  // byte is not locked
93107>>>>>                        Set pdwLockPosition to dwFilePos
93108>>>>>                        Move True to bLocked
93109>>>>>                        Move iMaxUsers to iCurUser
93110>>>>>                    End
93110>>>>>>
93110>>>>>                Loop
93111>>>>>>
93111>>>>>                If (not(bLocked)) Begin
93113>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93114>>>>>                    Move 4 to UserCount.iError
93115>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93116>>>>>                    Function_Return UserCount
93117>>>>>                End
93117>>>>>>
93117>>>>>            End
93117>>>>>>
93117>>>>>        End
93117>>>>>>
93117>>>>>
93117>>>>>        Function_Return UserCount
93118>>>>>    End_Function
93119>>>>>
93119>>>>>
93119>>>>>    Procedure DoReleaseUserCount
93121>>>>>        Integer iResult
93121>>>>>        Handle  hFile
93121>>>>>        DWord   dwLockPos
93121>>>>>
93121>>>>>        Get phUserCountFile to hFile
93122>>>>>        Get pdwLockPosition to dwLockPos
93123>>>>>        If (hFile) Begin
93125>>>>>            If (dwLockPos) Begin
93127>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93128>>>>>            End
93128>>>>>>
93128>>>>>            Get CloseUserCountFile hFile to iResult
93129>>>>>        End
93129>>>>>>
93129>>>>>    End_Procedure
93130>>>>>
93130>>>>>    Function CurrentNumberOfUsers Returns Integer
93132>>>>>        Handle  hFile
93132>>>>>        Integer iMaxUsers
93132>>>>>        DWord   dwFilePos
93132>>>>>        Integer iCurUser
93132>>>>>        Integer iResult
93132>>>>>        Integer iNumberOfLocks
93132>>>>>        String  sPath sFile
93132>>>>>
93132>>>>>        Move 0 to iNumberOfLocks
93133>>>>>
93133>>>>>        Get ApplicationPath to sPath
93134>>>>>        Get vFolderFormat sPath to sPath
93135>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93136>>>>>        Get OpenUserCountFile sFile to hFile
93137>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93139>>>>>            Send UserError CS_UnableToInitUserCountSys
93140>>>>>            Abort
93141>>>>>>
93141>>>>>        End
93141>>>>>>
93141>>>>>
93141>>>>>        If (hFile > 0) Begin
93143>>>>>            Get piMaxUsers To iMaxUsers
93144>>>>>
93144>>>>>            // Set Filepointer to beginning of the file
93144>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93145>>>>>            If (dwFilePos = -1) Begin
93147>>>>>                Send UserError CS_UnableResetUserCountSys
93148>>>>>                Abort
93149>>>>>>
93149>>>>>            End
93149>>>>>>
93149>>>>>            For iCurUser from 1 to iMaxUsers
93155>>>>>>
93155>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93156>>>>>                If (Not(iResult)) Begin  // byte is locked
93158>>>>>                    Increment iNumberOfLocks
93159>>>>>                End
93159>>>>>>
93159>>>>>                Else Begin  // byte is not locked
93160>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93161>>>>>                End
93161>>>>>>
93161>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93162>>>>>                If (dwFilePos = -1) Begin
93164>>>>>                    Send UserError CS_ErrorAdvancingPointer
93165>>>>>                    Abort
93166>>>>>>
93166>>>>>                End
93166>>>>>>
93166>>>>>            Loop
93167>>>>>>
93167>>>>>        End
93167>>>>>>
93167>>>>>        Get CloseUserCountFile hFile to iResult
93168>>>>>        Function_Return iNumberOfLocks
93169>>>>>    End_Function
93170>>>>>
93170>>>>>End_Class
93171>>>Use cDbUpdateFunctionLibrary.pkg
93171>>>
93171>>>//{ DataBindable=True }
93171>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
93171>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
93172>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary
93172>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
93172>>>
93172>>>    Procedure Construct_Object
93174>>>        tUserCount UserCount
93174>>>        tUserCount UserCount
93174>>>        Integer iUserCount
93174>>>        Handle ho                     
93174>>>
93174>>>        Forward Send Construct_Object
93176>>>        Move Self to ghoDbUpdateHandler  
93177>>>        
93177>>>        // Latin1_General_CI_AS = General Insensitive collation
93177>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93177>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93177>>>        // Good read about which collation to select:
93177>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93177>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93178>>>
93178>>>        // Struct array that will contain pnVersionNumbers & object id's of
93178>>>        // all child cDbVersion objects.
93178>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93179>>>
93179>>>        Property Integer Error_Processing_State False  // internal usage
93180>>>        
93180>>>        Property Boolean Private.pbDbVersionCheckDone False
93181>>>
93181>>>        Property Boolean pbUseCustomDbVersion False  
93182>>>        
93182>>>        // If this property = True _and_ no DbVersion table exists 
93182>>>        // when the framework is started, a DbVersion table will be created automatically.
93182>>>        Property Boolean pbAutoCreateDbVersionTable True
93183>>>
93183>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93183>>>        // the Filelist.cfg slot number indicated by this property will be used
93183>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93183>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93183>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93183>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93183>>>        Property Integer Private.piDbVersionFileNumber -1
93184>>>        Property Integer Private.piDbVersionFieldNumber 1
93185>>>
93185>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93185>>>        // that creates all library properties
93185>>>        Send CreateDbUpdateLibraryProperties
93186>>>
93186>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93187>>>
93187>>>        // Error handling:
93187>>>        Property Boolean Private.pbOnCreateExecuted False
93188>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93189>>>        Property Boolean Private.pbProcessingError False
93190>>>        Property Boolean pbDbUpdateErrorHasOccured False
93191>>>        // Don't touch. It is being used by the cDbUpdateVersion
93191>>>        // subclass to tell if that particular update went OK or not.
93191>>>        Property Boolean Private.pbUpdateVersionObjectError False
93192>>>        Property String[] paSQLQueryMessages
93193>>>
93193>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93194>>>        Move Self to Error_Object_Id
93195>>>        // Error handling:
93195>>>        // Temporarily redirect all errors to this object so we can silently
93195>>>        // log all errors that might appear while updating the database.
93195>>>        // We temporarily redirect all errors to this object so we can
93195>>>        // log and write errors to the log file. It will be reset after
93195>>>        // the database updates have been finished.
93195>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93196>>>
93196>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93197>>>
93197>>>        // Error Reporting Related
93197>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93197>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93198>>>
93198>>>        // If the pbContinueOnError = False, an update
93198>>>        // of another cDbUpdateVersion object will _not_ be
93198>>>        // performed if an error occured in a previous
93198>>>        // cDbUpdateVersion object.
93198>>>        Property Boolean pbContinueOnError False
93199>>>        // Stops execution in other cDbUpdateVersion objecs,
93199>>>        // if errors occurred in one cDbUpdateVersion object.
93199>>>        Property Boolean pbStopOnFirstError False
93200>>>        // If True errors that occured while updating the database
93200>>>        // will be shown in the default app for .txt files when done.
93200>>>        // Note: The log file will _always_ be created in the Data folder.
93200>>>        Property Boolean pbShowErrorLogPostRun True
93201>>>
93201>>>        // Be _very_ careful to set this property to true!
93201>>>        // If = True, no question will be asked if the update
93201>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93201>>>        // the error log won't be shown. The logfile itself will still be created though.
93201>>>        // You have to know what you're doing!
93201>>>        Property Boolean pbSilentMode False
93202>>>        
93202>>>        Property Boolean pbEnableCancelButton False
93203>>>
93203>>>        // Don't touch! Very private. The value is used by the error log to write for which
93203>>>        // cDbUpdateVersion object an error occured.
93203>>>        Property Number pnCurrentVersionUpdate 0
93204>>>
93204>>>        // The user counting logic is used to safe-guard agains anybody else is
93204>>>        // using the application when a database update is to be performed.
93204>>>        // (Garters & suspenders!)
93204>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93205>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93206>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93207>>>
93207>>>        // This lock file is used to guard against somebody else tries to start the
93207>>>        // application while updates are in progress.
93207>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93208>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93209>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93210>>>                                                                                      // Only the current user allowed.
93210>>>        // Properties for the table & column of a system file field/column where
93210>>>        // the database version update number gets saved.
93210>>>        Property Integer Private.Data_File  0
93211>>>        Property Integer Private.Data_Field 0
93212>>>
93212>>>        // Property that is used to indicate that we have already
93212>>>        // started the database update.
93212>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93213>>>
93213>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93213>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93213>>>        // change of the database has been made.
93213>>>        Property Boolean Private.pbDatabaseWasUpdated False
93214>>>
93214>>>        // We need to trigger the user counting system so that a bit in the
93214>>>        // user counting file is locked. This is to guard that not more than one user
93214>>>        // is currently runnning the program.
93214>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93215>>>
93215>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93216>>>        If (iUserCount > 0) Begin
93218>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93219>>>            Send Exit_Application
93220>>>        End
93220>>>>
93220>>>
93220>>>        Set pbHandleQueryErrors to False
93221>>>            
93221>>>        Property Handle phoSQLConnectionHandler 0
93222>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93222>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93222>>>        // etc information.
93222>>>        If (ghoSQLConnectionHandler = 0) Begin
93224>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93225>>>            Set phoSQLConnectionHandler to ho
93226>>>        End             
93226>>>>
93226>>>        
93226>>>        Property Boolean pbCheckIntFiles False   
93227>>>        Property Handle  phIntFilesTable 2048
93228>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93229>>>        
93229>>>        Set Icon to "Default.ico"
93230>>>    End_Procedure
93231>>>
93231>>>    Procedure End_Construct_Object
93233>>>        Boolean bCheckIntFiles
93233>>>        
93233>>>        Forward Send End_Construct_Object
93235>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93237>>>            Send OnCreate
93238>>>            Set Private.pbOnCreateExecuted to True
93239>>>        End
93239>>>>
93239>>>        Send Cleanup
93240>>>    End_Procedure
93241>>>    
93241>>>    // Programmers hook event.
93241>>>    Procedure OnCreate
93243>>>    End_Procedure        
93244>>>                                 
93244>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93244>>>    //                                                
93244>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
93244>>>    // cDbUpdateHandler object.
93244>>>    //
93244>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93244>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93244>>>    //
93244>>>    // If not done previously the phIntFilesTable will be created and filled with data
93244>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93244>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93244>>>    // of Filelist.cfg is made for backup purposes.
93244>>>    //
93244>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93244>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93244>>>    Procedure CheckIntFilesIntegrity
93246>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
93246>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
93246>>>        String sFileListZipFile sParam sProgram sFile 
93246>>>        Integer iDataPaths iCount
93246>>>        Handle hTable hIntFilesTable                    
93246>>>        UChar[] asFileListArray 
93247>>>        String[] asSavedIntFile
93248>>>        tDUFIntFile[] DUFIntFiles
93248>>>        tDUFIntFile[] DUFIntFiles
93249>>>        
93249>>>        Get pbCheckIntFiles to bCheckIntFiles
93250>>>        If (bCheckIntFiles = False) Begin
93252>>>            Procedure_Return
93253>>>        End
93253>>>>
93253>>>        
93253>>>        Move True to bResult        
93254>>>        
93254>>>        // Note: Include_Resource is a compiler directive!
93254>>>        // It will embedd the Filelist.cfg from the developers machine
93254>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
93254>>>        // need to change the next code line.         
93254>>>        //
93254>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93254>>>        // when we get here and then the compiler can't embedd it!        
93254>>>        // ToDo: Change compiler directives in Project properties (?)
93254>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93254>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93254>>>        
93254>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93255>>>        Get vFilePathExists sFileListName to bExists 
93256>>>        If (bExists = True) Begin
93258>>>            Get ParseFolderName sFileListName to sDataPath    
93259>>>            Get vFolderFormat sDataPath to sDataPath                              
93260>>>            Get ParseFileName sFileListName to sFile
93261>>>            // We need to create a backup copy of Filelist.cfg.
93261>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
93262>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
93263>>>            If (bOK = False) Begin
93265>>>                Move False to bResult
93266>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
93267>>>>
93267>>>            End
93267>>>>
93267>>>        End
93267>>>>
93267>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
93267>>>        Else Begin
93268>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
93269>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
93269>>>            If (bOK = False) Begin   
93271>>>                Move False to bResult
93272>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
93273>>>>
93273>>>            End
93273>>>>
93273>>>        End
93273>>>>
93273>>>        
93273>>>        Get phIntFilesTable to hIntFilesTable
93274>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
93277>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
93278>>>        // This will automatically create the phIntFilesTable if not exists.
93278>>>        // It is used to save data from the current set of .int files.
93278>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
93280>>>            Send AutoCreateIntFilesTable
93281>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93282>>>            If (bIntFilesTablesCheckDone = False) Begin
93284>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
93285>>>                Send Exit_Application of ghoApplication
93286>>>            End
93286>>>>
93286>>>        End                                                       
93286>>>>
93286>>>        
93286>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
93286>>>        // ToDo: Or should this always be attempted? Else the 
93286>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93287>>>        Move (IsDebuggerPresent()) to bDevelop
93288>>>        If (bDevelop = False) Begin
93290>>>            Get vFolderExists sDDSrcPath to bDevelop
93291>>>        End
93291>>>>
93291>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93292>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93293>>>        For iCount from 1 to iDataPaths
93299>>>>
93299>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93300>>>            Get vFolderFormat sDataPath to sDataPath 
93301>>>            Get vFolderExists sDataPath to bExists
93302>>>            If (bExists = True) Begin                  
93304>>>                Move 0 to hTable
93305>>>                Repeat
93305>>>>
93305>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93308>>>                    If (hTable <> 0) Begin
93310>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93313>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93314>>>                        If (bIsSQL = True) Begin     
93316>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93317>>>                            Move (sIntFileName + ".int")    to sIntFileName
93318>>>                            Get IsIntFileSaved sIntFileName to bSaved  
93319>>>                            Move True to bOK            
93320>>>                            
93320>>>                            // Save .int file to database if not done previously.
93320>>>                            // We only attempt to read .int files on a development machine.
93320>>>                            If (bDevelop = True) Begin
93322>>>                                If (bSaved = False) Begin
93324>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93325>>>                                    If (bOK = False) Begin
93327>>>                                        Move False to bResult    
93328>>>                                    End
93328>>>>
93328>>>                                End         
93328>>>>
93328>>>                                If (bOK = True) Begin
93330>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93331>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
93333>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93334>>>                                        If (bOK = False) Begin
93336>>>                                            Move False to bResult
93337>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93338>>>>
93338>>>                                        End
93338>>>>
93338>>>                                    End
93338>>>>
93338>>>                                End
93338>>>>
93338>>>                            End
93338>>>>
93338>>>                            
93338>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
93339>>>                            If (bExists = False) Begin                           
93341>>>                                // If the .int file is missing on disk; create it from database.
93341>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
93342>>>                                If (bOK = False) Begin         
93344>>>                                    Move False to bResult
93345>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
93346>>>>
93346>>>                                End
93346>>>>
93346>>>                            End
93346>>>>
93346>>>                        End
93346>>>>
93346>>>                    End
93346>>>>
93346>>>                Until (hTable = 0)
93348>>>            End
93348>>>>
93348>>>        Loop       
93349>>>>
93349>>>        
93349>>>        // If an error occured we need to exit the application.
93349>>>        If (bResult = False) Begin  
93351>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
93352>>>            Send Exit_Application
93353>>>        End
93353>>>>
93353>>>        
93353>>>    End_Procedure               
93354>>>
93354>>>    // To update currently saved IntFile data to the database.
93354>>>    // Because it is much easier, we first delete all current records and
93354>>>    // then saves the changed .int file to the database.
93354>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93356>>>        Boolean bOK
93356>>>        
93356>>>        Move False to bOK
93357>>>
93357>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93358>>>        If (bOK = True) Begin
93360>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93361>>>        End
93361>>>>
93361>>>        
93361>>>        Function_Return bOK
93362>>>    End_Function
93363>>>    
93363>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93365>>>        Handle hTable
93365>>>        Boolean bOK
93365>>>        Integer iColumn iIndex   
93365>>>        String sFileName
93365>>>        
93365>>>        Move False to bOK
93366>>>        Get phIntFilesTable to hTable
93367>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93368>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93369>>>
93369>>>        Open hTable
93371>>>        Set_Field_Value hTable iColumn to sIntFileName
93374>>>        Vfind hTable iIndex GE
93376>>>        Get_Field_Value hTable iColumn to sFileName
93379>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93381>>>            Move True to bOK    
93382>>>        End
93382>>>>
93382>>>        Close hTable
93383>>>        
93383>>>        Function_Return bOK       
93384>>>    End_Function   
93385>>>    
93385>>>    // Checks that the passed .int file is the same as what is saved in the database.
93385>>>    // If not same, the return string array will contain the read .int file,
93385>>>    // else the returned array will be empty.
93385>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93387>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93391>>>        Boolean bIsSame
93391>>>        
93391>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
93392>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
93393>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93394>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93395>>>        
93395>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93396>>>        If (bIsSame = False) Begin
93398>>>            Move asIntFileOrg to asReturnIntFile    
93399>>>        End
93399>>>>
93399>>>        
93399>>>        Function_Return asReturnIntFile    
93400>>>    End_Function                                   
93401>>>    
93401>>>    // Takes a string array as parameter and returns a new
93401>>>    // string array without any empty rows and all rows trimmed.
93401>>>    // This is e.g. used by the HasIntFileChanged message to compare
93401>>>    // two .int file arrays. 
93401>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93403>>>        Integer iSize iCount iRow
93403>>>        String sVal        
93403>>>        String[] asRetValArray
93404>>>        
93404>>>        Move (SizeOfArray(asIntFile)) to iSize
93405>>>        If (iSize = 0) Begin
93407>>>            Function_Return asRetValArray
93408>>>        End                          
93408>>>>
93408>>>        Decrement iSize         
93409>>>        Move 0 to iRow
93410>>>        
93410>>>        For iCount from 0  to iSize
93416>>>>
93416>>>            Move asIntFile[iCount] to sVal
93417>>>            Move (Trim(sVal)) to sVal
93418>>>            If (sVal <> "") Begin
93420>>>                Move sVal to asRetValArray[iRow]
93421>>>                Increment iRow        
93422>>>            End
93422>>>>
93422>>>        Loop
93423>>>>
93423>>>        
93423>>>        Function_Return asRetValArray
93424>>>    End_Function
93425>>>    
93425>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93427>>>        Handle hTable
93427>>>        Boolean bOK bErr
93427>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93427>>>        Number iID
93427>>>        String sFileName
93427>>>        String[] asIntFile
93428>>>        
93428>>>        Move Err to bErr
93429>>>        Move False to Err
93430>>>        Move False to bOK
93431>>>        Get phIntFilesTable to hTable  
93432>>>        Move 1              to iIDCol
93433>>>        Move 2              to iFileCol
93434>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93435>>>        Move 1              to iIDIdx   // Main ID index.
93436>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93437>>>
93437>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93438>>>        Move (SizeOfArray(asIntFile)) to iSize
93439>>>        If (iSize = 0) Begin
93441>>>            Function_Return False
93442>>>        End
93442>>>>
93442>>>        Decrement iSize
93443>>>        Open hTable  
93445>>>                  
93445>>>        // Find the last used ID no:
93445>>>        Fill_Field hTable iIDCol with DF_HIGH
93447>>>        Vfind hTable iIDIdx LE
93449>>>        Get_Field_Value hTable iIDCol to iID 
93452>>>        // This only happens the very first time we save a record.
93452>>>        If (iID = 999999999999) Begin
93454>>>            Move 0 to iID
93455>>>        End
93455>>>>
93455>>>        Increment iID        
93456>>>        
93456>>>        Lock
93457>>>>
93457>>>            For iCount from 0 to iSize
93463>>>>
93463>>>                Clear hTable
93464>>>                Set_Field_Value hTable iIDCol   to iID     
93467>>>                Set_Field_Value hTable iFileCol to sIntFileName
93470>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
93473>>>                SaveRecord hTable
93474>>>                Increment iID
93475>>>            Loop
93476>>>>
93476>>>        Unlock
93477>>>>
93477>>>        Close hTable
93478>>>        
93478>>>        Move (not(Err)) to bOK
93479>>>        Move bErr to Err
93480>>>        
93480>>>        Function_Return bOK
93481>>>    End_Function
93482>>>    
93482>>>    // Deletes all records for the passed sIntFileName value,
93482>>>    // from the phIntFilesTable.
93482>>>    // Returns True if no errors occured.
93482>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
93484>>>        Handle hTable
93484>>>        Boolean bOK bErr bFound
93484>>>        Integer iFileCol iIndex
93484>>>        String sVal
93484>>>        String[] asIntFile
93485>>>        
93485>>>        Move Err to bErr
93486>>>        Move False to Err
93487>>>        Move False to bOK
93488>>>        Move 2              to iFileCol
93489>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93490>>>        Get phIntFilesTable to hTable  
93491>>>        Open hTable  
93493>>>                  
93493>>>        // Find the first record
93493>>>        Set_Field_Value hTable iFileCol to sIntFileName
93496>>>        Vfind hTable iIndex GE
93498>>>        Get_Field_Value hTable iFileCol to sVal
93501>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93502>>>        While (bFound = True)
93506>>>            Delete hTable
93507>>>            Vfind hTable iIndex GT
93509>>>            Get_Field_Value hTable iFileCol to sVal
93512>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93513>>>        Loop
93514>>>>
93514>>>        Unlock
93515>>>>
93515>>>        Close hTable
93516>>>        
93516>>>        Move (not(Err)) to bOK
93517>>>        Move bErr to Err
93518>>>        
93518>>>        Function_Return bOK
93519>>>    End_Function
93520>>>
93520>>>    // Returns all saved phIntFilesTable records for the passed 
93520>>>    // sIntFileName value as a string array.
93520>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
93522>>>        Handle hTable
93522>>>        Boolean bOK bErr bFound
93522>>>        Integer iFileCol iTextCol iIndex
93522>>>        String sVal sFileName
93522>>>        String[] asIntFile asEmptyArray
93524>>>        
93524>>>        Move Err to bErr
93525>>>        Move False to Err
93526>>>        Move False to bOK
93527>>>        Move 2              to iFileCol
93528>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93529>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93530>>>        Get phIntFilesTable to hTable  
93531>>>        Open hTable  
93533>>>
93533>>>        // Find the first record
93533>>>        Set_Field_Value hTable iFileCol to sIntFileName
93536>>>        Vfind hTable iIndex GE
93538>>>        Get_Field_Value hTable iFileCol to sFileName
93541>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93542>>>        While (bFound = True)
93546>>>            Get_Field_Value hTable iFileCol to sFileName
93549>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93550>>>            If (bFound = True) Begin
93552>>>                Get_Field_Value hTable iTextCol to sVal
93555>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
93556>>>            End
93556>>>>
93556>>>            Vfind hTable iIndex GT
93558>>>        Loop
93559>>>>
93559>>>        
93559>>>        Close hTable
93560>>>        Move (not(Err)) to bOK
93561>>>        If (bOK = False) Begin
93563>>>            Move asEmptyArray to asIntFile
93564>>>        End
93564>>>>
93564>>>        Move bErr to Err               
93565>>>        
93565>>>        Function_Return asIntFile
93566>>>    End_Function
93567>>>
93567>>>    // Reads the passed sIntFileName from disk and returns its value
93567>>>    // as a string array.
93567>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
93569>>>        String[] asIntFile       
93570>>>        String sFileName sLine
93570>>>        Integer iCh iSize iCount
93570>>>        
93570>>>        Get vFolderFormat sPath to sPath
93571>>>        If (not(sIntFileName contains ".")) Begin
93573>>>            Move (sIntFileName + ".int") to sIntFileName
93574>>>        End
93574>>>>
93574>>>        Move (sPath + sIntFileName) to sFileName
93575>>>        Get Seq_Open_input_Channel sFileName to iCh
93576>>>        If (iCh < 0) Begin
93578>>>            Function_Return asIntFile
93579>>>        End                                 
93579>>>>
93579>>>        
93579>>>        Repeat
93579>>>>
93579>>>            Readln channel iCh sLine
93581>>>            If (SeqEof = False) Begin
93583>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
93584>>>            End
93584>>>>
93584>>>        Until (SeqEof = True)
93586>>>        Send Seq_Close_Channel iCh    
93587>>>        
93587>>>        Function_Return asIntFile
93588>>>    End_Function
93589>>>    
93589>>>    // Reads the Filelist.cfg from memeory as a resource.
93589>>>    // The Filelist.cfg has been compiled into the program.
93589>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
93591>>>        Integer iCh iCount
93591>>>        Number nByteCount
93591>>>        String[] asFileListArray sEmptyArray
93593>>>        String sLine
93593>>>        UChar[] uCharData
93594>>>        
93594>>>        Move False to Err
93595>>>        Get Seq_New_Channel to iCh
93596>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93598>>>            Error DFERR_PROGRAM 'No channel available...'
93599>>>>
93599>>>            Function_Return sEmptyArray
93600>>>        End
93600>>>>
93600>>>
93600>>>        // First decide the size of the script
93600>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
93602>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
93604>>>        Close_Input channel iCh
93606>>>        Send Seq_Release_Channel iCh
93607>>>
93607>>>        Function_Return uCharData
93608>>>    End_Function    
93609>>>    
93609>>>    // Writes a copy of the workspace Filelist.cfg to disk.
93609>>>    // It does so by reading from a memory resource, as the file has
93609>>>    // been compiled into the program.
93609>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
93611>>>        Boolean bOK bErr
93611>>>        Integer iSize iCh
93611>>>        
93611>>>        Move Err to bErr
93612>>>        Move False to Err
93613>>>        Move False to bOK
93614>>>        Move (SizeOfArray(asFileListArray)) to iSize
93615>>>        If (iSize = 0) Begin
93617>>>            Function_Return False
93618>>>        End
93618>>>>
93618>>>
93618>>>        Get Seq_New_Channel to iCh
93619>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93621>>>            Error DFERR_PROGRAM 'No channel available...'
93622>>>>
93622>>>            Function_Return False
93623>>>        End                      
93623>>>>
93623>>>        
93623>>>        Direct_Output channel iCh sFileListName
93625>>>        Writeln channel iCh asFileListArray
93628>>>                
93628>>>        Close_Input channel iCh
93630>>>        Send Seq_Release_Channel iCh
93631>>>        Move (not(Err)) to bOK
93632>>>        Move bErr to Err
93633>>>        
93633>>>        Function_Return bOK
93634>>>    End_Function
93635>>>
93635>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
93635>>>    // It first deletes the .cch file (if any).
93635>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
93637>>>        Boolean bOK bFound bExists bErr
93637>>>        Integer iCh iSize iCount
93637>>>        String sFileName sCCHFileName sVal
93637>>>        String[] asIntFile
93638>>>        
93638>>>        Move Err to bErr   
93639>>>        Move False to Err
93640>>>        Move False to bOK
93641>>>
93641>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
93642>>>        Move (SizeOfArray(asIntFile)) to iSize
93643>>>        If (iSize = 0) Begin
93645>>>            Function_Return False        
93646>>>        End                      
93646>>>>
93646>>>        Decrement iSize
93647>>>        
93647>>>        Get Seq_New_Channel to iCh
93648>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93650>>>            Function_Return False
93651>>>        End   
93651>>>>
93651>>>        
93651>>>        // Before we start to actually create the new .int file, make sure we delete
93651>>>        // the .cch file first.                                     
93651>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
93652>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
93653>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
93654>>>        If (bExists = True) Begin
93656>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
93657>>>            If (bOK = False) Begin
93659>>>                Function_Return False
93660>>>            End
93660>>>>
93660>>>        End
93660>>>>
93660>>>        
93660>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
93662>>>        For iCount from 0 to iSize
93668>>>>
93668>>>            Writeln channel iCh asIntFile[iCount]
93671>>>        Loop
93672>>>>
93672>>>        
93672>>>        Close_Input channel iCh
93674>>>        Send Seq_Release_Channel iCh
93675>>>        Move (not(Err)) to bOK
93676>>>        Move bErr to Err
93677>>>        
93677>>>        Function_Return bOK
93678>>>    End_Function   
93679>>>              
93679>>>    // Automatically writes .int files to disk that is missing.
93679>>>    // We only need to make this test this once, but because the message is called
93679>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
93679>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
93679>>>    Procedure AutoCreateIntFilesTable 
93681>>>        Integer hTable 
93681>>>        Boolean bIntFilesTablesCheckDone bTableExists
93681>>>        String sInfoTxt 
93681>>>        
93681>>>        Get phIntFilesTable to hTable  
93682>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93683>>>        If (bIntFilesTablesCheckDone = True) Begin
93685>>>            Procedure_Return
93686>>>        End
93686>>>>
93686>>>
93686>>>        If (hTable < 1) Begin
93688>>>            Set Private.pbIntFilesTablesCheckDone to False
93689>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93690>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
93691>>>>
93691>>>            Procedure_Return
93692>>>        End
93692>>>>
93692>>>
93692>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
93693>>>        If (bTableExists = True) Begin
93695>>>            Set Private.pbIntFilesTablesCheckDone to True
93696>>>            Procedure_Return
93697>>>        End
93697>>>>
93697>>>
93697>>>        Send CreateIntFilesTable hTable
93698>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93699>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93700>>>    End_Function
93701>>>                
93701>>>    Procedure CreateIntFilesTable Handle hTable
93703>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
93703>>>        Boolean bTableExists bOK bUseConnectionID bExists
93703>>>        tAPIColumn[] APIColumn
93703>>>        tAPIColumn[] APIColumn
93704>>>
93704>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93705>>>        If (bTableExists = True) Begin
93707>>>            Procedure_Return
93708>>>        End
93708>>>>
93708>>>
93708>>>        Move False to Err
93709>>>        Get psDriverID to sDriverID
93710>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93711>>>
93711>>>        Move CS_IntFilesTableRootName to sTableName
93712>>>
93712>>>        Move 1                  to APIColumn[0].iFieldNumber
93713>>>        Move "ID"               to APIColumn[0].sFieldName
93714>>>        Move DF_BCD             to APIColumn[0].iType
93715>>>        Move False              to APIColumn[0].bIsSQLType
93716>>>        Move 12                 to APIColumn[0].iLength
93717>>>        Move 0                  to APIColumn[0].iPrecision
93718>>>
93718>>>        Move 2                  to APIColumn[1].iFieldNumber
93719>>>        Move "IntFileName"      to APIColumn[1].sFieldName
93720>>>        Move DF_ASCII           to APIColumn[1].iType
93721>>>        Move False              to APIColumn[1].bIsSQLType
93722>>>        Move 50                 to APIColumn[1].iLength
93723>>>        Move 0                  to APIColumn[1].iPrecision
93724>>>
93724>>>        Move 3                  to APIColumn[2].iFieldNumber
93725>>>        Move "IntLineText"      to APIColumn[2].sFieldName
93726>>>        Move DF_ASCII           to APIColumn[2].iType
93727>>>        Move False              to APIColumn[2].bIsSQLType
93728>>>        Move 100                to APIColumn[2].iLength
93729>>>        Move 0                  to APIColumn[2].iPrecision
93730>>>
93730>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93731>>>        
93731>>>        If (bOK = True and Err = False) Begin
93733>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93734>>>        End
93734>>>>
93734>>>        Else Begin
93735>>>            Set Private.pbIntFilesTablesCheckDone to False
93736>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93737>>>            Error DFERR_PROGRAM sInfoTxt
93738>>>>
93738>>>            Procedure_Return
93739>>>        End
93739>>>>
93739>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93740>>>        
93740>>>        Open hTable
93742>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
93743>>>        If (bOK = True) Begin
93745>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
93746>>>        End
93746>>>>
93746>>>        If (bOK = False) Begin
93748>>>            Set Private.pbIntFilesTablesCheckDone to False
93749>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93750>>>            Error DFERR_PROGRAM sInfoTxt
93751>>>>
93751>>>            Procedure_Return
93752>>>        End                    
93752>>>>
93752>>>        
93752>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
93752>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93753>>>        Get vFolderFormat sDataPath to sDataPath
93754>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
93755>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
93756>>>        If (bExists = True) Begin
93758>>>            Move CS_IntFilesTableRootName to sTableName
93759>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
93760>>>            If (bExists = True) Begin
93762>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
93763>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
93764>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
93765>>>            End
93765>>>>
93765>>>        End
93765>>>>
93765>>>        
93765>>>        Set Private.pbIntFilesTablesCheckDone to True
93766>>>    End_Procedure
93767>>>
93767>>>    Procedure CheckAutoCreateDbVersionTable
93769>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
93769>>>        Integer iDbVersionFileNumber
93769>>>
93769>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
93770>>>        If (bDbVersionCheckDone = True) Begin
93772>>>            Procedure_Return
93773>>>        End
93773>>>>
93773>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
93774>>>        If (bUseCustomDbVersion = True) Begin
93776>>>            Procedure_Return
93777>>>        End
93777>>>>
93777>>>
93777>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
93778>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
93780>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93781>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
93782>>>>
93782>>>            Send Exit_Application
93783>>>        End
93783>>>>
93783>>>
93783>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
93784>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93785>>>        If (bTableExists = True) Begin
93787>>>            Set Private.pbDbVersionCheckDone to True
93788>>>            Procedure_Return
93789>>>        End
93789>>>>
93789>>>
93789>>>        Send CreateDbVersionTable iDbVersionFileNumber
93790>>>
93790>>>        // We only need to these DbVersion checks once, but because this message is called
93790>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
93790>>>        // we use a property to only run these tests once.
93790>>>        Set Private.pbDbVersionCheckDone to True
93791>>>    End_Procedure
93792>>>
93792>>>    Procedure CreateDbVersionTable Handle hTable
93794>>>        String sTableName sColumnName sInfoTxt sDriverID 
93794>>>        Boolean bTableExists bOK bUseConnectionID
93794>>>        tAPIColumn[] APIColumn
93794>>>        tAPIColumn[] APIColumn
93795>>>
93795>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93796>>>        If (bTableExists = True) Begin
93798>>>            Procedure_Return
93799>>>        End
93799>>>>
93799>>>
93799>>>        Get psDriverID to sDriverID
93800>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93801>>>
93801>>>        Move "DbVersion"        to sTableName
93802>>>        Move 1                  to APIColumn[0].iFieldNumber
93803>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
93804>>>        Move DF_BCD             to APIColumn[0].iType
93805>>>        Move False              to APIColumn[0].bIsSQLType
93806>>>        Move 4                  to APIColumn[0].iLength
93807>>>        Move 2                  to APIColumn[0].iPrecision
93808>>>
93808>>>        Move False to Err                                
93809>>>        
93809>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
93809>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
93809>>>        Set psDriverID to DATAFLEX_ID
93810>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93811>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93812>>>        Set psDriverID to sDriverID
93813>>>        
93813>>>        If (bOK = True and Err = False) Begin
93815>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
93815>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93816>>>        End
93816>>>>
93816>>>        Else Begin
93817>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
93818>>>        End
93818>>>>
93818>>>
93818>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93819>>>    End_Procedure
93820>>>
93820>>>    Procedure Set pbVerboseState Boolean bVerboseState
93822>>>        Handle ho
93822>>>        Get phoLogFile to ho
93823>>>        Set pbVerboseState of ho to bVerboseState
93824>>>    End_Procedure
93825>>>
93825>>>    Function pbVerboseState Returns Boolean
93827>>>        Boolean bVerboseState
93827>>>        Handle ho
93827>>>        Get phoLogFile to ho
93828>>>        Get pbVerboseState of ho to bVerboseState
93829>>>        Function_Return bVerboseState
93830>>>    End_Function
93831>>>
93831>>>    // Callback functionality used when e.g. calling driver functions directly.
93831>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
93831>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
93833>>>        Integer iPerc
93833>>>        Number nReady nTotal nVersion
93833>>>        Boolean bVerboseState
93833>>>        Handle hoLogFile
93833>>>
93833>>>        Get pbVerboseState to bVerboseState
93834>>>        Get pnCurrentVersionUpdate to nVersion
93835>>>        Get phoLogFile     to hoLogFile
93836>>>        Send DoAdvance of ghoProgressBar
93837>>>
93837>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
93839>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93840>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93841>>>        End
93841>>>>
93841>>>        If (sCallback_Text contains "Creating index") Begin
93843>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
93844>>>        End
93844>>>>
93844>>>
93844>>>        Case Begin
93844>>>            Case (iCallback_Type = DF_Message_Text)
93846>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93847>>>                Set Action_Text  of ghoStatusPanel to ""
93848>>>                If (bVerboseState = True) Begin
93850>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93851>>>                End
93851>>>>
93851>>>                Case Break
93852>>>            Case (iCallback_Type = DF_Message_Heading_1)
93855>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93856>>>                If (bVerboseState = True) Begin
93858>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93859>>>                End
93859>>>>
93859>>>                Case Break
93860>>>            Case (iCallback_Type = DF_Message_Heading_2)
93863>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93864>>>                Set Action_Text  of ghoStatusPanel to ""
93865>>>                If (bVerboseState = True) Begin
93867>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93868>>>                End
93868>>>>
93868>>>                Case Break
93869>>>            Case (iCallback_Type = DF_Message_Heading_3)
93872>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93873>>>                Set Action_Text  of ghoStatusPanel to ""
93874>>>                If (bVerboseState = True) Begin
93876>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93877>>>                End
93877>>>>
93877>>>                Case Break
93878>>>            Case (iCallback_Type = DF_Message_Heading_4)
93881>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93882>>>                Set Action_Text  of ghoStatusPanel to ""
93883>>>                If (bVerboseState = True) Begin
93885>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93886>>>                End
93886>>>>
93886>>>                Case Break
93887>>>            Case (iCallback_Type = DF_Message_Heading_5)
93890>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93891>>>                Set Action_Text  of ghoStatusPanel to ""
93892>>>                If (bVerboseState = True) Begin
93894>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93895>>>                End
93895>>>>
93895>>>                Case Break
93896>>>            Case (iCallback_Type = DF_Message_Warning)
93899>>>                If (bVerboseState = True) Begin
93901>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93902>>>                End
93902>>>>
93902>>>                Case Break
93903>>>            Case (iCallback_Type = DF_Message_Progress_Title)
93906>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93907>>>                Set Action_Text  of ghoStatusPanel to ""
93908>>>                If (bVerboseState = True) Begin
93910>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93911>>>                End
93911>>>>
93911>>>                Case Break
93912>>>            Case (iCallback_Type = DF_Message_Progress_Value)
93915>>>                //*** Interpret numbers
93915>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
93916>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
93917>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
93918>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
93919>>>                Set piPosition of ghoProgressBar to iPerc
93920>>>                Case Break
93921>>>            Case Else
93921>>>                Set Message_Text to ""
93922>>>                Set Action_Text  to ""
93923>>>        Case End
93923>>>
93923>>>        Send ProcessEvents of ghoStatusPanel
93924>>>        Function_Return False
93925>>>    End_Function
93926>>>
93926>>>    // This was made to be a procedure/function pair so we
93926>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
93926>>>
93926>>>    Procedure Set piDbType Integer iDbType
93928>>>        If (ghoSQLConnectionHandler = 0) Begin
93930>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93931>>>>
93931>>>            Procedure_Return
93932>>>        End
93932>>>>
93932>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
93933>>>    End_Procedure
93934>>>
93934>>>    Function piDbType Returns Integer
93936>>>        Integer iDbType
93936>>>        If (ghoSQLConnectionHandler = 0) Begin
93938>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93939>>>>
93939>>>            Function_Return ""
93940>>>        End
93940>>>>
93940>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
93941>>>        Function_Return iDbType
93942>>>    End_Function
93943>>>
93943>>>    Procedure Set psDriverID String sDriverID
93945>>>        If (ghoSQLConnectionHandler = 0) Begin
93947>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93948>>>>
93948>>>            Procedure_Return
93949>>>        End
93949>>>>
93949>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
93950>>>    End_Procedure
93951>>>
93951>>>    Function psDriverID Returns String
93953>>>        String sValue
93953>>>        If (ghoSQLConnectionHandler = 0) Begin
93955>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93956>>>>
93956>>>            Function_Return ""
93957>>>        End
93957>>>>
93957>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
93958>>>        Function_Return sValue
93959>>>    End_Function
93960>>>
93960>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
93962>>>        If (ghoSQLConnectionHandler = 0) Begin
93964>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93965>>>>
93965>>>            Procedure_Return
93966>>>        End
93966>>>>
93966>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
93967>>>    End_Procedure
93968>>>
93968>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
93970>>>        Integer iRetval
93970>>>        If (ghoSQLConnectionHandler = 0) Begin
93972>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93973>>>>
93973>>>            Function_Return 2
93974>>>        End
93974>>>>
93974>>>
93974>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
93975>>>        Function_Return iRetval
93976>>>    End_Function
93977>>>
93977>>>    Procedure Set psConnectionID String sValue
93979>>>        If (ghoSQLConnectionHandler = 0) Begin
93981>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93982>>>>
93982>>>            Procedure_Return
93983>>>        End
93983>>>>
93983>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
93984>>>    End_Procedure
93985>>>
93985>>>    Function psConnectionID Returns String
93987>>>        String sValue
93987>>>        If (ghoSQLConnectionHandler = 0) Begin
93989>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93990>>>>
93990>>>            Function_Return ""
93991>>>        End
93991>>>>
93991>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
93992>>>
93992>>>        Function_Return sValue
93993>>>    End_Function
93994>>>
93994>>>    // These "properties" are settings of the cCLIHandler class, but are being
93994>>>    // relayed to the ghoSQLConnectionHandler object
93994>>>    // simply by changing one of its parameters.
93994>>>    Procedure Set psServer String sValue
93996>>>        If (ghoSQLConnectionHandler = 0) Begin
93998>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93999>>>>
93999>>>            Procedure_Return
94000>>>        End
94000>>>>
94000>>>        Set psServer of ghoSQLConnectionHandler to sValue
94001>>>    End_Procedure
94002>>>
94002>>>    Function psServer Returns String
94004>>>        String sValue
94004>>>        If (ghoSQLConnectionHandler = 0) Begin
94006>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94007>>>>
94007>>>            Function_Return ""
94008>>>        End
94008>>>>
94008>>>        Get psServer of ghoSQLConnectionHandler to sValue
94009>>>
94009>>>        Function_Return sValue
94010>>>    End_Function
94011>>>
94011>>>    Procedure Set psDatabase String sValue
94013>>>        If (ghoSQLConnectionHandler = 0) Begin
94015>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94016>>>>
94016>>>            Procedure_Return
94017>>>        End
94017>>>>
94017>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94018>>>    End_Procedure
94019>>>
94019>>>    Function psDatabase Returns String
94021>>>        String sValue
94021>>>        If (ghoSQLConnectionHandler = 0) Begin
94023>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94024>>>>
94024>>>            Function_Return ""
94025>>>        End
94025>>>>
94025>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94026>>>
94026>>>        Function_Return sValue
94027>>>    End_Function
94028>>>
94028>>>    Procedure Set psUserID String sValue
94030>>>        If (ghoSQLConnectionHandler = 0) Begin
94032>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94033>>>>
94033>>>            Procedure_Return
94034>>>        End
94034>>>>
94034>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94035>>>    End_Procedure
94036>>>
94036>>>    Function psUserID Returns String
94038>>>        String sValue
94038>>>        If (ghoSQLConnectionHandler = 0) Begin
94040>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94041>>>>
94041>>>            Function_Return ""
94042>>>        End
94042>>>>
94042>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94043>>>
94043>>>        Function_Return sValue
94044>>>    End_Function
94045>>>
94045>>>    Procedure Set psPassword String sValue
94047>>>        If (ghoSQLConnectionHandler = 0) Begin
94049>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94050>>>>
94050>>>            Procedure_Return
94051>>>        End
94051>>>>
94051>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94052>>>    End_Procedure
94053>>>
94053>>>    Function psPassword Returns String
94055>>>        String sValue
94055>>>        If (ghoSQLConnectionHandler = 0) Begin
94057>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94058>>>>
94058>>>            Function_Return ""
94059>>>        End
94059>>>>
94059>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94060>>>
94060>>>        Function_Return sValue
94061>>>    End_Function
94062>>>
94062>>>    Procedure Set pbTrusted Boolean bValue
94064>>>        If (ghoSQLConnectionHandler = 0) Begin
94066>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94067>>>>
94067>>>            Procedure_Return
94068>>>        End
94068>>>>
94068>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94069>>>    End_Procedure
94070>>>
94070>>>    Function pbTrusted Returns Boolean
94072>>>        Boolean bValue
94072>>>        If (ghoSQLConnectionHandler = 0) Begin
94074>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94075>>>>
94075>>>            Function_Return False
94076>>>        End
94076>>>>
94076>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94077>>>
94077>>>        Function_Return bValue
94078>>>    End_Function
94079>>>
94079>>>    Procedure Set psConnectionString String sValue
94081>>>        If (ghoSQLConnectionHandler = 0) Begin
94083>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94084>>>>
94084>>>            Procedure_Return
94085>>>        End
94085>>>>
94085>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94086>>>    End_Procedure
94087>>>
94087>>>    Function psConnectionString Returns String
94089>>>        String sValue
94089>>>        If (ghoSQLConnectionHandler = 0) Begin
94091>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94092>>>>
94092>>>            Function_Return ""
94093>>>        End
94093>>>>
94093>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94094>>>
94094>>>        Function_Return sValue
94095>>>    End_Function
94096>>>
94096>>>    Function piConnectionOptions Returns Integer
94098>>>        Integer iValue
94098>>>        If (ghoSQLConnectionHandler = 0) Begin
94100>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94101>>>>
94101>>>            Function_Return 0
94102>>>        End
94102>>>>
94102>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94103>>>
94103>>>        Function_Return iValue
94104>>>    End_Function
94105>>>
94105>>>
94105>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94107>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94108>>>    End_Procedure
94109>>>
94109>>>    Function pbCheckDataFlexUserCount Returns Boolean
94111>>>        Boolean bState
94111>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94112>>>        Function_Return bState
94113>>>    End_Function
94114>>>
94114>>>    Procedure Set psLogTextFile String sValue
94116>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94117>>>    End_Procedure
94118>>>
94118>>>    Function psLogTextFile Returns String
94120>>>        String sValue
94120>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94121>>>        Function_Return sValue
94122>>>    End_Function
94123>>>
94123>>>    Procedure Set psEditorProgram String sValue
94125>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94126>>>    End_Procedure
94127>>>
94127>>>    Function psEditorProgram Returns String
94129>>>        String sValue
94129>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94130>>>        Function_Return sValue
94131>>>    End_Function
94132>>>
94132>>>    Procedure Set pbUseDataTableLog Boolean bState
94134>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94135>>>    End_Procedure
94136>>>
94136>>>    Function pbUseDataTableLog Returns Boolean
94138>>>        Boolean bState
94138>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94139>>>        Function_Return bState
94140>>>    End_Function
94141>>>
94141>>>    Procedure Set pbQuickWrite Boolean bState
94143>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94144>>>    End_Procedure
94145>>>
94145>>>    Function pbQuickWrite Returns Boolean
94147>>>        Boolean bState
94147>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94148>>>        Function_Return bState
94149>>>    End_Function
94150>>>
94150>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94152>>>        Boolean bUpdateVersionObjectError bVerboseState
94152>>>        Integer iSize iCount
94152>>>        Number nVersion
94152>>>        String[] aSQLQueryMessages
94153>>>
94153>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94154>>>        Set Private.pbDatabaseWasUpdated to bState
94155>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94155>>>        // to the log that it was OK.
94155>>>        If (bUpdateVersionObjectError = False) Begin
94157>>>            Get pnCurrentVersionUpdate to nVersion
94158>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94159>>>        End
94159>>>>
94159>>>
94159>>>        Get pbVerboseState to bVerboseState
94160>>>        If (bVerboseState = True) Begin
94162>>>            Get paSQLQueryMessages to aSQLQueryMessages
94163>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94164>>>            Decrement iSize
94165>>>            For iCount from 0 to iSize
94171>>>>
94171>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94172>>>            Loop
94173>>>>
94173>>>        End
94173>>>>
94173>>>
94173>>>    End_Procedure 
94174>>>    
94174>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94176>>>        Set Private.piDbVersionFileNumber to iFileNumber
94177>>>    End_Procedure                                         
94178>>>    
94178>>>    Function piDbVersionFileNumber Returns Integer
94180>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94181>>>    End_Function
94182>>>
94182>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94184>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94185>>>    End_Procedure                                         
94186>>>    
94186>>>    Function piDbVersionFieldNumber Returns Integer
94188>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94189>>>    End_Function
94190>>>
94190>>>    Function pbDatabaseWasUpdated Returns Boolean
94192>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94193>>>    End_Function
94194>>>    
94194>>>    //
94194>>>    Procedure ReinitializeFramework  
94196>>>        tDbVersionInfo[] aDbVersionInfoArray
94196>>>        tDbVersionInfo[] aDbVersionInfoArray
94197>>>        Handle hoDbVersionObject
94197>>>        Integer iSize iCount
94197>>>        
94197>>>        Set Private.pbDatabaseUpdateStarted to False
94198>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94199>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94200>>>        Decrement iSize
94201>>>        
94201>>>        For iCount from 0 to iSize
94207>>>>
94207>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94208>>>            Send ProcessUpdate                  of hoDbVersionObject False
94209>>>        Loop
94210>>>>
94210>>>        Send Cleanup
94211>>>    End_Procedure
94212>>>    
94212>>>    // This event is triggered by the cDbUpdateVersion child class when
94212>>>    // a database change is to be started, and is considered private.
94212>>>    // It is only executed once for the first cDbUpateVersion object!
94212>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94214>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94214>>>        Integer iRetval iDataFlexUsers iUserCount
94214>>>        Handle hoUserCountSystem
94214>>>        tUserCount UserCount
94214>>>        tUserCount UserCount
94214>>>        DateTime dtUpdateStarted
94214>>>        tSQLConnection SQLConnection
94214>>>        tSQLConnection SQLConnection
94214>>>
94214>>>        // *Important:* If we already started the update; we do no further checking.
94214>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94215>>>        If (bDatabaseUpdateStarted = True) Begin
94217>>>            Procedure_Return
94218>>>        End
94218>>>>
94218>>>
94218>>>        // If not silent mode; Ask user if OK to start database update.
94218>>>        If (pbSilentMode(Self) = False) Begin
94220>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94221>>>            If (iRetval <> MBR_Yes) Begin
94223>>>                Send Exit_Application
94224>>>            End
94224>>>>
94224>>>        End
94224>>>>
94224>>>        
94224>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94225>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94226>>>        Send Start_StatusPanel      of ghoStatusPanel
94227>>>
94227>>>        // This will save the status of all open tables including Master/Alias settings,
94227>>>        // so we can restore them later;
94227>>>        Send SaveOpenTables
94228>>>
94228>>>        Move 0 to iDataFlexUsers
94229>>>        // Make various tests to check that the database is not in use.
94229>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94230>>>        // We also use our own user counting mechanism to guard against the
94230>>>        // database isn't opened already as we need exclusive access to the tables.:
94230>>>        Get phoUserCountSystem to hoUserCountSystem
94231>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94232>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94233>>>
94233>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94234>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94234>>>        If (bCheckDataFlexUserCount = True) Begin
94236>>>            Get_Current_User_Count to iDataFlexUsers
94237>>>            // For some reason DataFlex - in some cases - might think that 2 users
94237>>>            // are in use while debugging from the Studio.
94237>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94239>>>                Decrement iDataFlexUsers
94240>>>            End
94240>>>>
94240>>>        End 
94240>>>>
94240>>>        Else Begin
94241>>>            Move 1 to iDataFlexUsers 
94242>>>            Move 1 to iUserCount
94243>>>            Move False to bInUse
94244>>>        End
94244>>>>
94244>>>
94244>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94246>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94247>>>            If (iRetval <> MBR_Yes) Begin
94249>>>                Send Exit_Application
94250>>>            End
94250>>>>
94250>>>        End
94250>>>>
94250>>>
94250>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94252>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94253>>>            Send Exit_Application
94254>>>        End
94254>>>>
94254>>>
94254>>>        // This will put a look on the DbUpdateLock.ucf file.
94254>>>        // It is released when the update process is finished
94254>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94255>>>
94255>>>        Move (CurrentDateTime()) to dtUpdateStarted
94256>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94257>>>        Set Private.pbDatabaseUpdateStarted to True
94258>>>
94258>>>        // We need to close all tables before starting to make changes.
94258>>>        Close DF_ALL DF_PERMANENT
94259>>>
94259>>>        // If these properties has not exclicitly been set in the object, set them
94259>>>        // to settings from the SQLConnections.ini file;
94259>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94260>>>        If (psSchema(Self) = "") Begin
94262>>>            Set psSchema            to SQLConnection.sSchema
94263>>>        End
94263>>>>
94263>>>        If (psBaseTableSpace(Self) = "") Begin
94265>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94266>>>        End
94266>>>>
94266>>>        If (psLongTableSpace(Self) = "") Begin
94268>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94269>>>        End
94269>>>>
94269>>>        If (psIndexTableSpace(Self) = "") Begin
94271>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94272>>>        End
94272>>>>
94272>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94274>>>            Procedure_Return
94275>>>        End
94275>>>>
94275>>>
94275>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94276>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94278>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94279>>>            Send Stop_StatusPanel of ghoStatusPanel
94280>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94280>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94281>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94281>>>            Send Exit_Application
94282>>>        End
94282>>>>
94282>>>    End_Procedure
94283>>>
94283>>>    // *** Hook message for pre-processing ***
94283>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94283>>>    // Aka, when another table than the standard "DbVersion" is used.
94283>>>    Procedure OnCreateCustomDbVersionTable
94285>>>    End_Procedure
94286>>>    
94286>>>    // *** Hook message for pre-processing ***
94286>>>    // The programmer can use this event for putting code that
94286>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94286>>>    // child objects are executed.
94286>>>    Procedure OnPreUpdate
94288>>>    End_Procedure
94289>>>
94289>>>    // *** Hook message for post-processing ***
94289>>>    // The programmer should use this event for putting code that
94289>>>    // needs to be executed _after_ all database updates have finished.
94289>>>    Procedure OnPostUpdate
94291>>>    End_Procedure
94292>>>
94292>>>    // *** Hook message for custom DbVersion record find ***
94292>>>    // The programmer can use this event for putting code that
94292>>>    // needs to be executed to find a *custom* DbVersion table record.
94292>>>    // By default the DbVersion table is used but this can be
94292>>>    // customized by adding this line to the code;
94292>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94292>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94292>>>    //       to save the current database version to. Only if you use your own
94292>>>    //       table _and_ it is not a system table (contains only one record).
94292>>>    Procedure OnFindVersionRecord
94294>>>        // Open MyTable
94294>>>        // Move xx to MyTable.Field1
94294>>>        // Move yy to MyTable.Field2
94294>>>        // Find le MyTable by Index.x
94294>>>    End_Procedure
94295>>>
94295>>>    // Hook event for writing header error text (pre-update) to
94295>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94295>>>    // Don't forget to Open the table first (!) as all
94295>>>    // tables have been closed at this stage.
94295>>>    // The start date & time is passed.
94295>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94297>>>    End_Procedure
94298>>>
94298>>>    // Hook event to log errors to a database table.
94298>>>    // Only called if the pbUseDataTableLog = True.
94298>>>    // Don't forget to Open the table first (!) as all
94298>>>    // tables have been closed at this stage.
94298>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94298>>>    // will contain just one row, as it is called for each error
94298>>>    // that occurred. Else it is called once at the end after all updates
94298>>>    // have run and contains all errors.
94298>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94300>>>    End_Procedure
94301>>>
94301>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94301>>>    Procedure Cleanup
94303>>>        Boolean bDatabaseWasUpdated bError
94303>>>
94303>>>        Send CheckAutoCreateDbVersionTable
94304>>>        Send RestoreOpenTables
94305>>>
94305>>>        // The function library have two purposes; one is to use it in the
94305>>>        // Database Update Framework, but it can also be used on its own.
94305>>>        // If that is the case it has its own error handling system, which
94305>>>        // we temporarily disbled when running updates because we have
94305>>>        // error handling/logging here too... We now restore its setting.
94305>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94307>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94308>>>        End
94308>>>>
94308>>>        Set pbHandleQueryErrors to True
94309>>>
94309>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94310>>>        Get pbDbUpdateErrorHasOccured to bError
94311>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94313>>>
94313>>>            // We should always create the log as it also contains info about
94313>>>            // the update being successful.
94313>>>            Send WriteErrorLog of (phoLogFile(Self))
94314>>>
94314>>>            // This is a programmer's hook message:
94314>>>            Send OnPostUpdate
94315>>>
94315>>>            Send Stop_StatusPanel of ghoStatusPanel
94316>>>
94316>>>            If (pbSilentMode(Self) = False) Begin
94318>>>                If (bError = True) Begin
94320>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94322>>>                        Send ShowErrorLog of (phoLogFile(Self))
94323>>>                    End
94323>>>>
94323>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94324>>>                    Send Exit_Application
94325>>>                End
94325>>>>
94325>>>                Else Begin
94326>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94328>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94329>>>                    End
94329>>>>
94329>>>                    Else Begin
94330>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94331>>>                    End
94331>>>>
94331>>>
94331>>>                End
94331>>>>
94331>>>            End
94331>>>>
94331>>>        End
94331>>>>
94331>>>
94331>>>        // Restore the standard error handler:
94331>>>        Get piOrgErrorHandlerID to Error_Object_Id
94332>>>    End_Procedure
94333>>>
94333>>>    // We do this _before_ we close the database to make changes, and save
94333>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94333>>>    // we reopen the database.
94333>>>    Procedure SaveOpenTables
94335>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94335>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94336>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94337>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94338>>>    End_Procedure
94339>>>
94339>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94339>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94339>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94341>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94341>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94342>>>        Integer hTable iMasterAliasType iSize
94342>>>        Boolean bOpen
94342>>>
94342>>>        Move 0 to hTable
94343>>>        Repeat
94343>>>>
94343>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94346>>>            If (hTable <> 0) Begin
94348>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94351>>>                If (bOpen = True) Begin
94353>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94356>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94357>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94358>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94359>>>                End
94359>>>>
94359>>>            End
94359>>>>
94359>>>        Until (hTable = 0)
94361>>>
94361>>>        Function_Return aDbUpdateHandlerMasterAlias
94362>>>    End_Function
94363>>>
94363>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94363>>>    // Takes one parameter:
94363>>>    //   A struct array with all master & alias
94363>>>    Procedure RestoreOpenTables
94365>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94365>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94366>>>        Integer hTable iFileAlias iSize iCount
94366>>>        Boolean bOpen
94366>>>        String sRootName
94366>>>
94366>>>        Move 0 to hTable
94367>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94368>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94369>>>        Decrement iSize
94370>>>        For iCount from 0 to iSize
94376>>>>
94376>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94377>>>            // We also need to check that the table hasn't been removed...
94377>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94380>>>            If (hTable <> 0 and sRootName <> "") Begin
94382>>>                Open hTable
94384>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94387>>>                If (bOpen = True) Begin
94389>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94390>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94392>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94395>>>                    End
94395>>>>
94395>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94398>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94401>>>                    End
94401>>>>
94401>>>                End
94401>>>>
94401>>>            End
94401>>>>
94401>>>        Loop
94402>>>>
94402>>>    End_Procedure
94403>>>
94403>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94403>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94403>>>    Procedure CheckForDuplicates Number nVersion
94405>>>        tDbVersionInfo[] DbVersionInfoArray
94405>>>        tDbVersionInfo[] DbVersionInfoArray
94406>>>        Integer iCount iSize iHits iDuplicateIndex
94406>>>        Number nCompare
94406>>>        Handle hObject1 hObject2
94406>>>        String sObjectName1 sObjectName2
94406>>>        Boolean bObjectOrderError
94406>>>
94406>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94407>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94408>>>        Decrement iSize
94409>>>        Move 0 to iHits
94410>>>        Move 0 to nCompare
94411>>>        Move False to bObjectOrderError
94412>>>        For iCount from 0 to iSize
94418>>>>
94418>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94420>>>                Increment iHits
94421>>>                If (iHits > 1) Begin
94423>>>                    Move iCount to iDuplicateIndex
94424>>>                    If (nCompare <> 0) Begin
94426>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94427>>>                    End
94427>>>>
94427>>>                End
94427>>>>
94427>>>            End
94427>>>>
94427>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94428>>>        Loop
94429>>>>
94429>>>        If (iHits > 1) Begin
94431>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94432>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94433>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94434>>>            Move (Name(hObject1)) to sObjectName1
94435>>>            Move (Name(hObject2)) to sObjectName2
94436>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94437>>>>
94437>>>            Send Exit_Application
94438>>>        End
94438>>>>
94438>>>        Else If (bObjectOrderError = True) Begin
94441>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94442>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94443>>>>
94443>>>            Send Exit_Application
94444>>>        End
94444>>>>
94444>>>    End_Procedure
94445>>>
94445>>>    // We take care of all errors in the Error_Report below and
94445>>>    // collect them all to an array property. So just ignore any
94445>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94445>>>    // in some other package.
94445>>>    Procedure Ignore_Error Integer iError
94447>>>    End_Procedure
94448>>>
94448>>>    Procedure Trap_Error Integer iError
94450>>>    End_Procedure
94451>>>
94451>>>    // Build complete error description from Flexerrs and user error message.
94451>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94453>>>        String Full_Error_Text
94453>>>        
94453>>>        Move (Trim(ErrMsg)) to ErrMsg
94454>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94455>>>        
94455>>>        If (ErrMsg <> "") Begin
94457>>>            
94457>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94459>>>                // Make sure last character of error text is a separating symbol.
94459>>>                // if not, add a "." So we have format of "error-text. error-detail"
94459>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
94462>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
94463>>>            End
94463>>>>
94463>>>            Else ;                Move ErrMsg to Full_Error_Text
94465>>>            
94465>>>        End
94465>>>>
94465>>>        
94465>>>        Function_Return Full_Error_Text
94466>>>    End_Function
94467>>>
94467>>>    // While we update the database we collect all errors in
94467>>>    // the struct array paDbUpdateErrorArray.
94467>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94469>>>        Number nVersion
94469>>>        Handle hoLogFile 
94469>>>//        String sErrExtraText
94469>>>        
94469>>>        If (Private.pbProcessingError(Self)) Begin
94471>>>            Procedure_Return
94472>>>        End
94472>>>>
94472>>>
94472>>>        // The UtilTableNameFromHandleToString function does a:
94472>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
94472>>>        // and it generates an error if the table is of the embedded type.
94472>>>        // As we don't want to trigger an error in that very specific case,
94472>>>        // we just ignore it here.
94472>>>        //
94472>>>        // If no report mode, just set the err indicator to true.
94472>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
94474>>>            Move False to Err
94475>>>            Procedure_Return
94476>>>        End
94476>>>>
94476>>>
94476>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
94478>>>            Procedure_Return
94479>>>        End
94479>>>>
94479>>>
94479>>>        Set Private.pbProcessingError to True
94480>>>        Set Private.pbUpdateVersionObjectError to True
94481>>>
94481>>>        Set pbDbUpdateErrorHasOccured to True
94482>>>        Get pnCurrentVersionUpdate to nVersion
94483>>>        Get phoLogFile to hoLogFile
94484>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
94485>>>
94485>>>        Set Private.pbProcessingError to False
94486>>>    End_Procedure
94487>>>
94487>>>End_Class
94488>Use vWin32fh.pkg
94488>Use cDbUpdateVersion.pkg
94488>
94488>Object oHtmlHelp is a cHtmlHelp
94490>    Set pbAlwaysOnTop to False
94491>End_Object
94492>
94492>Define CS_PropertiesKeyWord     for "Properties"
94492>Define CS_ThemeKeyWord          for "Theme"
94492>
94492>
94492>Object oApplication is a cApplication
94494>    Set psCompany to "RDC Tools International"
94495>    Set psProduct to "DUF - Code Generator"
94496>    Set peHelpType to htHtmlHelp
94497>    // Note: The help file settings gets changed by the Help toolbar button(s).
94497>    Set psHelpFile to "Developer5.chm"
94498>
94498>    Property Handle phoDbUpdateHandler 0
94500>    Property Handle phoTableDUFCodeGenerator_vw 0
94502>    Property String private.psFilelistFromOrg ""
94504>    Property String psFilelistFrom ""
94506>    Property Integer[] piaDifferences
94508>    Property String psOrgOpenPath ""
94510>
94510>    Property String psCompileDateAndTime
94512>    // This is used by the About object to display the compile date & time:
94512>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
94512>    
94512>    Function psWorkspaceHomePath Returns String
94515>        String sPath 
94515>        Get psHome of (phoWorkspace(Self)) to sPath
94516>        Function_Return sPath
94517>    End_Function
94518>
94518>    // Set psOrgOpenPath at startup
94518>    Procedure Save_DF_OPEN_PATH
94521>        String sOrgOpenPath sDataPath sFileListPath
94521>        
94521>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListPath
94522>        Set private.psFilelistFromOrg to sFileListPath
94523>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
94526>        // First remove the current Data folder path
94526>        Get PathAtIndex of (phoWorkspace(Self)) sOrgOpenPath 1 to sDataPath
94527>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
94528>        If (Left(sOrgOpenPath, 2) = "\;") Begin
94530>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
94531>        End
94531>        Set psOrgOpenPath to sOrgOpenPath
94532>    End_Procedure
94533>
94533>    Procedure OnWorkspaceOpened
94536>        Forward Send OnWorkspaceOpened
94538>        Send Save_DF_OPEN_PATH
94539>    End_Procedure
94540>
94540>    Procedure Restore_DF_OPEN_PATH
94543>        String sOrgOpenpath
94543>        Get psOrgOpenPath to sOrgOpenpath
94544>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
94547>    End_Procedure
94548>
94548>    Procedure ResetFilelistPathing
94551>        String sDriverID sServer sFileList sDataPath
94551>        Send Restore_DF_OPEN_PATH
94552>        Close DF_ALL DF_PERMANENT
94553>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
94554>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer  
94555>        If (sDriverID <> "") Begin
94557>            Logout sDriverID sServer
94558>        End
94558>        Set psDriverID of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
94559>        Set psServer   of ghoDbUpdateFunctionLibrary to ""
94560>        Get private.psFilelistFromOrg to sFileList
94561>        Get ParseFolderName sFileList                      to sDataPath
94562>        If (Right(sDataPath, 1) = "\") Begin
94564>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
94565>        End
94565>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
94566>        Set psFileList of (phoWorkspace(Self))  to sFileList
94567>        Set_Attribute DF_FILELIST_NAME          to sFileList
94570>    End_Procedure
94571>
94571>    Function ChangeFilelistPathing String sFileList Returns Boolean
94574>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
94574>        Boolean bExists bEmbedded bIsSQLDriver bErr
94574>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile
94574>        tSQLConnection SQLConnection
94574>        tSQLConnection SQLConnection
94574>        Integer iRetval iDriverID
94574>
94574>        Move False to Err
94575>        Move (Trim(sFileList)) to sFileList
94576>        Get vFilePathExists sFileList to bExists
94577>        If (bExists = False) Begin
94579>            Send Info_Box "Can't find Filelist.cfg"
94580>            Function_Return False
94581>        End
94581>
94581>        Send Cursor_Wait of Cursor_Control
94582>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
94583>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
94584>        Send Restore_DF_OPEN_PATH
94585>        Close DF_ALL DF_PERMANENT
94586>        Logout sDriverID sServer
94587>
94587>        Get ParseFolderName sFileList                      to sDataPath
94588>        If (Right(sDataPath, 1) = "\") Begin
94590>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
94591>        End
94591>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
94592>        Set psFileList of (phoWorkspace(Self))  to sFileList
94593>
94593>        // Temporarily "redirect" the Open path to the current Data folder
94593>        Get psOrgOpenPath to sOrgOpenPath
94594>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
94597>        Set_Attribute DF_FILELIST_NAME to sFileList
94600>        Get UtilIsAnyFilelistEntrySQLtable of ghoDbUpdateFunctionLibrary to sDriverID
94601>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bIsSQLDriver
94602>        
94602>        // If none of the tables in the Filelist.cfg are SQL, we're done. Let's get out of here!
94602>        If (bIsSQLDriver = False) Begin
94604>            Send Cursor_Ready of Cursor_Control
94605>            Function_Return True
94606>        End
94606>
94606>        // Note: We delete all cache files (*.cch) before attempting to open any
94606>        // tables as a precausion, in case a table has been changed at the SQL back-end,
94606>        // because then the .cch file is out-of-sync with the SQL table.
94606>        Get DriverIndex of ghoDbUpdateFunctionLibrary sDriverID to iDriverID
94607>        Move Err to bErr 
94608>        Send Ignore_Error of Error_Object_Id DFERR_OPERATION_NOT_ALLOWED
94609>        Get_Attribute DF_DRIVER_CACHE_PATH of iDriverID to sPath
94612>        If (sPath = "") Begin 
94614>            If (LastErr = DFERR_OPERATION_NOT_ALLOWED and bErr = False) Begin
94616>                Move False to Err
94617>            End
94617>            Move sDataPath to sPath
94618>        End
94618>        Get vFolderFormat sPath to sPath
94619>        Get vDeleteFile (sPath + "*.cch") to iRetval
94620>
94620>        // Try to make a database connection by reading the SQLConnections.ini file:
94620>        Get vFolderFormat sDataPath to sPath
94621>        Get vParentPath sDataPath   to sPath
94622>        Get vFolderFormat sPath     to sPath
94623>        Move (sPath + "Programs")   to sPath
94624>        Get vFolderFormat sPath     to sPath
94625>        Move CS_SQLIniFileName to sSQLConnectionsIniName
94626>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
94627>        If (bExists = False) Begin
94629>            Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bEmbedded
94630>            If (bEmbedded = False) Begin
94632>                Send Cursor_Ready of Cursor_Control
94633>                Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
94634>                If (iRetval = MBR_Yes) Begin
94636>                    Send Cursor_Wait of Cursor_Control
94637>                    Move "DFConnId.ini" to sSQLConnectionsIniName
94638>                        Send UnRegisterAllConnections of ghoConnection
94639>                        Get AddAllConnections of ghoConnection to bExists
94640>                        Set psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsIniName
94641>                        Set psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
94642>                        Get SetupSQLConnection of ghoSQLConnectionHandler True False to SQLConnection
94643>                End
94643>            End
94643>        End
94643>        Else Begin
94644>            Get phoDbUpdateHandler to hoDbUpdateHandler
94645>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
94646>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
94647>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
94648>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
94649>
94649>            Get SetupSQLConnection of hoSQLConnectionHandler True True to SQLConnection
94650>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection
94651>        End
94651>
94651>        Send Cursor_Ready of Cursor_Control
94652>        Function_Return (Err = False)
94653>    End_Function
94654>
94654>    Object oConnection is a cConnection
94656>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\LoginEncryption.pkg)
94656>>>Use cLoginEncryption.pkg
94656>>>
94656>>>Object oLoginEncryption is a cLoginEncryption
94658>>>
94658>>>    // this must be created in your appsrc directory and must contain an encryption
94658>>>    // key that is set to psEncryptPassword. It will look something like this
94658>>>    //
94658>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
94658>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
94658>>>>// Studio generated login encryption key
94658>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
94659>>>>
94659>>>    
94659>>>    // use this to register this object to your cConnection Object. This object
94659>>>    // must be created after the cConnection object
94659>>>    Move Self to ghoLoginEncryption
94660>>>End_Object
94661>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 23.0\Pkg\DatabaseLoginDialog.dg)
94661>>>
94661>>>Use Windows.pkg
94661>>>Use cConnection.pkg
94661>>>Use dfLine.pkg
94661>>>
94661>>>Object oDatabaseLoginDialog is a ModalPanel
94663>>>    Set Label to "Database Login"
94664>>>    Set Location to 2 2
94665>>>    Set Size to 110 211
94666>>>    
94666>>>    Property String psId
94668>>>    Property Boolean pbOk False
94670>>>    Property Boolean pbChanged False
94672>>>    Property Boolean pbAllowRemember True
94674>>>    
94674>>>    // this registers this object with the cConnection object.
94674>>>    Move Self to ghoLoginConnectDialog
94675>>>    
94675>>>    Object oUserIDForm is a Form
94677>>>        Set Label to "User Name"
94678>>>        Set Size to 12 85
94679>>>        Set Location to 34 79
94680>>>        Set Label_Col_Offset to 64
94681>>>        Set peAnchors to anTopLeftRight
94682>>>    End_Object
94683>>>    
94683>>>    Object oPwdForm is a Form
94685>>>        Set Size to 12 85
94686>>>        Set Location to 49 79
94687>>>        Set Label_Col_Offset to 64
94688>>>        Set Password_State to True
94689>>>        Set peAnchors to anTopLeftRight
94690>>>        Set Label to "Password"
94691>>>    End_Object
94692>>>    
94692>>>    Object oTrustedConnection is a CheckBox
94694>>>        Set Size to 10 50
94695>>>        Set Location to 65 79
94696>>>        Set Label to "Trusted Connection"
94697>>>    End_Object
94698>>>    
94698>>>    Object oRemember is a CheckBox
94700>>>        Set Size to 10 50
94701>>>        Set Location to 79 14
94702>>>        Set Label to "Remember and don't ask again"
94703>>>        Set Checked_State to True
94704>>>    End_Object
94705>>>    
94705>>>    Object oLogin_btn is a Button
94707>>>        Set Label to "&Login"
94708>>>        Set Location to 92 102
94709>>>        Set peAnchors to anBottomRight
94710>>>        Set Default_State to True
94711>>>        
94711>>>        Procedure OnClick
94714>>>            Boolean bTrust
94714>>>            String sUser sPwd sConn sErr sId
94714>>>            Integer iError
94714>>>            Get psId to sId
94715>>>            Get Value of oUserIDForm to sUser
94716>>>            Get Value of oPwdForm to sPwd
94717>>>            Get Checked_State of oTrustedConnection to bTrust
94718>>>            
94718>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
94719>>>            If (iError=0) Begin
94721>>>                Set pbOk to True
94722>>>                Set pbChanged to True
94723>>>                Send Close_Panel
94724>>>            End
94724>>>>
94724>>>            Else Begin
94725>>>                Get psErrorText of ghoConnection to sErr
94726>>>                Send UserError sErr "Login Error"
94727>>>            End
94727>>>>
94727>>>        End_Procedure
94728>>>    End_Object
94729>>>    
94729>>>    Object oCancel_btn is a Button
94731>>>        Set Label to "&Cancel"
94732>>>        Set Location to 92 157
94733>>>        Set peAnchors to anBottomRight
94734>>>        
94734>>>        Procedure OnClick
94737>>>            Send Close_Panel
94738>>>        End_Procedure
94739>>>    End_Object
94740>>>    
94740>>>    Object oConnectionIdInfo is a TextBox
94742>>>        Set Size to 10 50
94743>>>        Set Location to 4 14
94744>>>        Set Label to 'Connection Id='
94745>>>    End_Object
94746>>>    
94746>>>    Object oConnectionServerInfo is a TextBox
94748>>>        Set Size to 10 50
94749>>>        Set Location to 16 14
94750>>>        Set Label to 'Server'
94751>>>    End_Object
94752>>>    
94752>>>    Object oLineControl1 is a LineControl
94754>>>        Set Size to 2 202
94755>>>        Set Location to 29 5
94756>>>    End_Object
94757>>>    
94757>>>    Function LoginConnectIdDialog String sId Returns Boolean
94760>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
94760>>>        String sUser sPwd sDescription
94760>>>        tConnection Connect
94760>>>        tConnection Connect
94760>>>        
94760>>>        Get pbAllowRemember to bAllowRemember
94761>>>        
94761>>>        
94761>>>        If not bAllowRemember Begin
94763>>>            Set Enabled_State of oRemember to bRemember
94764>>>            Set Visible_State of oRemember to bRemember
94765>>>        End
94765>>>>
94765>>>        
94765>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
94766>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
94767>>>        Set Value of oConnectionServerInfo to Connect.sString
94768>>>        
94768>>>        Set psId to sId
94769>>>        Set pbOk to False
94770>>>        Set pbChanged to False
94771>>>        Set Value of oUserIDForm to Connect.sUID
94772>>>        Set Value of oPwdForm to ""
94773>>>        
94773>>>        Send Popup
94774>>>        
94774>>>        Get pbOk to bOk
94775>>>        Get pbChanged to bChanged
94776>>>        If (bChanged and bOk) Begin
94778>>>            If bAllowRemember Begin
94780>>>                Get Checked_State of oRemember to bRemember
94781>>>                If bRemember Begin
94783>>>                    Get Checked_State of oTrustedConnection to bTrusted
94784>>>                    If not (bTrusted) Begin
94786>>>                        Get Value of oUserIDForm to sUser
94787>>>                        Get Value of oPwdForm to sPwd
94788>>>                    End
94788>>>>
94788>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
94789>>>                End
94789>>>>
94789>>>            End
94789>>>>
94789>>>        End
94789>>>>
94789>>>        Function_Return bOk
94790>>>    End_Function
94791>>>    
94791>>>    
94791>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
94792>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
94793>>>End_Object
94794>>>
94794>    End_Object
94795>
94795>    Procedure End_Construct_Object
94798>        String sCompileTime  
94798>        Integer iPos
94798>        
94798>        Forward Send End_Construct_Object
94800>        Direct_Input "resource: res_CompileHeader"
94801>        Readln sCompileTime
94802>        Move (Pos('"', sCompileTime)) to iPos
94803>        If (iPos <> 0) Begin
94805>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
94806>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
94807>            Set psCompileDateAndTime to sCompileTime
94808>        End
94808>        Close_Input
94809>    End_Procedure
94810>
94810>End_Object
94811>
94811>Object oDbUpdateHandler is a cDbUpdateHandler
94813>    Set piDbVersionFileNumber  to 1
94814>    Set piDbVersionFieldNumber to 1
94815>    Set phoDbUpdateHandler of ghoApplication to Self
94816>
94816>    Procedure OnPreUpdate
94819>        String sVersionInfo                     // DF 18.2 MSSQLDRV
94819>//        Get MinMSSQLDRV_And_ClientVersion "6.1.0.32"  SQLSERVER2012CLIENT True True to sVersionInfo
94819>                                                // DF 19.1 MSSQLDRV
94819>        Get MinMSSQLDRV_And_ClientVersion "6.3.0.13" SQLSERVER2016CLIENT True True to sVersionInfo
94820>    End_Procedure  
94821>
94821>    Object oDbUpdateVersion1_0 is a cDbUpdateVersion
94823>        Set pnVersionNumber to 1.0
94824>//        Procedure OnUpdate
94824>//            Boolean bOK 
94824>//        End_Procedure
94824>    End_Object
94825>
94825>End_Object
94826>
94826>Object oToolTipController is a cToolTipController
94828>    Move Self to ghoToolTipController
94829>    Set pbBalloonStyle to False
94830>    Set piIcon to TTI_INFO
94831>    Set psTitle to "Information"
94832>    Set piMaxWidth to 400
94833>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
94834>End_Object
94835>
94835>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oEditContextMenu.pkg)
94835>>>Use cCJStandardMenuItemClasses.pkg
94835>>>
94835>>>Object oEditContextMenu is a cCJContextMenu
94837>>>    
94837>>>    Move Self to Default_Form_Floating_Menu_ID
94838>>>    
94838>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94840>>>    End_Object
94841>>>    
94841>>>    Object oCutMenuItem is a cCJCutMenuItem
94843>>>        Set pbControlBeginGroup to True
94844>>>    End_Object
94845>>>    
94845>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94847>>>    End_Object
94848>>>
94848>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94850>>>    End_Object
94851>>>
94851>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94853>>>    End_Object
94854>>>
94854>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94856>>>        Set pbControlBeginGroup to True
94857>>>    End_Object
94858>>>
94858>>>End_Object
94859>>>
94859>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oDEOEditContextMenu17.pkg)
94859>>>Use Windows.pkg
94859>>>Use cCJStandardMenuItemClasses.pkg
94859>>>Use cCJDeoMenuItemClasses.pkg
94859>>>
94859>>>
94859>>>Object oDEOEditContextMenu17 is a cCJContextMenu
94861>>>    
94861>>>    Move Self to Default_dbFloating_Menu_ID
94862>>>    
94862>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94864>>>    End_Object
94865>>>    
94865>>>    Object oCutMenuItem is a cCJCutMenuItem
94867>>>        Set pbControlBeginGroup to True
94868>>>    End_Object
94869>>>    
94869>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94871>>>    End_Object
94872>>>
94872>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94874>>>    End_Object
94875>>>
94875>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94877>>>    End_Object
94878>>>
94878>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94880>>>        Set pbControlBeginGroup to True
94881>>>    End_Object
94882>>>
94882>>>    Object oPromptMenuItem is a cCJPromptMenuItem
94884>>>        Set pbControlBeginGroup to True
94885>>>    End_Object
94886>>>
94886>>>    Object oFindNextMenu is a cCJFindNextMenuItem
94888>>>        Set pbControlBeginGroup to True
94889>>>    End_Object
94890>>>
94890>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
94892>>>    End_Object
94893>>>
94893>>>    Object oClearMenuItem is a cCJClearMenuItem
94895>>>        Set pbControlBeginGroup to True
94896>>>    End_Object
94897>>>
94897>>>    Object oClearAllMenu is a cCJClearAllMenuItem
94899>>>    End_Object
94900>>>
94900>>>    Object oSaveMenu is a cCJSaveMenuItem
94902>>>    End_Object
94903>>>    
94903>>>    Object oDeleteMenu is a cCJDeleteMenuItem
94905>>>    End_Object
94906>>>
94906>>>    Object oRememberitem is a cCJRememberFieldMenuItem
94908>>>        Set pbControlBeginGroup to True
94909>>>    End_Object
94910>>>
94910>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
94912>>>    End_Object
94913>>>
94913>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
94915>>>    End_Object
94916>>>
94916>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
94918>>>    End_Object
94919>>>
94919>>>End_Object
94920>Use CaptureWindow.pkg
Including file: CaptureWindow.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\CaptureWindow.pkg)
94920>>>Use CaptureWindow.h
Including file: CaptureWindow.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\CaptureWindow.h)
94920>>>>>Define C_CaptureFolderKey  for "CaptureFolder"
94920>>>>>Define C_CaptureFolderName for "Capture"
94920>>>>>Define SRCCOPY           for |CI$00CC0020
94920>>>>>Define CF_BITMAP         for |CI2
94920>>>>>
94920>>>>>Enum_List   //Enum DEVCAP_INDEX As Integer  
94920>>>>>    Define DRIVERVERSION for 0 
94920>>>>>    Define TECHNOLOGY for 2 
94920>>>>>    Define HORZSIZE for 4 
94920>>>>>    Define VERTSIZE for 6 
94920>>>>>    Define HORZRES for 8 
94920>>>>>    Define VERTRES for 10 
94920>>>>>    Define BITSPIXEL for 12 
94920>>>>>    Define PLANES for 14 
94920>>>>>    Define NUMBRUSHES for 16 
94920>>>>>    Define NUMPENS for 18 
94920>>>>>    Define NUMMARKERS for 20 
94920>>>>>    Define NUMFONTS for 22 
94920>>>>>    Define NUMCOLORS for 24 
94920>>>>>    Define PDEVICESIZE for 26 
94920>>>>>    Define CURVECAPS for 28 
94920>>>>>    Define LINECAPS for 30 
94920>>>>>    Define POLYGONALCAPS for 32 
94920>>>>>    Define TEXTCAPS for 34 
94920>>>>>    Define CLIPCAPS for 36 
94920>>>>>    Define RASTERCAPS for 38 
94920>>>>>    Define ASPECTX for 40 
94920>>>>>    Define ASPECTY for 42 
94920>>>>>    Define ASPECTXY for 44 
94920>>>>>    Define SHADEBLENDCAPS for 45 
94920>>>>>    Define SIZEPALETTE for 104 
94920>>>>>    Define NUMRESERVED for 106 
94920>>>>>    Define COLORRES for 108 
94920>>>>>    Define PHYSICALWIDTH for 110 
94920>>>>>    Define PHYSICALHEIGHT for 111 
94920>>>>>    Define PHYSICALOFFSETX for 112 
94920>>>>>    Define PHYSICALOFFSETY for 113 
94920>>>>>    Define SCALINGFACTORX for 114 
94920>>>>>    Define SCALINGFACTORY for 115 
94920>>>>>    Define VREFRESH for 116 
94920>>>>>    Define DESKTOPVERTRES for 117 
94920>>>>>    Define DESKTOPHORZRES for 118 
94920>>>>>    Define BLTALIGNMENT for 119 
94920>>>>>End_Enum_List  
94920>>>>>
94920>>>>>Enum_List   //Enum compression
94920>>>>>    Define bi_rgb for 0       //- none (also identified by bi_rgb)
94920>>>>>    Define bi_rle4 for 1      //- rle 8-bit / pixel (also identified by bi_rle4)
94920>>>>>    Define bi_rle8 for 2      //- rle 4-bit / pixel (also identified by bi_rle8)
94920>>>>>    Define bi_bitfields for 3 //- bitfields (also identified by bi_bitfields)
94920>>>>>End_Enum_List  
94920>>>>>
94920>>>>>
94920>>>>>
94920>>>>>Define DIB_PAL_COLORS for 1
94920>>>>>Define DIB_RGB_COLORS for 0
94920>>>>>
94920>>>>>Struct RECT_TYPE
94920>>>>>   Integer ileft
94920>>>>>   Integer itop
94920>>>>>   Integer iright
94920>>>>>   Integer ibottom
94920>>>>>End_Struct
94920>>>>>
94920>>>>>Struct BITMAPINFOHEADER
94920>>>>>    DWord biSize                    // DWORD=integer
94920>>>>>    Integer biWidth                    // LONG =integer
94920>>>>>    Integer biHeight                   // LONG 
94920>>>>>    Short biPlanes                   // WORD =short
94920>>>>>    Short biBitCount                 // WORD 
94920>>>>>    DWord biCompression             // DWORD
94920>>>>>    DWord biSizeImage               // DWORD
94920>>>>>    Integer biXPelsPerMeter            // LONG 
94920>>>>>    Integer biYPelsPerMeter            // LONG 
94920>>>>>    DWord biClrUsed                 // DWORD
94920>>>>>    DWord biClrImportant            // DWORD
94920>>>>>End_Struct
94920>>>>>
94920>>>>>Struct RGBQUAD
94920>>>>>  CHAR rgbBlue            //BYTE=CHAR
94920>>>>>  CHAR rgbGreen
94920>>>>>  CHAR rgbRed
94920>>>>>  CHAR rgbReserved
94920>>>>>End_Struct
94920>>>>>
94920>>>>>Struct BITMAPINFO 
94920>>>>>    BITMAPINFOHEADER bmiHeader 
94920>>>>>    BITMAPINFOHEADER bmiHeader 
94920>>>>>    RGBQUAD[] bmiColors
94920>>>>>    RGBQUAD[] bmiColors
94920>>>>>End_Struct
94920>>>>>
94920>>>>>Struct BITMAPFILEHEADER
94920>>>>>    Short bfType         //WORD  //BM (0x4D42)
94920>>>>>    DWord bfSize        //DWORD
94920>>>>>    Short bfReserved1    //WORD 
94920>>>>>    Short bfReserved2    //WORD 
94920>>>>>    DWord bfOffBits     //DWORD
94920>>>>>End_Struct
94920>>>>>
94920>>>>>Struct BITMAP 
94920>>>>>    Integer   bmType
94920>>>>>    Integer   bmWidth
94920>>>>>    Integer   bmHeight
94920>>>>>    Integer   bmWidthBytes
94920>>>>>    Short   bmPlanes
94920>>>>>    Short   bmBitsPixel
94920>>>>>    Pointer bmBits
94920>>>>>end_struct
94920>>>>>
94920>>>>>Struct DIBSECTION 
94920>>>>>    BITMAP           dsBm
94920>>>>>    BITMAP           dsBm
94920>>>>>    BITMAPINFOHEADER dsBmih
94920>>>>>    BITMAPINFOHEADER dsBmih
94920>>>>>    DWord[3]         dsBitfields
94920>>>>>  Handle           dshSection
94920>>>>>  DWord            dsOffset
94920>>>>>End_Struct
94920>>>Use vWin32fh.pkg
94920>>>Use cApplication.pkg
94920>>>Use cIniFile.pkg
94920>>>
94920>>>Define CS_CaptureSection for "Capture"
94920>>>Define CS_CaptureFolder  for "Capture Folder"
94920>>>
94920>>>//   Declare Function GetActiveWindow% Lib "User" ()
94920>>>External_Function GetActiveWindow "GetActiveWindow" User32.dll ;    Returns Handle
94921>>>
94921>>>//   Declare Function GetDesktopWindow% Lib "User" ()
94921>>>
94921>>>//   Declare Sub GetWindowRect Lib "User" (ByVal Hwnd%, lpRect As RECT_Type)
94921>>>
94921>>>//   Declare Function GetDC% Lib "User" (ByVal Hwnd%)
94921>>>
94921>>>//   Declare Function CreateCompatibleDC% Lib "GDI" (ByVal hdc%)
94921>>>
94921>>>//   Declare Function CreateCompatibleBitmap% Lib "GDI" (ByVal hdc%, ByVal nWidth%, ByVal nHeight%)
94921>>>
94921>>>//   Declare Function SelectObject% Lib "GDI" (ByVal hdc%, ByVal hObject%)
94921>>>
94921>>>//   Declare Function BitBlt% Lib "GDI" (ByVal hDestDC%, ByVal X%, ByVal Y%, ByVal nWidth%, ;
94921>>>//                     ByVal nHeight%, ByVal hSrcDC%, ByVal XSrc%, ByVal YSrc%, ByVal dwRop&)
94921>>>
94921>>>//   Declare Function OpenClipboard% Lib "User" (ByVal Hwnd%)
94921>>>External_Function OpenClipboard "OpenClipboard" User32.dll  ;    Handle hWnd  Returns Integer
94922>>>
94922>>>//   Declare Function EmptyClipboard% Lib "User" ()
94922>>>External_Function EmptyClipboard "EmptyClipboard" User32.dll ;    Returns Integer
94923>>>
94923>>>//   Declare Function SetClipboardData% Lib "User" (ByVal wFormat%, ByVal hMem%)
94923>>>External_Function SetClipboardData "SetClipboardData" User32.dll ;    Integer wFormat Handle hMem Returns Integer
94924>>>
94924>>>//   Declare Function CloseClipboard% Lib "User" ()
94924>>>External_Function CloseClipboard "CloseClipboard" User32.dll ;    Returns Integer
94925>>>
94925>>>//   Declare Function ReleaseDC% Lib "User" (ByVal Hwnd%, ByVal hdc%)
94925>>>
94925>>>//   Declare Function DeleteDC% Lib "GDI" (ByVal hdc%)
94925>>>
94925>>>    External_Function CreateDIBSection "CreateDIBSection" Gdi32.dll ;        Handle hdc ;     // Handle to the device context        pointer pbmi ; //puntero a BITMAPINFO        UInteger iUsage ;        Pointer ppvBits ;        Handle hSection ;        DWord dwOffset ;        Returns Handle // HBITMAP
94926>>>
94926>>>    External_Function GetDIBits "GetDIBits" Gdi32.dll ;        handle hdc ;        handle hbmp ;        Uinteger uStartScan ;        uinteger cScanLines ;        pointer lpvBits ;        pointer lpbi ;  // LPBITMAPINFO        uinteger uUsage ;        Returns Integer
94927>>>
94927>>>External_Function Createfile "CreateFileA" kernel32.dll ;    Pointer lpFile ;      //filename    DWord dwDesAccess ;   // access mode    DWord dwShare ;       // share mode    Pointer lpSecAtt ;    // SD    DWord dwCrDisp ;      // how to create    DWord dwFlags ;       // file attributes    Handle hTempFile ;   // handle to template fil    Returns Integer      //Returns handle that can be used to access the object
94928>>>
94928>>>    External_Function WriteFile "WriteFile" Kernel32.dll ;        Handle hFile ;     // Handle to the file        Pointer lpBuffer ;  // data buffer        DWord nNumberOfBytesToWrite ;        Pointer lpNumberOfBytesWritten ;        Pointer lpOverlapped ;        Returns Boolean
94929>>>
94929>>>External_Function CloseHandle "CloseHandle" kernel32.dll ;    Handle hObject ;        // handle to object    Returns Integer
94930>>>
94930>>>
94930>>>     External_Function GetDIBColorTable "GetDIBColorTable" Gdi32.dll ;        handle hdc ;        uinteger uStartIndex ;        uinteger cEntries ;        pointer pColors ;        Returns Integer
94931>>>
94931>>>     External_Function GetObject "GetObjectA" Gdi32.dll ;        handle hgdiobj ;        integer cbBuffer ;        pointer lpvObject ;        Returns Integer
94932>>>
94932>>>
94932>>>// Check if focus is what you search or a child of it
94932>>>Function Find_Parent Global Handle hofocus Handle hofind Returns Boolean
94934>>>    If (hoFocus = hoFind) Begin
94936>>>        Function_Return True
94937>>>    End
94937>>>>
94937>>>   While (hofocus>Desktop)
94941>>>        If (Parent(hoFocus) = hoFind) Begin
94943>>>            Function_Return True
94944>>>        End
94944>>>>
94944>>>      Move (Parent(hofocus)) to hofocus
94945>>>   Loop
94946>>>>
94946>>>   Function_Return False
94947>>>End_Function
94948>>>
94948>>>// Returns the view object (outmost container) of the currently focused object.
94948>>>Function Current_View Global Returns Integer
94950>>>    Integer Obj#
94950>>>
94950>>>    Move (Focus(Self)) to Obj#
94951>>>    Repeat
94951>>>>
94951>>>        Move (Parent(Obj#)) to Obj#
94952>>>    Until (Scope_State(Obj#) = True)
94954>>>
94954>>>    Function_Return Obj#
94955>>>End_Function
94956>>>
94956>>>// Helper function. See also main message TakeSnapshot.
94956>>>// Capture an bitmap image of the current object and saves it to disk.
94956>>>Function CaptureImage Global Handle hVent String sFile Returns Integer
94958>>>    Handle hwnd deskhwnd hfile hnulo
94958>>>    Handle hdcScreen
94958>>>    Handle hdcWindow
94958>>>    Handle hdcMemDC
94958>>>    Handle hbmScreen
94958>>>    BITMAP bmpScreen
94958>>>    BITMAP bmpScreen
94958>>>    BITMAPFILEHEADER   bmfHeader
94958>>>    BITMAPFILEHEADER   bmfHeader
94958>>>    BITMAPINFOHEADER   bi
94958>>>    BITMAPINFOHEADER   bi
94958>>>    RECT_Type rcClient
94958>>>    RECT_Type rcClient
94958>>>    Integer junk fwidth fheight iret
94958>>>    DWord dwSizeofDIB dwBytesWritten dwBmpSize
94958>>>    Boolean baux
94958>>>    Pointer lpbitmap pnulo
94958>>>
94958>>>    //---------------------------------------------------
94958>>>    // Get window handle to Windows and our View
94958>>>    //---------------------------------------------------
94958>>>    Move (GetDesktopWindow()) to DeskHwnd
94959>>>    Get Window_Handle of hVent to hwnd
94960>>>
94960>>>    // Retrieve the handle to a display device context for the client
94960>>>    // area of the window.
94960>>>    Move (GetDC(hwnd)) to hdcScreen //what you want to paint (getdc(null)=full screen)
94961>>>    Move (GetDC(deskhwnd)) to hdcWindow //context = GetDC(hWnd);
94962>>>
94962>>>    // Create a compatible DC which is used in a BitBlt from the window DC
94962>>>    Move (CreateCompatibleDC(hdcWindow)) to hdcMemDC
94963>>>    Move 0 to iret
94964>>>    If (hdcMemDC) Begin
94966>>>       // Get the client area for size calculation
94966>>>       Move (GetWindowRect(hwnd,AddressOf(rcClient))) to junk
94967>>>       Move (rcClient.iright-rcClient.ileft) to fwidth
94968>>>       Move (rcClient.ibottom-rcClient.itop) to fheight
94969>>>
94969>>>       // Create a compatible bitmap from the Window DC
94969>>>       Move (CreateCompatibleBitmap(hdcWindow, fwidth, fheight)) to hbmScreen
94970>>>
94970>>>       If hbmScreen Begin
94972>>>          // Select the compatible bitmap into the compatible memory DC.
94972>>>          Move (SelectObject(hdcMemDC,hbmScreen)) to junk
94973>>>
94973>>>          // Bit block transfer into our compatible memory DC.
94973>>>          If (BitBlt(hdcMemDC,0,0, fwidth, fheight,hdcWindow, rcClient.ileft,rcClient.itop,SRCCOPY)) Begin
94975>>>             // Get the BITMAP from the HBITMAP
94975>>>             Move (GetObject(hbmScreen,SizeOfType(BITMAP),AddressOf(bmpScreen))) to junk
94976>>>             Move (SizeOfType(BITMAPINFOHEADER)) to bi.biSize
94977>>>             Move bmpScreen.bmWidth to bi.biWidth
94978>>>             Move bmpScreen.bmHeight to bi.biHeight
94979>>>             Move 1 to bi.biPlanes
94980>>>             Move 32 to bi.biBitCount
94981>>>             Move bi_rgb to bi.biCompression
94982>>>             Move 0 to bi.biSizeImage
94983>>>             Move 0 to bi.biXPelsPerMeter
94984>>>             Move 0 to bi.biYPelsPerMeter
94985>>>             Move 0 to bi.biClrUsed
94986>>>             Move 0 to bi.biClrImportant
94987>>>
94987>>>             Move (((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight ) to dwBmpSize
94988>>>             Move (Alloc(dwBmpSize+100)) to lpbitmap
94989>>>
94989>>>             // Gets the "bits" from the bitmap and copies them into a buffer
94989>>>             // which is pointed to by lpbitmap.
94989>>>             Move (GetDIBits(hdcWindow, hbmScreen, 0,bmpScreen.bmHeight, ;                 lpbitmap,AddressOf(bi), DIB_RGB_COLORS) ) to junk
94990>>>
94990>>>             // A file is created, this is where we will save the screen capture.
94990>>>             Move (CreateFile(AddressOf(sFile),GENERIC_WRITE, 0, ;                 hnulo,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, hnulo)) to hfile
94991>>>
94991>>>             // Add the size of the headers to the size of the bitmap to get the total file size
94991>>>             Move (dwBmpSize + SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to dwSizeofDIB
94992>>>
94992>>>             // Offset to where the actual bitmap bits start.
94992>>>             Move (SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to bmfHeader.bfOffBits
94993>>>
94993>>>             // Size of the file
94993>>>             Move dwSizeofDIB to bmfHeader.bfSize
94994>>>
94994>>>             // bfType must always be BM for Bitmaps
94994>>>             Move 19778 to bmfHeader.bfType //= 0x4D42; //BM   19778
94995>>>
94995>>>             Move 0 to dwBytesWritten
94996>>>             Move (WriteFile(hFile, AddressOf(bmfHeader), SizeOfType(BITMAPFILEHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
94997>>>             Move (WriteFile(hFile, AddressOf(bi), SizeOfType(BITMAPINFOHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
94998>>>             Move (WriteFile(hFile, lpbitmap, dwBmpSize, AddressOf(dwBytesWritten), pnulo))  to baux
94999>>>
94999>>>             //Close the handle for the file that was created
94999>>>             Move (CloseHandle(hFile)) to junk
95000>>>
95000>>>             // Write image from clipboard
95000>>>             Move (OpenClipboard(DeskHwnd)) to junk
95001>>>             Move (EmptyClipboard()) to junk
95002>>>             Move (SetClipboardData(CF_BITMAP,hbmScreen)) to junk
95003>>>             Move (CloseClipboard()) to junk
95004>>>
95004>>>             Move (DeleteObject(hbmScreen)) to baux
95005>>>             Move (Free(lpbitmap)) to baux
95006>>>             Move 1 to iret
95007>>>          End
95007>>>>
95007>>>       End
95007>>>>
95007>>>    End
95007>>>>
95007>>>    Move (ReleaseDC(hWnd, hdcMemDC)) to junk
95008>>>    Move (ReleaseDC(hwnd,hdcScreen)) to junk
95009>>>    Move (ReleaseDC(deskhwnd,hdcWindow)) to junk
95010>>>
95010>>>    Function_Return iret
95011>>>End_Function
95012>>>
95012>>>// *** MAIN MESSAGE ***
95012>>>// Takes a snapshot of the currently active view and saves it as a bitmap file,
95012>>>// in the current workspace's Capture folder. If that folder doesn't exist,
95012>>>// it will be created.
95012>>>// Pass False to take snapshot of the currently active view, or pass True
95012>>>// to take snapshot of the entire application. 
95012>>>// Pass True for the second boolean parameter (bShowSnapShotImage) to
95012>>>// show the file in the containing folder with Windows Explorer.
95012>>>Procedure TakeSnapshot Global Boolean bApplicationShot Boolean bSelectInExplorer
95014>>>    Integer iRetval
95014>>>    String sPath sToday sFileName
95014>>>    Handle hObjTo
95014>>>
95014>>>    Sysdate sToday
95015>>>    Move (Replace("/", sToday, "-")) to sToday
95016>>>
95016>>>    // Select the view to capture
95016>>>    If (bApplicationShot = False) Begin
95018>>>        Get Current_View to hObjTo
95019>>>    End
95019>>>>
95019>>>    Else Begin
95020>>>        Move (Parent(ghoCommandBars)) to hObjTo
95021>>>    End
95021>>>>
95021>>>
95021>>>    Get SnapShotFolder to sPath
95022>>>    Get vFolderFormat sPath to sPath
95023>>>
95023>>>    Move (sPath + (Object_Label(hObjTo)) + sToday + ".bmp") to sFileName
95024>>>    Get CaptureImage hObjTo sFileName to iRetval
95025>>>    If (iRetval <> 0 and bSelectInExplorer = True) Begin
95027>>>        Move ("/select, " + sFileName) to sFileName
95028>>>        Send vShellExecute "open" "explorer.exe" sFileName ""
95029>>>    End
95029>>>>
95029>>>End_Procedure
95030>>>
95030>>>// Function to get the folder where snapshots are saved.
95030>>>// Returns the full folder path. If the folder doesn't exist
95030>>>// it will be created.
95030>>>// Returns: The full snapshot folder path.
95030>>>Function SnapShotFolder Global Returns String
95032>>>    String sHome sPath sWorkSpaceFile
95032>>>    Boolean bExist
95032>>>    Integer iRetval
95032>>>    Handle hoIniFile
95032>>>
95032>>>    Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkSpaceFile
95033>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
95034>>>    Get vFolderFormat sHome to sHome
95035>>>
95035>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95036>>>    Set psFileName of hoIniFile to sWorkSpaceFile
95037>>>    Get ReadString of hoIniFile CS_CaptureSection CS_CaptureFolder CS_CaptureSection to sPath
95038>>>    Send Destroy of hoIniFile
95039>>>
95039>>>    If (Pos("..\", sPath)) Begin
95041>>>        Move (Replace("..\", sPath, "")) to sPath
95042>>>        Move (sHome + sPath) to sPath
95043>>>    End
95043>>>>
95043>>>    Else If (Pos(".\", sPath)) Begin
95046>>>        Move (Replace(".\", sPath, "")) to sPath
95047>>>        Move (sHome + sPath) to sPath
95048>>>    End
95048>>>>
95048>>>    Else Begin
95049>>>        Move (sHome + sPath) to sPath
95050>>>    End
95050>>>>
95050>>>
95050>>>    Get vFolderExists sPath to bExist
95051>>>    If (bExist = False) Begin
95053>>>        If (sPath = "") Begin
95055>>>            Get vSHGetFolderPath vCSIDL_MYPICTURES to sPath  // E.g. "C:\Documents and Settings\username\My Documents\My Pictures"
95056>>>        End
95056>>>>
95056>>>        Else Begin
95057>>>            Get vCreateDirectory sPath to iRetval
95058>>>            If (iRetval <> 0) Begin
95060>>>                Send Info_Box ("Could not create the 'Capture' folder for saving shapshots to." * sPath)
95061>>>                Function_Return ""
95062>>>            End
95062>>>>
95062>>>        End
95062>>>>
95062>>>    End
95062>>>>
95062>>>
95062>>>    Function_Return sPath
95063>>>End_Function
95064>
95064>Object oMain is a Panel
95066>    Set Label to (psProduct(ghoApplication))
95067>    Set Location to 4 3
95068>    Set Size to 350 602
95069>    Set piMinSize to 400 515
95070>    Set Icon to "DUFUpdateCodeGenerator1.ico"
95071>
95071>    Object oCommandBarSystem is a cCJCommandBarSystem
95073>        Set pbTimerUpdate to True
95074>            Set pbAutoResizeIcons to True
95075>            Set pbTabbedWorkspaces to True
95076>            Set peVisualTheme to xtpThemeOffice2013Publisher
95077>            Set pbLargeIcons to True
95078>
95078>        Procedure OnCreateCommandBars
95081>            Integer eTheme
95081>            Forward Send OnCreateCommandBars
95083>
95083>            Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord xtpThemeOffice2013Publisher to eTheme
95084>            Send SetTheTheme eTheme
95085>            Send DisplayTabWorkspace
95086>        End_Procedure
95087>
95087>        Procedure DisplayTabWorkspace
95090>            Variant vTab vPaintManager
95090>            Handle hoTab hoPaintManager hoOptions
95090>            Integer iSize
95090>
95090>            If (not(IsComObjectCreated(Self))) Begin
95092>                Procedure_Return
95093>            End
95093>
95093>            Get OptionsObject to hoOptions
95094>
95094>            // Create the tab workspace object. It will get created for the Client_Area so
95094>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
95094>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
95095>            Get ComShowTabWorkspace True to vTab
95096>            // Connect the CodeJock side to the DataFlex proxy object.
95096>            Set pvComObject  of hoTab to vTab
95097>
95097>            // We don't allow to close tabs as we have no menu system.
95097>            Set ComFlags of hoTab to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
95098>            Send ComEnableGroups of hoTab
95099>
95099>            // Create a paint manager object that is needed to set some
95099>            // of the tab-workspace properties.
95099>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
95100>            Get ComPaintManager of hoTab          to vPaintManager
95101>            Set pvComObject     of hoPaintManager to vPaintManager
95102>
95102>            // Sets the tab-pages to display on the left side, instead of at the top:
95102>            Set ComPosition     of hoPaintManager to xtpTabPositionLeft
95103>
95103>            // This will truncate the middle part of long items
95103>            Set ComDrawTextPathEllipsis of hoPaintManager to True
95104>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
95105>
95105>            Move 32 to iSize
95106>            Send ComSetIconSize     of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
95107>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
95108>            Get ComPaintManager of hoPaintManager  to vPaintManager
95109>            Set pvComObject     of hoPaintManager  to vPaintManager
95110>            Set ComAutoResizeIcons of hoPaintManager to True
95111>            Send Destroy of hoPaintManager
95112>            Send ComRecalcLayout
95113>            Send Destroy of hoTab
95114>        End_Procedure
95115>
95115>            Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95118>                // This will truncate the middle part of long text items
95118>                Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95119>                Set ComFlags of hoTabWorkspace to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
95120>            End_Procedure
95121>
95121>        Procedure SetTheTheme Integer eTheme
95124>            Integer iColor
95124>            Set peVisualTheme of ghoCommandBars to eTheme
95125>            Send ComRecalcLayout of ghoCommandBars
95126>            Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95127>            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95129>        End_Procedure
95130>
95130>        Object oActions_Toolbar is a cCJToolbar
95132>            Set pbCloseable to False
95133>            Set pbCustomizable to False
95134>            Set pbShowExpandButton to False
95135>            Set psTitle to "Actions"
95136>
95136>            Object oCodeGenerator_MenuItem is a cCJMenuItem
95138>                Set psCaption to "Code &Generator"
95139>                Set psImage to "SqlScript1.ico"
95140>                Set peControlStyle to xtpButtonIconAndCaption
95141>                Procedure OnExecute Variant vCommandBarControl
95144>                    Forward Send OnExecute vCommandBarControl
95146>                    Set pbChecked to True
95147>                    Set pbChecked of (oCompareDatabases_MenuItem(ghoCommandBars)) to False
95148>                    Send Activate_oTableDUFCodeGenerator of (Client_Id(phoMainPanel(ghoApplication)))
95149>                End_Procedure
95150>            End_Object
95151>
95151>            Object oCompareDatabases_MenuItem is a cCJMenuItem
95153>                Set psCaption to "Compare &Databases"
95154>                Set psImage to "DbCompare1.ico"
95155>                Set peControlStyle to xtpButtonIconAndCaption
95156>                Set pbChecked to True
95157>
95157>                Procedure OnExecute Variant vCommandBarControl  
95160>                    Forward Send OnExecute vCommandBarControl
95162>                    Set pbChecked to True
95163>                    Set pbChecked of (oCodeGenerator_MenuItem(ghoCommandBars)) to False
95164>                    Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
95165>                End_Procedure
95166>            End_Object
95167>
95167>        End_Object
95168>
95168>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95168>        // the previous tab workspace view.
95168>
95168>        Object oEditToolBar is a cCJToolbar
95170>            Set psTitle to "Edit Toolbar"
95171>            Set pbCloseable to False
95172>            Set pbCustomizable to False
95173>            Set pbShowExpandButton to False
95174>
95174>            Object oCutToolbarItem is a cCJCutMenuItem
95176>                Set psImage to "ActionCut1.ico"
95177>            End_Object
95178>
95178>            Object oCopyToolbarItem is a cCJCopyMenuItem
95180>                Set psImage to "ActionCopy1.ico"
95181>
95181>            End_Object
95182>
95182>            Object oPasteToolbarItem is a cCJPasteMenuItem
95184>                Set psImage to "ActionPaste1.ico"
95185>            End_Object
95186>
95186>//            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95186>//                Set psImage to "ActionDelete1.ico"
95186>//                Set pbControlBeginGroup to True
95186>//            End_Object
95186>
95186>            Object oPromptToolItem is a cCJPromptMenuItem
95188>                Set psImage to "ActionPrompt1.ico"
95189>                Set pbControlBeginGroup to True
95190>            End_Object
95191>
95191>            Object oClearToolItem is a cCJClearMenuItem
95193>                Set peControlStyle to xtpButtonIconAndCaption
95194>                Set psCaption      to "Clear/Add"
95195>                Set pbControlBeginGroup to True
95196>                Set psImage to "ActionClear1.ico"  
95197>                
95197>                Function IsEnabled Returns Boolean
95200>                    Function_Return True
95201>                End_Function
95202>
95202>            End_Object
95203>
95203>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
95205>                Set psImage to "ActionOpenContainingFolder1.ico"
95206>                Set psCaption to "Containing Folder"
95207>                Set psToolTip to "Open containing folder"
95208>                Set psDescription to "Open Containing Folder"
95209>                Set pbActiveUpdate to True
95210>                Set pbControlBeginGroup to True
95211>
95211>                Procedure OnExecute Variant vCommandBarControl
95214>                    String sPath sFile       
95214>                    Boolean bExists
95214>
95214>                    Forward Send OnExecute vCommandBarControl
95216>                    Get psFilelistFrom of ghoApplication to sFile
95217>                    Get ParseFolderName sFile to sPath
95218>                    Get vFilePathExists sFile to bExists
95219>                    // We want to have that file to be selected in Windows Explorer;
95219>                    If (bExists = True) Begin
95221>                        Move ("/select, " + sFile) to sPath
95222>                    End
95222>                    Send vShellExecute "open" "explorer.exe" sPath ""
95223>                End_Procedure
95224>
95224>                Function IsEnabled Returns Boolean
95227>                    String sFile
95227>                    Boolean bExists
95227>                    Get psFilelistFrom of ghoApplication to sFile
95228>                    Get vFilePathExists sFile to bExists
95229>                    Function_Return (bExists = True)
95230>                End_Function
95231>
95231>            End_Object
95232>
95232>            Object oCompareToolItem is a cCJMenuItem
95234>//                Set peControlStyle to xtpButtonIconAndCaption
95234>//                Set psCaption to "&Connection" 
95234>                Set psToolTip to "Show SQL Settings dialog"
95235>                Set psImage to "SQLSettings1.ico"
95236>                Set piShortCutKey to xtpKey_Alt VK_S
95237>                Set pbControlBeginGroup to True
95238>                Set pbActiveUpdate to True
95239>
95239>                Procedure OnExecute Variant vCommandBarControl
95242>                    tSQLConnection Connection
95242>                    tSQLConnection Connection
95242>                    String sFileListFrom sCurrentFilelist
95242>                    Handle hoFocus
95242>                    Boolean bExists bOK
95242>
95242>                    Move (Focus(Desktop)) to hoFocus
95243>
95243>                    // First change the "current" filelist depending on which
95243>                    // Filelist form is active.
95243>                    Get Value of hoFocus to sCurrentFilelist
95244>                    Get vFilePathExists sCurrentFilelist to bExists
95245>                    Get psFilelistFrom of ghoApplication to sFileListFrom
95246>                    If (sFileListFrom = "") Begin 
95248>                        Send Info_Box "You need to select a Filelist.cfg file with SQL tables first."
95249>                        Procedure_Return
95250>                    End
95250>                    If (bExists = True and sCurrentFilelist <> "") Begin
95252>                        Get ChangeFilelistPathing of ghoApplication sCurrentFilelist to bOK
95253>                        Get psFilelistFrom of ghoApplication to sFileListFrom
95254>                    End
95254>
95254>                    If (sFileListFrom <> "") Begin
95256>                        Get pSQLConnection of ghoSQLConnectionHandler to Connection
95257>                    End
95257>
95257>                    Send Activate_ReadOnlySQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
95258>                End_Procedure  
95259>                
95259>                Function IsEnabled Returns Boolean
95262>                    tSQLConnection Connection
95262>                    tSQLConnection Connection
95262>                    Get pSQLConnection of ghoSQLConnectionHandler to Connection
95263>                    Function_Return (Connection.sDriverID <> DATAFLEX_ID and Connection.sDriverID <> "")
95264>                End_Function
95265>
95265>            End_Object
95266>
95266>            Object oAddToStudio_MenuItem is a cCJMenuItem
95268>                Set psCaption to "Add to Studio"
95269>                Set psDescription to "Add to Studio"
95270>                Set psToolTip to "Add this tool to the DataFlex Studio's 'Tools' menu"
95271>                Set psImage to "ActionAddStudio1.ico"
95272>                Set pbControlBeginGroup to True   
95273>                
95273>                Procedure OnExecute Variant vCommandBarControl
95276>                    Forward Send OnExecute vCommandBarControl
95278>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
95279>                End_Procedure
95280>                
95280>            End_Object
95281>
95281>//            Object oCaptureViewMenuItem is a cCJMenuItem
95281>//                Set psCaption to "E&ditor Settings"
95281>//                Set psToolTip to "Editor"
95281>//                Set psDescription to "Editor Settings (Alt+D)"
95281>//
95281>//                Set psCaption to "Take shapshot"
95281>//                Set psToolTip to "Take shapshot"
95281>//                Set psDescription to "Take a snapshot image of the current view/panel. (F10)"
95281>//                Set psImage to "Camera1.ico"
95281>//                
95281>//                Procedure OnExecute Variant vCommandBarControl
95281>//                    Send TakeSnapshot False
95281>//                End_Procedure
95281>//
95281>//                Function IsEnabled Returns Boolean
95281>//                    Function_Return
95281>//                End_Function   
95281>//            End_Object
95281>
95281>//            #IF (!@ > 182)
95281>//
95281>//            Use DatabaseSelection.pkg
95281>//    
95281>//            Object oThemeItem is a cCJMenuItem
95281>//                Set peControlType to xtpControlComboBox
95281>//                Set psToolTip to "Theme"
95281>//                Set psCaption to "Theme:"
95281>//                Set psDescription to "Select a theme from the drop down list"
95281>//                Set pbControlBeginGroup to True
95281>//                Set pbVisible to False
95281>//
95281>//                Procedure OnCreateControl Handle hoObj
95281>//                    Integer iItem eTheme
95281>//                    Set ComWidth of hoObj to 250
95281>//                    Send FillComboList hoObj
95281>//                    Get peVisualTheme to eTheme
95281>//                    Get FindDataItem hoObj eTheme to iItem
95281>//                    Set ComListIndex of hoObj to (If(iItem, iItem, 1))
95281>//                End_Procedure
95281>//
95281>//                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95281>//                    Integer iCount i eTheme
95281>//                    Get ComListCount of hoCombo to iCount
95281>//                    For i from 1 to iCount
95281>//                        Get ComItemData of hoCombo i to eTheme
95281>//                        If (eTheme = eVal) Begin
95281>//                            Send SetTheTheme eTheme
95281>//                            Function_Return i
95281>//                        End
95281>//                    Loop
95281>//                    Function_Return 0
95281>//                End_Function
95281>//
95281>//                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95281>//                    Integer iCount
95281>//                    Get ComListCount of hoCombo to iCount
95281>//                    Increment iCount
95281>//                    Send ComAddItem  of hoCombo sText iCount
95281>//                    Set ComItemData  of hoCombo iCount to  eTheme
95281>//                End_Procedure
95281>//
95281>//                Procedure FillComboList Handle hoCombo
95281>//                    Send ComClear     of hoCombo
95281>//
95281>//                    #IF (!@ > 190)
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016Access" xtpThemeOffice2016Access
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016Excel" xtpThemeOffice2016Excel
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016OneNote" xtpThemeOffice2016OneNote
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016Outlook" xtpThemeOffice2016Outlook
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016PowerPoint" xtpThemeOffice2016PowerPoint
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016Publisher" xtpThemeOffice2016OneNote
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2016Word" xtpThemeOffice2016Word
95281>//                    #ENDIF
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95281>//                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95281>//                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95281>//                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95281>//
95281>//                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95281>//                End_Procedure
95281>//
95281>//                Function CurrentTheme Handle vCommandBarControl Returns Integer
95281>//                    Handle hMessage hoCombo
95281>//                    Integer iIndex
95281>//                    // create and bind  proxy control
95281>//                    Get CreateProxyControl vCommandBarControl to hoCombo
95281>//                    // get the current selection
95281>//                    Get ComListIndex of hoCombo to iIndex
95281>//                    // note the index selections are 1 based
95281>//                    If (iIndex > 0) Begin
95281>//                        // get the ItemData for the selected item and send that message
95281>//                        Get ComItemData of hoCombo iIndex to hMessage
95281>//                        Function_Return hMessage
95281>//                    End
95281>//                    // dispose of the proxy control
95281>//                    Send Destroy of hoCombo 
95281>//                    Function_Return 0
95281>//                End_Function
95281>//
95281>//                Procedure OnExecute Variant vCommandBarControl
95281>//                    Integer eTheme
95281>//                    Integer iColor
95281>//                    Get CurrentTheme vCommandBarControl to eTheme
95281>//                    Set peVisualTheme of ghoCommandBars to eTheme
95281>//                    Send ComRecalcLayout of ghoCommandBars
95281>//                    Send WriteDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme
95281>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95281>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95281>//                End_Procedure
95281>//
95281>//                Procedure SetTheTheme Integer eTheme
95281>//                    Integer iColor
95281>//                    Set peVisualTheme of ghoCommandBars to eTheme
95281>//                    Send ComRecalcLayout of ghoCommandBars
95281>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95281>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95281>//                End_Procedure
95281>//
95281>//                Function ConvertSystemColor Integer iColor Returns Integer
95281>//                    Integer iSysColor
95281>//                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95281>//                        Move clNone to iColor
95281>//                    End
95281>//                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95281>//                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95281>//                        Move (GetSysColor(iSysColor)) to iColor
95281>//                    End
95281>//                    Function_Return iColor
95281>//                End_Function
95281>//
95281>//                Procedure OnCreateAction
95281>//                    Integer eTheme
95281>//                    Forward Send OnCreateAction
95281>//                    Get peVisualTheme of ghoCommandBars to eTheme
95281>//                    Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme to eTheme
95281>//                    Set peVisualTheme to eTheme
95281>//                End_Procedure
95281>//
95281>//            End_Object
95281>//            #ENDIF
95281>
95281>//            Object oColorSelection_TextItem is a cCJMenuItem
95281>//                Set peControlType to xtpControlLabel
95281>//                Set pbControlBeginGroup to True
95281>//                Set psCaption to "Hotspot Color:"
95281>//            End_Object
95281>//
95281>//            Object oColorSelection_Item is a cCJMenuItem
95281>//                Set psImage to "ColorSelectorBlack1.ico"
95281>//
95281>//                Object oColorDialog is a ColorDialog
95281>//                    Function SelectColor Returns Integer
95281>//                        Integer iRgbColor
95281>//                        Boolean bColorSelected
95281>//
95281>//                        Move -1 to iRgbColor
95281>//                        Get Show_Dialog to bColorSelected
95281>//                        If (bColorSelected) Begin
95281>//                            Get SelectedColor to iRgbColor
95281>//                        End
95281>//
95281>//                        Function_Return iRgbColor
95281>//                    End_Function
95281>//                End_Object
95281>//
95281>//                Procedure OnExecute Variant vCommandBarControl
95281>//                    Integer iColor
95281>//                    Forward Send OnExecute vCommandBarControl
95281>//                    Get SelectColor of oColorDialog to iColor
95281>//                    If (iColor <> -1) Begin
95281>//                        Broadcast Recursive Set piHeaderHotspotColor of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95281>//                    End
95281>//                End_Procedure
95281>//
95281>//            End_Object
95281>
95281>            Object oAbout_MenuItem is a cCJMenuItem
95283>                Set psCaption to "About"
95284>                Set psToolTip to "About Info"
95285>                Set psDescription to "About the program"
95286>                Set psImage to "ActionAbout1.ico"
95287>                Set pbControlBeginGroup to True
95288>                Procedure OnExecute Variant vCommandBarControl
95291>                    Forward Send OnExecute vCommandBarControl
95293>                    Send Activate_About of (Client_Id(ghoCommandBars))
95294>                End_Procedure
95295>            End_Object
95296>
95296>            Object oHelpMenuItem is a cCJHelpMenuItem
95298>                Set peControlType to xtpControlSplitButtonPopup
95299>                Set psImage to "ActionHelp1.ico"
95300>
95300>                Procedure OnExecute Variant vCommandBarControl
95303>                    Send ShowProgramHelp
95304>                End_Procedure
95305>
95305>                Object oHelpMenuItemLocal is a cCJMenuItem
95307>                    Set psCaption to "Local HTML Help"
95308>                    Set psImage to "ActionHelp1.ico"
95309>                    Procedure OnExecute Variant vCommandBarControl
95312>                        Send ShowProgramHelp
95313>                    End_Procedure
95314>                End_Object
95315>
95315>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95317>                    Set psCaption to "Online HTML Help"
95318>                    Set psImage to "ActionHelpInternet1.ico"
95319>                    Procedure OnExecute Variant vCommandBarControl
95322>                        Runprogram Shell Background "http://www.rdctools.com/HTMLHelpDUF/Developer5.htm"
95323>                    End_Procedure
95324>
95324>                End_Object
95325>
95325>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
95327>                    Set psCaption to "Check for Updates"
95328>                    Set psDescription to "Check for Updates..."
95329>                    Set psImage to "InternetUpdate1.ico"
95330>                    Set pbControlBeginGroup to True
95331>                    
95331>                    Procedure OnExecute Variant vCommandBarControl
95334>                        String sPath sUpdateProgram sParam
95334>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
95335>                        Get vFolderFormat sPath to sPath
95336>                        Move "updater.exe" to sUpdateProgram
95337>                        Move "/checknow"   to sParam
95338>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
95339>                    End_Procedure
95340>                
95340>                End_Object
95341>                
95341>            End_Object
95342>
95342>            Object oExitMenuItem is a cCJExitMenuItem
95344>                Set psToolTip to "Exit application"
95345>                Set psDescription to "Exit the program (Alt+F4)"
95346>                Set psImage to "ActionExit1.ico"
95347>                Set pbControlBeginGroup to True
95348>            End_Object
95349>
95349>        End_Object
95350>
95350>        Object oPreviousTabAction is a cCJAction
95352>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95353>            Procedure OnExecute Variant vCommandBarControl
95356>                Handle hoCommandBars hoClientArea
95356>                Forward Send OnExecute vCommandBarControl
95358>                Get CommandBarSystemObject to hoCommandBars
95359>                Get ClientAreaObject of hoCommandBars to hoClientArea
95360>                If hoClientArea Begin
95362>                    Send Switch_Next_View of hoClientArea
95363>                End
95363>            End_Procedure
95364>        End_Object
95365>
95365>        Object oStatusBar is a cCJStatusBar
95367>
95367>            Object oStatusPane1 is a cCJStatusBarPane
95369>                Set piID to sbpIDIdlePane
95370>                Set pbStyleStretch to True
95371>            End_Object
95372>
95372>            Object oStatusPane2 is a cCJStatusBarPane
95374>                Set phoViewPane to Self
95375>                Set pbStyleStretch to True
95376>            End_Object
95377>
95377>        End_Object
95378>
95378>    End_Object
95379>
95379>    Object oClientArea is a ClientArea
95381>        Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
95381>>>Use Windows.pkg
95381>>>Use Cursor.pkg
95381>>>Use cCJCommandBarSystem.pkg
95381>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButtonDPI.pkg)
95381>>>>>//****************************************************************************
95381>>>>>// $Module type: Package
95381>>>>>// $Module name: cRDCButtonDPI.pkg
95381>>>>>//
95381>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95381>>>>>// Copyright (c) 2013 RDC Tools International
95381>>>>>// E-mail      : support@rdctools.com
95381>>>>>// Web-site    : http://www.rdctools.com
95381>>>>>//
95381>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
95381>>>>>//
95381>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95381>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95381>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95381>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95381>>>>>// in the help folder for more details.
95381>>>>>//
95381>>>>>//****************************************************************************
95381>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButton.pkg)
95381>>>>>>>//****************************************************************************
95381>>>>>>>// $Module type: Package
95381>>>>>>>// $Module name: cRDCButton.pkg
95381>>>>>>>//
95381>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95381>>>>>>>// Copyright (c) 2013 RDC Tools International
95381>>>>>>>// E-mail      : support@rdctools.com
95381>>>>>>>// Web-site    : http://www.rdctools.com
95381>>>>>>>//
95381>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
95381>>>>>>>//
95381>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95381>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95381>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95381>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95381>>>>>>>// in the help folder for more details.
95381>>>>>>>//
95381>>>>>>>//****************************************************************************
95381>>>>>>>Use Windows.pkg
95381>>>>>>>Use Enclient.pkg
95381>>>>>>>Use errornum.inc
95381>>>>>>>
95381>>>>>>>Class cButtonIdleHandler is a cIdleHandler
95382>>>>>>>    Procedure Construct_Object
95384>>>>>>>        Forward Send Construct_Object
95386>>>>>>>
95386>>>>>>>    End_Procedure
95387>>>>>>>
95387>>>>>>>    Procedure OnIdle
95389>>>>>>>        Delegate Send DoUpdate
95391>>>>>>>    End_Procedure
95392>>>>>>>
95392>>>>>>>End_Class
95393>>>>>>>
95393>>>>>>>Class cRDCButton is a Button
95394>>>>>>>
95394>>>>>>>    Procedure Construct_Object
95396>>>>>>>        Forward Send Construct_Object
95398>>>>>>>
95398>>>>>>>        Property Boolean pbAutoEnable True
95399>>>>>>>
95399>>>>>>>        Property Boolean pbEnabled True
95400>>>>>>>
95400>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
95401>>>>>>>
95401>>>>>>>        On_Key kCancel Send CancelIfPopupObject
95402>>>>>>>    End_Procedure
95403>>>>>>>
95403>>>>>>>    Procedure CancelIfPopupObject
95405>>>>>>>        Boolean bIsInPopupObject
95405>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
95407>>>>>>>        If (bIsInPopupObject = True) Begin
95409>>>>>>>            Send Close_Panel
95410>>>>>>>        End
95410>>>>>>>>
95410>>>>>>>    End_Procedure
95411>>>>>>>
95411>>>>>>>    Procedure End_Construct_Object
95413>>>>>>>        String sTooltip sStatus_Help
95413>>>>>>>
95413>>>>>>>        Forward Send End_Construct_Object
95415>>>>>>>
95415>>>>>>>        Get psToolTip   to sTooltip
95416>>>>>>>        Get Status_Help to sStatus_Help
95417>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
95419>>>>>>>            Set psToolTip to sStatus_Help
95420>>>>>>>        End
95420>>>>>>>>
95420>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
95422>>>>>>>            Set Status_Help to sToolTip
95423>>>>>>>        End
95423>>>>>>>>
95423>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
95424>>>>>>>    End_Procedure
95425>>>>>>>
95425>>>>>>>    Procedure DoUpdate
95427>>>>>>>        If (pbAutoEnable(Self) = False) Begin
95429>>>>>>>            Procedure_Return
95430>>>>>>>        End
95430>>>>>>>>
95430>>>>>>>        Set Enabled_State to (IsEnabled(Self))
95431>>>>>>>    End_Procedure
95432>>>>>>>
95432>>>>>>>    Function IsEnabled Returns Boolean
95434>>>>>>>        Boolean bEnabled
95434>>>>>>>        Get pbEnabled to bEnabled
95435>>>>>>>        Function_Return bEnabled
95436>>>>>>>    End_Function
95437>>>>>>>
95437>>>>>>>    // Enable the idle handler timer when the button is activated
95437>>>>>>>    Procedure Activating
95439>>>>>>>        Forward Send Activating
95441>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
95442>>>>>>>    End_Procedure
95443>>>>>>>
95443>>>>>>>    // Disable the idle handler when the button is deactivated
95443>>>>>>>    Procedure Deactivating
95445>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
95446>>>>>>>        Forward Send Deactivating
95448>>>>>>>    End_Procedure
95449>>>>>>>
95449>>>>>>>End_Class
95450>>>>>
95450>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
95450>>>>>Class cRDCButtonDPI is a cRDCButton
95451>>>>>    Procedure Construct_Object
95453>>>>>        Integer iIconSize
95453>>>>>        Forward Send Construct_Object
95455>>>>>        Set piImageMarginLeft to 10
95456>>>>>    End_Procedure
95457>>>>>
95457>>>>>    // Returns: DPI setting as an integer.
95457>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95457>>>>>    //                      iDPI=120 is "Medium setting" 125%
95457>>>>>    //                      iDPI= 144 is "Large setting" 150%
95457>>>>>    Function GetCurrentDPI Returns Integer
95459>>>>>        Handle hDC
95459>>>>>        Integer iPixelsX
95459>>>>>        Move (GetDC(0)) to hDC
95460>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95461>>>>>        Move (ReleaseDC(0, hDC)) to hDC
95462>>>>>        Function_Return iPixelsX
95463>>>>>    End_Function
95464>>>>>
95464>>>>>    Function GetCorrectIconSize Returns Integer
95466>>>>>        Integer iPixelsX iIndex iSize
95466>>>>>        Integer[] iaSizes
95467>>>>>
95467>>>>>        Move 16 to iaSizes[0]
95468>>>>>        Move 24 to iaSizes[1]
95469>>>>>        Move 32 to iaSizes[2]
95470>>>>>        Move 48 to iaSizes[3]
95471>>>>>        Move 64 to iaSizes[4]
95472>>>>>
95472>>>>>        Get piImageSize to iSize  // the "100%" size
95473>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
95474>>>>>        Move (0 max iIndex) to iIndex
95475>>>>>        Get GetCurrentDPI to iPixelsX
95476>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
95476>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
95476>>>>>        // will increment iIndex as many times as we need here.
95476>>>>>        Case Begin
95476>>>>>            Case (iPixelsX > 144)
95478>>>>>                Increment iIndex
95479>>>>>            Case (iPixelsX = 144)
95482>>>>>                Increment iIndex
95483>>>>>            Case (iPixelsX = 120)
95486>>>>>                Increment iIndex
95487>>>>>        Case End
95487>>>>>        Move (iIndex min 4) to iIndex
95488>>>>>        Function_Return iaSizes[iIndex]
95489>>>>>    End_Function
95490>>>>>
95490>>>>>    Procedure Set psToolTip String sToolTip
95492>>>>>        String sStatusHelp
95492>>>>>
95492>>>>>        Get Status_Help to sStatusHelp
95493>>>>>        If (sStatusHelp = "") Begin
95495>>>>>            Set Status_Help to sToolTip
95496>>>>>        End
95496>>>>>>
95496>>>>>
95496>>>>>        Forward Set psToolTip to sToolTip
95498>>>>>    End_Procedure
95499>>>>>
95499>>>>>End_Class
95500>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
95500>>>>>Use Windows.pkg
95500>>>>>
95500>>>>>// Used by the "Page" message below to show
95500>>>>>// a rectangle around ComboForm and Checkbox objects.
95500>>>>>    Define WM_CHANGEUISTATE for |CI$0127
95500>>>>>    Define WM_UPDATEUISTATE for |CI$0128
95500>>>>>    Define WM_QUERYUISTATE  for |CI$0129
95500>>>>>    Define UIS_SET          for 1
95500>>>>>    Define UIS_CLEAR        for 2
95500>>>>>    Define UIS_INITIALIZE   for 3
95500>>>>>    Define UISF_HIDEFOCUS   for |CI$1
95500>>>>>    Define UISF_HIDEACCEL   for |CI$2
95500>>>>>    Define UISF_ACTIVE      for |CI$4
95500>>>>>
95500>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
95500>>>>>Class cSQLCheckBox is a CheckBox
95501>>>>>    Procedure Construct_Object
95503>>>>>        Forward Send Construct_Object
95505>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95505>>>>>        Property Integer piItem
95506>>>>>    End_Procedure
95507>>>>>
95507>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95509>>>>>    End_Procedure
95510>>>>>
95510>>>>>    Procedure ReadConnectionData String[] sConnectionData
95512>>>>>        Integer iItem
95512>>>>>        Get piItem to iItem
95513>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
95514>>>>>    End_Procedure
95515>>>>>
95515>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95517>>>>>        Boolean bState
95517>>>>>        Integer iItem
95517>>>>>        Get piItem to iItem
95518>>>>>        Get Checked_State to bState
95519>>>>>        Move bState to sConnectionData[iItem]
95520>>>>>    End_Procedure
95521>>>>>
95521>>>>>    Procedure Set psToolTip String sToolTip
95523>>>>>        String sStatusHelp
95523>>>>>
95523>>>>>        Get Status_Help to sStatusHelp
95524>>>>>        If (sStatusHelp = "") Begin
95526>>>>>            Set Status_Help to sToolTip
95527>>>>>        End
95527>>>>>>
95527>>>>>
95527>>>>>        Forward Set psToolTip to sToolTip
95529>>>>>    End_Procedure
95530>>>>>
95530>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95530>>>>>    // The bug being that the focus rectangle doesn't show.
95530>>>>>    Procedure Page Integer iPageObject
95532>>>>>        Handle hWnd
95532>>>>>        Integer iRet iState
95532>>>>>
95532>>>>>        Forward Send Page iPageObject
95534>>>>>
95534>>>>>        If (iPageObject) Begin
95536>>>>>            Get Window_Handle to hWnd
95537>>>>>            If (hWnd) Begin
95539>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95540>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95542>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95543>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95544>>>>>                End
95544>>>>>>
95544>>>>>            End
95544>>>>>>
95544>>>>>        End
95544>>>>>>
95544>>>>>    End_Procedure
95545>>>>>
95545>>>>>End_Class
95546>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
95546>>>>>Use Windows.pkg
95546>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCComboForm.pkg)
95546>>>>>>>//****************************************************************************
95546>>>>>>>// $Module type: Package
95546>>>>>>>// $Module name: cRDCComboform.pkg
95546>>>>>>>//
95546>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95546>>>>>>>// Copyright (c) 2014 RDC Tools International
95546>>>>>>>// E-mail      : support@rdctools.com
95546>>>>>>>// Web-site    : http://www.rdctools.com
95546>>>>>>>//
95546>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
95546>>>>>>>//
95546>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
95546>>>>>>>//               The auto-size combo width logic was developed by Raveen.
95546>>>>>>>//
95546>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95546>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95546>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95546>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95546>>>>>>>// in the help folder for more details.
95546>>>>>>>//
95546>>>>>>>//****************************************************************************
95546>>>>>>>Use Windows.pkg
95546>>>>>>>
95546>>>>>>>// Used by the "Page" message below to show
95546>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
95546>>>>>>>
95546>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
95547>>>>>>>    Procedure Construct_Object
95549>>>>>>>        Forward Send Construct_Object
95551>>>>>>>
95551>>>>>>>        Set Label_Row_Offset to 0
95552>>>>>>>        Set Label_Col_Offset to 2
95553>>>>>>>        Set Label_Justification_Mode to jMode_Right
95554>>>>>>>        Set Combo_Sort_State to False
95555>>>>>>>        Set Entry_State to False
95556>>>>>>>
95556>>>>>>>    End_Procedure
95557>>>>>>>
95557>>>>>>>    Procedure OnIdle
95559>>>>>>>        Delegate Send DoUpdate
95561>>>>>>>    End_Procedure
95562>>>>>>>
95562>>>>>>>End_Class
95563>>>>>>>
95563>>>>>>>Class cRDCComboForm is a ComboForm
95564>>>>>>>    Procedure Construct_Object
95566>>>>>>>        Forward Send Construct_Object
95568>>>>>>>
95568>>>>>>>        Property Boolean pbAutoListWidth True
95569>>>>>>>
95569>>>>>>>        Property Boolean pbAutoShadowLabelObject True
95570>>>>>>>
95570>>>>>>>        Property Boolean pbAutoEnable False
95571>>>>>>>        Set Label_Col_Offset to 2
95572>>>>>>>        Property Boolean pbEnabled True
95573>>>>>>>        Set Label_Justification_Mode to JMode_Right
95574>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
95575>>>>>>>
95575>>>>>>>    End_Procedure
95576>>>>>>>
95576>>>>>>>    Procedure End_Construct_Object
95578>>>>>>>        Boolean bAutoShadowLabelObject
95578>>>>>>>        String sTooltip sStatus_Help
95578>>>>>>>
95578>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95579>>>>>>>        If (bAutoShadowLabelObject = True) Begin
95581>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95582>>>>>>>        End
95582>>>>>>>>
95582>>>>>>>
95582>>>>>>>        Forward Send End_Construct_Object
95584>>>>>>>
95584>>>>>>>        Get psToolTip   to sTooltip
95585>>>>>>>        Get Status_Help to sStatus_Help
95586>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
95588>>>>>>>            Set psToolTip to sStatus_Help
95589>>>>>>>        End
95589>>>>>>>>
95589>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
95592>>>>>>>            Set Status_Help to sTooltip
95593>>>>>>>        End
95593>>>>>>>>
95593>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
95594>>>>>>>
95594>>>>>>>    End_Procedure
95595>>>>>>>
95595>>>>>>>    Procedure DoUpdate
95597>>>>>>>        If (pbAutoEnable(Self) = False) Begin
95599>>>>>>>            Procedure_Return
95600>>>>>>>        End
95600>>>>>>>>
95600>>>>>>>        Set Enabled_State to (IsEnabled(Self))
95601>>>>>>>    End_Procedure
95602>>>>>>>
95602>>>>>>>    Function IsEnabled Returns Boolean
95604>>>>>>>        Boolean bEnabled
95604>>>>>>>        Get pbEnabled to bEnabled
95605>>>>>>>        Function_Return bEnabled
95606>>>>>>>    End_Function
95607>>>>>>>
95607>>>>>>>    // Enable the idle handler timer when the object is activated
95607>>>>>>>    Procedure Activating
95609>>>>>>>        Forward Send Activating
95611>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
95612>>>>>>>    End_Procedure
95613>>>>>>>
95613>>>>>>>    // Disable the idle handler when the object is deactivated
95613>>>>>>>    Procedure Deactivating
95615>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
95616>>>>>>>        Forward Send Deactivating
95618>>>>>>>    End_Procedure
95619>>>>>>>
95619>>>>>>>    // To "un-select" the text in the comboform on startup
95619>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
95621>>>>>>>        Integer iStart iEnd
95621>>>>>>>
95621>>>>>>>        If (Focus(Desktop)=Self) Begin
95623>>>>>>>            Get SelStart to iStart
95624>>>>>>>            Get SelEnd   to iEnd
95625>>>>>>>        End
95625>>>>>>>>
95625>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
95627>>>>>>>        Send SetSel iStart iEnd
95628>>>>>>>    End_Procedure
95629>>>>>>>
95629>>>>>>>    // Message that will drop down the list without the user clicking it,
95629>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
95629>>>>>>>    Procedure DropDownList
95631>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
95632>>>>>>>    End_Procedure
95633>>>>>>>
95633>>>>>>>    Procedure SizeComboWidth
95635>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
95635>>>>>>>        String sVal
95635>>>>>>>
95635>>>>>>>        // Initialise Width
95635>>>>>>>        Set ListWidth to 0
95636>>>>>>>        Send DoSetListWidth
95637>>>>>>>
95637>>>>>>>        Get ListRowCount     to iRows
95638>>>>>>>        Get Combo_Item_Count to iCount
95639>>>>>>>
95639>>>>>>>        // Vertical scroll-bar adjustment is needed
95639>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
95640>>>>>>>        If (iVertAdj) Begin
95642>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
95643>>>>>>>        End
95643>>>>>>>>
95643>>>>>>>        Else Begin
95644>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
95645>>>>>>>        End
95645>>>>>>>>
95645>>>>>>>
95645>>>>>>>        // Calculate New Width
95645>>>>>>>        Decrement iCount
95646>>>>>>>        For iItem from 0 to iCount
95652>>>>>>>>
95652>>>>>>>            Get Combo_Value iItem to sVal
95653>>>>>>>            If (sVal <> "") Begin
95655>>>>>>>                Get Text_Extent sVal to iTextExt
95656>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
95657>>>>>>>                If (iWd > iNewWd) Begin
95659>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
95660>>>>>>>                End
95660>>>>>>>>
95660>>>>>>>            End
95660>>>>>>>>
95660>>>>>>>        Loop
95661>>>>>>>>
95661>>>>>>>
95661>>>>>>>        // Set New Width
95661>>>>>>>        Set ListWidth to iNewWd
95662>>>>>>>        Send DoSetListWidth
95663>>>>>>>    End_Procedure
95664>>>>>>>
95664>>>>>>>    Procedure Combo_Add_Item String sValue
95666>>>>>>>        Forward Send Combo_Add_Item sValue
95668>>>>>>>        If (pbAutoListWidth(Self)) Begin
95670>>>>>>>            Send SizeComboWidth
95671>>>>>>>        End
95671>>>>>>>>
95671>>>>>>>    End_Procedure
95672>>>>>>>
95672>>>>>>>    Procedure Combo_Fill_List
95674>>>>>>>        Forward Send Combo_Fill_List
95676>>>>>>>        If (pbAutoListWidth(Self)) Begin
95678>>>>>>>            Send SizeComboWidth
95679>>>>>>>        End
95679>>>>>>>>
95679>>>>>>>    End_Procedure
95680>>>>>>>
95680>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95680>>>>>>>    // The bug being that the focus rectangle doesn't show.
95680>>>>>>>    Procedure Page Integer iPageObject
95682>>>>>>>        Handle hWnd
95682>>>>>>>        Integer iRet iState
95682>>>>>>>
95682>>>>>>>        Forward Send Page iPageObject
95684>>>>>>>
95684>>>>>>>        If (iPageObject) Begin
95686>>>>>>>            Get Window_Handle to hWnd
95687>>>>>>>            If (hWnd) Begin
95689>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95690>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95692>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95693>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95694>>>>>>>                End
95694>>>>>>>>
95694>>>>>>>            End
95694>>>>>>>>
95694>>>>>>>        End
95694>>>>>>>>
95694>>>>>>>
95694>>>>>>>        // To "un-select" the text in the comboform
95694>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
95696>>>>>>>            Send SetSel 0 0
95697>>>>>>>        End
95697>>>>>>>>
95697>>>>>>>    End_Procedure
95698>>>>>>>
95698>>>>>>>End_Class
95699>>>>>
95699>>>>>// Used by the "Page" message below to show
95699>>>>>// a rectangle around ComboForm and Checkbox objects.
95699>>>>>//#IFNDEF WM_CHANGEUISTATE
95699>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
95699>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
95699>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
95699>>>>>//    Define UIS_SET          for 1
95699>>>>>//    Define UIS_CLEAR        for 2
95699>>>>>//    Define UIS_INITIALIZE   for 3
95699>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
95699>>>>>//    Define UISF_HIDEACCEL   for |CI$2
95699>>>>>//    Define UISF_ACTIVE      for |CI$4
95699>>>>>//#ENDIF
95699>>>>>
95699>>>>>Class cSQLComboForm is a cRDCComboForm
95700>>>>>    Procedure Construct_Object
95702>>>>>        Forward Send Construct_Object
95704>>>>>
95704>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
95704>>>>>//        Property Boolean pbAutoShadowLabelObject True
95704>>>>>
95704>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95704>>>>>        Property Integer piItem
95705>>>>>
95705>>>>>//        Set Label_Col_Offset to 2
95705>>>>>//        Set Label_Justification_Mode to JMode_Right
95705>>>>>    End_Procedure
95706>>>>>
95706>>>>>    Procedure End_Construct_Object
95708>>>>>//        Boolean bAutoShadowLabelObject
95708>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95708>>>>>//        If (bAutoShadowLabelObject = True) Begin
95708>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95708>>>>>//        End
95708>>>>>        Forward Send End_Construct_Object
95710>>>>>    End_Procedure
95711>>>>>
95711>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95713>>>>>    End_Procedure
95714>>>>>
95714>>>>>    Procedure ReadConnectionData String[] sConnectionData
95716>>>>>        Integer iItem
95716>>>>>        Get piItem to iItem
95717>>>>>        Set Value to sConnectionData[iItem]
95718>>>>>    End_Procedure
95719>>>>>
95719>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95721>>>>>        String sValue
95721>>>>>        Integer iItem
95721>>>>>        Get piItem to iItem
95722>>>>>        Get Value to sValue
95723>>>>>        Move sValue to sConnectionData[iItem]
95724>>>>>    End_Procedure
95725>>>>>
95725>>>>>//    Procedure Set psToolTip String sToolTip
95725>>>>>//        String sStatusHelp
95725>>>>>//
95725>>>>>//        Get Status_Help to sStatusHelp
95725>>>>>//        If (sStatusHelp = "") Begin
95725>>>>>//            Set Status_Help to sToolTip
95725>>>>>//        End
95725>>>>>//
95725>>>>>//        Forward Set psToolTip to sToolTip
95725>>>>>//    End_Procedure
95725>>>>>//
95725>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
95725>>>>>//    // The bug being that the focus rectangle doesn't show.
95725>>>>>//    Procedure Page Integer iPageObject
95725>>>>>//        Handle hWnd
95725>>>>>//        Integer iRet iState
95725>>>>>//
95725>>>>>//        Forward Send Page iPageObject
95725>>>>>//
95725>>>>>//        If (iPageObject) Begin
95725>>>>>//            Get Window_Handle to hWnd
95725>>>>>//            If (hWnd) Begin
95725>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95725>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
95725>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95725>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95725>>>>>//                End
95725>>>>>//            End
95725>>>>>//        End
95725>>>>>//    End_Procedure
95725>>>>>
95725>>>>>End_Class
95726>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
95726>>>>>Use Windows.pkg
95726>>>>>
95726>>>>>Class cSQLForm is a Form
95727>>>>>    Procedure Construct_Object
95729>>>>>        Forward Send Construct_Object
95731>>>>>
95731>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
95731>>>>>        Property Boolean pbAutoShadowLabelObject True
95732>>>>>
95732>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95732>>>>>        Property Integer piItem
95733>>>>>
95733>>>>>        Set Label_Justification_Mode to JMode_Right
95734>>>>>        Set Label_Col_Offset to 2
95735>>>>>    End_Procedure
95736>>>>>
95736>>>>>    Procedure End_Construct_Object
95738>>>>>        Boolean bAutoShadowLabelObject
95738>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95739>>>>>        If (bAutoShadowLabelObject = True) Begin
95741>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95742>>>>>        End
95742>>>>>>
95742>>>>>        Forward Send End_Construct_Object
95744>>>>>    End_Procedure
95745>>>>>
95745>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95747>>>>>    End_Procedure
95748>>>>>
95748>>>>>    Procedure ReadConnectionData String[] sConnectionData
95750>>>>>        Integer iItem
95750>>>>>        Get piItem to iItem
95751>>>>>        Set Value to sConnectionData[iItem]
95752>>>>>    End_Procedure
95753>>>>>
95753>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95755>>>>>        String sValue
95755>>>>>        Integer iItem
95755>>>>>        Get piItem to iItem
95756>>>>>        Get Value to sValue
95757>>>>>        Move sValue to sConnectionData[iItem]
95758>>>>>    End_Procedure
95759>>>>>
95759>>>>>    Procedure Set psToolTip String sToolTip
95761>>>>>        String sStatusHelp
95761>>>>>
95761>>>>>        Get Status_Help to sStatusHelp
95762>>>>>        If (sStatusHelp = "") Begin
95764>>>>>            Set Status_Help to sToolTip
95765>>>>>        End
95765>>>>>>
95765>>>>>
95765>>>>>        Forward Set psToolTip to sToolTip
95767>>>>>    End_Procedure
95768>>>>>
95768>>>>>End_Class
95769>>>Use cSQLConnectionHandler.pkg
95769>>>Use cDbUpdateFunctionLibrary.pkg
95769>>>Use cDbUpdateDatabaseDriver.pkg
95769>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95769>>>>>Use Windows.pkg
95769>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridPromptList.pkg)
95769>>>>>>>Use Windows.pkg
95769>>>>>>>Use cCJGrid.pkg
95769>>>>>>>Use umPromptRelational.pkg
95769>>>>>>>
95769>>>>>>>Class cCJGridPromptList is a cCJGrid
95770>>>>>>>    
95770>>>>>>>    Procedure Construct_Object
95772>>>>>>>        Forward Send Construct_Object
95774>>>>>>>        
95774>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95775>>>>>>>        Property Boolean Private_pbAutoOrdering True
95776>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95777>>>>>>>        Property Integer peUpdateMode umPromptValue
95778>>>>>>>        Property Integer piUpdateColumn 0
95779>>>>>>>        Property Integer piInitialColumn -1
95780>>>>>>>        Property String  psSeedValue ''
95781>>>>>>>        Property Handle phmPromptUpdateCallback 0
95782>>>>>>>        Property Integer phoInvokingObject
95783>>>>>>>        
95783>>>>>>>        Property Boolean pbStoredAutoSeed
95784>>>>>>>        Property Boolean pbStoredAutoOrdering
95785>>>>>>>        Property Boolean pbStoredAutoSearch
95786>>>>>>>        Property Integer peStoredUpdateMode
95787>>>>>>>        Property Integer piStoredUpdateColumn
95788>>>>>>>        Property Integer piStoredInitialColumn
95789>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
95790>>>>>>>        Property Boolean pbStoredSelectionEnable
95791>>>>>>>        Property Boolean pbStoredMultipleSelection
95792>>>>>>>        
95792>>>>>>>        // internally set by list
95792>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
95792>>>>>>>        Property Boolean pbCanceled
95793>>>>>>>        Property Integer[] pSelectedRows
95794>>>>>>>        
95794>>>>>>>        Property Boolean pbNeedsNewOrdering
95795>>>>>>>        Property Boolean pbRequestSearch
95796>>>>>>>        Property tGridKeyPair[] pSearchKeys
95797>>>>>>>        
95797>>>>>>>        // these properties makes a prompt list a prompt list
95797>>>>>>>        // and should not be changed.
95797>>>>>>>        Set pbEditOnKeyNavigation to False
95798>>>>>>>        Set pbEditOnClick to False
95799>>>>>>>        Set pbReadOnly to True
95800>>>>>>>        Set pbFocusSubItems to True
95801>>>>>>>        
95801>>>>>>>        // these could maybe be changed
95801>>>>>>>        Set pbShadeSortColumn to True
95802>>>>>>>        Set pbHeaderReorders to True
95803>>>>>>>        Set pbHeaderTogglesDirection to True
95804>>>>>>>        Set pbHeaderSelectsColumn to True
95805>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95806>>>>>>>        Set piFocusCellBackColor to clNone
95807>>>>>>>        Set piFocusCellForeColor to clNone
95808>>>>>>>        Set piFocusCellRectangleColor to clBlack
95809>>>>>>>        Set pbUseFocusCellRectangle to False
95810>>>>>>>        Set pbSelectionEnable to True
95811>>>>>>>        
95811>>>>>>>        On_Key kEnter Send Ok
95812>>>>>>>        On_Key kCancel Send Cancel
95813>>>>>>>        
95813>>>>>>>    End_Procedure
95814>>>>>>>    
95814>>>>>>>    // reorder list automatically on column change
95814>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95814>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95816>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95817>>>>>>>        Set pbFocusSubItems to bAutoOrder
95818>>>>>>>    End_Procedure
95819>>>>>>>    
95819>>>>>>>    Function pbAutoOrdering Returns Boolean
95821>>>>>>>        Boolean bAutoOrder
95821>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95822>>>>>>>        Function_Return bAutoOrder
95823>>>>>>>    End_Function
95824>>>>>>>    
95824>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95824>>>>>>>    Procedure OnIdle
95826>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95826>>>>>>>        Handle hoCol
95826>>>>>>>        Integer iKy1 iKy2 iCol
95826>>>>>>>        
95826>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95827>>>>>>>        If bNeedsReorder Begin
95829>>>>>>>            Get SelectedColumn to iCol
95830>>>>>>>            If (iCol<>-1) Begin
95832>>>>>>>                
95832>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95833>>>>>>>                Set pbHeaderTogglesDirection to False
95834>>>>>>>                Send HeaderReorder iCol
95835>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95836>>>>>>>                
95836>>>>>>>                Set pbNeedsNewOrdering to False
95837>>>>>>>            End
95837>>>>>>>>
95837>>>>>>>        End
95837>>>>>>>>
95837>>>>>>>        
95837>>>>>>>        Get pbRequestSearch to bSearch
95838>>>>>>>        If bSearch Begin
95840>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95841>>>>>>>        End
95841>>>>>>>>
95841>>>>>>>        
95841>>>>>>>        Forward Send OnIdle
95843>>>>>>>    End_Procedure
95844>>>>>>>    
95844>>>>>>>    Procedure OnStoreDefaults
95846>>>>>>>        Integer iVal
95846>>>>>>>        Boolean bVal
95846>>>>>>>        
95846>>>>>>>        Get pbAutoSeed to bVal
95847>>>>>>>        Set pbStoredAutoSeed to bVal
95848>>>>>>>        
95848>>>>>>>        Get pbAutoOrdering to bVal
95849>>>>>>>        Set pbStoredAutoOrdering to bVal
95850>>>>>>>        
95850>>>>>>>        Get pbAutoSearch to bVal
95851>>>>>>>        Set pbStoredAutoSearch to bVal
95852>>>>>>>        
95852>>>>>>>        Get peUpdateMode to iVal
95853>>>>>>>        Set peStoredUpdateMode to iVal
95854>>>>>>>        
95854>>>>>>>        Get piUpdateColumn to iVal
95855>>>>>>>        Set piStoredUpdateColumn to iVal
95856>>>>>>>        
95856>>>>>>>        Get piInitialColumn to iVal
95857>>>>>>>        Set piStoredInitialColumn to iVal
95858>>>>>>>        
95858>>>>>>>        Get phmPromptUpdateCallback to iVal
95859>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
95860>>>>>>>        
95860>>>>>>>        Get pbSelectionEnable to bVal
95861>>>>>>>        Set pbStoredSelectionEnable to bVal
95862>>>>>>>        
95862>>>>>>>        Get pbMultipleSelection to bVal
95863>>>>>>>        Set pbStoredMultipleSelection to bVal
95864>>>>>>>        
95864>>>>>>>    End_Procedure
95865>>>>>>>    
95865>>>>>>>    Procedure OnRestoreDefaults
95867>>>>>>>        Integer iVal
95867>>>>>>>        Boolean bVal
95867>>>>>>>        
95867>>>>>>>        Get pbStoredAutoSeed to bVal
95868>>>>>>>        Set pbAutoSeed to bVal
95869>>>>>>>        
95869>>>>>>>        Get pbStoredAutoOrdering to bVal
95870>>>>>>>        Set pbAutoOrdering to bVal
95871>>>>>>>        
95871>>>>>>>        Get pbStoredAutoSearch to bVal
95872>>>>>>>        Set pbAutoSearch to bVal
95873>>>>>>>        
95873>>>>>>>        Get peStoredUpdateMode to iVal
95874>>>>>>>        Set peUpdateMode to iVal
95875>>>>>>>        
95875>>>>>>>        Get piStoredInitialColumn to iVal
95876>>>>>>>        Set piInitialColumn to iVal
95877>>>>>>>        
95877>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
95878>>>>>>>        Set phmPromptUpdateCallback to iVal
95879>>>>>>>        
95879>>>>>>>        Get pbStoredSelectionEnable to bVal
95880>>>>>>>        Set pbSelectionEnable to bVal
95881>>>>>>>        
95881>>>>>>>        Get pbStoredMultipleSelection to bVal
95882>>>>>>>        Set pbMultipleSelection to bVal
95883>>>>>>>        
95883>>>>>>>    End_Procedure
95884>>>>>>>    
95884>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95884>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95884>>>>>>>    // Suitable for augmentation
95884>>>>>>>    Procedure OnSeedData
95886>>>>>>>        Integer iUpdateColumn iSortColumn
95886>>>>>>>        Boolean bSeed bAuto
95886>>>>>>>        String sValue
95886>>>>>>>        Handle hoCol
95886>>>>>>>        
95886>>>>>>>        Get piUpdateColumn to iUpdateColumn
95887>>>>>>>        Get psSeedValue to sValue
95888>>>>>>>        Get pbAutoSeed to bSeed
95889>>>>>>>        Get piSortColumn to iSortColumn
95890>>>>>>>        Get pbAutoOrdering to bAuto
95891>>>>>>>        // if not yet sorted and this is auto ordering we will
95891>>>>>>>        // sort the data for the search column. We do this to make the
95891>>>>>>>        // column search GE logic work properly.
95891>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95893>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
95894>>>>>>>            Send SortGridByColumn hoCol False
95895>>>>>>>        End
95895>>>>>>>>
95895>>>>>>>        
95895>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95897>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95898>>>>>>>        End
95898>>>>>>>>
95898>>>>>>>        Else Begin
95899>>>>>>>            Send MovetoFirstRow
95900>>>>>>>        End
95900>>>>>>>>
95900>>>>>>>        
95900>>>>>>>    End_Procedure
95901>>>>>>>    
95901>>>>>>>    Procedure OnMoveValueOutByValue
95903>>>>>>>        String sValue
95903>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95903>>>>>>>        Integer iRow iCol
95903>>>>>>>        Integer[] SelRowsIndexes
95904>>>>>>>        
95904>>>>>>>        Get phoInvokingObject to hoInvokingObject
95905>>>>>>>        Get pSelectedRows to SelRowsIndexes
95906>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95908>>>>>>>            Get piUpdateColumn to iCol
95909>>>>>>>            Get ColumnObject iCol to hoCol
95910>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95911>>>>>>>            Set Value of hoInvokingObject to sValue
95912>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
95913>>>>>>>        End
95913>>>>>>>>
95913>>>>>>>    End_Procedure
95914>>>>>>>    
95914>>>>>>>    Procedure OnMoveValueOutByCustom
95916>>>>>>>    End_Procedure
95917>>>>>>>    
95917>>>>>>>    // augment to popup a search window when allowed
95917>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95919>>>>>>>        Boolean bSubFocus bAutoSearch bChar
95919>>>>>>>        Integer iVal
95919>>>>>>>        
95919>>>>>>>        Get pbFocusSubItems to bSubFocus
95920>>>>>>>        Get pbAutoSearch to bAutoSearch
95921>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95923>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95925>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95927>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95928>>>>>>>                Move (iVal<>0) to bChar
95929>>>>>>>            End
95929>>>>>>>>
95929>>>>>>>            If bChar Begin
95931>>>>>>>                // this can get called multiple times before a search dialog pops up
95931>>>>>>>                Send AddToSearchKeys llKeyCode llShift
95932>>>>>>>            End
95932>>>>>>>>
95932>>>>>>>        End
95932>>>>>>>>
95932>>>>>>>    End_Procedure
95933>>>>>>>    
95933>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95935>>>>>>>        Boolean bAutoSearch
95935>>>>>>>        Integer iKeyCode iShiftCode
95935>>>>>>>        Get pbAutoSearch to bAutoSearch
95936>>>>>>>        If bAutoSearch Begin
95938>>>>>>>            // this can get called multiple times before a search dialog pops up
95938>>>>>>>            Get piLastKey to iKeyCode
95939>>>>>>>            Get piLastKey2 to iShiftCode
95940>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95941>>>>>>>        End
95941>>>>>>>>
95941>>>>>>>        Move True to llCancel
95942>>>>>>>    End_Procedure
95943>>>>>>>    
95943>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95945>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
95946>>>>>>>        Forward Send OnComRowDblClick llRow llItem
95948>>>>>>>    End_Procedure
95949>>>>>>>    
95949>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95951>>>>>>>        Send Ok
95952>>>>>>>    End_Procedure
95953>>>>>>>    
95953>>>>>>>    
95953>>>>>>>    // we don't want a menu for prompt lists
95953>>>>>>>    Function CreateContextMenu Returns Handle
95955>>>>>>>        Function_Return 0
95956>>>>>>>    End_Function
95957>>>>>>>    
95957>>>>>>>    // if we use auto-ordering, change the order when the column changes
95957>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95959>>>>>>>        Boolean bAutoOrder
95959>>>>>>>        Forward Send ColumnChanged iOld iNew
95961>>>>>>>        Get pbAutoOrdering to bAutoOrder
95962>>>>>>>        If bAutoOrder Begin
95964>>>>>>>            // will be reordered in idle event
95964>>>>>>>            Set pbNeedsNewOrdering to True
95965>>>>>>>        End
95965>>>>>>>>
95965>>>>>>>    End_Procedure
95966>>>>>>>    
95966>>>>>>>    
95966>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95968>>>>>>>        Integer eMode
95968>>>>>>>        Integer[] SelRowsIndexes
95969>>>>>>>        Set pbCanceled to True // assume cancel unless changed
95970>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95971>>>>>>>        Get peUpdateMode to eMode
95972>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
95974>>>>>>>            Send OnStoreDefaults
95975>>>>>>>        End
95975>>>>>>>>
95975>>>>>>>        Send InitializePromptList
95976>>>>>>>        Forward Send Add_Focus hoParent
95978>>>>>>>        Send LoadData
95979>>>>>>>        Set psSeedValue to ""
95980>>>>>>>    End_Procedure
95981>>>>>>>    
95981>>>>>>>    // called before the list is activated.
95981>>>>>>>    Procedure InitializePromptList
95983>>>>>>>        Integer hoInvokingObject
95983>>>>>>>        Boolean bAutoColumn bAutoSeed
95983>>>>>>>        Integer i iOldMode eUpdateMode
95983>>>>>>>        String sValue
95983>>>>>>>        
95983>>>>>>>        Get peUpdateMode to eUpdateMode
95984>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95986>>>>>>>            Get Focus of Desktop to hoInvokingObject
95987>>>>>>>            If (hoInvokingObject<=Desktop) Begin
95989>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95990>>>>>>>>
95990>>>>>>>                Procedure_Return
95991>>>>>>>            End
95991>>>>>>>>
95991>>>>>>>            
95991>>>>>>>            Set phoInvokingObject to hoInvokingObject
95992>>>>>>>            
95992>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
95993>>>>>>>            Get peUpdateMode to eUpdateMode
95994>>>>>>>        End
95994>>>>>>>>
95994>>>>>>>        
95994>>>>>>>        Send ClearSearchRequest // clear the search keys
95995>>>>>>>        Set pbNeedsNewOrdering to False
95996>>>>>>>        
95996>>>>>>>        Get pbAutoSeed to bAutoSeed
95997>>>>>>>        
95997>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
95999>>>>>>>            Get Value of hoInvokingObject to sValue
96000>>>>>>>            Set psSeedValue to sValue
96001>>>>>>>        End
96001>>>>>>>>
96001>>>>>>>        
96001>>>>>>>    End_Procedure
96002>>>>>>>    
96002>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96002>>>>>>>    Procedure LoadData
96004>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96004>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96004>>>>>>>        Integer eUpdateMode
96004>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96004>>>>>>>        
96004>>>>>>>        Get phoDataSource to hoDataSource
96005>>>>>>>        Get peUpdateMode to eUpdateMode
96006>>>>>>>        Get phoInvokingObject to hoInvokingObject
96007>>>>>>>        Get pbAutoSeed to bAutoSeed
96008>>>>>>>        Get piInitialColumn to iInitialColumn
96009>>>>>>>        Get piUpdateColumn to iUpdateColumn
96010>>>>>>>        Get RowCount of hoDataSource to iRows
96011>>>>>>>        
96011>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96011>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96011>>>>>>>        If (iInitialColumn=-1) Begin
96013>>>>>>>            Move iUpdateColumn to iInitialColumn
96014>>>>>>>        End
96014>>>>>>>>
96014>>>>>>>        If (iInitialColumn>=0) Begin
96016>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96017>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96018>>>>>>>        End
96018>>>>>>>>
96018>>>>>>>        Send OnSeedData // find a good starting place for the row
96019>>>>>>>        Get pbFocusSubItems to bSubFocus
96020>>>>>>>        If bSubFocus Begin
96022>>>>>>>            // if column focus, which is normal, go to initialcolumn
96022>>>>>>>            If hoInitialColumn Begin
96024>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96025>>>>>>>            End
96025>>>>>>>>
96025>>>>>>>            Else Begin
96026>>>>>>>                Send MoveToFirstEnterableColumn
96027>>>>>>>            End
96027>>>>>>>>
96027>>>>>>>        End
96027>>>>>>>>
96027>>>>>>>        
96027>>>>>>>    End_Procedure
96028>>>>>>>    
96028>>>>>>>    // This is only called in a successful close
96028>>>>>>>    Procedure ClosePromptList
96030>>>>>>>        Handle hoDataSource hoInvokingObject
96030>>>>>>>        Handle hmCallBack
96030>>>>>>>        Integer iRow eUpdateMode
96030>>>>>>>        Integer[] SelRowsIndexes
96031>>>>>>>        
96031>>>>>>>        Get phoDataSource to hoDataSource
96032>>>>>>>        Get phoInvokingObject to hoInvokingObject
96033>>>>>>>        
96033>>>>>>>        If (pbMultipleSelection(Self)) Begin
96035>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96036>>>>>>>        End
96036>>>>>>>>
96036>>>>>>>        Else Begin
96037>>>>>>>            Get SelectedRow of hoDataSource to iRow
96038>>>>>>>            If (iRow<>-1) Begin
96040>>>>>>>                Move iRow to SelRowsIndexes[0]
96041>>>>>>>            End
96041>>>>>>>>
96041>>>>>>>        End
96041>>>>>>>>
96041>>>>>>>        
96041>>>>>>>        Set pbCanceled to False
96042>>>>>>>        Set pSelectedRows to SelRowsIndexes
96043>>>>>>>        
96043>>>>>>>        Get peUpdateMode to eUpdateMode
96044>>>>>>>        // if non-invoking there is by definition, no move value out
96044>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96046>>>>>>>            
96046>>>>>>>            If (eUpdateMode=umPromptValue) Begin
96048>>>>>>>                Send OnMoveValueOutByValue
96049>>>>>>>            End
96049>>>>>>>>
96049>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96052>>>>>>>                Send OnMoveValueOutByCustom
96053>>>>>>>            End
96053>>>>>>>>
96053>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
96054>>>>>>>            If hmCallBack Begin
96056>>>>>>>                Send hmCallBack of hoInvokingObject Self
96057>>>>>>>            End
96057>>>>>>>>
96057>>>>>>>        End
96057>>>>>>>>
96057>>>>>>>        
96057>>>>>>>        Send Close_Panel
96058>>>>>>>    End_Procedure
96059>>>>>>>    
96059>>>>>>>    // augment to send OnRestoreDefaults.
96059>>>>>>>    Procedure Release_Focus
96061>>>>>>>        Integer eUpdateMode
96061>>>>>>>        Get peUpdateMode to eUpdateMode
96062>>>>>>>        Forward Send Release_Focus
96064>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96066>>>>>>>            Send OnRestoreDefaults
96067>>>>>>>        End
96067>>>>>>>>
96067>>>>>>>    End_Procedure
96068>>>>>>>    
96068>>>>>>>    Function SelectedRowIds Returns RowID[]
96070>>>>>>>        RowID[] SelectedRowids
96071>>>>>>>        Integer[] SelectedRows
96072>>>>>>>        Integer i iRows
96072>>>>>>>        Handle hoDataSource
96072>>>>>>>        Get phoDataSource to hoDataSource
96073>>>>>>>        Get pSelectedRows to SelectedRows
96074>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96075>>>>>>>        For i from 0 to (iRows-1)
96081>>>>>>>>
96081>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96082>>>>>>>        Loop
96083>>>>>>>>
96083>>>>>>>        Function_Return SelectedRowids
96084>>>>>>>    End_Function
96085>>>>>>>    
96085>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96087>>>>>>>        String[] SelectedValues
96088>>>>>>>        Integer[] SelectedRows
96089>>>>>>>        Integer i iRows
96089>>>>>>>        Handle hoCol
96089>>>>>>>        Get ColumnObject iCol to hoCol
96090>>>>>>>        Get pSelectedRows to SelectedRows
96091>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96092>>>>>>>        For i from 0 to (iRows-1)
96098>>>>>>>>
96098>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96099>>>>>>>        Loop
96100>>>>>>>>
96100>>>>>>>        Function_Return SelectedValues
96101>>>>>>>    End_Function
96102>>>>>>>    
96102>>>>>>>    Procedure Ok Returns Integer
96104>>>>>>>        Send ClosePromptList
96105>>>>>>>    End_Procedure
96106>>>>>>>    
96106>>>>>>>    Procedure Cancel Returns Integer
96108>>>>>>>        Send Close_Panel
96109>>>>>>>    End_Procedure
96110>>>>>>>    
96110>>>>>>>    Procedure Search
96112>>>>>>>        Send Activate // give focus back to list so focus things are correct
96113>>>>>>>        Send Request_Search 0 0
96114>>>>>>>    End_Procedure
96115>>>>>>>    
96115>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96115>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96115>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96115>>>>>>>    Procedure Request_SearchEx
96117>>>>>>>        tGridKeyPair[] Keys
96117>>>>>>>        tGridKeyPair[] Keys
96118>>>>>>>        Integer iCol
96118>>>>>>>        Handle hoCol hoSearchDialog
96118>>>>>>>        Boolean bOk
96118>>>>>>>        String sValue
96118>>>>>>>        
96118>>>>>>>        Get piSortColumn to iCol
96119>>>>>>>        If (iCol<>-1) Begin
96121>>>>>>>            Get ColumnObject iCol to hoCol
96122>>>>>>>            Get pSearchKeys to Keys
96123>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96124>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96125>>>>>>>            If bOk Begin
96127>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
96128>>>>>>>            End
96128>>>>>>>>
96128>>>>>>>            Send Destroy of hoSearchDialog
96129>>>>>>>        End
96129>>>>>>>>
96129>>>>>>>        Send ClearSearchRequest // clear the search keys
96130>>>>>>>    End_Procedure
96131>>>>>>>    
96131>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96131>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96133>>>>>>>        tGridKeyPair[] Keys
96133>>>>>>>        tGridKeyPair[] Keys
96134>>>>>>>        tGridKeyPair KeyPair
96134>>>>>>>        tGridKeyPair KeyPair
96134>>>>>>>        Set pbRequestSearch to True
96135>>>>>>>        Move iKeyCode to KeyPair.KeyCode
96136>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
96137>>>>>>>        Get pSearchKeys to Keys
96138>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96139>>>>>>>        Set pSearchKeys to Keys
96140>>>>>>>    End_Procedure
96141>>>>>>>    
96141>>>>>>>    Procedure ClearSearchRequest
96143>>>>>>>        tGridKeyPair[] SearchKeys
96143>>>>>>>        tGridKeyPair[] SearchKeys
96144>>>>>>>        Set pSearchKeys to SearchKeys
96145>>>>>>>        Set pbRequestSearch to False
96146>>>>>>>    End_Procedure
96147>>>>>>>    
96147>>>>>>>End_Class
96148>>>>>>>
96148>>>>>Use cDbUpdateFunctionLibrary.pkg
96148>>>>>Use MSSqldrv.pkg
96148>>>>>Use db2_drv.pkg
96148>>>>>Use odbc_drv.pkg
96148>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\cRDCModalPanel.pkg)
96148>>>>>>>//****************************************************************************
96148>>>>>>>// $Module type: Class
96148>>>>>>>// $Module name: cRDCModalPanel
96148>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96148>>>>>>>// Created     : 2014-03-17 @ 12:33
96148>>>>>>>//
96148>>>>>>>// Description :
96148>>>>>>>//
96148>>>>>>>// $Rev History:
96148>>>>>>>//    2014-03-17  Module header created
96148>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96148>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96148>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96148>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96148>>>>>>>// in the help folder for more details.
96148>>>>>>>//
96148>>>>>>>//****************************************************************************
96148>>>>>>>Use Windows.pkg
96148>>>>>>>Use cCJCommandBarSystem.pkg   
96148>>>>>>>Use cCJSkinFramework.pkg
96148>>>>>>>
96148>>>>>>>Class cRDCModalPanel is a ModalPanel
96149>>>>>>>
96149>>>>>>>    Procedure Construct_Object
96151>>>>>>>        Forward Send Construct_Object
96153>>>>>>>
96153>>>>>>>        Set Maximize_Icon to True
96154>>>>>>>        Set Minimize_Icon to False
96155>>>>>>>        Set Border_Style to Border_Thick
96156>>>>>>>        Set Locate_Mode to Center_On_Parent
96157>>>>>>>
96157>>>>>>>        Property String Private_Icon
96158>>>>>>>        Property Handle phoDialogCommandbar
96159>>>>>>>    End_Procedure
96160>>>>>>>
96160>>>>>>>    Procedure Set Icon String sIcon
96162>>>>>>>        Forward Set Icon to sIcon
96164>>>>>>>        Set Private_Icon to sIcon
96165>>>>>>>    End_Procedure
96166>>>>>>>
96166>>>>>>>    Function Icon Returns String
96168>>>>>>>        String sIcon
96168>>>>>>>        Get Private_Icon to sIcon
96169>>>>>>>        Function_Return sIcon
96170>>>>>>>    End_Function
96171>>>>>>>
96171>>>>>>>    Procedure Page Integer iPageObject
96173>>>>>>>        String sIcon
96173>>>>>>>        Integer hWnd
96173>>>>>>>        
96173>>>>>>>        Forward Send Page iPageObject
96175>>>>>>>        Get Private_Icon to sIcon
96176>>>>>>>        If (sIcon <> "") Begin
96178>>>>>>>            Set Icon to sIcon
96179>>>>>>>        End
96179>>>>>>>>
96179>>>>>>>
96179>>>>>>>        Get Window_Handle to hWnd
96180>>>>>>>
96180>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96182>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96183>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96184>>>>>>>        End
96184>>>>>>>>
96184>>>>>>>    End_Procedure
96185>>>>>>>
96185>>>>>>>    // Put a status bar at the bottom of the panel, which makes
96185>>>>>>>    // status_help work and puts a gripper in the lower right corner.
96185>>>>>>>    Procedure End_Construct_Object
96187>>>>>>>        Integer iStyle iSize iOffset
96187>>>>>>>
96187>>>>>>>        Forward Send End_Construct_Object
96189>>>>>>>
96189>>>>>>>        Get Border_Style to iStyle
96190>>>>>>>        Move 8 to iOffset
96191>>>>>>>        If (iStyle = Border_Thick) Begin
96193>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96195>>>>>>>                Object oStatusBar is a cCJStatusBar
96197>>>>>>>                    Set phoDialogCommandbar to Self
96198>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96200>>>>>>>                        Set piId to sbpIDIdlePane
96201>>>>>>>                        Set pbStyleStretch to True
96202>>>>>>>                    End_Object
96203>>>>>>>                End_Object
96204>>>>>>>            End_Object
96205>>>>>>>            Get Size to iSize
96206>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96207>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96208>>>>>>>        End
96208>>>>>>>>
96208>>>>>>>
96208>>>>>>>    End_Procedure
96209>>>>>>>
96209>>>>>>>    Procedure Popup
96211>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96212>>>>>>>        Forward Send Popup
96214>>>>>>>    End_Procedure
96215>>>>>>>
96215>>>>>>>End_Class
96216>>>>>
96216>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96218>>>>>    Set Label to "SQL Database Selection"
96219>>>>>    Set Size to 119 183
96220>>>>>    Set piMinSize to 89 170
96221>>>>>    Set Location to 2 2
96222>>>>>    Set Border_Style to Border_Thick
96223>>>>>    Set Icon to "DatabaseLookup1.ico"
96224>>>>>
96224>>>>>    Property String[] psTheData
96226>>>>>
96226>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96228>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96230>>>>>        End_Object
96231>>>>>    End
96231>>>>>>
96231>>>>>
96231>>>>>    Object oSelList is a cCJGridPromptList
96233>>>>>        Set Size to 89 167
96234>>>>>        Set Location to 6 6
96235>>>>>        Set peAnchors to anAll
96236>>>>>        Set pbAllowColumnRemove to False
96237>>>>>        Set pbUseAlternateRowBackgroundColor to True
96238>>>>>        Set pbGrayIfDisable to False
96239>>>>>        Set pbHeaderReorders to False
96240>>>>>        Set pbHeaderSelectsColumn to False
96241>>>>>        Set pbHeaderTogglesDirection to False
96242>>>>>        Set pbShadeSortColumn to False
96243>>>>>        Set piFocusCellBackColor to clDkGray
96244>>>>>
96244>>>>>        Object oName is a cCJGridColumn
96246>>>>>            Set piWidth to 334
96247>>>>>            Set psCaption to "Database Name"
96248>>>>>        End_Object
96249>>>>>
96249>>>>>        Procedure Activating
96252>>>>>            tDataSourceRow[] MyData
96252>>>>>            tDataSourceRow[] MyData
96253>>>>>            Handle hoDataSource
96253>>>>>            String[] sTheData
96254>>>>>            Integer iCount iSize
96254>>>>>
96254>>>>>            Send Cursor_Wait of Cursor_Control
96255>>>>>            Forward Send Activating
96257>>>>>
96257>>>>>            Get psTheData to sTheData
96258>>>>>            Move (SizeOfArray(sTheData)) to iSize
96259>>>>>            Decrement iSize
96260>>>>>            For iCount from 0 to iSize
96266>>>>>>
96266>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96267>>>>>            Loop
96268>>>>>>
96268>>>>>
96268>>>>>            Get phoDataSource to hoDataSource
96269>>>>>            Send InitializeData of hoDataSource MyData
96270>>>>>            Send Cursor_Ready of Cursor_Control
96271>>>>>        End_Procedure
96272>>>>>
96272>>>>>    End_Object
96273>>>>>
96273>>>>>    Object oOK_Btn is a Button
96275>>>>>        Set Size to 14 50
96276>>>>>        Set Label    to "&OK"
96277>>>>>        Set Location to 98 68
96278>>>>>        Set peAnchors To anBottomRight
96279>>>>>
96279>>>>>        Procedure OnClick
96282>>>>>            Send Ok of oSelList
96283>>>>>        End_Procedure
96284>>>>>
96284>>>>>    End_Object
96285>>>>>
96285>>>>>    Object oCancel_Btn is a Button
96287>>>>>        Set Size to 14 50
96288>>>>>        Set Label    to "&Cancel"
96289>>>>>        Set Location to 98 123
96290>>>>>        Set peAnchors to anBottomRight
96291>>>>>
96291>>>>>        Procedure OnClick
96294>>>>>            Send Close_Panel
96295>>>>>        End_Procedure
96296>>>>>
96296>>>>>    End_Object
96297>>>>>
96297>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96298>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96299>>>>>End_Object
96300>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
96300>>>>>Use Windows.pkg
96300>>>>>Use cCJGridPromptList.pkg
96300>>>>>Use MSSqldrv.pkg
96300>>>>>Use db2_drv.pkg
96300>>>>>Use odbc_drv.pkg    
96300>>>>>Use cRDCModalPanel.pkg
96300>>>>>Use cDbUpdateFunctionLibrary.pkg
96300>>>>>
96300>>>>>Object oServerSelection_sl is a cRDCModalPanel
96302>>>>>    Set Size to 105 225
96303>>>>>    Set Label to "Database Server/DSN Selection"
96304>>>>>    Set piMinSize to 89 211
96305>>>>>    Set Location to 2 2
96306>>>>>    Set Icon to "ServerLookup1.ico"
96307>>>>>
96307>>>>>    Property String[] psTheData
96309>>>>>
96309>>>>>    Object oSelList is a cCJGridPromptList
96311>>>>>        Set Size to 72 215
96312>>>>>        Set Location to 6 6
96313>>>>>        Set peAnchors to anAll
96314>>>>>        Set pbAllowColumnRemove to False
96315>>>>>        Set pbUseAlternateRowBackgroundColor to True
96316>>>>>        Set pbGrayIfDisable to False
96317>>>>>        Set pbHeaderReorders to False
96318>>>>>        Set pbHeaderSelectsColumn to False
96319>>>>>        Set pbHeaderTogglesDirection to False
96320>>>>>        Set pbShadeSortColumn to False
96321>>>>>        Set piFocusCellBackColor to clDkGray
96322>>>>>
96322>>>>>        Object oName is a cCJGridColumn
96324>>>>>            Set piWidth to 358
96325>>>>>            Set psCaption to "Name"
96326>>>>>        End_Object
96327>>>>>
96327>>>>>        Procedure Activating
96330>>>>>            tDataSourceRow[] MyData
96330>>>>>            tDataSourceRow[] MyData
96331>>>>>            Handle hoDataSource
96331>>>>>            String[] sTheData
96332>>>>>            Integer iCount iSize
96332>>>>>
96332>>>>>            Send Cursor_Wait of Cursor_Control
96333>>>>>            Get psTheData to sTheData
96334>>>>>            Move (SizeOfArray(sTheData)) to iSize
96335>>>>>            Decrement iSize
96336>>>>>            For iCount from 0 to iSize
96342>>>>>>
96342>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96343>>>>>            Loop
96344>>>>>>
96344>>>>>
96344>>>>>            Forward Send Activating
96346>>>>>
96346>>>>>            Get phoDataSource to hoDataSource
96347>>>>>            Send InitializeData of hoDataSource MyData
96348>>>>>            Send Cursor_Ready of Cursor_Control
96349>>>>>        End_Procedure
96350>>>>>
96350>>>>>    End_Object
96351>>>>>
96351>>>>>    Object oOK_Btn is a Button
96353>>>>>        Set Size to 14 50
96354>>>>>        Set Label    to "&OK"
96355>>>>>        Set Location to 85 116
96356>>>>>        Set peAnchors To anBottomRight
96357>>>>>
96357>>>>>        Procedure OnClick
96360>>>>>            Send Ok of oSelList
96361>>>>>        End_Procedure
96362>>>>>
96362>>>>>    End_Object
96363>>>>>
96363>>>>>    Object oCancel_Btn is a Button
96365>>>>>        Set Size to 14 50
96366>>>>>        Set Label    to "&Cancel"
96367>>>>>        Set Location to 85 171
96368>>>>>        Set peAnchors to anBottomRight
96369>>>>>
96369>>>>>        Procedure OnClick
96372>>>>>            Send Close_Panel
96373>>>>>        End_Procedure
96374>>>>>
96374>>>>>    End_Object
96375>>>>>
96375>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96376>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96377>>>>>End_Object
96378>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
96378>>>>>Use Windows.pkg
96378>>>>>Use cCJGridPromptList.pkg     
96378>>>>>Use cRDCModalPanel.pkg
96378>>>>>Use cDbUpdateFunctionLibrary.pkg
96378>>>>>
96378>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
96380>>>>>    Set Size to 118 177
96381>>>>>    Set Label to "SQL Tablespace Selection"
96382>>>>>    Set piMinSize to 89 177
96383>>>>>    Set Location to 2 2
96384>>>>>    Set Icon to "DatabaseLookup1.ico"
96385>>>>>
96385>>>>>    Property String[] psTheData
96387>>>>>
96387>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
96387>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96387>>>>>//        End_Object
96387>>>>>//    End
96387>>>>>
96387>>>>>    Object oSelList is a cCJGridPromptList
96389>>>>>        Set Size to 89 167
96390>>>>>        Set Location to 6 6
96391>>>>>        Set peAnchors to anAll
96392>>>>>        Set pbAllowColumnRemove to False
96393>>>>>        Set pbUseAlternateRowBackgroundColor to True
96394>>>>>        Set pbGrayIfDisable to False
96395>>>>>        Set pbHeaderReorders to False
96396>>>>>        Set pbHeaderSelectsColumn to False
96397>>>>>        Set pbHeaderTogglesDirection to False
96398>>>>>        Set pbShadeSortColumn to False
96399>>>>>        Set piFocusCellBackColor to clDkGray
96400>>>>>
96400>>>>>        Object oName is a cCJGridColumn
96402>>>>>            Set piWidth to 334
96403>>>>>            Set psCaption to "Table Space Name"
96404>>>>>        End_Object
96405>>>>>
96405>>>>>        Procedure Activating
96408>>>>>            tDataSourceRow[] MyData
96408>>>>>            tDataSourceRow[] MyData
96409>>>>>            Handle hoDataSource
96409>>>>>            String[] sTheData
96410>>>>>            Integer iCount iSize
96410>>>>>
96410>>>>>            Send Cursor_Wait of Cursor_Control
96411>>>>>            Forward Send Activating
96413>>>>>
96413>>>>>            Get psTheData to sTheData
96414>>>>>            Move (SizeOfArray(sTheData)) to iSize
96415>>>>>            Decrement iSize
96416>>>>>            For iCount from 0 to iSize
96422>>>>>>
96422>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96423>>>>>            Loop
96424>>>>>>
96424>>>>>
96424>>>>>            Get phoDataSource to hoDataSource
96425>>>>>            Send InitializeData of hoDataSource MyData
96426>>>>>            Send Cursor_Ready of Cursor_Control
96427>>>>>        End_Procedure
96428>>>>>
96428>>>>>    End_Object
96429>>>>>
96429>>>>>    Object oOK_Btn is a Button
96431>>>>>        Set Size to 14 50
96432>>>>>        Set Label    to "&OK"
96433>>>>>        Set Location to 98 68
96434>>>>>        Set peAnchors To anBottomRight
96435>>>>>
96435>>>>>        Procedure OnClick
96438>>>>>            Send Ok of oSelList
96439>>>>>        End_Procedure
96440>>>>>
96440>>>>>    End_Object
96441>>>>>
96441>>>>>    Object oCancel_Btn is a Button
96443>>>>>        Set Size to 14 50
96444>>>>>        Set Label    to "&Cancel"
96445>>>>>        Set Location to 98 123
96446>>>>>        Set peAnchors to anBottomRight
96447>>>>>
96447>>>>>        Procedure OnClick
96450>>>>>            Send Close_Panel
96451>>>>>        End_Procedure
96452>>>>>
96452>>>>>    End_Object
96453>>>>>
96453>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96454>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96455>>>>>End_Object
96456>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
96456>>>>>Use Windows.pkg
96456>>>>>Use cCJGridPromptList.pkg  
96456>>>>>Use cRDCModalPanel.pkg
96456>>>>>Use cDbUpdateFunctionLibrary.pkg
96456>>>>>
96456>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
96458>>>>>    Set Size to 118 177
96459>>>>>    Set Label to "SQL Schemas Selection"
96460>>>>>    Set piMinSize to 89 177
96461>>>>>    Set Location to 2 2
96462>>>>>    Set Icon to "DatabaseLookup1.ico"
96463>>>>>
96463>>>>>    Property String[] psTheData
96465>>>>>
96465>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96467>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96469>>>>>        End_Object
96470>>>>>    End
96470>>>>>>
96470>>>>>
96470>>>>>    Object oSelList is a cCJGridPromptList
96472>>>>>        Set Size to 89 167
96473>>>>>        Set Location to 6 6
96474>>>>>        Set peAnchors to anAll
96475>>>>>        Set pbAllowColumnRemove to False
96476>>>>>        Set pbUseAlternateRowBackgroundColor to True
96477>>>>>        Set pbGrayIfDisable to False
96478>>>>>        Set pbHeaderReorders to False
96479>>>>>        Set pbHeaderSelectsColumn to False
96480>>>>>        Set pbHeaderTogglesDirection to False
96481>>>>>        Set pbShadeSortColumn to False
96482>>>>>        Set piFocusCellBackColor to clDkGray
96483>>>>>
96483>>>>>        Object oName is a cCJGridColumn
96485>>>>>            Set piWidth to 334
96486>>>>>            Set psCaption to "Schema Name"
96487>>>>>        End_Object
96488>>>>>
96488>>>>>        Procedure Activating
96491>>>>>            tDataSourceRow[] MyData
96491>>>>>            tDataSourceRow[] MyData
96492>>>>>            Handle hoDataSource
96492>>>>>            String[] sTheData
96493>>>>>            Integer iCount iSize
96493>>>>>
96493>>>>>            Send Cursor_Wait of Cursor_Control
96494>>>>>            Forward Send Activating
96496>>>>>
96496>>>>>            Get psTheData to sTheData
96497>>>>>
96497>>>>>            Move (SizeOfArray(sTheData)) to iSize
96498>>>>>            Decrement iSize
96499>>>>>            For iCount from 0 to iSize
96505>>>>>>
96505>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96506>>>>>            Loop
96507>>>>>>
96507>>>>>
96507>>>>>            Get phoDataSource to hoDataSource
96508>>>>>            Send InitializeData of hoDataSource MyData
96509>>>>>            Send Cursor_Ready of Cursor_Control
96510>>>>>        End_Procedure
96511>>>>>
96511>>>>>    End_Object
96512>>>>>
96512>>>>>    Object oOK_Btn is a Button
96514>>>>>        Set Size to 14 50
96515>>>>>        Set Label    to "&OK"
96516>>>>>        Set Location to 98 68
96517>>>>>        Set peAnchors To anBottomRight
96518>>>>>
96518>>>>>        Procedure OnClick
96521>>>>>            Send Ok of oSelList
96522>>>>>        End_Procedure
96523>>>>>
96523>>>>>    End_Object
96524>>>>>
96524>>>>>    Object oCancel_Btn is a Button
96526>>>>>        Set Size to 14 50
96527>>>>>        Set Label    to "&Cancel"
96528>>>>>        Set Location to 98 123
96529>>>>>        Set peAnchors to anBottomRight
96530>>>>>
96530>>>>>        Procedure OnClick
96533>>>>>            Send Close_Panel
96534>>>>>        End_Procedure
96535>>>>>
96535>>>>>    End_Object
96536>>>>>
96536>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96537>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96538>>>>>End_Object
96539>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCHeaderGroup.pkg)
96539>>>>>//****************************************************************************
96539>>>>>// $Module type: Package
96539>>>>>// $Module name: cRDCHeaderGroup.pkg
96539>>>>>//
96539>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96539>>>>>// Copyright (c) 2017 RDC Tools International
96539>>>>>// E-mail      : support@rdctools.com
96539>>>>>// Web-site    : http://www.rdctools.com
96539>>>>>//
96539>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
96539>>>>>//
96539>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96539>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96539>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96539>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96539>>>>>// in the help folder for more details.
96539>>>>>//
96539>>>>>//****************************************************************************
96539>>>>>Use Windows.pkg
96539>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCommandLinkButton.pkg)
96539>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
96539>>>>>>>// older versions you will just get a regular great big button.
96539>>>>>>>
96539>>>>>>>Use Windows.pkg
96539>>>>>>>Use CharTranslate.pkg
96539>>>>>>>
96539>>>>>>>Class cCommandLinkButton is a Button
96540>>>>>>>    
96540>>>>>>>    Procedure Construct_Object
96542>>>>>>>        Forward Send Construct_Object
96544>>>>>>>        Property String psPrivateNote
96545>>>>>>>    End_Procedure
96546>>>>>>>    
96546>>>>>>>    Procedure Set psNote String sNote
96548>>>>>>>        Boolean bSupported
96548>>>>>>>        Set psPrivateNote to sNote
96549>>>>>>>        Get IsExControlSupported to bSupported
96550>>>>>>>        If bSupported Begin
96552>>>>>>>            Send SetWinNote
96553>>>>>>>        End
96553>>>>>>>>
96553>>>>>>>    End_Procedure
96554>>>>>>>    
96554>>>>>>>    Procedure SetWinNote
96556>>>>>>>        WString wNote
96556>>>>>>>        Handle hWnd
96556>>>>>>>        Integer i
96556>>>>>>>        Pointer pVar
96556>>>>>>>        Get Form_Window_Handle 0 to hWnd
96557>>>>>>>        If hWnd Begin
96559>>>>>>>            Get psNote to wNote
96560>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
96561>>>>>>>        End
96561>>>>>>>>
96561>>>>>>>    End_Procedure
96562>>>>>>>    
96562>>>>>>>    
96562>>>>>>>    Function psNote Returns String
96564>>>>>>>        Function_Return (psPrivateNote(Self))
96565>>>>>>>    End_Function
96566>>>>>>>    
96566>>>>>>>    
96566>>>>>>>    Procedure Page Integer iState
96568>>>>>>>        Integer i hWnd
96568>>>>>>>        Boolean bSupported
96568>>>>>>>        Get IsExControlSupported to bSupported
96569>>>>>>>        If (iState=1 and bSupported) Begin
96571>>>>>>>            Get form_style i to i
96572>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
96573>>>>>>>            Forward Send Page iState
96575>>>>>>>            Send SetWinNote
96576>>>>>>>        End
96576>>>>>>>>
96576>>>>>>>        Else Begin
96577>>>>>>>            Forward Send Page iState
96579>>>>>>>        End
96579>>>>>>>>
96579>>>>>>>    End_Procedure
96580>>>>>>>    
96580>>>>>>>End_Class
96581>>>>>
96581>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
96581>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
96581>>>>>
96581>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
96582>>>>>    Procedure Construct_Object
96584>>>>>        Forward Send Construct_Object
96586>>>>>
96586>>>>>        Set Size to 18 19
96587>>>>>        Set Focus_Mode to NonFocusable
96588>>>>>        Set peImageAlign to Button_ImageList_Align_Top
96589>>>>>        Set pbAutoResizeIcons to True
96590>>>>>    End_Procedure
96591>>>>>
96591>>>>>    Procedure OnClick
96593>>>>>        Broadcast Send Prompt of (Parent(Self))
96595>>>>>    End_Procedure
96596>>>>>
96596>>>>>    Procedure Set Bitmap String sBitmapName
96598>>>>>        Forward Set psImage to sBitmapName
96600>>>>>    End_Procedure
96601>>>>>
96601>>>>>    Procedure End_Construct_Object
96603>>>>>        Set pbShield to False
96604>>>>>        Forward Send End_Construct_Object
96606>>>>>    End_Procedure
96607>>>>>
96607>>>>>End_Class
96608>>>>>
96608>>>>>// Intermediate class - don't use.
96608>>>>>Class _cRDCHeaderGroup is a Container3d
96609>>>>>
96609>>>>>    Procedure Construct_Object
96611>>>>>        Forward Send Construct_Object
96613>>>>>
96613>>>>>        Property String private.psImage
96614>>>>>        Property String private.psLabel
96615>>>>>
96615>>>>>    End_Procedure
96616>>>>>
96616>>>>>    Procedure Set psImage String sImage
96618>>>>>        Set private.psImage to sImage
96619>>>>>    End_Procedure
96620>>>>>
96620>>>>>    Function psImage Returns String
96622>>>>>        Function_Return (private.psImage(Self))
96623>>>>>    End_Function
96624>>>>>
96624>>>>>    Procedure Set psLabel String sLabel
96626>>>>>        Set private.psLabel to sLabel
96627>>>>>    End_Procedure
96628>>>>>
96628>>>>>    Function psLabel Returns String
96630>>>>>        Function_Return (private.psLabel(Self))
96631>>>>>    End_Function
96632>>>>>
96632>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
96632>>>>>    Procedure Set Label String sLabel
96634>>>>>        Set psLabel to sLabel
96635>>>>>    End_Procedure
96636>>>>>
96636>>>>>    Function Label Returns String
96638>>>>>        Function_Return (private.psLabel(Self))
96639>>>>>    End_Function
96640>>>>>
96640>>>>>End_Class
96641>>>>>
96641>>>>>Register_Procedure NavigatePrevious
96641>>>>>Register_Procedure NavigateNext
96641>>>>>
96641>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
96642>>>>>
96642>>>>>    Procedure Construct_Object
96644>>>>>        Forward Send Construct_Object
96646>>>>>
96646>>>>>        Set peAnchors to anTopLeftRight
96647>>>>>        Set pbAcceptDropFiles to True
96648>>>>>        Set Border_Style to Border_Normal
96649>>>>>
96649>>>>>        Property Integer private.piColorOrg
96650>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
96651>>>>>        Property String private.psToolTip ""
96652>>>>>
96652>>>>>        Property Integer piImageColOffset 4
96653>>>>>        Property Integer piImageRowOffset -1
96654>>>>>        Property String psNote ""
96655>>>>>        Property Boolean pbLargeImageSize True
96656>>>>>        Property Integer private.piLargeImageSize 24
96657>>>>>        Property Integer private.piSmallImageSize 16
96658>>>>>        Property Boolean pbUseHotspotColor False
96659>>>>>        Property Integer piHeaderHotspotColor clAqua
96660>>>>>        Property String private.psLabel ""
96661>>>>>        Property Integer piLabelColor clGreenGrey
96662>>>>>        Property Boolean pbLabelFontItalics False
96663>>>>>        Property Integer piLabelLargeFontHeight 12
96664>>>>>        Property Integer piLabelSmallFontHeight 10
96665>>>>>        Property Boolean pbUseLargeFontHeight False
96666>>>>>
96666>>>>>        Property Integer piLabelFontPointWeight fw_Bold
96667>>>>>        Property Integer piLabelColOffset 28
96668>>>>>        Property Integer piLabelRowOffset 4
96669>>>>>        Property Boolean pbCreateTooltipItem True
96670>>>>>
96670>>>>>        Set pbAcceptDropFiles to True
96671>>>>>
96671>>>>>        Send Define_ToolTip_Support_Mixin
96672>>>>>
96672>>>>>        // For the Studio to render the header image
96672>>>>>        Set Bitmap to "Default32x32.bmp"
96673>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
96673>>>>>        // to render some text in the header when in design mode?
96673>>>>>        Set Label to "HEADER TEXT"
96674>>>>>
96674>>>>>        On_Key kLeftArrow  Send NavigatePrevious
96675>>>>>        On_Key kUpArrow    Send NavigatePrevious
96676>>>>>        On_Key kRightArrow Send NavigateNext
96677>>>>>        On_Key kDownArrow  Send NavigateNext
96678>>>>>        On_Key kSwitch     Send Switch_Next_Area
96679>>>>>    End_Procedure
96680>>>>>
96680>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
96681>>>>>
96681>>>>>    Procedure Set psImage String sImage
96683>>>>>        Set Bitmap to ""
96684>>>>>        Forward Set psImage to sImage
96686>>>>>    End_Procedure
96687>>>>>
96687>>>>>    Function psImage Returns String
96689>>>>>        Function_Return (psImage(Self))
96690>>>>>    End_Function
96691>>>>>
96691>>>>>    Procedure Set Label String sLabel
96693>>>>>        Forward Set psLabel to sLabel
96695>>>>>    End_Procedure
96696>>>>>
96696>>>>>    Procedure Set psToolTip String sToolTip
96698>>>>>        Set private.psToolTip to sToolTip
96699>>>>>    End_Procedure
96700>>>>>
96700>>>>>    Function psToolTip Returns String
96702>>>>>        Function_Return (private.psToolTip(Self))
96703>>>>>    End_Function
96704>>>>>
96704>>>>>    Procedure End_Construct_Object
96706>>>>>        String sNote sLabel
96706>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
96706>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
96706>>>>>
96706>>>>>        Forward Send End_Construct_Object
96708>>>>>
96708>>>>>        Get piLabelColOffset to iLabelColOffset
96709>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
96710>>>>>        If (bUseLargeFontHeight = True) Begin
96712>>>>>            Get piLabelLargeFontHeight to iFontHeight
96713>>>>>            Move 8 to iLabelRowOffset
96714>>>>>        End
96714>>>>>>
96714>>>>>        Else Begin
96715>>>>>            Get piLabelSmallFontHeight to iFontHeight
96716>>>>>            Move 6 to iLabelRowOffset
96717>>>>>        End
96717>>>>>>
96717>>>>>
96717>>>>>        Get pbLargeImageSize to bLargeImageSize
96718>>>>>        If (bLargeImageSize = True) Begin
96720>>>>>            Get private.piLargeImageSize to iImageSize
96721>>>>>        End
96721>>>>>>
96721>>>>>        Else Begin
96722>>>>>            Get private.piSmallImageSize to iImageSize
96723>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
96724>>>>>        End
96724>>>>>>
96724>>>>>
96724>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
96726>>>>>            Set piImageSize to iImageSize
96727>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
96728>>>>>            Set psImage to (private.psImage(Self))
96729>>>>>            Set peImageAlign to Button_ImageList_Align_Center
96730>>>>>            Set psToolTip to (private.psToolTip(Self))
96731>>>>>        End_Object
96732>>>>>
96732>>>>>        Object oHeaderGroupInfo_tb is a TextBox
96734>>>>>            Set Size to 12 100
96735>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
96736>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
96737>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
96738>>>>>            Set FontPointHeight to iFontHeight
96739>>>>>            Set Label to (private.psLabel(Self))
96740>>>>>            Set TextColor to (piLabelColor(Self))
96741>>>>>            Set psToolTip to (private.psToolTip(Self))
96742>>>>>            Get Size to iSize
96743>>>>>        End_Object
96744>>>>>
96744>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
96744>>>>>        // How can it be improved?
96744>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
96745>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
96747>>>>>            Get private.psLabel to sLabel
96748>>>>>            Get Text_Extent sLabel to iTextOffset
96749>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
96750>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
96752>>>>>                Set Size to 10 10
96753>>>>>                If (bUseLargeFontHeight = True) Begin
96755>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
96755>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
96756>>>>>                End
96756>>>>>>
96756>>>>>                Else Begin
96757>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
96757>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
96758>>>>>                End
96758>>>>>>
96758>>>>>                Set psToolTip to (private.psToolTip(Self))
96759>>>>>                Set Bitmap to "ActionAbout.bmp"
96760>>>>>            End_Object
96761>>>>>        End
96761>>>>>>
96761>>>>>
96761>>>>>        Get psNote to sNote
96762>>>>>        If (Trim(sNote) <> "") Begin
96764>>>>>            Object oHeaderGroupNote_tb is a TextBox
96766>>>>>                Set Size to 12 100
96767>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
96768>>>>>                Set Label to ("-" * String(sNote))
96769>>>>>                Set TextColor to (piLabelColor(Self))
96770>>>>>                Set FontPointHeight to 9
96771>>>>>                Set psToolTip to (private.psToolTip(Self))
96772>>>>>            End_Object
96773>>>>>        End
96773>>>>>>
96773>>>>>
96773>>>>>    End_Procedure
96774>>>>>
96774>>>>>    Function Popup_State Returns Boolean
96776>>>>>        Boolean bIsPopup
96776>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
96777>>>>>        Function_Return bIsPopup
96778>>>>>    End_Function
96779>>>>>
96779>>>>>    Procedure OnEnterArea Handle hoFrom
96781>>>>>        Integer iColor
96781>>>>>        Forward Send OnEnterArea hoFrom
96783>>>>>        // Not ideal, but works most of the time.
96783>>>>>        //       When navigating to i.e a popup we don't want
96783>>>>>        //       the coloring to appear. Else there will be 2
96783>>>>>        //       cRDCHeaderGroup's with the highlight color...
96783>>>>>        // Is there a better way?
96783>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
96785>>>>>            Procedure_Return
96786>>>>>        End
96786>>>>>>
96786>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96788>>>>>            Get Color to iColor
96789>>>>>            Set private.piColorOrg to iColor
96790>>>>>            Get piHeaderHotspotColor to iColor
96791>>>>>            Set Color to iColor
96792>>>>>            Broadcast Recursive Set Color to iColor
96794>>>>>        End
96794>>>>>>
96794>>>>>    End_Procedure
96795>>>>>
96795>>>>>    Procedure OnExitArea Handle hoFrom
96797>>>>>        Integer iColor
96797>>>>>        Forward Send OnExitArea hoFrom
96799>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96801>>>>>            Get private.piColorOrg to iColor
96802>>>>>            Set Color to iColor
96803>>>>>            Broadcast Recursive Set Color to iColor
96805>>>>>        End
96805>>>>>>
96805>>>>>    End_Procedure
96806>>>>>
96806>>>>>    // Public access message to change the group header text color at runtime.
96806>>>>>    Procedure Set Label_Color Integer iColor
96808>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
96809>>>>>    End_Procedure
96810>>>>>
96810>>>>>    Procedure NavigatePrevious
96812>>>>>        Integer iMulti ivoid iLastErr
96812>>>>>        Handle hWnd
96812>>>>>        Boolean bErr
96812>>>>>
96812>>>>>        Move Err to bErr
96813>>>>>        Move LastErr to iLastErr
96814>>>>>
96814>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96815>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
96816>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96817>>>>>        If (Err) Begin
96819>>>>>            Move bErr to Err
96820>>>>>            Move iLastErr to LastErr
96821>>>>>            Procedure_Return
96822>>>>>        End
96822>>>>>>
96822>>>>>
96822>>>>>        Move bErr to Err
96823>>>>>        Move iLastErr to LastErr
96824>>>>>        If (iMulti = Multi_Select) Begin
96826>>>>>            Send Previous
96827>>>>>        End
96827>>>>>>
96827>>>>>        Else Begin
96828>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
96829>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
96830>>>>>        End
96830>>>>>>
96830>>>>>    End_Procedure
96831>>>>>
96831>>>>>    Procedure NavigateNext
96833>>>>>        Integer iMulti iVoid iLastErr
96833>>>>>        Handle hWnd
96833>>>>>        Boolean bErr
96833>>>>>
96833>>>>>        Move Err to bErr
96834>>>>>        Move LastErr to iLastErr
96835>>>>>
96835>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96836>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
96837>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96838>>>>>        If (Err) Begin
96840>>>>>            Move bErr to Err
96841>>>>>            Move iLastErr to LastErr
96842>>>>>            Procedure_Return
96843>>>>>        End
96843>>>>>>
96843>>>>>
96843>>>>>        Move bErr to Err
96844>>>>>        Move iLastErr to LastErr
96845>>>>>        If (iMulti = Multi_Select) Begin
96847>>>>>            Send Next
96848>>>>>        End
96848>>>>>>
96848>>>>>        Else Begin
96849>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
96850>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
96851>>>>>        End
96851>>>>>>
96851>>>>>
96851>>>>>    End_Procedure
96852>>>>>
96852>>>>>    Procedure Enable_Window Integer iState
96854>>>>>        Handle hWnd
96854>>>>>        Get Window_Handle to hWnd
96855>>>>>        If hWnd Begin
96857>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
96858>>>>>        End
96858>>>>>>
96858>>>>>    End_Procedure
96859>>>>>
96859>>>>>    Procedure Page_Object Integer iState
96861>>>>>        Handle hWnd
96861>>>>>        Get Window_Handle to hWnd
96862>>>>>        Forward Send Page_Object iState
96864>>>>>        If (hWnd = 0 and iState) Begin
96866>>>>>            Send Shadow_Display
96867>>>>>        End
96867>>>>>>
96867>>>>>    End_Procedure
96868>>>>>
96868>>>>>    Procedure Shadow_Display
96870>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
96871>>>>>    End_Procedure
96872>>>>>
96872>>>>>    Function Explicit_Shadow_State Returns Boolean
96874>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
96875>>>>>    End_Function
96876>>>>>
96876>>>>>    // For some reason we need to augment this event to allow
96876>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
96876>>>>>    // happen.
96876>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
96878>>>>>        Delegate Send OnFileDropped sFilename bLast
96880>>>>>    End_Procedure
96881>>>>>
96881>>>>>End_Class
96882>>>>>
96882>>>>>// We don't want the broadcast of setting color to set the background
96882>>>>>// color for forms that are within a cRDCHeaderGroup object.
96882>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
96882>>>>>// behave as it always has. But if you don't like this; just comment
96882>>>>>// it out.
96882>>>>>//Procedure Set Color for Form Integer eColor
96882>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
96882>>>>>//    Integer iLastErr
96882>>>>>//
96882>>>>>//    Move Err to bErr
96882>>>>>//    Move LastErr to iLastErr
96882>>>>>//
96882>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96882>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
96882>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96882>>>>>//    Move bErr to Err
96882>>>>>//    Move iLastErr to LastErr
96882>>>>>//    If (bIsHeaderGroup = False) Begin
96882>>>>>//        Forward Set Color to eColor
96882>>>>>//    End
96882>>>>>//End_Procedure
96882>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
96882>>>>>Use cApplication.pkg
96882>>>>>Use Dfline.pkg
96882>>>>>Use cRichEdit.pkg
96882>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainer.pkg)
96882>>>>>>>// Provides support for scrolling containers.
96882>>>>>>>// Scrolling containers is provided by creating two objects,
96882>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
96882>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96882>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96882>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96882>>>>>>>
96882>>>>>>>Use Windows.pkg
96882>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainerMixin.pkg)
96882>>>>>>>>>// Mixin classes for scrolling container support:
96882>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96882>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96882>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96882>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96882>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96882>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96882>>>>>>>>>
96882>>>>>>>>>Use Windows.pkg
96882>>>>>>>>>Use Winuser.pkg
96882>>>>>>>>>Use tWinStructs.pkg
96882>>>>>>>>>
96882>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96882>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96882>>>>>>>>>// support for the scrolling client area mixin object.
96882>>>>>>>>>
96882>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96883>>>>>>>>>    
96883>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96885>>>>>>>>>        
96885>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96886>>>>>>>>>        Set Border_Style to Border_None
96887>>>>>>>>>        
96887>>>>>>>>>        Property Boolean pbAutoScroll True
96888>>>>>>>>>        Property Boolean pbAutoScrollFocus True
96889>>>>>>>>>        Property Integer piAutoScrollMarginX 5
96890>>>>>>>>>        Property Integer piAutoScrollMarginY 5
96891>>>>>>>>>        Property Integer piAutoScrollMinX 0
96892>>>>>>>>>        Property Integer piAutoScrollMinY 0
96893>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96894>>>>>>>>>        
96894>>>>>>>>>        
96894>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96895>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96896>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96897>>>>>>>>>        // keeps track of scrolling
96897>>>>>>>>>        Property Integer piCurrentVertScrolled 0
96898>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
96899>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96900>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
96902>>>>>>>>>        
96902>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96902>>>>>>>>>        Property Boolean pbTabWorkspaceView False
96903>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96903>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96904>>>>>>>>>    End_Procedure
96905>>>>>>>>>    
96905>>>>>>>>>    // low level event sent from windows.
96905>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96907>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96907>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96908>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96909>>>>>>>>>        If (wParam<0) Begin
96911>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96912>>>>>>>>>        End
96912>>>>>>>>>>
96912>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96913>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96914>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96914>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96915>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96916>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
96916>>>>>>>>>        If (iClicks<>0) Begin
96918>>>>>>>>>            Send OnMouseWheel iClicks iKeys
96919>>>>>>>>>        End
96919>>>>>>>>>>
96919>>>>>>>>>        // tell windows that we've handled the event.
96919>>>>>>>>>        Set Windows_Override_State to True
96920>>>>>>>>>    End_Procedure
96921>>>>>>>>>    
96921>>>>>>>>>    
96921>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96921>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96923>>>>>>>>>        Integer iLineScrollUnit
96923>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96924>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96925>>>>>>>>>    End_Procedure
96926>>>>>>>>>    
96926>>>>>>>>>    // should be sent by WM_VSCROLL
96926>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96928>>>>>>>>>        Boolean bOk
96928>>>>>>>>>        tWinScrollInfo ScrollInfo
96928>>>>>>>>>        tWinScrollInfo ScrollInfo
96928>>>>>>>>>        Integer iLineScrollUnit
96928>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96929>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96930>>>>>>>>>        If bOk Begin
96932>>>>>>>>>            
96932>>>>>>>>>            Case Begin
96932>>>>>>>>>                Case (iType=SB_PAGEDOWN)
96934>>>>>>>>>                    Send VScroll ScrollInfo.nPage
96935>>>>>>>>>                    Case Break
96936>>>>>>>>>                
96936>>>>>>>>>                Case (iType=SB_PAGEUP)
96939>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96940>>>>>>>>>                    Case Break
96941>>>>>>>>>                
96941>>>>>>>>>                Case (iType=SB_LINEDOWN)
96944>>>>>>>>>                    Send VScroll iLineScrollUnit
96945>>>>>>>>>                    Case Break
96946>>>>>>>>>                
96946>>>>>>>>>                Case (iType=SB_LINEUP)
96949>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
96950>>>>>>>>>                    Case Break
96951>>>>>>>>>                
96951>>>>>>>>>                Case (iType=SB_BOTTOM)
96954>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96955>>>>>>>>>                    Case Break
96956>>>>>>>>>                
96956>>>>>>>>>                Case (iType=SB_Top)
96959>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96960>>>>>>>>>                    Case Break
96961>>>>>>>>>                
96961>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
96964>>>>>>>>>                    Case Break
96965>>>>>>>>>                
96965>>>>>>>>>                Case (iType=SB_THUMBTRACK)
96968>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96969>>>>>>>>>                    Case Break
96970>>>>>>>>>            Case End
96970>>>>>>>>>        End
96970>>>>>>>>>>
96970>>>>>>>>>    End_Procedure
96971>>>>>>>>>    
96971>>>>>>>>>    // should be sent by WM_HSCROLL
96971>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96973>>>>>>>>>        Boolean bOk
96973>>>>>>>>>        tWinScrollInfo ScrollInfo
96973>>>>>>>>>        tWinScrollInfo ScrollInfo
96973>>>>>>>>>        Integer iLineScrollUnit
96973>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96974>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96975>>>>>>>>>        If bOk Begin
96977>>>>>>>>>            
96977>>>>>>>>>            Case Begin
96977>>>>>>>>>                Case (iType=SB_PAGEDOWN)
96979>>>>>>>>>                    Send hScroll ScrollInfo.nPage
96980>>>>>>>>>                    Case Break
96981>>>>>>>>>                
96981>>>>>>>>>                Case (iType=SB_PAGEUP)
96984>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96985>>>>>>>>>                    Case Break
96986>>>>>>>>>                
96986>>>>>>>>>                Case (iType=SB_LINEDOWN)
96989>>>>>>>>>                    Send hScroll iLineScrollUnit
96990>>>>>>>>>                    Case Break
96991>>>>>>>>>                
96991>>>>>>>>>                Case (iType=SB_LINEUP)
96994>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
96995>>>>>>>>>                    Case Break
96996>>>>>>>>>                
96996>>>>>>>>>                Case (iType=SB_BOTTOM)
96999>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
97000>>>>>>>>>                    Case Break
97001>>>>>>>>>                
97001>>>>>>>>>                Case (iType=SB_Top)
97004>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
97005>>>>>>>>>                    Case Break
97006>>>>>>>>>                
97006>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
97009>>>>>>>>>                    Case Break
97010>>>>>>>>>                
97010>>>>>>>>>                Case (iType=SB_THUMBTRACK)
97013>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
97014>>>>>>>>>                    Case Break
97015>>>>>>>>>            Case End
97015>>>>>>>>>        End
97015>>>>>>>>>>
97015>>>>>>>>>    End_Procedure
97016>>>>>>>>>    
97016>>>>>>>>>    
97016>>>>>>>>>    // this calls SetScrollInfo with proper info
97016>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
97018>>>>>>>>>        tWinScrollInfo ScrollInfo
97018>>>>>>>>>        tWinScrollInfo ScrollInfo
97018>>>>>>>>>        Integer iVoid
97018>>>>>>>>>        Handle hWnd
97018>>>>>>>>>        Boolean bShow
97018>>>>>>>>>        
97018>>>>>>>>>        Delegate Get Window_Handle to hWnd
97020>>>>>>>>>        If (hWnd <> 0) Begin
97022>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97023>>>>>>>>>            
97023>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
97024>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
97025>>>>>>>>>            If bShow Begin
97027>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
97028>>>>>>>>>            End
97028>>>>>>>>>>
97028>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
97029>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
97030>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
97031>>>>>>>>>            Move 0 to ScrollInfo.nPos
97032>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
97033>>>>>>>>>            
97033>>>>>>>>>        End
97033>>>>>>>>>>
97033>>>>>>>>>    End_Procedure
97034>>>>>>>>>    
97034>>>>>>>>>    // this wraps GetScrollInfo
97034>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
97036>>>>>>>>>        Boolean bOk
97036>>>>>>>>>        Handle hWnd
97036>>>>>>>>>        
97036>>>>>>>>>        Delegate Get Window_Handle to hWnd
97038>>>>>>>>>        If (hWnd <> 0) Begin
97040>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97041>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
97042>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
97043>>>>>>>>>        End
97043>>>>>>>>>>
97043>>>>>>>>>        Function_Return bOk
97044>>>>>>>>>    End_Function
97045>>>>>>>>>    
97045>>>>>>>>>    // this wraps SetScrollPos
97045>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
97047>>>>>>>>>        Integer iVoid
97047>>>>>>>>>        Handle hWnd
97047>>>>>>>>>        
97047>>>>>>>>>        Delegate Get Window_Handle to hWnd
97049>>>>>>>>>        If (hWnd <> 0) Begin
97051>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
97052>>>>>>>>>        End
97052>>>>>>>>>>
97052>>>>>>>>>    End_Procedure
97053>>>>>>>>>    
97053>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
97053>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
97053>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
97055>>>>>>>>>        Send ScrollClientArea
97056>>>>>>>>>    End_Procedure
97057>>>>>>>>>    
97057>>>>>>>>>    // augment to handle the scrolling area initialization.
97057>>>>>>>>>    Procedure Add_Focus Handle hoParent
97059>>>>>>>>>        Forward Send Add_Focus hoParent
97061>>>>>>>>>        // at this the scrolling container and client area should both be paged.
97061>>>>>>>>>        // child objects ae also paged with initial anchors applied
97061>>>>>>>>>        Send CalculateAutoScrollMinimums
97062>>>>>>>>>    End_Procedure
97063>>>>>>>>>    
97063>>>>>>>>>    Procedure Page Integer iPage
97065>>>>>>>>>        Forward Send Page iPage
97067>>>>>>>>>        If iPage Begin
97069>>>>>>>>>            // at this the scrolling container and client area should both be paged
97069>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
97069>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
97069>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
97069>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
97069>>>>>>>>>            // before they were really needed. This should be more accurate
97069>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
97070>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
97071>>>>>>>>>        End
97071>>>>>>>>>>
97071>>>>>>>>>    End_Procedure
97072>>>>>>>>>    
97072>>>>>>>>>    // determine scrolling minimums and set the client area as required.
97072>>>>>>>>>    
97072>>>>>>>>>    Procedure CalculateAutoScrollMinimums
97074>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
97074>>>>>>>>>        Integer iAutoMinX iAutoMinY
97074>>>>>>>>>        Boolean bAutoScroll
97074>>>>>>>>>        Handle hoNext hoFirst
97074>>>>>>>>>        
97074>>>>>>>>>        Get pbAutoScroll to bAutoScroll
97075>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
97076>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
97077>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
97078>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
97079>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
97080>>>>>>>>>        Set piMinimumHeight to iAutoMinY
97081>>>>>>>>>        Set piMinimumWidth to iAutoMinX
97082>>>>>>>>>        
97082>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
97084>>>>>>>>>            
97084>>>>>>>>>            Get Next_Level to hoFirst
97085>>>>>>>>>            Move hoFirst to hoNext
97086>>>>>>>>>            If (hoFirst) Begin
97088>>>>>>>>>                Repeat
97088>>>>>>>>>>
97088>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
97089>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
97090>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
97091>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
97092>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
97093>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
97095>>>>>>>>>                
97095>>>>>>>>>                If (iAutoMinY=0) Begin
97097>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
97098>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
97099>>>>>>>>>                End
97099>>>>>>>>>>
97099>>>>>>>>>                
97099>>>>>>>>>                If (iAutoMinX=0) Begin
97101>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
97102>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
97103>>>>>>>>>                    
97103>>>>>>>>>                End
97103>>>>>>>>>>
97103>>>>>>>>>            End
97103>>>>>>>>>>
97103>>>>>>>>>        End
97103>>>>>>>>>>
97103>>>>>>>>>        
97103>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
97103>>>>>>>>>        Broadcast Set pbAnchorCreated to False
97105>>>>>>>>>        Send ScrollClientArea
97106>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
97106>>>>>>>>>        Broadcast Send DoCreateAnchors
97108>>>>>>>>>    End_Procedure
97109>>>>>>>>>    
97109>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
97109>>>>>>>>>    // work of scrolling.
97109>>>>>>>>>    
97109>>>>>>>>>    Procedure ScrollClientArea
97111>>>>>>>>>        Integer iSiz
97111>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
97111>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
97111>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
97111>>>>>>>>>        
97111>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97113>>>>>>>>>        Move (Hi(iSiz)) to iHeight
97114>>>>>>>>>        Move (Low(iSiz)) to iWidth
97115>>>>>>>>>        
97115>>>>>>>>>        // Vertical scrolling
97115>>>>>>>>>        
97115>>>>>>>>>        Get piMinimumHeight to iOrig
97116>>>>>>>>>        Get piMinimumWidth to iWOrig
97117>>>>>>>>>        
97117>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
97119>>>>>>>>>            
97119>>>>>>>>>            If (iOrig<>0) Begin
97121>>>>>>>>>                Get piCurrentVertScrolled to iHCur
97122>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
97122>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
97124>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
97125>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
97126>>>>>>>>>                End
97126>>>>>>>>>>
97126>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
97128>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
97129>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
97130>>>>>>>>>                End
97130>>>>>>>>>>
97130>>>>>>>>>                Else Begin
97131>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
97132>>>>>>>>>                End
97132>>>>>>>>>>
97132>>>>>>>>>            End
97132>>>>>>>>>>
97132>>>>>>>>>            
97132>>>>>>>>>            // Horiz scrolling
97132>>>>>>>>>            
97132>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
97133>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
97133>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
97135>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
97136>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
97137>>>>>>>>>            End
97137>>>>>>>>>>
97137>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
97139>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
97140>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
97141>>>>>>>>>            End
97141>>>>>>>>>>
97141>>>>>>>>>            Else Begin
97142>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
97143>>>>>>>>>            End
97143>>>>>>>>>>
97143>>>>>>>>>        End
97143>>>>>>>>>>
97143>>>>>>>>>        
97143>>>>>>>>>        // this could change depending on scrollbars appearing or not
97143>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97145>>>>>>>>>        
97145>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
97145>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
97145>>>>>>>>>        // This is required to make anchors work sensibly
97145>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
97146>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
97147>>>>>>>>>        Move (-iHCur) to iLocY
97148>>>>>>>>>        Move (-iWCur) to iLocX
97149>>>>>>>>>        
97149>>>>>>>>>        // Allow chance to make modifications
97149>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
97150>>>>>>>>>        
97150>>>>>>>>>        Set GuiSize to iSzY iSzX
97151>>>>>>>>>        // if we've scrolled, we need to reposition the container
97151>>>>>>>>>        Set GuiLocation to iLocY iLocX
97152>>>>>>>>>    End_Procedure
97153>>>>>>>>>    
97153>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
97153>>>>>>>>>    // this way, it does not interfere with anchors.
97153>>>>>>>>>    
97153>>>>>>>>>    Procedure VScroll Integer iDelta
97155>>>>>>>>>        Integer iHeight iCur iOrig iSiz
97155>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97157>>>>>>>>>        Move (hi(iSiz)) to iHeight
97158>>>>>>>>>        Get piCurrentVertScrolled to iCur
97159>>>>>>>>>        Get piMinimumHeight to iOrig
97160>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
97162>>>>>>>>>            Procedure_Return
97163>>>>>>>>>        End
97163>>>>>>>>>>
97163>>>>>>>>>        // make sure delta is within range
97163>>>>>>>>>        If (iDelta+iCur<0) Begin
97165>>>>>>>>>            Move (-iCur) to iDelta
97166>>>>>>>>>        End
97166>>>>>>>>>>
97166>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97169>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97170>>>>>>>>>        End
97170>>>>>>>>>>
97170>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
97173>>>>>>>>>        
97173>>>>>>>>>        Move (iCur + iDelta) to iCur
97174>>>>>>>>>        Set piCurrentVertScrolled to iCur
97175>>>>>>>>>        Send SetScrollBarPosInfo True iCur
97176>>>>>>>>>        Get GuiLocation to iSiz
97177>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
97178>>>>>>>>>        Send ScrollClientArea
97179>>>>>>>>>    End_Procedure
97180>>>>>>>>>    
97180>>>>>>>>>    
97180>>>>>>>>>    Procedure HScroll Integer iDelta
97182>>>>>>>>>        Integer iHeight iCur iOrig iSiz
97182>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97184>>>>>>>>>        Move (low(iSiz)) to iHeight
97185>>>>>>>>>        Get piCurrentHorzScrolled to iCur
97186>>>>>>>>>        Get piMinimumWidth to iOrig
97187>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
97189>>>>>>>>>            Procedure_Return
97190>>>>>>>>>        End
97190>>>>>>>>>>
97190>>>>>>>>>        If (iDelta+iCur<0) Begin
97192>>>>>>>>>            Move (-iCur) to iDelta
97193>>>>>>>>>        End
97193>>>>>>>>>>
97193>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97196>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97197>>>>>>>>>        End
97197>>>>>>>>>>
97197>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
97200>>>>>>>>>        
97200>>>>>>>>>        Move (iCur + iDelta) to iCur
97201>>>>>>>>>        Set piCurrentHorzScrolled to iCur
97202>>>>>>>>>        Send SetScrollBarPosInfo False iCur
97203>>>>>>>>>        Get GuiLocation to iSiz
97204>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
97205>>>>>>>>>        Send ScrollClientArea
97206>>>>>>>>>    End_Procedure
97207>>>>>>>>>    
97207>>>>>>>>>    // make sure client is a 0,0
97207>>>>>>>>>    Procedure ScrollHome
97209>>>>>>>>>        Send SetVScrollbox SB_TOP 0
97210>>>>>>>>>        Send SetHScrollbox SB_TOP 0
97211>>>>>>>>>    End_Procedure
97212>>>>>>>>>    
97212>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
97212>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
97214>>>>>>>>>        Integer ivoid
97214>>>>>>>>>        tWinRect Rect0 Rect1
97214>>>>>>>>>        tWinRect Rect0 Rect1
97214>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
97215>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
97216>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
97217>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
97218>>>>>>>>>    End_Procedure
97219>>>>>>>>>    
97219>>>>>>>>>    // This scrolls this object into visual range.
97219>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
97221>>>>>>>>>        Handle hoScrollingContainer
97221>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
97221>>>>>>>>>        Integer iViewHeight iViewWidth
97221>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
97221>>>>>>>>>        Integer iSize iControlHeight iControlWidth
97221>>>>>>>>>        Integer iScroll
97221>>>>>>>>>        Integer iMarginX iMarginY
97221>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
97221>>>>>>>>>        
97221>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
97222>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
97223>>>>>>>>>        
97223>>>>>>>>>        // the scrolling container
97223>>>>>>>>>        Move Self to hoScrollingContainer
97224>>>>>>>>>        // the amount the SC is currently scrolled
97224>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
97225>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
97226>>>>>>>>>        
97226>>>>>>>>>        // size of view's client area (this is the viewport area)
97226>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
97227>>>>>>>>>        Move (hi(iSize)) to iViewHeight
97228>>>>>>>>>        Move (low(iSize)) to iViewWidth
97229>>>>>>>>>        
97229>>>>>>>>>        // get this object's location relative to the scrolling container
97229>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
97230>>>>>>>>>        
97230>>>>>>>>>        // we expect that the client size is the window size but just in case
97230>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
97231>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
97232>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
97233>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
97234>>>>>>>>>        
97234>>>>>>>>>        // the outer size of the control object
97234>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
97235>>>>>>>>>        Move (hi(iSize)) to iControlHeight
97236>>>>>>>>>        Move (low(iSize)) to iControlWidth
97237>>>>>>>>>        
97237>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
97237>>>>>>>>>        
97237>>>>>>>>>        // Vertical Scroll
97237>>>>>>>>>        
97237>>>>>>>>>        // Vertical Scroll down
97237>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
97237>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
97239>>>>>>>>>            
97239>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
97239>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
97240>>>>>>>>>            
97240>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
97240>>>>>>>>>            // top of the object appears at the bottom
97240>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
97242>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
97243>>>>>>>>>            End
97243>>>>>>>>>>
97243>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
97243>>>>>>>>>            If (iScroll>0) Begin
97245>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
97246>>>>>>>>>            End
97246>>>>>>>>>>
97246>>>>>>>>>        End
97246>>>>>>>>>>
97246>>>>>>>>>        // else vertical scroll up
97246>>>>>>>>>        // We scroll if the top of the object is not visible.
97246>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
97249>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
97249>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
97250>>>>>>>>>            If (iScroll<0) Begin
97252>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
97253>>>>>>>>>            End
97253>>>>>>>>>>
97253>>>>>>>>>        End
97253>>>>>>>>>>
97253>>>>>>>>>        
97253>>>>>>>>>        // Horizonal Scroll
97253>>>>>>>>>        
97253>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
97253>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
97255>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
97256>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
97258>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
97259>>>>>>>>>            End
97259>>>>>>>>>>
97259>>>>>>>>>            If (iScroll>0) Begin
97261>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
97262>>>>>>>>>            End
97262>>>>>>>>>>
97262>>>>>>>>>        End
97262>>>>>>>>>>
97262>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
97264>>>>>>>>>            // if this can fit by moving all the way to left, do so.
97264>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
97266>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97267>>>>>>>>>            End
97267>>>>>>>>>>
97267>>>>>>>>>            Else Begin
97268>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97269>>>>>>>>>            End
97269>>>>>>>>>>
97269>>>>>>>>>            If (iScroll<0) Begin
97271>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97272>>>>>>>>>            End
97272>>>>>>>>>>
97272>>>>>>>>>        End
97272>>>>>>>>>>
97272>>>>>>>>>        
97272>>>>>>>>>        
97272>>>>>>>>>    End_Procedure
97273>>>>>>>>>    
97273>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97273>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97275>>>>>>>>>        Boolean bScrollOnFocus
97275>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97276>>>>>>>>>        If bScrollOnFocus Begin
97278>>>>>>>>>            Send ScrollObjectInRange hoControl
97279>>>>>>>>>        End
97279>>>>>>>>>>
97279>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97281>>>>>>>>>    End_Procedure
97282>>>>>>>>>    
97282>>>>>>>>>    
97282>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97284>>>>>>>>>        Boolean bCenter
97284>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97285>>>>>>>>>        Function_Return bCenter
97286>>>>>>>>>    End_Function
97287>>>>>>>>>    
97287>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97289>>>>>>>>>        Boolean bTabWorkspaceView
97289>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
97290>>>>>>>>>        If bTabWorkspaceView Begin
97292>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
97293>>>>>>>>>        End
97293>>>>>>>>>>
97293>>>>>>>>>    End_Procedure
97294>>>>>>>>>    
97294>>>>>>>>>    Function ParentView Returns Handle
97296>>>>>>>>>        Function_Return (Parent(Parent(Self)))
97297>>>>>>>>>    End_Function
97298>>>>>>>>>    
97298>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97300>>>>>>>>>        Integer iSize iMax iDiff
97300>>>>>>>>>        Handle hoView
97300>>>>>>>>>        Boolean bCenter bModal
97300>>>>>>>>>        Get ParentView to hoView
97301>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
97302>>>>>>>>>        If not bModal Begin
97304>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
97305>>>>>>>>>            Get GuiSize of hoView to iSize
97306>>>>>>>>>            Get piMaxSize of hoView to iMax
97307>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97308>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97310>>>>>>>>>                If bCenter Begin
97312>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97313>>>>>>>>>                End
97313>>>>>>>>>>
97313>>>>>>>>>                Move (Low(iMax)) to iWidth
97314>>>>>>>>>            End
97314>>>>>>>>>>
97314>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97316>>>>>>>>>                If bCenter Begin
97318>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97319>>>>>>>>>                    Move (iLocy min 25) to  iLocY
97320>>>>>>>>>                End
97320>>>>>>>>>>
97320>>>>>>>>>                Move (Hi(imax)) to iHeight
97321>>>>>>>>>            End
97321>>>>>>>>>>
97321>>>>>>>>>        End
97321>>>>>>>>>>
97321>>>>>>>>>    End_Procedure
97322>>>>>>>>>    
97322>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97322>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97322>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97322>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97322>>>>>>>>>    // This should almost always yield the right answer.
97322>>>>>>>>>    // This is called by the scrolling container's end_constructor
97322>>>>>>>>>    Procedure AutoSetTabWorkspaceView
97324>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97324>>>>>>>>>        Handle hoParent
97324>>>>>>>>>        Integer iSize
97324>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97325>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97327>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97328>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97328>>>>>>>>>            // change this after the commandbar is paged.
97328>>>>>>>>>            If (bTabView) Begin
97330>>>>>>>>>                Get ParentView to hoParent
97331>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97332>>>>>>>>>                If (bIsView) Begin
97334>>>>>>>>>                    // set this as a tab workspace view
97334>>>>>>>>>                    Set pbTabWorkspaceView to True
97335>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97335>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97335>>>>>>>>>                    Set pbAutoScroll to True
97336>>>>>>>>>                    
97336>>>>>>>>>                End
97336>>>>>>>>>>
97336>>>>>>>>>            End
97336>>>>>>>>>>
97336>>>>>>>>>        End
97336>>>>>>>>>>
97336>>>>>>>>>    End_Procedure
97337>>>>>>>>>    
97337>>>>>>>>>End_Class
97338>>>>>>>>>
97338>>>>>>>>>// Container scrolling class support. Nothing in here is public
97338>>>>>>>>>Class cScrollingContainerMixin is a Mixin
97339>>>>>>>>>    
97339>>>>>>>>>    Procedure Define_cScrollingContainerMixin
97341>>>>>>>>>        Forward Set Border_Style to Border_None
97343>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97344>>>>>>>>>        Forward Set peAnchors to anAll
97346>>>>>>>>>        
97346>>>>>>>>>        // forcing scrollbars right away seems to make painting better
97346>>>>>>>>>        Set Window_Style WS_HSCROLL to True
97347>>>>>>>>>        Set Window_Style WS_VSCROLL to True
97348>>>>>>>>>        
97348>>>>>>>>>        Property Handle phoScrollingClientArea 0
97349>>>>>>>>>    End_Procedure
97350>>>>>>>>>    
97350>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97350>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
97352>>>>>>>>>    End_Procedure
97353>>>>>>>>>    
97353>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97353>>>>>>>>>    Procedure Set Border_Style Integer eStyle
97355>>>>>>>>>    End_Procedure
97356>>>>>>>>>    
97356>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97356>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97358>>>>>>>>>        Handle hoClient
97358>>>>>>>>>        Get phoScrollingClientArea to hoClient
97359>>>>>>>>>        If hoClient Begin
97361>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97362>>>>>>>>>        End
97362>>>>>>>>>>
97362>>>>>>>>>    End_Procedure
97363>>>>>>>>>    
97363>>>>>>>>>    // should be sent by WM_VSCROLL
97363>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97365>>>>>>>>>        Handle hoClient
97365>>>>>>>>>        Get phoScrollingClientArea to hoClient
97366>>>>>>>>>        If hoClient Begin
97368>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97369>>>>>>>>>        End
97369>>>>>>>>>>
97369>>>>>>>>>    End_Procedure
97370>>>>>>>>>    
97370>>>>>>>>>    // should be sent by WM_HSCROLL
97370>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97372>>>>>>>>>        Handle hoClient
97372>>>>>>>>>        Get phoScrollingClientArea to hoClient
97373>>>>>>>>>        If hoClient Begin
97375>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97376>>>>>>>>>        End
97376>>>>>>>>>>
97376>>>>>>>>>    End_Procedure
97377>>>>>>>>>    
97377>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97377>>>>>>>>>    // After this is set, anchors will handle any further resizing.
97377>>>>>>>>>    Procedure Page Integer iState
97379>>>>>>>>>        Integer iSiz iHeight iWidth
97379>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97379>>>>>>>>>        Boolean bGroup
97379>>>>>>>>>        Handle hoClient
97379>>>>>>>>>        If (iState =1) Begin
97381>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97383>>>>>>>>>            // We have special code to support groups because they
97383>>>>>>>>>            // draw a border inside of the client rectangle
97383>>>>>>>>>            If bGroup Begin
97385>>>>>>>>>                Get Physical_FontSize to iFontSize
97386>>>>>>>>>                Move (Hi(iFontSize)) to iTop
97387>>>>>>>>>                Move 2 to iLeft
97388>>>>>>>>>                Move 2 to iRight
97389>>>>>>>>>                Move 2 to iBottom
97390>>>>>>>>>            End
97390>>>>>>>>>>
97390>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97390>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97390>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
97390>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97392>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97393>>>>>>>>>            Set GuiLocation to iTop iLeft
97394>>>>>>>>>            Send Adjust_Logicals
97395>>>>>>>>>        End
97395>>>>>>>>>>
97395>>>>>>>>>        Forward Send Page iState
97397>>>>>>>>>    End_Procedure
97398>>>>>>>>>    
97398>>>>>>>>>    Procedure End_Construct_Object
97400>>>>>>>>>        Handle hoClient
97400>>>>>>>>>        Forward Send End_Construct_Object
97402>>>>>>>>>        Get phoScrollingClientArea to hoClient
97403>>>>>>>>>        If (hoClient) Begin
97405>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97406>>>>>>>>>        End
97406>>>>>>>>>>
97406>>>>>>>>>    End_Procedure
97407>>>>>>>>>    
97407>>>>>>>>>End_Class
97408>>>>>>>
97408>>>>>>>Class cScrollingClientArea is a Container3d
97409>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97410>>>>>>>    Procedure Construct_Object
97412>>>>>>>        Forward Send Construct_Object
97414>>>>>>>        Send Define_cScrollingClientAreaMixin
97415>>>>>>>    End_Procedure
97416>>>>>>>End_Class
97417>>>>>>>
97417>>>>>>>
97417>>>>>>>
97417>>>>>>>Class cScrollingContainer is a Container3d
97418>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
97419>>>>>>>    Procedure Construct_Object
97421>>>>>>>        Forward Send Construct_Object
97423>>>>>>>        Send Define_cScrollingContainerMixin
97424>>>>>>>    End_Procedure
97425>>>>>>>End_Class
97426>>>>>Use cRDCModalPanel.pkg
97426>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCForm.pkg)
97426>>>>>>>//****************************************************************************
97426>>>>>>>// $Module type: Class
97426>>>>>>>// $Module name: cForm
97426>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
97426>>>>>>>// Created     : 2014-03-17 @ 12:34
97426>>>>>>>//
97426>>>>>>>// Description :
97426>>>>>>>//
97426>>>>>>>// $Rev History:
97426>>>>>>>//    2014-03-17  Module header created
97426>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97426>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97426>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97426>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97426>>>>>>>// in the help folder for more details.
97426>>>>>>>//
97426>>>>>>>//****************************************************************************
97426>>>>>>>Use Windows.pkg
97426>>>>>>>
97426>>>>>>>Class cFormIdleHandler is a cIdleHandler
97427>>>>>>>    Procedure Construct_Object
97429>>>>>>>        Forward Send Construct_Object
97431>>>>>>>
97431>>>>>>>    End_Procedure
97432>>>>>>>
97432>>>>>>>    Procedure OnIdle
97434>>>>>>>        Delegate Send DoUpdate
97436>>>>>>>    End_Procedure
97437>>>>>>>
97437>>>>>>>End_Class
97438>>>>>>>
97438>>>>>>>Class cRDCForm is a Form
97439>>>>>>>
97439>>>>>>>    Procedure Construct_Object
97441>>>>>>>        Forward Send Construct_Object
97443>>>>>>>
97443>>>>>>>        Property Boolean pbAutoEnable False
97444>>>>>>>
97444>>>>>>>        Property Boolean pbEnabled True
97445>>>>>>>
97445>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
97446>>>>>>>
97446>>>>>>>        Set Label_Justification_mode to JMode_Right
97447>>>>>>>        Set Label_Col_Offset to 2
97448>>>>>>>        Set Label_Row_Offset to 0
97449>>>>>>>    End_Procedure
97450>>>>>>>
97450>>>>>>>    Procedure End_Construct_Object
97452>>>>>>>        String sTooltip sStatus_Help
97452>>>>>>>
97452>>>>>>>        Forward Send End_Construct_Object
97454>>>>>>>
97454>>>>>>>        Get psToolTip   to sTooltip
97455>>>>>>>        Get Status_Help to sStatus_Help
97456>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97458>>>>>>>            Set psToolTip to sStatus_Help
97459>>>>>>>        End
97459>>>>>>>>
97459>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
97462>>>>>>>            Set Status_Help to sTooltip
97463>>>>>>>        End
97463>>>>>>>>
97463>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97464>>>>>>>    End_Procedure
97465>>>>>>>
97465>>>>>>>    Procedure DoUpdate
97467>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97469>>>>>>>            Procedure_Return
97470>>>>>>>        End
97470>>>>>>>>
97470>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97471>>>>>>>    End_Procedure
97472>>>>>>>
97472>>>>>>>    Function IsEnabled Returns Boolean
97474>>>>>>>        Boolean bEnabled
97474>>>>>>>        Get pbEnabled to bEnabled
97475>>>>>>>        Function_Return bEnabled
97476>>>>>>>    End_Function
97477>>>>>>>
97477>>>>>>>    // Enable the idle handler timer when the object is activated
97477>>>>>>>    Procedure Activating
97479>>>>>>>        Forward Send Activating
97481>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97482>>>>>>>    End_Procedure
97483>>>>>>>
97483>>>>>>>    // Disable the idle handler when the object is deactivated
97483>>>>>>>    Procedure Deactivating  
97485>>>>>>>        // When exiting the program it can happen that the idle handler
97485>>>>>>>        // already has been destroyed.      
97485>>>>>>>        If (Object_id(phoIdleHandler(Self)) <> 0) Begin
97487>>>>>>>            Set pbEnabled of (phoIdleHandler(Self)) to False
97488>>>>>>>        End
97488>>>>>>>>
97488>>>>>>>        Forward Send Deactivating
97490>>>>>>>    End_Procedure 
97491>>>>>>>    
97491>>>>>>>    // Toggles the password state, as it doesn't work changing the
97491>>>>>>>    // password_state at runtine because it is a design time property.
97491>>>>>>>    Procedure TogglePasswordState
97493>>>>>>>        Boolean bState    
97493>>>>>>>        Handle hoFocus hoParent
97493>>>>>>>        Integer iRetval
97493>>>>>>>        Get Password_State to bState
97494>>>>>>>        Set Password_State to (not(bState))
97495>>>>>>>        Get Focus of Desktop to hoFocus
97496>>>>>>>        Move (Parent(Self)) to hoParent
97497>>>>>>>        Send Page_Object False
97498>>>>>>>        Send Page_Object True   
97499>>>>>>>        Get msg_Add_Focus hoParent to iRetval
97500>>>>>>>        Set Focus_Mode of hoFocus to Focusable
97501>>>>>>>//        Send Page_Delete
97501>>>>>>>//        Send Page 1
97501>>>>>>>    End_Procedure
97502>>>>>>>
97502>>>>>>>End_Class
97503>>>>>Use cRDCComboForm.pkg
97503>>>>>Use cRDCButton.pkg
97503>>>>>Use cRDCHeaderGroup.pkg
97503>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
97503>>>>>>>//****************************************************************************
97503>>>>>>>// $Module type: Class
97503>>>>>>>// $Module name: cDbDriverSettingsForm
97503>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
97503>>>>>>>// Created     : 2014-03-17 @ 12:34
97503>>>>>>>//
97503>>>>>>>// Description :
97503>>>>>>>//
97503>>>>>>>// $Rev History:
97503>>>>>>>//    2014-03-17  Module header created
97503>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97503>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97503>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97503>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97503>>>>>>>// in the help folder for more details.
97503>>>>>>>//
97503>>>>>>>//****************************************************************************
97503>>>>>>>Use Windows.pkg
97503>>>>>>>Use seq_chnl.pkg
97503>>>>>>>
97503>>>>>>>Class cDbDriverSettingsForm is a Form
97504>>>>>>>
97504>>>>>>>    Procedure Construct_Object
97506>>>>>>>        Forward Send Construct_Object
97508>>>>>>>
97508>>>>>>>        Property Boolean private.pbDriverLoadingError False
97509>>>>>>>        
97509>>>>>>>        Set Label_Col_Offset to 2
97510>>>>>>>        Set Label_Justification_Mode to JMode_Right
97511>>>>>>>        Set Size to 11 125 
97512>>>>>>>        // We use these settings and not enabled_state to be able
97512>>>>>>>        // to show tooltips.
97512>>>>>>>        Set Color to clBtnFace
97513>>>>>>>        Set Focus_Mode to NonFocusable
97514>>>>>>>        Set peAnchors to anTopLeftRight
97515>>>>>>>
97515>>>>>>>        Property String psDriverIniFile ""
97516>>>>>>>    End_Procedure
97517>>>>>>>
97517>>>>>>>    Procedure Set psToolTip String sText
97519>>>>>>>        If (Trim(sText) = "") Begin
97521>>>>>>>            Move "No info available" to sText
97522>>>>>>>        End
97522>>>>>>>>
97522>>>>>>>        Forward Set psToolTip to sText
97524>>>>>>>    End_Procedure
97525>>>>>>>
97525>>>>>>>    Function psToolTip Returns String
97527>>>>>>>        String sTooltip sSearchValue
97527>>>>>>>
97527>>>>>>>        Get Label to sSearchValue
97528>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
97529>>>>>>>
97529>>>>>>>        Function_Return sTooltip
97530>>>>>>>    End_Function
97531>>>>>>>
97531>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
97533>>>>>>>        Integer iDriver
97533>>>>>>>        String sValue
97533>>>>>>>
97533>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
97533>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
97533>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
97535>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97536>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
97537>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
97538>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97539>>>>>>>            If (iDriver <= 0) Begin
97541>>>>>>>                Procedure_Return
97542>>>>>>>            End
97542>>>>>>>>
97542>>>>>>>            // Set indicator to false prior asking for the driver attribute.
97542>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
97542>>>>>>>            Move False to Err
97543>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
97546>>>>>>>            If (sValue = "0") Begin
97548>>>>>>>                Move "0 (False)" to sValue
97549>>>>>>>            End
97549>>>>>>>>
97549>>>>>>>            If (sValue = "1") Begin
97551>>>>>>>                Move "1 (True)"  to sValue
97552>>>>>>>            End
97552>>>>>>>>
97552>>>>>>>            Set Value to sValue
97553>>>>>>>
97553>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
97554>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
97554>>>>>>>            // all labels (DF_DRIVER_XXX values).
97554>>>>>>>            Get Propercase sLabel to sLabel
97555>>>>>>>            Set Label to sLabel
97556>>>>>>>
97556>>>>>>>            Get ExtractIniFileComment sLabel to sValue
97557>>>>>>>            Set Status_Help to sValue
97558>>>>>>>            Set psToolTip to sValue
97559>>>>>>>        End
97559>>>>>>>>
97559>>>>>>>    End_Procedure
97560>>>>>>>
97560>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
97560>>>>>>>    // Returns: The comments in the file as a string.
97560>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
97562>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
97562>>>>>>>        Boolean bCommentRow bStart
97562>>>>>>>        Integer iCh
97562>>>>>>>
97562>>>>>>>        Get psDriverIniFile to sIniFile
97563>>>>>>>        Move ";" to sCommentMarker
97564>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
97565>>>>>>>        While (SeqEof = False)
97569>>>>>>>            Readln channel iCh sValue
97571>>>>>>>            Move (Trim(sValue)) to sValue
97572>>>>>>>
97572>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
97572>>>>>>>            Move (Left(sValue, 1)) to sComment
97573>>>>>>>            If (bStart = False) Begin
97575>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
97576>>>>>>>            End
97576>>>>>>>>
97576>>>>>>>            If (bStart = True) Begin
97578>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
97578>>>>>>>                If (sComment <> sCommentMarker) Begin
97580>>>>>>>                    Move True to SeqEof
97581>>>>>>>                End
97581>>>>>>>>
97581>>>>>>>                Else Begin
97582>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
97583>>>>>>>                    If (bCommentRow = True) Begin
97585>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
97586>>>>>>>
97586>>>>>>>                        // Replace all double spaces with a single space character.
97586>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
97587>>>>>>>
97587>>>>>>>                        If (sRetval = "") Begin
97589>>>>>>>                            Move sValue to sRetval
97590>>>>>>>                        End
97590>>>>>>>>
97590>>>>>>>                        Else Begin
97591>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
97592>>>>>>>                        End
97592>>>>>>>>
97592>>>>>>>                    End
97592>>>>>>>>
97592>>>>>>>                End
97592>>>>>>>>
97592>>>>>>>            End
97592>>>>>>>>
97592>>>>>>>        Loop
97593>>>>>>>>
97593>>>>>>>        Send Seq_Close_Channel iCh
97594>>>>>>>
97594>>>>>>>CompilerWarnings Off
97594>>>>>>>        // Replaces all double spaces with a single space character.
97594>>>>>>>        // The Replaces function doesn't quite work for this.
97594>>>>>>>        Repeat
97594>>>>>>>>
97594>>>>>>>            Replace "  " in sRetval with " "
97598>>>>>>>        Until (FindErr)
97600>>>>>>>        
97600>>>>>>>        Function_Return sRetval
97601>>>>>>>    End_Function
97602>>>>>>>CompilerWarnings On
97602>>>>>>>
97602>>>>>>>    Function Propercase String sText Returns String 
97604>>>>>>>        String[] sDelimiters
97605>>>>>>>        Integer iPos
97605>>>>>>>        
97605>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
97605>>>>>>>        Move (Lowercase(sText)) to sText
97606>>>>>>>        
97606>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
97607>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
97608>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
97609>>>>>>>        
97609>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
97615>>>>>>>>
97615>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
97615>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
97618>>>>>>>        Loop
97619>>>>>>>>
97619>>>>>>>        
97619>>>>>>>        Function_Return sText
97620>>>>>>>    End_Function
97621>>>>>>>
97621>>>>>>>End_Class
97622>>>>>Use cDbUpdateFunctionLibrary.pkg
97622>>>>>
97622>>>>>Register_Procedure psOrgToolTip String sTooltip
97622>>>>>
97622>>>>>Object oDriverSettings_dg is a cRDCModalPanel
97624>>>>>    Set Size to 291 345
97625>>>>>    Set Label to "Driver Configuration File Info"
97626>>>>>    Set Location to 2 2
97627>>>>>    Set Maximize_Icon to False
97628>>>>>    Set Locate_Mode to CENTER_ON_PARENT
97629>>>>>    Set Icon to "DriverSettings1.ico"
97630>>>>>    
97630>>>>>    Property String psDriverID MSSQLDRV_ID
97632>>>>>    Property Boolean pbDriverLoadingError False
97634>>>>>    
97634>>>>>    Object oCancel_Btn is a cRDCButton
97636>>>>>        Set Label    to "&Close"
97637>>>>>        Set Location to 269 287
97638>>>>>        Set peAnchors to anBottomRight
97639>>>>>
97639>>>>>        Procedure OnClick
97642>>>>>            Send Close_Panel
97643>>>>>        End_Procedure
97644>>>>>
97644>>>>>    End_Object
97645>>>>>
97645>>>>>    Object oDriver_cf is a cRDCComboForm
97647>>>>>        Set Label to "Database Driver"
97648>>>>>        Set Size to 13 80
97649>>>>>        Set Location to 8 90
97650>>>>>        Set Form_Border to 0
97651>>>>>        Set Label_Col_Offset to 2
97652>>>>>        Set Label_Justification_Mode to JMode_Right
97653>>>>>        Set Status_Help to "Database driver."
97654>>>>>        Set Enabled_State to False
97655>>>>>        Set Skip_State to True
97656>>>>>
97656>>>>>        Procedure Combo_Fill_List
97659>>>>>            Send Combo_Add_Item DATAFLEX_ID
97660>>>>>            Send Combo_Add_Item DFBTRDRV_ID
97661>>>>>            Send Combo_Add_Item ODBC_DRV_ID
97662>>>>>            Send Combo_Add_Item MSSQLDRV_ID
97663>>>>>            Send Combo_Add_Item DB2_DRV_ID
97664>>>>>        End_Procedure
97665>>>>>
97665>>>>>    End_Object
97666>>>>>
97666>>>>>    Object oDriverFileName_cf is a cRDCForm
97668>>>>>        Set Label to "Database Driver File"
97669>>>>>        Set Size to 12 193
97670>>>>>        Set Location to 24 90
97671>>>>>        Set Label_Col_Offset to 2
97672>>>>>        Set Label_Justification_Mode to JMode_Right
97673>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
97674>>>>>        Set Color to clBtnFace
97675>>>>>        Set Focus_Mode to NonFocusable
97676>>>>>        Set peAnchors to anTopLeftRight
97677>>>>>
97677>>>>>        Procedure OnChange
97680>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
97680>>>>>
97680>>>>>            Forward Send OnChange
97682>>>>>            Get Value to sValue
97683>>>>>            Set Status_Help to sValue
97684>>>>>
97684>>>>>            Get psDriverID to sDriverID
97685>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
97687>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
97688>>>>>                If (sPath <> "") Begin
97690>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
97691>>>>>                End
97691>>>>>>
97691>>>>>            End
97691>>>>>>
97691>>>>>            Else Begin
97692>>>>>                Move sDriverID to sDriverIntFileName
97693>>>>>            End
97693>>>>>>
97693>>>>>
97693>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
97694>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
97695>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
97696>>>>>
97696>>>>>            // In case driver attribute objects already exists; destroy them
97696>>>>>            Broadcast Send Destroy    of oScrollingClientArea
97698>>>>>            // Then recreate them to show driver attributes
97698>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
97699>>>>>        End_Procedure  
97700>>>>>        
97700>>>>>    End_Object
97701>>>>>
97701>>>>>    Object oDriverInfo_btn is a cRDCButton
97703>>>>>        Set Size to 13 50
97704>>>>>        Set Location to 24 287
97705>>>>>        Set Label to "Version Info"
97706>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
97707>>>>>        Set peAnchors to anTopRight
97708>>>>>
97708>>>>>        Procedure OnClick
97711>>>>>            Object oSysInfoDialog is a SysInfoDialog
97713>>>>>            End_Object
97714>>>>>
97714>>>>>            Send Popup of oSysInfoDialog
97715>>>>>        End_Procedure
97716>>>>>    End_Object
97717>>>>>
97717>>>>>    Object oDriverIniFile_fm is a cRDCForm
97719>>>>>        Set Size to 13 193
97720>>>>>        Set Location to 39 90
97721>>>>>        Set Label_Col_Offset to 2
97722>>>>>        Set Label_Justification_Mode to JMode_Right
97723>>>>>        Set Label to "Driver Configuration File"
97724>>>>>        Set peAnchors to anTopLeftRight
97725>>>>>        Set Color to clBtnFace
97726>>>>>        Set Focus_Mode to NonFocusable
97727>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
97729>>>>>        Set Status_Help to (psOrgToolTip(Self))
97730>>>>>    End_Object
97731>>>>>
97731>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
97733>>>>>        Set Size to 13 50
97734>>>>>        Set Label to "Edit File"
97735>>>>>        Set Location to 39 287
97736>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
97737>>>>>        Set psImage to "ActionEdit1.ico"
97738>>>>>        Set peAnchors to anTopRight
97739>>>>>        Set pbAutoEnable to True
97740>>>>>
97740>>>>>        Procedure OnClick
97743>>>>>            String sFileName
97743>>>>>            Get Value of oDriverIniFile_fm to sFileName
97744>>>>>            If (sFileName <> DATAFLEX_ID) Begin
97746>>>>>                Runprogram Background "Notepad.exe" sFileName
97747>>>>>            End
97747>>>>>>
97747>>>>>            Else Begin
97748>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
97749>>>>>            End
97749>>>>>>
97749>>>>>        End_Procedure   
97750>>>>>        
97750>>>>>        Function IsEnabled Returns Boolean
97753>>>>>            String sFileName
97753>>>>>            Get Value of oDriverFileName_cf to sFileName
97754>>>>>            Function_Return (sFileName <> "")
97755>>>>>        End_Function
97756>>>>>
97756>>>>>    End_Object
97757>>>>>
97757>>>>>    Object oDumpDriverData_Btn is a cRDCButton
97759>>>>>        Set Size to 13 50
97760>>>>>        Set Label to "Dump"
97761>>>>>        Set Location to 54 233
97762>>>>>        Set peAnchors to anTopRight
97763>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
97764>>>>>        Set psImage to "ActionExport1.ico"
97765>>>>>        Set pbAutoEnable to True
97766>>>>>        
97766>>>>>        Procedure OnClick
97769>>>>>            Handle hoCLI
97769>>>>>            String sDriver sPath sFileName
97769>>>>>            Integer iRetval
97769>>>>>
97769>>>>>            Get psDriverID to sDriver
97770>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
97771>>>>>            Set psDriverID of hoCLI  to sDriver
97772>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
97774>>>>>                Send Destroy of hoCLI
97775>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
97776>>>>>                Procedure_Return
97777>>>>>            End
97777>>>>>>
97777>>>>>
97777>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
97778>>>>>            Get vFolderFormat sPath to sPath
97779>>>>>            Move (sDriver + "dump.txt") to sFileName
97780>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
97781>>>>>            Send Destroy of hoCLI
97782>>>>>
97782>>>>>            Send vShellExecute "open" sFileName "" sPath
97783>>>>>            Sleep 1
97784>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
97785>>>>>        End_Procedure
97786>>>>>
97786>>>>>        Function IsEnabled Returns Boolean
97789>>>>>            String sFileName
97789>>>>>            Boolean bDriverLoadingError 
97789>>>>>            Get pbDriverLoadingError to bDriverLoadingError
97790>>>>>            Get Value of oDriverFileName_cf to sFileName
97791>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
97792>>>>>        End_Function
97793>>>>>
97793>>>>>    End_Object
97794>>>>>
97794>>>>>    Object oReset_Btn is a cRDCButton
97796>>>>>        Set Size to 13 50
97797>>>>>        Set Label to "Refresh"
97798>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
97799>>>>>        Set Location to 54 287
97800>>>>>        Set psImage to "ActionRefresh1.ico"
97801>>>>>        Set peAnchors to anTopRight
97802>>>>>        Set pbAutoEnable to True
97803>>>>>
97803>>>>>        Procedure OnClick
97806>>>>>            String sDriver
97806>>>>>            Get psDriverID to sDriver
97807>>>>>            Unload_Driver sDriver
97808>>>>>            Load_Driver sDriver
97809>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
97810>>>>>            Send Close_Panel
97811>>>>>        End_Procedure
97812>>>>>
97812>>>>>        Function IsEnabled Returns Boolean
97815>>>>>            String sFileName
97815>>>>>            Boolean bDriverLoadingError 
97815>>>>>            Get pbDriverLoadingError to bDriverLoadingError
97816>>>>>            Get Value of oDriverFileName_cf to sFileName
97817>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
97818>>>>>        End_Function
97819>>>>>
97819>>>>>    End_Object
97820>>>>>
97820>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
97822>>>>>        Set Size to 125 328
97823>>>>>        Set Location to 74 9
97824>>>>>        Set psImage to "DriverSettings1.ico"
97825>>>>>        Set Label to "Driver Configuration File Settings"   
97826>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
97827>>>>>        Set peAnchors to anAll
97828>>>>>
97828>>>>>        Object oInvisible_Container is a Container3d
97830>>>>>            Set Size to 100 327
97831>>>>>            Set Location to 24 0
97832>>>>>            Set Border_Style to Border_None
97833>>>>>            Set peAnchors to anAll
97834>>>>>    
97834>>>>>            Object oScrollingContainer is a cScrollingContainer
97836>>>>>               
97836>>>>>                Object oScrollingClientArea is a cScrollingClientArea
97838>>>>>
97838>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
97838>>>>>                    // and one object will automatically be created for each attribute
97838>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
97838>>>>>                    Function GeneralDriverAttributes Returns String[]
97841>>>>>                        String[] sAttributesArray
97842>>>>>    
97842>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
97843>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
97844>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
97845>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
97846>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
97847>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
97848>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
97849>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
97850>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
97851>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
97852>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
97853>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
97854>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
97855>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
97856>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
97857>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
97858>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
97859>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
97860>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
97861>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
97862>>>>>    
97862>>>>>                        // Exception to the rule!
97862>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
97862>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
97862>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
97862>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
97863>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
97864>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
97865>>>>>    
97865>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
97866>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
97867>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
97868>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
97869>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
97870>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
97871>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
97872>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
97873>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
97874>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
97875>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
97876>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
97877>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
97878>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
97879>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
97880>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
97881>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
97882>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
97883>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
97884>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
97885>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
97886>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
97887>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
97888>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
97889>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
97890>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
97891>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
97892>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
97893>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
97894>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
97895>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
97896>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
97897>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
97898>>>>>    
97898>>>>>                        // Sort items alphabetically
97898>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
97899>>>>>                        Function_Return sAttributesArray
97900>>>>>                    End_Function
97901>>>>>    
97901>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
97904>>>>>                        String sAttribute sTmp
97904>>>>>                        Integer iPos
97904>>>>>    
97904>>>>>                        Move (Pos("|", sValue)) to iPos
97905>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
97906>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
97907>>>>>                        Move (Trim(sAttribute)) to sAttribute
97908>>>>>                        Move (Eval(sTmp)) to iAttribute
97909>>>>>    
97909>>>>>                        Function_Return sAttribute
97910>>>>>                    End_Function
97911>>>>>    
97911>>>>>                    // Note: Creates dynamic objects.
97911>>>>>                    // They are not being destroyed by this method.
97911>>>>>                    // It is the reponsibility of the calling method to do that,
97911>>>>>                    // prior calling this method.
97911>>>>>                    Procedure DoReadDriverSettings String sDriver
97914>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
97914>>>>>                        Handle ho hoParent
97914>>>>>                        String[] sAttributesArray
97915>>>>>                        String sValue sAttribute sDriverIniFile 
97915>>>>>                        Boolean bDriverLoadingError
97915>>>>>    
97915>>>>>                        Move (Self) to hoParent
97916>>>>>                        Move 13  to iHfactor // Height offset between form
97917>>>>>                        Move 120 to iLocW
97918>>>>>                        Move 10  to iLocH                            
97919>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
97920>>>>>    
97920>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
97921>>>>>                        If (Trim(sDriverIniFile) = "") Begin
97923>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
97924>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
97925>>>>>                            Set Location of ho to iLocH (iLocW + 30)
97926>>>>>                            Set Label of ho to "No Driver Configuration File found!"
97927>>>>>                            Set Value of ho to "No attributes to display..."   
97928>>>>>                            Procedure_Return
97929>>>>>                        End
97929>>>>>>
97929>>>>>                            
97929>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
97929>>>>>                        // so notify and quite.
97929>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
97931>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
97932>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
97933>>>>>                            Set Location of ho to iLocH (iLocW + 30)
97934>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
97935>>>>>                            Set Value of ho to "Sorry, no attributes to display"
97936>>>>>                            Procedure_Return
97937>>>>>                        End
97937>>>>>>
97937>>>>>    
97937>>>>>                        Get GeneralDriverAttributes to sAttributesArray
97938>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
97939>>>>>                        Decrement iItems
97940>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
97941>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
97942>>>>>    
97942>>>>>                        For iCount from 0 to iItems
97948>>>>>>
97948>>>>>                            Move sAttributesArray[iCount] to sValue
97949>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
97950>>>>>    
97950>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
97951>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
97952>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
97953>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
97954>>>>>                            If (bDriverLoadingError = True) Begin
97956>>>>>                                Set Label of ho to "Driver could not be loaded!"   
97957>>>>>                                If (Trim(sDriverIniFile) = "") Begin
97959>>>>>                                    Set Value of ho to "Driver .dll file not found!"
97960>>>>>                                End
97960>>>>>>
97960>>>>>                                Else Begin
97961>>>>>                                    Set Value of ho to "No attributes to display..."   
97962>>>>>                                End
97962>>>>>>
97962>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
97963>>>>>                                Delegate Set pbDriverLoadingError to True
97965>>>>>                                Move iItems to iCount // We're out of here.   
97966>>>>>                                Move False to Err
97967>>>>>                            End
97967>>>>>>
97967>>>>>                            If (Err = True) Begin
97969>>>>>                                Send Destroy of ho
97970>>>>>                            End
97970>>>>>>
97970>>>>>                            Else Begin
97971>>>>>                                If (iCount = 0) Begin
97973>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
97974>>>>>                                End
97974>>>>>>
97974>>>>>                                Set Location of ho to iLocH (iLocW + 30)
97975>>>>>                                Move (iLocH + iHfactor) to iLocH
97976>>>>>                            End
97976>>>>>>
97976>>>>>                        Loop
97977>>>>>>
97977>>>>>    
97977>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
97978>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97979>>>>>                    End_Procedure
97980>>>>>    
97980>>>>>                End_Object
97981>>>>>
97981>>>>>            End_Object
97982>>>>>    
97982>>>>>        End_Object
97983>>>>>
97983>>>>>    End_Object
97984>>>>>
97984>>>>>    Object oInfo_edt is a cRichEdit
97986>>>>>        Set Size to 49 328
97987>>>>>        Set Location to 213 9
97988>>>>>        Set Label to "General Connectivity Kit Information:"
97989>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
97990>>>>>        Set Skip_State to True
97991>>>>>        Set Read_Only_State to True
97992>>>>>        Set pbItalics to True
97993>>>>>        Set peAnchors to anBottomLeftRight
97994>>>>>
97994>>>>>        Procedure DoIndent
97997>>>>>            Integer iTwipsPerInch iCurrentIndent
97997>>>>>        
97997>>>>>            // number of twips per inch
97997>>>>>            Move 1440 to iTwipsPerInch
97998>>>>>        
97998>>>>>            Set piSpacingBefore to (1440 * 0.05)
97999>>>>>            // indent 0.1 inches from current indentation
97999>>>>>            Get piParagraphIndent to iCurrentIndent
98000>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
98001>>>>>        End_Procedure
98002>>>>>        Send DoIndent
98003>>>>>
98003>>>>>    End_Object
98004>>>>>
98004>>>>>    Procedure Activating
98007>>>>>        Forward Send Activating
98009>>>>>        Send Cursor_Ready of Cursor_Control
98010>>>>>    End_Procedure
98011>>>>>
98011>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98012>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98013>>>>>End_Object
98014>>>>>
98014>>>>>// General purpose access method for the dialog above:
98014>>>>>Procedure PopupDriverSettings String sDriverID 
98017>>>>>    Handle ho
98017>>>>>    String sDriverFile sPath
98017>>>>>
98017>>>>>    Send Cursor_Wait of Cursor_Control
98018>>>>>    Move (oDriverSettings_dg(Self)) to ho
98019>>>>>    Set psDriverID of ho to sDriverID
98020>>>>>    Set pbDriverLoadingError of ho to False
98021>>>>>
98021>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
98022>>>>>    Get DatabaseDriverPath sDriverID to sPath
98023>>>>>    If (sPath <> "") Begin
98025>>>>>        Move (sDriverID + ".dll")  to sDriverFile
98026>>>>>    End
98026>>>>>>
98026>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
98027>>>>>    Send Cursor_Ready of Cursor_Control
98028>>>>>
98028>>>>>    Send Popup of ho
98029>>>>>End_Procedure
98030>>>>>
98030>>>>>Function DatabaseDriverPath String sDriverID Returns String
98033>>>>>    String sPath sDriverFileName
98033>>>>>
98033>>>>>    Move "" to sPath
98034>>>>>    If (sDriverID = DATAFLEX_ID) Begin
98036>>>>>        Function_Return sPath
98037>>>>>    End                   
98037>>>>>>
98037>>>>>    
98037>>>>>    Move (sDriverID + ".dll") to sDriverFileName
98038>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
98039>>>>>    
98039>>>>>    Function_Return sPath
98040>>>>>End_Function      
98041>>>>>
98041>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
98044>>>>>    String sPath sDriverFileName
98044>>>>>
98044>>>>>    Move "" to sPath
98045>>>>>    If (sDriverID = DATAFLEX_ID) Begin
98047>>>>>        Function_Return sPath
98048>>>>>    End                   
98048>>>>>>
98048>>>>>    
98048>>>>>    Move (sDriverID + ".int") to sDriverFileName
98049>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
98050>>>>>    
98050>>>>>    Function_Return sPath
98051>>>>>End_Function      
98052>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
98052>>>>>Use Windows.pkg
98052>>>>>Use cRDCModalPanel.pkg
98052>>>>>Use cRDCForm.pkg 
98052>>>>>Use cRDCComboForm.pkg
98052>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCSuggestionIniForm.pkg)
98052>>>>>>>//****************************************************************************
98052>>>>>>>// $Module type: Class
98052>>>>>>>// $Module name: cRDCSuggestionIniForm
98052>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
98052>>>>>>>// Web-site    : http://www.rdctools.com
98052>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
98052>>>>>>>//
98052>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
98052>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
98052>>>>>>>//
98052>>>>>>>// $Rev History:
98052>>>>>>>//    2018-09-05  Module header created
98052>>>>>>>//
98052>>>>>>>//****************************************************************************
98052>>>>>>>Use Windows.pkg
98052>>>>>>>Use Windows.pkg
98052>>>>>>>Use WinSuggestion.pkg
98052>>>>>>>Use cIniFile.pkg
98052>>>>>>>Use cRDCForm.pkg
98052>>>>>>>Use vWin32fh.pkg
98052>>>>>>>
98052>>>>>>>Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
98052>>>>>>>Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
98052>>>>>>>Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
98052>>>>>>>
98052>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
98053>>>>>>>
98053>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
98055>>>>>>>
98055>>>>>>>        Property Integer piTimeOutTicks 0
98056>>>>>>>
98056>>>>>>>        On_Key kEnter            Send SelectSuggestion
98057>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
98058>>>>>>>        On_Key Key_Up_Arrow      Send Up
98059>>>>>>>        On_Key Key_Down_Arrow    Send Down
98060>>>>>>>
98060>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
98060>>>>>>>        On_Key Key_Home          Send Home
98061>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
98062>>>>>>>    On_Key Key_End           Send End
98063>>>>>>>On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
98064>>>>>>>
98064>>>>>>>// Just can't seem to get the popup of the suggestion list with F4 to work.
98064>>>>>>>On_Key kPrompt           Send Prompt
98065>>>>>>>End_Procedure
98066>>>>>>>
98066>>>>>>>Import_Class_Protocol cSuggestionControl_mixin
98067>>>>>>>Import_Class_Protocol cSuggestion_mixin
98068>>>>>>>
98068>>>>>>>Procedure Construct_Object
98070>>>>>>>    Forward Send Construct_Object
98072>>>>>>>    Send Define_cRDCSuggestionControl_mixin
98073>>>>>>>    Send Define_cSuggestion_mixin
98074>>>>>>>
98074>>>>>>>    Set peSuggestionMode to smCustom
98075>>>>>>>    Set pbFullText to True
98076>>>>>>>    Set piStartAtChar to 1
98077>>>>>>>
98077>>>>>>>    Property String[] psSavedFormValues
98078>>>>>>>    Property String psIniFileSection
98079>>>>>>>    Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
98080>>>>>>>    Property Boolean pbUseWorkspaceIniFile True
98081>>>>>>>    Property Boolean pbAutoCheckValueExistsAsFile True
98082>>>>>>>    Property Boolean pbAskToRemoveMissingFile True
98083>>>>>>>    // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
98083>>>>>>>    //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
98083>>>>>>>    //       worspace .ws file on program startup.
98083>>>>>>>    Property String psIniFileName "RDCSuggestionForm.ini"
98084>>>>>>>End_Procedure
98085>>>>>>>
98085>>>>>>>Procedure ShowSuggestions
98087>>>>>>>    tSuggestion[] aResults
98087>>>>>>>    tSuggestion[] aResults
98088>>>>>>>    Integer i iLines
98088>>>>>>>    String sSearch
98088>>>>>>>
98088>>>>>>>    Get pSearchResults to aResults
98089>>>>>>>    Get Value to sSearch
98090>>>>>>>
98090>>>>>>>    If (ghoSuggestionList <> 0) Begin
98092>>>>>>>        Send Delete_Data of ghoSuggestionList
98093>>>>>>>        Move (SizeOfArray(aResults)) to iLines
98094>>>>>>>        For i from 0 to (iLines-1)
98100>>>>>>>>
98100>>>>>>>            Send ShowSuggestion aResults[i] sSearch
98101>>>>>>>            If ((iLines-1)<>i) Begin
98103>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
98104>>>>>>>            End
98104>>>>>>>>
98104>>>>>>>        Loop
98105>>>>>>>>
98105>>>>>>>        Send AdjustSuggestionListSize iLines
98106>>>>>>>    End
98106>>>>>>>>
98106>>>>>>>
98106>>>>>>>    Set Cursor of Cursor_Control to IDC_ARROW
98107>>>>>>>    Send Activate of (Self)
98108>>>>>>>    Send Release_Mouse_Capture
98109>>>>>>>End_Procedure
98110>>>>>>>
98110>>>>>>>Procedure Home
98112>>>>>>>    If (Focus(Desktop) = Self and ghoSuggestionList) Begin
98114>>>>>>>        Send ScrollHome
98115>>>>>>>    End
98115>>>>>>>>
98115>>>>>>>    Else Begin
98116>>>>>>>        Send Key VK_HOME
98117>>>>>>>    End
98117>>>>>>>>
98117>>>>>>>End_Procedure
98118>>>>>>>
98118>>>>>>>Procedure ScrollHome
98120>>>>>>>    Send SelectRow of ghoSuggestionList 0
98121>>>>>>>End_Procedure
98122>>>>>>>
98122>>>>>>>Procedure End
98124>>>>>>>If (Focus(Desktop) = Self and ghoSuggestionList) Begin
98126>>>>>>>    Send ScrollEnd
98127>>>>>>>End
98127>>>>>>>>
98127>>>>>>>Else Begin
98128>>>>>>>    Send Key VK_END
98129>>>>>>>End
98129>>>>>>>>
98129>>>>>>>End_Procedure
98130>>>>>>>
98130>>>>>>>Procedure ScrollEnd
98132>>>>>>>    Integer iLine iLines
98132>>>>>>>    Get Line_Count of ghoSuggestionList  to iLines
98133>>>>>>>    Get SelectedRow of ghoSuggestionList to iLine
98134>>>>>>>    // there can be an extra line at the end
98134>>>>>>>    If (iLine < iLines - 1) Begin
98136>>>>>>>        Send SelectRow of ghoSuggestionList (iLines - 1)
98137>>>>>>>    End
98137>>>>>>>>
98137>>>>>>>End_Procedure
98138>>>>>>>
98138>>>>>>>Procedure Activating
98140>>>>>>>    String[] sSavedFormValues
98141>>>>>>>    If (pbUseWorkspaceIniFile(Self) = True) Begin
98143>>>>>>>        Get ReadWorkspaceIniFile to sSavedFormValues
98144>>>>>>>        Set psSavedFormValues    to sSavedFormValues
98145>>>>>>>    End
98145>>>>>>>>
98145>>>>>>>End_Procedure
98146>>>>>>>
98146>>>>>>>Procedure Set psToolTip String sToolTip
98148>>>>>>>    String sStatusHelp
98148>>>>>>>
98148>>>>>>>    Get Status_Help to sStatusHelp
98149>>>>>>>    If (sStatusHelp = "") Begin
98151>>>>>>>        Set Status_Help to sToolTip
98152>>>>>>>    End
98152>>>>>>>>
98152>>>>>>>
98152>>>>>>>    Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
98153>>>>>>>    Forward Set psToolTip to sToolTip
98155>>>>>>>End_Procedure
98156>>>>>>>
98156>>>>>>>Function ReadWorkspaceIniFile Returns String[]
98158>>>>>>>    String sWorkspaceFile sObjectName sValue
98158>>>>>>>    String[] sSavedFormValues
98159>>>>>>>    Handle hoIniFile
98159>>>>>>>    Integer iItem iCount iSize
98159>>>>>>>    Boolean bExists
98159>>>>>>>
98159>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98161>>>>>>>        Function_Return sSavedFormValues
98162>>>>>>>    End
98162>>>>>>>>
98162>>>>>>>
98162>>>>>>>    Move 0 to iItem
98163>>>>>>>    Get Object_Label to sObjectName
98164>>>>>>>    Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
98165>>>>>>>    Set psIniFileName to sWorkspaceFile
98166>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
98167>>>>>>>    Set psFileName of hoIniFile to sWorkspaceFile
98168>>>>>>>    Get piSuggestionListMaxItems to iSize
98169>>>>>>>
98169>>>>>>>    For iCount from 0 to iSize
98175>>>>>>>>
98175>>>>>>>        Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
98176>>>>>>>        // We need to loop through all possible values because the list of items may not start at zero.
98176>>>>>>>        Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
98177>>>>>>>        If (Trim(sValue) <> "") Begin
98179>>>>>>>            Move sValue to sSavedFormValues[iItem]
98180>>>>>>>            Increment iItem
98181>>>>>>>        End
98181>>>>>>>>
98181>>>>>>>    Loop
98182>>>>>>>>
98182>>>>>>>
98182>>>>>>>    Send Destroy of hoIniFile
98183>>>>>>>    Function_Return sSavedFormValues
98184>>>>>>>End_Function
98185>>>>>>>
98185>>>>>>>Procedure WriteWorkspaceIniFile
98187>>>>>>>    String sWorkspaceFile sObjectName sValue
98187>>>>>>>    String[] sSavedFormValues
98188>>>>>>>    Handle hoIniFile
98188>>>>>>>    Integer iSize iCount
98188>>>>>>>    Boolean bExists
98188>>>>>>>
98188>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98190>>>>>>>        Procedure_Return
98191>>>>>>>    End
98191>>>>>>>>
98191>>>>>>>
98191>>>>>>>    Get Object_Label  to sObjectName
98192>>>>>>>    Get psIniFileName to sWorkspaceFile
98193>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
98194>>>>>>>    Set psFileName    of hoIniFile to sWorkspaceFile
98195>>>>>>>    Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
98196>>>>>>>    If (bExists = True) Begin
98198>>>>>>>        Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
98199>>>>>>>    End
98199>>>>>>>>
98199>>>>>>>
98199>>>>>>>    Get psSavedFormValues to sSavedFormValues
98200>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98201>>>>>>>    Decrement iSize
98202>>>>>>>
98202>>>>>>>    For iCount from 0 to iSize
98208>>>>>>>>
98208>>>>>>>        Move sSavedFormValues[iCount] to sValue
98209>>>>>>>        Move (Trim(sValue)) to sValue
98210>>>>>>>        Get vFilePathExists sValue to bExists
98211>>>>>>>        If (bExists = True) Begin
98213>>>>>>>            Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
98214>>>>>>>        End
98214>>>>>>>>
98214>>>>>>>    Loop
98215>>>>>>>>
98215>>>>>>>
98215>>>>>>>    Send Destroy of hoIniFile
98216>>>>>>>End_Procedure
98217>>>>>>>
98217>>>>>>>Procedure Prompt
98219>>>>>>>    If (ghoSuggestionTimer=0) Begin
98221>>>>>>>        Send CreateSuggestionTimer
98222>>>>>>>    End
98222>>>>>>>>
98222>>>>>>>    Send ActivateSuggestionList
98223>>>>>>>    Send FindSuggestions
98224>>>>>>>    Set Visible_State of ghoSuggestionList to True
98225>>>>>>>End_Procedure
98226>>>>>>>
98226>>>>>>>Procedure OnExitObject
98228>>>>>>>    String sValue
98228>>>>>>>    Boolean bExists
98228>>>>>>>    String[] sSavedFormValues
98229>>>>>>>    Integer iSize iIndex
98229>>>>>>>
98229>>>>>>>    Forward Send OnExitObject
98231>>>>>>>
98231>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98233>>>>>>>        Procedure_Return
98234>>>>>>>    End
98234>>>>>>>>
98234>>>>>>>
98234>>>>>>>    Get Value to sValue
98235>>>>>>>    Move (Trim(sValue)) to sValue
98236>>>>>>>    Get psSavedFormValues to sSavedFormValues
98237>>>>>>>    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
98238>>>>>>>    // Does it exist in the array already?
98238>>>>>>>    If (iIndex <> -1) Begin
98240>>>>>>>        Procedure_Return
98241>>>>>>>    End
98241>>>>>>>>
98241>>>>>>>    Get vFilePathExists sValue to bExists
98242>>>>>>>    If (bExists = False) Begin
98244>>>>>>>        Procedure_Return
98245>>>>>>>    End
98245>>>>>>>>
98245>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98246>>>>>>>    Move sValue to sSavedFormValues[iSize]
98247>>>>>>>    Set psSavedFormValues to sSavedFormValues
98248>>>>>>>    Send WriteWorkspaceIniFile
98249>>>>>>>End_Procedure
98250>>>>>>>
98250>>>>>>>// Custom code to find all matches for the search
98250>>>>>>>Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
98252>>>>>>>    String[] sSavedFormValues
98253>>>>>>>    Integer i iLen iSize iCount
98253>>>>>>>
98253>>>>>>>    Move (Lowercase(sSearch)) to sSearch
98254>>>>>>>    Move (Length(sSearch)) to iLen
98255>>>>>>>    Get psSavedFormValues to sSavedFormValues
98256>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98257>>>>>>>    Decrement iSize
98258>>>>>>>    For i from 0 to iSize
98264>>>>>>>>
98264>>>>>>>        If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
98266>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
98267>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
98268>>>>>>>            Increment iCount
98269>>>>>>>        End
98269>>>>>>>>
98269>>>>>>>    Loop
98270>>>>>>>>
98270>>>>>>>End_Procedure
98271>>>>>>>
98271>>>>>>>Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
98273>>>>>>>    Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
98273>>>>>>>    Integer iRetval iIndex
98273>>>>>>>    String[] sSavedFormValues
98274>>>>>>>    String sValue
98274>>>>>>>
98274>>>>>>>    //        Send Release_Mouse_Capture
98274>>>>>>>    Move Suggestion.sRowId to sValue
98275>>>>>>>    Move (Trim(sValue)) to sValue
98276>>>>>>>    Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
98277>>>>>>>
98277>>>>>>>    If (bAutoCheckValueExistsAsFile = True) Begin
98279>>>>>>>        Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
98280>>>>>>>        Get vFilePathExists sValue to bExists
98281>>>>>>>        If (bExists = False) Begin
98283>>>>>>>            If (bAskToRemoveMissingFile = True) Begin
98285>>>>>>>                Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
98286>>>>>>>            End
98286>>>>>>>>
98286>>>>>>>            // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
98286>>>>>>>            // Then the missing file will just be removed from the saved list.
98286>>>>>>>            Else Begin
98287>>>>>>>                Move MBR_Yes to iRetval
98288>>>>>>>            End
98288>>>>>>>>
98288>>>>>>>
98288>>>>>>>            If (iRetval = MBR_Yes) Begin
98290>>>>>>>                Get psSavedFormValues to sSavedFormValues
98291>>>>>>>                Move (SearchArray(sValue, sSavedFormValues)) to iIndex
98292>>>>>>>                If (iIndex <> -1) Begin
98294>>>>>>>                    Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
98295>>>>>>>                    Set psSavedFormValues to sSavedFormValues
98296>>>>>>>                    Send WriteWorkspaceIniFile
98297>>>>>>>                    Set Value to ""
98298>>>>>>>                    Procedure_Return
98299>>>>>>>                End
98299>>>>>>>>
98299>>>>>>>            End
98299>>>>>>>>
98299>>>>>>>        End
98299>>>>>>>>
98299>>>>>>>    End
98299>>>>>>>>
98299>>>>>>>
98299>>>>>>>    Set Value to Suggestion.sRowId
98300>>>>>>>    Set Item_Changed_State to False
98301>>>>>>>End_Procedure
98302>>>>>>>
98302>>>>>>>//    { MethodType=Event  NoDoc=True }
98302>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
98302>>>>>>>//        Send Release_Mouse_Capture
98302>>>>>>>//        Forward Send Mouse_click i1 i2
98302>>>>>>>//    End_Procedure
98302>>>>>>>
98302>>>>>>>End_Class
98303>>>>>>>
98303>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
98303>>>>>>>//        Handle hoObj
98303>>>>>>>//        Send Release_Mouse_Capture
98303>>>>>>>//        Get phoOwner to hoObj
98303>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
98303>>>>>>>//        Send SelectSuggestion of hoObj
98303>>>>>>>//    End_Procedure // Mouse_Up
98303>>>>>>>
98303>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
98303>>>>>>>//        tWinMouseHookStruct MouseHook
98303>>>>>>>//        Integer ivoid hObj
98303>>>>>>>//        Handle hoOwner hoParent
98303>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
98303>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
98303>>>>>>>//            Send Release_Mouse_Capture
98303>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
98303>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
98303>>>>>>>//            If (hObj = Cursor_Control) Begin
98303>>>>>>>//                Move (Focus(Desktop)) to hObj
98303>>>>>>>//            End
98303>>>>>>>//            Get Parent to hoParent
98303>>>>>>>//            Get phoOwner of hoParent to hoOwner
98303>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
98303>>>>>>>//                Send DisableWindowsHook
98303>>>>>>>//                Send DeActivateSuggestionList of hoOwner
98303>>>>>>>//            End
98303>>>>>>>//        End
98303>>>>>>>//    End_Function
98303>>>>>>>
98303>>>>>Use cDbUpdateFunctionLibrary.pkg
98303>>>>>Use cRDCHeaderGroup.pkg
98303>>>>>Use cCommandLinkButton.pkg
98303>>>>>
98303>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
98305>>>>>    Set Size to 151 312
98306>>>>>    Set Label to "Create New Database"
98307>>>>>    Set piMinSize to 53 211
98308>>>>>    Set Location to 2 2
98309>>>>>    Set Icon to "ActionCreateDatabase1.ico"
98310>>>>>    
98310>>>>>    Property String psDriverID                   
98312>>>>>    Property String psCollation 
98314>>>>>    Property String psDatabaseName 
98316>>>>>
98316>>>>>//    Object oCollate_cf is a cRDCComboForm
98316>>>>>//        Set Size to 13 216
98316>>>>>//        Set Location to 42 63
98316>>>>>//        Set Label to "Use Collation:"  
98316>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
98316>>>>>//        // This must be set to False; else the filling takes for ever.
98316>>>>>//        Set pbAutoListWidth to False
98316>>>>>//        
98316>>>>>//        Procedure Combo_Fill_List
98316>>>>>//            String[] asCollations   
98316>>>>>//            Integer iCount iSize      
98316>>>>>//            String sDriverID sCollation
98316>>>>>//            
98316>>>>>//            Get psDriverID to sDriverID      
98316>>>>>//            
98316>>>>>//            // The _SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
98316>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
98316>>>>>//                Send Cursor_Wait of Cursor_Control
98316>>>>>//                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
98316>>>>>//                Move (SizeOfArray(asCollations)) to iSize
98316>>>>>//                Decrement iSize
98316>>>>>//                For iCount from 0 to iSize
98316>>>>>//                    Send Combo_Add_Item asCollations[iCount]
98316>>>>>//                Loop
98316>>>>>//                
98316>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
98316>>>>>//                Set Value to sCollation
98316>>>>>//                Send Cursor_Ready of Cursor_Control
98316>>>>>//            End
98316>>>>>//        End_Procedure
98316>>>>>//    
98316>>>>>//        Procedure OnChange
98316>>>>>//            String sValue
98316>>>>>//            Get Value to sValue
98316>>>>>//            Set psCollation to sValue
98316>>>>>//        End_Procedure
98316>>>>>//     
98316>>>>>//    End_Object
98316>>>>>
98316>>>>>    Object oInfo_tb is a TextBox
98318>>>>>        Set Auto_Size_State to False
98319>>>>>        Set Size to 8 50
98320>>>>>        Set Location to 133 120
98321>>>>>        Set TextColor to clGreen
98322>>>>>        Set Justification_Mode to JMode_Right
98323>>>>>        Set peAnchors to anBottomRight
98324>>>>>    End_Object
98325>>>>>
98325>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
98327>>>>>        Set Size to 108 293
98328>>>>>        Set Location to 8 10
98329>>>>>        Set psImage to "ActionCreateDatabase1.ico"
98330>>>>>        Set Label to "Create Database"
98331>>>>>        Set psNote to "Enter collation and database name"
98332>>>>>        Set peAnchors to anTopBottom
98333>>>>>
98333>>>>>        Object oDriver_fm is a cRDCForm
98335>>>>>            Set Size to 13 100
98336>>>>>            Set Location to 34 63
98337>>>>>            Set Label to "Driver"
98338>>>>>            Set Enabled_State to False  
98339>>>>>        End_Object  
98340>>>>>        
98340>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
98342>>>>>            Set Size to 13 216
98343>>>>>            Set Location to 49 63
98344>>>>>            Set Label to "Default Collation"
98345>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
98346>>>>>            Set Enabled_State to False  
98347>>>>>            
98347>>>>>            Procedure InitializeCollation 
98350>>>>>                String sCollation
98350>>>>>                
98350>>>>>                Move False to Err
98351>>>>>                Send Ignore_All of Error_Object_Id
98352>>>>>                // Fetch the SQL server's default collation:
98352>>>>>                // It will be used when creating a new database, if nothing else is specified.
98352>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
98353>>>>>                Send Trap_All of Error_Object_Id
98354>>>>>                If (Err = True) Begin
98356>>>>>                    Move "" to sCollation
98357>>>>>                End
98357>>>>>>
98357>>>>>                Set Value to sCollation
98358>>>>>            End_Procedure     
98359>>>>>    
98359>>>>>        End_Object  
98360>>>>>        
98360>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
98362>>>>>            Set Size to 13 216
98363>>>>>            Set Location to 65 63
98364>>>>>            Set Label to "Collation"
98365>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
98366>>>>>            Set pbAskToRemoveMissingFile to False
98367>>>>>            Set pbAutoCheckValueExistsAsFile to False
98368>>>>>            Set pbUseWorkspaceIniFile to True
98369>>>>>            Set piStartAtChar to 3
98370>>>>>            Set Prompt_Button_Mode to PB_PromptOn
98371>>>>>            
98371>>>>>            Function ReadWorkspaceIniFile Returns String[]
98374>>>>>                String[] asCollations   
98375>>>>>                Integer iCount iSize      
98375>>>>>                String sDriverID sCollation
98375>>>>>                
98375>>>>>                Get psDriverID to sDriverID      
98376>>>>>                // The _SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
98376>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
98378>>>>>                    Function_Return asCollations
98379>>>>>                End                 
98379>>>>>>
98379>>>>>                
98379>>>>>                Send Cursor_Wait of Cursor_Control
98380>>>>>                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
98381>>>>>                Set psSavedFormValues to asCollations
98382>>>>>                    
98382>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
98384>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
98385>>>>>                    Set Value to sCollation
98386>>>>>                End
98386>>>>>>
98386>>>>>                Send Cursor_Ready of Cursor_Control
98387>>>>>                Function_Return asCollations
98388>>>>>            End_Function
98389>>>>>    
98389>>>>>            Procedure OnChange
98392>>>>>                String sValue
98392>>>>>                Get Value to sValue
98393>>>>>                Set psCollation to sValue
98394>>>>>            End_Procedure
98395>>>>>         
98395>>>>>            Procedure WriteWorkspaceIniFile
98398>>>>>            End_Procedure             
98399>>>>>            
98399>>>>>//            Procedure Prompt      
98399>>>>>//                If (ghoSuggestionTimer=0) Begin
98399>>>>>//                    Send CreateSuggestionTimer
98399>>>>>//                End
98399>>>>>//                Send ActivateSuggestionList
98399>>>>>//                Send FindSuggestions
98399>>>>>//                Set Visible_State of ghoSuggestionList to True
98399>>>>>//            End_Procedure 
98399>>>>>            
98399>>>>>            Procedure OnEnterObject
98402>>>>>                Set pbUseWorkspaceIniFile to True
98403>>>>>                Forward Send OnEnterObject
98405>>>>>            End_Procedure
98406>>>>>
98406>>>>>            Procedure OnExitObject
98409>>>>>                Set pbUseWorkspaceIniFile to False
98410>>>>>                Forward Send OnExitObject
98412>>>>>            End_Procedure
98413>>>>>        
98413>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
98414>>>>>//            On_Key kPrompt Send Prompt
98414>>>>>        End_Object   
98415>>>>>        
98415>>>>>        Object oDatabaseName_fm is a cRDCForm
98417>>>>>            Set Size to 13 216
98418>>>>>            Set Location to 81 63
98419>>>>>            Set Label_Col_Offset to 2
98420>>>>>            Set Label_Justification_Mode to JMode_Right
98421>>>>>            Set Label to "Database Name"
98422>>>>>            Set psToolTip to "Specify the name of the database to be created."
98423>>>>>        End_Object
98424>>>>>    
98424>>>>>    End_Object
98425>>>>>
98425>>>>>    Object oOK_Btn is a Button
98427>>>>>        Set Label    to "&OK"
98428>>>>>        Set Location to 130 198
98429>>>>>        Set peAnchors to anBottomRight   
98430>>>>>        
98430>>>>>        Property String psWorkingText "Working..."
98432>>>>>        Property String psIdleText    ""
98434>>>>>
98434>>>>>        Procedure OnClick
98437>>>>>            String sDatabase sDriverID sCollation
98437>>>>>            Boolean bOK bExists
98437>>>>>        
98437>>>>>            Get Value of oDatabaseName_fm to sDatabase    
98438>>>>>            Get psDriverID to sDriverID
98439>>>>>            Set psDatabaseName to ""
98440>>>>>
98440>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
98442>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
98443>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
98445>>>>>                    Get psCollation to sCollation
98446>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
98447>>>>>                End
98447>>>>>>
98447>>>>>
98447>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
98448>>>>>                If (bExists = True) Begin
98450>>>>>                    Set Value of oInfo_tb to ""
98451>>>>>                    Send Info_Box "The database already exists. No changes made."
98452>>>>>                    Procedure_Return
98453>>>>>                End
98453>>>>>>
98453>>>>>                Send Cursor_Wait of Cursor_Control     
98454>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
98455>>>>>                Send Cursor_Ready of Cursor_Control
98456>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
98457>>>>>                If (bOK = False) Begin
98459>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
98460>>>>>                    Procedure_Return
98461>>>>>                End 
98461>>>>>>
98461>>>>>                Set psDatabaseName to sDatabase
98462>>>>>                Send Close_Panel
98463>>>>>            End                                 
98463>>>>>>
98463>>>>>            Else If (sDatabase = "") Begin
98466>>>>>                Send Info_Box ("Please enter a database name and try again.")
98467>>>>>            End
98467>>>>>>
98467>>>>>        End_Procedure
98468>>>>>
98468>>>>>    End_Object
98469>>>>>
98469>>>>>    Object oCancel_Btn is a Button
98471>>>>>        Set Label    to "&Cancel"
98472>>>>>        Set Location to 130 253
98473>>>>>        Set peAnchors to anBottomRight
98474>>>>>
98474>>>>>        Procedure OnClick
98477>>>>>            Send Close_Panel
98478>>>>>        End_Procedure
98479>>>>>
98479>>>>>    End_Object
98480>>>>>
98480>>>>>    Object oHelp_btn is a Button
98482>>>>>        Set Location to 130 75
98483>>>>>        Set Label to "Help"
98484>>>>>        Set psImage to "ActionHelpInternet1.ico"
98485>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
98486>>>>>        Set peAnchors to anBottomLeft
98487>>>>>    
98487>>>>>        Procedure OnClick
98490>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
98491>>>>>        End_Procedure
98492>>>>>    
98492>>>>>    End_Object
98493>>>>>    
98493>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
98494>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98495>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98496>>>>>End_Object
98497>>>>>
98497>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
98500>>>>>    String sDatabaseName         
98500>>>>>    Handle ho
98500>>>>>    
98500>>>>>    Move (oCreateDatabase_dg(Self)) to ho
98501>>>>>    Set psDriverID of ho to sDriverID
98502>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
98503>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
98504>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
98505>>>>>    Send Popup of ho
98506>>>>>    
98506>>>>>    Get psDatabaseName of ho to sDatabaseName
98507>>>>>    Function_Return sDatabaseName
98508>>>>>End_Function                         
98509>>>
98509>>>Define CS_LoadingServers        for "Enumerating servers..."
98509>>>Define CS_LoadingDatabases      for "Enumerating databases..."
98509>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
98509>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
98509>>>Define CS_LoginAttempt          for "Connecting..."
98509>>>Define CS_LoginSuccessful       for "Login successful!"
98509>>>Define CS_LoginFailed           for "Login failed!"
98509>>>Define CS_DF_File_Schema        for "Schema"
98509>>>Define CS_DF_File_Owner         for "Owner"
98509>>>
98509>>>Object oSQLMaintainConnections_dg is a ModalPanel
98511>>>    Set Label to "Edit SQL Connection"
98512>>>    Set Size to 315 324 //309 324
98513>>>    Set Location to 4 6
98514>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
98515>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
98516>>>    Set Locate_Mode to CENTER_ON_PARENT
98517>>>    Set Border_Style to Border_Thick
98518>>>    
98518>>>    Property Boolean pbReadOnly  False
98520>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
98522>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
98524>>>    Property Boolean pbChanged   False // If any change was made to the data.
98526>>>    Property Handle phoDialogCommandbar
98528>>>    Property tSQLConnection pSQLConnectionData
98530>>>    Property tDataSourceRow[] pTheData
98532>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
98534>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
98536>>>
98536>>>    Object oSettings_grp is a cRDCHeaderGroup
98538>>>        Set Size to 202 303
98539>>>        Set Location to 77 11 //71 11
98540>>>        Set psImage to "Settings1.ico"
98541>>>        Set psLabel to "SQL Connection Settings"
98542>>>        Set peAnchors to anTopLeftRight
98543>>>        Set psToolTip to "Setup the SQL connection."
98544>>>
98544>>>        Object oConnectionID_fm is a cSQLForm
98546>>>            Set Size to 13 115
98547>>>            Set Location to 22 82
98548>>>            Set Label to "Connection ID"
98549>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
98550>>>            Set piItem to 2
98551>>>            Set peAnchors to anTopLeftRight
98552>>>        End_Object
98553>>>
98553>>>        Object oEnabled_cb is a cSQLCheckBox
98555>>>            Set Size to 10 36
98556>>>            Set Location to 25 210
98557>>>            Set Label to "Enabled"
98558>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
98559>>>            Set piItem to 1
98560>>>            Set peAnchors to anTopRight
98561>>>
98561>>>            Procedure OnChange
98564>>>                Boolean bChecked bNew
98564>>>                tSQLConnection SQLConnection
98564>>>                tSQLConnection SQLConnection
98564>>>
98564>>>                Get pbNew to bNew
98565>>>                Get Checked_State to bChecked
98566>>>                If (bNew = False and bChecked = True) Begin
98568>>>                    Get pSQLConnectionData to SQLConnection
98569>>>                    Move True to SQLConnection.bEnabled
98570>>>                End
98570>>>>
98570>>>
98570>>>            End_Procedure
98571>>>
98571>>>        End_Object
98572>>>
98572>>>        Object oODBC_rgp is a RadioGroup
98574>>>            Set Location to 38 24
98575>>>            Set Size to 32 173
98576>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
98576>>>            Set peAnchors to anTopLeftRight
98577>>>            Set Label to "ODBC Source Type"
98578>>>
98578>>>            Object oRadio0 is a Radio
98580>>>                Set Label to "User data"
98581>>>                Set Size to 10 44
98582>>>                Set Location to 12 5
98583>>>            End_Object
98584>>>
98584>>>            Object oRadio1 is a Radio
98586>>>                Set Label to "System data"
98587>>>                Set Size to 10 52
98588>>>                Set Location to 12 52
98589>>>            End_Object
98590>>>
98590>>>            Object oRadio2 is a Radio
98592>>>                Set Label to "Both"
98593>>>                Set Size to 10 26
98594>>>                Set Location to 13 109
98595>>>            End_Object
98596>>>
98596>>>            Object oRadio3 is a Radio
98598>>>                Set Label to "File"
98599>>>                Set Size to 10 25
98600>>>                Set Location to 13 141
98601>>>            End_Object
98602>>>
98602>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
98605>>>                Forward Send Notify_Select_State iToItem iFromItem 
98607>>>                If (oFileDSN_btn(Self) <> 0) Begin
98609>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
98610>>>                End
98610>>>>
98610>>>            End_Procedure
98611>>>
98611>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98614>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
98615>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
98616>>>            End_Procedure
98617>>>
98617>>>            Set Current_Radio to 2
98618>>>        End_Object
98619>>>
98619>>>        Object oFileDSN_btn is a cRDCButton
98621>>>            Set Size to 13 78
98622>>>            Set Location to 42 210
98623>>>            Set Label to "Select File DSN..."
98624>>>            Set pbAutoEnable to True
98625>>>            Set peAnchors to anTopRight
98626>>>
98626>>>            Procedure OnClick
98629>>>                String sFileName
98629>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
98630>>>                If (sFileName <> "") Begin
98632>>>                    Set Value of oServer_fm to sFileName
98633>>>                End
98633>>>>
98633>>>            End_Procedure     
98634>>>            
98634>>>            Function IsEnabled Returns Boolean
98637>>>                String sDriverID
98637>>>                Integer iRadio
98637>>>                Get Value of oDriverID_cf to sDriverID
98638>>>                Get Current_Radio of oODBC_rgp to iRadio
98639>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
98640>>>            End_Function
98641>>>
98641>>>        End_Object
98642>>>
98642>>>        Object oODBCAdmin_btn is a cRDCButton
98644>>>            Set Size to 13 78
98645>>>            Set Location to 57 210
98646>>>            Set Label to "ODBC Admin" 
98647>>>            Set psImage to "ODBCAD32.ico"
98648>>>            Set pbAutoEnable to True
98649>>>            Set peAnchors to anTopRight
98650>>>            
98650>>>            Procedure OnClick
98653>>>                Handle hWnd
98653>>>                Get Window_Handle to hWnd
98654>>>                If (hWnd <> 0) Begin
98656>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
98661>>>                End
98661>>>>
98661>>>                Else Begin
98662>>>                    Send Stop_Box "Could not get a Windows handle.."
98663>>>                End
98663>>>>
98663>>>            End_Procedure
98664>>>
98664>>>            Function IsEnabled Returns Boolean
98667>>>                String sDriverID
98667>>>                Get Value of oDriverID_cf to sDriverID
98668>>>                Function_Return (sDriverID = ODBC_DRV_ID)
98669>>>            End_Function
98670>>>
98670>>>        End_Object
98671>>>
98671>>>        Object oServer_fm is a cSQLForm
98673>>>            Set Size to 13 114
98674>>>            Set Location to 74 82
98675>>>            Set Label to "Server"
98676>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
98677>>>            Set piItem to 5
98678>>>            Set peAnchors to anTopLeftRight
98679>>>
98679>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
98681>>>
98681>>>            Procedure Prompt
98684>>>                String sDriverID sValue
98684>>>                String[] sTheData
98685>>>                Integer iDbType iODBCType iRadio iPos
98685>>>                Handle ho
98685>>>
98685>>>                Get Prompt_Object to ho
98686>>>                If (ho = 0) Begin
98688>>>                    Procedure_Return
98689>>>                End
98689>>>>
98689>>>
98689>>>                Set Label of oShowInfo_tb to CS_LoadingServers
98690>>>                Send Cursor_Wait of Cursor_Control
98691>>>                Get SelectedDbType of oDbType_cf to iDbType
98692>>>                Get Value of oDriverID_cf to sDriverID
98693>>>                Move (Trim(sDriverID)) to sDriverID
98694>>>                Get Current_Radio of oODBC_rgp to iRadio
98695>>>                If (iRadio = 0) Begin
98697>>>                    Move SQL_FETCH_USER   to iODBCType
98698>>>                End
98698>>>>
98698>>>                If (iRadio = 1) Begin
98700>>>                    Move SQL_FETCH_SYSTEM to iODBCType
98701>>>                End
98701>>>>
98701>>>                If (iRadio = 2) Begin
98703>>>                    Move SQL_FETCH_ALL    to iODBCType
98704>>>                End
98704>>>>
98704>>>
98704>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98705>>>                Load_Driver sDriverID
98706>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98707>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
98709>>>                    Send Cursor_Ready of Cursor_Control
98710>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
98711>>>                    Procedure_Return
98712>>>                End
98712>>>>
98712>>>
98712>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
98713>>>                Set psTheData  of ho to sTheData
98714>>>                Set Label of oShowInfo_tb to ""
98715>>>
98715>>>                Forward Send Prompt
98717>>>
98717>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
98717>>>                // We need to remove those parts from the comma and to the end of string.
98717>>>                If (sDriverID = ODBC_DRV_ID) Begin
98719>>>                    Get Value to sValue
98720>>>                    Move (Pos(",", sValue)) to iPos
98721>>>                    Move (Left(sValue, (iPos - 1))) to sValue
98722>>>                    Set Value to sValue
98723>>>                End
98723>>>>
98723>>>            End_Procedure
98724>>>
98724>>>            Procedure OnChange
98727>>>                tSQLIntTableInfo[] sReturnStructArray
98727>>>                tSQLIntTableInfo[] sReturnStructArray
98728>>>                String sServer sDatabaseName sVal sDriverID
98728>>>                Integer iSize iCount iPos 
98728>>>                Boolean bFileDSN
98728>>>                
98728>>>                Move False to bFileDSN
98729>>>                Get Value of oDriverID_cf to sDriverID
98730>>>                If (sDriverID = "") Begin
98732>>>                    Procedure_Return
98733>>>                End
98733>>>>
98733>>>                If (sDriverID = ODBC_DRV_ID) Begin
98735>>>                    Move "" to sDatabaseName
98736>>>                    Get Value to sServer 
98737>>>                    Move (Pos(",", sServer)) to iPos
98738>>>                    If (iPos <> 0) Begin
98740>>>                        Move (Left(sServer, (iPos -1))) to sServer
98741>>>                    End
98741>>>>
98741>>>                    If (sServer <> "") Begin
98743>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
98744>>>                    End
98744>>>>
98744>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
98745>>>                    If (SizeOfArray(sReturnStructArray)) Begin
98747>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
98749>>>                            // If a FILEDSN: (can only be one database name)
98749>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
98750>>>                            Move True to bFileDSN
98751>>>                        End
98751>>>>
98751>>>                        Else Begin
98752>>>                            // Else the DSN's were read from the registry.
98752>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
98753>>>                            Decrement iSize
98754>>>                            For iCount from 0 to iSize
98760>>>>
98760>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
98761>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
98763>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
98764>>>                                    Move iSize to iCount // We're done.
98765>>>                                End
98765>>>>
98765>>>                            Loop
98766>>>>
98766>>>                        End
98766>>>>
98766>>>                    End
98766>>>>
98766>>>                    Set Value of oDatabase_fm to sDatabaseName
98767>>>                    If (bFileDSN = True) Begin
98769>>>                        Set Current_Radio of oODBC_rgp to 3
98770>>>                    End    
98770>>>>
98770>>>                    Else Begin
98771>>>                        Set Current_Radio of oODBC_rgp to 2
98772>>>                    End
98772>>>>
98772>>>                End
98772>>>>
98772>>>
98772>>>            End_Procedure
98773>>>
98773>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98776>>>                String sLabel
98776>>>                Handle ho
98776>>>
98776>>>                Get phoPromptObject to ho
98777>>>                Set Prompt_Button_Mode to PB_PromptOn
98778>>>                Case Begin
98778>>>                    Case (iDbType = EN_dbTypeDB2)
98780>>>                        Move "DSN" to sLabel
98781>>>                        Case Break
98782>>>                    Case (iDbType = EN_dbTypeMSSQL)
98785>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98787>>>                            Move "ODBC Data Source" to sLabel
98788>>>                        End
98788>>>>
98788>>>                        Else Begin
98789>>>                            Move "Server" to sLabel
98790>>>                        End
98790>>>>
98790>>>                        Case Break
98791>>>                    Case (iDbType = EN_dbTypeMySQL)
98794>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98796>>>                            Move "ODBC Data Source" to sLabel
98797>>>                        End
98797>>>>
98797>>>                        Else Begin
98798>>>                            Move "DSN" to sLabel
98799>>>                        End
98799>>>>
98799>>>                        Case Break
98800>>>                    Case (iDbType = EN_dbTypeOracle)
98803>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98805>>>                            Move "ODBC Data Source" to sLabel
98806>>>                        End
98806>>>>
98806>>>                        Else Begin
98807>>>                            Move "Server" to sLabel
98808>>>                        End
98808>>>>
98808>>>                        Case Break
98809>>>                    Case (iDbType = EN_dbTypePostgre)
98812>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98814>>>                            Move "ODBC Data Source" to sLabel
98815>>>                        End
98815>>>>
98815>>>                        Else Begin
98816>>>                            Move "Server" to sLabel
98817>>>                        End
98817>>>>
98817>>>                        Case Break
98818>>>                    Case Else
98818>>>                Case End
98818>>>
98818>>>                Set Prompt_Object to ho
98819>>>                Set Label to sLabel
98820>>>            End_Procedure
98821>>>
98821>>>        End_Object
98822>>>
98822>>>        Object oSilentLogin_fm is a cSQLCheckBox
98824>>>            Set Size to 10 48
98825>>>            Set Location to 76 210
98826>>>            Set Label to "Silent Login"
98827>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
98828>>>            Set peAnchors to anTopRight
98829>>>            Set piItem to 15
98830>>>        End_Object
98831>>>
98831>>>        Object oTrusted_cb is a cSQLCheckbox
98833>>>            Set Size to 12 85
98834>>>            Set Location to 91 82
98835>>>            Set Label to "Use Trusted Connection"
98836>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
98837>>>            Set piItem to 8
98838>>>
98838>>>            Procedure OnChange
98841>>>                Boolean bChecked
98841>>>                Get Checked_State to bChecked
98842>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
98843>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
98844>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
98845>>>            End_Procedure
98846>>>
98846>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98849>>>                Boolean bChecked
98849>>>
98849>>>                Get Checked_State to bChecked
98850>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
98852>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
98853>>>                    If (bChecked = True) Begin
98855>>>                        Set Checked_State to False
98856>>>                    End
98856>>>>
98856>>>                End
98856>>>>
98856>>>                Else Begin
98857>>>                    Set Enabled_State to True
98858>>>                End
98858>>>>
98858>>>
98858>>>                Send OnChange
98859>>>            End_Procedure
98860>>>
98860>>>        End_Object
98861>>>
98861>>>        Object oUserID_fm is a cSQLForm
98863>>>            Set Size to 13 114
98864>>>            Set Location to 103 82
98865>>>            Set Label to "User ID"
98866>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
98867>>>            Set piItem to 9
98868>>>            Set peAnchors to anTopLeftRight
98869>>>        End_Object
98870>>>
98870>>>        Object oPassword_fm is a cSQLForm
98872>>>            Set Size to 13 61
98873>>>            Set Location to 103 210
98874>>>            Set Label to "Password"
98875>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
98876>>>            Set piItem to 10
98877>>>            Set Password_State to True
98878>>>            Set peAnchors to anTopRight
98879>>>            Set Label_Col_Offset to 0
98880>>>            Set Label_Justification_Mode to JMode_Top
98881>>>        End_Object
98882>>>
98882>>>        Object oShowInfo_tb is a TextBox
98884>>>            Set Auto_Size_State to False
98885>>>            Set Size to 10 114
98886>>>            Set Location to 119 82
98887>>>            Set TextColor to clGreen
98888>>>            Set Justification_Mode to JMode_Center
98889>>>            Set peAnchors to anTopRight
98890>>>        End_Object
98891>>>
98891>>>        Object oViewPassword_btn is a cRDCButton
98893>>>            Set Size to 13 15
98894>>>            Set Location to 103 273
98895>>>            Set psToolTip to "View/hide password"
98896>>>            Set psImage to "ViewPassword1.ico"
98897>>>            Set piImageMarginLeft to 2
98898>>>            Set peAnchors to anTopRight
98899>>>
98899>>>            Procedure OnClick
98902>>>                Handle ho
98902>>>                Boolean bState
98902>>>
98902>>>                Move (oPassword_fm(Self)) to ho
98903>>>                Get Password_State of ho 0 to bState
98904>>>                Send Deactivate of ho
98905>>>                Set Password_State of ho to (not(bState))
98906>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
98906>>>                Send Activate of ho (Parent(Self))
98907>>>            End_Procedure
98908>>>
98908>>>        End_Object
98909>>>
98909>>>        Object oCheckLogin_btn is a cRDCButton
98911>>>            Set Size to 13 78
98912>>>            Set Location to 119 210
98913>>>            Set Label to "Check &Login"
98914>>>            Set psImage to "ActionLogin1.ico"
98915>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
98916>>>            Set piImageMarginLeft to 3
98917>>>            Set peAnchors to anTopRight
98918>>>
98918>>>            Procedure OnClick
98921>>>                String sConnectionString sDriverID sError
98921>>>                Boolean bLoginSuccessful 
98921>>>                Integer iDriverID
98921>>>                Handle hoErrorObj
98921>>>
98921>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
98922>>>                Move Error_Object_Id to hoErrorObj
98923>>>                Move Self to Error_Object_Id
98924>>>                Move False to Err
98925>>>
98925>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
98926>>>                Send PumpMsgQueue
98927>>>                
98927>>>                Get Value of oDriverID_cf to sDriverID
98928>>>                Move "" to sError
98929>>>                Get LoginString (&sError) to sConnectionString
98930>>>                If (sError <> "") Begin
98932>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
98933>>>                    Send Info_Box sError
98934>>>                    Procedure_Return
98935>>>                End
98935>>>>
98935>>>                
98935>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
98936>>>                If (iDriverID = 0) Begin
98938>>>                    Set TextColor of oLoginInfo_tb to clRed
98939>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
98940>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
98941>>>                    Procedure_Return
98942>>>                End
98942>>>>
98942>>>
98942>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
98945>>>
98945>>>                Move False to Err
98946>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
98947>>>
98947>>>                Move (Err = False) to bLoginSuccessful
98948>>>                If bLoginSuccessful Begin
98950>>>                    Set TextColor of oLoginInfo_tb to clGreen
98951>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
98952>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98953>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
98954>>>                End
98954>>>>
98954>>>                Else Begin
98955>>>                    Set TextColor of oLoginInfo_tb to clRed
98956>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
98957>>>                End
98957>>>>
98957>>>
98957>>>                Move hoErrorObj to Error_Object_Id
98958>>>                Send Cursor_Ready of Cursor_Control
98959>>>            End_Procedure
98960>>>
98960>>>            // This method is here simply to intercept any error that may occur while logging in
98960>>>            // it does not have to do anything with the error, but it suppresses the normal error display
98960>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
98963>>>                If (LastErr = 25000) Begin
98965>>>                    If (Trim(sErrMsg) <> "") Begin
98967>>>                        Send Info_Box sErrMsg
98968>>>                    End
98968>>>>
98968>>>                End  
98968>>>>
98968>>>            End_Procedure   
98969>>>            
98969>>>        End_Object
98970>>>
98970>>>        Object oIndexTableSpace_fm is a cSQLForm
98972>>>            Set Size to 13 114
98973>>>            Set Location to 133 82
98974>>>            Set Label to "Index Table Space"
98975>>>            Set piItem to 14
98976>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
98977>>>            Set Prompt_Button_Mode to PB_PromptOn
98978>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
98979>>>            Set peAnchors to anTopLeftRight
98980>>>
98980>>>            Procedure Prompt
98983>>>                String[] sTheData
98984>>>                Handle ho
98984>>>                tSQLConnection SQLConnection
98984>>>                tSQLConnection SQLConnection
98984>>>
98984>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
98985>>>                Get ReadCurrentSQLSettings to SQLConnection
98986>>>
98986>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
98987>>>
98987>>>                Get Prompt_Object to ho
98988>>>                Set psTheData     of ho to sTheData
98989>>>                Set Label of oShowInfo_tb to ""
98990>>>
98990>>>                Forward Send Prompt
98992>>>            End_Procedure
98993>>>
98993>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98996>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
98997>>>            End_Procedure
98998>>>
98998>>>        End_Object
98999>>>
98999>>>        Object oLoginInfo_tb is a TextBox
99001>>>            Set Auto_Size_State to False
99002>>>            Set Size to 9 78
99003>>>            Set Location to 135 210
99004>>>            Set TextColor to clGreen
99005>>>            Set peAnchors to anTopRight
99006>>>            Set Justification_Mode to JMode_Left
99007>>>        End_Object
99008>>>
99008>>>        Object oBaseTableSpace_fm is a cSQLForm
99010>>>            Set Size to 13 114
99011>>>            Set Location to 148 82
99012>>>            Set Label to "Table Space"
99013>>>            Set piItem to 12
99014>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
99015>>>            Set Prompt_Button_Mode to PB_PromptOn
99016>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
99017>>>            Set peAnchors to anTopLeftRight
99018>>>
99018>>>            Procedure Prompt
99021>>>                String[] sTheData
99022>>>                Handle ho
99022>>>                tSQLConnection SQLConnection
99022>>>                tSQLConnection SQLConnection
99022>>>
99022>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
99023>>>                Get ReadCurrentSQLSettings to SQLConnection
99024>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99025>>>
99025>>>                Get Prompt_Object to ho
99026>>>                Set psTheData  of ho to sTheData
99027>>>                Set Label of oShowInfo_tb to ""
99028>>>
99028>>>                Forward Send Prompt
99030>>>            End_Procedure
99031>>>
99031>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99034>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
99035>>>            End_Procedure
99036>>>
99036>>>        End_Object
99037>>>
99037>>>        Object oLongTableSpace_fm is a cSQLForm
99039>>>            Set Size to 13 114
99040>>>            Set Location to 163 82
99041>>>            Set Label to "Long Table Space"
99042>>>            Set piItem to 13
99043>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
99044>>>            Set Prompt_Button_Mode to PB_PromptOn
99045>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
99046>>>            Set peAnchors to anTopLeftRight
99047>>>
99047>>>            Procedure Prompt
99050>>>                String[] sTheData
99051>>>                Handle ho
99051>>>                tSQLConnection SQLConnection
99051>>>                tSQLConnection SQLConnection
99051>>>
99051>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
99052>>>                Get ReadCurrentSQLSettings to SQLConnection
99053>>>
99053>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99054>>>
99054>>>                Get Prompt_Object to ho
99055>>>                Set psTheData     of ho to sTheData
99056>>>                Set Label of oShowInfo_tb to ""
99057>>>
99057>>>                Forward Send Prompt
99059>>>            End_Procedure
99060>>>
99060>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99063>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
99064>>>            End_Procedure
99065>>>
99065>>>        End_Object
99066>>>
99066>>>        Object oSchema_fm is a cSQLForm
99068>>>            Set Size to 13 78
99069>>>            Set Location to 163 210
99070>>>            Set Label to "Schema"
99071>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
99072>>>            Set piItem to 11
99073>>>            Set Enabled_State to False
99074>>>
99074>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
99076>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
99078>>>
99078>>>            Set peAnchors to anTopRight
99079>>>            Set Label_Justification_Mode to JMode_Top
99080>>>            Set Label_Col_Offset to 0
99081>>>
99081>>>            Procedure Prompt
99084>>>                String[] sTheData
99085>>>                Handle ho
99085>>>                tSQLConnection SQLConnection
99085>>>                tSQLConnection SQLConnection
99085>>>
99085>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
99086>>>                Get ReadCurrentSQLSettings to SQLConnection
99087>>>
99087>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99088>>>
99088>>>                Get Prompt_Object to ho
99089>>>                Set psTheData     of ho to sTheData
99090>>>                Set Label of oShowInfo_tb to ""
99091>>>
99091>>>                Forward Send Prompt
99093>>>            End_Procedure
99094>>>
99094>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99097>>>                String sValue
99097>>>
99097>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
99098>>>                If (iDbType = EN_dbTypeMSSQL) Begin
99100>>>                    Set Label to CS_DF_File_Owner
99101>>>                    Set Prompt_Button_Mode to PB_PromptOff
99102>>>                    Set Prompt_Object to 0
99103>>>                    Set psToolTip to (psOwnerTooltip(Self))
99104>>>                    Get Value to sValue
99105>>>                    If (Trim(sValue) = "") Begin
99107>>>                        Set Value to "dbo"
99108>>>                    End
99108>>>>
99108>>>                End
99108>>>>
99108>>>                Else Begin
99109>>>                    Set Label to CS_DF_File_Schema
99110>>>                    Set Prompt_Button_Mode to PB_PromptOn
99111>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
99112>>>                    Set psToolTip to (psSchemaToolTip(Self))
99113>>>                    If (Trim(sValue) = "dbo") Begin
99115>>>                        Set Value to ""
99116>>>                    End
99116>>>>
99116>>>                End
99116>>>>
99116>>>                If (Enabled_State(Self) = False) Begin
99118>>>                    Set Value to ""
99119>>>                End
99119>>>>
99119>>>            End_Procedure
99120>>>
99120>>>        End_Object
99121>>>
99121>>>        Object oDatabase_fm is a cSQLForm
99123>>>            Set Size to 13 114
99124>>>            Set Location to 178 82
99125>>>            Set Label to "Database"
99126>>>            Set peAnchors to anTopLeftRight
99127>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
99128>>>            Set piItem to 6
99129>>>            Set Prompt_Button_Mode to PB_PromptOn
99130>>>
99130>>>            Procedure Prompt
99133>>>                String[] sTheData
99134>>>                Handle ho
99134>>>                tSQLConnection SQLConnection
99134>>>                tSQLConnection SQLConnection
99134>>>
99134>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
99135>>>                Get ReadCurrentSQLSettings to SQLConnection
99136>>>
99136>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
99137>>>
99137>>>                Get Prompt_Object to ho
99138>>>                Set psTheData     of ho to sTheData
99139>>>                Set Label of oShowInfo_tb to ""
99140>>>
99140>>>                Forward Send Prompt
99142>>>            End_Procedure
99143>>>
99143>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99146>>>                Boolean bAdd
99146>>>                String sValue
99146>>>
99146>>>                If (sDriverID <> "") Begin
99148>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
99149>>>                    If (Enabled_State(Self) = True) Begin
99151>>>                        Move (piCurrentRow(Self) = -1) to bAdd
99152>>>                        Get Value to sValue
99153>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
99155>>>                            Set Value to "master"
99156>>>                        End
99156>>>>
99156>>>                        Else Begin
99157>>>                            Set Prompt_Button_Mode to PB_PromptOn
99158>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
99159>>>                            If (Value(Self) = "master") Begin
99161>>>                                Set Value to ""
99162>>>                            End
99162>>>>
99162>>>                        End
99162>>>>
99162>>>                    End
99162>>>>
99162>>>                    If (Enabled_State(Self) = False) Begin
99164>>>                        Set Value to ""
99165>>>                    End
99165>>>>
99165>>>                End
99165>>>>
99165>>>            End_Procedure
99166>>>
99166>>>        End_Object
99167>>>
99167>>>        Object oCreateDatabase_btn is a cRDCButton
99169>>>            Set Size to 13 78
99170>>>            Set Location to 178 210
99171>>>            Set Label to "Create Database..."
99172>>>            Set psImage to "ActionCreateDatabase1.ico"
99173>>>            Set pbAutoEnable to True
99174>>>            Set peAnchors to anTopRight
99175>>>        
99175>>>            Procedure OnClick                                                              
99178>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
99178>>>                
99178>>>                Get LoginString (&sError) to sConnectionString
99179>>>                If (sError <> "") Begin
99181>>>                    Send Info_Box sError
99182>>>                    Procedure_Return
99183>>>                End                         
99183>>>>
99183>>>                
99183>>>                Get Value of oDriverID_cf to sDriverID
99184>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
99185>>>                If (sDatabaseName <> "") Begin
99187>>>                    Set Value of oDatabase_fm to sDatabaseName
99188>>>                End
99188>>>>
99188>>>            End_Procedure                
99189>>>            
99189>>>            Function IsEnabled Returns Boolean
99192>>>                Integer iDbType    
99192>>>                Boolean bReadOnly
99192>>>                Get SelectedDbType of oDbType_cf to iDbType
99193>>>                Get pbReadOnly to bReadOnly
99194>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
99195>>>            End_Function
99196>>>        
99196>>>        End_Object
99197>>>
99197>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
99200>>>            String sDbType
99200>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
99201>>>            Set Label to (sDbType * "Connection Details")
99202>>>        End_Procedure
99203>>>
99203>>>    End_Object
99204>>>
99204>>>    Object oOK_Btn is a cRDCButton
99206>>>        Set Label    to C_$OK
99207>>>        Set Location to 287 208 //281 208
99208>>>        Set peAnchors to anBottomRight
99209>>>
99209>>>        Procedure OnClick
99212>>>            String sLoginText
99212>>>            String[] sConnectionData
99213>>>            tSQLConnection SQLIniFileConnection
99213>>>            tSQLConnection SQLIniFileConnection
99213>>>            Boolean bNew bOK bShouldSave
99213>>>            Integer iRetval
99213>>>
99213>>>            Delegate Get Should_Save to bShouldSave
99215>>>            If (bShouldSave = False) Begin
99217>>>                Set pbChanged to False
99218>>>                Send Close_Panel
99219>>>                Procedure_Return
99220>>>            End
99220>>>>
99220>>>
99220>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
99222>>>
99222>>>            Get pbNew to bNew
99223>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
99224>>>            Case Begin
99224>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
99226>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
99228>>>                        Move "" to SQLIniFileConnection.sDatabase
99229>>>                    End
99229>>>>
99229>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
99231>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99233>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
99234>>>                        End
99234>>>>
99234>>>                        Else Begin
99235>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
99236>>>                        End
99236>>>>
99236>>>                    End
99236>>>>
99236>>>                    Else Begin
99237>>>                        // It should probably be allowed to use an UID but no password...
99237>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99239>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99240>>>                        End
99240>>>>
99240>>>                        Else Begin
99241>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99242>>>                        End
99242>>>>
99242>>>                    End
99242>>>>
99242>>>                    Case Break
99243>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID)
99246>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
99248>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99250>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
99251>>>                        End
99251>>>>
99251>>>                        Else Begin
99252>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
99253>>>                        End
99253>>>>
99253>>>                    End
99253>>>>
99253>>>                    Else Begin
99254>>>                        // It should probably be allowed to use an UID but no password...
99254>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99256>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99257>>>                        End
99257>>>>
99257>>>                        Else Begin
99258>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99259>>>                        End
99259>>>>
99259>>>                    End
99259>>>>
99259>>>                    Case Break
99260>>>            Case End
99260>>>
99260>>>            If (bOK = False) Begin
99262>>>                Send Info_Box "Please fill in all connection data."
99263>>>                Procedure_Return
99264>>>            End
99264>>>>
99264>>>
99264>>>            Move MBR_Yes to iRetval
99265>>>            Get Label of oLoginInfo_tb to sLoginText
99266>>>            If (sLoginText = CS_LoginFailed) Begin
99268>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
99269>>>            End
99269>>>>
99269>>>            Else If (sLoginText = "") Begin
99272>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
99273>>>            End
99273>>>>
99273>>>            If (iRetval <> MBR_Yes) Begin
99275>>>                Procedure_Return
99276>>>            End
99276>>>>
99276>>>
99276>>>            Set pSQLConnectionData to SQLIniFileConnection
99277>>>            Set pbChanged to True
99278>>>            Send Close_Panel
99279>>>        End_Procedure
99280>>>
99280>>>    End_Object
99281>>>
99281>>>    Object oCancel_Btn is a cRDCButton
99283>>>        Set Label    to C_$Cancel
99284>>>        Set Location to 287 264 //281 264
99285>>>        Set peAnchors to anBottomRight
99286>>>
99286>>>        Procedure OnClick
99289>>>            Set pbChanged to False
99290>>>            Send Close_Panel
99291>>>        End_Procedure
99292>>>
99292>>>    End_Object
99293>>>
99293>>>    Object oHelp_Btn is a cRDCButton
99295>>>        Set Label to C_$Help
99296>>>        Set Location to 287 11 //281 11
99297>>>        Set peAnchors to anBottomLeft
99298>>>        Set psImage to "ActionHelp1.ico"
99299>>>
99299>>>        Procedure OnClick
99302>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
99303>>>        End_Procedure
99304>>>    End_Object
99305>>>
99305>>>    Object oConnectionType_grp is a cRDCHeaderGroup
99307>>>        Set Size to 60 303
99308>>>        Set Location to 8 11 //2 11
99309>>>        Set psImage to "SQLSettings1.ico"
99310>>>        Set psLabel to "Database Type Settings"
99311>>>
99311>>>        Object oDbType_cf is a cSQLComboForm
99313>>>            Set Size to 13 115
99314>>>            Set Location to 22 82
99315>>>            Set Label to "Database Type"
99316>>>            Set Entry_State to False
99317>>>            Set Combo_Sort_State to False
99318>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
99319>>>            Set piItem to 3
99320>>>            
99320>>>            Procedure Combo_Fill_List
99323>>>                Send Combo_Add_Item CS_dbTypeMSSQL
99324>>>                Send Combo_Add_Item CS_dbTypeMySQL
99325>>>                Send Combo_Add_Item CS_dbTypeOracle
99326>>>                Send Combo_Add_Item CS_dbTypeDB2
99327>>>                Send Combo_Add_Item CS_dbTypePostgre
99328>>>            End_Procedure
99329>>>
99329>>>            Procedure OnChange
99332>>>                Integer iDbType
99332>>>                String sDriverID
99332>>>    
99332>>>                Get SelectedDbType to iDbType
99333>>>                Send Refill_Comboform of oDriverID_cf iDbType
99334>>>                Get Value of oDriverID_cf to sDriverID
99335>>>                If (sDriverID = "") Begin
99337>>>                    Move MSSQLDRV_ID to sDriverID
99338>>>                End
99338>>>>
99338>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99339>>>            End_Procedure
99340>>>    
99340>>>            Function SelectedDbType Returns Integer
99343>>>                Integer iRetval
99343>>>                String sDbType
99343>>>    
99343>>>                Get Value to sDbType
99344>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
99345>>>    
99345>>>                Function_Return iRetval
99346>>>            End_Function
99347>>>
99347>>>        End_Object
99348>>>
99348>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
99348>>>//        Object oStartSQLManager_btn is a cRDCButton
99348>>>//            Set Size to 13 78
99348>>>//            Set Location to 22 210
99348>>>//            Set Label to "SQL Manager"
99348>>>//            Set pbAutoEnable to True  
99348>>>//            Set psImage to "SSMS1.ico" 
99348>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
99348>>>//            Set peAnchors to anTopRight
99348>>>//        
99348>>>//            Procedure OnClick
99348>>>//                Runprogram Shell Background "Ssms.exe"    
99348>>>//            End_Procedure  
99348>>>//            
99348>>>//            Function IsEnabled Returns Boolean
99348>>>//                String sDbType
99348>>>//                Get Value of oDbType_cf to sDbType
99348>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
99348>>>//            End_Function
99348>>>//        
99348>>>//        End_Object
99348>>>
99348>>>        Object oDriverID_cf is a cSQLComboForm
99350>>>            Set Size to 13 115
99351>>>            Set Location to 37 82
99352>>>            Set Label to "Driver ID"
99353>>>            Set Entry_State to False
99354>>>            Set Combo_Sort_State to False
99355>>>            Set psToolTip to "Depending on the database type selected the comboform list will vary."
99356>>>            Set piItem to 4
99357>>>
99357>>>            Procedure Refill_Comboform Integer iDbType
99360>>>                String sValue
99360>>>
99360>>>                Send Combo_Delete_Data
99361>>>                Send Combo_Add_Item MSSQLDRV_ID
99362>>>                Send Combo_Add_Item DB2_DRV_ID
99363>>>                Send Combo_Add_Item ODBC_DRV_ID
99364>>>                Send Combo_Add_Item DATAFLEX_ID
99365>>>
99365>>>                Case Begin
99365>>>                    Case (iDbType = EN_dbTypeMSSQL)
99367>>>                        Move MSSQLDRV_ID to sValue
99368>>>                        Case Break
99369>>>                    Case (iDbType = EN_dbTypeMySQL)
99372>>>                        Move ODBC_DRV_ID to sValue
99373>>>                        Case Break
99374>>>                    Case (iDbType = EN_dbTypeOracle)
99377>>>                        Move ODBC_DRV_ID to sValue
99378>>>                        Case Break
99379>>>                    Case (iDbType = EN_dbTypeDB2)
99382>>>                        Move DB2_DRV_ID to sValue
99383>>>                        Case Break
99384>>>                    Case (iDbType = EN_dbTypePostgre)
99387>>>                        Move ODBC_DRV_ID to sValue
99388>>>                        Case Break
99389>>>                    Case Else
99389>>>                        Move DATAFLEX_ID to sValue
99390>>>                Case End
99390>>>                Set Value to sValue
99391>>>            End_Procedure
99392>>>
99392>>>            Procedure OnChange
99395>>>                String sDriverID
99395>>>                Integer iDbType
99395>>>
99395>>>                Get Value to sDriverID
99396>>>                If (sDriverID = "") Begin
99398>>>//                    Move MSSQLDRV_ID to sDriverID 
99398>>>                    Procedure_Return
99399>>>                End
99399>>>>
99399>>>                Get SelectedDbType of oDbType_cf to iDbType
99400>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99402>>>            End_Procedure
99403>>>
99403>>>        End_Object
99404>>>
99404>>>        Object oShowDriverSettings_btn is a cRDCButton
99406>>>            Set Size to 13 78
99407>>>            Set Location to 37 210
99408>>>            Set Label to "Driver Settings"
99409>>>            Set Status_Help to "Shows settings for the selected driver."
99410>>>            Set psImage to "DriverSettings1.ico"
99411>>>            Set peAnchors to anTopRight
99412>>>
99412>>>            Procedure OnClick
99415>>>                String sDriver sPath 
99415>>>                
99415>>>                Get Value of oDriverID_cf to sDriver
99416>>>                Send PopupDriverSettings sDriver 
99417>>>            End_Procedure
99418>>>    
99418>>>        End_Object
99419>>>
99419>>>    End_Object
99420>>>
99420>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
99423>>>        tSQLConnection SQLConnection
99423>>>        tSQLConnection SQLConnection
99423>>>
99423>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
99424>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
99425>>>
99425>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
99426>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
99427>>>        Get Value of oServer_fm          to SQLConnection.sServer
99428>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
99429>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
99430>>>        Move False to Err
99431>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
99432>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
99433>>>        Move Err to SQLConnection.bError
99434>>>        
99434>>>        Function_Return SQLConnection
99435>>>    End_Function
99436>>>
99436>>>    Function LoginString String ByRef sError Returns String
99439>>>        String sDriverID sServer sDatabase
99439>>>        tSQLConnection SQLConnection
99439>>>        tSQLConnection SQLConnection
99439>>>        
99439>>>        Get Value of oDriverID_cf to sDriverID
99440>>>        If (sDriverID = "") Begin
99442>>>            Move "Please select a driver first, then try again." to sError
99443>>>            Function_Return ""
99444>>>        End
99444>>>>
99444>>>
99444>>>        Get Value of oServer_fm   to sServer
99445>>>        If (sServer = "") Begin
99447>>>            Move "Please select a server first, then try again." to sError
99448>>>            Function_Return ""
99449>>>        End
99449>>>>
99449>>>
99449>>>        Get Value of oDatabase_fm to sDatabase
99450>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
99452>>>            Move "master" to sDatabase
99453>>>        End
99453>>>>
99453>>>
99453>>>        Get ReadCurrentSQLSettings to SQLConnection
99454>>>        If (SQLConnection.bError = True) Begin
99456>>>            Move "Login Error" to sError
99457>>>        End
99457>>>>
99457>>>
99457>>>        Function_Return SQLConnection.sConnectionString
99458>>>    End_Function
99459>>>
99459>>>    // Returns True if anything has changed.
99459>>>    Function Should_Save Returns Boolean
99462>>>        String[] sConnectionData sConnectionData2
99464>>>        tSQLConnection SQLConnectionData
99464>>>        tSQLConnection SQLConnectionData
99464>>>        Boolean bState
99464>>>
99464>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
99466>>>        Get pSQLConnectionData to SQLConnectionData
99467>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
99468>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
99468>>>        // to be able to compare properly.
99468>>>        Move "" to sConnectionData2[7]
99469>>>
99469>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
99470>>>        Function_Return (bState = False)
99471>>>    End_Function
99472>>>
99472>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
99475>>>        Integer iCount iSize iItems iCurrentRow
99475>>>        String sValue sConnectionID
99475>>>        Boolean bExists
99475>>>        tDataSourceRow[] TheData
99475>>>        tDataSourceRow[] TheData
99476>>>        tDataSourceRow TheRow
99476>>>        tDataSourceRow TheRow
99476>>>
99476>>>        Move 0 to iItems
99477>>>        Get piCurrentRow to iCurrentRow
99478>>>        Move SQLConnection.sConnectionID to sConnectionID
99479>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
99480>>>        Get pTheData to TheData
99481>>>        Move (SizeOfArray(TheData)) to iSize
99482>>>        If (iCurrentRow <> -1) Begin
99484>>>            // This is the sConnectionID:
99484>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
99485>>>        End
99485>>>>
99485>>>        Else Begin
99486>>>            Move TheRow to TheData[iSize]
99487>>>        End
99487>>>>
99487>>>        Move (SizeOfArray(TheData)) to iSize
99488>>>        Decrement iSize
99489>>>        For iCount from 0 to iSize
99495>>>>
99495>>>            Move TheData[iCount].sValue[2] to sValue
99496>>>            Move (sValue = sConnectionID) to bExists
99497>>>            If (bExists) Begin
99499>>>                Increment iItems
99500>>>            End
99500>>>>
99500>>>        Loop
99501>>>>
99501>>>
99501>>>        Function_Return (iItems > 1)
99502>>>    End_Function
99503>>>
99503>>>    // Transfers data between a tSQLConnection struct and a grid data row.
99503>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
99506>>>        tDataSourceRow TheRow
99506>>>        tDataSourceRow TheRow
99506>>>        Integer iDbType
99506>>>        String sValue
99506>>>
99506>>>        Move 0                                  to TheRow.sValue[0]
99507>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
99508>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
99509>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
99510>>>
99510>>>        // We only show three asterisks ("***") instead of the password in the grid.
99510>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
99511>>>        Move sValue                             to TheRow.sValue[4]
99512>>>
99512>>>        Move SQLConnection.iDbType to iDbType
99513>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
99514>>>        Move sValue                             to TheRow.sValue[5]
99515>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
99516>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
99517>>>
99517>>>        // Hidden columns (to make Should_Save function work)
99517>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
99518>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
99519>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
99520>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
99521>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
99522>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
99523>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
99524>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
99525>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
99526>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
99526>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
99526>>>
99526>>>        Function_Return TheRow
99527>>>    End_Function
99528>>>
99528>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
99531>>>        String[] sConnectionData
99532>>>        Integer iRetval
99532>>>
99532>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
99533>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
99534>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
99535>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
99536>>>        Move SQLConnection.sServer           to sConnectionData[5]
99537>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
99538>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
99539>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
99540>>>        Move SQLConnection.sUserID           to sConnectionData[9]
99541>>>
99541>>>        If (SQLConnection.sPassword <> "") Begin
99543>>>            Move MBR_Yes to iRetval
99544>>>            If (pbDFConnId(Self) = True) Begin
99546>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
99547>>>                If (iRetval = MBR_Yes) Begin
99549>>>                    Set psUncryptedPw to SQLConnection.sPassword
99550>>>                    Move "" to SQLConnection.sPassword 
99551>>>//                    Set Enabled_State of oCheckLogin_btn to False
99551>>>                End
99551>>>>
99551>>>                Else Begin
99552>>>                    Send Stop_UI
99553>>>                End
99553>>>>
99553>>>            End
99553>>>>
99553>>>            Else Begin
99554>>>                Move SQLConnection.sPassword to sConnectionData[10]
99555>>>            End
99555>>>>
99555>>>        End
99555>>>>
99555>>>
99555>>>        Move SQLConnection.sSchema           to sConnectionData[11]
99556>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
99557>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
99558>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
99559>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
99560>>>
99560>>>        Function_Return sConnectionData
99561>>>    End_Function
99562>>>
99562>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
99565>>>        tSQLConnection SQLConnection
99565>>>        tSQLConnection SQLConnection
99565>>>
99565>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
99566>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
99567>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
99568>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
99569>>>        Move sConnectionData[5]  to SQLConnection.sServer
99570>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
99571>>>
99571>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
99572>>>        Move sConnectionData[9]  to SQLConnection.sUserID
99573>>>
99573>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
99575>>>            Move sConnectionData[10] to SQLConnection.sPassword
99576>>>        End
99576>>>>
99576>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
99576>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
99576>>>        If (pbDFConnId(Self) = True) Begin
99578>>>            Get psUncryptedPw to SQLConnection.sPassword
99579>>>        End
99579>>>>
99579>>>
99579>>>        Move sConnectionData[11] to SQLConnection.sSchema
99580>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
99581>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
99582>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
99583>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
99584>>>
99584>>>        // Connection string:
99584>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
99585>>>
99585>>>        Function_Return SQLConnection
99586>>>    End_Function
99587>>>
99587>>>    Procedure Popup
99590>>>        tSQLConnection SQLIniFileConnection
99590>>>        tSQLConnection SQLIniFileConnection
99590>>>        String[] sConnectionData
99591>>>        String sDriverID
99591>>>        Integer iDbType
99591>>>        Boolean bAdd
99591>>>
99591>>>        Move (piCurrentRow(Self) = -1) to bAdd
99592>>>        Get pSQLConnectionData to SQLIniFileConnection             
99593>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
99593>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
99594>>>        Set Value of oDriverID_cf to ""
99595>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
99597>>>            Move True to SQLIniFileConnection.bEnabled
99598>>>        End
99598>>>>
99598>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
99599>>>
99599>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
99600>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
99601>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
99603>>>
99603>>>        // We need this message to "auto-default" certain fields.
99603>>>        If (bAdd = True) Begin
99605>>>            Get SelectedDbType of oDbType_cf to iDbType
99606>>>            Get Value of oDriverID_cf to sDriverID
99607>>>            If (sDriverID = "") Begin
99609>>>                Move MSSQLDRV_ID to sDriverID
99610>>>            End
99610>>>>
99610>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99612>>>        End
99612>>>>
99612>>>
99612>>>        Set Password_State of oPassword_fm to True
99613>>>        Set Value of oLoginInfo_tb to ""
99614>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
99615>>>
99615>>>        Forward Send Popup
99617>>>    End_Procedure
99618>>>
99618>>>    Procedure Page Integer iPageObject
99621>>>        Boolean bNew bReadOnly
99621>>>        String sText
99621>>>        Handle hWnd
99621>>>
99621>>>        Send Cursor_Ready of Cursor_Control
99622>>>        Forward Send Page iPageObject
99624>>>
99624>>>        Set Icon to "SQLConnections1.ico"
99625>>>
99625>>>        Get pbNew to bNew
99626>>>        If (bNew = True) Begin
99628>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
99629>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
99630>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
99631>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
99632>>>            Send Info_Box sText
99633>>>        End
99633>>>>
99633>>>
99633>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
99635>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
99636>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
99637>>>        End
99637>>>>
99637>>>
99637>>>        Get pbReadOnly to bReadOnly
99638>>>        If (bReadOnly = True) Begin
99640>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
99642>>>            Set Enabled_State of oConnectionType_grp to True
99643>>>            Set Enabled_State of oSettings_grp       to True
99644>>>            Set Enabled_State of oPassword_fm        to True
99645>>>            Set Enabled_State of oViewPassword_btn   to True
99646>>>            Set Enabled_State of oCheckLogin_btn     to True
99647>>>            Set Enabled_State of oCancel_Btn         to True
99648>>>            Set Enabled_State of oHelp_Btn           to True
99649>>>            Set Enabled_State of oShowDriverSettings_btn to True
99650>>>            Set Enabled_State of oCreateDatabase_btn to False
99651>>>            Send Activate of oCancel_Btn
99652>>>        End
99652>>>>
99652>>>    End_Procedure
99653>>>
99653>>>    Function IniFileName Returns String
99656>>>        String sRetval
99656>>>        Function_Return sRetval
99657>>>    End_Function
99658>>>
99658>>>    // Put a status bar at the bottom of the panel, which makes
99658>>>    // status_help work and puts a gripper in the lower right corner.
99658>>>    Procedure End_Construct_Object
99661>>>        Integer iStyle iSize iOffset
99661>>>
99661>>>        Forward Send End_Construct_Object
99663>>>
99663>>>        Get Border_Style to iStyle
99664>>>        Move 8 to iOffset
99665>>>        If (iStyle = Border_Thick) Begin
99667>>>            Object oDialogCommandbar is a cCJCommandBarSystem
99669>>>                Object oStatusBar is a cCJStatusBar
99671>>>                    Set phoDialogCommandbar to Self
99672>>>                    Object oStatusIdle is a cCJStatusBarPane
99674>>>                        Set piId to sbpIDIdlePane
99675>>>                        Set pbStyleStretch to True
99676>>>                    End_Object
99677>>>                End_Object
99678>>>            End_Object
99679>>>
99679>>>            Get Size to iSize
99680>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
99681>>>        End
99681>>>>
99681>>>    End_Procedure
99682>>>
99682>>>    Procedure ShowProgramHelp
99685>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
99686>>>    End_Procedure
99687>>>
99687>>>    On_Key Key_F1         Send ShowProgramHelp
99688>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
99689>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
99690>>>End_Object
99691>>>
99691>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
99691>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
99694>>>    Handle ho
99694>>>    String sPath sSQLConnectionsFileName
99694>>>    Boolean bExists
99694>>>    
99694>>>    Send Cursor_Wait of Cursor_Control
99695>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
99696>>>    Set pbReadOnly              of ho to False
99697>>>    Set pbNew                   of ho to bNew
99698>>>    Set piCurrentRow            of ho to iCurrentRow
99699>>>    Set pbDFConnId              of ho to bDFConnId
99700>>>    Set pSQLConnectionData      of ho to SQLConnectionData
99701>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
99702>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
99703>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
99704>>>    If (bExists = True) Begin
99706>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
99707>>>    End
99707>>>>
99707>>>    
99707>>>    Set pTheData                of ho to TheData
99708>>>
99708>>>    Send Popup                  of ho
99709>>>
99709>>>    Get pSQLConnectionData      of ho to SQLConnectionData
99710>>>    Get pbChanged               of ho to bChanged
99711>>>End_Procedure
99712>>>
99712>>>// Read-only access message
99712>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
99715>>>    Handle ho
99715>>>    String sPath sSQLConnectionsFileName
99715>>>
99715>>>    Send Cursor_Wait of Cursor_Control
99716>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
99717>>>    Set pbReadOnly              of ho to True
99718>>>
99718>>>    Set pSQLConnectionData      of ho to SQLConnectionData
99719>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
99720>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
99721>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
99722>>>
99722>>>    Send Popup of ho
99723>>>End_Procedure
99724>>>
99724>        Use AddToStudio.dg     
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
99724>>>Use Windows.pkg
99724>>>Use Dfspnfrm.pkg
99724>>>Use cRegistry.pkg
99724>>>Use vWin32fh.pkg
99724>>>
99724>>>Enum_List
99724>>>    Define cx_RegKeyAlreadyExist
99724>>>    Define cx_RegKeyCreated
99724>>>    Define cx_RegkeyFailed
99724>>>    Define cx_RegKeyVDFKeyDoesNotExist
99724>>>    Define CX_InstalledOkVdfUnder16
99724>>>End_Enum_List
99724>>>
99724>>>// Note: The "Visual" part will automatically be removed if
99724>>>// the current DataFlex version is above 17.
99724>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
99724>>>Define CS_StudioTools       for "\Studio\Tools"
99724>>>Define CS_RegApplication    for "<application>"
99724>>>Define CS_RegWorkspace      for "<workspace>"
99724>>>Define CS_CommandLine       for "CommandLine"
99724>>>Define CS_Name              for "Name"
99724>>>Define CS_Separator         for "Separator"
99724>>>Define CS_Command           for "Command"
99724>>>
99724>>>Object oAddToStudio_dg is a ModalPanel
99726>>>    Set Size to 79 330
99727>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
99728>>>    Set piMinSize to 79 211
99729>>>    Set Location to 5 4
99730>>>    Set Locate_Mode to Center_On_Parent
99731>>>
99731>>>    Property String psTag CS_RegApplication
99733>>>
99733>>>    Object oStudioIntegration_grp is a Group
99735>>>        Set Size to 45 299
99736>>>        Set Location to 8 15
99737>>>        Set Label to "DataFlex Studio Integration"
99738>>>
99738>>>        Object oStudioMajorVersion_sf is a SpinForm
99740>>>            Set Size to 12 27
99741>>>            Set Location to 18 168
99742>>>            Set Maximum_Position to 30
99743>>>            Set Minimum_Position to 14
99744>>>            Set Label_Col_Offset to 2
99745>>>            Set Label_Justification_Mode to JMode_Right
99746>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
99747>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
99748>>>            Set Value to FMAC_VERSION
99749>>>            Set peAnchors to anNone
99750>>>        End_Object
99751>>>
99751>>>        Object oStudioMinorVersion_sf is a SpinForm
99753>>>            Set Size to 12 27
99754>>>            Set Location to 18 254
99755>>>            Set Label_Col_Offset to 2
99756>>>            Set Label to "Minor Version"
99757>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
99758>>>            Set Maximum_Position to 9
99759>>>            Set Minimum_Position to 0
99760>>>            Set Value to FMAC_REVISION
99761>>>            Set Label_Justification_Mode to JMode_Right
99762>>>            Set peAnchors to anNone
99763>>>        End_Object
99764>>>
99764>>>    End_Object
99765>>>
99765>>>    Object oOK_btn is a Button
99767>>>        Set Location to 59 207
99768>>>        Set Label to "Add Now"
99769>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
99770>>>        Set peAnchors to anTopRight
99771>>>
99771>>>        Procedure OnClick
99774>>>            Integer iRetval iMajorVersion iMinorVersion
99774>>>            String sText sStudioVersion
99774>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
99775>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
99776>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
99777>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
99778>>>            Case Begin
99778>>>                Case (iRetval = cx_RegKeyAlreadyExist)
99780>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
99781>>>                    Break
99782>>>                Case (iRetval = cx_RegKeyCreated)
99785>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
99786>>>                    Break
99787>>>                Case (iRetval = cx_RegkeyFailed)
99790>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
99791>>>                    Break
99792>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
99795>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
99796>>>                    Break
99797>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
99800>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
99801>>>                    Break
99802>>>            Case End
99802>>>
99802>>>            Send Info_Box sText
99803>>>        End_Procedure
99804>>>    End_Object
99805>>>
99805>>>    Object oCancel_Btn is a Button
99807>>>        Set Label to C_$Close
99808>>>        Set Location to 59 264
99809>>>        Set peAnchors to anBottomRight
99810>>>
99810>>>        Procedure OnClick
99813>>>            Send Close_Panel
99814>>>        End_Procedure
99815>>>
99815>>>    End_Object
99816>>>
99816>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
99819>>>        Boolean bOk bExists bOpen
99819>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
99819>>>        Handle hoReg hoArray
99819>>>        Integer i iItems iCreated iRetval
99819>>>
99819>>>        Move False to bOk
99820>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
99821>>>        If (sStudioVersion > "17.1") Begin
99823>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
99824>>>        End
99824>>>>
99824>>>
99824>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
99825>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
99826>>>        Get vFolderFormat sProgramPath to sProgramPath
99827>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
99828>>>        Get Module_Name to sProgram
99829>>>        Get Create (RefClass(cRegistry)) to hoReg
99830>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
99831>>>
99831>>>        // First check if the VDF version is installed
99831>>>        Get KeyExists of hoReg sStudioPath to bExists
99832>>>        If (bExists = False) Begin
99834>>>            Send Destroy of hoReg
99835>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
99836>>>        End
99836>>>>
99836>>>
99836>>>        // Then check if any tools have been installed in the Tools Menu.
99836>>>        // If no tools created yet, create the Tools registry key.
99836>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
99837>>>        Get KeyExists of hoReg sStudioPath to bExists
99838>>>        If (bExists = False) Begin
99840>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
99841>>>            Get CreateKey of hoReg sStudioPath to iCreated
99842>>>            If (iCreated <> 0) Begin
99844>>>                Move cx_RegkeyFailed to iRetval
99845>>>            End
99845>>>>
99845>>>            Else Begin
99846>>>                Move True to bExists
99847>>>            End
99847>>>>
99847>>>        End
99847>>>>
99847>>>
99847>>>        If (bExists = True) Begin
99849>>>            Get OpenKey of hoReg sStudioPath to bOk
99850>>>            If (bOk = True) Begin
99852>>>                Get Create (RefClass(Array)) to hoArray
99853>>>                Get GetSubkeys of hoReg hoArray to iItems
99854>>>                Decrement iItems
99855>>>                Move False to bExists
99856>>>                Set pfAccessRights of hoReg to KEY_READ
99857>>>                // Check if the key already exists:
99857>>>                For i from 0 to iItems
99863>>>>
99863>>>                    Get Value of hoArray i to sKey
99864>>>                    Move (sStudioPath + "\" + sKey) to sKey
99865>>>                    Get OpenKey of hoReg sKey to bOpen
99866>>>                    If (bOpen = True) Begin
99868>>>                        Get ReadString of hoReg CS_Name to sValue
99869>>>                        If (sValue = sProduct) Begin
99871>>>                            Move True to bExists
99872>>>                        End
99872>>>>
99872>>>                    End
99872>>>>
99872>>>                Loop
99873>>>>
99873>>>                Send Destroy of hoArray
99874>>>                If (bExists = False) Begin
99876>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
99877>>>                    // We need to create the next key number:
99877>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
99877>>>                    Increment iItems
99878>>>                    Increment iItems
99879>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
99880>>>                    If (iCreated = 0) Begin
99882>>>                        Send WriteString of hoReg CS_Name sProduct
99883>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
99883>>>                        If (sStudioVersion >= "16.0") Begin
99885>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
99886>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
99887>>>                        End
99887>>>>
99887>>>                        Else Begin
99888>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
99889>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
99890>>>                        End
99890>>>>
99890>>>                        Send WriteDword  of hoReg CS_Separator 1
99891>>>                        Move cx_RegKeyCreated to iRetval
99892>>>                    End
99892>>>>
99892>>>                    Else Begin
99893>>>                        Move cx_RegkeyFailed to iRetval
99894>>>                    End
99894>>>>
99894>>>                End
99894>>>>
99894>>>                Else Begin
99895>>>                    Move cx_RegKeyAlreadyExist to iRetval
99896>>>                End
99896>>>>
99896>>>                Send CloseKey of hoReg
99897>>>            End
99897>>>>
99897>>>        End
99897>>>>
99897>>>
99897>>>        Send Destroy of hoReg
99898>>>        Function_Return iRetval
99899>>>    End_Function
99900>>>
99900>>>    Procedure Page Integer iPageObject
99903>>>        Forward Send Page iPageObject
99905>>>        Set Icon to "ActionAddStudio1.ico"
99906>>>    End_Procedure
99907>>>
99907>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99908>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99909>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
99910>>>End_Object
99911>        Use ViewSourceCode.dg
Including file: ViewSourceCode.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ViewSourceCode.dg)
99911>>>Use Windows.pkg
99911>>>Use cRDCButtonDPI.pkg
99911>>>Use cRichEdit.pkg
99911>>>Use seq_chnl.pkg
99911>>>Use vWin32fh.pkg
99911>>>
99911>>>Object oSourceCodeDialog_dg is a ModalPanel
99913>>>    Set Size to 214 395
99914>>>    Set Label to "View Source Code Dialog"
99915>>>    Set piMinSize to 89 211
99916>>>    Set Location to 2 2
99917>>>    Set Border_Style To Border_Thick
99918>>>    Set Locate_Mode to Center_On_Parent
99919>>>
99919>>>    Property String psSourceCode ""
99921>>>    Property Integer piIndent
99923>>>
99923>>>    Object oSourceCode_edt is a cRichEdit
99925>>>        Set Size to 169 373
99926>>>        Set Location to 16 11
99927>>>        Set TextColor to clBlack
99928>>>        Set peAnchors to anAll
99929>>>        Set Label_Row_Offset to 3
99930>>>        Set Label_TextColor to clGreenGreyLight
99931>>>        Set Label_FontItalics to True
99932>>>        Set piFontSize to 200
99933>>>        Set psTypeFace to 'Consolas'
99934>>>
99934>>>        Delegate Set piIndent to (piParagraphIndent(Self))
99936>>>
99936>>>        Procedure DoSaveDocument
99939>>>            String sSourceCode
99939>>>            Boolean bOk bOkToSave bChanged
99939>>>
99939>>>            Move False to bOkToSave
99940>>>            Get pbCanUndo to bChanged
99941>>>            If (bChanged = False) Begin
99943>>>                Procedure_Return
99944>>>            End
99944>>>>
99944>>>
99944>>>            Get psSourceCode to sSourceCode
99945>>>            Send Write sSourceCode
99946>>>            // clear undo buffer on save
99946>>>            // we want undo buffer to only apply to the new document
99946>>>            Send ClearUndoBuffer
99947>>>            Send Info_Box "Changes saved."
99948>>>        End_Procedure
99949>>>
99949>>>        Procedure LoadData
99952>>>            String sSourceCode
99952>>>            Integer iTwips iIndent
99952>>>
99952>>>            Get psSourceCode to sSourceCode
99953>>>            Set Label to sSourceCode
99954>>>            Move 1440 to iTwips
99955>>>            Get piIndent to iIndent
99956>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
99957>>>
99957>>>            Send Read sSourceCode
99958>>>        End_Procedure
99959>>>
99959>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
99960>>>        On_Key kCancel Send Cancel
99961>>>    End_Object
99962>>>
99962>>>    Object oCancel_Btn is a cRDCButtonDPI
99964>>>        Set Label    to "&Close"
99965>>>        Set Location to 193 334
99966>>>        Set peAnchors to anBottomRight
99967>>>
99967>>>        Procedure OnClick
99970>>>            Send Close_Panel
99971>>>        End_Procedure
99972>>>
99972>>>    End_Object
99973>>>
99973>>>
99973>>>    Object oFirstRun_btn is a cRDCButtonDPI
99975>>>        Set Location to 193 220
99976>>>        Set Label to "View &Top"
99977>>>        Set peAnchors to anBottomRight
99978>>>
99978>>>        Procedure OnClick
99981>>>            Send Beginning_of_Data to oSourceCode_edt
99982>>>        End_Procedure
99983>>>
99983>>>    End_Object
99984>>>
99984>>>    Object oLatestRun_btn is a cRDCButtonDPI
99986>>>        Set Location to 193 277
99987>>>        Set Label to "View &Bottom"
99988>>>        Set peAnchors to anBottomRight
99989>>>
99989>>>        Procedure OnClick
99992>>>            Send End_of_Data to oSourceCode_edt
99993>>>        End_Procedure
99994>>>
99994>>>    End_Object
99995>>>
99995>>>    // Automatically load data into the grid when activating.
99995>>>    Procedure Activating
99998>>>        Handle ho
99998>>>        Move (oSourceCode_edt(Self)) to ho
99999>>>        Send LoadData    of ho
100000>>>        Send Activate    of ho
100001>>>    End_Procedure
100002>>>
100002>>>    Procedure Page Integer iPageObject
100005>>>        Forward Send Page iPageObject
100007>>>        Set Icon to "ViewSourceCode1.ico"
100008>>>    End_Procedure
100009>>>
100009>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
100009>>>    Procedure End_Construct_Object
100012>>>        Integer iStyle iSize iOffset
100012>>>
100012>>>        Forward Send End_Construct_Object
100014>>>
100014>>>        Get Border_Style to iStyle
100015>>>        Move 8 to iOffset
100016>>>        If (iStyle = Border_Thick) Begin
100018>>>            Object oDialogCommandbar is a cCJCommandBarSystem
100020>>>                Object oStatusBar is a cCJStatusBar
100022>>>                    Object oStatusIdle is a cCJStatusBarPane
100024>>>                        Set piId to sbpIDIdlePane
100025>>>                        Set pbStyleStretch to True
100026>>>                    End_Object
100027>>>                End_Object
100028>>>            End_Object
100029>>>
100029>>>            Get Size to iSize
100030>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
100031>>>        End
100031>>>>
100031>>>    End_Procedure
100032>>>
100032>>>    On_Key Key_Alt+Key_T  Send KeyAction of oFirstRun_btn
100033>>>    On_Key Key_Ctrl+Key_T Send KeyAction of oFirstRun_btn
100034>>>    On_Key Key_Alt+Key_B  Send KeyAction of oLatestRun_btn
100035>>>    On_Key Key_Ctrl+Key_B Send KeyAction of oLatestRun_btn
100036>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
100037>>>End_Object
100038>>>
100038>>>Procedure ActivateSourceCodeDialog String sSourceCode
100041>>>    Handle ho
100041>>>    Boolean bExists
100041>>>
100041>>>    Get vFilePathExists sSourceCode to bExists
100042>>>    If (bExists = False) Begin
100044>>>        Send Info_Box "The file doesn't exist."
100045>>>        Procedure_Return
100046>>>    End
100046>>>>
100046>>>    Move (oSourceCodeDialog_dg(Self)) to ho
100047>>>    Set psSourceCode of ho to sSourceCode
100048>>>    Send Popup of ho
100049>>>End_Procedure
100050>        Use TableDUFCodeGenerator.vw   
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
100050>>>Use Windows.pkg
100050>>>Use DFClient.pkg
100050>>>Use Cursor.pkg
100050>>>Use Batchdd.pkg
100050>>>Use cCJGrid.pkg
100050>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridColumnRowIndicator.pkg)
100050>>>>>Use cCJGridColumn.pkg
100050>>>>>
100050>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
100051>>>>>    
100051>>>>>    Procedure Construct_Object
100053>>>>>        Forward Send Construct_Object
100055>>>>>        
100055>>>>>        Property Integer piImage 0
100056>>>>>        
100056>>>>>        Set psCaption to ""
100057>>>>>        Set piWidth to 20
100058>>>>>        Set pbResizable to False
100059>>>>>        Set pbEditable to False
100060>>>>>        Set pbFocusable to False
100061>>>>>        Set pbAllowDrag to False
100062>>>>>        Set psToolTip to "Row Indicator"
100063>>>>>    End_Procedure
100064>>>>>    
100064>>>>>    Procedure OnCreateColumn
100066>>>>>        Integer iImage
100066>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
100068>>>>>        Set piImage to iImage
100069>>>>>    End_Procedure
100070>>>>>    
100070>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
100072>>>>>        Integer iImage iFocusedRow
100072>>>>>        Handle hoDataSource
100072>>>>>        
100072>>>>>        Get phoDataSource to hoDataSource
100073>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
100074>>>>>        Move -1 to iImage
100075>>>>>        If (iRow = iFocusedRow) Begin
100077>>>>>            Get piImage to iImage
100078>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
100079>>>>>        End
100079>>>>>>
100079>>>>>    End_Procedure
100080>>>>>    
100080>>>>>End_Class
100081>>>Use cCJGridColumn.pkg
100081>>>Use dfLine.pkg
100081>>>Use cRDCButton.pkg
100081>>>Use cDbUpdateFunctionLibrary.pkg
100081>>>Use DUFStatusPanel.pkg
100081>>>Use seq_chnl.pkg
100081>>>Use vWin32fh.pkg
100081>>>Use cRDCHeaderGroup.pkg
100081>>>Use cRDCSuggestionIniForm.pkg
100081>>>Use cSQLCheckBox.pkg
100081>>>Use WriteTestProgram.pkg
Including file: WriteTestProgram.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\WriteTestProgram.pkg)
100081>>>>>Use vWin32fh.pkg
100081>>>>>
100081>>>>>Define CS_DUFTestProgram for "DUFInternalUpdateProgram.src"
100081>>>>>
100081>>>>>Function WriteTestProgram String sSourcePackageName String sAppSrcPath Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField Returns Boolean
100084>>>>>    Integer iCh                                                               
100084>>>>>    
100084>>>>>    Get Seq_Open_Output_Channel sSourcePackageName to iCh
100085>>>>>    If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
100087>>>>>        Send Info_Box "No free channel to write output to. Process interrupted" "Error"
100088>>>>>        Function_Return False
100089>>>>>    End  
100089>>>>>>
100089>>>>>    
100089>>>>>    Get vFolderFormat sAppSrcPath to sAppSrcPath
100090>>>>>    
100090>>>>>    Move False to Err
100091>>>>>    Direct_Output channel iCh (sAppSrcPath + CS_DUFTestProgram)
100093>>>>>        Send WriteProgramCode iCh sSourcePackageName nSourcePackageVersion iDbVersionTable iDbVersionField
100094>>>>>    Close_Output channel iCh
100096>>>>>    Send Seq_Release_Channel iCh    
100097>>>>>                                        
100097>>>>>    Function_Return (Err = False)
100098>>>>>End_Function                                   
100099>>>>>
100099>>>>>Procedure WriteProgramCode Integer iCh String sSourcePackageName Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField
100102>>>>>    Writeln channel iCh ("/" + "/ *** DUF Auto-Generated Program - For Internal Usage Only! ***")
100105>>>>>    Writeln channel iCh ("/" + "/ *** Use it to send to a collegue that is working on the same project, ***")
100108>>>>>    Writeln channel iCh ("/" + "/ *** to update his/her database with database changes you have made. ***")
100111>>>>>    Writeln channel iCh (SFormat("#IF (%1@ > 190)",Character(33)))
100114>>>>>    Writeln channel iCh "    CompilerLevelWarning All On"
100117>>>>>    Writeln channel iCh "#ENDIF"
100120>>>>>    Writeln channel iCh "Use cApplication.pkg"
100123>>>>>    Writeln channel iCh "Use cDbUpdateHandler.pkg"
100126>>>>>    Writeln channel iCh 
100128>>>>>    Writeln channel iCh "Object oApplication is a cApplication"
100131>>>>>    Writeln channel iCh "    Set psCompany to 'RDC Tools International'"
100134>>>>>    Writeln channel iCh "    Set psProduct to 'DUF Auto Update Program'"
100137>>>>>    Writeln channel iCh "    Set psProgram to 'Internal use/test of a DUF Update Package'"
100140>>>>>    Writeln channel iCh "    Set psVersion to '19.1'"
100143>>>>>    Writeln channel iCh "End_Object"
100146>>>>>    Writeln channel iCh 
100148>>>>>    Writeln channel iCh 'Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: ' (String(nSourcePackageVersion)) ' now?") to WindowIndex'
100153>>>>>    Writeln channel iCh "If (WindowIndex <> MBR_Yes) Begin"
100156>>>>>    Writeln channel iCh "    Send Exit_Application"
100159>>>>>    Writeln channel iCh "End"
100162>>>>>    Writeln channel iCh 
100164>>>>>    Writeln channel iCh "Object oDbUpdateHandler is a cDbUpdateHandler"
100167>>>>>    Writeln channel iCh "    Set piDbVersionFileNumber  to " iDbVersionTable
100171>>>>>    Writeln channel iCh "    Set piDbVersionFieldNumber to " iDbVersionField
100175>>>>>    Writeln channel iCh "    Set pbAutoCreateDbVersionTable to True"
100178>>>>>    Writeln channel iCh 
100180>>>>>    Writeln channel iCh "    Use " sSourcePackageName
100184>>>>>    Writeln channel iCh 
100186>>>>>    Writeln channel iCh "End_Object"
100189>>>>>    Writeln channel iCh 
100191>>>>>    Writeln channel ich "If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin"
100194>>>>>    Writeln channel ich "   Send Info_Box 'Nothing to update. (Version number has not changed)'"
100197>>>>>    Writeln channel ich "End"
100200>>>>>    Writeln channel iCh 
100202>>>>>    Writeln channel iCh "Send Exit_Application"
100205>>>>>    Writeln channel iCh ("/" + "/ *** End-Of-Program Code ***")
100208>>>>>
100208>>>>>//    Writeln channel iCh "Object oMainPanel is a BasicPanel"
100208>>>>>//    Writeln channel iCh "    Set Location to 59 173"
100208>>>>>//    Writeln channel iCh "    Set Size to 180 394"
100208>>>>>//    Writeln channel iCh "    Set piMinSize to 180 394"
100208>>>>>//    Writeln channel iCh "    Set Border_Style to Border_Thick"
100208>>>>>//    Writeln channel iCh "    Set Locate_Mode to Center_On_Screen"
100208>>>>>//    Writeln channel iCh "    Set Label to (psProduct(ghoApplication))"
100208>>>>>//    Writeln channel iCh "    Set Maximize_Icon to False"
100208>>>>>//    Writeln channel iCh "    Set peNeighborhood to nhPublic"
100208>>>>>//    Writeln channel iCh "End_Object"
100208>>>>>//    Writeln channel iCh "
100208>>>>>//    Writeln channel iCh "Start_UI oMainPanel
100208>>>>>End_Procedure
100209>>>Use cRDCCommandLinkButton.pkg
Including file: cRDCCommandLinkButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCCommandLinkButton.pkg)
100209>>>>>//****************************************************************************
100209>>>>>// $Module type: Package
100209>>>>>// $Module name: cRDCCommandLinkButton.pkg
100209>>>>>//
100209>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100209>>>>>// Copyright (c) 2018 RDC Tools International
100209>>>>>// E-mail      : support@rdctools.com
100209>>>>>// Web-site    : http://www.rdctools.com
100209>>>>>//
100209>>>>>// Created     : 2018-11-09 @ 17:04 (Military date format - Year-Month-Day)
100209>>>>>//
100209>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100209>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100209>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100209>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100209>>>>>// in the help folder for more details.
100209>>>>>//
100209>>>>>//****************************************************************************
100209>>>>>Use Windows.pkg
100209>>>>>Use cCommandLinkButton.pkg
100209>>>>>Use Enclient.pkg
100209>>>>>Use errornum.inc
100209>>>>>
100209>>>>>Class cRDCCommandLinkButtonIdleHandler is a cIdleHandler
100210>>>>>    Procedure Construct_Object
100212>>>>>        Forward Send Construct_Object
100214>>>>>
100214>>>>>    End_Procedure
100215>>>>>
100215>>>>>    Procedure OnIdle
100217>>>>>        Delegate Send DoUpdate
100219>>>>>    End_Procedure
100220>>>>>
100220>>>>>End_Class
100221>>>>>
100221>>>>>Class cRDCCommandLinkButton is a cCommandLinkButton
100222>>>>>
100222>>>>>    Procedure Construct_Object
100224>>>>>        Forward Send Construct_Object
100226>>>>>
100226>>>>>        Property Boolean pbAutoEnable True
100227>>>>>
100227>>>>>        Property Boolean pbEnabled True
100228>>>>>
100228>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cRDCCommandLinkButtonIdleHandler)))
100229>>>>>
100229>>>>>        Set Border_Style to Border_Normal
100230>>>>>        Set piImageSize to 32
100231>>>>>        Set pbCenterToolTip to True
100232>>>>>
100232>>>>>    End_Procedure
100233>>>>>
100233>>>>>    Procedure End_Construct_Object
100235>>>>>        String sTooltip sStatus_Help
100235>>>>>
100235>>>>>        Forward Send End_Construct_Object
100237>>>>>
100237>>>>>        Get psToolTip   to sTooltip
100238>>>>>        Get Status_Help to sStatus_Help
100239>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
100241>>>>>            Set psToolTip to sStatus_Help
100242>>>>>        End
100242>>>>>>
100242>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
100243>>>>>    End_Procedure
100244>>>>>
100244>>>>>    Procedure DoUpdate
100246>>>>>        If (pbAutoEnable(Self) = False) Begin
100248>>>>>            Procedure_Return
100249>>>>>        End
100249>>>>>>
100249>>>>>        Set Enabled_State to (IsEnabled(Self))
100250>>>>>    End_Procedure
100251>>>>>
100251>>>>>    Function IsEnabled Returns Boolean
100253>>>>>        Boolean bEnabled
100253>>>>>        Get pbEnabled to bEnabled
100254>>>>>        Function_Return bEnabled
100255>>>>>    End_Function
100256>>>>>
100256>>>>>    // Enable the idle handler timer when the button is activated
100256>>>>>    Procedure Activating
100258>>>>>        Forward Send Activating
100260>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
100261>>>>>    End_Procedure
100262>>>>>
100262>>>>>    // Disable the idle handler when the button is deactivated
100262>>>>>    Procedure Deactivating
100264>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
100265>>>>>        Forward Send Deactivating
100267>>>>>    End_Procedure
100268>>>>>
100268>>>>>    Procedure Set Color Integer eColor
100270>>>>>        Forward Set Color to clBtnFace
100272>>>>>    End_Procedure
100273>>>>>
100273>>>>>End_Class
100274>>>Use cRDCSlideButton.pkg                                 
Including file: cRDCSlideButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCSlideButton.pkg)
100274>>>>>//****************************************************************************
100274>>>>>// $Module type: Package
100274>>>>>// $Module name: cRDCSlideButton.pkg
100274>>>>>//
100274>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100274>>>>>// Copyright (c) 2018 RDC Tools International
100274>>>>>// E-mail      : support@rdctools.com
100274>>>>>// Web-site    : http://www.rdctools.com
100274>>>>>//
100274>>>>>// Created     : 2018-01-04 @ 16:47 (Military date format - Year-Month-Day)
100274>>>>>//
100274>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100274>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100274>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100274>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100274>>>>>// in the help folder for more details.
100274>>>>>//
100274>>>>>//****************************************************************************
100274>>>>>Use Windows.pkg
100274>>>>>Use cCommandLinkButton.pkg
100274>>>>>
100274>>>>>
100274>>>>>Enum_List
100274>>>>>    Define CI_RDCSlideButtonSmallImage  for 16
100274>>>>>    Define CI_RDCSlideButtonMediumImage for 24
100274>>>>>End_Enum_List
100274>>>>>
100274>>>>>// Used by the "Page" message below to show
100274>>>>>// a rectangle around ComboForm and Checkbox objects.
100274>>>>>
100274>>>>>Class cRDCSlideButtonImage is a cCommandLinkButton
100275>>>>>    Procedure Construct_Object
100277>>>>>        Forward Send Construct_Object
100279>>>>>
100279>>>>>        Property Handle private.phoParent 0
100280>>>>>
100280>>>>>    End_Procedure
100281>>>>>
100281>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
100283>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
100285>>>>>        Send OnChange of (private.phoParent(Self))
100286>>>>>        Send Activate of (private.phoParent(Self))
100287>>>>>    End_Procedure
100288>>>>>
100288>>>>>    Procedure End_Construct_Object
100290>>>>>        Forward Send End_Construct_Object
100292>>>>>    End_Procedure
100293>>>>>
100293>>>>>End_Class
100294>>>>>
100294>>>>>Class cRDCSlideTextbox is a CheckBox
100295>>>>>
100295>>>>>    Procedure Construct_Object
100297>>>>>        Forward Send Construct_Object
100299>>>>>
100299>>>>>        Set Auto_Size_State to True
100300>>>>>    End_Procedure
100301>>>>>
100301>>>>>    Procedure End_Construct_Object
100303>>>>>        Forward Send End_Construct_Object
100305>>>>>    End_Procedure
100306>>>>>
100306>>>>>    Procedure OnChange
100308>>>>>        Delegate Send OnChange
100310>>>>>    End_Procedure
100311>>>>>
100311>>>>>    Procedure Page Integer iState
100313>>>>>        Integer iStyle iRet
100313>>>>>        Handle hWnd
100313>>>>>
100313>>>>>        If (iState = 1) Begin
100315>>>>>            Get Form_Style iStyle to iStyle
100316>>>>>            Set Form_Style 0 to (iStyle ior BS_USERBUTTON)
100317>>>>>            Forward Send Page iState
100319>>>>>            Get Window_Handle to hWnd
100320>>>>>            If (hWnd) Begin
100322>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
100323>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
100325>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
100326>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
100327>>>>>                End
100327>>>>>>
100327>>>>>            End
100327>>>>>>
100327>>>>>        End
100327>>>>>>
100327>>>>>        Else Begin
100328>>>>>            Forward Send Page iState
100330>>>>>        End
100330>>>>>>
100330>>>>>    End_Procedure
100331>>>>>
100331>>>>>End_Class
100332>>>>>
100332>>>>>// Intermediate class - don't use.
100332>>>>>Class _cRDCSlideButtonContainer is a Container3d
100333>>>>>
100333>>>>>    Procedure Construct_Object
100335>>>>>        Forward Send Construct_Object
100337>>>>>
100337>>>>>        Property String private.psLabel
100338>>>>>        Property String private.psToolTip
100339>>>>>        Property String private.Status_Help
100340>>>>>        Property Handle private.Label_Object
100341>>>>>
100341>>>>>        Set Border_Style to Border_None
100342>>>>>    End_Procedure
100343>>>>>
100343>>>>>    Procedure End_Construct_Object
100345>>>>>        Forward Send End_Construct_Object
100347>>>>>
100347>>>>>    End_Procedure
100348>>>>>
100348>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
100348>>>>>    Procedure Set psLabel String sLabel
100350>>>>>        Set private.psLabel to sLabel
100351>>>>>        If (private.Label_Object(Self) <> 0) Begin
100353>>>>>            Set Label of (private.Label_Object(Self)) to sLabel
100354>>>>>        End
100354>>>>>>
100354>>>>>    End_Procedure
100355>>>>>
100355>>>>>    Function psLabel Returns String
100357>>>>>        Function_Return (private.psLabel(Self))
100358>>>>>    End_Function
100359>>>>>
100359>>>>>    Procedure Set Label String sLabel
100361>>>>>        Set psLabel to sLabel
100362>>>>>    End_Procedure
100363>>>>>
100363>>>>>    Function Label Returns String
100365>>>>>        Function_Return (private.psLabel(Self))
100366>>>>>    End_Function
100367>>>>>
100367>>>>>    Procedure Set psToolTip String sToolTip
100369>>>>>        Set private.psToolTip to sToolTip
100370>>>>>    End_Procedure
100371>>>>>
100371>>>>>    Function psToolTip Returns String
100373>>>>>        Function_Return (private.psToolTip(Self))
100374>>>>>    End_Function
100375>>>>>
100375>>>>>    Procedure Set Status_Help String sStatusHelp
100377>>>>>        Set private.Status_Help to sStatusHelp
100378>>>>>    End_Procedure
100379>>>>>
100379>>>>>    Function Status_Help Returns String
100381>>>>>        Function_Return (private.Status_Help(Self))
100382>>>>>    End_Function
100383>>>>>
100383>>>>>End_Class
100384>>>>>
100384>>>>>Class cRDCSlideButton is a _cRDCSlideButtonContainer
100385>>>>>
100385>>>>>    Procedure Construct_Object
100387>>>>>        Forward Send Construct_Object
100389>>>>>
100389>>>>>        Property Handle private.phoButton 0
100390>>>>>        Property String private.psImage
100391>>>>>
100391>>>>>        Property Boolean private.Checked_State False
100392>>>>>        Property Boolean private.Auto_Size_State True
100393>>>>>        Property Integer private.piButtonHeight 15
100394>>>>>        Property Integer private.piButtonWidth  14
100395>>>>>        Property Integer private.piButtonLocationOffset -5
100396>>>>>        Property String psToggleOnImage  "ToggleOn.ico"
100397>>>>>        Property String psToggleOffImage "ToggleOff.ico"
100398>>>>>        Property Integer piImageSize CI_RDCSlideButtonMediumImage
100399>>>>>
100399>>>>>        On_Key kSwitch Send Switch_Next_Area
100400>>>>>    End_Procedure
100401>>>>>
100401>>>>>    // We support two syntaxes "Checked_State" and "pbChecked"
100401>>>>>    Procedure Set Checked_State Boolean bState
100403>>>>>        Set private.Checked_State to (not(bState))
100404>>>>>        Send OnChange
100405>>>>>    End_Procedure
100406>>>>>
100406>>>>>    Procedure Set pbChecked Boolean bState
100408>>>>>        Set private.Checked_State to bState
100409>>>>>        Send OnChange
100410>>>>>    End_Procedure
100411>>>>>
100411>>>>>    Function Checked_State Returns Boolean
100413>>>>>        Function_Return (private.Checked_State(Self))
100414>>>>>    End_Function
100415>>>>>
100415>>>>>    Function pbChecked Returns Boolean
100417>>>>>        Function_Return (private.Checked_State(Self))
100418>>>>>    End_Function
100419>>>>>
100419>>>>>    // This adjustment is so that the Studio layout is the same as when the
100419>>>>>    // program has been compiled and run.
100419>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
100421>>>>>        If (iColPos > 4) Begin
100423>>>>>            Move (iColPos -4) to iColPos
100424>>>>>        End
100424>>>>>>
100424>>>>>
100424>>>>>        Forward Set Location to iRowPos iColPos
100426>>>>>    End_Procedure
100427>>>>>
100427>>>>>    // This slight adjustment is needed so the control doesn't
100427>>>>>    // "bump into" an object to the right of it that is located really close.
100427>>>>>    //    Procedure Set Size Integer iHeight Integer iWidth
100427>>>>>    //        If (iWidth > 5) Begin
100427>>>>>    //            Move (iWidth -5) to iWidth
100427>>>>>    //        End
100427>>>>>    //
100427>>>>>    //        Forward Set Size to iHeight iWidth
100427>>>>>    //    End_Procedure
100427>>>>>
100427>>>>>    Procedure OnChange
100429>>>>>        Handle hoButton
100429>>>>>        Boolean bChecked
100429>>>>>        String sImage
100429>>>>>
100429>>>>>        Get private.Checked_State to bChecked
100430>>>>>        Set private.Checked_State to (not(bChecked))
100431>>>>>        Get psCurrentImage to sImage
100432>>>>>        Get private.phoButton to hoButton
100433>>>>>        If (hoButton <> 0) Begin
100435>>>>>            Set psImage of hoButton to sImage
100436>>>>>            If (Desktop <> Self) Begin
100438>>>>>                Send OnChangeEvent
100439>>>>>            End
100439>>>>>>
100439>>>>>        End
100439>>>>>>
100439>>>>>    End_Procedure
100440>>>>>
100440>>>>>    Function psCurrentImage Returns String
100442>>>>>        Boolean bChecked
100442>>>>>        String sImage
100442>>>>>
100442>>>>>        Get private.Checked_State to bChecked
100443>>>>>        If (bChecked = True) Begin
100445>>>>>            Get psToggleOnImage to sImage
100446>>>>>        End
100446>>>>>>
100446>>>>>        Else Begin
100447>>>>>            Get psToggleOffImage to sImage
100448>>>>>        End
100448>>>>>>
100448>>>>>        Function_Return sImage
100449>>>>>    End_Function
100450>>>>>
100450>>>>>    Procedure OnClick
100452>>>>>        Send OnChange
100453>>>>>    End_Procedure
100454>>>>>
100454>>>>>    Procedure OnChangeEvent
100456>>>>>    End_Procedure
100457>>>>>
100457>>>>>    Procedure DoToggle
100459>>>>>        Boolean bChecked
100459>>>>>        Get Checked_State to bChecked
100460>>>>>        Set Checked_State to (not(bChecked))
100461>>>>>    End_Procedure
100462>>>>>
100462>>>>>    Procedure End_Construct_Object
100464>>>>>        Integer iSize iLoc iHeight iWidth iOffset iTextOffset iIconIndex iImageSize
100464>>>>>        Handle ho hoParent
100464>>>>>        String sImage sLabel
100464>>>>>
100464>>>>>        Forward Send End_Construct_Object
100466>>>>>
100466>>>>>        Get piImageSize to iImageSize
100467>>>>>        Case Begin
100467>>>>>            Case (iImageSize = CI_RDCSlideButtonSmallImage)
100469>>>>>                Set private.piButtonHeight         to 14
100470>>>>>                Set private.piButtonWidth          to 14
100471>>>>>                Set private.piButtonLocationOffset to -5
100472>>>>>                Case Break
100473>>>>>            Case (iImageSize = CI_RDCSlideButtonMediumImage)
100476>>>>>                Set private.piButtonHeight         to 16
100477>>>>>                Set private.piButtonWidth          to 20
100478>>>>>                Set private.piButtonLocationOffset to -6
100479>>>>>                Case Break
100480>>>>>        Case End
100480>>>>>
100480>>>>>        Move Self to hoParent
100481>>>>>        Get Label of hoParent to sLabel
100482>>>>>        Get Text_Extent sLabel to iTextOffset
100483>>>>>        Get Size     to iSize
100484>>>>>        Get Location to iLoc
100485>>>>>        Get psCurrentImage to sImage
100486>>>>>        Get private.piButtonHeight to iHeight
100487>>>>>        Get private.piButtonWidth  to iWidth
100488>>>>>        Set Size to (Hi(iSize)) (Low(iSize) + iWidth -7)
100489>>>>>        Get private.piButtonLocationOffset to iOffset
100490>>>>>        Get GetCorrectIconIndex  to iIconIndex
100491>>>>>        Move (iOffset + iIconIndex -1) to iOffset
100492>>>>>
100492>>>>>        Get CreateNamed (RefClass(cRDCSlideButtonImage)) "oRDCSlideButtonImage" to ho
100493>>>>>        Set Size                of ho to iHeight iWidth
100494>>>>>        Set Location            of ho to iOffset 0
100495>>>>>        Set psToolTip           of ho to (private.psToolTip(hoParent))
100496>>>>>        If (private.Status_Help(hoParent) = "") Begin
100498>>>>>            Set Status_Help     of ho to (private.psToolTip(hoParent))
100499>>>>>        End
100499>>>>>>
100499>>>>>        Else Begin
100500>>>>>            Set Status_Help     of ho to (private.Status_Help(hoParent))
100501>>>>>        End
100501>>>>>>
100501>>>>>        Set psImage             of ho to sImage
100502>>>>>        Set pbAutoResizeIcons   of ho to True
100503>>>>>        Set piImageSize         of ho to (piImageSize(Self))
100504>>>>>        //            Set Focus_Mode          of ho to NonFocusable
100504>>>>>        Set private.phoParent   of ho to hoParent
100505>>>>>        Set private.phoButton to ho
100506>>>>>
100506>>>>>        Get CreateNamed (RefClass(cRDCSlideTextbox)) "cRDCSlideTextbox" to ho
100507>>>>>        Set private.Label_Object to ho
100508>>>>>        Set Size                of ho to (Hi(iSize)) (Low(iSize) + iWidth)
100509>>>>>        Set Location            of ho to 2 iWidth
100510>>>>>        Set Label               of ho to sLabel
100511>>>>>        Set Focus_Mode          of ho to NonFocusable
100512>>>>>        Set psToolTip           of ho to (private.psToolTip(Parent(ho)))
100513>>>>>        If (private.Status_Help(hoParent) = "") Begin
100515>>>>>            Set Status_Help     of ho to (private.psToolTip(hoParent))
100516>>>>>        End
100516>>>>>>
100516>>>>>        Else Begin
100517>>>>>            Set Status_Help     of ho to (private.Status_Help(hoParent))
100518>>>>>        End
100518>>>>>>
100518>>>>>
100518>>>>>        //        Get psCurrentImage to sImage
100518>>>>>        //        Set Bitmap of ho to sImage
100518>>>>>        Send OnChangeEvent
100519>>>>>    End_Procedure
100520>>>>>
100520>>>>>    // Returns: DPI setting as an integer.
100520>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
100520>>>>>    //                      iDPI=120 is "Medium setting" 125%
100520>>>>>    //                      iDPI= 144 is "Large setting" 150%
100520>>>>>    Function GetCurrentDPI Returns Integer
100522>>>>>        Handle hDC
100522>>>>>        Integer iPixelsX
100522>>>>>        Move (GetDC(0)) to hDC
100523>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
100524>>>>>        Move (ReleaseDC(0, hDC)) to hDC
100525>>>>>        Function_Return iPixelsX
100526>>>>>    End_Function
100527>>>>>
100527>>>>>    Function GetCorrectIconSize Returns Integer
100529>>>>>        Integer iPixelsX iIndex iSize
100529>>>>>        Integer[] iaSizes
100530>>>>>
100530>>>>>        Move 16 to iaSizes[0]
100531>>>>>        Move 24 to iaSizes[1]
100532>>>>>        Move 32 to iaSizes[2]
100533>>>>>        Move 48 to iaSizes[3]
100534>>>>>        Move 64 to iaSizes[4]
100535>>>>>
100535>>>>>        Get piImageSize to iSize  // the "100%" size
100536>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
100537>>>>>        Move (0 max iIndex) to iIndex
100538>>>>>        Get GetCurrentDPI to iPixelsX
100539>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
100539>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
100539>>>>>        // will increment iIndex as many times as we need here.
100539>>>>>        Case Begin
100539>>>>>            Case (iPixelsX > 144)
100541>>>>>                Increment iIndex
100542>>>>>            Case (iPixelsX = 144)
100545>>>>>                Increment iIndex
100546>>>>>            Case (iPixelsX = 120)
100549>>>>>                Increment iIndex
100550>>>>>        Case End
100550>>>>>        Move (iIndex min 4) to iIndex
100551>>>>>        Function_Return iaSizes[iIndex]
100552>>>>>    End_Function
100553>>>>>
100553>>>>>    Function GetCorrectIconIndex Returns Integer
100555>>>>>        Integer iPixelsX iIndex iSize
100555>>>>>        Integer[] iaSizes
100556>>>>>
100556>>>>>        Move 16 to iaSizes[0]
100557>>>>>        Move 24 to iaSizes[1]
100558>>>>>        Move 32 to iaSizes[2]
100559>>>>>        Move 48 to iaSizes[3]
100560>>>>>        Move 64 to iaSizes[4]
100561>>>>>
100561>>>>>        Get piImageSize to iSize  // the "100%" size
100562>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
100563>>>>>        Move (0 max iIndex) to iIndex
100564>>>>>        Get GetCurrentDPI to iPixelsX
100565>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
100565>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
100565>>>>>        // will increment iIndex as many times as we need here.
100565>>>>>        Case Begin
100565>>>>>            Case (iPixelsX > 144)
100567>>>>>                Increment iIndex
100568>>>>>            Case (iPixelsX = 144)
100571>>>>>                Increment iIndex
100572>>>>>            Case (iPixelsX = 120)
100575>>>>>                Increment iIndex
100576>>>>>        Case End
100576>>>>>        Move (iIndex min 4) to iIndex
100577>>>>>        Function_Return iIndex
100578>>>>>    End_Function
100579>>>>>
100579>>>>>End_Class
100580>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCCJSelectionGrid.pkg)
100580>>>>>//****************************************************************************
100580>>>>>// $Module type: Package
100580>>>>>// $Module name: cRDCCJSelectionGrid.pkg
100580>>>>>//
100580>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100580>>>>>// Copyright (c) 2018 RDC Tools International
100580>>>>>// E-mail      : support@rdctools.com
100580>>>>>// Web-site    : http://www.rdctools.com
100580>>>>>//
100580>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
100580>>>>>//
100580>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
100580>>>>>//
100580>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100580>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100580>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100580>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100580>>>>>// in the help folder for more details.
100580>>>>>//
100580>>>>>//****************************************************************************
100580>>>>>Use cCJGrid.pkg
100580>>>>>Use cCJGridColumn.pkg
100580>>>>>Use cCJGridColumnRowIndicator.pkg
100580>>>>>Use Cursor.pkg
100580>>>>>Use vWin32fh.pkg
100580>>>>>
100580>>>>>    Define CS_Settings                for "Settings"
100580>>>>>    Define CS_GridFontSize            for "GridFontSize"
100580>>>>>    Define CS_GridRowBackgroundColor  for "GridRowBackgroundColor"
100580>>>>>
100580>>>>>Struct tsSearchResult
100580>>>>>    String sFilename
100580>>>>>    String sAlternateFileName   // 8.3 format
100580>>>>>    DateTime dtCreationDateTime
100580>>>>>    DateTime dtLastAccessDateTime
100580>>>>>    DateTime dtLastWriteDateTime
100580>>>>>    BigInt biFileSize
100580>>>>>    Integer iFileAttributes
100580>>>>>End_Struct
100580>>>>>
100580>>>>>Enum_List
100580>>>>>    Define cx_Select_All
100580>>>>>    Define cx_Select_None
100580>>>>>    Define cx_Select_Invert
100580>>>>>End_Enum_List
100580>>>>>
100580>>>>>Struct tFolderData
100580>>>>>    String sFolderName
100580>>>>>    Boolean bSelected
100580>>>>>End_Struct
100580>>>>>
100580>>>>>// Classes used by the cRDCCJSelectionGrid
100580>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
100581>>>>>
100581>>>>>    Procedure Construct_Object
100583>>>>>        Forward Send Construct_Object
100585>>>>>        Set psCaption to "Toggle Current Item"
100586>>>>>        Set psImage to "ToggleOn.ico"
100587>>>>>        Set psShortcut to "Space-Bar"
100588>>>>>    End_Procedure
100589>>>>>
100589>>>>>    Procedure OnExecute Variant vCommandBarControl
100591>>>>>        Forward Send OnExecute vCommandBarControl
100593>>>>>        Send ToggleCurrentItem
100594>>>>>    End_Procedure
100595>>>>>
100595>>>>>End_Class
100596>>>>>
100596>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
100597>>>>>
100597>>>>>    Procedure Construct_Object
100599>>>>>        Forward Send Construct_Object
100601>>>>>        Set pbControlBeginGroup to True
100602>>>>>        Set psCaption to "Select All"
100603>>>>>        Set psImage to "SelectAll.ico"
100604>>>>>        Set psShortcut to "Ctrl+A"
100605>>>>>    End_Procedure
100606>>>>>
100606>>>>>    Procedure OnExecute Variant vCommandBarControl
100608>>>>>        Forward Send OnExecute vCommandBarControl
100610>>>>>        Set SelectItems to cx_Select_All
100611>>>>>    End_Procedure
100612>>>>>
100612>>>>>End_Class
100613>>>>>
100613>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
100614>>>>>
100614>>>>>    Procedure Construct_Object
100616>>>>>        Forward Send Construct_Object
100618>>>>>        Set psCaption to "Select None"
100619>>>>>        Set psImage to "SelectNone.ico"
100620>>>>>        Set psShortcut to "Ctrl+N"
100621>>>>>    End_Procedure
100622>>>>>
100622>>>>>    Procedure OnExecute Variant vCommandBarControl
100624>>>>>        Forward Send OnExecute vCommandBarControl
100626>>>>>        Set SelectItems to cx_Select_None
100627>>>>>    End_Procedure
100628>>>>>
100628>>>>>End_Class
100629>>>>>
100629>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
100630>>>>>
100630>>>>>    Procedure Construct_Object
100632>>>>>        Forward Send Construct_Object
100634>>>>>        Set psCaption to "Invert Selection"
100635>>>>>        Set psImage to "SelectInvert.ico"
100636>>>>>        Set psShortcut to "Ctrl+I"
100637>>>>>    End_Procedure
100638>>>>>
100638>>>>>    Procedure OnExecute Variant vCommandBarControl
100640>>>>>        Forward Send OnExecute vCommandBarControl
100642>>>>>        Set SelectItems to cx_Select_Invert
100643>>>>>    End_Procedure
100644>>>>>
100644>>>>>End_Class
100645>>>>>
100645>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
100646>>>>>
100646>>>>>    Procedure Construct_Object
100648>>>>>        Forward Send Construct_Object
100650>>>>>        Set psCaption to "Add Folder"
100651>>>>>        Set psImage to "AddFolder.ico"
100652>>>>>        Set psShortcut to "Ins"
100653>>>>>    End_Procedure
100654>>>>>
100654>>>>>    Procedure OnExecute Variant vCommandBarControl
100656>>>>>        Forward Send OnExecute vCommandBarControl
100658>>>>>        Send BrowseForFolder
100659>>>>>    End_Procedure
100660>>>>>
100660>>>>>End_Class
100661>>>>>
100661>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
100662>>>>>
100662>>>>>    Procedure Construct_Object
100664>>>>>        Forward Send Construct_Object
100666>>>>>        Set psCaption to "Remove From Grid"
100667>>>>>        Set psImage to "ActionDelete.ico"
100668>>>>>        Set psShortcut to "Del"
100669>>>>>    End_Procedure
100670>>>>>
100670>>>>>    Procedure OnExecute Variant vCommandBarControl
100672>>>>>        Forward Send OnExecute vCommandBarControl
100674>>>>>        Send Request_Delete
100675>>>>>    End_Procedure
100676>>>>>
100676>>>>>End_Class
100677>>>>>
100677>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
100677>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
100677>>>>>Register_Function pbShowInvertSelectionsMenuItem Returns Boolean
100677>>>>>
100677>>>>>Class cGridContext_mnu is a cCJContextMenu
100678>>>>>    Procedure Construct_Object
100680>>>>>        Handle hoMenuItem
100680>>>>>        Forward Send Construct_Object
100682>>>>>
100682>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
100683>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
100684>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
100685>>>>>        If (pbShowInvertSelectionsMenuItem(Self) = True) Begin
100687>>>>>            Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
100688>>>>>        End
100688>>>>>>
100688>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
100690>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
100691>>>>>            Set pbControlBeginGroup of hoMenuItem to True
100692>>>>>        End
100692>>>>>>
100692>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
100694>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
100695>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
100697>>>>>                Set pbControlBeginGroup of hoMenuItem to True
100698>>>>>            End
100698>>>>>>
100698>>>>>        End
100698>>>>>>
100698>>>>>    End_Procedure
100699>>>>>
100699>>>>>End_Class
100700>>>>>
100700>>>>>Class cRDCCJSelectionGrid is a cCJGrid
100701>>>>>
100701>>>>>    Procedure Construct_Object
100703>>>>>        Forward Send Construct_Object
100705>>>>>
100705>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
100705>>>>>        Property Handle phoData_Col 0
100706>>>>>        Property Handle phoCheckbox_Col 0
100707>>>>>
100707>>>>>        Property Boolean pbShowAddFolderMenuItem False
100708>>>>>        Property Boolean pbShowRemoveFolderMenuItem False   
100709>>>>>        Property Boolean pbShowInvertSelectionsMenuItem True
100710>>>>>        Property Boolean pbEnableMoveKeys False
100711>>>>>        Property Boolean pbAutoSaveSelections False
100712>>>>>
100712>>>>>        Set pbRestoreLayout to True
100713>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
100714>>>>>        Set psNoItemsText to "No data found..."
100715>>>>>        Set pbHeaderReorders to True
100716>>>>>        Set pbHeaderPrompts to False
100717>>>>>        Set pbHeaderTogglesDirection to True
100718>>>>>        Set pbSelectionEnable to True
100719>>>>>        Set pbAllowInsertRow to False
100720>>>>>        Set pbAllowAppendRow to False
100721>>>>>        Set pbShowRowFocus to True
100722>>>>>        Set pbShowFooter to True
100723>>>>>        Set pbMultipleSelection to True
100724>>>>>        Set pbHotTracking to True
100725>>>>>        Set pbEditOnClick to True
100726>>>>>        Set piLayoutBuild to 4
100727>>>>>        Set Status_Help to "Select with the spacebar"
100728>>>>>        Set pbUseAlternateRowBackgroundColor to True
100729>>>>>        Set peAnchors to anAll
100730>>>>>        // This makes the ticked checkboxes to appear as bold.
100730>>>>>                Set peVisualTheme to xtpGridThemeVisualStudio2012Light
100731>>>>>
100731>>>>>        On_Key Key_Space      Send ToggleCurrentItem
100732>>>>>        On_Key Key_Delete     Send Request_Delete
100733>>>>>        On_Key Key_Insert     Send BrowseForFolder
100734>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
100735>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
100736>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
100737>>>>>        On_Key kCancel        Send CancelIfPopupObject
100738>>>>>        On_Key Key_Alt+Key_Down_Arrow Send MoveDown
100739>>>>>        On_Key Key_Alt+Key_Up_Arrow   Send MoveUp
100740>>>>>    End_Procedure
100741>>>>>
100741>>>>>    Procedure MoveUp
100743>>>>>        tDataSourceRow[] TheData
100743>>>>>        tDataSourceRow[] TheData
100744>>>>>        tDataSourceRow TheRow
100744>>>>>        tDataSourceRow TheRow
100744>>>>>        Handle hDataSource
100744>>>>>        Integer iCurrentRow
100744>>>>>
100744>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
100746>>>>>            Procedure_Return
100747>>>>>        End
100747>>>>>>
100747>>>>>        Get phoDataSource to hDataSource
100748>>>>>        Get DataSource of hDataSource to TheData
100749>>>>>        Get SelectedRow of hDataSource to iCurrentRow
100750>>>>>        If (iCurrentRow > 0) Begin
100752>>>>>            Move TheData[iCurrentRow - 1] to TheRow
100753>>>>>            Move TheData[iCurrentRow] to TheData[iCurrentRow - 1]
100754>>>>>            Move TheRow to TheData[iCurrentRow]
100755>>>>>            Send ReInitializeData TheData True
100756>>>>>            Send MoveToRow (iCurrentRow - 1)
100757>>>>>        End
100757>>>>>>
100757>>>>>    End_Procedure
100758>>>>>
100758>>>>>    Procedure MoveDown
100760>>>>>        tDataSourceRow[] TheData
100760>>>>>        tDataSourceRow[] TheData
100761>>>>>        tDataSourceRow TheRow
100761>>>>>        tDataSourceRow TheRow
100761>>>>>        Handle hDataSource
100761>>>>>        Integer iCurrentRow
100761>>>>>
100761>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
100763>>>>>            Procedure_Return
100764>>>>>        End
100764>>>>>>
100764>>>>>        Get phoDataSource to hDataSource
100765>>>>>        Get DataSource of hDataSource to TheData
100766>>>>>        Get SelectedRow of hDataSource to iCurrentRow
100767>>>>>        If ((iCurrentRow + 1) < SizeOfArray(TheData)) Begin
100769>>>>>            Move TheData[iCurrentRow] to TheRow
100770>>>>>            Move TheData[iCurrentRow + 1] to TheData[iCurrentRow]
100771>>>>>            Move TheRow to TheData[iCurrentRow + 1]
100772>>>>>            Send ReInitializeData TheData True
100773>>>>>            Send MoveToRow (iCurrentRow + 1)
100774>>>>>        End
100774>>>>>>
100774>>>>>    End_Procedure
100775>>>>>
100775>>>>>    Procedure RefreshSelectionUpdate
100777>>>>>    End_Procedure                   
100778>>>>>    
100778>>>>>    Procedure CancelIfPopupObject
100780>>>>>        Boolean bIsInPopupObject
100780>>>>>        Delegate Get Popup_State to bIsInPopupObject
100782>>>>>        If (bIsInPopupObject = True) Begin
100784>>>>>            Send Close_Panel
100785>>>>>        End
100785>>>>>>
100785>>>>>    End_Procedure
100786>>>>>
100786>>>>>    Procedure End_Construct_Object
100788>>>>>        String sColor
100788>>>>>        Handle hoContextMenu
100788>>>>>        Forward Send End_Construct_Object
100790>>>>>
100790>>>>>        Object oCheckbox_col is a cCJGridColumn
100792>>>>>            Set phoCheckbox_Col to Self
100793>>>>>            Set piWidth to 60
100794>>>>>            Set pbResizable to False
100795>>>>>            Set psCaption to "Select"
100796>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
100797>>>>>            Set pbCheckbox to True
100798>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
100799>>>>>            Set peFooterAlignment to xtpAlignmentCenter
100800>>>>>            Set peDataType to Mask_Numeric_Window
100801>>>>>        End_Object
100802>>>>>
100802>>>>>        If (ghoApplication <> 0) Begin
100804>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
100805>>>>>        End
100805>>>>>>
100805>>>>>        If (sColor = "clBlueGreyLight") Begin
100807>>>>>            Move "clGreenGrey" to sColor
100808>>>>>        End
100808>>>>>>
100808>>>>>        Set piSelectedRowBackColor to sColor
100809>>>>>        Set piHighlightBackColor   to sColor
100810>>>>>
100810>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
100811>>>>>        Set phoContextMenu to hoContextMenu
100812>>>>>    End_Procedure
100813>>>>>
100813>>>>>    Procedure OnCreateGridControl
100815>>>>>        Handle hoObject
100815>>>>>        Integer iToolTipStyle
100815>>>>>        Boolean bIsBalloonStyleSupported
100815>>>>>
100815>>>>>        Forward Send OnCreateGridControl
100817>>>>>
100817>>>>>        Get phoToolTipContext to hoObject
100818>>>>>        If (hoObject <> 0) Begin
100820>>>>>            Move xtpToolTipStandard to iToolTipStyle
100821>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
100821>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
100821>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
100822>>>>>            If (bIsBalloonStyleSupported = True) Begin
100824>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
100825>>>>>            End
100825>>>>>>
100825>>>>>            Set ComStyle             of hoObject to iToolTipStyle
100826>>>>>            Set ComShowOfficeBorder  of hoObject to True
100827>>>>>            Set ComShowShadow        of hoObject to True
100828>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
100828>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
100828>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
100829>>>>>        End
100829>>>>>>
100829>>>>>        Send DoChangeFontSize
100830>>>>>    End_Procedure
100831>>>>>
100831>>>>>    Procedure AddItem String sDataValue
100833>>>>>        Handle hoDataSource
100833>>>>>        tDataSourceRow[] TheData
100833>>>>>        tDataSourceRow[] TheData
100834>>>>>        tsSearchResult[] asFolderArray
100834>>>>>        tsSearchResult[] asFolderArray
100835>>>>>        Integer iSize iData_Col iCheckbox_Col
100835>>>>>
100835>>>>>        If (not(IsComObjectCreated(Self))) Begin
100837>>>>>            Procedure_Return
100838>>>>>        End
100838>>>>>>
100838>>>>>
100838>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
100839>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
100840>>>>>        Get phoDataSource to hoDataSource
100841>>>>>        Get DataSource of hoDataSource to TheData
100842>>>>>        Move (SizeOfArray(TheData)) to iSize
100843>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
100844>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
100845>>>>>
100845>>>>>        Send ReInitializeData TheData False
100846>>>>>        Send MoveToLastRow
100847>>>>>    End_Procedure
100848>>>>>
100848>>>>>    Procedure BrowseForFolder
100850>>>>>        String sFolderName
100850>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
100851>>>>>        If (sFolderName <> "") Begin
100853>>>>>            Send AddItem sFolderName
100854>>>>>        End
100854>>>>>>
100854>>>>>    End_Procedure
100855>>>>>
100855>>>>>    // We don't want columns to be editable. But setting
100855>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
100855>>>>>    // and makes it impossible to select the checkbox column with the mouse.
100855>>>>>    // So we disable those columns instead.
100855>>>>>    Function CanEditColumn Integer iCol Returns Boolean
100857>>>>>        Handle hoCol
100857>>>>>        Boolean bRetval
100857>>>>>
100857>>>>>        Forward Get CanEditColumn iCol to bRetval
100859>>>>>
100859>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
100860>>>>>        If (iCol <> hoCol) Begin
100862>>>>>            Move False to bRetval
100863>>>>>        End
100863>>>>>>
100863>>>>>        Else Begin
100864>>>>>            Move True to bRetval
100865>>>>>        End
100865>>>>>>
100865>>>>>
100865>>>>>        Function_Return bRetval
100866>>>>>    End_Function
100867>>>>>
100867>>>>>    Procedure Request_Clear_All
100869>>>>>        tDataSourceRow[] EmptyData
100869>>>>>        tDataSourceRow[] EmptyData
100870>>>>>        Handle hoGrid hoDataSource
100870>>>>>
100870>>>>>        Move Self  to hoGrid
100871>>>>>        If (IsComObjectCreated(hoGrid)) Begin
100873>>>>>            Get phoDataSource of hoGrid to hoDataSource
100874>>>>>            Send InitializeData of hoGrid EmptyData
100875>>>>>            Send DoSetCheckboxFooterText
100876>>>>>        End
100876>>>>>>
100876>>>>>    End_Procedure
100877>>>>>
100877>>>>>    // Set checkboxes of the first column as selected.
100877>>>>>    // iState can be one of the following:
100877>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
100877>>>>>    Procedure Set SelectItems Integer iState
100879>>>>>        Integer iCount iSize iCheckbox_Col
100879>>>>>        Boolean bChecked
100879>>>>>        Handle hoDataSource hoCheckBox_Col
100879>>>>>        tDataSourceRow[] TheData
100879>>>>>        tDataSourceRow[] TheData
100880>>>>>        
100880>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
100881>>>>>        If (hoCheckBox_Col = 0) Begin
100883>>>>>            Procedure_Return
100884>>>>>        End                 
100884>>>>>>
100884>>>>>        
100884>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
100885>>>>>        Get phoDataSource               to hoDataSource
100886>>>>>        Get DataSource of hoDataSource  to TheData
100887>>>>>        Move (SizeOfArray(TheData))     to iSize
100888>>>>>        Decrement iSize
100889>>>>>        For iCount from 0 to iSize
100895>>>>>>
100895>>>>>            Case Begin
100895>>>>>                Case (iState = cx_Select_All)
100897>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
100898>>>>>                    Case Break
100899>>>>>                Case (iState = cx_Select_None)
100902>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
100903>>>>>                    Case Break
100904>>>>>                Case (iState = cx_Select_Invert)
100907>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
100908>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
100909>>>>>                    Case Break
100910>>>>>            Case End
100910>>>>>        Loop
100911>>>>>>
100911>>>>>
100911>>>>>        Send ReInitializeData TheData False
100912>>>>>        Send DoSetCheckboxFooterText
100913>>>>>    End_Procedure
100914>>>>>
100914>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
100914>>>>>    Function SelectedItems Returns String[]
100916>>>>>        Integer iCount iSize iCheckbox_Col iData_Col
100916>>>>>        String[] asDataArray
100917>>>>>        Handle hoDataSource
100917>>>>>        tDataSourceRow[] TheData
100917>>>>>        tDataSourceRow[] TheData
100918>>>>>        Boolean bSelected
100918>>>>>
100918>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
100919>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
100920>>>>>
100920>>>>>        Get phoDataSource to hoDataSource
100921>>>>>        Get DataSource of hoDataSource to TheData
100922>>>>>        Move (SizeOfArray(TheData)) to iSize
100923>>>>>        Decrement iSize
100924>>>>>
100924>>>>>        For iCount from 0 to iSize
100930>>>>>>
100930>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bSelected
100931>>>>>            If (bSelected = True) Begin
100933>>>>>                Move TheData[iCount].sValue[iData_Col] to asDataArray[SizeOfArray(asDataArray)]
100934>>>>>            End
100934>>>>>>
100934>>>>>        Loop
100935>>>>>>
100935>>>>>
100935>>>>>        Function_Return asDataArray
100936>>>>>    End_Function
100937>>>>>
100937>>>>>    // Returns a string array with *all* values for the data column (phoData_Col).
100937>>>>>    Function AllItems Returns tFolderData[]
100939>>>>>        Integer iCount iSize iCheckbox_Col iData_Col iItem
100939>>>>>        tFolderData[] asDataArray
100939>>>>>        tFolderData[] asDataArray
100940>>>>>        Handle hoDataSource
100940>>>>>        tDataSourceRow[] TheData
100940>>>>>        tDataSourceRow[] TheData
100941>>>>>        Boolean bSelected
100941>>>>>
100941>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
100942>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
100943>>>>>
100943>>>>>        Get phoDataSource to hoDataSource
100944>>>>>        Get DataSource of hoDataSource to TheData
100945>>>>>        Move (SizeOfArray(TheData)) to iSize
100946>>>>>        Decrement iSize
100947>>>>>
100947>>>>>        For iCount from 0 to iSize                                
100953>>>>>>
100953>>>>>            Move (SizeOfArray(asDataArray)) to iItem
100954>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bSelected
100955>>>>>            Move bSelected                         to asDataArray[iItem].bSelected
100956>>>>>            Move TheData[iCount].sValue[iData_Col] to asDataArray[iItem].sFolderName
100957>>>>>        Loop
100958>>>>>>
100958>>>>>
100958>>>>>        Function_Return asDataArray
100959>>>>>    End_Function
100960>>>>>
100960>>>>>    Procedure SelectAll
100962>>>>>        Set SelectItems to cx_Select_All
100963>>>>>    End_Procedure
100964>>>>>
100964>>>>>    Procedure SelectNone
100966>>>>>        Set SelectItems to cx_Select_None
100967>>>>>    End_Procedure
100968>>>>>
100968>>>>>    Procedure SelectInvert
100970>>>>>        Set SelectItems to cx_Select_Invert
100971>>>>>    End_Procedure
100972>>>>>
100972>>>>>    // Returns number of items.
100972>>>>>    Function ItemCount Returns Integer
100974>>>>>        Integer iItems
100974>>>>>        Handle hoDataSource
100974>>>>>        tDataSourceRow[] TheData
100974>>>>>        tDataSourceRow[] TheData
100975>>>>>
100975>>>>>        Get phoDataSource to hoDataSource
100976>>>>>        Get DataSource of hoDataSource to TheData
100977>>>>>        Move (SizeOfArray(TheData)) to iItems
100978>>>>>
100978>>>>>        Function_Return iItems
100979>>>>>    End_Function
100980>>>>>
100980>>>>>    // Returns number of checked items.
100980>>>>>    Function CheckedItems Returns Integer
100982>>>>>        Integer iCount iItems iCheckbox_Col iRetval
100982>>>>>        Handle hoDataSource hoCheckbox_Col
100982>>>>>        tDataSourceRow[] TheData
100982>>>>>        tDataSourceRow[] TheData
100983>>>>>        Boolean bChecked
100983>>>>>
100983>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
100984>>>>>        If (hoCheckbox_Col = 0) Begin
100986>>>>>            Procedure_Return
100987>>>>>        End
100987>>>>>>
100987>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
100988>>>>>        Get phoDataSource to hoDataSource
100989>>>>>        Get DataSource of hoDataSource to TheData
100990>>>>>        Move (SizeOfArray(TheData)) to iItems
100991>>>>>        Decrement iItems
100992>>>>>
100992>>>>>        For iCount from 0 to iItems
100998>>>>>>
100998>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
100999>>>>>            If (bChecked = True) Begin
101001>>>>>                Increment iRetval
101002>>>>>            End
101002>>>>>>
101002>>>>>        Loop
101003>>>>>>
101003>>>>>
101003>>>>>        Function_Return iRetval
101004>>>>>    End_Function
101005>>>>>
101005>>>>>    // Toggles the current row on/off (the checkbox)
101005>>>>>    Procedure ToggleCurrentItem
101007>>>>>        Boolean bChecked
101007>>>>>        Integer iCol
101007>>>>>        Handle hoCol hoCheckbox_Col
101007>>>>>
101007>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
101008>>>>>        If (hoCheckbox_Col = 0) Begin
101010>>>>>            Procedure_Return
101011>>>>>        End
101011>>>>>>
101011>>>>>        Get piColumnId of hoCheckbox_Col to iCol
101012>>>>>        Get ColumnObject iCol   to hoCol
101013>>>>>        Get SelectedRowValue    of hoCol to bChecked
101014>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
101015>>>>>        Send Request_Save
101016>>>>>        Send DoSetCheckboxFooterText
101017>>>>>    End_Procedure
101018>>>>>
101018>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
101020>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
101022>>>>>        Send Request_Save
101023>>>>>        Send DoSetCheckboxFooterText
101024>>>>>    End_Procedure
101025>>>>>
101025>>>>>    Procedure DoSetCheckboxFooterText
101027>>>>>        Integer iCol iSelected iItems
101027>>>>>        Handle hoCol hoCheckbox_Col
101027>>>>>
101027>>>>>        If ((phoData_Col(Self) = 0)) Begin
101029>>>>>            Move 1 to iCol
101030>>>>>        End
101030>>>>>>
101030>>>>>        Else Begin
101031>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
101032>>>>>        End
101032>>>>>>
101032>>>>>        Get ItemCount to iItems
101033>>>>>        Get ColumnObject iCol to hoCol
101034>>>>>        Get CheckedItems to iSelected
101035>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
101036>>>>>    End_Procedure
101037>>>>>
101037>>>>>    Procedure DoChangeFontSize
101039>>>>>        Handle hoFont hoPaintManager
101039>>>>>        Variant vFont
101039>>>>>        String sFont sFontSize
101039>>>>>        Boolean bCreated
101039>>>>>        Integer iVal
101039>>>>>
101039>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
101040>>>>>        If (bCreated = False) Begin
101042>>>>>            Procedure_Return
101043>>>>>        End
101043>>>>>>
101043>>>>>
101043>>>>>        Get phoReportPaintManager to hoPaintManager
101044>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
101045>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
101046>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
101047>>>>>
101047>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
101048>>>>>        Set ComSize of hoFont to iVal
101049>>>>>        Send ComRedraw
101050>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
101051>>>>>    End_Procedure
101052>>>>>
101052>>>>>    // Augment to load data to the grid. Is called automatically
101052>>>>>    // from procedure Activating
101052>>>>>    Procedure LoadData
101054>>>>>    End_Procedure
101055>>>>>
101055>>>>>    // Automatically load data into the grid when activating.
101055>>>>>    Procedure Activating
101057>>>>>        Send Cursor_Wait of Cursor_Control
101058>>>>>        Send LoadData                       
101059>>>>>        Send DoChangeFontSize      
101060>>>>>        Send Cursor_Ready of Cursor_Control
101061>>>>>    End_Procedure
101062>>>>>
101062>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
101064>>>>>        Integer iSize jSize kSize iSup iInf iDef
101064>>>>>        Handle hoPaintManager hoFont
101064>>>>>        Variant vFont
101064>>>>>        
101064>>>>>        Move 3 to iInf      //max size
101065>>>>>        Move 18 to iSup     //min size
101066>>>>>        Move 8 to iDef      //default
101067>>>>>        Boolean blimite
101067>>>>>        Get phoReportPaintManager to hoPaintManager
101068>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
101070>>>>>            Procedure_Return
101071>>>>>        End
101071>>>>>>
101071>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
101072>>>>>        Get ComTextFont of hoPaintManager to vFont
101073>>>>>        Set pvComObject of hoFont to vFont
101074>>>>>        If (iDirection = 0) Begin
101076>>>>>            Set ComSize of hoFont to iDef
101077>>>>>        End
101077>>>>>>
101077>>>>>        Else Begin
101078>>>>>           Get ComSize of hoFont to iSize
101079>>>>>           Move iSize to jSize
101080>>>>>           Repeat
101080>>>>>>
101080>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
101081>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
101082>>>>>                If (not(blimite)) Begin       
101084>>>>>                   Set ComSize of hoFont to jSize
101085>>>>>                   Get ComSize of hoFont to kSize
101086>>>>>                End
101086>>>>>>
101086>>>>>            Until (iSize <> kSize or blimite)
101088>>>>>        End
101088>>>>>>
101088>>>>>        Send Destroy to hoFont 
101089>>>>>        Send ComRedraw  
101090>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
101091>>>>>    End_Procedure 
101092>>>>>
101092>>>>>    Procedure Destroy
101094>>>>>        String sHomePath sFolderName sDefaultFolders
101094>>>>>        String[] asNoFolderList asStartFolder asFolderArray asDefaultFolders
101098>>>>>        Handle hoDataSource
101098>>>>>        tDataSourceRow[] TheData
101098>>>>>        tDataSourceRow[] TheData
101099>>>>>        Integer iSize iRow iCount iFolderCol iCheckBoxCol iDefaultFolders iFolder
101099>>>>>        Boolean bChecked bAutoSaveSelections
101099>>>>>
101099>>>>>        Get pbAutoSaveSelections to bAutoSaveSelections
101100>>>>>        If (not(IsComObjectCreated(Self))) Begin
101102>>>>>            Move False to bAutoSaveSelections // Can't save
101103>>>>>        End
101103>>>>>>
101103>>>>>        Get psWorkspaceHomePath of ghoApplication to sHomePath
101104>>>>>        If (sHomePath = "") Begin
101106>>>>>            Move False to bAutoSaveSelections // Can't save
101107>>>>>        End
101107>>>>>>
101107>>>>>            
101107>>>>>        If (bAutoSaveSelections = True) Begin
101109>>>>>            Send Cursor_Wait of Cursor_Control
101110>>>>>            Get phoDataSource to hoDataSource
101111>>>>>            Get DataSource of hoDataSource to TheData
101112>>>>>            Get piColumnId of (phoData_Col(Self))     to iFolderCol
101113>>>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
101114>>>>>            Move (SizeOfArray(TheData)) to iSize
101115>>>>>            Decrement iSize
101116>>>>>            Move 0 to iRow
101117>>>>>
101117>>>>>            For iCount from 0 to iSize
101123>>>>>>
101123>>>>>                Move TheData[iCount].sValue[iFolderCol]   to sFolderName
101124>>>>>                Move TheData[iCount].sValue[iCheckBoxCol] to bChecked
101125>>>>>                If (bChecked = True) Begin
101127>>>>>                    Move sFolderName to asFolderArray[iRow]
101128>>>>>                    Increment iRow
101129>>>>>                End
101129>>>>>>
101129>>>>>            Loop                  
101130>>>>>>
101130>>>>>            If (SizeOfArray(asFolderArray)) Begin
101132>>>>>                
101132>>>>>            End
101132>>>>>>
101132>>>>>            Send Cursor_Ready of Cursor_Control
101133>>>>>        End
101133>>>>>>
101133>>>>>            
101133>>>>>        Forward Send Destroy
101135>>>>>    End_Procedure
101136>>>>>    
101136>>>>>End_Class
101137>>>Use cRDCForm.pkg
101137>>>
101137>>>Enum_List
101137>>>    Define GenerateOK
101137>>>    Define GenerateUserCancel
101137>>>    Define GenerateError
101137>>>    Define GenerateChannelError
101137>>>    Define GenerateUserInputError
101137>>>    Define GenerateOpenTableError
101137>>>End_Enum_List
101137>>>
101137>>>Struct tGeneratorRow
101137>>>    Handle hTable
101137>>>    String sLogicalName
101137>>>    String sRootName
101137>>>    String sDisplayName
101137>>>    Boolean bIsAlias
101137>>>    Boolean bSelected
101137>>>End_Struct
101137>>>
101137>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
101147>>>>
101147>>>Object oTableDUFCodeGenerator is a dbView
101149>>>    Set Size to 328 501
101150>>>    Set Label to "Generator"
101151>>>    Set Border_Style to Border_Thick
101152>>>    Set pbAcceptDropFiles to True
101153>>>    Set pbAutoActivate to True
101154>>>
101154>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
101155>>>
101155>>>    Property String psOrgOpenPath
101157>>>    Property Handle phtable
101159>>>    Property String psTableName
101161>>>    Property Integer piDbVersionFileNumber  -1
101163>>>    Property Integer piDbVersionFieldNumber -1
101165>>>    Property Number pnSourcePackageVersion -1
101167>>>    
101167>>>    // Set psOrgOpenPath at startup
101167>>>    Procedure StartUp
101170>>>        String sOrgOpenPath sDataPath
101170>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
101173>>>        // First remove the current Data folder path
101173>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
101174>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
101175>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
101177>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
101178>>>        End
101178>>>>
101178>>>        Set psOrgOpenPath to sOrgOpenPath
101179>>>    End_Procedure
101180>>>    Send StartUp
101181>>>
101181>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
101183>>>        Set Size to 50 473
101184>>>        Set Location to 8 15
101185>>>        Set pbAcceptDropFiles to True
101186>>>        Set psImage to "FolderLeft1.ico"
101187>>>        Set Label to "Select FROM Filelist.cfg"
101188>>>        Set psNote to "The development/latest version of the database"   
101189>>>        Set psToolTip to "Select the Filelist.cfg for your development database. This is a suggestion form. So if used before - start typing what you're looking for."
101190>>>
101190>>>        Object oFilelistPath_fm is a cRDCSuggestionIniForm
101192>>>            Set Size to 12 424
101193>>>            Set Location to 29 29
101194>>>            Set Label_Col_Offset to 0
101195>>>            Set Label_Row_Offset to 1
101196>>>            Set Label_Justification_Mode to JMode_Top
101197>>>            Set Prompt_Button_Mode to PB_PromptOn
101198>>>            Set peAnchors to anTopLeftRight
101199>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
101200>>>            Set Prompt_Object to Self
101201>>>
101201>>>            Procedure Prompt
101204>>>                String sFileName sPath sFileMask sRetval
101204>>>
101204>>>                Get Value to sFileName
101205>>>                Get ParseFolderName sFileName to sPath
101206>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
101207>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
101208>>>                If (sRetval <> "") Begin
101210>>>                    Set Value to sRetval
101211>>>                End
101211>>>>
101211>>>            End_Procedure
101212>>>
101212>>>            Procedure OnChange
101215>>>                String sFileList
101215>>>                Boolean bOK bExists bCfgFile bHasRecords
101215>>>                Handle hTable
101215>>>                Number nVersionNumber
101215>>>
101215>>>                Move 0 to nVersionNumber
101216>>>                Get Value to sFileList
101217>>>                Get vFilePathExists sFileList to bExists
101218>>>                Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
101219>>>                If (bExists = True and bCfgFile) Begin
101221>>>                    // A little trick to show the filelist.cfg in the form before we start filling the grid.
101221>>>                    Send PumpMsgQueue of Desktop
101222>>>                    Get ChangeFilelistPathing of ghoApplication sFileList to bOK
101223>>>
101223>>>                    If (bOK = True) Begin
101225>>>                        Set psFilelistFrom of ghoApplication to sFileList
101226>>>
101226>>>                        // *** LOAD DATA ***
101226>>>                        Send LoadData to oFilelist_grd
101227>>>
101227>>>                        // It just seem logical to activate the grid after populating it.
101227>>>                        // At this point there is little use of still having the oFilelist_fm active.
101227>>>                        Get HasRecords of oFilelist_grd to bHasRecords
101228>>>                        If (bHasRecords = True) Begin
101230>>>                            Send Activate of oFilelist_grd
101231>>>                        End
101231>>>>
101231>>>
101231>>>                        If (bExists = True) Begin
101233>>>                            Get phDbVersion of oFilelist_grd to hTable
101234>>>                            If (hTable <> 0) Begin
101236>>>                                Open hTable
101238>>>                                Get_Field_Value hTable 1   to nVersionNumber 
101241>>>                                // ToDo: How to handle this if not the standard "DbVersion" table is used?
101241>>>                                Set pnSourcePackageVersion to nVersionNumber
101242>>>                                Set piDbVersionFileNumber  to hTable
101243>>>                                Set piDbVersionFieldNumber to 1
101244>>>                                Close hTable
101245>>>                            End
101245>>>>
101245>>>                        End
101245>>>>
101245>>>                        If (nVersionNumber = 0) Begin
101247>>>                            Move 1.0 to nVersionNumber
101248>>>                        End   
101248>>>>
101248>>>                        Else Begin
101249>>>                            Move (nVersionNumber + .1) to nVersionNumber
101250>>>                        End
101250>>>>
101250>>>                        Set Value of oPnVersionNumber_fm to nVersionNumber
101251>>>                    End
101251>>>>
101251>>>                End
101251>>>>
101251>>>            End_Procedure
101252>>>
101252>>>            Function Window_Handle Returns Handle
101255>>>                Integer rVal
101255>>>                Get Window_Handle of (Parent(Self)) to rVal
101256>>>                Function_Return rVal
101257>>>            End_Function
101258>>>
101258>>>            Function Next_Object_Id Boolean bNoDescend Returns Integer
101261>>>                Function_Return (oFilelist_grd(Self))
101262>>>            End_Function
101263>>>
101263>>>            On_Key Key_Ctrl+Key_W Send None
101264>>>            On_Key Key_Ctrl+Key_Q Send None
101265>>>        End_Object
101266>>>
101266>>>    End_Object
101267>>>
101267>>>    Object oSelectTables_grp is a cRDCHeaderGroup
101269>>>        Set Size to 92 473
101270>>>        Set Location to 69 15
101271>>>        Set peAnchors to anAll
101272>>>        Set psImage to "SelectTables1.ico"
101273>>>        Set psLabel to "Select Tables"
101274>>>        Set psNote to "Right click grid for options"  
101275>>>        Set psToolTip to "Select one or more tables to generate 'DUF' database update code for. (Ctrl+A = 'Select All Tables'. Right-click grid for selection options."
101276>>>
101276>>>        Object oFilelist_grd is a cRDCCJSelectionGrid
101278>>>            Set Size to 56 423
101279>>>            Set Location to 27 29
101280>>>            Set piLayoutBuild to 6
101281>>>            Set Status_Help to "Select with the spacebar, or use the selection buttons above the grid"
101282>>>
101282>>>            Property Handle phDbVersion
101284>>>            Property Integer piCurrentRow -1
101286>>>
101286>>>            Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
101288>>>                Set piWidth to 26
101289>>>            End_Object
101290>>>                         
101290>>>            Object oFilelistNumber_col is a cCJGridColumn
101292>>>                Set piWidth to 74
101293>>>                Set psCaption to "Filelist No"
101294>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101295>>>                Set peDataType to Mask_Numeric_Window
101296>>>                Set pbEditable to False
101297>>>                Set peTextAlignment to xtpAlignmentCenter
101298>>>            End_Object
101299>>>
101299>>>            Object oLogicalName_col is a cCJGridColumn
101301>>>                Set piWidth to 121
101302>>>                Set psCaption to "Logical Name"
101303>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101304>>>                Set pbEditable to False
101305>>>                Set psFooterText to "No of Tables:"
101306>>>            End_Object
101307>>>
101307>>>            Object oRootName_col is a cCJGridColumn
101309>>>                // NOTE: This must be set at one of the columns!
101309>>>                Set phoData_Col to Self
101310>>>                Set piWidth to 191
101311>>>                Set psCaption to "Table Name (Rootname)"
101312>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101313>>>                Set pbEditable to False
101314>>>                Set psFooterText to "Selected:"
101315>>>            End_Object
101316>>>
101316>>>            Object oDisplayName_col is a cCJGridColumn
101318>>>                Set piWidth to 267
101319>>>                Set psCaption to "Display Name"
101320>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101321>>>                Set pbEditable to False
101322>>>            End_Object
101323>>>
101323>>>            Object oIsAlias_Col is a cCJGridColumn
101325>>>                Set piWidth to 85
101326>>>                Set psCaption to "Is Alias"
101327>>>                Set pbCheckbox to True
101328>>>                Set peHeaderAlignment to xtpAlignmentCenter
101329>>>                Set peFooterAlignment to xtpAlignmentCenter
101330>>>                Set pbVDFEditControl to False
101331>>>                Set psToolTip to "Is table an alias table? (Read-Only)"
101332>>>                Set psFooterText to "Alias:"
101333>>>            End_Object
101334>>>
101334>>>            Procedure LoadData
101337>>>                String sFileList sLogicalName
101337>>>                Handle hoDataSource hTable
101337>>>                tDataSourceRow[] TheData TheDataEmpty
101337>>>                tDataSourceRow[] TheData TheDataEmpty
101339>>>                Integer iRow iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
101339>>>                Boolean bExists bIsAlias bUserCancel
101339>>>
101339>>>                Get Value of oFilelistPath_fm to sFilelist
101340>>>                Get vFilePathExists sFileList to bExists
101341>>>                If (bExists = False) Begin
101343>>>                    Procedure_Return
101344>>>                End
101344>>>>
101344>>>
101344>>>                Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
101345>>>                Send Start_StatusPanel of ghoStatusPanel
101346>>>                Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
101347>>>                Set pbVisible of ghoProgressBar to True
101348>>>                Set pbVisible of ghoProgressBarOverall to False
101349>>>                Set piMaximum of ghoProgressBar to iNoOfTables
101350>>>                Move 0 to iCount
101351>>>                Get phoDataSource to hoDataSource
101352>>>                Get DataSource of hoDataSource to TheData
101353>>>                Move TheDataEmpty to TheData
101354>>>                Get piColumnId of oFilelistNumber_col to iTableNo
101355>>>                Get piColumnId of oRootName_col       to iRoot
101356>>>                Get piColumnid of oLogicalName_col    to iLogical
101357>>>                Get piColumnId of oDisplayName_col    to iDisplay
101358>>>                Get piColumnId of oIsAlias_Col        to iIsAlias
101359>>>                Get piColumnId of oCheckbox_Col       to iChecked
101360>>>
101360>>>                Move 0 to hTable
101361>>>                Move 0 to iRow
101362>>>                Repeat
101362>>>>
101362>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101365>>>                    Set piPosition of ghoProgressBar to iCount
101366>>>
101366>>>                    If (hTable > 0 and hTable <> 50) Begin
101368>>>                        Move hTable                                   to TheData[iRow].sValue[iTableNo]
101369>>>                        Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
101372>>>                        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
101375>>>                        Move sLogicalName                             to TheData[iRow].sValue[iLogical]
101376>>>                        If (Uppercase(sLogicalName) = "DBVERSION") Begin
101378>>>                            Set phDbVersion to hTable
101379>>>                        End
101379>>>>
101379>>>                        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
101382>>>                        Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
101383>>>                        Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias]
101384>>>                        If (bIsAlias = True) Begin
101386>>>                            Increment iAliasCount
101387>>>                        End
101387>>>>
101387>>>                        Move False to TheData[iRow].sValue[iChecked]
101388>>>                        Increment iRow
101389>>>                    End
101389>>>>
101389>>>                    Increment iCount
101390>>>                    Get Check_StatusPanel of ghoStatusPanel to bUserCancel
101391>>>                    If (bUserCancel = True) Begin
101393>>>                        Move TheDataEmpty to TheData
101394>>>                        Move 0 to iRow
101395>>>                        Move 0 to iAliasCount
101396>>>                        Move 0 to hTable
101397>>>                    End
101397>>>>
101397>>>                Until (hTable = 0)
101399>>>                                    
101399>>>                Send InitializeData TheData
101400>>>                Set psFooterText of oLogicalName_col to ("No of Tables:" * String(iRow))
101401>>>                Set psFooterText of oIsAlias_Col     to ("Alias:" * String(iAliasCount))
101402>>>                Send Stop_StatusPanel of ghoStatusPanel
101403>>>            End_Procedure
101404>>>
101404>>>            Function SelectedTableNumber Returns Handle
101407>>>                Integer hTable iTableNo iRowNo
101407>>>                Handle hoDataSource
101407>>>                tDataSourceRow[] TheData
101407>>>                tDataSourceRow[] TheData
101408>>>
101408>>>                Get phoDataSource to hoDataSource
101409>>>                Get piColumnId of oFilelistNumber_col to iTableNo
101410>>>                Get DataSource of hoDataSource to TheData
101411>>>                Get SelectedRow of hoDataSource to iRowNo
101412>>>                Move TheData[iRowNo].sValue[iTableNo] to hTable
101413>>>
101413>>>                Function_Return hTable
101414>>>            End_Function
101415>>>
101415>>>            Function GenerateSourceFileName Returns String
101418>>>                String sRetval sPath sFileListName sTableName sVersionNumber
101418>>>                Boolean bExists
101418>>>                Integer iLogical iRowNo iSelected iPos
101418>>>                tDataSourceRow[] TheData
101418>>>                tDataSourceRow[] TheData
101419>>>                Handle hoDataSource
101419>>>                Number nVersionNumber
101419>>>
101419>>>                Get Value of oFilelistPath_fm to sFileListName
101420>>>                Get vFilePathExists sFileListName to bExists
101421>>>                If (bExists = False) Begin
101423>>>                    Function_Return ""
101424>>>                End
101424>>>>
101424>>>
101424>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101427>>>                Get Value of oPnVersionNumber_fm to sVersionNumber
101428>>>//                Move nVersionNumber to sVersionNumber
101428>>>                Move (Pos(".", sVersionNumber)) to iPos
101429>>>                If (iPos = 0) Begin
101431>>>                    Move (sVersionNumber + String(".0")) to sVersionNumber
101432>>>                End
101432>>>>
101432>>>                Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
101433>>>                Move (Replaces(",", sVersionNumber, "_")) to sVersionNumber
101434>>>
101434>>>                Get ParseFolderName sFileListName to sPath
101435>>>                Get vParentPath sPath   to sPath
101436>>>                Get vFolderFormat sPath to sPath
101437>>>                Move (sPath + "AppSrc") to sPath
101438>>>                Get vFolderFormat sPath to sPath
101439>>>
101439>>>                Get phoDataSource to hoDataSource
101440>>>                Get piColumnid of oLogicalName_col to iLogical
101441>>>                Get DataSource of hoDataSource to TheData
101442>>>                Get CheckedItems to iSelected
101443>>>                If (iSelected > 1) Begin
101445>>>                    Move "MultipleTables" to sTableName
101446>>>                End
101446>>>>
101446>>>                Else Begin
101447>>>                    If (SizeOfArray(TheData) <> 0) Begin
101449>>>                        Get SelectedRow of hoDataSource to iRowNo
101450>>>                        Move TheData[iRowNo].sValue[iLogical] to sTableName
101451>>>                    End
101451>>>>
101451>>>                End
101451>>>>
101451>>>                Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
101452>>>
101452>>>                Move (sPath + sTableName) to sRetval
101453>>>
101453>>>                Function_Return sRetval
101454>>>            End_Function
101455>>>
101455>>>            Function piCheckboxCol Returns Integer
101458>>>                Integer iIndex
101458>>>                Get piColumnId of oCheckbox_Col to iIndex
101459>>>                Function_Return iIndex
101460>>>            End_Function
101461>>>
101461>>>            // Returns a string array with the selected items.
101461>>>            Function SelectedItems Returns tGeneratorRow[]
101464>>>                Integer[] SelRows
101465>>>                Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
101465>>>                String sFileName
101465>>>                String[] sFilesArray
101466>>>                Handle hoDataSource
101466>>>                tDataSourceRow[] TheData
101466>>>                tDataSourceRow[] TheData
101467>>>                Boolean bChecked bIsAlias
101467>>>                tGeneratorRow[] GeneratorRowArray
101467>>>                tGeneratorRow[] GeneratorRowArray
101468>>>
101468>>>                Get piColumnId of oFilelistNumber_col to iFilelistNo_Col
101469>>>                Get piColumnId of oLogicalName_col    to iLogical_Col
101470>>>                Get piColumnId of oRootName_col       to iRoot_Col
101471>>>                Get piColumnId of oDisplayName_col    to iDisplay_Col
101472>>>                Get piColumnId of oIsAlias_Col        to iIsAlias_Col
101473>>>                Get piColumnId of oCheckbox_Col       to iCheckbox_Col
101474>>>
101474>>>                Get phoDataSource to hoDataSource
101475>>>                Get DataSource of hoDataSource to TheData
101476>>>                Move (SizeOfArray(TheData)) to iItems
101477>>>                Decrement iItems
101478>>>
101478>>>                For i from 0 to iItems
101484>>>>
101484>>>                    Move TheData[i].sValue[iCheckbox_Col] to bChecked
101485>>>                    If (bChecked = True) Begin
101487>>>                        Move (SizeOfArray(GeneratorRowArray)) to iSize
101488>>>                        Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
101489>>>                        Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
101490>>>                        Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
101491>>>                        Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName
101492>>>                        Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
101493>>>                        Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
101494>>>                        Move sFileName to sFilesArray[iSize]
101495>>>                    End
101495>>>>
101495>>>                Loop
101496>>>>
101496>>>
101496>>>                Function_Return GeneratorRowArray
101497>>>            End_Function
101498>>>
101498>>>            Procedure Request_Clear
101501>>>                Delegate Send Request_Clear
101503>>>            End_Procedure   
101504>>>            
101504>>>            Function HasRecords Returns Boolean
101507>>>                Handle hoDataSource
101507>>>                tDataSourceRow[] TheData
101507>>>                tDataSourceRow[] TheData
101508>>>                Integer iItems
101508>>>
101508>>>                Get phoDataSource to hoDataSource
101509>>>                Get DataSource of hoDataSource to TheData
101510>>>                Move (SizeOfArray(TheData)) to iItems
101511>>>                Function_Return (iItems <> 0)
101512>>>            End_Function
101513>>>
101513>>>            Procedure Set SelectItems Integer iState
101516>>>                String sSourceFile
101516>>>
101516>>>                Forward Set SelectItems to iState
101518>>>                Get GenerateSourceFileName  to sSourceFile
101519>>>                Set Value of oSourceName_fm to sSourceFile
101520>>>            End_Procedure     
101521>>>            
101521>>>            Procedure ToggleCurrentItem 
101524>>>                String sSourceFile
101524>>>
101524>>>                Forward Send ToggleCurrentItem
101526>>>                Get GenerateSourceFileName  to sSourceFile
101527>>>                Set Value of oSourceName_fm to sSourceFile
101528>>>                
101528>>>            End_Procedure
101529>>>
101529>>>        End_Object
101530>>>
101530>>>        // Needed to not close the view when Esc is hit in the grid.
101530>>>        On_Key kCancel Send None
101531>>>    End_Object
101532>>>
101532>>>    Object oConfigureGeneration_grp is a cRDCHeaderGroup
101534>>>        Set Size to 48 473
101535>>>        Set Location to 172 15
101536>>>        Set peAnchors to anBottomLeftRight
101537>>>        Set psLabel to "Configure Code Generation"
101538>>>        Set psImage to "Settings1.ico"   
101539>>>        Set psToolTip to "Select how code is generated. If you are not sure what the flags does, leave the default settings."
101540>>>        
101540>>>        Object oUseConnectionID_cb is a cSQLCheckBox
101542>>>            Set Size to 9 78
101543>>>            Set Location to 19 30
101544>>>            Set Label to "Use Connection ID"
101545>>>            Set Checked_State to True
101546>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
101547>>>        End_Object
101548>>>
101548>>>        Object oANSI_cb is a cSQLCheckBox
101550>>>            Set Size to 9 49
101551>>>            Set Location to 19 136
101552>>>            Set Label to "ANSI/OEM"
101553>>>            Set Checked_State to True  
101554>>>            Set psToolTip to "Set property 'pbToANSI' True/False. DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
101555>>>        End_Object
101556>>>
101556>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
101558>>>            Set Size to 9 93
101559>>>            Set Location to 19 200
101560>>>            Set Label to "Change Asc/Descending"
101561>>>            Set Checked_State to False
101562>>>            Set psToolTip to "Set property 'pbCompareIndexAscending' True/False. Check if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so with SQL checking this per table doesn't make sense)"
101563>>>        End_Object
101564>>>
101564>>>        Object oApiTableUpdateAuto_cb is a cSQLCheckBox
101566>>>            Set Size to 9 137
101567>>>            Set Location to 19 316
101568>>>            Set Label to "Auto Update Table to SQL"
101569>>>            Set Checked_State to True
101570>>>            Set psToolTip to "Set property 'pbApiTableUpdateAuto' True/False. When set to True, 'TO' tables will get converted to the same database format as the 'FROM' tables. So if a 'FROM' table is an SQL table and the 'TO' table is in the embedded format (DataFlex table), it will be converted to SQL."
101571>>>        End_Object
101572>>>
101572>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
101574>>>            Set Size to 9 91
101575>>>            Set Location to 32 30
101576>>>            Set Label to "Change Date/DataTime"
101577>>>            Set Checked_State to False
101578>>>            Set psToolTip to "Set property 'pbCompareDate_DateTime' True/False. Check if there are Date/DateTime column differences. Tick the box if the framework should create code to change e.g. a 'To' DateTime column to a Date column if the 'FROM' table column is defined as Date. Be careful as you might loose data!"
101579>>>        End_Object
101580>>>
101580>>>        Object oRecnum_cb is a cSQLCheckBox
101582>>>            Set Size to 9 57
101583>>>            Set Location to 32 136
101584>>>            Set Label to "Use Recnum"
101585>>>            Set Checked_State to True
101586>>>            Set psToolTip to "Set property 'pbRecnum' True/False. If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
101587>>>        End_Object
101588>>>
101588>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
101590>>>            Set Size to 9 98
101591>>>            Set Location to 32 200
101592>>>            Set Label to "Change Upper/Lowercase"
101593>>>            Set Checked_State to False
101594>>>            Set psToolTip to "Set property 'pbCompareIndexUppercase' True/False. Check if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
101595>>>        End_Object
101596>>>
101596>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
101598>>>            Set Size to 9 142
101599>>>            Set Location to 32 316
101600>>>            Set Label to "Change Upper/Lowercase Table Names"
101601>>>            Set Checked_State to True
101602>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
101603>>>        End_Object
101604>>>
101604>>>        Procedure ToggleCurrentItem
101607>>>            Boolean bChecked
101607>>>            Handle hObject
101607>>>
101607>>>            Get Focus to hObject
101608>>>            Get Checked_State of hObject to bChecked
101609>>>            Set Checked_State of hObject to (not(bChecked))
101610>>>        End_Procedure
101611>>>
101611>>>    End_Object
101612>>>
101612>>>    Object oGenerateFilename_grp is a cRDCHeaderGroup
101614>>>        Set Size to 39 473
101615>>>        Set Location to 232 15
101616>>>        Set peAnchors to anBottomLeftRight
101617>>>        Set psImage to "ActionSaveCode1.ico"
101618>>>        Set psLabel to "Generated Package File Name"  
101619>>>        Set psToolTip to "A suggestion for the package file to be generated is shown. It can be changed if needed, but you are not encouraged to do so."
101620>>>
101620>>>        Object oPnVersionNumber_fm is a cRDCForm
101622>>>            Set Size to 12 22
101623>>>            Set Location to 17 108
101624>>>            Set Label to "Next pnVersionNumber"
101625>>>            Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
101626>>>            Set peAnchors to anBottomLeft
101627>>>            Set Label_Justification_Mode to JMode_Right
101628>>>            Set Label_Col_Offset to 2
101629>>>            Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101632>>>            Set Form_Datatype to 2
101633>>>            Set Value to 1.0
101634>>>
101634>>>            Procedure OnChange
101637>>>                String sSourceFile
101637>>>                Number nVersionNumber 
101637>>>                Integer iDecimalSeparator                     
101637>>>                
101637>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101640>>>                Get Value to nVersionNumber
101641>>>//                If (nVersionNumber < 1) Begin
101641>>>//                    Move 1 to nVersionNumber   
101641>>>//                    Set Value to nVersionNumber     
101641>>>//                End
101641>>>                Set pnSourcePackageVersion to nVersionNumber
101642>>>                Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
101643>>>                Set Value of oSourceName_fm to sSourceFile
101644>>>            End_Procedure
101645>>>
101645>>>        End_Object
101646>>>
101646>>>        Object oSourceName_fm is a cRDCForm
101648>>>            Set Size to 12 315
101649>>>            Set Location to 17 134
101650>>>            Set peAnchors to anBottomLeftRight
101651>>>            Set Label_Col_Offset to 0
101652>>>            Set Label_Justification_Mode to JMode_Top
101653>>>            Set Label_Row_Offset to 1
101654>>>            Set psToolTip to "The name of the output file to be generated. The suggested name can be changed if needed."
101655>>>        End_Object
101656>>>
101656>>>    End_Object
101657>>>
101657>>>    Object oBusinessProcess is a BusinessProcess
101659>>>        Set Status_Panel_Id to ghoStatusPanel
101660>>>        Set Allow_Cancel_State to True
101661>>>        Set Process_Caption to "The Database Update Framework"
101662>>>        Set Process_Title to "Generating Database Update Code..."
101663>>>        Set Process_Message to "For table:"
101664>>>
101664>>>        Procedure OnProcess
101667>>>            Send StartGenerateCode
101668>>>        End_Procedure
101669>>>
101669>>>        Procedure Ignore_Error Integer iError
101672>>>        End_Procedure
101673>>>        Procedure Trap_Error Integer iError
101676>>>        End_Procedure
101677>>>
101677>>>    End_Object
101678>>>
101678>>>    Object oGenerateCode_btn is a cRDCCommandLinkButton
101680>>>        Set Size to 36 166
101681>>>        Set Location to 281 63
101682>>>        Set Label to "Generate Code!"
101683>>>        Set psNote to "Create DUF update package for the selected tables."
101684>>>        Set psToolTip to "Start generating DUF code for all selected tables."
101685>>>        Set psImage to "SqlScript1.ico"    
101686>>>        Set Default_State to True
101687>>>        Set MultiLineState to True
101688>>>        Set piImageSize to 32 
101689>>>        Set pbAutoEnable to True
101690>>>        Set peAnchors to anBottomRight
101691>>>
101691>>>        Procedure OnClick
101694>>>            Boolean bExists
101694>>>            String sSourceFile sPath
101694>>>            Integer iSelected iRetval
101694>>>
101694>>>            Get Value of oSourceName_fm to sSourceFile
101695>>>            Get vFilePathExists sSourceFile to bExists
101696>>>            If (bExists = True) Begin
101698>>>                Get YesNo_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nDo you want to overwrite it?") to iRetval
101699>>>                If (iRetval <> MBR_Yes) Begin
101701>>>                    Procedure_Return
101702>>>                End
101702>>>>
101702>>>            End                     
101702>>>>
101702>>>            
101702>>>            Get ExtractFilePath sSourceFile to sPath
101703>>>            Get vFilePathExists sPath       to bExists
101704>>>            If (bExists = False) Begin
101706>>>                Send Info_Box "Please check the source file path and try again. It doesn't exist!"
101707>>>                Procedure_Return
101708>>>            End
101708>>>>
101708>>>
101708>>>            Get CheckedItems  of oFilelist_grd to iSelected
101709>>>            If (iSelected = 0) Begin
101711>>>                Send Info_Box "No tables selected. Please adjust and try again."
101712>>>                Procedure_Return
101713>>>            End
101713>>>>
101713>>>
101713>>>            Send DoProcess of oBusinessProcess
101714>>>            Send Restore_DF_OPEN_PATH of ghoApplication
101715>>>        End_Procedure
101716>>>
101716>>>        Function IsEnabled Returns Boolean
101719>>>            Integer iSelected 
101719>>>            Get CheckedItems  of oFilelist_grd to iSelected
101720>>>            Function_Return (iSelected <> 0)
101721>>>        End_Function
101722>>>            
101722>>>    End_Object
101723>>>
101723>>>    Object oGenerateInternalUpdatetProgram_btn is a cRDCCommandLinkButton
101725>>>        Set Size to 36 77
101726>>>        Set Location to 281 239
101727>>>        Set Label to "Local"
101728>>>        Set psNote to "Create local helper program"
101729>>>        Set peAnchors to anBottomRight
101730>>>        Set psToolTip to "Generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database."
101731>>>        Set psImage to "SqlScript1.ico"    
101732>>>        Set piImageSize to 16 // 24
101733>>>        Set pbAutoEnable to True
101734>>>        
101734>>>        Procedure OnClick
101737>>>            Integer iRetval
101737>>>            String sText
101737>>>        
101737>>>            Move "This generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database. Continue?" to sText
101738>>>            Get YesNo_Box sText to iRetval
101739>>>            If (iRetval = MBR_Yes) Begin
101741>>>                Send GenerateInternalUpdateProgram
101742>>>            End
101742>>>>
101742>>>        End_Procedure
101743>>>        
101743>>>        Procedure GenerateInternalUpdateProgram
101746>>>            String sPath sSourcePackageName
101746>>>            Integer iDbVersionFileNumber iDbVersionFieldNumber
101746>>>            Number nSourcePackageVersion
101746>>>            Boolean bOK 
101746>>>            
101746>>>            Get piDbVersionFileNumber   to iDbVersionFileNumber
101747>>>            Get piDbVersionFieldNumber  to iDbVersionFieldNumber
101748>>>            Get pnSourcePackageVersion  to nSourcePackageVersion
101749>>>            
101749>>>            Get Value of oSourceName_fm to sSourcePackageName
101750>>>            Get ParseFolderName sSourcePackageName to sPath
101751>>>            Get ParseFileName sSourcePackageName to sSourcePackageName
101752>>>                        
101752>>>            Get WriteTestProgram sSourcePackageName sPath nSourcePackageVersion iDbVersionFileNumber iDbVersionFieldNumber to bOK
101753>>>            If (bOK = True) Begin
101755>>>                Send Info_Box ("Success! The source program" * CS_DUFTestProgram * "was created in:" * sPath)        
101756>>>            End 
101756>>>>
101756>>>            Else Begin
101757>>>                Send Info_Box "The creation of the source program failed..."
101758>>>            End
101758>>>>
101758>>>        End_Procedure
101759>>>        
101759>>>        Function IsEnabled Returns Boolean
101762>>>            String sPath sSourceName
101762>>>            Boolean bExists
101762>>>            Integer iSelected 
101762>>>
101762>>>            Get CheckedItems of oFilelist_grd to iSelected
101763>>>            Get Value of oSourceName_fm to sSourceName
101764>>>            Get ParseFolderName sSourceName to sPath
101765>>>            Get vFolderExists sPath to bExists
101766>>>            Function_Return (iSelected <> 0 and bExists = True)
101767>>>        End_Function
101768>>>
101768>>>    End_Object
101769>>>
101769>>>    Object oViewSoureCode_btn is a cRDCCommandLinkButton
101771>>>        Set Size to 36 76
101772>>>        Set Location to 281 326
101773>>>        Set Label to "View"
101774>>>        Set psNote to "View source code"
101775>>>        Set peAnchors to anBottomRight
101776>>>        Set psToolTip to "Open the source file in the editor"
101777>>>        Set MultiLineState to True
101778>>>        Set psImage to "ViewSourceCode1.ico" 
101779>>>        Set piImageSize to 16 
101780>>>        Set pbAutoEnable to True
101781>>>
101781>>>        Procedure OnClick
101784>>>            String sSourceName
101784>>>            
101784>>>            Get Value of oSourceName_fm to sSourceName
101785>>>            Send ActivateSourceCodeDialog sSourceName
101786>>>        End_Procedure
101787>>>
101787>>>        Function IsEnabled Returns Boolean
101790>>>            String sSourceName
101790>>>            Boolean bExists
101790>>>
101790>>>            Get Value of oSourceName_fm to sSourceName
101791>>>            Get vFilePathExists sSourceName to bExists
101792>>>            Function_Return (bExists = True)
101793>>>        End_Function
101794>>>
101794>>>    End_Object
101795>>>
101795>>>    Object oOpenAppSrcFolder_btn is a cRDCCommandLinkButton
101797>>>        Set Size to 36 76
101798>>>        Set Location to 281 413
101799>>>        Set Label to "F&older"
101800>>>        Set psNote to "Open containing folder"
101801>>>        Set peAnchors to anBottomRight
101802>>>        Set psToolTip to "Open the source location in Windows Explorer"
101803>>>        Set MultiLineState to True
101804>>>        Set psImage to "ActionOpenFolder1.ico" 
101805>>>        Set piImageSize to 16 // 24
101806>>>        Set pbAutoEnable to True
101807>>>
101807>>>        Procedure OnClick
101810>>>            String sPath sSourceName sFile  
101810>>>            Boolean bExists
101810>>>            
101810>>>            Get Value of oSourceName_fm to sSourceName
101811>>>            Get vFilePathExists sSourceName to bExists
101812>>>            Get ParseFolderName sSourceName to sPath
101813>>>            Get ParseFileName sSourceName to sFile
101814>>>            // We want to have that file to be selected in Windows Explorer when it opens
101814>>>            If (bExists = True) Begin
101816>>>                Move ("/select, " + '"' + sSourceName + '"') to sSourceName
101817>>>            End
101817>>>>
101817>>>            Runprogram Shell Background "Explorer.exe" sSourceName
101818>>>        End_Procedure
101819>>>
101819>>>        Function IsEnabled Returns Boolean
101822>>>            String sPath sSourceName
101822>>>            Boolean bExists
101822>>>
101822>>>            Get Value of oSourceName_fm to sSourceName
101823>>>            Get ParseFolderName sSourceName to sPath
101824>>>            Get vFolderExists sPath to bExists
101825>>>            Function_Return (bExists = True)
101826>>>        End_Function
101827>>>
101827>>>    End_Object
101828>>>
101828>>>    Procedure StartGenerateCode
101831>>>        String sSourceFile
101831>>>        Boolean bUseConnectionID bANSI bRecnum bCompareIndexUppercase bCompareIndexAscending
101831>>>        Handle hTable
101831>>>        Integer iErrors
101831>>>        Number nVersionNumber
101831>>>        tGeneratorRow[] TheData
101831>>>        tGeneratorRow[] TheData
101832>>>        tAPITableBooleans CompareTableBooleans
101832>>>        tAPITableBooleans CompareTableBooleans
101832>>>
101832>>>        Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101835>>>        Get Value of oSourceName_fm                      to sSourceFile
101836>>>        Get Checked_State of oUseConnectionID_cb         to bUseConnectionID
101837>>>        Get Checked_State of oANSI_cb                    to bANSI
101838>>>        Get Checked_State of oRecnum_cb                  to bRecnum
101839>>>        Get Checked_State of oApiTableUpdateAuto_cb      to CompareTableBooleans.bApiTableUpdateAuto
101840>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
101841>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
101842>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
101843>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
101844>>>
101844>>>        Get SelectedItems of oFilelist_grd to TheData
101845>>>        Get pnSourcePackageVersion to nVersionNumber
101846>>>        Get GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans to iErrors
101847>>>
101847>>>        If (iErrors = GenerateChannelError) Begin
101849>>>            Send Info_Box "Sorry, couldn't retrieve a free channel number. Process halted."
101850>>>        End
101850>>>>
101850>>>        If (iErrors = GenerateUserInputError) Begin
101852>>>            Send Info_Box "Table number and pnVersionNumber both needs to be > 0. Please adjust and try again."
101853>>>        End
101853>>>>
101853>>>
101853>>>        Send Stop_StatusPanel of ghoStatusPanel
101854>>>        If (iErrors = GenerateOK) Begin
101856>>>            Send Info_Box "Ready!"
101857>>>        End
101857>>>>
101857>>>        If (iErrors = GenerateError) Begin
101859>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see those fields.")
101860>>>        End
101860>>>>
101860>>>        If (iErrors = GenerateOpenTableError) Begin
101862>>>            Send Info_Box ("Sorry, couldn't open the table! (Table No:" * String(phTable(Self)) * String(psFileName(Self)) + ") Process halted.")
101863>>>        End
101863>>>>
101863>>>        If (iErrors = GenerateUserCancel) Begin
101865>>>            Send Info_Box "Process cancelled by user."
101866>>>        End
101866>>>>
101866>>>    End_Procedure
101867>>>
101867>>>    Function GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans Returns Integer
101870>>>        Boolean bApiTableUpdateAuto bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
101870>>>        Integer iCh iColumn iLength iPrecision iOptions iCount iSize iTable iTables
101870>>>        Integer iIndex iIndexes iSegment iNumSegments iType iErrors iStatus
101870>>>        Boolean bOpened bOK bDawSqlDriver bIsAlias bSqlDriver bSkipTable
101870>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sDataType sDriverID
101870>>>        Handle hTable
101870>>>        tAPITableNameInfo  APITableNameInfo
101870>>>        tAPITableNameInfo  APITableNameInfo
101870>>>        tAPIColumn[]   APIColumns
101870>>>        tAPIColumn[]   APIColumns
101871>>>        tAPIRelation[] APIRelations
101871>>>        tAPIRelation[] APIRelations
101872>>>        tAPIIndex[]    APIIndexes
101872>>>        tAPIIndex[]    APIIndexes
101873>>>        DateTime dtCreationTime
101873>>>
101873>>>        Move (CurrentDateTime()) to dtCreationTime
101874>>>        Move 0 to iErrors
101875>>>        Move (SizeOfArray(TheData)) to iTables
101876>>>        Decrement iTables
101877>>>        Move 0 to iTable
101878>>>        Move TheData[iTable].hTable to hTable
101879>>>
101879>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
101880>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
101882>>>            Function_Return GenerateChannelError
101883>>>        End
101883>>>>
101883>>>
101883>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
101885>>>            Function_Return GenerateUserInputError
101886>>>        End
101886>>>>
101886>>>
101886>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
101887>>>        Send Start_StatusPanel of ghoStatusPanel
101888>>>        Set pbVisible of ghoProgressBar to True
101889>>>        Set pbVisible of ghoProgressBarOverall to True
101890>>>        Set piMaximum of ghoProgressBarOverall to iTables
101891>>>        
101891>>>        Move CompareTableBooleans.bApiTableUpdateAuto       to bApiTableUpdateAuto
101892>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
101893>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
101894>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
101895>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
101896>>>
101896>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
101897>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
101900>>>        If (bOpened = False) Begin
101902>>>            Send Seq_Close_Channel iCh
101903>>>            Set phTable to hTable
101904>>>            Set psFileName to TheData[iTable].sLogicalName
101905>>>            Function_Return GenerateOpenTableError
101906>>>        End
101906>>>>
101906>>>
101906>>>        Writeln channel iCh "/" "/ " CS_DatabaseUpdateFramework
101911>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
101914>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
101917>>>        Writeln channel iCh
101919>>>        Writeln channel iCh ("Object oDbUpdateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
101922>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
101925>>>        Writeln channel iCh ("    Procedure OnUpdate")
101928>>>        Writeln channel iCh ("        Boolean bOK")
101931>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
101934>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
101937>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
101940>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
101943>>>        Writeln channel iCh ("        Integer iCount iSegment")
101946>>>        Writeln channel iCh ("        Handle hTable")
101949>>>        Writeln channel iCh
101951>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
101954>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False"))
101957>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
101960>>>        Writeln channel iCh ("        Set pbApiTableUpdateAuto    to" * If(bApiTableUpdateAuto, "True", "False"))
101963>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
101966>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
101969>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
101972>>>        Writeln channel iCh
101974>>>        Writeln channel iCh ("        Set Allow_Cancel_State of ghoStatusPanel  to False")
101977>>>        Writeln channel iCh ("        Set pbVisible    of ghoProgressBarOverall to True")
101980>>>        Writeln channel iCh ("        Set piPosition   of ghoProgressBarOverall to 0")
101983>>>        Writeln channel iCh ("        Set piMaximum    of ghoProgressBarOverall to" * String(iTables))
101986>>>        Writeln channel iCh ("        Set piAdvanceBy  of ghoProgressBarOverall to 1")
101989>>>        Writeln channel iCh ("        Send DoAdvance   of ghoProgressBarOverall")   
101992>>>        Writeln channel iCh ("        Move 0 to iCount")
101995>>>        Writeln channel iCh
101997>>>
101997>>>        // Create Definitions:
101997>>>        Move 0 to iTable
101998>>>        For iTable from 0 to iTables
102004>>>>
102004>>>            Set piPosition of ghoProgressBarOverall to iTable
102005>>>            Move TheData[iTable].hTable to hTable
102006>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
102007>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
102010>>>            If (bOpened = False) Begin
102012>>>                Send Seq_Close_Channel iCh
102013>>>                Set phTable to hTable
102014>>>                Set psTableName to TheData[iTable].sLogicalName
102015>>>                Function_Return GenerateOpenTableError
102016>>>            End
102016>>>>
102016>>>            
102016>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION") to bSkipTable
102017>>>
102017>>>            If (bSkipTable = False) Begin
102019>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
102020>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(sLogicalName))
102021>>>
102021>>>                Move hTable                       to APITableNameInfo.iTableNumber
102022>>>                Move TheData[iTable].sRootName    to sRootName
102023>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
102024>>>                Move sRootName                    to APITableNameInfo.sRootName
102025>>>
102025>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
102026>>>                Move TheData[iTable].bIsAlias     to bIsAlias
102027>>>                Move bIsAlias                     to APITableNameInfo.bIsAlias
102028>>>                Get _UtilTableIsSql of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
102029>>>
102029>>>                // Get the Driver ID
102029>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
102032>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
102033>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
102034>>>
102034>>>                If (bIsAlias = False) Begin
102036>>>                    Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(APITableNameInfo.sLogicalName))
102037>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
102038>>>                    If (APIColumns[0].bError = True) Begin
102040>>>                        Function_Return GenerateError
102041>>>                    End
102041>>>>
102041>>>                    If (APIColumns[0].bCancel = True) Begin
102043>>>                        Function_Return GenerateUserCancel
102044>>>                    End
102044>>>>
102044>>>                    Move (SizeOfArray(APIColumns)) to iSize
102045>>>                    Decrement iSize
102046>>>                    If (iSize >= 0) Begin
102048>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
102051>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                    * "to APITableNameInfo.iTableNumber")
102054>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'        * "to APITableNameInfo.sRootName")
102057>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'        * "to APITableNameInfo.sLogicalName")
102060>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'        * "to APITableNameInfo.sDisplayName")
102063>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'        * "to APITableNameInfo.sDriverID")
102066>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias,      "True", "False")) * "to APITableNameInfo.bIsAlias")
102069>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,        "True", "False")) * "to APITableNameInfo.bIsSQL")
102072>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSystemFile, "True", "False")) * "to APITableNameInfo.bIsSystemFile")
102075>>>                        Writeln channel iCh
102077>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
102080>>>                    End
102080>>>>
102080>>>
102080>>>                    For iCount from 0 to iSize
102086>>>>
102086>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
102089>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
102092>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
102095>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType")
102098>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bAllowNULL, "True", "False")) * "to APIColumns[iCount].bAllowNULL")
102101>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sDefaultValue) + '"'       * "to APIColumns[iCount].sDefaultValue")
102104>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
102106>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
102109>>>                            Increment iErrors
102110>>>                        End
102110>>>>
102110>>>                        Move APIColumns[iCount].sType to sDataType
102111>>>                        If (Lowercase(sDataType) contains "identity") Begin
102113>>>                            Move (Replace("identity",sDataType, "")) to sDataType
102114>>>                            Move (Trim(sDataType)) to sDataType
102115>>>                        End
102115>>>>
102115>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
102118>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
102121>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
102124>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
102127>>>
102127>>>                        If (iCount < iSize) Begin
102129>>>                            Writeln channel iCh ("        Increment iCount")
102132>>>                            Writeln channel iCh
102134>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
102137>>>                        End
102137>>>>
102137>>>                    Loop
102138>>>>
102138>>>
102138>>>                    // Create Index Definitions:
102138>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
102139>>>                    If (APIIndexes[0].bError = True) Begin
102141>>>                        Function_Return GenerateError
102142>>>                    End
102142>>>>
102142>>>                    If (APIIndexes[0].bCancel = True) Begin
102144>>>                        Function_Return GenerateUserCancel
102145>>>                    End
102145>>>>
102145>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
102146>>>                    Decrement iIndexes
102147>>>                    If (iIndexes >= 0) Begin
102149>>>                        Writeln channel iCh
102151>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
102154>>>                        Writeln channel iCh ("        Move 0 to iCount")
102157>>>                        Writeln channel iCh ("        Move 0 to iSegment")
102160>>>                    End
102160>>>>
102160>>>                    For iIndex from 0 to iIndexes
102166>>>>
102166>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
102169>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iPrimaryIndex)       * "to APIIndexes[iCount].iPrimaryIndex")
102172>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
102175>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLClustered),  "True", "False") * "to APIIndexes[iCount].bIsSQLClustered")
102178>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsSQLPrimaryKey")
102181>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
102183>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
102186>>>                        End
102186>>>>
102186>>>
102186>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
102187>>>                        Decrement iNumSegments
102188>>>                        For iSegment from 0 to iNumSegments
102194>>>>
102194>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
102197>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
102200>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
102203>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
102206>>>                            If (iSegment < iNumSegments) Begin
102208>>>                                Writeln channel iCh ("        Increment iSegment")
102211>>>                            End
102211>>>>
102211>>>                        Loop
102212>>>>
102212>>>
102212>>>                        If (iIndex < iIndexes) Begin
102214>>>                            Writeln channel iCh ("        Increment iCount")
102217>>>                            Writeln channel iCh
102219>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
102222>>>                            Writeln channel iCh ("        Move 0 to iSegment")
102225>>>                        End
102225>>>>
102225>>>                    Loop
102226>>>>
102226>>>
102226>>>                    // Create Relation Definitions:
102226>>>                    Get UtilRelationsStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
102227>>>                    If (APIRelations[0].bError = True) Begin
102229>>>                        Function_Return GenerateError
102230>>>                    End
102230>>>>
102230>>>                    If (APIRelations[0].bCancel = True) Begin
102232>>>                        Function_Return GenerateUserCancel
102233>>>                    End
102233>>>>
102233>>>                    Move (SizeOfArray(APIRelations)) to iSize
102234>>>                    Decrement iSize
102235>>>                    If (iSize >= 0) Begin
102237>>>                        Writeln channel iCh
102239>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
102242>>>                        Writeln channel iCh ("        Move 0 to iCount")
102245>>>                    End
102245>>>>
102245>>>                    For iCount from 0 to iSize
102251>>>>
102251>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
102254>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
102257>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
102260>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
102263>>>                        If (iCount < iSize) Begin
102265>>>                            Writeln channel iCh ("        Increment iCount")
102268>>>                            Writeln channel iCh
102270>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
102273>>>                        End
102273>>>>
102273>>>                    Loop
102274>>>>
102274>>>
102274>>>                    // Create Table Update Definition:
102274>>>                    Writeln channel iCh
102276>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
102279>>>                    Writeln channel iCh
102281>>>
102281>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
102284>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
102287>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
102290>>>                    Writeln channel iCh ("        Move 0 to iCount")
102293>>>                    Writeln channel iCh ("        Send DoAdvance of ghoProgressBarOverall")
102296>>>                    Writeln channel iCh
102298>>>                End
102298>>>>
102298>>>
102298>>>                If (bIsAlias = True) Begin
102300>>>                    // Create Alias Table Definition:
102300>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
102303>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
102306>>>                    If (bSqlDriver = True and not(APITableNameInfo.sRootName contains sDriverID)) Begin
102308>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
102311>>>                    End
102311>>>>
102311>>>                    Else Begin
102312>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
102315>>>                    End
102315>>>>
102315>>>
102315>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
102318>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
102321>>>                    Writeln channel iCh
102323>>>                End
102323>>>>
102323>>>            End
102323>>>>
102323>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
102324>>>            If (iStatus <> 0) Begin
102326>>>                Send Seq_Close_Channel iCh
102327>>>                Function_Return GenerateUserCancel
102328>>>            End         
102328>>>>
102328>>>            
102328>>>            Close hTable
102329>>>        Loop // Main TheData loop
102330>>>>
102330>>>
102330>>>        Writeln channel iCh ("    End_Procedure")
102333>>>        Writeln channel iCh ("End_Object")
102336>>>
102336>>>        Send Seq_Close_Channel iCh
102337>>>        Function_Return GenerateOK
102338>>>    End_Function
102339>>>
102339>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
102342>>>        String sRetval
102342>>>        Case Begin
102342>>>            Case (iDataFlexDataType = DF_ASCII)
102344>>>                Move DF_ASCII_DUF to sRetval
102345>>>                Case Break
102346>>>            Case (iDataFlexDataType = DF_BCD)
102349>>>                Move "DF_BCD_DUF" to sRetval
102350>>>                Case Break
102351>>>            Case (iDataFlexDataType = DF_BINARY)
102354>>>                Move "DF_BINARY_DUF" to sRetval
102355>>>                Case Break
102356>>>            Case (iDataFlexDataType = DF_DATE)
102359>>>                Move "DF_DATE_DUF" to sRetval
102360>>>                Case Break
102361>>>            Case (iDataFlexDataType = DF_DATETIME)
102364>>>                Move "DF_DATETIME_DUF" to sRetval
102365>>>                Case Break
102366>>>            Case (iDataFlexDataType = DF_TEXT)
102369>>>                Move "DF_TEXT_DUF" to sRetval
102370>>>                Case Break
102371>>>            Case Else
102371>>>                Move iDataFlexDataType to sRetval
102372>>>        Case End
102372>>>
102372>>>        Function_Return sRetval
102373>>>    End_Function
102374>>>
102374>>>    Procedure Request_Clear    
102377>>>        tSQLConnection Connection
102377>>>        tSQLConnection Connection
102377>>>        tDataSourceRow[] EmptyData
102377>>>        tDataSourceRow[] EmptyData
102378>>>        Handle hoGrid hoDataSource
102378>>>        Integer[] iDifferencesEmpty
102379>>>        
102379>>>        Move DATAFLEX_ID to Connection.sDriverID
102380>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
102381>>>        Move (oFilelist_grd(Self))  to hoGrid
102382>>>        Get phoDataSource of hoGrid to hoDataSource
102383>>>        Send InitializeData of hoGrid EmptyData
102384>>>        Send ResetFilelistPathing of ghoApplication
102385>>>        Set Value of oFilelistPath_fm    to ""
102386>>>        Set Value of oPnVersionNumber_fm to 1.0
102387>>>        Set Value of oSourceName_fm      to ""
102388>>>        Set phDbVersion of oFilelist_grd to 0
102389>>>        Set psFilelistFrom of ghoApplication to ""
102390>>>        Set psFooterText of oLogicalName_col to "No of Tables:"
102391>>>        Set psFooterText of oRootName_col    to "Selected:"
102392>>>        Set psFooterText of oIsAlias_Col     to "Alias:"
102393>>>        Send Activate of oFilelistPath_fm    
102394>>>    End_Procedure
102395>>>
102395>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
102398>>>        Integer iSize iCount iItem iItems iTableNo iTableNo_Col iCheckbox_Col
102398>>>        Handle hoGrid hoDataSource
102398>>>        tDataSourceRow[] TheData
102398>>>        tDataSourceRow[] TheData
102399>>>
102399>>>        Set Value of oFilelistPath_fm to sFromFilelist
102400>>>        Move (oFilelist_grd(Self)) to hoGrid
102401>>>
102401>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
102402>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
102403>>>        Get phoDataSource of hoGrid to hoDataSource
102404>>>        Get DataSource of hoDataSource to TheData
102405>>>        Move (SizeOfArray(TheData)) to iItems
102406>>>        Decrement iItems
102407>>>
102407>>>        Move (SizeOfArray(iaDifferences)) to iSize
102408>>>        If (iSize = 0) Begin
102410>>>            Procedure_Return
102411>>>        End
102411>>>>
102411>>>        Decrement iSize
102412>>>        If (iSize > 0) Begin
102414>>>//            Send KeyAction of oDeSelectAll_btn  
102414>>>            Set SelectItems of oFilelist_grd to cx_Select_None
102415>>>        End
102415>>>>
102415>>>
102415>>>        For iCount from 0 to iSize
102421>>>>
102421>>>            Move iaDifferences[iCount] to iTableNo
102422>>>            If (iTableNo > 0) Begin
102424>>>                For iItem from 0 to iItems
102430>>>>
102430>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
102432>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
102433>>>                        Move iItems to iItem // We found it and we're out of this loop.
102434>>>                    End
102434>>>>
102434>>>                Loop
102435>>>>
102435>>>            End
102435>>>>
102435>>>        Loop
102436>>>>
102436>>>
102436>>>        Send ReInitializeData of hoGrid TheData False
102437>>>        Send DoSetCheckboxFooterText of hoGrid
102438>>>    End_Procedure
102439>>>
102439>>>    Procedure OnSetFocus
102442>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
102444>>>            Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
102445>>>        End
102445>>>>
102445>>>    End_Procedure
102446>>>    
102446>>>    Procedure OnFileDropped String sFilename Boolean bLast
102449>>>        String sTest
102449>>>        Forward Send OnFileDropped sFilename bLast
102451>>>        If (bLast = True) Begin
102453>>>            Get ParseFileName sFilename to sTest
102454>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
102456>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
102457>>>                Procedure_Return
102458>>>            End
102458>>>>
102458>>>            Set Value of oFilelistPath_fm to sFilename
102459>>>        End
102459>>>>
102459>>>    End_Procedure
102460>>>
102460>>>//    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
102460>>>//    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
102460>>>//    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
102460>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
102461>>>    On_Key Key_Ctrl+Key_O  Send KeyAction of oOpenAppSrcFolder_btn
102462>>>    On_Key kClear          Send Request_Clear
102463>>>    On_Key kClear_All      Send Request_Clear
102464>>>    On_Key Key_Ctrl+Key_F4 Send None
102465>>>End_Object
102466>>>
102466>>>// General purpose access message to auto-fill grid with tables with
102466>>>// differences (after "Compare Databases" has been run).
102466>>>Procedure TagFileNamesForCodeGeneration
102469>>>    String sFileListFrom sCurrentFilelist
102469>>>    Integer[] iaDifferences
102470>>>    Handle ho
102470>>>
102470>>>    Send Activate_oTableDUFCodeGenerator
102471>>>    Move (oTableDUFCodeGenerator(Self)) to ho
102472>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
102473>>>    If (sCurrentFilelist <> "") Begin
102475>>>        Send Request_Clear of ho
102476>>>    End
102476>>>>
102476>>>
102476>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
102477>>>    Get piaDifferences of ghoApplication to iaDifferences
102478>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
102479>>>    Send Info_Box ("Ready marking tables. Number of different tables:" * (String(SizeOfArray(iaDifferences))))
102480>>>End_Procedure
102481>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.vw)
102481>>>Use Windows.pkg
102481>>>Use Dfclient.pkg
102481>>>Use Cursor.pkg
102481>>>Use Batchdd.pkg
102481>>>Use cRDCButton.pkg
102481>>>Use cDbUpdateFunctionLibrary.pkg
102481>>>Use DUFStatusPanel.pkg
102481>>>Use seq_chnl.pkg
102481>>>Use vWin32fh.pkg
102481>>>Use cRDCHeaderGroup.pkg
102481>>>Use cRDCSuggestionIniForm.pkg
102481>>>Use cSQLCheckBox.pkg
102481>>>Use cRDCCommandLinkButton.pkg
102481>>>Use LogFileDialog.dg
Including file: LogFileDialog.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LogFileDialog.dg)
102481>>>>>Use Windows.pkg
102481>>>>>Use cRDCButtonDPI.pkg
102481>>>>>Use cRichEdit.pkg
102481>>>>>Use seq_chnl.pkg
102481>>>>>Use vWin32fh.pkg
102481>>>>>
102481>>>>>Object oLogFileDialog_dg is a ModalPanel
102483>>>>>    Set Size to 230 435
102484>>>>>    Set Label to "Log File Dialog"
102485>>>>>    Set piMinSize to 89 211
102486>>>>>    Set Location to 2 2
102487>>>>>    Set Border_Style To Border_Thick
102488>>>>>    Set Locate_Mode to Center_On_Parent
102489>>>>>    
102489>>>>>    Property String psLogFileName ""  
102491>>>>>    Property Integer piIndent 
102493>>>>>    
102493>>>>>    Object oLogFile_edt is a cRichEdit
102495>>>>>        Set Size to 185 413
102496>>>>>        Set Location to 16 11
102497>>>>>        Set TextColor to clBlack
102498>>>>>        Set peAnchors to anAll
102499>>>>>        Set Label_Row_Offset to 3
102500>>>>>        Set Label_TextColor to clGreenGreyLight
102501>>>>>        Set Label_FontItalics to True
102502>>>>>        Set piFontSize to 200
102503>>>>>        Set psTypeFace to 'Consolas'
102504>>>>>        
102504>>>>>        Delegate Set piIndent to (piParagraphIndent(Self))
102506>>>>>        
102506>>>>>        Procedure DoSaveDocument
102509>>>>>            String sLogFileName
102509>>>>>            Boolean bOk bOkToSave bChanged
102509>>>>>        
102509>>>>>            Move False to bOkToSave       
102510>>>>>            Get pbCanUndo to bChanged
102511>>>>>            If (bChanged = False) Begin
102513>>>>>                Procedure_Return
102514>>>>>            End
102514>>>>>>
102514>>>>>        
102514>>>>>            Get psLogFileName to sLogFileName
102515>>>>>            Send Write sLogFileName
102516>>>>>            // clear undo buffer on save
102516>>>>>            // we want undo buffer to only apply to the new document
102516>>>>>            Send ClearUndoBuffer
102517>>>>>            Send Info_Box "Changes saved."
102518>>>>>        End_Procedure 
102519>>>>>        
102519>>>>>        Procedure LoadData
102522>>>>>            String sLogFileName
102522>>>>>            Integer iTwips iIndent
102522>>>>>    
102522>>>>>            Get psLogFileName to sLogFileName
102523>>>>>            Set Label to sLogFileName
102524>>>>>            Move 1440 to iTwips
102525>>>>>            Get piIndent to iIndent
102526>>>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
102527>>>>>            
102527>>>>>            Send Read sLogFileName
102528>>>>>        End_Procedure
102529>>>>>    
102529>>>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
102530>>>>>        On_Key kCancel Send Cancel
102531>>>>>    End_Object
102532>>>>>
102532>>>>>    Object oCancel_Btn is a cRDCButtonDPI
102534>>>>>        Set Label    to "&Close"
102535>>>>>        Set Location to 209 374
102536>>>>>        Set peAnchors to anBottomRight
102537>>>>>
102537>>>>>        Procedure OnClick
102540>>>>>            Send Close_Panel
102541>>>>>        End_Procedure
102542>>>>>
102542>>>>>    End_Object
102543>>>>>
102543>>>>>
102543>>>>>    Object oFirstRun_btn is a cRDCButtonDPI
102545>>>>>        Set Location to 209 260
102546>>>>>        Set Label to "Beginning"
102547>>>>>        Set peAnchors to anBottomRight
102548>>>>>    
102548>>>>>        Procedure OnClick
102551>>>>>            Send Beginning_of_Data to oLogFile_edt    
102552>>>>>        End_Procedure
102553>>>>>    
102553>>>>>    End_Object
102554>>>>>    Object oLatestRun_btn is a cRDCButtonDPI
102556>>>>>        Set Location to 209 317
102557>>>>>        Set Label to "End"
102558>>>>>        Set peAnchors to anBottomRight
102559>>>>>    
102559>>>>>        Procedure OnClick
102562>>>>>            Send End_of_Data to oLogFile_edt    
102563>>>>>        End_Procedure
102564>>>>>    
102564>>>>>    End_Object
102565>>>>>
102565>>>>>    // Automatically load data into the grid when activating.
102565>>>>>    Procedure Activating 
102568>>>>>        Handle ho
102568>>>>>        Move (oLogFile_edt(Self)) to ho
102569>>>>>        Send LoadData    of ho
102570>>>>>        // We need to active before we can send end_of_data.
102570>>>>>        Send Activate    of ho
102571>>>>>//        Send End_of_Data to ho
102571>>>>>    End_Procedure
102572>>>>>
102572>>>>>    Procedure Page Integer iPageObject
102575>>>>>        Forward Send Page iPageObject
102577>>>>>        Set Icon to "ViewReportBlack1.ico"
102578>>>>>    End_Procedure      
102579>>>>>    
102579>>>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
102579>>>>>    Procedure End_Construct_Object
102582>>>>>        Integer iStyle iSize iOffset
102582>>>>>
102582>>>>>        Forward Send End_Construct_Object
102584>>>>>
102584>>>>>        Get Border_Style to iStyle
102585>>>>>        Move 8 to iOffset
102586>>>>>        If (iStyle = Border_Thick) Begin
102588>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
102590>>>>>                Object oStatusBar is a cCJStatusBar
102592>>>>>                    Object oStatusIdle is a cCJStatusBarPane
102594>>>>>                        Set piId to sbpIDIdlePane
102595>>>>>                        Set pbStyleStretch to True
102596>>>>>                    End_Object
102597>>>>>                End_Object
102598>>>>>            End_Object
102599>>>>>
102599>>>>>            Get Size to iSize
102600>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
102601>>>>>        End
102601>>>>>>
102601>>>>>    End_Procedure
102602>>>>>
102602>>>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
102603>>>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
102604>>>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
102605>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
102606>>>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
102607>>>>>End_Object
102608>>>>>
102608>>>>>Procedure ActivateLogFileDialog String sLogFile
102611>>>>>    Handle ho       
102611>>>>>    Boolean bExists
102611>>>>>    
102611>>>>>    Get vFilePathExists sLogFile to bExists
102612>>>>>    If (bExists = False) Begin
102614>>>>>        Send Info_Box "The logfile doesn't exist."
102615>>>>>        Procedure_Return
102616>>>>>    End
102616>>>>>>
102616>>>>>    Move (oLogFileDialog_dg(Self)) to ho
102617>>>>>    Set psLogFileName of ho to sLogFile
102618>>>>>    Send Popup of ho
102619>>>>>End_Procedure           
102620>>>
102620>>>Define CS_ReportFileName                for "DUFCompareReport"
102620>>>Define CS_ReportFileNameExtenstion      for ".txt"
102620>>>Define CS_ReportDifferenceNote          for "(*)"
102620>>>Define CS_ReportTableNotFound           for "Table doesn't exist!"
102620>>>Define CS_ReportFieldNotFound           for "Field doesn't exist!"
102620>>>Define CS_ReportIndexNotFound           for "Index doesn't exist!"
102620>>>Define CS_ReportIndexSegmentNotFound    for "Index segment doesn't exist!"
102620>>>Define CS_ReportIndexNotApplicable      for "N/A"
102620>>>Define CS_ReportRelationNotFound        for "Relationship doesn't exist!"
102620>>>Define CS_ReportHeaderUnderWrite        for "===================================================================================="
102620>>>
102620>>>Define CI_ReportColumn1                 for 17
102620>>>Define CI_ReportColumn2                 for 65
102620>>>//Define CI_ReportColumn3                 for 75
102620>>>//Define CI_ReportColumn4                 for 90
102620>>>
102620>>>Struct tRelationDiffs
102620>>>    String sFromFieldsRight
102620>>>    String sFromFields
102620>>>    String sToFields
102620>>>    String sFrom
102620>>>    String sTo
102620>>>End_Struct
102620>>>
102620>>>Global_Variable Integer giDifferenceTables
102620>>>
102620>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
102630>>>>
102630>>>Object oCompareDatabases_vw is a dbView
102632>>>    Set Size to 323 490
102633>>>    Set Label to "Compare"
102634>>>    Set piMinSize to 89 211
102635>>>    Set Border_Style To Border_Thick
102636>>>    Set pbAutoActivate to True
102637>>>    Set pbAcceptDropFiles to True
102638>>>
102638>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
102640>>>        Set Size to 50 462
102641>>>        Set Location to 8 15
102642>>>        Set psImage to "FolderLeft1.ico"
102643>>>        Set Label to "Select FROM Filelist.cfg"
102644>>>        Set psNote to "The development/latest version of the database"  
102645>>>        Set psToolTip to "Select the Filelist.cfg file for the development database"
102646>>>
102646>>>        Object oFilelistPathFrom_fm is a cRDCSuggestionIniForm
102648>>>            Set Size to 12 413
102649>>>            Set Location to 29 29
102650>>>            Set Label_Col_Offset to 0
102651>>>            Set Label_Row_Offset to 1
102652>>>            Set Label_Justification_Mode to JMode_Top
102653>>>            Set Prompt_Button_Mode to PB_PromptOn
102654>>>            Set peAnchors to anTopLeftRight
102655>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
102656>>>            // This is needed for the toolbar's prompt icon to be active
102656>>>            Set Prompt_Object to Self
102657>>>
102657>>>            Procedure Prompt
102660>>>                String sFileName sPath sFileMask sRetval
102660>>>
102660>>>                Get Value to sFileName
102661>>>                Get ParseFolderName sFileName to sPath
102662>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102663>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102664>>>                If (sRetval <> "") Begin
102666>>>                    Set Value to sRetval
102667>>>                End
102667>>>>
102667>>>            End_Procedure
102668>>>
102668>>>            Procedure OnChange
102671>>>                String sValue
102671>>>                Boolean bOK bCfgFile
102671>>>
102671>>>                Get Value to sValue
102672>>>                Get vFilePathExists sValue to bOK
102673>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102674>>>                If (bOK = True and bCfgFile) Begin
102676>>>                    Get ChangeFilelistPathing of ghoApplication sValue to bOK
102677>>>                    If (bOK = True) Begin
102679>>>                        Set psFilelistFrom of ghoApplication to sValue
102680>>>                    End
102680>>>>
102680>>>                End
102680>>>>
102680>>>
102680>>>            End_Procedure
102681>>>
102681>>>            On_Key Key_Ctrl+Key_W Send None
102682>>>            On_Key Key_Ctrl+Key_Q Send None
102683>>>        End_Object
102684>>>
102684>>>    End_Object
102685>>>
102685>>>    Object oToFilelist_grp is a cRDCHeaderGroup
102687>>>        Set Size to 50 462
102688>>>        Set Location to 69 15
102689>>>        Set psImage to "FolderRight1.ico"
102690>>>        Set Label to "Select TO Filelist.cfg"
102691>>>        Set psNote to "The customer/current version of the database"   
102692>>>        Set psToolTip to "Select the Filelist.cfg file for the database that needs to be updated"
102693>>>
102693>>>        Object oFilelistPathTo_fm is a cRDCSuggestionIniForm
102695>>>            Set Size to 12 413
102696>>>            Set Location to 29 28
102697>>>            Set Label_Col_Offset to 0
102698>>>            Set Label_Row_Offset to 1
102699>>>            Set Label_Justification_Mode to JMode_Top
102700>>>            Set Prompt_Button_Mode to PB_PromptOn
102701>>>            Set peAnchors to anTopLeftRight
102702>>>            Set psToolTip to "Select the TO database Filelist.cfg"
102703>>>            Set Prompt_Object to Self
102704>>>
102704>>>            Procedure Prompt
102707>>>                String sFileName sPath sFileMask sRetval
102707>>>
102707>>>                Get Value to sFileName
102708>>>                Get ParseFolderName sFileName to sPath
102709>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102710>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102711>>>                If (sRetval <> "") Begin
102713>>>                    Set Value to sRetval
102714>>>                End
102714>>>>
102714>>>            End_Procedure
102715>>>
102715>>>            Procedure OnChange
102718>>>                String sValue sPath sReportName sToday
102718>>>                Date dToday
102718>>>                Boolean bOK bCfgFile
102718>>>
102718>>>                Get Value to sValue
102719>>>                Get vFilePathExists sValue to bOK
102720>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102721>>>                If (bOK = False or bCfgFile = False) Begin
102723>>>                    Procedure_Return
102724>>>                End
102724>>>>
102724>>>
102724>>>                Set psFilelistFrom of ghoApplication to sValue
102725>>>                Sysdate dToday  
102726>>>                Move dToday to sToday
102727>>>                Move (Replaces("/", sToday, "-")) to sToday
102728>>>                Move (Replaces(".", sToday, "-")) to sToday
102729>>>                Get Value to sPath
102730>>>                Get ParseFolderName sPath to sPath
102731>>>                Get vFolderFormat   sPath to sPath
102732>>>                Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
102733>>>                Set Value of oReportFileName_fm to sReportName
102734>>>            End_Procedure
102735>>>
102735>>>            On_Key Key_Ctrl+Key_W Send None
102736>>>            On_Key Key_Ctrl+Key_Q Send None
102737>>>        End_Object
102738>>>
102738>>>    End_Object
102739>>>
102739>>>    Object oCompareProperties_grp is a cRDCHeaderGroup
102741>>>        Set Size to 59 462
102742>>>        Set Location to 130 15
102743>>>        Set Label to "Configure Database Compare"
102744>>>        Set psNote to "Select checkboxes to configure the comparison"
102745>>>        Set psImage to "Settings1.ico" 
102746>>>        Set psToolTip to "Configure what will be compared"
102747>>>        
102747>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
102749>>>            Set Size to 9 123
102750>>>            Set Location to 28 30
102751>>>            Set Label to "Check Date/DataTime difference"
102752>>>            Set psToolTip to "Check Date to DateTime column differences"
102753>>>            Set Checked_State to False
102754>>>        End_Object
102755>>>
102755>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
102757>>>            Set Size to 9 134
102758>>>            Set Location to 28 199
102759>>>            Set Label to "Check Index Ascending/Descending"
102760>>>            Set Checked_State to False
102761>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102762>>>        End_Object
102763>>>
102763>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
102765>>>            Set Size to 9 117
102766>>>            Set Location to 41 30
102767>>>            Set Label to "Check Index Lower/Uppercase"
102768>>>            Set Checked_State to False
102769>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102770>>>        End_Object
102771>>>
102771>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
102773>>>            Set Size to 9 156
102774>>>            Set Location to 41 199
102775>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
102776>>>            Set Checked_State to True
102777>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
102778>>>        End_Object
102779>>>
102779>>>    End_Object
102780>>>
102780>>>    Object oReportFilename_grp is a cRDCHeaderGroup
102782>>>        Set Size to 51 462
102783>>>        Set Location to 200 15
102784>>>        Set psImage to "ActionPrintSave1.ico"
102785>>>        Set Label to "Report File Name"
102786>>>        Set psNote to "Output file name"    
102787>>>        Set psToolTip to "The name of the report file that contains the compare result"
102788>>>        
102788>>>        Object oReportFileName_fm is a Form
102790>>>            Set Size to 12 413
102791>>>            Set Location to 29 29
102792>>>            Set Label_Col_Offset to 0
102793>>>            Set Label_Row_Offset to 1
102794>>>            Set Label_Justification_Mode to JMode_Top
102795>>>            Set Prompt_Button_Mode to PB_PromptOn
102796>>>            Set peAnchors to anTopLeftRight
102797>>>            Set psToolTip to "The name of the output text file for database differences that will be generated"
102798>>>            Set Status_Help to "The name of the output text file for database differences that will be generated"
102799>>>            Set Prompt_Object to Self
102800>>>
102800>>>            Procedure Prompt
102803>>>                String sFileName sPath sFileMask sRetval
102803>>>
102803>>>                Get Value to sFileName
102804>>>                Get ParseFolderName sFileName to sPath
102805>>>                Move "Text files (*.txt)|*.txt" to sFileMask
102806>>>                Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
102807>>>                If (sRetval <> "") Begin
102809>>>                    Set Value to sRetval
102810>>>                End
102810>>>>
102810>>>            End_Procedure
102811>>>
102811>>>            On_Key Key_Ctrl+Key_W Send None
102812>>>            On_Key Key_Ctrl+Key_Q Send None
102813>>>        End_Object
102814>>>
102814>>>    End_Object
102815>>>
102815>>>    Procedure MainProcess
102818>>>        String sFilelistFrom sFilelistTo
102818>>>        Integer[] iaDifferences
102819>>>        Integer iSize iRetval hTable
102819>>>        Boolean bFromExists bToExists
102819>>>        tAPITableBooleans CompareCheckBoxes
102819>>>        tAPITableBooleans CompareCheckBoxes
102819>>>        DateTime dtExecStart dtExecEnd
102819>>>        TimeSpan tsTotalTime
102819>>>
102819>>>        Move (CurrentDateTime()) to dtExecStart
102820>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
102821>>>        Get vFilePathExists sFilelistFrom to bFromExists
102822>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
102823>>>        Get vFilePathExists sFilelistTo   to bToExists
102824>>>
102824>>>        If (bFromExists = False or bToExists = False) Begin
102826>>>            Send Info_Box "You first need to select a 'FROM' and a 'TO' Filelist.cfg."
102827>>>            Procedure_Return
102828>>>        End
102828>>>>
102828>>>
102828>>>        Move 0 to giDifferenceTables
102829>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareCheckBoxes.bCompareDate_DateTime
102830>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareCheckBoxes.bCompareIndexAscending
102831>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareCheckBoxes.bCompareIndexUppercase
102832>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareCheckBoxes.bCompareFilelistUppercase
102833>>>
102833>>>        Get CompareAndOutputDiffs sFilelistFrom sFilelistTo CompareCheckBoxes dtExecStart to iaDifferences
102834>>>        Set piaDifferences of ghoApplication to iaDifferences
102835>>>
102835>>>        Send Stop_StatusPanel of ghoStatusPanel
102836>>>        Move (CurrentDateTime()) to dtExecEnd
102837>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
102838>>>        Move (SizeOfArray(iaDifferences)) to iSize
102839>>>
102839>>>        Case Begin
102839>>>            Case (iSize = 0)
102841>>>                Send Info_Box "No differences found. The two databases should be identical."
102842>>>                Case Break
102843>>>            Case (iaDifferences[0] >= 1)
102846>>>                Get YesNo_Box ("Ready! (Time elapsed:" * String(tsTotalTime) + ")\n" + String(iSize) * "Differences found. View the report now?") to iRetval
102847>>>                If (iRetval = MBR_Yes) Begin
102849>>>                    Send DoShowReport of oViewReport_Btn
102850>>>                End
102850>>>>
102850>>>                Case Break
102851>>>            Case (iaDifferences[0] = -1)
102854>>>                Send Info_Box "Process interrupted."
102855>>>                Case Break
102856>>>            Case (iaDifferences[0] < -1)
102859>>>                Move iaDifferences[0]  to hTable
102860>>>                Move (999999 + hTable * -1) to hTable
102861>>>                Send Info_Box ("Process not complete. Couldn't open table number:" * String(hTable))
102862>>>                Send DoShowReport of oViewReport_Btn
102863>>>                Case Break
102864>>>            Case Else
102864>>>                Send Info_Box "An unknown error occured. Process interrupted."
102865>>>        Case End
102865>>>
102865>>>        Send Activate of oFilelistPathFrom_fm
102866>>>    End_Procedure
102867>>>
102867>>>    Function CompareAndOutputDiffs String sFilelistFrom String sFilelistTo tAPITableBooleans CompareCheckBoxes DateTime dtExecStart Returns Integer[]
102870>>>        Integer iSize iCount iNoOfTablesFrom iNoOfTablesTo iCh
102870>>>        Boolean bIsSame bFilelistError bUserCancel bOK bCollationDiff bIsEmbedded
102870>>>        Handle hTable
102870>>>        String sLogicalName sDatabaseCollationFrom sDatabaseCollationTo sDatabase
102870>>>        tAPITable[] aFromStructure aToStructure
102870>>>        tAPITable[] aFromStructure aToStructure
102872>>>        tAPITableCompare[] aAPITableCompare
102872>>>        tAPITableCompare[] aAPITableCompare
102873>>>        Integer[] iaDifferences iaDifferencesEmpty 
102875>>>
102875>>>        Set Message_Text of ghoStatusPanel to ""
102876>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
102876>>>        Get ChangeFilelistPathing of ghoApplication sFilelistFrom to bOK
102877>>>        If (bOK = False) Begin
102879>>>            Move -1 to iaDifferencesEmpty[0]
102880>>>            Function_Return iaDifferencesEmpty
102881>>>        End       
102881>>>>
102881>>>        Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bIsEmbedded
102882>>>        If (bIsEmbedded = False) Begin
102884>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
102885>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationFrom
102886>>>        End 
102886>>>>
102886>>>        Else Begin
102887>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationFrom
102888>>>        End
102888>>>>
102888>>>
102888>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesFrom
102889>>>        Set pbVisible   of ghoProgressBar        to True
102890>>>        Set piPosition  of ghoProgressBar        to 0
102891>>>        Set piAdvanceBy of ghoProgressBar        to 1
102892>>>        Set pbVisible   of ghoProgressBarOverall to True
102893>>>        Set piPosition  of ghoProgressBarOverall to 0
102894>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
102895>>>        Set piMaximum   of ghoProgressBarOverall to iNoOfTablesFrom
102896>>>        
102896>>>        // *** Fill the 'FROM' structure with data: (1 of 3)
102896>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True True to aFromStructure
102897>>>        
102897>>>        // Process cancelled by user?
102897>>>        If (aFromStructure[0].bCancel = True) Begin
102899>>>            Move -1 to iaDifferencesEmpty[0]
102900>>>            Function_Return iaDifferencesEmpty
102901>>>        End
102901>>>>
102901>>>        
102901>>>        // Error while filling struct array (Table could not be opened)?
102901>>>        If (aFromStructure[0].bError = True) Begin
102903>>>            Move aFromStructure[0].ApiTableInfo.iTableNumber to hTable
102904>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
102905>>>            Function_Return iaDifferencesEmpty
102906>>>        End
102906>>>>
102906>>>
102906>>>        // Set up the pathing correctly for the 'TO' Filelist.cfg so we can open tables from the other workspace:
102906>>>        Get ChangeFilelistPathing of ghoApplication sFilelistTo to bOK
102907>>>        If (bOK = False) Begin
102909>>>            Move -1 to iaDifferencesEmpty[0]
102910>>>            Function_Return iaDifferencesEmpty
102911>>>        End
102911>>>>
102911>>>
102911>>>        If (bIsEmbedded = False) Begin
102913>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
102914>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationTo
102915>>>        End 
102915>>>>
102915>>>        Else Begin
102916>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationTo
102917>>>        End
102917>>>>
102917>>>
102917>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesTo
102918>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTablesTo
102919>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
102920>>>
102920>>>        // *** Fill the 'TO' structure with data: (2 of 3)
102920>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True False to aToStructure
102921>>>        // Process cancelled by user?
102921>>>        If (aToStructure[0].bCancel = True) Begin
102923>>>            Move -1 to iaDifferencesEmpty[0]
102924>>>            Function_Return iaDifferencesEmpty
102925>>>        End
102925>>>>
102925>>>        // Error while filling struct array (Table could not be opened)?
102925>>>        If (aToStructure[0].bError = True) Begin
102927>>>            Move aToStructure[0].ApiTableInfo.iTableNumber to hTable
102928>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
102929>>>//            Function_Return iaDifferencesEmpty
102929>>>        End
102929>>>>
102929>>>
102929>>>        Set Message_Text of ghoStatusPanel to "Comparing and Writing Differences: (3 of 3)"
102930>>>        Move 0 to hTable
102931>>>        Move 0 to iCount
102932>>>        Get WriteReportHeader sDatabaseCollationFrom sDatabaseCollationTo to iCh
102933>>>
102933>>>        Get UtilTableCombineFromAndToArrays of ghoDbUpdateFunctionLibrary aFromStructure aToStructure to aAPITableCompare
102934>>>        Move (SizeOfArray(aAPITableCompare))   to iSize
102935>>>        Set piMaximum of ghoProgressBar        to iSize
102936>>>        Set piMaximum of ghoProgressBarOverall to iSize
102937>>>        Decrement iSize
102938>>>
102938>>>        For iCount from 0 to iSize
102944>>>>
102944>>>            Move True to bIsSame
102945>>>            Set piPosition of ghoProgressBarOverall to iCount
102946>>>            Move aAPITableCompare[iCount].hTable to hTable
102947>>>
102947>>>            If (aAPITableCompare[iCount].bExistsFrom = True) Begin
102949>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
102950>>>            End
102950>>>>
102950>>>            Else Begin
102951>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
102952>>>            End
102952>>>>
102952>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * String("Number:") * String(hTable))
102953>>>
102953>>>            Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aAPITableCompare[iCount] CompareCheckBoxes False (&bFilelistError) to bIsSame
102954>>>
102954>>>            If (bIsSame = False) Begin
102956>>>                Send MainReport (&aAPITableCompare[iCount]) (&CompareCheckBoxes) iCh
102957>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
102958>>>            End
102958>>>>
102958>>>
102958>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
102959>>>            If (bUserCancel = True) Begin
102961>>>                Move -1 to iaDifferencesEmpty[0]
102962>>>                Function_Return iaDifferencesEmpty
102963>>>            End
102963>>>>
102963>>>        Loop
102964>>>>
102964>>>        
102964>>>        Move False to bCollationDiff
102965>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
102967>>>            Move True to bCollationDiff
102968>>>        End
102968>>>>
102968>>>        Send WriteReportFooter (SizeOfArray(iaDifferences)) bCollationDiff iCh dtExecStart
102969>>>        Close DF_ALL DF_PERMANENT
102970>>>
102970>>>        Function_Return iaDifferences
102971>>>    End_Function
102972>>>
102972>>>    Procedure MainReport tAPITableCompare ByRef aAPITableCompare tAPITableBooleans ByRef CompareCheckBoxes Integer iCh
102975>>>        String sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo
102975>>>        Handle hTable
102975>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
102975>>>        Boolean bExistsFrom bExistsTo bIsSQLFrom bIsSQLTo
102975>>>
102975>>>        Move CompareCheckBoxes.bCompareDate_DateTime     to bCompareDate_DateTime
102976>>>        Move CompareCheckBoxes.bCompareIndexAscending    to bCompareIndexAscending
102977>>>        Move CompareCheckBoxes.bCompareIndexUppercase    to bCompareIndexUppercase
102978>>>        Move CompareCheckBoxes.bCompareFilelistUppercase to bCompareFilelistUppercase
102979>>>
102979>>>        Move aAPITableCompare.bExistsFrom                            to bExistsFrom
102980>>>        Move aAPITableCompare.bExistsTo                              to bExistsTo
102981>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLFrom     to bIsSQLFrom
102982>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLTo       to bIsSQLTo
102983>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDFrom  to sDriverIDFrom
102984>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDTo    to sDriverIDTo
102985>>>        Move aAPITableCompare.APITableNameInfoCompare.iTableNumber   to hTable
102986>>>
102986>>>        If (aAPITableCompare.bExistsFrom = True) Begin
102988>>>            Move aAPITableCompare.APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
102989>>>        End
102989>>>>
102989>>>        Else Begin
102990>>>            Move (aAPITableCompare.APITableNameInfoCompare.sLogicalNameTo) to sLogicalName
102991>>>        End
102991>>>>
102991>>>
102991>>>        Send WriteTableInfoDiff aAPITableCompare.APITableNameInfoCompare bCompareFilelistUppercase iCh
102992>>>        If (aAPITableCompare.bExistsFrom = True and aAPITableCompare.bExistsTo = True) Begin
102994>>>            Send WriteColumnDiffs sDriverIDFrom sDriverIDTo hTable sLogicalName bIsSQLFrom bIsSQLTo aAPITableCompare.aAPIColumnsCompare bCompareDate_DateTime iCh
102995>>>            Send WriteIndexDiffs hTable bIsSQLFrom bIsSQLTo sLogicalName aAPITableCompare.aAPIIndexesCompare bCompareIndexUppercase bCompareIndexAscending iCh
102996>>>            Send WriteRelationDiffs hTable aAPITableCompare.aAPIRelationsCompare iCh
102997>>>        End
102997>>>>
102997>>>
102997>>>    End_Procedure
102998>>>
102998>>>    Function WriteReportHeader String sDatabaseCollationFrom String sDatabaseCollationTo Returns Integer
103001>>>        Integer iCh
103001>>>        String sFilelistFrom sFilelistTo sReportName //sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo sRootName sTableName
103001>>>        DateTime dtCreationTime    
103001>>>
103001>>>        Get Value of oReportFileName_fm to sReportName
103002>>>        Get Seq_Open_Output_Channel sReportName to iCh
103003>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
103005>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
103006>>>            Function_Return 0
103007>>>        End                   
103007>>>>
103007>>>        
103007>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
103009>>>            Move (sDatabaseCollationTo * String("(*)")) to sDatabaseCollationTo
103010>>>        End
103010>>>>
103010>>>
103010>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
103011>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
103012>>>        Move (CurrentDateTime()) to dtCreationTime
103013>>>
103013>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103016>>>        Writeln channel iCh CS_DatabaseUpdateFramework
103019>>>        Writeln channel iCh (" ***  DATABASE DIFFERENCES REPORT  ***")
103022>>>        Writeln channel iCh ""
103025>>>        Writeln channel iCh ("      Date & Time Printed       :" * String(dtCreationTime))
103028>>>        Writeln channel iCh ("      FROM Database Filelist.cfg:" * String(sFilelistFrom))
103031>>>        Writeln channel iCh ("      TO   Database Filelist.cfg:" * String(sFilelistTo))
103034>>>        Writeln channel iCh ("      FROM Database Collation   :" * String(sDatabaseCollationFrom))
103037>>>        Writeln channel iCh ("      TO   Database Collation   :" * String(sDatabaseCollationTo))
103040>>>        Writeln channel iCh ""
103043>>>        Writeln channel iCh ("      Note: An asterisk in parenthesis (*) denotes a difference!")
103046>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103049>>>        Writeln channel iCh
103051>>>
103051>>>        Function_Return iCh
103052>>>    End_Function
103053>>>
103053>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
103053>>>    Procedure WriteTableInfoDiff tAPITableNameInfoCompare APITableNameInfoCompare Boolean bCompareFilelistUppercase Integer iCh
103056>>>        String sLogicalName  sFrom sTo
103056>>>        Boolean bExistsFrom bExistsTo bIsSame
103056>>>        Handle hTable
103056>>>
103056>>>        Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoCompare to bIsSame
103057>>>        If (bIsSame = True) Begin
103059>>>            Procedure_Return
103060>>>        End
103060>>>>
103060>>>
103060>>>        Move APITableNameInfoCompare.iTableNumber to hTable
103061>>>        Move APITableNameInfoCompare.bExistsFrom  to bExistsFrom
103062>>>        Move APITableNameInfoCompare.bExistsTo    to bExistsTo
103063>>>        If (bExistsFrom = True) Begin
103065>>>            Move APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
103066>>>        End
103066>>>>
103066>>>        If (bExistsTo = True) Begin
103068>>>            Move APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
103069>>>        End
103069>>>>
103069>>>
103069>>>        Writeln channel iCh
103071>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable " - " sLogicalName
103077>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103080>>>
103080>>>        Move "FROM Database:" to sFrom
103081>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103082>>>        Move (sFrom + "TO Database:") to sFrom
103083>>>        Writeln channel iCh sFrom
103086>>>        Move (Repeat("-", Length(sFrom))) to sFrom
103087>>>        Writeln channel iCh sFrom
103090>>>
103090>>>        Move "Logical Name:"                                                to sFrom
103091>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103092>>>        If (bExistsFrom = True) Begin
103094>>>            Move (sFrom + String(APITableNameInfoCompare.sLogicalNameFrom)) to sFrom
103095>>>        End
103095>>>>
103095>>>        If (bExistsFrom = False) Begin
103097>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103098>>>        End
103098>>>>
103098>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103099>>>        If (bExistsTo = True) Begin
103101>>>            Move APITableNameInfoCompare.sLogicalNameTo                     to sTo
103102>>>        End
103102>>>>
103102>>>        If (bExistsTo = False) Begin
103104>>>            Move ""                                                         to sTo
103105>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103106>>>        End
103106>>>>
103106>>>        Writeln channel iCh sFrom sTo
103110>>>
103110>>>        Move "Root Name:"                                                   to sFrom
103111>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103112>>>        If (bExistsFrom = True) Begin
103114>>>            Move (sFrom + String(APITableNameInfoCompare.sRootNameFrom))    to sFrom
103115>>>        End
103115>>>>
103115>>>        If (bExistsFrom = False) Begin
103117>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103118>>>        End
103118>>>>
103118>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103119>>>        If (bExistsTo = True) Begin
103121>>>            Move APITableNameInfoCompare.sRootNameTo                        to sTo
103122>>>        End
103122>>>>
103122>>>        If (bExistsTo = False) Begin
103124>>>            Move ""                                                         to sTo
103125>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103126>>>        End
103126>>>>
103126>>>        Writeln channel iCh sFrom sTo
103130>>>
103130>>>        Move "Display Name:"                                                to sFrom
103131>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103132>>>        If (bExistsFrom = True) Begin
103134>>>            Move (sFrom + String(APITableNameInfoCompare.sDisplayNameFrom)) to sFrom
103135>>>        End
103135>>>>
103135>>>        If (bExistsFrom = False) Begin
103137>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103138>>>        End
103138>>>>
103138>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103139>>>        If (bExistsTo = True) Begin
103141>>>            Move APITableNameInfoCompare.sDisplayNameTo                     to sTo
103142>>>        End
103142>>>>
103142>>>        If (bExistsTo = False) Begin
103144>>>            Move ""                                                         to sTo
103145>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103146>>>        End
103146>>>>
103146>>>        Writeln channel iCh sFrom sTo
103150>>>
103150>>>        If (bExistsFrom = False or bExistsTo = False) Begin
103152>>>            Writeln channel iCh
103154>>>        End
103154>>>>
103154>>>        Writeln channel iCh
103156>>>    End_Procedure
103157>>>
103157>>>    Procedure WriteColumnDiffs String sDriverIDFrom String sDriverIDTo Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DateTime Integer iCh
103160>>>        Integer iSize iCount
103160>>>        Boolean bIsSame bHeader
103160>>>        String sFrom sTo sTypeFrom sTypeTo
103160>>>
103160>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
103161>>>        If (iSize = 0) Begin
103163>>>            Procedure_Return
103164>>>        End
103164>>>>
103164>>>
103164>>>        Decrement iSize
103165>>>        For iCount from 0 to iSize
103171>>>>
103171>>>            Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
103172>>>            If (bIsSame = False) Begin
103174>>>
103174>>>                If (bHeader = False) Begin
103176>>>                    Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
103182>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103185>>>                    Move "FROM Database:" to sFrom
103186>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103187>>>                    Move (sFrom + "TO Database:") to sFrom
103188>>>                    Writeln channel iCh sFrom
103191>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103192>>>                    Writeln channel iCh sFrom
103195>>>                    Move True to bHeader
103196>>>                End
103196>>>>
103196>>>
103196>>>                Get MakeFromString "Field Number:" aAPIColumnCompare[iCount].iFieldNumber (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsFrom to sFrom
103197>>>                Get MakeToString aAPIColumnCompare[iCount].iFieldNumber "" (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103198>>>                Writeln channel iCh sFrom sTo
103202>>>
103202>>>                Get MakeFromString "Field Name" aAPIColumnCompare[iCount].sFieldNameFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsTo to sFrom
103203>>>                Get MakeToString aAPIColumnCompare[iCount].sFieldNameTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) to sTo
103204>>>                Writeln channel iCh sFrom sTo
103208>>>
103208>>>                Get MakeFromString "Type:" aAPIColumnCompare[iCount].sTypeFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103209>>>                Get MakeToString aAPIColumnCompare[iCount].sTypeTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sTypeFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sTypeTo)) to sTo
103210>>>                Writeln channel iCh sFrom sTo
103214>>>
103214>>>                Get MakeFromString "Length:" aAPIColumnCompare[iCount].iLengthFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103215>>>                Get MakeToString aAPIColumnCompare[iCount].iLengthTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iLengthFrom = ;                                 aAPIColumnCompare[iCount].iLengthTo) to sTo
103216>>>                Writeln channel iCh sFrom sTo
103220>>>
103220>>>                Get MakeFromString "Precision:" aAPIColumnCompare[iCount].iPrecisionFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103221>>>                Get MakeToString aAPIColumnCompare[iCount].iPrecisionTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iPrecisionFrom = ;                                 aAPIColumnCompare[iCount].iPrecisionTo) to sTo
103222>>>                Writeln channel iCh sFrom sTo
103226>>>
103226>>>                Get MakeFromString "Default Value:" aAPIColumnCompare[iCount].sDefaultValueFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103227>>>                Get MakeToString aAPIColumnCompare[iCount].sDefaultValueTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].sDefaultValueFrom = ;                                 aAPIColumnCompare[iCount].sDefaultValueTo) to sTo
103228>>>                Writeln channel iCh sFrom sTo
103232>>>
103232>>>                Get MakeFromString "Allow NULL:" (If(aAPIColumnCompare[iCount].bAllowNULLFrom = True, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
103233>>>                Get MakeToString (If(aAPIColumnCompare[iCount].bAllowNULLTo = True, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103234>>>                Writeln channel iCh sFrom sTo
103238>>>
103238>>>                Get MakeFromString "Identity Field:" (If(aAPIColumnCompare[iCount].iOptionsFrom = C_tAPIColumn_Identity, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
103239>>>                Get MakeToString (If(aAPIColumnCompare[iCount].iOptionsTo = C_tAPIColumn_Identity, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103240>>>                Writeln channel iCh sFrom sTo
103244>>>                Writeln channel iCh
103246>>>            End
103246>>>>
103246>>>        Loop
103247>>>>
103247>>>
103247>>>        If (bHeader = True) Begin
103249>>>            Writeln channel iCh ""
103252>>>        End
103252>>>>
103252>>>    End_Procedure
103253>>>
103253>>>    Procedure WriteIndexDiffs Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sLogicalTableName tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh
103256>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2 iFieldNumberFrom iFieldNumberTo
103256>>>        Integer iIndexNumberFrom iIndexNumberTo iPrimaryIndexFrom iPrimaryIndexTo
103256>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
103256>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
103259>>>        String sFrom sTo sSQLIndexTypeFrom sSQLIndexTypeTo sSQLIndexNameFrom sSQLIndexNameTo sFieldNameFrom sFieldNameTo
103259>>>        Boolean bIsSame bIsSQLPrimaryFrom bIsSQLPrimaryTo bIsSQLClusteredFrom bIsSQLClusteredTo bHeader
103259>>>
103259>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
103260>>>        Decrement iSize
103261>>>
103261>>>        For iCount from 0 to iSize
103267>>>>
103267>>>            Get UtilIndexCompare of ghoDbUpdateFunctionLibrary bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexAscending bCompareIndexUppercase to bIsSame
103268>>>            If (bIsSame = False) Begin
103270>>>                If (bHeader = False) Begin
103272>>>                    Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
103278>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103281>>>                    Move "FROM Database:" to sFrom
103282>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103283>>>                    Move (sFrom + "TO Database:") to sFrom
103284>>>                    Writeln channel iCh sFrom
103287>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103288>>>                    Writeln channel iCh sFrom
103291>>>                    Move True to bHeader
103292>>>                End
103292>>>>
103292>>>
103292>>>                // FROM Index:
103292>>>                If (aAPIIndexCompare[iCount].bExistsFrom = True) Begin
103294>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberFrom
103295>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexFrom         to iPrimaryIndexFrom
103296>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameFrom         to sSQLIndexNameFrom
103297>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom      to bIsSQLPrimaryFrom
103298>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredFrom       to bIsSQLClusteredFrom
103299>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                         aAPIIndexCompare[iCount].iSQLIndexTypeFrom         to sSQLIndexTypeFrom
103300>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayFrom     to aApiIndexSegmentsFrom
103301>>>                End
103301>>>>
103301>>>                Else Begin
103302>>>                    Move -1                                                 to iIndexNumberFrom
103303>>>                    Move -1                                                 to iPrimaryIndexFrom
103304>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameFrom
103305>>>                    Move False                                              to bIsSQLPrimaryFrom
103306>>>                    Move False                                              to bIsSQLClusteredFrom
103307>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeFrom
103308>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsFrom
103309>>>                End
103309>>>>
103309>>>
103309>>>                If (aAPIIndexCompare[iCount].bExistsTo = True) Begin
103311>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberTo
103312>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexTo           to iPrimaryIndexTo
103313>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameTo           to sSQLIndexNameTo
103314>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyTo        to bIsSQLPrimaryTo
103315>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredTo         to bIsSQLClusteredTo
103316>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                        aAPIIndexCompare[iCount].iSQLIndexTypeTo            to sSQLIndexTypeTo
103317>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayTo       to aApiIndexSegmentsTo
103318>>>                End
103318>>>>
103318>>>                Else Begin
103319>>>                    Move -1                                                 to iIndexNumberTo
103320>>>                    Move -1                                                 to iPrimaryIndexTo
103321>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameTo
103322>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
103323>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLClusteredTo
103324>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeTo
103325>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
103326>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsTo
103327>>>                End
103327>>>>
103327>>>
103327>>>                Get MakeFromString "Index Number:" iIndexNumberFrom CS_ReportIndexNotFound (iIndexNumberFrom <> -1) to sFrom
103328>>>                Get MakeToString iIndexNumberTo "" (CS_ReportIndexNotFound * String(CS_ReportDifferenceNote)) (iIndexNumberTo <> -1) to sTo
103329>>>                Writeln channel iCh sFrom sTo
103333>>>
103333>>>                Get MakeFromString "Primary Idx #:" iPrimaryIndexFrom CS_ReportDifferenceNote (iPrimaryIndexFrom <> -1) to sFrom
103334>>>                Get MakeToString iPrimaryIndexTo "" CS_ReportDifferenceNote (iPrimaryIndexTo <> -1) to sTo
103335>>>                Writeln channel iCh sFrom sTo
103339>>>
103339>>>                // SQL Index info:
103339>>>                If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
103341>>>                    Get MakeFromString "SQL Name:" sSQLIndexNameFrom CS_ReportDifferenceNote (sSQLIndexNameFrom <> "") to sFrom
103342>>>                    Get MakeToString sSQLIndexNameTo "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and Uppercase(sSQLIndexNameFrom) = Uppercase(sSQLIndexNameTo)) to sTo
103343>>>                    Writeln channel iCh sFrom sTo
103347>>>
103347>>>                    Get MakeFromString "SQL Primary:" (If(bIsSQLPrimaryFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
103348>>>                    Get MakeToString (If(bIsSQLPrimaryTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLPrimaryFrom = bIsSQLPrimaryTo) to sTo
103349>>>                    Writeln channel iCh sFrom sTo
103353>>>
103353>>>                    Get MakeFromString "SQL Clustered:" (If(bIsSQLClusteredFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
103354>>>                    Get MakeToString (If(bIsSQLClusteredTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLClusteredFrom = bIsSQLClusteredTo) to sTo
103355>>>                    Writeln channel iCh sFrom sTo
103359>>>
103359>>>                    Get MakeFromString "SQL Type:" sSQLIndexTypeFrom CS_ReportDifferenceNote True to sFrom
103360>>>                    Get MakeToString sSQLIndexTypeTo "" CS_ReportDifferenceNote True to sTo
103361>>>                    Writeln channel iCh sFrom sTo
103365>>>                End
103365>>>>
103365>>>
103365>>>                // Index Segments:
103365>>>                Move (SizeOfArray(aApiIndexSegmentsFrom)) to iSegmentSizeFrom
103366>>>                Move (SizeOfArray(aApiIndexSegmentsTo))   to iSegmentSizeTo
103367>>>
103367>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
103368>>>                Decrement iSize2
103369>>>                If (iSize2 > -1) Begin
103371>>>                    Writeln channel iCh
103373>>>                End
103373>>>>
103373>>>
103373>>>                For iCount2 from 0 to iSize2
103379>>>>
103379>>>                    Move "" to sFieldNameFrom
103380>>>                    Move "" to sFieldNameTo
103381>>>                    Get MakeStringLength "Field# & Name:" CI_ReportColumn1               to sFrom
103382>>>                    If (iCount2 < iSegmentSizeFrom) Begin
103384>>>                        Move aApiIndexSegmentsFrom[iCount2].iFieldNumber                 to iFieldNumberFrom
103385>>>                        Move (sFrom + String(iFieldNumberFrom))                          to sFrom
103386>>>                        Move (String(aApiIndexSegmentsFrom[iCount2].sFieldName))         to sFieldNameFrom
103387>>>                        Move (sFrom * String(sFieldNameFrom))                            to sFrom
103388>>>                    End
103388>>>>
103388>>>                    Else Begin
103389>>>                        Move 0                                                           to iFieldNumberFrom
103390>>>                        Move (sFrom + CS_ReportIndexSegmentNotFound)                     to sFrom
103391>>>                    End
103391>>>>
103391>>>                    Get MakeStringLength sFrom CI_ReportColumn2                          to sFrom
103392>>>
103392>>>                    Move ""                                                              to sTo
103393>>>                    If (iIndexNumberTo <> -1) Begin
103395>>>                        Move aApiIndexSegmentsTo[iCount2].iFieldNumber                   to iFieldNumberTo
103396>>>                        Move (String(iFieldNumberTo))                                    to sTo
103397>>>                        Move (String(aApiIndexSegmentsTo[iCount2].sFieldName))           to sFieldNameTo
103398>>>                        Move (sTo * String(sFieldNameTo))                                to sTo
103399>>>                    End
103399>>>>
103399>>>                    If (iFieldNumberFrom <> iFieldNumberTo or Uppercase(sFieldNameFrom) <> Uppercase(sFieldNameTo)) Begin
103401>>>                        Move (sTo + String(CS_ReportDifferenceNote))                     to sTo
103402>>>                    End
103402>>>>
103402>>>                    Writeln channel iCh sFrom sTo
103406>>>
103406>>>                    // Uppercase Index Segment:
103406>>>                    If (bCompareIndexUppercase = True) Begin
103408>>>                        Get MakeStringLength "Uppercase:" CI_ReportColumn1                                        to sFrom
103409>>>                        If (bIsSqlTableFrom = True) Begin
103411>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
103412>>>                        End
103412>>>>
103412>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
103415>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom
103416>>>                        End
103416>>>>
103416>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
103417>>>                        Move "" to sTo
103418>>>                        If (bIsSqlTableFrom = True) Begin
103420>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
103421>>>                        End
103421>>>>
103421>>>                        Else If (iCount <= iSegmentSizeTo) Begin
103424>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No")))           to sTo
103425>>>                        End
103425>>>>
103425>>>                        Writeln channel iCh sFrom sTo
103429>>>                    End
103429>>>>
103429>>>
103429>>>                    // Ascending/Descending Index:
103429>>>                    If (bCompareIndexAscending = True) Begin
103431>>>                        Get MakeStringLength "Ascending:" CI_ReportColumn1                                        to sFrom
103432>>>                        If (bIsSqlTableFrom = True) Begin
103434>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
103435>>>                        End
103435>>>>
103435>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
103438>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom
103439>>>                        End
103439>>>>
103439>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
103440>>>                        Move "" to sTo
103441>>>                        If (bIsSqlTableFrom = True) Begin
103443>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
103444>>>                        End
103444>>>>
103444>>>                        Else If (iCount <= iSegmentSizeTo) Begin
103447>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No")))           to sTo
103448>>>                        End
103448>>>>
103448>>>                        Writeln channel iCh sFrom sTo
103452>>>                    End
103452>>>>
103452>>>                Loop
103453>>>>
103453>>>                Writeln channel iCh ""
103456>>>            End
103456>>>>
103456>>>        Loop
103457>>>>
103457>>>
103457>>>        If (bHeader = True) Begin
103459>>>            Writeln channel iCh ""
103462>>>        End
103462>>>>
103462>>>    End_Procedure
103463>>>
103463>>>    Procedure WriteRelationDiffs Handle hTable tAPIRelationCompare[] aAPIRelationCompare Integer iCh
103466>>>        Integer iSizeFrom iSize iCount iRow iItem
103466>>>        Boolean bExists bIsSame bHeader
103466>>>        String sFrom sTo sFromFieldsRight sFromFields sToFields sLogicalNameFrom
103466>>>        tRelationDiffs[] asRelationDiffs
103466>>>        tRelationDiffs[] asRelationDiffs
103467>>>
103467>>>
103467>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
103468>>>        Decrement iSize
103469>>>        For iCount from 0 to iSize
103475>>>>
103475>>>            Get UtilRelationCompare of ghoDbUpdateFunctionLibrary hTable aAPIRelationCompare[iCount] to bIsSame
103476>>>            If (bIsSame = False) Begin
103478>>>                If (bHeader = False) Begin
103480>>>                    Move aAPIRelationCompare[iCount].sLogicalNameFrom_From   to sLogicalNameFrom
103481>>>                    If (sLogicalNameFrom = "") Begin
103483>>>                        Move aAPIRelationCompare[iCount].sLogicalNameFrom_To to sLogicalNameFrom
103484>>>                    End
103484>>>>
103484>>>                    Writeln channel iCh ""
103487>>>                    Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " sLogicalNameFrom
103493>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103496>>>                    Move "FROM Database:" to sFrom
103497>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103498>>>                    Move (sFrom + "TO Database:") to sFrom
103499>>>                    Writeln channel iCh sFrom
103502>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103503>>>                    Writeln channel iCh sFrom
103506>>>                    Move True to bHeader
103507>>>                End
103507>>>>
103507>>>
103507>>>                // FROM Relation:
103507>>>                Get MakeStringLength "Table.Field:" CI_ReportColumn1                            to sFrom
103508>>>                If (aAPIRelationCompare[iCount].bExistsFrom = True) Begin
103510>>>                    Move (sFrom + String(aAPIRelationCompare[iCount].hTableFrom)   + "." ;                                + String(aAPIRelationCompare[iCount].iColumnFrom)  * "->")      to sFrom
103511>>>                    Move (sFrom * String(aAPIRelationCompare[iCount].hTableTo)     + "." ;                                + String(aAPIRelationCompare[iCount].iColumnTo))                to sFrom
103512>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103513>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_From) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_From)   * "->")     to sFromFields
103514>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameTo_From)   + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_From))                to sFromFieldsRight
103515>>>                End
103515>>>>
103515>>>                Else Begin
103516>>>                    Move (String(CS_ReportRelationNotFound) * String(CS_ReportDifferenceNote))  to sFrom
103517>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103518>>>                    Move (String(CS_ReportDifferenceNote))                                      to sFromFields
103519>>>                    Move ""                                                                     to sFromFieldsRight
103520>>>                    Move iCount                                                                 to iItem
103521>>>                End
103521>>>>
103521>>>                Move (sFromFields * String(sFromFieldsRight))                                   to sFromFields
103522>>>                Get MakeStringLength sFromFields CI_ReportColumn2                               to sFromFields
103523>>>
103523>>>                // TO Relation:
103523>>>                If (aAPIRelationCompare[iCount].bExistsTo = True) Begin
103525>>>                    Move (String(aAPIRelationCompare[iCount].hTableFrom)           + "." ;                        + String(aAPIRelationCompare[iCount].iColumnFrom)          * "->")      to sTo
103526>>>                    Move (sTo * String(aAPIRelationCompare[iCount].hTableTo)       + "." ;                        + String(aAPIRelationCompare[iCount].iColumnTo))                        to sTo
103527>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_To)  + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_To)    * "->")      to sToFields
103528>>>                    Move (sToFields * String(aAPIRelationCompare[iCount].sLogicalNameTo_To) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_To))                  to sToFields
103529>>>                End
103529>>>>
103529>>>                Else Begin
103530>>>                    Move (CS_ReportRelationNotFound * String(CS_ReportDifferenceNote))          to sTo
103531>>>                    Move (String(CS_ReportDifferenceNote))                                      to sToFields
103532>>>                End
103532>>>>
103532>>>
103532>>>                Move sFromFieldsRight to asRelationDiffs[iRow].sFromFieldsRight
103533>>>                Move sFrom to asRelationDiffs[iRow].sFrom
103534>>>                Move sTo   to asRelationDiffs[iRow].sTo
103535>>>                Move sFromFields to asRelationDiffs[iRow].sFromFields
103536>>>                Move sToFields   to asRelationDiffs[iRow].sToFields
103537>>>                If (iCount < iSize) Begin
103539>>>                    Increment iRow
103540>>>                    Move "" to asRelationDiffs[iRow].sFrom
103541>>>                    Move "" to asRelationDiffs[iRow].sTo
103542>>>                End
103542>>>>
103542>>>                Else Begin
103543>>>                    Increment iRow
103544>>>                End
103544>>>>
103544>>>            End
103544>>>>
103544>>>        Loop
103545>>>>
103545>>>
103545>>>        // We put all relations in an array struct so we can sort it alphatically.
103545>>>        // This is to show multiple field relations from one table to another next to each other, just as the Studio does.
103545>>>        Move (SortArray(asRelationDiffs))   to asRelationDiffs
103546>>>        Move (SizeOfArray(asRelationDiffs)) to iSizeFrom
103547>>>        Decrement iSizeFrom
103548>>>        For iCount from 0 to iSizeFrom
103554>>>>
103554>>>            Writeln channel iCh asRelationDiffs[iCount].sFrom       asRelationDiffs[iCount].sTo
103558>>>            Writeln channel iCh asRelationDiffs[iCount].sFromFields asRelationDiffs[iCount].sToFields
103562>>>            Writeln channel iCh
103564>>>        Loop
103565>>>>
103565>>>
103565>>>        If (bHeader = True) Begin
103567>>>            Writeln channel iCh ""
103570>>>        End
103570>>>>
103570>>>    End_Procedure
103571>>>
103571>>>    Procedure WriteReportFooter Integer iSize Boolean bCollationDiff Integer iCh DateTime dtExecStart
103574>>>        DateTime dtExecEnd
103574>>>        TimeSpan tsTotalTime
103574>>>
103574>>>        Move (CurrentDateTime()) to dtExecEnd
103575>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
103576>>>
103576>>>        Writeln channel iCh
103578>>>        Writeln channel iCh "SUMMARY:  [Total Elapsed Time: " tsTotalTime "]"
103583>>>        Writeln channel iCh CS_ReportHeaderUnderWrite               
103586>>>        If (bCollationDiff = False) Begin
103588>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103592>>>        End 
103592>>>>
103592>>>        Else Begin
103593>>>            If (iSize <> 0) Begin
103595>>>                Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103599>>>            End
103599>>>>
103599>>>            Writeln channel iCh "*** IMPORTANT: The SQL collation used for the 'FROM' and 'TO' database are different! ***"
103602>>>            Writeln channel iCh 
103604>>>        End
103604>>>>
103604>>>        
103604>>>        If (iSize = 0) Begin
103606>>>            Writeln channel iCh "*** No table differences found. All tables should be identical! ***"
103609>>>        End
103609>>>>
103609>>>
103609>>>        Send Seq_Close_Channel iCh
103610>>>    End_Procedure
103611>>>
103611>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
103614>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
103615>>>
103615>>>        Function_Return sValue
103616>>>    End_Function
103617>>>
103617>>>    Function MakeFromString String sStartText String sText String sMissingText Boolean bExists Returns String
103620>>>        String sFrom
103620>>>
103620>>>        Get MakeStringLength sStartText CI_ReportColumn1 to sFrom
103621>>>        If (bExists = True) Begin
103623>>>            Move (sFrom + String(sText)) to sFrom
103624>>>        End
103624>>>>
103624>>>        Else Begin
103625>>>            Move (sFrom + String(sMissingText)) to sFrom
103626>>>        End
103626>>>>
103626>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103627>>>
103627>>>        Function_Return sFrom
103628>>>    End_Function
103629>>>
103629>>>    Function MakeToString String sStartText String sText String sMissingText Boolean bSame Returns String
103632>>>        String sTo
103632>>>
103632>>>        Move (String(sStartText) * String(sText)) to sTo
103633>>>        If (bSame = False) Begin
103635>>>            If (sTo <> "-1") Begin
103637>>>                Move (sTo * String(sMissingText)) to sTo
103638>>>            End
103638>>>>
103638>>>            Else Begin
103639>>>                Move (String(sMissingText)) to sTo
103640>>>            End
103640>>>>
103640>>>        End
103640>>>>
103640>>>
103640>>>        Function_Return sTo
103641>>>    End_Function
103642>>>
103642>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
103645>>>        Integer iSizeFrom iSizeTo
103645>>>        Handle hTableFrom hTableTo
103645>>>        String sLogicalName
103645>>>
103645>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
103646>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
103647>>>
103647>>>        Move -1 to hTableFrom
103648>>>        Move -1 to hTableTo
103649>>>        Move iCount to iItemFrom
103650>>>        Move iCount to iItemTo
103651>>>
103651>>>        // The two struct arrays may be different in size (contain different number of items/tables).
103651>>>        //
103651>>>        // To avoid "Referenced Array Index Out of Bounds" error.
103651>>>        If (iCount < iSizeFrom) Begin
103653>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
103654>>>        End
103654>>>>
103654>>>        If (iCount < iSizeTo) Begin
103656>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
103657>>>        End
103657>>>>
103657>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
103659>>>            Move (hTableFrom min hTableTo)                to hTable
103660>>>        End
103660>>>>
103660>>>        Else Begin
103661>>>            Move (hTableFrom max hTableTo)                to hTable
103662>>>        End
103662>>>>
103662>>>
103662>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
103664>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103665>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103666>>>        End
103666>>>>
103666>>>
103666>>>        // If the 'TO' table number is lower than 'FROM'
103666>>>        Else If (iCount < iSizeTo) Begin
103669>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103670>>>            Get FindTableNumber (&aFromStructure) hTable to iItemFrom
103671>>>        End
103671>>>>
103671>>>        Else If (iCount = iSizeTo) Begin
103674>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103675>>>        End
103675>>>>
103675>>>
103675>>>        Function_Return sLogicalName
103676>>>    End_Function
103677>>>
103677>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
103680>>>        Integer iSize iCount iTable iItem
103680>>>        tAPITableNameInfo ApiTableNameInfo
103680>>>        tAPITableNameInfo ApiTableNameInfo
103680>>>
103680>>>        Move -1 to iItem
103681>>>        Move (SizeOfArray(aTableStructure)) to iSize
103682>>>        Decrement iSize
103683>>>        For iCount from 0 to iSize
103689>>>>
103689>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
103690>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
103692>>>                Move iCount to iItem
103693>>>                Move iSize  to iCount // We're done.
103694>>>            End
103694>>>>
103694>>>        Loop
103695>>>>
103695>>>
103695>>>        Function_Return iItem
103696>>>    End_Function
103697>>>
103697>>>    // Pass one tAPIRelation for the FROM database and a struct array with relations for the TO database
103697>>>    // Returns the item number in the aAPIRelationsTO that equals the FROM relation struct data.
103697>>>    // If not found returns -1.
103697>>>//    Function FindEqualRelation tAPIRelation APIRelationFrom tAPIRelation[] aAPIRelationsTO Returns Integer
103697>>>//        Integer iRetval iSize iCount
103697>>>//
103697>>>//        Move -1 to iRetval
103697>>>//        Move (SizeOfArray(aAPIRelationsTO)) to iSize
103697>>>//        Decrement iSize
103697>>>//        For iCount from 0 to iSize
103697>>>//            If (APIRelationFrom.hTableFrom  = aAPIRelationsTO[iCount].hTableFrom  and ;
103697>>>//                APIRelationFrom.iColumnFrom = aAPIRelationsTO[iCount].iColumnFrom and ;
103697>>>//                APIRelationFrom.hTableTo    = aAPIRelationsTO[iCount].hTableTo    and ;
103697>>>//                APIRelationFrom.iColumnTo   = aAPIRelationsTO[iCount].iColumnTo) Begin
103697>>>//                    Move iCount to iRetval
103697>>>//                End
103697>>>//        Loop
103697>>>//
103697>>>//        Function_Return iRetval
103697>>>//    End_Function
103697>>>
103697>>>    // Returns a value <> -1 if the passed iIndex was found in the APIIndex struct array.
103697>>>    // The value returned is the item number, else a -1.
103697>>>//    Function FindIndexInArray Integer iIndex tAPIIndex[] APIIndex Returns Integer
103697>>>//        Integer iRetval iSize iCount iCompareIndex
103697>>>//
103697>>>//        Move -1 to iRetval
103697>>>//        Move (SizeOfArray(APIIndex)) to iSize
103697>>>//        Decrement iSize
103697>>>//        For iCount from 0 to iSize
103697>>>//            If (iIndex = APIIndex[iCount].iIndexNumber) Begin
103697>>>//                Move iCount to iRetval
103697>>>//            End
103697>>>//        Loop
103697>>>//        Function_Return iRetval
103697>>>//    End_Function
103697>>>
103697>>>    Procedure Request_Clear
103700>>>        tSQLConnection Connection
103700>>>        tSQLConnection Connection
103700>>>        Integer[] iDifferencesEmpty
103701>>>
103701>>>        Move DATAFLEX_ID to Connection.sDriverID
103702>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
103703>>>        Set Value of oFilelistPathFrom_fm   to ""
103704>>>        Set Value of oFilelistPathTo_fm     to ""
103705>>>        Set Value of oReportFileName_fm     to ""
103706>>>        Set psFilelistFrom of ghoApplication to ""
103707>>>        Set piaDifferences of ghoApplication to iDifferencesEmpty
103708>>>
103708>>>        Send Activate of oFilelistPathFrom_fm
103709>>>    End_Procedure
103710>>>
103710>>>    Object oBusinessProcess is a BusinessProcess
103712>>>        Set Status_Panel_Id to ghoStatusPanel
103713>>>        Set Allow_Cancel_State to True
103714>>>        Set Process_Caption to "The Database Update Framework"
103715>>>        Set Process_Title to "Comparing Database Structures..."
103716>>>//        Set Display_Error_State to True // Temp!
103716>>>
103716>>>        Procedure OnProcess
103719>>>            Send MainProcess
103720>>>        End_Procedure
103721>>>
103721>>>        Procedure Ignore_Error Integer iError
103724>>>        End_Procedure
103725>>>        Procedure Trap_Error Integer iError
103728>>>        End_Procedure
103729>>>
103729>>>    End_Object
103730>>>
103730>>>    Object oCompare_btn is a cRDCCommandLinkButton
103732>>>        Set Size to 36 166
103733>>>        Set Location to 276 139
103734>>>        Set Label to "Co&mpare Databases!"
103735>>>        Set psNote to "Compare the two selected databases."
103736>>>        Set psImage to "DbCompare1.ico"
103737>>>        Set Default_State to True
103738>>>        Set psToolTip to "Start the compare process"
103739>>>        Set piImageSize to 32 // 48
103740>>>        Set peAnchors to anBottomRight
103741>>>
103741>>>        Procedure OnClick
103744>>>            String sFilelistFrom sFilelistTo
103744>>>            Integer[] iaDifferences
103745>>>            Boolean bFromExists bToExists
103745>>>
103745>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
103746>>>            Get vFilePathExists sFilelistFrom to bFromExists
103747>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
103748>>>            Get vFilePathExists sFilelistTo   to bToExists
103749>>>            If (bFromExists = False or bToExists = False) Begin
103751>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
103752>>>                Procedure_Return
103753>>>            End
103753>>>>
103753>>>
103753>>>            Send DoProcess of oBusinessProcess
103754>>>            Send Restore_DF_OPEN_PATH of ghoApplication
103755>>>        End_Procedure
103756>>>
103756>>>        Function IsEnabled Returns Boolean
103759>>>            String sFileListFrom sFileListTo
103759>>>            Boolean bExists bState
103759>>>
103759>>>            Get Value of oFilelistPathFrom_fm to sFileListFrom
103760>>>            Get vFilePathExists sFileListFrom to bExists
103761>>>            If (bExists = False) Begin
103763>>>                Function_Return False
103764>>>            End
103764>>>>
103764>>>            Get Value of oFilelistPathTo_fm to sFileListTo
103765>>>            Get vFilePathExists sFileListTo to bExists
103766>>>            Get Enabled_State to bState
103767>>>            If (bState = False and bExists = False) Begin
103769>>>                Function_Return False
103770>>>            End
103770>>>>
103770>>>            Function_Return bExists
103771>>>        End_Function
103772>>>
103772>>>    End_Object
103773>>>
103773>>>    Object oViewReport_Btn is a cRDCCommandLinkButton
103775>>>        Set Size to 36 77
103776>>>        Set Location to 276 315
103777>>>        Set Label to "&Report"
103778>>>        Set psNote to "View report"
103779>>>        Set peAnchors to anBottomRight
103780>>>        Set psImage to "ViewReport1.ico"
103781>>>        Set psToolTip to "Open the folder where the report was generated. (Ctrl+R)"
103782>>>        Set piImageSize to 16 //24
103783>>>
103783>>>        Procedure OnClick
103786>>>            Send DoShowReport
103787>>>        End_Procedure
103788>>>        
103788>>>        Procedure DoShowReport
103791>>>            String sReportName
103791>>>            Get Value of oReportFileName_fm to sReportName
103792>>>            Send ActivateLogFileDialog of (Client_Id(ghoCommandBars)) sReportName
103793>>>//            Runprogram Shell Background sReportName
103793>>>        End_Procedure
103794>>>
103794>>>        Function IsEnabled Returns Boolean
103797>>>            String sReportName
103797>>>            Boolean bExists
103797>>>
103797>>>            Get Value of oReportFileName_fm to sReportName
103798>>>            Get vFilePathExists sReportName to bExists
103799>>>            Function_Return bExists
103800>>>        End_Function
103801>>>
103801>>>    End_Object
103802>>>
103802>>>    Object oTagFilelist_Btn is a cRDCCommandLinkButton
103804>>>        Set Size to 36 76
103805>>>        Set Location to 276 402
103806>>>        Set Label to "&Tag"
103807>>>        Set psNote to "Tag differences"
103808>>>        Set peAnchors to anBottomRight
103809>>>        Set MultiLineState to True
103810>>>        Set Border_Style to Border_Normal
103811>>>        Set peImageAlign to Button_ImageList_Align_Center
103812>>>        Set psImage to "SelectInvert1.ico"
103813>>>        Set psToolTip to "Tag Tables for the 'FROM' Filelist.cfg with differences - for code generation on the 'Code Generator' view page."
103814>>>        Set pbAutoEnable to True
103815>>>        Set piImageSize to 16 // 24
103816>>>
103816>>>        Procedure OnClick
103819>>>            String sFileListFrom
103819>>>            Get Value of oFilelistPathFrom_fm    to sFileListFrom
103820>>>            Set psFilelistFrom of ghoApplication to sFileListFrom
103821>>>            Send TagFileNamesForCodeGeneration
103822>>>        End_Procedure
103823>>>
103823>>>        Function IsEnabled Returns Boolean
103826>>>            Integer[] iaDifferences
103827>>>            Get piaDifferences of ghoApplication to iaDifferences
103828>>>            Function_Return (SizeOfArray(iaDifferences))
103829>>>        End_Function
103830>>>
103830>>>    End_Object
103831>>>
103831>>>    Procedure OnSetFocus
103834>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
103836>>>            Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
103837>>>        End
103837>>>>
103837>>>    End_Procedure
103838>>>    
103838>>>    Procedure OnFileDropped String sFilename Boolean bLast
103841>>>        String sTest sFileListFrom sFileListTo
103841>>>
103841>>>        Forward Send OnFileDropped sFilename bLast
103843>>>        Get Value of oFilelistPathFrom_fm to sFileListFrom
103844>>>        Get Value of oFilelistPathTo_fm    to sFileListTo
103845>>>        If (bLast = True) Begin
103847>>>            Get ParseFileName sFilename to sTest
103848>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
103850>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
103851>>>                Procedure_Return
103852>>>            End                                           
103852>>>>
103852>>>            If (sFileListFrom = "") Begin
103854>>>                Set Value of oFilelistPathFrom_fm to sFilename
103855>>>            End 
103855>>>>
103855>>>            Else Begin
103856>>>                Set Value of oFilelistPathTo_fm to sFilename
103857>>>            End
103857>>>>
103857>>>                
103857>>>        End
103857>>>>
103857>>>    End_Procedure
103858>>>
103858>>>    On_Key Key_Ctrl+Key_M  Send KeyAction of oCompare_btn
103859>>>    On_Key Key_Ctrl+Key_R  Send KeyAction of oViewReport_Btn
103860>>>    On_Key Key_Ctrl+Key_T  Send KeyAction of oTagFilelist_Btn
103861>>>    On_Key kClear          Send Request_Clear
103862>>>    On_Key kClear_All      Send Request_Clear
103863>>>    On_Key Key_Ctrl+Key_F4 Send None
103864>>>End_Object
103865>
103865>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\StdAbout.pkg)
103865>>>//************************************************************************
103865>>>// Confidential Trade Secret.
103865>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
103865>>>// as an unpublished work.  All rights reserved.
103865>>>// DataFlex is a registered trademark of Data Access Corporation.
103865>>>//
103865>>>//************************************************************************
103865>>>//************************************************************************
103865>>>//
103865>>>// $File name  : StdAbout.pkg
103865>>>// $File title : Standard about object package for VDF
103865>>>// Notice      :
103865>>>// $Author(s)  : John Tuohy
103865>>>//
103865>>>// $Rev History
103865>>>//
103865>>>// JT 06/27/97   File created
103865>>>//************************************************************************
103865>>>
103865>>>// This provides a quick and simple way to create an about package for a program.
103865>>>// You need to create a message inside you client area called Activate_About.
103865>>>// Within this message you should send the message DoAbout passing needed
103865>>>// string information.
103865>>>//
103865>>>//       Procedure Activate_About
103865>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
103865>>>//       End_Procedure
103865>>>//    where: sTitle =     Name of application. If none provided, uses caption
103865>>>//                        bar title
103865>>>//           sVersion   = Version Line. If none provided, will be blank
103865>>>//           sCopyRight = Copyright Line. If none provided, will be blank
103865>>>//           sAuthor    = Author name, blank if none provided
103865>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
103865>>>//                        is used.
103865>>>// It is expected that you will place this in your own object package. For
103865>>>// example an order about package may look like this:
103865>>>//
103865>>>//   // OrderAbout.pkg
103865>>>//   Use StdAbout.pkg
103865>>>//   Procedure Activate_About
103865>>>//      String sTitle sCopyright sVersion sAuthor
103865>>>//      Move "My Order Entry System" to sTitle
103865>>>//      Move "Version 2.1" to sVersion
103865>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
103865>>>//      Move "John Smith"  to sAuthor
103865>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
103865>>>//   end_procedure
103865>>>//   // end of file.
103865>>>
103865>>>Use DfAbout.pkg
103865>>>
103865>>>// *************************************************************************
103865>>>//  Public message. This is the default message. It is expected that you will
103865>>>//   create your own message to override this
103865>>>// *************************************************************************
103865>>>
103865>>>Procedure Activate_About
103868>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
103869>>>End_Procedure
103870>>>
103870>>>// *************************************************************************
103870>>>//  Public message. It is expected that you will send this message (most
103870>>>//  likely from Activate_About. This creates an about object, activates it
103870>>>//  and destroys it when done. It is not exepected that you will augment this.
103870>>>// *************************************************************************
103870>>>// Sample usage:
103870>>>//   The first two params will automatically be filled from the application settings if not provided.
103870>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
103870>>>
103870>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
103873>>>    Integer hoObj hoMain iArgs
103873>>>    String sValue
103873>>>
103873>>>    // Create object
103873>>>    Object About is an AboutDialog
103875>>>    // Uncomment these two lines if you would like to have a resizable About object.
103875>>>    //            Set Border_Style to Border_Thick
103875>>>    //            Set peAnchors to anAll
103875>>>
103875>>>    // Add checking for the number of arguments passed to avoid runtime errors
103875>>>    // if one of them is not passed. This makes the interface
103875>>>    // more flexible.
103875>>>        Move num_arguments to iArgs
103876>>>
103876>>>        // If no title is passed use the label of the main panel (if a main panel exists).
103876>>>        If (iArgs > 0 and sTitle = "") Begin
103878>>>            Get Main_Window of Desktop to hoMain
103879>>>            If hoMain Begin
103881>>>                Get Label of hoMain to sValue
103882>>>            End
103882>>>>
103882>>>        End
103882>>>>
103882>>>        Else If (iArgs > 0 and sTitle <> "") Begin
103885>>>            Move sTitle to sValue
103886>>>        End
103886>>>>
103886>>>        Else If (iArgs = 0) Begin
103889>>>            Get Main_Window of Desktop to hoMain
103890>>>            If hoMain Begin
103892>>>                Get Label of hoMain to sValue
103893>>>            End
103893>>>>
103893>>>        End
103893>>>>
103893>>>
103893>>>        If (sValue <> "") Begin
103895>>>            Send Add_LineLn sValue
103896>>>        End
103896>>>>
103896>>>        Move "" to sValue
103897>>>
103897>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
103897>>>        // For this to work the Project Properties Version must have been set in the Studio.
103897>>>        If (iArgs < 2) Begin
103899>>>            Move "" to sValue
103900>>>        End
103900>>>>
103900>>>        Else Begin
103901>>>            Move sVersion to sValue
103902>>>        End
103902>>>>
103902>>>        Set Version to sValue
103903>>>
103903>>>        If (iArgs > 2 and sCopyRight <> "") Begin
103905>>>            Send Add_LineLn sCopyRight
103906>>>        End
103906>>>>
103906>>>
103906>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
103906>>>        // else we do.
103906>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
103908>>>            Send Add_Line sAuthor
103909>>>        End
103909>>>>
103909>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
103912>>>            Send Add_LineLn sAuthor
103913>>>        End
103913>>>>
103913>>>
103913>>>        // Square bitmaps of 80x80 works best
103913>>>        If (iArgs > 4 and sBitmap <> "") Begin
103915>>>            Set Logo to sBitMap
103916>>>        End
103916>>>>
103916>>>
103916>>>        // Here starts handling of the five optional params:
103916>>>        If (iArgs = 6 and sParam6  <> "") Begin
103918>>>            Send Add_Line sParam6
103919>>>        End
103919>>>>
103919>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
103922>>>            Send Add_LineLn sParam6
103923>>>        End
103923>>>>
103923>>>
103923>>>        If (iArgs = 7 and sParam7  <> "") Begin
103925>>>            Send Add_Line sParam7
103926>>>        End
103926>>>>
103926>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
103929>>>            Send Add_LineLn sParam7
103930>>>        End
103930>>>>
103930>>>
103930>>>        If (iArgs = 8 and sParam8  <> "") Begin
103932>>>            Send Add_Line sParam8
103933>>>        End
103933>>>>
103933>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
103936>>>            Send Add_LineLn sParam8
103937>>>        End
103937>>>>
103937>>>
103937>>>        If (iArgs = 9 and sParam9  <> "") Begin
103939>>>            Send Add_Line sParam9
103940>>>        End
103940>>>>
103940>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
103943>>>            Send Add_LineLn sParam9
103944>>>        End
103944>>>>
103944>>>
103944>>>        If (iArgs = 10 and sParam10 <> "") Begin
103946>>>            Send Add_Line sParam10
103947>>>        End
103947>>>>
103947>>>
103947>>>        Move Self to hoObj
103948>>>    End_Object
103949>>>
103949>>>    Send Popup   of hoObj // Popup the about object
103950>>>    Send Destroy of hoObj // When done, it will be destroyed
103951>>>End_Procedure
103952>        Use CompareDatabases.rv
Including file: CompareDatabases.rv    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.rv)
103952>>>Use Windows.pkg
103952>>>Use DFRptVw.pkg
103952>>>Use DFRpt.pkg
103952>>>Use File_Dlg.Pkg
103952>>>Use CompareDatabases.img
Including file: CompareDatabases.img    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.img)
103952>>>>>// CompareDatabases Basic Report
103952>>>>>// Since report images, such as the one used here, are not fully supported by
103952>>>>>// the Studio, the images for this report are placed in a separate package.
103952>>>>>//
/HEADER
Image 1, HEADER
 ***  The Database Update Framework (DUF) DATABASE DIFFERENCES REPORT  ***
     
      Date & Time Printed       : ____________________
      FROM Database Filelist.cfg: ________________________________________________________________________________________________________________________
      TO   Database Filelist.cfg: ________________________________________________________________________________________________________________________
/Top
Image 2, TOP
                                                                           Page:___.
/SubHeader
Image 3, SUBHEADER
________ Difference(s) for Table: ____ - ______________________________    
====================================================================================
FROM Database:                                              TO Database:
------------------------------------------------------------------------
/BodyFields
Image 4, BODYFIELDS
Field Number:  ____                                         ____
Name:          ____________________________________________ ____________________________________________
Type:          ____________________________________________ ____________________________________________
Length:        ____                                         ____
Precision:     ____                                         ____
Identity Field:___                                          ___   
/Footer
Image 5, FOOTER
SUMMARY:
====================================================================================
Number of Tables with differences: ____
/*
103952>>>
103952>>>Activate_View Activate_oCompareDatabases for oCompareDatabases
103962>>>>
103962>>>Object oCompareDatabases is a ReportView
103964>>>    Set Location to 6 6
103965>>>    Set Size to 84 181
103966>>>    Set Label to "Compare Databases"
103967>>>
103967>>>    Property String psFilelistFrom
103969>>>    Property String psFilelistTo
103971>>>    Property Integer piDifferences
103973>>>
103973>>>    Object oDestination is a RadioGroup
103975>>>        Set Size to 59 171
103976>>>        Set Location to 5 5
103977>>>        Set Label to "Output Device:"
103978>>>
103978>>>        Object oScreen is a Radio
103980>>>            Set Label to "Screen"
103981>>>            Set Size to 10 39
103982>>>            Set Location to 15 10
103983>>>            Set Status_Help to "Preview the report to screen"
103984>>>        End_Object
103985>>>
103985>>>        Object oPrinter is a Radio
103987>>>            Set Label to "Printer"
103988>>>            Set Size to 10 37
103989>>>            Set Location to 30 10
103990>>>            Set Status_Help to "Send the report to the default printer"
103991>>>        End_Object
103992>>>
103992>>>        Object oFile is a Radio
103994>>>            Set Label to "File"
103995>>>            Set Size to 10 27
103996>>>            Set Location to 42 10
103997>>>            Set Status_Help to "Send the report to a file"
103998>>>        End_Object
103999>>>
103999>>>        Object oFileNameForm is a Form
104001>>>            Set Label to "FileName:"
104002>>>            Set Size to 13 116
104003>>>            Set Location to 40 50
104004>>>            Set Label_Col_Offset to 0
104005>>>            Set Label_Justification_Mode to jMode_Top
104006>>>            Set Prompt_Button_Mode to pb_PromptOn
104007>>>
104007>>>            Procedure Prompt
104010>>>                Boolean bOk
104010>>>                String sFileName sFilePath sDataPath
104010>>>                Integer hoWorkspace
104010>>>
104010>>>                Get Value To sFileName
104011>>>                If (sFileName <> "") Begin
104013>>>                    Set File_Name Of oSaveAsDialog to sFileName
104014>>>                    Get ExtractFilePath sFileName to sFilePath
104015>>>                End
104015>>>>
104015>>>                If (sFilePath = "") Begin
104017>>>                    Get phoWorkspace Of ghoApplication to hoWorkspace
104018>>>                    Get psDataPath Of hoWorkspace to sDataPath
104019>>>                    Get PathAtIndex Of hoWorkspace sDataPath 1 to sFilePath
104020>>>                End
104020>>>>
104020>>>
104020>>>                Set Initial_Folder Of oSaveAsDialog to sFilePath
104021>>>
104021>>>                Get Show_Dialog Of oSaveAsDialog to bOk
104022>>>                If (bOk) Begin
104024>>>                    Get File_Name Of oSaveAsDialog to sFileName
104025>>>                    Set Value To sFileName
104026>>>                End
104026>>>>
104026>>>            End_Procedure
104027>>>
104027>>>        End_Object
104028>>>
104028>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
104031>>>            Forward Send Notify_Select_State iNewItem iOldItem
104033>>>
104033>>>            Case Begin
104033>>>                Case (iNewItem = 0)
104035>>>                    Set Output_Device_Mode to PRINT_TO_WINDOW
104036>>>                    Case Break
104037>>>                Case (iNewItem = 1)
104040>>>                    Set Output_Device_Mode to PRINT_TO_PRINTER
104041>>>                    Case Break
104042>>>                Case (iNewItem = 2)
104045>>>                    Set Output_Device_Mode to PRINT_TO_FILE
104046>>>                    Case Break
104047>>>            Case End
104047>>>
104047>>>            Set Enabled_State Of oFileNameForm to (iNewItem = 2)
104048>>>        End_Procedure
104049>>>
104049>>>    End_Object
104050>>>
104050>>>    Object oOkButton is a Button
104052>>>        Set Label to "&OK"
104053>>>        Set Location to 66 71
104054>>>        Set Default_State to TRUE
104055>>>
104055>>>        Procedure OnClick
104058>>>            Send StartReport
104059>>>        End_Procedure
104060>>>
104060>>>    End_Object
104061>>>
104061>>>    Object oCancelButton is a Button
104063>>>        Set Label to "&Cancel"
104064>>>        Set Location to 66 126
104065>>>
104065>>>        Procedure OnClick
104068>>>            Send Request_Cancel
104069>>>        End_Procedure
104070>>>
104070>>>    End_Object
104071>>>
104071>>>    Object oSaveAsDialog is a SaveAsDialog
104073>>>    End_Object
104074>>>
104074>>>    Procedure StartReport
104077>>>        Integer iOutputDevice
104077>>>        Handle hoWorkspace
104077>>>        String sFileName sCurrentDirectory sDataPath
104077>>>
104077>>>        Get Output_Device_Mode to iOutputDevice
104078>>>
104078>>>        Case Begin
104078>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
104080>>>                Get_Current_Directory to sCurrentDirectory
104081>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
104082>>>                Get psDataPath Of hoWorkspace to sDataPath
104083>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
104084>>>                Set_Directory sDataPath
104085>>>                Make_Temp_File "TXT" sFileName
104086>>>                Set_Directory sCurrentDirectory
104087>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
104089>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
104090>>>                End
104090>>>>
104090>>>                Move (sDataPath - sFileName) to sFileName
104091>>>                Set Output_Device_Name to sFileName
104092>>>                Case Break
104093>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
104096>>>                Set Output_Device_Name to "WinLST:"
104097>>>                Case Break
104098>>>            Case (iOutputDevice = PRINT_TO_FILE)
104101>>>                Get Value Of oFileNameForm to sFileName
104102>>>                Set Output_Device_Name to sFileName
104103>>>                Case Break
104104>>>        Case End
104104>>>
104104>>>        Send Run_Report
104105>>>
104105>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
104107>>>            //Runprogram Background "NotePad" sFileName
104107>>>            Runprogram Shell Background sFileName
104108>>>            EraseFile sFileName
104109>>>>
104109>>>        End
104109>>>>
104109>>>    End_Procedure
104110>>>
104110>>>    Object oBasicReport is a BasicReport
104112>>>
104112>>>        Function Starting_Main_Report Returns Integer
104115>>>            Integer iRetval
104115>>>
104115>>>            Forward Get Starting_Main_Report to iRetval
104117>>>
104117>>>            Function_Return iRetval
104118>>>        End_Function
104119>>>
104119>>>        Procedure_Section Report_Header as Header
104124>>>            DateTime dtCreationTime
104124>>>            String sFilelistFrom sFilelistTo
104124>>>
104124>>>            Get psFilelistFrom to sFilelistFrom
104125>>>            Get psFilelistTo   to sFilelistTo
104126>>>            Move (CurrentDateTime()) to dtCreationTime
104127>>>
104127>>>            Print sFilelistFrom
104128>>>            Print sFilelistTo
104129>>>            Print dtCreationTime
104130>>>            Output_PageCheck Header
104131>>>        End_Procedure
104132>>>
104132>>>        Procedure_Section Page_Top as Top
104137>>>            Integer iPage
104137>>>
104137>>>            Get Page_Count to iPage
104138>>>            Print iPage
104139>>>            OutPut_PageCheck
104140>>>        End_Procedure
104141>>>
104141>>>        Procedure_Section SubHeaderFields as SubHeader
104146>>>            Print "Field"
104147>>>            Print "Table#"
104148>>>            Print "Table Name"
104149>>>        End_Procedure
104150>>>
104150>>>        Procedure_Section Body as BodyFields
104155>>>            Forward Send Body
104157>>>            // Print File.Field // Gets printed at BodySection.1
104157>>>            // Print Variable // Gets printed at BodySection.2
104157>>>            // Output_PageCheck // Without this nothing gets printed
104157>>>        End_Procedure
104158>>>
104158>>>//        Procedure_Section Page_Bottom as FooterSection
104158>>>//            Forward Send Page_Bottom
104158>>>//            // Output_PageCheck // Without this nothing gets printed
104158>>>//        End_Procedure
104158>>>
104158>>>        Procedure_Section Total as Footer
104163>>>            Integer iDifferences
104163>>>            Get piDifferences to iDifferences
104164>>>            Print iDifferences
104165>>>        End_Procedure
104166>>>
104166>>>    End_Object
104167>>>
104167>>>    On_Key Key_Alt+Key_O Send KeyAction of oOkButton
104168>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancelButton
104169>>>
104169>>>End_Object
104170>        Procedure Activate_About
104173>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator64x64.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
104174>        End_Procedure
104175>
104175>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
104176>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
104177>    End_Object
104178>
104178>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
104178>    // in the oHtmlHelp object, so we need to explitetly send the message
104178>    // to that object.
104178>    Procedure ShowProgramHelp
104181>        Set psHelpFile of ghoApplication to "Developer5.chm"
104182>        Send DoDisplayKeyword of oHtmlHelp "DUF Code Generator"
104183>    End_Procedure
104184>
104184>    Procedure ActivateCompareView
104187>        Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
104188>    End_Procedure
104189>
104189>    Procedure ActivateGenerateView
104192>        Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
104193>    End_Procedure
104194>
104194>    On_Key Key_Alt+Key_D   Send ActivateCompareView
104195>    On_Key Key_Ctrl+Key_D  Send ActivateCompareView
104196>    On_Key Key_Alt+Key_G   Send ActivateGenerateView
104197>    On_Key Key_Ctrl+Key_G  Send ActivateGenerateView    
104198>    On_Key Key_F1          Send ShowProgramHelp
104199>End_Object
104200>
104200>Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
104201>Start_UI
104202>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 54583
Total Resources: 6
Total Commands : 104201
Total Windows  : 20
Total Pages    : 5
Static Data    : 846625
Message area   : 668002
Total Blocks   : 37484
